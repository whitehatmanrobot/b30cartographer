 ABOVE TWO PATCHES ARE FIXED BY THE GRTAB.SAL MODULE, AT THE VERY BEGINNING.

;THIS NEXT ONE BYTE FIELD SHOULD BE KEPT AS THE BYTE JUST PREVIOUS TO THE
;INTERRUPT HANDLER ENTRY POINT AT "HANDLER".
		    PUBLIC MPEXNUM
MPEXNUM 	    DB	MY_MULTIPLEX_NUMBER ;PATCHING THIS ONE BYTE WILL CHANGE FOR ALL THE VALUE
		    HEADER <MULTIPLEXOR INTERRUPT HANDLER>
;CONDITIONS OF REGS AT ENTRY TO HANDLER:
;INPUT: AH = MULTIPLEXOR NUMBER.  I DO NOTHING IF THIS IS NOT MY OWN.
;	AL = FUNCTION REQUEST.	THERE ARE TWO FUNCTIONS RECOGNIZED:
;		   0 = "GET INSTALLED STATE"
;		   1 = "WHERE ARE YOU?"
;			AND DS:BX POINTS TO VECTOR TO RECEIVE POINTER
;			TO THE PREVIOUSLY INSTALLED GRAFTABL TABLE.
;		   IF FUNCTION REQUEST IS NOT '1', IT IS ASSUMED TO BE '0'.

		    PUBLIC HANDLER
HANDLER 	    PROC FAR		;INTERRUPT HANDLER ENTRY POINT
; $SALUT (4,3,9,41)
  PATHLABL GRTABHAN			;AN006;
  CMP	AH,MPEXNUM			;IS THIS MULTIPLEXOR REQUEST IS FOR ME?
; $IF	E				;IF MY MULTIPLEX NUMBER IS CALLED
  JNE $$IF1
      CMP   AL,RES_FUNC 		;IF IN RANGE F8-FF, DO NOTHING, JUST RETURN
;     $IF   B
      JNB $$IF2
	  CMP	AL,WHERE_R_U		;IF REQUEST FOR "WHERE ARE YOU?"
;	  $IF	E
	  JNE $$IF3
					;FOR THIS REQUEST, DS:BX POINTS TO A VECTOR
					; WHICH IS TO RECEIVE THE POINTER TO
					; WHERE THE ORIGINAL TABLE WAS LOADED

					;PASS OFFSET OF WHERE TABLE IS
	      MOV   [BX].VECOFF,PATCHED ; TO FIRST WORD OF RESPONSE AREA
PATCH_OFF     EQU   WORD PTR $-2	;THE ACTUAL VALUE OF THE IMMEDIATE IS PATCHED IN

					;PASS SEGID OF WHERE TABLE IS
	      MOV   [BX].VECSEG,PATCHED ; TO SECOND WORD OF RESPONSE AREA
PATCH_SEG     EQU   WORD PTR $-2	;THE ACTUAL VALUE OF THE IMMEDIATE IS PATCHED IN
;	  $ENDIF
$$IF3:
	  MOV	AL,INSTALLED		;SAY "INSTALLED"
;     $ENDIF
$$IF2:
      IRET				;RETURN TO INTERRUPT INVOKER
; $ENDIF
$$IF1:
;SINCE THE MULTIPLEX NUMBER IS FOR SOMEBODY ELSE, PASS THE CALL ON TO PREVIOUS OWNER
JMPREV: 				;REFERENCED WHEN PATCHING OUT "DUMMY"
  JMP	DUMMY				;CHAIN ON TO THE PREVIOUS OWNER
					; OF THE VECTOR AT 1FH*4.
					; USAGE OF "DUMMY" HERE IS JUST A PLACE-HLDER
					; WHICH WILL BE REPLACED DURING EXECUTION OF LOADER
  PATHLABL GRTABHAN			;AN006;
;=================================================================
  HEADER <POINTERS TO PREVIOUS OWNER, INSTRUCTION MODIFICATION>
;	     $SALUT (4,14,20,41)
PREV_OWN     EQU   DWORD PTR JMPREV+1	;REFERENCED DURING REPLACEMENT OF "HANDLER"
					; IN THE ABOVE JMP INSTRUCTION
HANDLER      ENDP
	     IF    ($-CSEG) MOD 16	;IF NOT ALREADY ON 16 BYTE BOUNDARY
		 ORG   ($-CSEG)+16-(($-CSEG) MOD 16) ;ADD PADDING TO GET TO 16 BYTE BOUNDARY
	     ENDIF
HANDLER_SIZE EQU   ($-CSEG)-(END_PSP-CSEG) ;MARK THE END OF RESIDENT EXECUTABLE ;AN000;
	     PUBLIC HANDLER_SIZE	; PORTION, NOT INCLUDING THE PSP	;AN000;
CSEG	     ENDS
	     END   END_PSP

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabno.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;A2
	TITLE	GRTABNO - NORDIC CHARACTER SET FOR GRAFTABL COMMAND
;This module is to be linked with the OBJ of GRTAB.SAL.  Refer to the
;Prolog of that module for more complete description.

;This module contains the binary description of the pixels that are used
;in graphics mode to define the Nordic character set when loaded to
;interrupt 1FH by the GRAFTABL command in DOS 3.3.
	IF1
	    %OUT    GRTABNO.ASM...
	ELSE
;    %OUT GRTABNO.ASM...
	ENDIF
CSEG	SEGMENT PARA PUBLIC
TABLENO EQU	THIS BYTE
	PUBLIC	TABLENO

;(note: the display of the character to the right of the decimal number
;value of this location is not necessarily the graphic that these pixels
;will produce.	The displayed character is from the USA character set, and
;does not represent the language character set generated by this table.)

;These fonts are as defined in the Nordic Code Page = 865.

	DB	00111100B		;128 
	DB	01100110B
	DB	01100000B
	DB	01100110B
	DB	00111100B
	DB	00001100B
	DB	00000110B
	DB	00111100B
;
	DB	00000000B		;129 
	DB	01100110B
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
.XLIST
;
	DB	00001110B		;130 
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;
	DB	01111110B		;131 
	DB	11000011B
	DB	00111100B
	DB	00000110B
	DB	00111110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	01100110B		;132 
	DB	00000000B
	DB	00111100B
	DB	00000110B
	DB	00111110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	01110000B		;133 
	DB	00000000B
	DB	00111100B
	DB	00000110B
	DB	00111110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	00011000B		;134 
	DB	00011000B
	DB	00111100B
	DB	00000110B
	DB	00111110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	00000000B		;135 
	DB	00000000B
	DB	00111100B
	DB	01100000B
	DB	01100000B
	DB	00111100B
	DB	00000110B
	DB	00011100B
;
	DB	01111110B		;136 
	DB	11000011B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;
	DB	01100110B		;137 
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;
	DB	01110000B		;138 
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;
	DB	01100110B		;139 
	DB	00000000B
	DB	00111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;
	DB	01111100B		;140 
	DB	11000110B
	DB	00111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;
	DB	01110000B		;141 
	DB	00000000B
	DB	00111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;
	DB	01100011B		;142 
	DB	00011100B
	DB	00110110B
	DB	01100011B
	DB	01111111B
	DB	01100011B
	DB	01100011B
	DB	00000000B
;
	DB	00011000B		;143 
	DB	00011000B
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100110B
	DB	00000000B
;
	DB	00001110B		;144 
	DB	00000000B
	DB	01111110B
	DB	00110000B
	DB	00111100B
	DB	00110000B
	DB	01111110B
	DB	00000000B
;
	DB	00000000B		;145 
	DB	00000000B
	DB	01111111B
	DB	00001100B
	DB	01111111B
	DB	11001100B
	DB	01111111B
	DB	00000000B
;
	DB	00011111B		;146 
	DB	00110110B
	DB	01100110B
	DB	01111111B
	DB	01100110B
	DB	01100110B
	DB	01100111B
	DB	00000000B
;
	DB	00111100B		;147 
	DB	01100110B
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00000000B
;
	DB	00000000B		;148 
	DB	01100110B
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00000000B
;
	DB	00000000B		;149 
	DB	01110000B
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00000000B
;
	DB	00111100B		;150 
	DB	01100110B
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	00000000B		;151 
	DB	01110000B
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	00000000B		;152 
	DB	01100110B
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	00111110B
	DB	00000110B
	DB	01111100B
;
	DB	11000011B		;153 
	DB	00011000B
	DB	00111100B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00011000B
	DB	00000000B
;
	DB	01100110B		;154 
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00000000B
;
	DB	00000000B		;155 	  *
	DB	00000000B
	DB	00000000B
	DB	00111100B
	DB	01101110B
	DB	01110110B
	DB	00111100B
	DB	00000000B
;
	DB	00011100B		;156 
	DB	00110110B
	DB	00110010B
	DB	01111000B
	DB	00110000B
	DB	01110011B
	DB	01111110B
	DB	00000000B
;
	DB	01111100B		;157 	  *
	DB	11000110B
	DB	11001110B
	DB	11011110B
	DB	11110110B
	DB	11100110B
	DB	01111100B
	DB	00000000B
;
	DB	11111000B		;158   
	DB	11001100B
	DB	11001100B
	DB	11111010B
	DB	11000110B
	DB	11001111B
	DB	11000110B
	DB	11000111B
;
	DB	00001110B		;159   
	DB	00011011B
	DB	00011000B
	DB	00111100B
	DB	00011000B
	DB	00011000B
	DB	11011000B
	DB	01110000B
;
	DB	00001110B		;160 
	DB	00000000B
	DB	00111100B
	DB	00000110B
	DB	00111110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	00011100B		;161 
	DB	00000000B
	DB	00111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;
	DB	00000000B		;162 
	DB	00001110B
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00000000B
;
	DB	00000000B		;163 
	DB	00001110B
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;
	DB	00000000B		;164 
	DB	01111100B
	DB	00000000B
	DB	01111100B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	00000000B
;
	DB	01111110B		;165 
	DB	00000000B
	DB	01100110B
	DB	01110110B
	DB	01111110B
	DB	01101110B
	DB	01100110B
	DB	00000000B
;
	DB	00111100B		;166   
	DB	01101100B
	DB	01101100B
	DB	00111110B
	DB	00000000B
	DB	01111110B
	DB	00000000B
	DB	00000000B
;
	DB	00111000B		;167   
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
	DB	01111100B
	DB	00000000B
	DB	00000000B
;
	DB	00011000B		;168 
	DB	00000000B
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	01100110B
	DB	00111100B
	DB	00000000B
;
	DB	00000000B		;169   
	DB	00000000B
	DB	00000000B
	DB	11111100B
	DB	11000000B
	DB	11000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;170   
	DB	00000000B
	DB	00000000B
	DB	11111100B
	DB	00001100B
	DB	00001100B
	DB	00000000B
	DB	00000000B
;
	DB	11000011B		;171   
	DB	11000110B
	DB	11001100B
	DB	11011110B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	00001111B
;
	DB	11000011B		;172   
	DB	11000110B
	DB	11001100B
	DB	11011011B
	DB	00110111B
	DB	01101111B
	DB	11001111B
	DB	00000011B
;
	DB	00011000B		;173 
	DB	00011000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
;
	DB	00000000B		;174   
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	01100110B
	DB	00110011B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;175 	  *
	DB	11000110B
	DB	01111100B
	DB	11000110B
	DB	11000110B
	DB	01111100B
	DB	11000110B
	DB	00000000B
;
	DB	00100010B		;176 
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
;
	DB	01010101B		;177 
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
;
	DB	11011011B		;178 
	DB	01110111B
	DB	11011011B
	DB	11101110B
	DB	11011011B
	DB	01110111B
	DB	11011011B
	DB	11101110B
;
	DB	00011000B		;179 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00011000B		;180 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00011000B		;181 
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00110110B		;182 
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00000000B		;183 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00000000B		;184 
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00110110B		;185 
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00110110B		;186 
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00000000B		;187 
	DB	00000000B
	DB	11111110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00110110B		;188 
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00110110B		;189 
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00011000B		;190 
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;191 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00011000B		;192 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00011000B		;193 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;194 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00011000B		;195 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00000000B		;196 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00011000B		;197 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00011000B		;198 
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00110110B		;199 
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00110110B		;200 
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;201 
	DB	00000000B
	DB	00111111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00110110B		;202 
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;203 
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00110110B		;204 
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00000000B		;205 
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00110110B		;206 
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00011000B		;207 
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00110110B		;208 
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;209 
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00000000B		;210 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00110110B		;211 
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00011000B		;212 
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;213 
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00000000B		;214 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00110110B		;215 
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;
	DB	00011000B		;216 
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00011000B		;217 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;218 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	11111111B		;219 
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
;
	DB	00000000B		;220 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
;
	DB	11110000B		;221 
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
;
	DB	00001111B		;222 
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
;
	DB	11111111B		;223 
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;224 
	DB	00000000B
	DB	00111011B
	DB	01101110B
	DB	01100100B
	DB	01101110B
	DB	00111011B
	DB	00000000B
;
	DB	00000000B		;225 
	DB	00111100B
	DB	01100110B
	DB	01111100B
	DB	01100110B
	DB	01111100B
	DB	01100000B
	DB	01100000B
;
	DB	00000000B		;226 
	DB	01111110B
	DB	01100110B
	DB	01100000B
	DB	01100000B
	DB	01100000B
	DB	01100000B
	DB	00000000B
;
	DB	00000000B		;227 
	DB	01111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00000000B
;
	DB	01111110B		;228 
	DB	01100110B
	DB	00110000B
	DB	00011000B
	DB	00110000B
	DB	01100110B
	DB	01111110B
	DB	00000000B
;
	DB	00000000B		;229 
	DB	00000000B
	DB	00111111B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
;
	DB	00000000B		;230 
	DB	00110011B
	DB	00110011B
	DB	00110011B
	DB	00110011B
	DB	00111110B
	DB	00110000B
	DB	01100000B
;
	DB	00000000B		;231 
	DB	00111011B
	DB	01101110B
	DB	00001100B
	DB	00001100B
	DB	00001100B
	DB	00001100B
	DB	00000000B
;
	DB	01111110B		;232 
	DB	00011000B
	DB	00111100B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00011000B
	DB	01111110B
;
	DB	00011100B		;233 
	DB	00110110B
	DB	01100011B
	DB	01111111B
	DB	01100011B
	DB	00110110B
	DB	00011100B
	DB	00000000B
;
	DB	00011100B		;234 
	DB	00110110B
	DB	01100011B
	DB	01100011B
	DB	00110110B
	DB	00110110B
	DB	01110111B
	DB	00000000B
;
	DB	00001110B		;235 
	DB	00011000B
	DB	00001100B
	DB	00111110B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00000000B
;
	DB	00000000B		;236 
	DB	00000000B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	00000000B
	DB	00000000B
;
	DB	00000110B		;237 
	DB	00001100B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	01100000B
	DB	11000000B
;
	DB	00011100B		;238 
	DB	01100000B
	DB	11000000B
	DB	11111100B
	DB	11000000B
	DB	01100000B
	DB	00011100B
	DB	00000000B
;
	DB	00111100B		;239 
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	00000000B
;
	DB	00000000B		;240 
	DB	01111110B
	DB	00000000B
	DB	01111110B
	DB	00000000B
	DB	01111110B
	DB	00000000B
	DB	00000000B
;
	DB	00011000B		;241 
	DB	00011000B
	DB	01111110B
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	01111110B
	DB	00000000B
;
	DB	00110000B		;242 
	DB	00011000B
	DB	00001100B
	DB	00011000B
	DB	00110000B
	DB	00000000B
	DB	01111110B
	DB	00000000B
;
	DB	00001100B		;243 
	DB	00011000B
	DB	00110000B
	DB	00011000B
	DB	00001100B
	DB	00000000B
	DB	01111110B
	DB	00000000B
;
	DB	00001110B		;244 
	DB	00011011B
	DB	00011011B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;
	DB	00011000B		;245 
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11011000B
	DB	11011000B
	DB	01110000B
;
	DB	00011000B		;246 
	DB	00011000B
	DB	00000000B
	DB	01111110B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
;
	DB	00000000B		;247 
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	00000000B
;
	DB	00111000B		;248 
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;249 
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;250 
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	00001111B		;251 
	DB	00001100B
	DB	00001100B
	DB	00001100B
	DB	11101100B
	DB	01101100B
	DB	00111100B
	DB	00011100B
;
	DB	01111000B		;252 
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DB	01110000B		;253 
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	01111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
.LIST
;
	DB	00000000B		;254 
	DB	00000000B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00000000B
	DB	00000000B
;
	DB	00000000B		;255
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DW	865			;TABLE ID
;	include graftnom.inc
	DB	"Nordic",0		;LANGUAGE NAME, IN ASCIIZ FORMAT
;(the above "DB" is an example of the ENGLISH version of the above include file)
	IF	($-CSEG) MOD 16 	;IF NOT ALREADY ON 16 BYTE BOUNDARY
	    DB	    (16-(($-CSEG) MOD 16)) DUP(0) ;ADD PADDING TO GET TO 16 BYTE BOUNDARY
	ENDIF
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabms.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
;:util GRAFTABL 	    ;utility name					;AN000;
;:class 1		    ;DOS extended errors:
;:class 2		    ;parse errors:
;1  Too many parameters
;2  Required parameter missing
;3  Invalid switch
;4  Invalid keyword
;5  Parameter value not in allowed range
;6  Parameter value not allowed    [parse ret codes 6 and 7]
;7   (undefined)
;8  Parameter format not correct
;9   (undefined)
;10 Invalid parameter		   [no corresponding parse ret code]
;11 Invalid parameter combination  [no corresponding parse ret code]
;;
;:class A		    ;system messages
;:use 1 COMMON1 	    ;MSG 1 is always "Incorrect DOS version"
;;
;;In these next 2 messages, %1 will be replaced with one from list, 4-5,
;; or with one entry of the list at "CPID". (see GRTABMS.INC)
;;
;:def 2 "Active Code Page: %1",CR,LF
;:def 3 "Previous Code Page: %1",CR,LF

;:def 4 "None",NULL
;:def 5 "Non-standard",NULL
;
;:end
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

;THIS MODULE IS INCLUDED IN GRTABSM.SAL.
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
SUBLIST_PARSE  SUBLIST <,,FILL_OFF,FILL_SEG,PC_ID_0,SF_BITS <SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1,PAD_BLK> ;AN003;
	PUBLIC SUBLIST_PARSE	   ;AN003;

;		THE NEXT GROUP ARE ADDITIONAL CLASS "A" MESSAGES
;		SPECIFICALLY DEFINED FOR THE GRAFTABL UTILITY
MSGNUM_ACTIVE  MSG_DESC <2,,SLIST_23,ONE_SUBS> ;AN000;"Active Code Page: %1",CR,LF
	       PUBLIC MSGNUM_ACTIVE						;AN000;

MSGNUM_PREVIOUS MSG_DESC <3,,SLIST_23,ONE_SUBS> ;AN000;"Previous Code Page: %1",CR,LF
	       PUBLIC MSGNUM_PREVIOUS						;AN000;

;BEFORE USING THE NEXT SUBLIST, THE SEG ID OF CPID
;(OR OF "NONE" OR "NON-STANDARD") MUST BE FILLED IN
;SINCE COM FILE CANNOT HAVE SEGMENT FIXUP.

;THIS NEXT SUBLIST IS USED BOTH MY MESSAGE 2 AND MESSAGE 3.

SLIST_23 SUBLIST <,,,,PC_ID_1,SF_BITS <SF_LEFT,,SF_ASCIIZ,SF_CHAR>,MAX_0,MIN_1,PAD_BLK> ;AN000;
	       PUBLIC SLIST_23							;AN000;
;NOTE: IN THE ABOVE SUBLIST, ID=1, THE VECTOR POINTING TO THE MSG NO. 2-3.
;  WILL NEED TO BE PUT INTO THE SUBLIST DURING MESSAGES INITIALIZATION.
;  TO SELECT "None" OR "Non Standard", OR TO POINT TO ELEMENT OF "CPID".

	       PUBLIC CPID,CPID_L						;AN000;
CPID DB "437",NULL                                                              ;AN000;
CPID_L EQU $-CPID ;AN000;NUMBER OF CHARS IN CPID
     DB "850",NULL								;AN000;
     DB "860",NULL                                                              ;AN000;
     DB "863",NULL                                                              ;AN000;
     DB "865",NULL                                                              ;AN000;
     DB "852",NULL

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
MSGNUM_NONE MSG_DESC <4> ;AN000;"None",NULL
		PUBLIC MSGNUM_NONE						;AN000;

MSGNUM_NSTD MSG_DESC <5> ;AN000;"Non-Standard",NULL
		PUBLIC MSGNUM_NSTD						;AN000;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

;CR,LF,"DOS command line parameters supported:",CR,LF,LF                        ;AN000;
;"    /STA - Request Status only",CR,LF                                         ;AN000;
;"    /?    - Display this summary of parameters",CR,LF 			;AN000;
;"    Code Pages available:",CR,LF
;"    437  - USA Graphic Character Set",CR,LF                                   ;AN000;
;"    850  - Multi-lingual Graphic Character Set",CR,LF 			;AN000;
;"    860  - Portuguese Graphic Character Set",CR,LF				;AN000;
;"    863  - Canadian French Graphic Character Set",CR,LF                       ;AN000;
;"    865  - Nordic Graphic Character Set",CR,LF                                ;AN000;
;"    852  - Latin II Graphic Character Set",CR,LF				;AN000;

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     303
		PUBLIC	MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST

MSGNUM_HELP_OPTIONS	MSG_DESC <MSG_OPTIONS_FIRST>
		PUBLIC	MSGNUM_HELP_OPTIONS

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;end of GRTABMS.INC

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabp.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;AN000;A2
	TITLE	GRTABP.SAL - GRAFTABL SYSTEM COMMAND LINE PARSER ;AN000;
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: GRTABP.SAL
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of GRAFTABL.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;	   The segment registers are ASSUMED according to the type .COM.
;	   The Common PARSER is then INCLUDEd.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.ASM statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.ASM statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.ASM)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT GRTABP,NUL,;
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 GRTAB.SAL.
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;AN000;
	    ; %OUT    COMPONENT=GRAFTABL, MODULE=GRTABP.SAL... ;AN000;
	ENDIF				;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<MACRO DEFINITION>	;AN000;
	INCLUDE PATHMAC.INC		;AN006;
; =  =	=  =  =  =  =  =  =  =	=  =

HEADER	MACRO	TEXT			;;AN000;
.XLIST					;AN000;
	SUBTTL	TEXT			;AN000;
.LIST					;AN000;
	PAGE				;AN000;
	ENDM				;;AN000;

; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<SYSPARSE - SYSTEM COMMAND LINE PARSER> ;AN000;
CSEG	SEGMENT PARA PUBLIC		;AN000;
	ASSUME	CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;

FARSW	EQU	0			;AN000;CALL THE PARSER BY NEAR CALL
DATESW	EQU	0			;AN000;SUPPRESS DATE CHECKING
TIMESW	EQU	0			;AN000;SUPPRESS TIME CHECKING
FILESW	EQU	0			;AN000;SUPPRESS CHECKING FILE SPECIFICATION
CAPSW	EQU	0			;AN000;SUPPRESS FILE TABLE CAPS
CMPXSW	EQU	0			;AN000;SUPPRESS CHECKING COMPLEX LIST
DRVSW	EQU	0			;AN000;SUPPRESS SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;AN000;SUPPRESS SUPPORT OF QUOTED STRING FORMAT
NUMSW	EQU	0			;AN000;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;AN000;SUPPRESS KEYWORD SUPPORT
SWSW	EQU	1			;AN000;DO SUPPORT SWITCHES
VAL1SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 1
VAL2SW	EQU	0			;AN000;SUPPRESS SUPPORT OF VALUE DEFINITION 2
VAL3SW	EQU	1			;AN000;DO SUPPORT VALUE DEFINITION 3
BASESW	EQU	1			;AN005;SPECIFY, PSDATA POINTED TO BY "DS"
INCSW	EQU	0			;AN006;DO NOT INCLUDE PSDATA.INC


;	INCLUDE PSDATA.INC		;AN006; WORK AREA FOR PARSER
.XLIST					;AN000;
.XCREF					;AN000;
	include version.inc
	INCLUDE PSDATA.INC		;AN006; WORK AREA FOR PARSER
.LIST					;AN000;
.CREF					;AN000;
	PATHLABL GRTABP 		;AN006;

	PUBLIC	SYSPARSE		;AN000;SUBROUTINE ENTRY POINT

;	INCLUDE PARSE.ASM		;GENERATED CODE SUPPRESSED FROM LISTING ;AN000;
.XLIST					;AN000;
.XCREF					;AN000;
	INCLUDE PARSE.ASM		;AN000;
.LIST					;AN000;
.CREF					;AN000;
	PATHLABL GRTABP 		;AN006;
CSEG	ENDS				;AN000;
	END				;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabpo.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;A2
	TITLE	GRTABPO - PORTUGUESE CHARACTER SET FOR GRAFTABL COMMAND
;This module is to be linked with the OBJ of GRTAB.SAL.  Refer to the
;Prolog of that module for more complete description.

;This module contains the binary description of the pixels that are used
;in graphics mode to define the Portuguese character set when loaded to
;interrupt 1FH by the GRAFTABL command in DOS 3.3.
	IF1
	    %OUT    GRTABPO.ASM...
	ELSE
;    %OUT GRTABPO.ASM...
	ENDIF
CSEG	SEGMENT PARA PUBLIC
TABLEPO EQU	THIS BYTE
	PUBLIC	TABLEPO

;(note: the display of the character to the right of the decimal number
;value of this location is not necessarily the graphic that these pixels
;will produce.	The displayed character is from the USA character set, and
;does not represent the language character set generated by this table.)

;These fonts are as defined in the Portugal Code Page = 860.

;			      128   
	DB	01111000B
	DB	11001100B
	DB	11000000B
	DB	11001100B
	DB	01111000B
	DB	00011000B
	DB	00001100B
	DB	01111000B

;			      129   
	DB	00000000B
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01110110B
	DB	00000000B
.XLIST

;			      130   
	DB	00011100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11000000B
	DB	01111000B
	DB	00000000B

;			      131   
	DB	01111110B
	DB	10000001B
	DB	00111100B
	DB	00000110B
	DB	00111110B
	DB	01100110B
	DB	00111011B
	DB	00000000B

;			      132   
	DB	01110010B
	DB	10001100B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01110110B
	DB	00000000B

;			      133   
	DB	11100000B
	DB	00000000B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01110110B
	DB	00000000B

;			      134   
	DB	00011100B
	DB	00000000B
	DB	00110000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11001100B
	DB	00000000B

;			      135   
	DB	00000000B
	DB	00000000B
	DB	01111000B
	DB	11000000B
	DB	11000000B
	DB	01111100B
	DB	00011000B
	DB	00111000B

;			      136   
	DB	01111110B
	DB	10000001B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B

;			      137   
	DB	01111110B
	DB	10000001B
	DB	01111110B
	DB	00110000B
	DB	00111100B
	DB	00110000B
	DB	01111110B
	DB	00000000B

;			      138   
	DB	11100000B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11000000B
	DB	01111000B
	DB	00000000B

;			      139   
	DB	00011100B
	DB	00000000B
	DB	01111000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B

;			      140   
	DB	01111100B
	DB	10000010B
	DB	00000000B
	DB	01111100B
	DB	11000110B
	DB	11000110B
	DB	01111100B
	DB	00000000B

;			      141   
	DB	11100000B
	DB	00000000B
	DB	01110000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B

;			      142   
	DB	01110110B
	DB	11011100B
	DB	00110000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11001100B
	DB	00000000B

;			      143   
	DB	01111000B
	DB	10000100B
	DB	00110000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11001100B
	DB	00000000B

;			      144   
	DB	00011100B
	DB	00000000B
	DB	11111100B
	DB	01100000B
	DB	01111000B
	DB	01100000B
	DB	11111100B
	DB	00000000B

;			      145   
	DB	11100000B
	DB	00000000B
	DB	00110000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11001100B
	DB	00000000B

;			      146   
	DB	11100000B
	DB	00000000B
	DB	11111100B
	DB	01100000B
	DB	01111000B
	DB	01100000B
	DB	11111100B
	DB	00000000B

;			      147   
	DB	01111000B
	DB	11001100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      148   
	DB	01101100B
	DB	11011000B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      149   
	DB	00000000B
	DB	11100000B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      150   
	DB	00011100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      151   
	DB	00000000B
	DB	11100000B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01110110B
	DB	00000000B

;			      152   
	DB	11100000B
	DB	00000000B
	DB	01111000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B

;			      153   
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	01111100B
	DB	11000110B
	DB	11000110B
	DB	01111100B
	DB	00000000B

;			      154   
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      155   
	DB	00011000B
	DB	00011000B
	DB	01111110B
	DB	11000000B
	DB	11000000B
	DB	01111110B
	DB	00011000B
	DB	00011000B

;			      156   
	DB	00111000B
	DB	01101100B
	DB	01100100B
	DB	11110000B
	DB	01100000B
	DB	11100110B
	DB	11111100B
	DB	00000000B

;			      157   	 *
	DB	11100000B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      158   
	DB	11111000B
	DB	11001100B
	DB	11001100B
	DB	11111010B
	DB	11000110B
	DB	11001111B
	DB	11000110B
	DB	11000111B

;			      159   	 *
	DB	00011110B
	DB	00000000B
	DB	00000000B
	DB	01111100B
	DB	11000110B
	DB	11000110B
	DB	01111100B
	DB	00000000B

;			      160   
	DB	00011100B
	DB	00000000B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01110110B
	DB	00000000B

;			      161   
	DB	00011100B
	DB	00000000B
	DB	01110000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B

;			      162   
	DB	00000000B
	DB	00011100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      163   
	DB	00000000B
	DB	00011100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01110110B
	DB	00000000B

;			      164   
	DB	00000000B
	DB	11111000B
	DB	00000000B
	DB	11111000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	00000000B

;			      165   
	DB	11111100B
	DB	00000000B
	DB	11001100B
	DB	11101100B
	DB	11111100B
	DB	11011100B
	DB	11001100B
	DB	00000000B

;			      166   
	DB	00111100B
	DB	01101100B
	DB	01101100B
	DB	00111110B
	DB	00000000B
	DB	01111110B
	DB	00000000B
	DB	00000000B

;			      167   
	DB	00111000B
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
	DB	01111100B
	DB	00000000B
	DB	00000000B

;			      168   
	DB	00110000B
	DB	00000000B
	DB	00110000B
	DB	01100000B
	DB	11000000B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      169   	 *
	DB	11110000B
	DB	00000000B
	DB	00000000B
	DB	01111100B
	DB	11000110B
	DB	11000110B
	DB	01111100B
	DB	00000000B

;			      170   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111100B
	DB	00001100B
	DB	00001100B
	DB	00000000B
	DB	00000000B

;			      171   
	DB	11000011B
	DB	11000110B
	DB	11001100B
	DB	11011110B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	00001111B

;			      172   
	DB	11000011B
	DB	11000110B
	DB	11001100B
	DB	11011011B
	DB	00110111B
	DB	01101111B
	DB	11001111B
	DB	00000011B

;			      173   
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00000000B

;			      174   
	DB	00000000B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	01100110B
	DB	00110011B
	DB	00000000B
	DB	00000000B

;			      175   
	DB	00000000B
	DB	11001100B
	DB	01100110B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	00000000B
	DB	00000000B

;			      176   
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B

;			      177   
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B

;			      178   
	DB	11011011B
	DB	01110111B
	DB	11011011B
	DB	11101110B
	DB	11011011B
	DB	01110111B
	DB	11011011B
	DB	11101110B

;			      179   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      180   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      181   
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      182   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      183   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      184   
	DB	00000000B
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      185   
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      186   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      187   
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      188   
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      189   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      190   
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      191   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      192   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      193   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      194   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      195   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      196   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      197   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      198   
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      199   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      200   
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      201   
	DB	00000000B
	DB	00000000B
	DB	00111111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      202   
	DB	00110110B
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      203   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      204   
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      205   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      206   
	DB	00110110B
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      207   
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      208   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      209   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      210   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      211   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      212   
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      213   
	DB	00000000B
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      214   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      215   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B

;			      216   
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      217   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      218   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      219   
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B

;			      220   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B

;			      221   
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B

;			      222   
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B

;			      223   
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      224   
	DB	00000000B
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	11001000B
	DB	11011100B
	DB	01110110B
	DB	00000000B

;			      225   
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111000B
	DB	11001100B
	DB	11111000B
	DB	11000000B
	DB	11000000B

;			      226   
	DB	00000000B
	DB	11111100B
	DB	11001100B
	DB	11000000B
	DB	11000000B
	DB	11000000B
	DB	11000000B
	DB	00000000B

;			      227   
	DB	00000000B
	DB	11111110B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00000000B

;			      228   
	DB	11111100B
	DB	11001100B
	DB	01100000B
	DB	00110000B
	DB	01100000B
	DB	11001100B
	DB	11111100B
	DB	00000000B

;			      229   
	DB	00000000B
	DB	00000000B
	DB	01111110B
	DB	11011000B
	DB	11011000B
	DB	11011000B
	DB	01110000B
	DB	00000000B

;			      230   
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01111100B
	DB	01100000B
	DB	11000000B

;			      231   
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00000000B

;			      232   
	DB	11111100B
	DB	00110000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00110000B
	DB	11111100B

;			      233   
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11111110B
	DB	11000110B
	DB	01101100B
	DB	00111000B
	DB	00000000B

;			      234   
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11000110B
	DB	01101100B
	DB	01101100B
	DB	11101110B
	DB	00000000B

;			      235   
	DB	00011100B
	DB	00110000B
	DB	00011000B
	DB	01111100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B

;			      236   
	DB	00000000B
	DB	00000000B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	00000000B
	DB	00000000B

;			      237   
	DB	00000110B
	DB	00001100B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	01100000B
	DB	11000000B

;			      238   
	DB	00111000B
	DB	01100000B
	DB	11000000B
	DB	11111000B
	DB	11000000B
	DB	01100000B
	DB	00111000B
	DB	00000000B

;			      239   
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	00000000B

;			      240   
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	00000000B

;			      241   
	DB	00110000B
	DB	00110000B
	DB	11111100B
	DB	00110000B
	DB	00110000B
	DB	00000000B
	DB	11111100B
	DB	00000000B

;			      242   
	DB	01100000B
	DB	00110000B
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	00000000B
	DB	11111100B
	DB	00000000B

;			      243   
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	00110000B
	DB	00011000B
	DB	00000000B
	DB	11111100B
	DB	00000000B

;			      244   
	DB	00001110B
	DB	00011011B
	DB	00011011B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B

;			      245   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11011000B
	DB	11011000B
	DB	01110000B

;			      246   
	DB	00110000B
	DB	00110000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	00110000B
	DB	00110000B
	DB	00000000B

;			      247   
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	00000000B

;			      248   
	DB	00111000B
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      249   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      250   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      251   
	DB	00001111B
	DB	00001100B
	DB	00001100B
	DB	00001100B
	DB	11101100B
	DB	01101100B
	DB	00111100B
	DB	00011100B

;			      252   
	DB	01111000B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00000000B
	DB	00000000B
	DB	00000000B

;			      253   
	DB	01110000B
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	01111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
.LIST

;			      254   
	DB	00000000B
	DB	00000000B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00000000B
	DB	00000000B

;			      255   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DW	860			;TABLE ID
;	include graftpom.inc
	DB	"Portuguese",0		;LANGUAGE NAME, IN ASCIIZ FORMAT
;(the above "DB" is an example of the ENGLISH version of the above include file)
	IF	($-CSEG) MOD 16 	;IF NOT ALREADY ON 16 BYTE BOUNDARY
	    DB	    (16-(($-CSEG) MOD 16)) DUP(0) ;ADD PADDING TO GET TO 16 BYTE BOUNDARY
	ENDIF
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabsm.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;AN000;A2
	TITLE	GRTABSM.SAL - GRAFTABL SYSTEM MESSAGES ;AN000;
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: GRTABSM.SAL
;
; DESCRIPTIVE NAME: Include the DOS system MESSAGE HANDLER in the SEGMENT
;		    configuration expected by the modules of GRAFTABL.
;
;FUNCTION: The common code of the DOS SYSTEM MESSAGE HANDLER is made a
;	   part of the GRAFTABL module by using INCLUDE to bring in the
;	   common portion, in SYSMSG.INC.  This included code contains
;	   the routines to initialize for message services, to find
;	   where a particular message is, and to display a message.
;
; ENTRY POINT: SYSDISPMSG:near
;	       SYSGETMSG:near
;	       SYSLOADMSG:near
;
; INPUT:
;    AX = MESSAGE NUMBER
;    BX = HANDLE TO DISPLAY TO (-1 means use DOS functions 1-12)
;    SI = OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
;    CX = NUMBER OF %PARMS, 0 IF NONE
;    DX = CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
;   CALL SYSDISPMSG		;DISPLAY THE MESSAGE

;    If carry set, extended error already called:
;    AX = EXTENDED MESSAGE NUMBER
;    BH = ERROR CLASS
;    BL = SUGGESTED ACTION
;    CH = LOCUS
; _ _ _ _ _ _ _ _ _ _ _ _

;    AX = MESSAGE NUMBER
;    DH = MESSAGE CLASS (1=DOS EXTENDED ERROR, 2=PARSE ERROR, -1=UTILITY MSG)
;   CALL SYSGETMSG		 ;FIND WHERE A MSG IS

;    If carry set, error
;     CX = 0, MESSAGE NOT FOUND
;    If carry NOT set, ok, and resulting regs are:
;     CX = MESSAGE SIZE
;     DS:SI = MESSAGE TEXT
; _ _ _ _ _ _ _ _ _ _ _ _

;   CALL SYSLOADMSG		 ;SET ADDRESSABILITY TO MSGS, CHECK DOS VERSION
;    If carry not set:
;    CX = SIZE OF MSGS LOADED

;    If carry is set, regs preset up for SYSDISPMSG, as:
;    AX = ERROR CODE IF CARRY SET
;	  AX = 1, INCORRECT DOS VERSION
;	  DH =-1, (Utility msg)
;	OR,
;	  AX = 1, Error loading messages
;	  DH = 0, (Message manager error)
;    BX = STDERR
;    CX = NO_REPLACE
;    DL = NO_INPUT
;
; EXIT-NORMAL: CARRY is not set
;
; EXIT-ERROR:  CARRY is set
;	       Call Get Extended Error for reason code, for SYSDISPMSG and
;	       SYSGETMSG.
;
; INTERNAL REFERENCES:
;    ROUTINES: (Generated by the MSG_SERVICES macro)
;	SYSLOADMSG
;	SYSDISPMSG
;	SYSGETMSG
;
;    DATA AREAS:
;	INCLUDE GRTABMS.INC  ;message defining control blocks
;	INCLUDE SYSMSG.INC   ;Permit System Message handler definition
;	INCLUDE COPYRIGH.INC ;Standard copyright notice
;	INCLUDE MSGHAN.INC   ;Defines message control blocks STRUCs
;	INCLUDE VERSIONA.INC ;INCLUDEd by code generated by SYSMSG.INC
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:
;
;		SALUT GRTABSM,NUL,;
;
;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 GRTAB.SAL.
;
;****************** END OF SPECIFICATIONS *****************************

	INCLUDE PATHMAC.INC		;AN006;
;	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;
.XLIST					;AN000;
	INCLUDE SYSMSG.INC		;AN000;PERMIT SYSTEM MESSAGE HANDLER DEFINITION
.LIST					;AN000;
	MSG_UTILNAME <GRAFTABL> 	;AN000;IDENTIFY THE COMPONENT
; =  =	=  =  =  =  =  =  =  =	=  =
;	   $SALUT (4,12,18,36)	   ;AN000;
CSEG	   SEGMENT PARA PUBLIC	   ;AN000;
	   ASSUME CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;AN000;

;THIS MODULE IS EXPECTED TO BE LINKED DIRECTLY FOLLOWING THE LAST
;FONT DEFINITION MODULE, SINCE THE VARIABLE, "COPYRIGHT", IS USED
;TO DETERMINE THE END OF THE ARRAY OF FONT TABLES.

	   PUBLIC COPYRIGHT	   ;AN000;
COPYRIGHT  LABEL BYTE		   ;AN006;
;(deleted ;AN004;) INCLUDE COPYRIGH.INC ;(this is now being done in MSG_SERVICES)

	   INCLUDE MSGHAN.INC	   ;AN000;DEFINE MESSAGE HANDLER CONTROL BLOCKS
	   INCLUDE GRTABMS.INC	   ;AN000;DEFINE THE MESSAGES, AND CONTROL BLOCKS
	   MSG_SERVICES <GRAFTABL.CLA,GRAFTABL.CL1,GRAFTABL.CL2> ;AN000;
	   MSG_SERVICES <MSGDATA>  ;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	   PUBLIC SYSLOADMSG	   ;AN000;
	   PUBLIC SYSDISPMSG	   ;AN000;
	   PUBLIC SYSGETMSG	   ;AN000;
	   PATHLABL GRTABSM	   ;AN006;
				   ;DEFAULT=CHECK DOS VERSION
				   ;DEFAULT=NEARmsg
				   ;DEFAULT=NO INPUTmsg
				   ;DEFAULT=NO NUMmsg
				   ;DEFAULT=NO TIMEmsg
				   ;DEFAULT=NO DATEmsg
;	   MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg>				;AN000;
.XLIST				   ;AN000;
.XCREF				   ;AN000;
	   MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg> ;AN000;
.LIST				   ;AN000;
.CREF				   ;AN000;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	   PATHLABL GRTABSM	   ;AN006;


CSEG	   ENDS 		   ;AN000;

include msgdcl.inc

	   END			   ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grbwprt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I added code to the procedures PRINT_BW_PRT and FILL_BUFFER 
;**                to handle the support of HP PCL printers.   I used the algorithm
;**                below for PRINT_BW_PRT.
;**  
;**                  if data_type = data_row
;**                          if cur_scan_lne_length = 0 goto next_coordinates
;**                                  for i:=1 to box_h
;**                                          call new_prt_line
;**                                          save regs.
;**                                          save cur_row & cur_column
;**                                          for j:=1 to cur_scan_lne_lenght/nb_boxes_per_prt_buf 
;**                                          (+1 if remainder)
;**                                                  call fill_buffer
;**                                                  call print_buffer
;**                                          end_for
;**                                          call end_prt_line
;**                                          restore cur_column & cur_row
;**                                          restore regs.
;**                                  end_for
;**                          restore regs.
;**  next_coordinates:       if rotate_sw = on
;**                                  inc cur_column
;**                          else
;**                                  inc cur_row
;**                          endif
;**                  else
;**                        .
;**                        .
;**                        .
;**                          call end_prt_line       ; Print CR & LF
;**                        .
;**                        .
;**                        .
;**                  endif
;**  
;**  DOCUMENTATION NOTES:  This version of GRBWPRT.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE ,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Black and White printing modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRBWPRT.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the code for printing a GRAPHICS screen on a	;AN000;
;;	 BLACK and WHITE printer.						;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;										;AN000;
;;	PRINT_BW_APA								;AN000;
;;	  FILL_BUFFER								;AN000;
;;	    INT2PAT								;AN000;
;;	    PAT2BOX								;AN000;
;;										;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRCTRL.EXT   - Externals for print screen control			;AN000;
;;	 GRCTRL.STR   - Structures and equates for print screen control 	;AN000;
;;	 GRPATTRN.STR - Structures for the printer patterns.			;AN000;
;;										;AN000;
;;	 GRSHAR.STR   - Shared Data Area Structure				;AN000;
;;										;AN000;
;;	 STRUC.INC    - Macros for using structured assembly language		;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR - Main module for printing the screen.			;AN000;
;;	 TO FILE GRCOMMON.ASM							;AN000;
;;	      Common modules - tools for printing a screen.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 This file is included by GRCTRL.ASM					;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
PAGE										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
										;AN000;
	PUBLIC	PRINT_BW_APA							;AN000;
	PUBLIC	LEN_OF_BW_MODULES						;AN000;
										;AN000;
.XLIST										;AN000;
INCLUDE GRCTRL.STR			; Stuctures needed			;AN000;
INCLUDE GRSHAR.STR			;  for both set of print modules	;AN000;
INCLUDE GRPATTRN.STR			;					;AN000;
INCLUDE GRCTRL.EXT			; Externals from PRT_SCR control module ;AN000;
INCLUDE STRUC.INC			;					;AN000;
										;AN000;
	PUBLIC PRINT_BW_APA		; Black and white modules,		;AN000;
.LIST										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BW_APA : PRINT A GRAPHIC MODE SCREEN ON A BLACK AND WHITE PRINTER	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;		BIOS_INT_5H = Pointer to BIOS int 5h				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:	This procedure	maps  each  pixel of the screen to a box	;AN000;
; of dots on the printer.  The box size depends on the screen resolution	;AN000;
; and  the number  of  bytes per printer line.	It is chosen in order to	;AN000;
; respect the  screen ratio and  is  documented in each printer profile.	;AN000;
;										;AN000;
;     For efficiency and space considerations, the print buffer does not	;AN000;
; hold a full print line.  Bytes representing pixels are printed as soon	;AN000;
; as they are  ready to be printed.  However, the print buffer	is  wide	;AN000;
; enough to hold complete boxes.						;AN000;
;										;AN000;
;     The order  for reading  pixels  off the screen  is  driven  by the	;AN000;
; order bytes  are  expected by the printer.  To print the screen in its	;AN000;
; original orientation we must begin reading it from the top left corner	;AN000;
; and  send  the pixels line by line; to print it sideways, reading will	;AN000;
; start from the bottom left  corner and a "LINE" will now be a vertical        ;AN000;
; screen column read from bottom to top.					;AN000;
;										;AN000;
;     There is	more  to it  however, the  printer  head  is  printing a	;AN000;
; vertical  column of 8 dots  at a time and each pixel read is mapped to	;AN000;
; a box of dots  that is less than  8 dots high  (e.g., 2 cols	x 1 row)	;AN000;
; therefore, many boxes must be stored in the bytes sent to the printer.	;AN000;
;										;AN000;
;     These boxes represent pixels that are one above each other on  the	;AN000;
; screen. We must read enough pixels on one column of the screen to  use	;AN000;
; all 8 bits of the vertical printer head (e.g., if the box size  is 2x1	;AN000;
; then 8  pixels  must be read	and  2 bytes of the print buffer will be	;AN000;
; filled).									;AN000;
;										;AN000;
;     The  PRINT BUFFER  for  any  box size  will be 8 bits high by "BOX        ;AN000;
; WIDTH" bits wide.                                                             ;AN000;
;										;AN000;
;     After the buffer is filled, it is  printed  and  the next "column"        ;AN000;
; of  8 pixels	is read.  Therefore,  the screen  is read "line by line"        ;AN000;
; where a line is  8 pixels high  for a 2x1 box (4 pixels high for a 3x2	;AN000;
; box).  ONE SUCH LINE IS CALLED A SCAN LINE.					;AN000;
;										;AN000;
PAGE										;AN000;
;										;AN000;
; A 350X200 screen mapping to a 3x2 box is read in the following order: 	;AN000;
;										;AN000;
; SCREEN:									;AN000;
;										;AN000;
;	  column column    . . .	column					;AN000;
;	  no. 0  no. 1			no. 349 				;AN000;
;	 ͻ				;AN000;
;  scan  1(0,0) 5(0,1) 	       1397(0,349)				;AN000;
;  line  2(1,0) 6(1,1)  . . . . . . . 1398(1,349)				;AN000;
;  no. 1 3(2,0) 7(2,1) 	       1399(2,349)				;AN000;
;	 4(3,0) 8(3,1) 	       1400(3,349)				;AN000;
;	 					  				;AN000;
;  scan  1401(4,0) 1405(4,1)			      LEGEND:	n(X,Y)		;AN000;
;  line  1402(5,0)   etc,			  				;AN000;
;  no. 2 1403(6,0)	     . . . . .		      n = READ RANK		;AN000;
;	 1404(7,0)				      X = ROW NUMBER		;AN000;
;	     . 				      Y = COLUMN NUMBER	;AN000;
;   etc,     . 				  				;AN000;
;	     . 		    70000(199,349)				;AN000;
;	 ͼ				;AN000;
;										;AN000;
;										;AN000;
; LOGIC :									;AN000;
;										;AN000;
; Initialize printer and local variables.					;AN000;
; CALL	  LOC_MODE_PRT_INFO ; Get printer info related to current mode. 	;AN000;
; CALL	  GET_SCREEN_INFO   ; Get info. about how to read the screen		;AN000;
; CALL	  SETUP_PRT	    ; Set up the printer (Line spacing, etc)		;AN000;
;										;AN000;
; FOR each scan line on the screen (NB_SCAN_LINES)				;AN000;
;   (Note: One scan line maps to one print line)				;AN000;
;   BEGIN									;AN000;
;   CALL DET_CUR_SCAN_LNE_LENGTH ; Determine length in pels of the current	;AN000;
;			  ;  scan line. 					;AN000;
;   IF CUR_SCAN_LNE_LENGTH NE 0 THEN						;AN000;
;     CALL NEW_PRT_LINE     ; Initialize a new printer line			;AN000;
;     DO CUR_SCAN_LNE_LENGTH times ; For each column				;AN000;
;	BEGIN									;AN000;
;	CALL FILL_BUFFER    ; Read top-down enough pels to fill the buffer	;AN000;
;	CALL PRINT_BUFFER   ; Print the buffer					;AN000;
;	IF printing sideways THEN INC CUR_ROW	 ; Get coordinates of next	;AN000;
;			     ELSE INC CUR_COLUMN ;  "column" (vertical chunk of ;AN000;
;	END (for each column)			 ;   a scan line).		;AN000;
;   PRINT_BYTE CR	  ; Print a CR and a LF 				;AN000;
;   PRINT_BYTE LF								;AN000;
;   ; Get coordinates of next scan line:					;AN000;
;   IF printing sideways THEN							;AN000;
;			      ADD CUR_COLUMN,NB_BOXES_PER_PRT_BUF		;AN000;
;			      MOV CUR_ROW,SCREEN_HEIGHT - 1			;AN000;
;			 ELSE							;AN000;
;			      ADD CUR_ROW,NB_BOXES_PER_PRT_BUF			;AN000;
;			      MOV CUR_COLUMN,0					;AN000;
;   END (for each scan line)							;AN000;
;										;AN000;
PRINT_BW_APA PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; INITIALIZATION:								;AN000;
;										;AN000;
;	1) Locate and extract printer DISPLAYMODE information from		;AN000;
;	   the shared data area, calculate the number of boxes fitting		;AN000;
;	   in the printer buffer.						;AN000;
;	2) Determine where to start reading the screen: 			;AN000;
;	     If printing sideways, start in LOW LEFT corner.			;AN000;
;	     If normal printing, start in TOP LEFT corner.			;AN000;
;	   Determine the maximum length for a scan line:			;AN000;
;	     If printing sideways, it is the height of the screen.		;AN000;
;	     For normal printing, it is the width of the screen.		;AN000;
;	   Determine the number of scan lines on the screen.			;AN000;
;	3) Set up the Printer for printing Graphics.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	LOC_MODE_PRT_INFO	; Get printer info related to curr. mode;AN000;
;										;AN000;
;-------Test if DISPLAYMODE info record was found:				;AN000;
       .IF <ERROR_CODE EQ DISPLAYMODE_INFO_NOT_FOUND>				;AN000;
       .THEN									;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; IF no record found,		;AN000;
	  JMP	  PRINT_BW_APA_END	     ; then, return error code		;AN000;
       .ENDIF				     ;	      and quit procedure	;AN000;
;										;AN000;
;-------Get the box size from the DISPLAYMODE info record:			;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset current DISPLAYMODE info.;AN000;
	MOV	AH,[BX].BOX_WIDTH	; Take local copy of the box size.	;AN000;
	MOV	BOX_W,AH		;  in BOX_W and BOX_H			;AN000;
	MOV	AL,[BX].BOX_HEIGHT						;AN000;
	MOV	BOX_H,AL							;AN000;
;										;AN000;
;-------Verify if the box size obtained from DISPLAYMODE info. is valid 	;AN000;
       .IF <ZERO AL> OR 		; IF height of the box is 0		;AN000;
       .IF <ZERO AH>			;  OR width of the box is 0		;AN000;
       .THEN				; THEN we can't print:                  ;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; return error code		;AN000;
	  JMP	  PRINT_BW_APA_END	;	and quit			;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get the Print Orientation from the DISPLAYMODE info record		;AN000;
       .IF <[BX].PRINT_OPTIONS EQ ROTATE>; If printing sideways 		;AN000;
       .THEN				;  then:				;AN000;
	  MOV	  ROTATE_SW,ON		;    Rotate switch := "ON"              ;AN000;
       .ENDIF									;AN000;
										;AN000;
;										;AN000;
;-------Initialize print variables and the printer:				;AN000;
	CALL	GET_SCREEN_INFO 	; Get info. about how to read the screen;AN000;
	CALL	SETUP_PRT		; Set up the printer (Line spacing, etc);AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: quit	;AN000;
	  JMP	  PRINT_BW_APA_END	;					;AN000;
       .ENDIF									;AN000;

	MOV	CX,NB_SCAN_LINES						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Added the following modification to support printers with
;               vertical print heads, such as HP PCL printers.  
;
;                                       ; .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>
CMP     DS:[BP].DATA_TYPE,DATA_ROW      ;        
JNE     GOTO_ITS_DATA_COLUMN            ;
;-------------------------------------------------------------------------------
;										
; FOR EACH SCAN LINE ON THE SCREEN, WHICH REALLY IS JUST ONE LINE:					
;										
;-------------------------------------------------------------------------------
PRINT_1_LINE_OF_BOXES:                          ;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine how many non-blanks on line 
        CMP     CUR_SCAN_LNE_LENGTH,0           ; .IF <CUR_SCAN_LNE_LENGTH NE 0>
        JE      GOTO_NEXT_COORDINATES           ; If line is not empty then, 			
						;				
	        PUSH	CX			; Save scan line counter	
                XOR     CH,CH                   ; Clear register
                MOV     CL,BOX_H                ; CX is the # of times we need to read
                                                ; a line to print complete boxes.
                MOV     DS:[BP].ROW_TO_EXTRACT,CL ; Determines what row to extract
                DEC     DS:[BP].ROW_TO_EXTRACT  ; zero based
READ_LINE:                                      ;
	        CALL	NEW_PRT_LINE		;  Send escape sequence to the printer 
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR> ; for starting a new line.       
               .THEN				; If a printer error occurred:	       
                        POP     CX              ; Restore counter for how many times we
                        JMP     PRINT_BW_APA_END; need to read line and quit!
               .ENDIF		                ;							
                PUSH    DX                      ;
                PUSH    CX                      ; Save counter for how many times we 
                                                ; need to read line.
	        PUSH    CUR_ROW                 ; Save coordinates where start reading
                PUSH    CUR_COLUMN              ; line.
                MOV     AX,CUR_SCAN_LNE_LENGTH  ; DX:AX = counter for how many pixels need to
                CWD                             ; be read per line
                XOR     BH,BH                   ;
                MOV     BL,NB_BOXES_PER_PRT_BUF ;
                
                DIV     BX                      ;
               .IF <DX NE 0>                    ; So don't lose data when
                     INC        AX              ; have a remainder.
               .ENDIF                           ;
                MOV     CX,AX                   ; loop CX times to read all
                                                ; pixels on scan line.
                JMP     SHORT  PRINT_1_LINE     ; Jumps were out of range
GOTO_NEXT_COORDINATES:                          ;
        JMP     SHORT   NEXT_COORDINATES        ;
GOTO_PRINT_1_LINE_OF_BOXES:                     ;
        JMP     PRINT_1_LINE_OF_BOXES           ;
GOTO_ITS_DATA_COLUMN:                           ; 
        JMP     SHORT   ITS_DATA_COLUMN         ;
PRINT_1_LINE:                                   ;
                CALL    FILL_BUFFER             ; Read enough pixels to fill the buffer
                                                ; convert each to a printer box,
                                                ; extract a row from each box,
                                                ; store it in the print buffer
                CALL    PRINT_BUFFER            ; Print it
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ;				       
               .THEN				        ; A printer error occurred:	       
                        POP       CUR_COLUMN            ;
                        POP       CUR_ROW               ;
	                POP	  CX			; Restore counter for how many pixels
                                                        ; needed to read per line      
                        POP       DX                    ;
                        POP       CX                    ; Save scan line counter
	                JMP	  PRINT_BW_APA_END	; and quit				
               .ENDIF					;			       
                LOOP    PRINT_1_LINE                    ; Continue reading, converting, extracting
                                                        ; storing and printing.
	        CALL	END_PRT_LINE		        ;  Send escape sequence to the printer 
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ; for ending a line.	       
               .THEN				        ; If a printer error occurred: 
                        POP       CUR_COLUMN            ;
                        POP       CUR_ROW               ;
                        POP       CX                    ; Restore counter for how many times we
                                                        ; needed to read per line      
                        POP       DX                    ;
                        POP       CX                    ; Save scan line counter
                        JMP     PRINT_BW_APA_END; need to read line and quit!
               .ENDIF					;			       
                DEC     DS:[BP].ROW_TO_EXTRACT          ; Extract next row. Note:zero based
                POP     CUR_COLUMN                      ; Restore coordinates of beginning
                POP     CUR_ROW                         ; of "scan" line.
                POP     CX                              ; Restore counter for how many times we
                                                        ; needed to read per line      
                POP     DX                              ;
                LOOP    READ_LINE                       ; Read the line again so we can extract
                                                        ; the other rows out of the printer boxes
                POP      CX                             ; Save scan line counter

NEXT_COORDINATES:                                       ; End of, if line is not empty 
       .IF <CUR_SCAN_LNE_LENGTH EQ 0>                   ; 
                CALL    NEW_PRT_LINE                    ; Send esc. seq. to printer
       .ENDIF                                           ;
       .IF <ROTATE_SW EQ ON>                            ; Get coordinates of next "scan" line
       .THEN                                            ;
                INC CUR_COLUMN                          ;
       .ELSE                                            ;
                INC CUR_ROW                             ;
       .ENDIF                                           ;
        DEC     CX                                      ; Loop was out of range.  Read another
        CMP     CX,0                                    ; "scan" line and print the corresponding
        JNE     GOTO_PRINT_1_LINE_OF_BOXES; printer boxes.
        JMP     SHORT   DONE_WITH_PRINTING              ;

ITS_DATA_COLUMN:                                        ; .ELSE

; /\ ~~mda(001) -----------------------------------------------------------------------
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR EACH SCAN LINE ON THE SCREEN:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_SCAN_LINE:								;AN000;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine how many non-blanks on line ;AN000;
       .IF <CUR_SCAN_LNE_LENGTH NE 0>		; If line is not empty		;AN000;	
       .THEN					; then, 			;AN000;	
                CALL	NEW_PRT_LINE		;  Send escape sequence to the printer	;AN000;
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR> ; for starting a new line.;AN000;	
               .THEN				; If a printer error occurred:	;AN000;	
	                JMP  SHORT PRINT_BW_APA_END	;   Quit !		;AN000;	
               .ENDIF								;AN000;
										;AN000;
	        PUSH	CX			; Save scan line counter	;AN000;
	        MOV	CX,CUR_SCAN_LNE_LENGTH					;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non-blank):		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_SCAN_COLUMN:								;AN000;
	        CALL	FILL_BUFFER		; Read all pixels on this column,    ;AN000;
					        ;   convert each to a printer box,   ;AN000;
					        ;    store boxes in the print buffer ;AN000;
					        ;     (a buffer contains one "column";AN000;
					        ;      of pixels).		     ;AN000;
	        CALL	PRINT_BUFFER		; Print the buffer.		     ;AN000;
               .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>				     ;AN000;
               .THEN				; A printer error occurred:	     ;AN000;
	                POP	  CX			; Restore scan line counter and quit	;AN000;
	                JMP	  SHORT  PRINT_BW_APA_END	;			;AN000;
               .ENDIF								;AN000;
										;AN000;
										;AN000;
;-------Get coordinates of next "column":                                       ;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways		;AN000;
               .THEN				;				;AN000;
	                DEC CUR_ROW			; then, get row above on screen	;AN000;
               .ELSE				;				;AN000;
	                INC CUR_COLUMN		; else, get column next right	;AN000;
               .ENDIF				;				;AN000;
										;AN000;
        	LOOP	PRINT_1_SCAN_COLUMN	; Print next column		;AN000;
										;AN000;
	        POP	CX			; Restore scan line counter	;AN000;
       .ENDIF					; Endif line is not empty	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Print a carriage return and a line feed:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Commented out the following and replaced it with the procedure
;               END_PRT_LINE because this procedure takes care of this as well
;               as sending the esc. seq. that comes after the keyword DATA.
;
;       MOV	AL,CR							;AN000;
;	CALL	PRINT_BYTE		        ; Send CR		;AN000;
;	JC	PRINT_BW_APA_END	        ; If printer error, leave;AN000;
;	MOV	AL,LF				;			;AN000;
;	CALL	PRINT_BYTE		        ; Send LF		;AN000;
;	JC	PRINT_BW_APA_END	        ; If printer error, leave;AN000;
;                                               ;
	CALL	END_PRT_LINE		        ;  Send escape sequence to the printer	;AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>   ; for ending a line, and for      ;AN000;
                                                ; doing a CR and LF.
       .THEN				        ; If a printer error occurred:	  ;AN000;
	JMP	SHORT   PRINT_BW_APA_END        ;   Quit !			  ;AN000;
       .ENDIF					;			;AN000;
; /\ ~~mda(001) -----------------------------------------------------------------------

        JMP     SHORT   GET_NEXT_SCAN_LINE      ;~~mda(001) Used this to replace a
GOTO_PRINT_1_SCAN_LINE:                         ; loop that was out or range.
        JMP     PRINT_1_SCAN_LINE               ;
GET_NEXT_SCAN_LINE:                             ;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Get coordinates of next scan line:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways		;AN000;
               .THEN				; then: 			;AN000;
	                MOV	  AL,NB_BOXES_PER_PRT_BUF ;   AX := Numbers of pels read on row ;AN000;
	                CBW				;				;AN000;
	                ADD	  CUR_COLUMN,AX 	;   CUR_COLUMN + Number of pels read	;AN000;
	                MOV	  AX,SCREEN_HEIGHT	;   CUR_ROW := SCREEN_HEIGHT - 1;AN000;
	                DEC	  AX			;				;AN000;
	                MOV	  CUR_ROW,AX		;				;AN000;
               .ELSE				; else, printing NOT rotated:	;AN000;
	                MOV	  AL,NB_BOXES_PER_PRT_BUF ;   AX := Number of pels read on colum;AN000;
	                CBW				;				;AN000;
	                ADD	  CUR_ROW,AX		;   CUR_ROW + Number of pels read;AN000;
	                MOV	  CUR_COLUMN,0		;   CUR_COLUMN := 0		;AN000;
               .ENDIF				;				;AN000;
;;        LOOP	PRINT_1_SCAN_LINE	;~~mda(001) Commented it out cause loop is  ;AN000;
                                        ;           out of range.
        DEC     CX                      ;~~mda(001) Used this instead of the LOOP
        OR      CX,CX
        JNZ      GOTO_PRINT_1_SCAN_LINE  ;
DONE_WITH_PRINTING:                     ;~~mda(001) Label for endif.										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore the printer.								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	RESTORE_PRT							;AN000;
PRINT_BW_APA_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BW_APA ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; FILL_BUFFER : READS ENOUGH PIXELS TO FILL UP THE PRINT BUFFER.		;AN000;
;		THESE PIXELS ARE MAPPED TO A PRINTER DOT BOX.			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_COLUMN,							;AN000;
;		CUR_ROW = Coordinates of the first pixel to be read		;AN000;
;		BOXES_PER_PRT_BUF = Number of boxes fitting in the print	;AN000;
;				    buffer					;AN000;
;		XLT_TAB = Color translation table				;AN000;
;										;AN000;
;	OUTPUT: PRT_BUF = PRINT BUFFER						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:									;AN000;
;										;AN000;
;	1) Pixels are read one by one vertically from top to bottom in		;AN000;
;	   the current column of the screen scan line.				;AN000;
;	   NOTE: What is called here a 'column' can actually be a line          ;AN000;
;		 on the physical display.					;AN000;
;	2) Each pixel is mapped to a printer dot box.				;AN000;
;	3) Each Dot box is stored in the printer buffer.			;AN000;
;	4) The coordinates in input are those of the "top" pixel                ;AN000;
;	   and restored when leaving this procedure.				;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Save coordinates of the current "column" (slice of a screen scan line)        ;AN000;
; DO for BOXES_PER_PRT_BUF  (8 / BOX_H) 					;AN000;
;   BEGIN									;AN000;
;   CALL READ_DOT		  ; Read a pixel, get index in XLT_TAB		;AN000;
;   Get pixel intensity from XLT_TAB						;AN000;
;   CALL INT2PAT		  ; Locate pattern corresponding to int.	;AN000;
;   CALL PAT2BOX		  ; Extract box from pattern			;AN000;
;   CALL STORE_BOX		  ; Store the box in the printer buffer 	;AN000;
;   ; Get coordinates of next pixel below:					;AN000;
;   IF printing is sideways THEN INC CUR_COLUMN 				;AN000;
;			    ELSE INC CUR_ROW					;AN000;
;   END 									;AN000;
; Restore initial coordinates.							;AN000;
;										;AN000;
FILL_BUFFER PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Save initial coordinates:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;	        If DATA_TYPE is equal to DATA_ROW then we have a horizontal 
;               print head so we SHOULDN'T save CUR_ROW and CUR_COLUMN because 
;               we are moving down the "scan" line from left to right a little 
;               at a time, that is we don't finish reading the scan line until 
;               we have made repeated calls to this procedure.  Remember since
;               we're dealing with horizontal print heads one scan line is 
;               really just one line.
;                                                  ;
       .IF <DS:[BP].DATA_TYPE NE DATA_ROW>         ;
                                                   ;
	        PUSH	CUR_ROW 		   ;					
	        PUSH	CUR_COLUMN		   ;					
       .ENDIF					   ;					
;/\  ~~mda(001) -----------------------------------------------------------------------
;-------Clear the print buffer: 						;AN000;
	XOR	BX,BX		; For each byte in the PRT_BUF: 		;AN000;
CLEAR_PRT_BUF:									;AN000;
	MOV	PRT_BUF[BX],0	;  Initialize byte to blanks			;AN000;
	INC	BX		;  Get next byte				;AN000;
	CMP	BL,BOX_W	;  All bytes cleared ?				;AN000;
	JL	CLEAR_PRT_BUF	;  No, clear next one.				;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB ; BX := Offset of XLT_TAB			;AN000;
										;AN000;
;-------Fill the print buffer with one box for each pixel read: 		;AN000;
	XOR	CX,CX		; CL := Number of pixels to read		;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF 					;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
READ_AND_STORE_1_PIXEL: 							;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Intensity			;AN000;
	CALL	INT2PAT 		; SI := Offset of matching Pattern	;AN000;
	CALL	PAT2BOX 		; Extract CUR_BOX from the pattern.	;AN000;
	MOV	SI,OFFSET CUR_BOX	; Store it in the PRT_BUF		;AN000;
	CALL	STORE_BOX							;AN000;
										;AN000;
;-------Get coordinates of next pixel:						;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE is DATA_ROW then we have a horizontal print head
;               so we need to read the next pixel on the scan line.  Remember
;               since we're dealing with horizontal print heads one scan line
;               is really just one line. For every pixel read we need to store 
;               one row of the corresponding box in the print buffer.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ;
                .IF <ROTATE_SW EQ ON>		; If printing sideways			
                .THEN				;					
	                DEC CUR_ROW		; then, decrement row number   
                .ELSE				;			       
	                INC CUR_COLUMN		; else, increment column number
                .ENDIF				;			       
       .ELSE                                    ;
;/\  ~~mda(001) -----------------------------------------------------------------------
                .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
                .THEN				;					;AN000;
	                INC CUR_COLUMN		; then, increment column number 	;AN000;
                .ELSE				;					;AN000;
	                INC CUR_ROW		; else, increment row number		;AN000;
                .ENDIF				;					;AN000;
       .ENDIF                                   ; ~~mda(001) Close IF stmt.
	LOOP READ_AND_STORE_1_PIXEL						;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore initial coordinates:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE = DATA_ROW then we don't restore initial coordinates.
;
       .IF <DS:[BP].DATA_TYPE NE DATA_ROW>         ;
	        POP	CUR_COLUMN		   ;					
	        POP	CUR_ROW 		   ;					
       .ENDIF					   ;					
;/\  ~~mda(001) -----------------------------------------------------------------------
										;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
FILL_BUFFER ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; INT2PAT : MAP AN INTENSITY TO A PATTERN.					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	AL = GREY INTENSITY (0 - 63 = BLACK to WHITE)			;AN000;
;		BOX_W = Number of columns in a box				;AN000;
;		CUR_MODE_PTR = Offset of current DISPLAYMODE info record	;AN000;
;										;AN000;
;	OUTPUT: SI = OFFSET OF THE PATTERN MATCHING THE INTENSITY		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Performs a sequential search in the table of patterns		;AN000;
; until the proper pattern is found.						;AN000;
;										;AN000;
;										;AN000;
; SI = 0 ; FOUND = FALSE							;AN000;
; DO UNTIL FOUND = TRUE 							;AN000;
;   BEGIN									;AN000;
;   IF AL <= Maximum intensity of the current pattern in the table		;AN000;
;     THEN									;AN000;
;	FOUND = TRUE								;AN000;
;     ELSE									;AN000;
;	SI = SI + (BOX_W * 2)							;AN000;
;   END 									;AN000;
;										;AN000;
INT2PAT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
;-------Calculate the size in bytes of one pattern STRUCTURE: (see GRPATTRN.STR);AN000;
	MOV	DL,BOX_W	; DX := Number of columns in the box		;AN000;
	XOR	DH,DH								;AN000;
	SHL	DL,1		; (DX * 2) = Number of columns in the pattern	;AN000;
	INC	DL		; DL := Size in bytes of one pattern		;AN000;
				;	(includes intensity field)		;AN000;
	MOV	BX,CUR_MODE_PTR ; BX := Offset of current mode			;AN000;
				; SI := Offset of the first pattern		;AN000;
	MOV	SI,[BX].PATTERN_TAB_PTR 					;AN000;
	ADD	SI,BP								;AN000;
										;AN000;
COMPARE_INTENSITY:								;AN000;
	CMP	AL,[SI] 	; Within the range of this pattern ?		;AN000;
	JLE	FOUND_PATTERN	;   Yes, use this pattern.			;AN000;
				;   No, look at next pattern:			;AN000;
	ADD	SI,DX		;     SI := SI + Number columns in pattern)	;AN000;
	JMP	SHORT COMPARE_INTENSITY 					;AN000;
										;AN000;
FOUND_PATTERN:									;AN000;
										;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
										;AN000;
INT2PAT ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PAT2BOX : SELECT AND EXTRACT THE PROPER BOX FROM THE PATTERN ACCORDING	;AN000;
;	    TO THE COORDINATES OF THE PIXEL.					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SI = OFFSET OF CURRENT PATTERN					;AN000;
;		CUR_COLUMN,							;AN000;
;		CUR_ROW  = COORDINATES OF THE CURRENT PIXEL			;AN000;
;										;AN000;
;	OUTPUT: CUR_BOX  = PORTION OF THE PATTERN TO BE PRINTED 		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: If the pixel is on even-even coordinates, then the		;AN000;
; top-left box of the pattern is extracted.					;AN000;
; If its Even-odd --> extract the top-right box.				;AN000;
; Odd-even --> low-left box, and Odd-odd  --> low-right box.			;AN000;
;										;AN000;
PAGE										;AN000;
;  For example., (with a 3x2 box):						;AN000;
;										;AN000;
;  PATTERN (over 6 bytes):							;AN000;
;										;AN000;
;										;AN000;
;	       byte1  byte2  byte3	byte4  byte5  byte6			;AN000;
;										;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
;		 0	0      0	  0	 0	0			;AN000;
; even-even --> dot1   dot2   dot3   |	 dot1	dot2   dot3 <-- even-odd	;AN000;
; (row-column)	dot4   dot5   dot6   |	 dot4	dot5   dot6	box		;AN000;
; box.	       ------------------------------------------------ 		;AN000;
; odd-even  --> dot1   dot2   dot3   |	 dot1	dot2   dot3 <-- odd-odd 	;AN000;
; box		dot4   dot5   dot6   |	 dot4	dot5   dot6	box		;AN000;
;										;AN000;
;										;AN000;
;  The selected box is then stored as follow:					;AN000;
;										;AN000;
;  CUR_BOX:									;AN000;
;		byte1 byte2 byte3						;AN000;
;     MSB ------> 0	0     0 						;AN000;
;     (bit7)	  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		  0	0     0 						;AN000;
;		 dot1  dot2  dot3 <-- box					;AN000;
;     LSB ------>dot4  dot5  dot6						;AN000;
;										;AN000;
; LOGIC:									;AN000;
; IF CUR_ROW is odd								;AN000;
; THEN SI := SI + BOX_W 	; Access right portion of pattern		;AN000;
; Build a bit mask in BL of BOX_H bits, right justified.			;AN000;
; FOR each column in the box (BOX_W)						;AN000;
;   Get the pattern column in AL						;AN000;
;   IF CUR_COLUMN is even							;AN000;
;   THEN									;AN000;
;     Move down the column of the top box.					;AN000;
;   AND BL,AL			; BL <-- Column of the desired box		;AN000;
;										;AN000;
;										;AN000;
PAT2BOX PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
										;AN000;
					; SI := Offset of current pattern	;AN000;
	INC	SI			; Skip the MAX INTENSITY field		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Set SI to either the left or right set of 2 boxes in the pattern:		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	TEST	CUR_ROW,1		; Odd row ?				;AN000;
	JZ	EXTRACT_BOX		;   No,  access left portion of pattern ;AN000;
	MOV	AL,BOX_W		;					;AN000;
	CBW				;					;AN000;
	ADD	SI,AX			;   Yes, access right portion of pattern;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Extract the box:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
EXTRACT_BOX:									;AN000;
;-------Build a bit mask that will be used to keep only BOX_H bits		;AN000;
;-------of the bytes where CUR_BOX is stored.					;AN000;
	XOR	AH,AH			; AH := Box column bit mask		;AN000;
	MOV	AL,BOX_H		; For each row of the box:		;AN000;
INIT_MASK:				;					;AN000;
	SHL	AH,1			;					;AN000;
	OR	AH,1			;    Insert one bit in the mask.	;AN000;
	DEC	AL			;					;AN000;
	CMP	AL,0			;					;AN000;
	JG	INIT_MASK							;AN000;
										;AN000;
	XOR	BX,BX			; BL := Column number within the box	;AN000;
;										;AN000;
;-------For each column of the box:						;AN000;
EXTRACT_1_BOX_COLUMN:								;AN000;
	MOV	AL,[SI] 		; AL := Current column of pattern	;AN000;
	TEST	CUR_COLUMN,1		; If the pixel is on ODD column 	;AN000;
	JNZ	BOTTOM_BOX		;   Then, need bottom box portion	;AN000;
	MOV	CL,BOX_H		;   Else, need top box portion		;AN000;
TOP_BOX:				; Need top box: 			;AN000;
	SHR	AL,CL			;   Shift top box over bottom box	;AN000;
BOTTOM_BOX:				; The box we want is now at bottom	;AN000;
	AND	AL,AH			; Keep only bits from the box		;AN000;
	MOV	CUR_BOX[BX],AL		; Store this box column 		;AN000;
	INC	SI			; Access next column of the pattern	;AN000;
	INC	BX			; One more column stored.		;AN000;
	CMP	BL,BOX_W		; All stored ?				;AN000;
	JL	EXTRACT_1_BOX_COLUMN	;   No, continue			;AN000;
										;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PAT2BOX ENDP									;AN000;
INCLUDE GRCOMMON.ASM								;AN000;
LEN_OF_BW_MODULES EQU $-PRINT_BW_APA						;AN000;
CODE	ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grcolprt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Color printing modules
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCOLPRT.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the code for printing a screen (text and graphics)	;AN000;
;;	 on a COLOR printer.							;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;										;AN000;
;;	PRINT_COLOR								;AN000;
;;	  SCAN_FOR_BANDS_APA							;AN000;
;;	  SCAN_FOR_BANDS_TXT							;AN000;
;;	  PRINT_BAND_APA							;AN000;
;;	  PRINT_BAND_TXT							;AN000;
;;	  SET_CURSOR								;AN000;
;;	  SET_COLOR_BAND							;AN000;
;;	  INIT_BLACK_BOX							;AN000;
;;										;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;										;AN000;
;;	 GRCTRL.EXT   - Externals for print screen control			;AN000;
;;	 GRCTRL.STR   - Structures and equates for print screen control 	;AN000;
;;	 GRPATTRN.STR - Structures for the printer patterns.			;AN000;
;;										;AN000;
;;	 GRSHAR.STR   - Shared Data Area Structure				;AN000;
;;										;AN000;
;;	 STRUC.INC    - Macros for using structured assembly language		;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR - Main module for printing the screen.			;AN000;
;;	 TO FILE GRCOMMON.ASM							;AN000;
;;	      Common modules - tools for printing a screen.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;	 Date last updated 5/26/87.						;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
PAGE										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
										;AN000;
	PUBLIC	PRINT_MODULE_START     ;; Color modules public			;AN000;
	PUBLIC	PRINT_COLOR	       ;;  procedures				;AN000;
	PUBLIC	LEN_OF_COLOR_MODULES   ;;					;AN000;
				       ;;					;AN000;
.XLIST					;					;AN000;
INCLUDE GRCTRL.STR			; Stuctures needed			;AN000;
INCLUDE GRSHAR.STR			;  for both set of print modules	;AN000;
INCLUDE GRPATTRN.STR			;					;AN000;
					;					;AN000;
INCLUDE GRCTRL.EXT			; Externals from PRT_SCR control module ;AN000;
INCLUDE STRUC.INC			;					;AN000;
.LIST					;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;										;AN000;
;; PRINT_COLOR : PRINT TEXT AND APA MODE SCREEN ON A COLOR PRINTER		;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Main control module for printing of text and graphics			;AN000;
;;   on color printers. 							;AN000;
;;										;AN000;
;;   Calls either the text or graphics mode routine.				;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_SCREEN								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   LOC_MODE_PRT_INFO, PRINT_COLOR_APA, PRINT_COLOR_TXT			;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   IF MODE_TYPE = TXT 							;AN000;
;;     THEN CALL PRINT_COLOR_TXT						;AN000;
;;   ELSE (MODE_TYPE = APA)							;AN000;
;;     CALL LOC_MODE_PRT_INFO	 ; Get DISPLAYMODE record from the SHARED AREA	;AN000;
;;     CALL PRINT_COLOR_APA							;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	;AN000;
PRINT_MODULE_START  LABEL BYTE							;AN000;
PRINT_COLOR	PROC NEAR							;AN000;
	JMP	SHORT PRINT_COLOR_BEGIN 					;AN000;
WHITE_BOX	DB	0,0,0,0 ; Print boxes for APA mode			;AN000;
BLACK_BOX	DB	?,?,?,? ;  NOTE: 1 print box = 1 screen pixel		;AN000;
				;   only BOX_W bytes are used out of these 2	;AN000;
				;    boxes.					;AN000;
										;AN000;
REQ_BAND_MASK	DB	?	; Mask = "All color bands needed for the current;AN000;
				;	   print line".                         ;AN000;
										;AN000;
PRINT_COLOR_BEGIN:								;AN000;
.IF <MODE_TYPE EQ TXT>								;AN000;
.THEN										;AN000;
;-------------------------------------------------------------------------------;AN000;
; The screen is in a text mode: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
  CALL PRINT_COLOR_TXT			; Print a text screen on a color printer;AN000;
.ELSE										;AN000;
;-------------------------------------------------------------------------------;AN000;
; The screen is in All Points Addressable mode: 				;AN000;
; Locate and extract printer DISPLAYMODE information from			;AN000;
; the shared data area. 							;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	LOC_MODE_PRT_INFO	; Get printer info related to curr. mode;AN000;
;										;AN000;
;-------Test if DISPLAYMODE info record was found:				;AN000;
       .IF <ERROR_CODE EQ DISPLAYMODE_INFO_NOT_FOUND>				;AN000;
       .THEN									;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; IF no record found,		;AN000;
	  JMP	  SHORT PRINT_COLOR_END      ; then, return error code		;AN000;
       .ENDIF				     ;	      and quit procedure	;AN000;
;										;AN000;
;-------Get the box size from the DISPLAYMODE info record:			;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset current DISPLAYMODE info.;AN000;
	MOV	AH,[BX].BOX_WIDTH	; Take local copy of the box size.	;AN000;
	MOV	BOX_W,AH		;  in BOX_W and BOX_H			;AN000;
	MOV	AL,[BX].BOX_HEIGHT						;AN000;
	MOV	BOX_H,AL							;AN000;
;										;AN000;
;-------Verify if the box size obtained from DISPLAYMODE info. is valid 	;AN000;
       .IF <ZERO AL> OR 		; IF height of the box is 0		;AN000;
       .IF <ZERO AH>			;  OR width of the box is 0		;AN000;
       .THEN				; THEN we can't print:                  ;AN000;
	  MOV	  ERROR_CODE,UNABLE_TO_PRINT ; return error code		;AN000;
	  JMP	  SHORT PRINT_COLOR_END      ;	     and quit			;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get the Print Orientation from the DISPLAYMODE info record		;AN000;
       .IF <[BX].PRINT_OPTIONS EQ ROTATE>; If printing sideways 		;AN000;
       .THEN				;  then:				;AN000;
	  MOV	  ROTATE_SW,ON		;    Rotate switch := "ON"              ;AN000;
       .ENDIF									;AN000;
  CALL PRINT_COLOR_APA			; Print APA screen on a color printer	;AN000;
.ENDIF										;AN000;
PRINT_COLOR_END:								;AN000;
	RET									;AN000;
PRINT_COLOR ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_COLOR_TXT: PRINT A TEXT MODE SCREEN ON A COLOR PRINTER			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP		     = Offset of the shared data area		;AN000;
;		XLT_TAB 	     = Color translation table			;AN000;
;		SCREEN_WIDTH	     = Maximum length of Screen scan line.	;AN000;
;		SCREEN_HEIGHT	     = Number of SCAN LINES on the screen	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: The screen is read and printed line by line; character by	;AN000;
; character.									;AN000;
; Each line is first scanned in order to determine what colors are present on	;AN000;
; it and what printer bands will be needed to approximate these colors. 	;AN000;
;										;AN000;
; For each printer color band needed for the current line, this screen line	;AN000;
; is READ AGAIN character by character; If the color of the			;AN000;
; current character must use the current color band to be			;AN000;
; approximated; then, the character is printed. 				;AN000;
;										;AN000;
;										;AN000;
; LOGIC :									;AN000;
;										;AN000;
; Save current coordinates of the cursor.					;AN000;
; Initialize the cursor to the first character to be read  (Top-left of screen) ;AN000;
; FOR each row on the screen (SCREEN_HEIGHT)					;AN000;
;   BEGIN									;AN000;
;   CALL SCAN_FOR_BANDS_TXT(CUR_ROW,CUR_COLUMN,REQ_BAND_MASK)			;AN000;
;   CUR_BAND_MASK := 01H							;AN000;
;   IF REQ_BAND_MASK <> 0 THEN							;AN000;
;	DO 8 TIMES								;AN000;
;	 IF (REQ_BAND_MASK AND CUR_BAND_MASK)=1 THEN				;AN000;
;	    CALL PRINT_BAND_TXT(CUR_ROW,CUR_COLUMN,CUR_BAND_MASK)		;AN000;
;	    CALL PRINT_BYTE(CARRIAGE_RETURN)					;AN000;
;	  ENDIF 								;AN000;
;	  Shift CUR_BAND_MASK one bit left					;AN000;
;	ENDDO									;AN000;
;	CALL PRINT_BYTE(LINE_FEED)						;AN000;
;   ENDIF									;AN000;
;   CUR_COLUMN := 0		    ; Get next row coordinates			;AN000;
;   CUR_ROW    := CUR_ROW + 1							;AN000;
;   END ; FOR each row on the screen						;AN000;
; Restore initial coordinates of the cursor					;AN000;
;										;AN000;
PRINT_COLOR_TXT PROC								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
;										;AN000;
;-------Save coordinates of the cursor on the stack:				;AN000;
	MOV	AH,READ_CURSOR_CALL  ; Read position of the cursor on the screen;AN000;
	MOV	BH,CUR_PAGE	     ;	for the current page			;AN000;
	INT	10H		     ; Call BIOS				;AN000;
	PUSH	DX		     ; DH := Row number, DL := Column number	;AN000;
				     ; CX := Top line and bottom line for cursor;AN000;
				     ;	      (not needed)			;AN000;
;										;AN000;
;-------Initialize the cursor to the first character to be read 		;AN000;
	MOV	CUR_ROW,0	     ; cursor = position (0,0) on the screen	;AN000;
	MOV	CUR_COLUMN,0	     ;	(top-left corner)			;AN000;
	CALL	SET_CURSOR							;AN000;
										;AN000;
	MOV	CX,SCREEN_HEIGHT     ; CX := Number of rows on the screen	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR EACH ROW ON THE SCREEN:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_1_TEXT_LINE:								;AN000;
	CALL	SCAN_FOR_BANDS_TXT	; REQ_BAND_MASK := Print bands needed	;AN000;
					;  for this line			;AN000;
	MOV	DL,01H			; DL :="Current Band printed" mask      ;AN000;
										;AN000;
	; NOTE: The COLORSELECT records are stored sequentially in the		;AN000;
	; Shared Data area. The band mask 00000001 corresponds to the first	;AN000;
	; record, 00000010 to the second, etc.					;AN000;
	; The COLORSELECT record indicates: "How to select the color band"      ;AN000;
	; on the printer (It contains the bytes that must be sent to the printer;AN000;
										;AN000;
	MOV	BX,DS:[BP].COLORSELECT_PTR; BX := relative offset of COLORSELECT;AN000;
	ADD	BX,BP			; BX := absolute offset of COLORSELECT	;AN000;
	PUSH	CX			; Save row counter			;AN000;
	MOV	CX,8			; For up to the maximum number of print ;AN000;
					;  bands with this printer		;AN000;
	;-----------------------------------------------------------------------;AN000;
	;									;AN000;
	; FOR each Color Band available with the ribbon installed on the printer;AN000;
	;									;AN000;
	;-----------------------------------------------------------------------;AN000;
	PRINT_1_COLOR_BAND_TXT: 	  ; Do one pass of the printer head:	;AN000;
	 .IF <BIT REQ_BAND_MASK AND DL>   ; IF this color band is needed	;AN000;
	 .THEN				  ;  by any character on the line	;AN000;
	    CALL SET_COLOR_BAND 	  ; then, select the color band 	;AN000;
	    CALL PRINT_BAND_TXT 	  ;    and do one Print Pass for it.	;AN000;
	   .IF	<BIT ERROR_CODE NZ PRINTER_ERROR>				;AN000;
	   .THEN			  ; A printer error occurred:		;AN000;
	      POP     CX		  ;   Restore the line counter		;AN000;
	      JMP     SHORT  PRINT_COLOR_TXT_END ;    and quit.			;AN000;
	   .ENDIF								;AN000;
	    MOV     AL,CR		  ;    Print a carriage return		;AN000;
	    CALL    PRINT_BYTE							;AN000;
	   .IF	C								;AN000;
	   .THEN			  ; A printer error occurred:		;AN000;
	      POP     CX		  ;   Restore the line counter		;AN000;
	      JMP     SHORT    PRINT_COLOR_TXT_END ;    and quit.			;AN000;
	   .ENDIF			  ; ENDIF printer error 		;AN000;
	 .ENDIF 			  ; ENDIF this color band is needed	;AN000;
	  SHL	  DL,1			  ; Get next Color Band mask		;AN000;
					  ; [BX] := Next COLORSELECT record:	;AN000;
	  MOV	  AL,[BX].NUM_SELECT_ESC  ;	skip the escape bytes		;AN000;
	  XOR	  AH,AH 		  ;					;AN000;
	  ADD	  BX,AX 		  ;					;AN000;
	  INC	  BX			  ;	skip the NUM_SELECT_ESC field	;AN000;
	LOOP	PRINT_1_COLOR_BAND_TXT						;AN000;
	POP	CX			  ; Restore row counter 		;AN000;
;										;AN000;
;-----Print a line feed:							;AN000;
	MOV	AL,LF								;AN000;
	CALL	PRINT_BYTE		; Send the LF				;AN000;
	JC	PRINT_COLOR_TXT_END	; If printer error, quit		;AN000;
;										;AN000;
;-------Get coordinates of the first character in the next scan line:		;AN000;
	INC	CUR_ROW 		;   CUR_ROW + 1 			;AN000;
	MOV	CUR_COLUMN,0		;   CUR_COLUMN := 0			;AN000;
;										;AN000;
;-------Point CURSOR to first character in the next scan line:			;AN000;
	CALL	SET_CURSOR							;AN000;
										;AN000;
	LOOP	PRINT_1_TEXT_LINE	; Print next scan line			;AN000;
										;AN000;
;										;AN000;
;-------Restore CURSOR to its original location (saved on the stack)		;AN000;
PRINT_COLOR_TXT_END:								;AN000;
	POP	DX			; DH := Row number, DL := Column number ;AN000;
	MOV	CL,DH								;AN000;
	MOV	CUR_ROW,CX		; CUR_ROW := Original row number	;AN000;
	MOV	CL,DL								;AN000;
	MOV	CUR_COLUMN,CX		; CUR_COLUMN := Original column number	;AN000;
	CALL	SET_CURSOR		; Set the cursor back there		;AN000;
										;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
PRINT_COLOR_TXT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SCAN_FOR_BANDS_TEXT: DETERMINE WHAT PRINTER COLOR BANDS ARE NEEDED FOR	;AN000;
;			PRINTING THE COLORS ON THE CURRENT SCREEN LINE. 	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; INPUT:  CUR_ROW	      = row to start scanning				;AN000;
;	  CUR_COLUMN	      = column to start scanning			;AN000;
;	  ROTATE_SW	      = ON if printing is sideways			;AN000;
;										;AN000;
; OUTPUT: REQ_BAND_MASK 							;AN000;
;										;AN000;
;										;AN000;
; DATA STRUCTURE REFERENCED:							;AN000;
;	  XLT_TAB	     = Color translation table				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Read all characters on the current line from left to right.	;AN000;
; For each character, extract its band mask from the color translation table.	;AN000;
; Add the band mask required for this character to the "Required Bands" mask.   ;AN000;
;										;AN000;
; LOGIC :									;AN000;
; Save current coordinates							;AN000;
; DO (SCREEN_WIDTH) TIMES							;AN000;
;   Read a character								;AN000;
;   Get its Band Mask from the color translation table in AL			;AN000;
;   OR REQ_BAND_MASK,AL 	; Add its band mask to the "Required bands" mask;AN000;
;   ; Get coordinates of the next character:					;AN000;
;   INC CUR_COLUMN								;AN000;
; Restore initial coordinates							;AN000;
;										;AN000;
SCAN_FOR_BANDS_TXT PROC NEAR							;AN000;
	PUSH	CUR_ROW 		; Save coordinates			;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	REQ_BAND_MASK,0 	; No Color bands needed so far...	;AN000;
	MOV	CX,SCREEN_WIDTH 	; For each character on the screen row	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; FOR each character on the current scan line:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SCAN_1_CHAR:									;AN000;
;										;AN000;
;-------Read the character at the current cursor position			;AN000;
	CALL	SET_CURSOR		; Set cursor at character to be read	;AN000;
	MOV	AH,READ_CHAR_CALL	; Read one character			;AN000;
	MOV	BH,CUR_PAGE		;  at CUR_PAGE, CUR_COLUMN and CUR_ROW	;AN000;
	INT	10H			; Call BIOS				;AN000;
					; AL:=Character read, AH:=Byte attribute;AN000;
	AND	AH,00001111B		; AH := Foreground color attribute	;AN000;
	XCHG	AL,AH			; AL := AH, used as index in the XLT_TAB;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	XLAT	XLT_TAB 		; AL  = Band mask			;AN000;
;										;AN000;
;-------Obtain what Print bands are required to print the color of this char:	;AN000;
	OR	REQ_BAND_MASK,AL						;AN000;
										;AN000;
	INC	CUR_COLUMN		; Get coordinates of next character	;AN000;
	LOOP	SCAN_1_CHAR		; Scan next character			;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore initial coordinates		;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
SCAN_FOR_BANDS_TXT ENDP 							;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;   PRINT_BAND_TXT: PRINT ALL CHARACTERS ON THE CURRENT LINE THAT ARE THE SAME ;AN000;
;;		     COLOR AS THE CURRENT PRINT BAND.				;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  INPUT:  CUR_ROW,								;AN000;
;	   CUR_COLUMN	  : Coordinates of the first character to be read in	;AN000;
;			    the current scan line.				;AN000;
;	   DL		  : Band mask indicating what print band to use 	;AN000;
;			    for this print pass.				;AN000;
;	   SCAN_LINE_LENGTH: Length of the current scan line.			;AN000;
;										;AN000;
;  OUTPUT: PRINTER								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; LOGIC:									;AN000;
;    DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;      CALL BIOS INT 10H Read Character - returns CHAR, COLOR_NUM		;AN000;
;      IF (CUR_BAND_MASK AND XLAT_TAB[COLOR_NUM])=1				;AN000;
;      THEN IF Background color is same as Foreground color			;AN000;
;	    THEN								;AN000;
;	      CALL PRINT_BYTE(SOLID_BOX)					;AN000;
;	    ELSE								;AN000;
;	      CALL PRINT_BYTE(CHAR)						;AN000;
;      ELSE									;AN000;
;	 CALL PRINT_BYTE(blank) 						;AN000;
;      Get coordinates of the next character					;AN000;
;										;AN000;
PRINT_BAND_TXT PROC								;AN000;
SOLID_BOX	EQU	219	; ASCII Code for printing a solid box		;AN000;
BLANK		EQU	32	; ASCII code for printing a space		;AN000;
	PUSH	CUR_COLUMN	; Save column number				;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	MOV	CX,SCREEN_WIDTH ; CX := Number of character on one screen row	;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each character on the current row:					;AN000;
;										;AN000;
;===============================================================================;AN000;
PRINT_1_CHAR:									;AN000;
;										;AN000;
;-------Read the character at the current cursor position			;AN000;
	CALL	SET_CURSOR		; Set cursor at character to be read	;AN000;
	MOV	AH,READ_CHAR_CALL	; Read one character			;AN000;
	MOV	BH,CUR_PAGE		;  at CUR_PAGE, CUR_COLUMN and CUR_ROW	;AN000;
	INT	10H			; Call BIOS				;AN000;
					; AL:=Character read, AH:=Byte attribute;AN000;
	MOV	CUR_CHAR,AL							;AN000;
	MOV	DH,AH			; DH := Byte attribute			;AN000;
	AND	DH,11110000B		; DH := Background color		;AN000;
	SHR	DH,1			; DH := Background color right justified;AN000;
	SHR	DH,1								;AN000;
	SHR	DH,1								;AN000;
	SHR	DH,1								;AN000;
	AND	AH,00001111B		; AH := Foreground color right justified;AN000;
;										;AN000;
;-------Test if this character should be printed (need color of the current band;AN000;
	MOV	AL,AH			; AL:=color used as index in the XLT_TAB;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask (DL=current band mask);AN000;
       .IF     <BIT AL AND DL>		;If needs this band to print the color	;AN000;
       .THEN				; of this character			;AN000;
	 .IF	 <AH EQ DH>		; then: when foreground = background	;AN000;
	 .THEN				;	send a solid box		;AN000;
	    MOV     AL,SOLID_BOX	;					;AN000;
	 .ELSE				;	when foreground <> background	;AN000;
	    MOV     AL,CUR_CHAR 	;	send the character		;AN000;
	 .ENDIF 			; Endif foreground = background 	;AN000;
       .ELSE				; else: send a blank			;AN000;
	  MOV	  AL,BLANK		;					;AN000;
       .ENDIF				; Endif color band needed		;AN000;
	CALL	PRINT_BYTE		; Print the byte			;AN000;
	JC	PRINT_BAND_TXT_END	; If printer error occurred: QUIT	;AN000;
	INC CUR_COLUMN			; Else, Get next column; keep going	;AN000;
	LOOP	PRINT_1_CHAR							;AN000;
										;AN000;
PRINT_BAND_TXT_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore column number 		;AN000;
	RET									;AN000;
CUR_CHAR	DB ?								;AN000;
PRINT_BAND_TXT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_COLOR_APA: PRINT AN APA MODE SCREEN ON A COLOR PRINTER			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP	 = Offset of the shared data area			;AN000;
;		XLT_TAB  = Color translation table				;AN000;
;		CUR_MODE_PTR = Coordinates of current DISPLAYMODE info. 	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Each pixel on the screen is printed as a "box" of dots on the    ;AN000;
; printer. For a screen pixel of a given color, the best color approximation	;AN000;
; is chosen among the color available on the printer.				;AN000;
;										;AN000;
; The printer colors are obtained by selecting a print band. A few more printer ;AN000;
; color are obtained by printing twice (or more times) with different color	;AN000;
; bands.									;AN000;
;										;AN000;
; For example, let's say we have a ribbon on the printer with a YELLOW CYAN     ;AN000;
; MAGENTA ribbon and we read a GREEN pixel on the screen.			;AN000;
;										;AN000;
;   We first determine what "box" size will be used to represent this pixel.    ;AN000;
;   Let's say it's a 3x2 box (this is obtained from the DISPLAYMODE record)     ;AN000;
;   In all cases, we will print this pixel as a 3x2 box of printer dots.	;AN000;
;   That is, we will print 6 dots on the printer for one on the screen. 	;AN000;
;   We do not use any kind of patterns (e,g,. printing only 2 dots out of 6)	;AN000;
;   for printing on the color printer. A screen pixel is either printed 	;AN000;
;   as a "full" box of printer dots or not printed at all (e,g,. if it's white).;AN000;
;										;AN000;
;   Now, from the COLORPRINT records, we know all the colors availables on the	;AN000;
;   printer, and what print bands must be used (or overlaid) in order to	;AN000;
;   obtain them.								;AN000;
;										;AN000;
;   So, we consult these COLORPRINT records one by one comparing how close	;AN000;
;   the color of each of them is to our GREEN pixel. (the colors for our pixel	;AN000;
;   AND for the printer color are both indicated in terms of RGB values)	;AN000;
;   WE PICK THE CLOSEST PRINTER COLOR.						;AN000;
;										;AN000;
;   To conclude, our GREEN pixel will be printed by first selecting the YELLOW	;AN000;
;   band, then sending to the printer a "box".  Then, the BLUE band is selected ;AN000;
;   and the "box" is sent again.                                                ;AN000;
;										;AN000;
; This process is carried line by line. 					;AN000;
;										;AN000;
; For each line, we first read each pixel to see what color bands are going	;AN000;
; to be needed for this line.							;AN000;
;										;AN000;
; Then, we loop for each band available on the printer. 			;AN000;
;										;AN000;
; IF the current line needs the current printer band (i.e.,if any pixel on	;AN000;
;  the line needs this color band in order to achieve its color.		;AN000;
; THEN, we select this color band (we know how to do it from the COLORSELECT	;AN000;
;	record in the Shared Data area) 					;AN000;
;	AND we must read the line again; for each pixel that needs the current	;AN000;
;	band  a "box" is sent to the printer.                                   ;AN000;
;										;AN000;
; LOGIC :									;AN000;
;     CALL INIT_BLACK_BOX		; Initialize a print box		;AN000;
;     CALL GET_SCREEN_INFO							;AN000;
;     CALL SETUP_PRT								;AN000;
;     DO (NB_SCAN_LINES) TIMES							;AN000;
;	  CALL DET_CUR_SCAN_LNE_LENGTH						;AN000;
;	  IF CUR_SCAN_LNE_LENGTH NE 0 THEN					;AN000;
;	    CALL SCAN_FOR_BANDS_APA(CUR_ROW,CUR_COLUMN,REQ_BAND_MASK)		;AN000;
;	    CUR_BAND_MASK := 01H						;AN000;
;	    IF REQ_BAND_MASK <> 0 THEN						;AN000;
;	       DO 8 TIMES							;AN000;
;		  IF (REQ_BAND_MASK AND CUR_BAND_MASK)=1 THEN			;AN000;
;		     CALL NEW_PRT_LINE						;AN000;
;		     CALL PRINT_BAND_APA(CUR_ROW,CUR_COLUMN,CUR_BAND_MASK)	;AN000;
;		     CALL PRINT_BYTE(CARRIAGE_RETURN)				;AN000;
;		  ENDIF 							;AN000;
;		  Shift CUR_BAND_MASK one bit left				;AN000;
;	       ENDDO								;AN000;
;	    ENDIF ; Should make a print pass for this color band		;AN000;
;	    CALL PRINT_BYTE(LINE_FEED)						;AN000;
;	  ENDIF ; Current scan line is not empty				;AN000;
;	  IF rotated print THEN 						;AN000;
;	     CUR_COLUMN := CUR_COLUMN - BOXES_PER_PRT_BUF			;AN000;
;	     CUR_ROW := SAVE_START_ROW						;AN000;
;	  ELSE									;AN000;
;	     CUR_ROW := CUR_ROW + BOXES_PER_PRT_BUF				;AN000;
;	     CUR_COLUMN := SAVE_START_COLUMN					;AN000;
;	  ENDIF 								;AN000;
;     ENDDO ; Number of Scan lines						;AN000;
;     CALL RESTORE_PRT								;AN000;
;										;AN000;
PRINT_COLOR_APA PROC								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
										;AN000;
;-------Initialize print box (A "box" represents one screen pel on the printer) ;AN000;
	CALL INIT_BLACK_BOX							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  Determine where to start reading the screen: 				;AN000;
;    If printing sideways, start in LOW LEFT corner.				;AN000;
;    If normal printing, start in TOP LEFT corner.				;AN000;
;  Determine the maximum length for a scan line:				;AN000;
;    If printing sideways, it is the height of the screen.			;AN000;
;    For normal printing, it is the width of the screen.			;AN000;
;  Determine the number of scan lines on the screen.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	GET_SCREEN_INFO 	; Get info. about how to read the screen;AN000;
	CALL	SETUP_PRT		; Set up the printer (Line spacing, etc);AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: quit	;AN000;
	  JMP	  SHORT  PRINT_COLOR_APA_END	;					;AN000;
       .ENDIF									;AN000;
										;AN000;
	MOV	CX,NB_SCAN_LINES						;AN000;
;----------------------------------------------------------------------------	;AN000;
;										;AN000;
; FOR EACH SCAN LINE ON THE SCREEN (and each print line):			;AN000;
;										;AN000;
;----------------------------------------------------------------------------	;AN000;
PRINT_SCAN_LINE:								;AN000;
	CALL	DET_CUR_SCAN_LNE_LENGTH ; Determine length of the scan line	;AN000;
       .IF <CUR_SCAN_LNE_LENGTH NE 0>	; If line is not empty			;AN000;
       .THEN									;AN000;
	  CALL	  SCAN_FOR_BANDS_APA	  ; REQ_BAND_MASK := Mask for what print;AN000;
					  ;  bands are needed.			;AN000;
	  MOV	  DL,01H		  ; DL := "Current Band to be printed"  ;AN000;
	  MOV	  BX,DS:[BP].COLORSELECT_PTR; BX := Offset of COLORSELECT record;AN000;
	  ADD	  BX,BP 		  ;	("How to select the color band");AN000;
	  PUSH	  CX			  ; Save scan line counter		;AN000;
	  MOV	  CX,8			  ; For up to the maximum number of prin;AN000;
					  ;  bands with this printer		;AN000;
	  ;---------------------------------------------------------------------;AN000;
	  ;									;AN000;
	  ; FOR each Color Band needed: 					;AN000;
	  ;									;AN000;
	  ;---------------------------------------------------------------------;AN000;
       PRINT_1_COLOR_BAND_APA:		  ; Only if this color band is needed:	;AN000;
	   .IF <BIT REQ_BAND_MASK AND DL> ;   Do one pass of the printer head	;AN000;
	   .THEN			  ;					;AN000;
	      CALL    SET_COLOR_BAND	  ; Select the color band on the printer;AN000;
	      CALL    NEW_PRT_LINE	  ; Send escape sequence to the printer ;AN000;
					  ;  for starting a new graphics line	;AN000;
	     .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>				;AN000;
	     .THEN			  ; A printer error occurred:		;AN000;
		POP   CX		  ; Restore the line counter and	;AN000;
		JMP   SHORT  PRINT_COLOR_APA_END ;  return				;AN000;
	     .ENDIF			  ; Endif printer error occurred	;AN000;
										;AN000;
	      CALL PRINT_BAND_APA	  ; Do one Print Pass for current band	;AN000;
	      MOV     AL,CR		  ;   Print a carriage return		;AN000;
	      CALL    PRINT_BYTE						;AN000;
	     .IF      C 		  ; If a printer error occurred 	;AN000;
	     .THEN								;AN000;
		POP   CX		  ; Restore the line counter and	;AN000;
		JMP   SHORT  PRINT_COLOR_APA_END ;  return				;AN000;
	     .ENDIF			  ; End if printer error occurred	;AN000;
	   .ENDIF			  ; End if this color band is needed	;AN000;
	    SHL     DL,1		  ; Get next Color Band mask		;AN000;
					  ; Locate next COLORSELECT record:	;AN000;
	    MOV     AL,[BX].NUM_SELECT_ESC;  skip the escape bytes		;AN000;
	    XOR     AH,AH							;AN000;
	    ADD     BX,AX							;AN000;
	    INC     BX			  ;  skip the NUM_SELECT_ESC field	;AN000;
	  LOOP	  PRINT_1_COLOR_BAND_APA					;AN000;
	  POP	  CX			  ; Restore scan line counter		;AN000;
       .ENDIF ; Scan line length <> 0						;AN000;
;										;AN000;
;-----Print a line feed:							;AN000;
	MOV	AL,LF								;AN000;
	CALL	PRINT_BYTE							;AN000;
	JC	PRINT_COLOR_APA_END	  ; If a printer error occurred: quit	;AN000;
;										;AN000;
;-------Get coordinates of next scan line:					;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then: 				;AN000;
	  MOV	  AL,NB_BOXES_PER_PRT_BUF;  AX := Numbers of pels read on row	;AN000;
	  CBW				;					;AN000;
	  ADD	  CUR_COLUMN,AX 	;   CUR_COLUMN + Number of pels read	;AN000;
	  MOV	  AX,SCREEN_HEIGHT	;   CUR_ROW := SCREEN_HEIGHT - 1	;AN000;
	  DEC	  AX			;					;AN000;
	  MOV	  CUR_ROW,AX		;					;AN000;
       .ELSE				; else, printing NOT rotated:		;AN000;
	  MOV	  AL,NB_BOXES_PER_PRT_BUF ; AX := Number of pels read on column ;AN000;
	  CBW				;					;AN000;
	  ADD	  CUR_ROW,AX		;   CUR_ROW + Number of pels read	;AN000;
	  MOV	  CUR_COLUMN,0		;   CUR_COLUMN := 0			;AN000;
       .ENDIF				; End if printing sideways		;AN000;
	LOOP	PRINT_SCAN_LINE 	;					;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Restore the printer (send a Page Eject, etc.) 				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	RESTORE_PRT							;AN000;
PRINT_COLOR_APA_END:								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_COLOR_APA ENDP								;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;										;AN000;
;;   SCAN_FOR_BANDS_APA : DETERMINE WHAT PRINT BANDS ARE NEEDED FOR THE CURRENT ;AN000;
;;			  PRINT PASS.						;AN000;
;;										;AN000;
;;------------------------------------------------------------------------------;AN000;
;										;AN000;
; INPUT:  CUR_ROW	      : row to start scanning	(word)			;AN000;
;	  CUR_COLUMN	      : column to start scanning (word) 		;AN000;
;	  CUR_SCAN_LNE_LENGTH : length of the current scan line (word)		;AN000;
;	  ROTATE_SW	      = ON if printing is sideways			;AN000;
;										;AN000;
; OUTPUT: REQ_BAND_MASK       : band mask for required bands (byte)		;AN000;
;										;AN000;
;;------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Print Info 								;AN000;
;;   Color Translate Table							;AN000;
;;										;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Read all the dots required for one print line to determine 		;AN000;
;;   the print bands required.	The print line corresponds to several		;AN000;
;;   screen rows (or columns if rotated printing).  The number of		;AN000;
;;   rows / columns per print line is stored in NB_BOXES_PER_PRT_BUF.		;AN000;
;;   The band information is obtained from the Color Translate Table.		;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_COLOR_APA								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   READ_DOT, BIOS INT 10H							;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   Save initial coordinates							;AN000;
;;   SAVE_START_COLUMN := CUR_COLUMN						;AN000;
;;   REQ_BAND_MASK := 00H							;AN000;
;;   DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;;	Save coordinates of the "column"                                        ;AN000;
;;	DO (BOXES_PER_PRT_BUF) TIMES						;AN000;
;;	  CALL READ_DOT(IN CUR_ROW,CUR_COLUMN; OUT COLOR_NUM)			;AN000;
;;	   REQ_BAND_MASK := REQ_BAND_MASK OR COLOR_XLAT_TAB[BX] 		;AN000;
;;	   IF rotated print THEN						;AN000;
;;	      Increment CUR_COLUMN						;AN000;
;;	   ELSE 								;AN000;
;;	      Increment CUR_ROW 						;AN000;
;;	   ENDIF								;AN000;
;;	Restore coordinates of the "column"                                     ;AN000;
;;	ENDDO									;AN000;
;;	IF rotated print THEN							;AN000;
;;	   Decrement CUR_ROW							;AN000;
;;	ELSE									;AN000;
;;	   Increment CUR_COLUMN 						;AN000;
;;	ENDIF									;AN000;
;;   ENDDO									;AN000;
;;   Restore initial coordinates						;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	;AN000;
SCAN_FOR_BANDS_APA PROC NEAR							;AN000;
	PUSH	CUR_ROW 							;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	REQ_BAND_MASK,0 	; No Color bands needed so far...	;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	MOV	CX,CUR_SCAN_LNE_LENGTH						;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non=blank):		;AN000;
;										;AN000;
;===============================================================================;AN000;
SCAN_1_COLUMN:									;AN000;
	PUSH	CX			; Save column counter			;AN000;
	PUSH	CUR_ROW 		; Save coordinates of the "column"      ;AN000;
	PUSH	CUR_COLUMN							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	XOR	CX,CX			; CX := Number of pixels to read	;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF ;   within the current "column"         ;AN000;
SCAN_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask			;AN000;
	OR	REQ_BAND_MASK,AL	; Add bands required for this pixel	;AN000;
										;AN000;
;-------Get coordinates of next pixel:						;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  INC CUR_COLUMN		; then, increment column number 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_ROW			; else, increment row number		;AN000;
       .ENDIF				;					;AN000;
	LOOP SCAN_1_PIXEL							;AN000;
	POP	CUR_COLUMN		; Restore coordinates of the "column"   ;AN000;
	POP	CUR_ROW 		;					;AN000;
	POP	CX			; Restore column counter		;AN000;
										;AN000;
										;AN000;
;-------Get coordinates of next "column":                                       ;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  DEC CUR_ROW			; then, get row above on screen 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_COLUMN		; else, get column next right		;AN000;
       .ENDIF				;					;AN000;
	LOOP	SCAN_1_COLUMN							;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN							;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
SCAN_FOR_BANDS_APA ENDP 							;AN000;
PAGE										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
;;										;AN000;
;;   PRINT_BAND_APA : PRINT ALL DOTS ON CURRENT LINE THAT NEED THE CURRENT BAND ;AN000;
;;		      TO APPROXIMATE THEIR COLOR.				;AN000;
;;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;  INPUT:  CUR_ROW,								;AN000;
;	   CUR_COLUMN	  : Coordinates of the first pixel to be read in the	;AN000;
;			    current scan line.					;AN000;
;	   DL		  : Band mask indicating what print band to use 	;AN000;
;			    for this print pass.				;AN000;
;	   CUR_SCAN_LNE_LENGTH: Length of the current scan line.		;AN000;
;	   ROTATE_SW	   = ON if printing is sideways 			;AN000;
;										;AN000;
;  OUTPUT: PRINTER								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Print Info 								;AN000;
;;   Color Translate Table							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Print all dots on this print line which need the current			;AN000;
;;   band. The print line corresponds to several				;AN000;
;;   screen rows (or columns if rotated printing).  The number of		;AN000;
;;   rows / columns per print line is stored in NB_BOXES_PER_PRT_BUF.		;AN000;
;;   The band information is obtained from the Color Translate Table.		;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   PRINT_COLOR_APA								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   READ_DOT, BIOS INT 10H, STORE_BOX, PRT_BUFFER, PRINT_BYTE			;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   SAVE_START_ROW := CUR_ROW							;AN000;
;;   SAVE_START_COLUMN := CUR_COLUMN						;AN000;
;;										;AN000;
;;   CALL SET_COLOR_BAND	; Select the color for this print pass		;AN000;
;;   DO (SCAN_LINE_LENGTH) TIMES						;AN000;
;;	Save coordinates of the "column"                                        ;AN000;
;;	Clear the print buffer							;AN000;
;;	DO (BOXES_PER_PRT_BUF) TIMES						;AN000;
;;	   CALL READ_DOT(CUR_ROW,CUR_COLUMN,COLOR_NUM)				;AN000;
;;	   IF (CUR_BAND_MASK AND XLAT_TAB[COLOR_NUM])=1 THEN			;AN000;
;;	      CALL STORE_BOX(black box) 					;AN000;
;;	   ELSE 								;AN000;
;;	      CALL STORE_BOX(white box) 					;AN000;
;;	   ENDIF								;AN000;
;;	   IF rotated print THEN						;AN000;
;;	      Decrement CUR_COLUMN						;AN000;
;;	   ELSE 								;AN000;
;;	      Increment CUR_ROW 						;AN000;
;;	   ENDIF								;AN000;
;;	ENDDO									;AN000;
;;	CALL PRINT_BUFFER							;AN000;
;;	Restore coordinates of the "column"                                     ;AN000;
;;	; Get coordinates of the next "column";                                 ;AN000;
;;	IF rotated print THEN							;AN000;
;;	   Decrement CUR_ROW							;AN000;
;;	   CUR_COLUMN := SAVE_START_COLUMN					;AN000;
;;	ELSE									;AN000;
;;	   Increment CUR_COLUMN 						;AN000;
;;	   CUR_ROW := SAVE_START_ROW						;AN000;
;;	ENDIF									;AN000;
;;   ENDDO									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AN000;
PRINT_BAND_APA	    PROC NEAR							;AN000;
	PUSH	CUR_ROW 		; Save coordinates			;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of translation table	;AN000;
	MOV	CX,CUR_SCAN_LNE_LENGTH						;AN000;
;===============================================================================;AN000;
;										;AN000;
; FOR each column on the current scan line (up to the last non=blank):		;AN000;
; (One "column" contains the number of pixels required to fill the Print buffer);AN000;
;										;AN000;
;===============================================================================;AN000;
PRINT_1_COLUMN: 								;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Clear the print buffer "PRT_BUF"                                              ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	XOR	DI,DI		; DI := Number of bytes cleared in the buffer	;AN000;
	XOR	AX,AX								;AN000;
	MOV	AL,BOX_W	; AX := Number of bytes in the print buffer	;AN000;
CLEAR_BUF:			; For each byte in the PRT_BUF: 		;AN000;
	MOV	PRT_BUF[DI],0	;    Initialize byte to blanks			;AN000;
	INC	DI		;    One more has been cleared			;AN000;
	CMP	DI,AX		;    All bytes cleared ?			;AN000;
	JL	CLEAR_BUF	;	 No, clear next one.			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Fill up the print buffer "PRT_BUF"                                            ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	PUSH	CX			; Save column counter			;AN000;
	XOR	CX,CX			; CX := Number of pixels to read	;AN000;
	MOV	CL,NB_BOXES_PER_PRT_BUF ;   within the current "column"         ;AN000;
					;    of the scan line			;AN000;
	PUSH	CUR_ROW 		; Save coordinates of the "column"      ;AN000;
	PUSH	CUR_COLUMN							;AN000;
;										;AN000;
; For each pixel within the current column of the scan line:			;AN000;
STORE_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask			;AN000;
       .IF <BIT AL AND DL>		; If color of the current pixel needs	;AN000;
       .THEN				;  the current printer band		;AN000;
	  MOV	SI,OFFSET BLACK_BOX	; then, store a box in the		;AN000;
	  CALL STORE_BOX		;	 PRT_BUF			;AN000;
       .ELSE				;					;AN000;
	  MOV	SI,OFFSET WHITE_BOX	;  else, store an empty box		;AN000;
	  CALL STORE_BOX		;	  in the PRT_BUF		;AN000;
       .ENDIF									;AN000;
;										;AN000;
;-------Get coordinates of next pixel:						;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  INC CUR_COLUMN		; then, increment column number 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_ROW			; else, increment row number		;AN000;
       .ENDIF				;					;AN000;
	LOOP STORE_1_PIXEL							;AN000;
										;AN000;
	POP	CUR_COLUMN		; Restore coordinates of the "column"   ;AN000;
	POP	CUR_ROW 		;					;AN000;
	POP	CX			; Restore column counter		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Print the PRT_BUF:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	CALL	PRINT_BUFFER							;AN000;
       .IF  <BIT ERROR_CODE NZ PRINTER_ERROR>					;AN000;
       .THEN				; A printer error occurred: QUIT	;AN000;
	  JMP SHORT PRINT_BAND_APA_END	;					;AN000;
       .ENDIF									;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Get coordinates of next "column":                                             ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				;					;AN000;
	  DEC CUR_ROW			; then, get row above on screen 	;AN000;
       .ELSE				;					;AN000;
	  INC CUR_COLUMN		; else, get column next right		;AN000;
       .ENDIF				;					;AN000;
	LOOP	PRINT_1_COLUMN							;AN000;
										;AN000;
PRINT_BAND_APA_END:								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	POP	CUR_COLUMN		; Restore initial coordinates		;AN000;
	POP	CUR_ROW 							;AN000;
	RET									;AN000;
PRINT_BAND_APA	ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SET_CURSOR : SET THE CURSOR TO CUR_ROW, CUR_COLUMN AND CUR_PAGE		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_ROW,							;AN000;
;		CUR_COLUMN  = Coordinates for the cursor (word) 		;AN000;
;		CUR_PAGE    = Page for which to set the cursor (byte)		;AN000;
;										;AN000;
;	OUTPUT: SCREEN								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SET_CURSOR PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
	MOV	DH,BYTE PTR CUR_ROW						;AN000;
	MOV	DL,BYTE PTR CUR_COLUMN						;AN000;
	MOV	BH,CUR_PAGE							;AN000;
	MOV	AH,SET_CURSOR_CALL	; Set cursor request			;AN000;
	INT	10H			; Call BIOS				;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SET_CURSOR ENDP 								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SET_COLOR_BAND : SET THE PRINTER TO THE CURRENT COLOR BAND			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: BX	= Offset of current COLORSELECT record in the		;AN000;
;			  Shared data area.					;AN000;
;	       DS:[BP]	= Offset of shared data area				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SET_COLOR_BAND PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------Send the escape sequence for selecting this color band to the printer:	;AN000;
	XOR	CX,CX								;AN000;
	MOV	CL,[BX].NUM_SELECT_ESC	; CX := Number of bytes to send 	;AN000;
	ADD	BX,OFFSET SELECT_ESC	; BX := Offset of bytes to send 	;AN000;
SEND_1_COLORSELECT_BYTE:							;AN000;
	MOV	AL,[BX] 		; AL := Byte to send to printer 	;AN000;
	CALL	PRINT_BYTE		; Send it				;AN000;
	JC	SET_COLOR_BAND_END	; If printer error: return		;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_COLORSELECT_BYTE 					;AN000;
										;AN000;
SET_COLOR_BAND_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SET_COLOR_BAND ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; INIT_BLACK_BOX: INIT. THE BOX FOR PRINTING APA MODE DOTS ON A COLOR PRINTER.	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BOX_W,								;AN000;
;		BOX_H		= Size of the print box for one pixel.		;AN000;
;										;AN000;
;	OUTPUT: BLACK_BOX	= A box for which all dots are on.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Initialize the print box used to print a screen pixel.		;AN000;
;										;AN000;
; For example,									;AN000;
; with a size of 3x2 the BLACK_BOX will use 3 bytes:				;AN000;
;										;AN000;
;										;AN000;
;	  byte1     byte2     byte3						;AN000;
;	(column1) (column2) (column3)						;AN000;
;  bit 7 -->0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    0	       0	 0						;AN000;
;	    1	       1	 1						;AN000;
;  bit 0 -->1	       1	 1						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
INIT_BLACK_BOX PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
;-------Build one box column:							;AN000;
	XOR	CX,CX								;AN000;
	MOV	CL,BOX_H	; CX := Height in bits of the print box 	;AN000;
	XOR	AL,AL		; AX := Bit mask for creating box column	;AN000;
       .REPEAT			; For height of the box:			;AN000;
	  SHL	  AL,1		;						;AN000;
	  OR	  AL,1		;   Insert one bit in the box column		;AN000;
       .LOOP									;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	AL now contains one box column. 					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
;-------Replicate this column over all columns of the box.			;AN000;
	XOR	BX,BX		; BX := Index into the BOX			;AN000;
INIT_1_BLACK_COLUMN:								;AN000;
	MOV	BLACK_BOX[BX],AL; Init current column to black box column	;AN000;
	INC	BX		; Get next column				;AN000;
	CMP	BL,BOX_W							;AN000;
	JL	INIT_1_BLACK_COLUMN						;AN000;
										;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
INIT_BLACK_BOX ENDP								;AN000;
INCLUDE GRCOMMON.ASM								;AN000;
LEN_OF_COLOR_MODULES EQU $-PRINT_COLOR						;AN000;
CODE	ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabpar.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;A2
	TITLE	GRTABPAR.SAL - LOOK AT COMMAND LINE PARMS ;
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: GRTABPAR.SAL

; DESCRIPTIVE NAME: Handle the definition of the DOS command line parameters
;		    and the interface to the DOS system PARSER.

;FUNCTION: The static data areas are prescribed by the DOS system PARSER
;	   to define the several parameters presented to GRAFTABL.  These
;	   data areas are passed to the PARSER, and its responses checked
;	   to determine the nature of the user's specifications.  Any errors
;	   found in the user's parameters are defined in messages back
;	   to the user.

; ENTRY POINT: PARSER, near

; INPUT: (DOS COMMAND LINE PARAMETERS)

;	      [d:][path] GRAFTABL  [cp|?|/STA|/STATUS]

;	 WHERE
;	      [d:][path] - Path where the GRAFTABL command resides.

;	      [cp]	 - Codepage number to be loaded.  If blank,
;			   437 is assumed

;	      [?]	 - This requests a display of the parameters
;			   supported by the GRAFTABL command.

;	      [/STATUS]  - (May be shortened to just /STA.)  This
;			   requests the current codepage already
;			   loaded by a previous GRAFTABL, if any,
;			   be displayed.

;	Upon entry to PARSER in this module,
;	"CURRENT_PARM" = offset to start of parm text in command string
;	"ORDINAL" = initialized to zero
;	PSP+81H = text of DOS command line parms string

; EXIT-NORMAL: If a Code Page number was specified
;		  BX = Offset to language table to be loaded
;		  DX = Integer value of Code Page specified
;	       If /STATUS (or /STA) was specified
;		  BX = 0
;	       If Question mark was specified
;		  BX=-1

; EXIT-ERROR: If there was any problem with the parms,
;	      the question mark is assumed, and the appropriate
;	      PARSE error message is displayed.
;	      The Errorlevel code of "EXPAR" (3), meaning: "PARM ERROR",
;	      set in "EXITFL", is requested to be returned to the user.

; INTERNAL REFERENCES:
;    ROUTINES:
;	PARSE_ERROR:NEAR Display the appropriate Parse error message.

;    DATA AREAS:
;	The several parameter control blocks, defined by the System
;	PARSER interface, defining the GRAFTABL parameters.

; EXTERNAL REFERENCES:
;    ROUTINES:
;	SENDMSG:NEAR	Uses Msg Descriptor to drive message handler.
;	SYSPARSE:NEAR	System Command Line Common Parser.

;    DATA AREAS:
;	TABLEUS:BYTE	First table of Fonts, happens to be the USA version.
;	  (Format of language Font defined in LANGUAGE STRUC.)
;	EXITFL:BYTE	Errorlevel return code.
;	MSGNUM_PARSE:WORD Message descriptor for all parse errors.
;	ACTIVECPID:WORD Pointer to CPID entry of active entry, where the
;	CPID	table is a set of 4 byte asciiz strings,
;			each defining the number of a Code Page font.

; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:

;		SALUT GRTABPAR,NUL

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 For LINK instructions, refer to the PROLOG of the main module,
;	 GRTAB.SAL.

; REVISION HISTORY:
;	A001 PTM 382 display "ACTIVE" OR "PREVIOUS" CP.
;	A002 PTM 474 Avoid duplicate switches
;	A003 PTM 538 Display parm in error

;****************** END OF SPECIFICATIONS *****************************
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE PATHMAC.INC
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER	MACRO	TEXT
.XLIST
	SUBTTL	TEXT
.LIST
	PAGE
	ENDM
; =  =	=  =  =  =  =  =  =  =	=  =
;		      $SALUT (4,23,28,36)
		      EXTRN CPID_L:ABS ;BYTES PER CPID ENTRY

MSG_DESC	      STRUC	   ;
MSG_NUM 	      DW   ?	   ;MESSAGE NUMBER (TO AX)
MSG_HANDLE	      DW   ?	   ;HANDLE OF OUTPUT DEVICE (TO BX)
MSG_SUBLIST	      DW   ?	   ;POINTER TO SUBLIST (TO SI)
MSG_COUNT	      DW   ?	   ;SUBSTITUTION COUNT (TO CX)
MSG_CLASS	      DW   ?	   ;MESSAGE CLASS (IN HIGH BYTE, TO DH)
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL);
MSG_DESC	      ENDS	   ;

ONE_SUBS	      EQU  1	   ;NUMBER OF VARIABLES

SUBLIST 	      STRUC	   ;
SUB_SIZE	      DB   ?	   ;SUBLIST SIZE (POINTER TO NEXT SUBLIST)
SUB_RES 	      DB   ?	   ;RESERVED
				   ;NEXT FIELD IS TO BE USED AS A DOUBLE WORD
SUB_VALUE	      DW   ?	   ;TIME, DATE, OR PTR TO DATA ITEM
SUB_VALUE_SEG	      DW   ?	   ;SEG ID OF PTR
				   ;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
				   ; IF THIS IS A .COM FILE)
SUB_ID		      DB   ?	   ;N OF %N
SUB_FLAGS	      DB   ?	   ;DATA TYPE FLAGS
SUB_MAX_WIDTH	      DB   ?	   ;MAXIMUM FIELD WIDTH (0=UNLIMITED)
SUB_MIN_WIDTH	      DB   ?	   ;MINIMUM FIELD WIDTH
SUB_PAD_CHAR	      DB   ?	   ;CHARACTER FOR PAD FIELD
				   ; CAN BE " ", "0" OR ",".
				   ; "," CAUSES INSERTION OF THE ACTIVE
				   ; THOUSANDS SEPARATOR BETWEEN EVERY 3 DIGITS.
SUBLIST 	      ENDS	   ;

;		LOCAL EQUATES
ZERO		      EQU  0	   ;COMPARAND FOR MISSING PARMS
RETCODE_QUESTION      EQU  -1	   ;VALUE IN BX, IF PARM=?
RETCODE_PARSE_ERROR   EQU  1	   ; Error during parse
EXPAR		      EQU  3	   ;RETURN TO DOS, INVALID DOS COMND LINE PARMS
CR		      EQU  13	   ;CARRIAGE RETURN
BLANK		      EQU  " "	   ;AVOIDS DUPLICATES SWITCHES
NUL		      EQU  0	   ;ASCIIZ DELIMITER
; =  =	=  =  =  =  =  =  =  =	=  =
;		EXIT CODES FROM SYSPARSE (WHEN CY=0)

SYSPRM_EX_OK	      EQU  0	   ; no error
SYSPRM_EX_MANY	      EQU  1	   ; too many operands
SYSPRM_EX_MISSING     EQU  2	   ; required operand missing
SYSPRM_EX_NOT_SWLIST  EQU  3	   ; not in switch list provided
SYSPRM_EX_NOT_KEYLIST EQU  4	   ; not in keyword list provided
SYSPRM_EX_RANGE       EQU  6	   ; out of range specified
SYSPRM_EX_VALUE       EQU  7	   ; not in value list provided
SYSPRM_EX_STRING      EQU  8	   ; not in string list provided
SYSPRM_EX_SYNTAX      EQU  9	   ; syntax error
SYSPRM_EX_EOL	      EQU  -1	   ; end of command line
; =  =	=  =  =  =  =  =  =  =	=  =
		      HEADER <STRUC - DEFINITIONS OF EXTERNAL CONTROL BLOCKS> ;
LANGUAGE	      STRUC	   ;DEFINITION OF EACH LANGUAGE TABLE
LANCHAR 	      DB   1024 DUP(?) ;8 BYTES PER EACH OF 128 CHARACTERS
LANID		      DW   ?	   ;TWO BYTE CODEPAGE ID, TO MATCH
				   ; GRAFTABL CMD LINE PARM
LANNAME 	      DB   14 DUP(?) ;ASCIIZ STRING NAME OF LANGUAGE
LANGUAGE	      ENDS	   ;
; =  =	=  =  =  =  =  =  =  =	=  =
PSP		      STRUC	   ;
		      DB   80H DUP (?) ;SKIP OVER FIRST HALF OF PSP
PSP_PARMLEN	      DB   ?	   ;NUMBER OF BYTES IN DOS COMMAND LINE
PSP_COMMAND	      DB   127 DUP(?) ;TEXT OF DOS COMMAND LINE
PSP		      ENDS	   ;
; =  =	=  =  =  =  =  =  =  =	=  =
		      HEADER <PARSING WORKAREAS> ;
;	     $SALUT (4,14,19,36)   ;
CSEG	     SEGMENT PARA PUBLIC   ;
	     ASSUME CS:CSEG,DS:CSEG,ES:CSEG,SS:CSEG ;

	     EXTRN SENDMSG:NEAR    ;USES MSG DESCRIPTOR TO DRIVE MESSAGE HANDLR
	     EXTRN SYSPARSE:NEAR   ;SYSTEM COMMAND LINE PARSER

	     EXTRN TABLEUS:BYTE    ;FIRST TABLE OF FONTS
	     EXTRN EXITFL:BYTE	   ;ERRORLEVEL RETURN CODE
	     EXTRN MSGNUM_PARSE:WORD ;MESSAGE DESCRIPTOR FOR ALL PARSE ERRORS
	     EXTRN SUBLIST_PARSE:WORD ;POINTS TO INVALID PARM
	     EXTRN ACTIVECPID:WORD ;POINTER TO CPID ENTRY OF ACTIVE ENTRY
; =  =	=  =  =  =  =  =  =  =	=  =

CURRENT_PARM DW   81H		   ;POINTER INTO COMMAND OF NEXT OPERAND
	     PUBLIC CURRENT_PARM   ;

ORDINAL      DW   0		   ;ORDINAL NUMBER OF WHICH PARM TO PARSE
	     PUBLIC ORDINAL	   ;

FIRST_TIME   DB   0		   ;INDICATES IF A PARM ALREADY FOUND
PARSE_RESULT DW   0		   ;TEMP, HOLDS BX TO BE RETURNED
;	       If a Code Page number was specified
;		  BX = Offset to language table to be loaded
;		  DX = Integer value of Code Page specified
;	       If /STATUS (or /STA) was specified
;		  BX = 0
;	       If Question mark was specified
;		  BX=-1
; =  =	=  =  =  =  =  =  =  =	=  =
	     HEADER <DOS COMMAND LINE PARSER CONTROL BLOCKS> ;

;INPUT PARAMETERS CONTROL BLOCK, POINTED TO BY ES:DI WHEN CALLING PARSER

	     PUBLIC PARMS	   ;LET LINK MAKE PARMS BLOCK ADDRESSABLE
PARMS	     LABEL BYTE 	   ;PARMS CONTROL BLOCK
	     DW   PARMSX	   ;POINTER TO PARMS EXTENSION
	     DB   0		   ; NUMBER OF STRINGS (0, 1, 2)
				   ; NEXT LIST WOULD BE EXTRA DELIM LIST
				   ;  (,& WHITESPACE ALWAYS)
				   ; NEXT LIST WOULD BE EXTRA END OF LINE LIST
				   ;  (CR,LF,0 ALWAYS)

;SYSTEM PARSER PARAMETER EXTENSION CONTROL BLOCK
PARMSX	     LABEL BYTE 	   ;PARMS EXTENSION CONTROL BLOCK
	     DB   0,1		   ; MIN, MAX POSITIONAL OPERANDS ALLOWED
	     DW   CONTROL_POS	   ; DESCRIPTION OF POSITIONAL 1

	     DB   2		   ; MAX SWITCH OPERANDS ALLOWED
	     DW   CONTROL_SW	   ; DESCRIPTION OF SWITCH 1 (/STATUS)
	     DW   CONTROL_SW2	   ;       DESCRIPTION OF SWITCH 2 (/?)

	     DB   0		   ; MAX KEYWORD OPERANDS ALLOWED
				   ; THERE IS NO CONTROL BLOCK
				   ;  DEFINING KEYWORDS

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	     HEADER <POSITIONAL PARM DESCRIPTOR BLOCK> ;
;PARSER CONTROL BLOCK DEFINING THE ONLY POSITIONAL PARAMETER, OPTIONAL

;FIRST POSITIONAL PARAMETER IS:
;	[cp|?]	THE CODEPAGE NUMBER, OR THE QUESTION MARK

	     PUBLIC CONTROL_POS    ;LET LINK MAKE THIS ADDRESSABLE
CONTROL_POS  LABEL BYTE 	   ;FIRST POSITIONAL DESCRIPTOR FOR FILESPEC,
				   ; OPTIONAL
	     DW   2001H 	   ; CONTROLS TYPE MATCHED
				   ; SELECTED BITS: "SIMPLE STRING" AND "OPTIONAL"

				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

	     DW   0000H 	   ;FUNCTION_FLAGS ("NO CAPS")
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END
	     DW   RESULT	   ; RESULT BUFFER
	     DW   VALS		   ; VALUE LISTS
	     DB   0		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;   IN FOLLOWING LIST

;VALUE CONTROL BLOCK FOR THE POSITIONAL PARAMETERS
VALS	     DB   3		   ;NUMBER OF VALS DEFINITIONS (0-3)
	     DB   0		   ;NUMBER OF RANGES (NONE)
	     DB   0		   ;NUMBER OF NUMERIC CHOICES (NONE)
	     DB   6		   ;NUMBER OF CHOICE STRINGS


;THE ORDER OF THESE VALUE DEFINITIONS IS SIGNIFICANT.  THEIR ORDER MUST
;MATCH THE ORDER IN WHICH THE CORRESPONDING FONT TABLE MODULES ARE
;LINKED TOGETHER.  THUE THE "VALUE RETURNED" OF 1 MEANS THE FIRST LINKED
;FONT TABLE, THE VALUE OF 5 MEANS THE FIFTH LINKED FONT TABLE, ETC.

VAL_437      EQU  1		   ;VALUE RETURNED
	     DB   VAL_437	   ; FOR:
	     DW   S437		   ;SPECIFIC CHOICE IF STRING

VAL_850      EQU  2		   ;VALUE RETURNED
	     DB   VAL_850	   ; FOR:
	     DW   S850		   ;SPECIFIC CHOICE IF STRING

VAL_860      EQU  3		   ;VALUE RETURNED
	     DB   VAL_860	   ; FOR:
	     DW   S860		   ;SPECIFIC CHOICE IF STRING

VAL_863      EQU  4		   ;VALUE RETURNED
	     DB   VAL_863	   ; FOR:
	     DW   S863		   ;SPECIFIC CHOICE IF STRING

VAL_865      EQU  5		   ;VALUE RETURNED
	     DB   VAL_865	   ; FOR:
	     DW   S865		   ;SPECIFIC CHOICE IF STRING

VAL_852	     EQU  6		   ;VALUE RETURNED
	     DB   VAL_852	   ; FOR:
	     DW   S852		   ;SPECIFIC CHOICE IF STRING

;		SET OF ASCIIZ STRINGS, DEFINING THE POSITIONAL PARAMETER
S437	     DB   "437",0	   ;USA
S850	     DB   "850",0	   ;MULTI-LINGUAL
S860	     DB   "860",0	   ;PORTUGUESE
S863	     DB   "863",0	   ;CANADIAN FRENCH
S865	     DB   "865",0	   ;NORDIC
S852	     DB   "852",0	   ;LATIN-2

;RESULTS CONTROL BLOCK FOR THE POSITIONAL PARAMETER, AND SWITCH PARAMETER
RESULT	     LABEL BYTE 	   ; BELOW FILLED IN FOR DEFAULTS
	     DB   3		   ; TYPE RETURNED: 0=RESERVED,
				   ;	   1=NUMBER, 2=LIST INDEX,
				   ;	   3=STRING, 4=COMPLEX,
				   ;	   5=FILESPEC, 6=DRIVE
				   ;	   7=DATE, 8=TIME
				   ;	   9=QUOTED STRING
RESULT_TAG   DB   0FFH		   ; MATCHED ITEM TAG
RESULT_SYN   DW   0		   ;POINTER TO SYNONYM

RESULT_PTR   DD   ?		   ;OFFSET OF STRING VALUE

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
	     HEADER <SWITCH PARM DESCRIPTOR BLOCK> ;
;PARSER CONTROL BLOCK DEFINING THE SWITCHES, OPTIONAL

;THE SWITCH IS "/STA" OR "/STATUS".  WHEN REQUESTED, IT MEANS TO IDENTIFY
;WHAT CODEPAGE IS CURRENTLY SUPPORTED BY THE PREVIOUS GRAFTABL, IF ANY.
	     PUBLIC CONTROL_SW	   ;LET LINK MAKE THIS ADDRESSABLE
CONTROL_SW   LABEL BYTE 	   ;SWITCH DESCRIPTOR FOR /STA
	     DW   0001H 	   ; CONTROLS TYPE MATCHED
				   ;SELECTED BITS: "OPTIONAL"
				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE
				   ;   CHECKED)
				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
				   ; 0010H=IGNORE ":" AT END IN MATCH
				   ; 0002H=REPEATS ALLOWED
				   ; 0001H=OPTIONAL

	     DW   0000H 	   ;FUNCTION_FLAGS ("NO CAPS")
				   ; 0001H=CAP RESULT BY FILE TABLE
				   ; 0002H=CAP RESULT BY CHAR TABLE
				   ; 0010H=REMOVE ":" AT END

	     DW   RESULT	   ; RESULT BUFFER
				   ;(USE SAME RESULT BUF AS DID POSITIONAL PARM)
	     DW   NOVALS	   ; VALUE LISTS
	     DB   2		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS
				   ;   IN FOLLOWING LIST
SW_STA	     DB   "/STA",0	   ; IF n >0, KEYWORD 1
SW_STATUS    DB   "/STATUS",0	   ;SECOND KEYWORD

;THE SWITCH IS "/?".  WHEN REQUESTED, IT MEANS TO DISPLAY
;THE COMMAND LINE OPTIONS FOR THIS PROGRAM.

	     PUBLIC CONTROL_SW2
CONTROL_SW2  LABEL BYTE
	     DW   0000H		   ; Match Mask
	     DW   0000H 	   ; Function Mask
	     DW   RESULT	   ; ptr to RESULT BUFFER
	     DW   NOVALS	   ; ptr to VALUE LISTS
	     DB   1		   ; count of synonyms in following list
SW2_SYN	     DB   "/?",0	   ; only this one synonum

;VALUE CONTROL BLOCK FOR THE SWITCHES

NOVALS	     LABEL BYTE 	   ;
	     DB   0		   ; NUMBER OF VALUE DEFINITIONS (0 - 3)
; =  =	=  =  =  =  =  =  =  =	=  =
	     PATHLABL GRTABPAR	   ;
	     HEADER <PARSER - ASK SYSPARM TO DECODE PARAMETERS> ;
;  $SALUT (4,4,9,36)		   ;
PARSER PROC NEAR		   ;
   PUBLIC PARSER		   ;

;INPUT: "CURRENT_PARM" = OFFSET TO NEXT PARM IN COMMAND STRING
;	"ORDINAL" = COUNT OF NEXT PARM TO PARSE
;	PSP+81H = TEXT OF DOS COMMAND LINE PARMS STRING
;OUTPUT: IF A CODEPAGE NUMBER WAS SPECIFIED
;	    BX = OFFSET TO LANGUAGE TABLE TO BE LOADED
;	    DX = INTEGER VALUE OF CODEPAGE SPECIFIED
;	 IF /STATUS WAS SPECIFIED
;	    BX = 0
;	 IF QUESTION MARK WAS SPECIFIED
;	    BX=-1
;	 If parse error occurred
;	    BX = 1

;IF THERE WAS ANY PROBLEM WITH THE PARMS,
;"EXITFL" SET TO "EXPAR" TO INDICATE PARM ERROR.

;IT A CP IS SPECIFIED, A STATUS REPORT IS ALWAYS GIVEN TO SAY WHAT WHAT
;THERE PREVIOUSLY, SO IF THE USER SPECIFIED A CP AND THE /STATUS SWITCH,
;THEN THE /STATUS DOES NOTHING BEYOND WHAT WOULD HAVE BEEN DONE ALREADY
;WITH JUST THE CP SPECIFICATION.  I ALWAYS REPORT STATUS.  THE ONLY
;REASON TO HAVE /STATUS IS TO BE ABLE TO SEE WHAT IS THERE ALREADY
;WITHOUT INVOKING THE DEFAULT OF 437 (USA) BY NOT SPECIFYING A CP.
; =  =	=  =  =  =  =  =  =  =	=  =

;  $SEARCH COMPLEX		   ;LOOP THRU COMMAND LINE
   JMP SHORT $$SS1
$$DO1:
				   ;LOOKING AT RET CODE IN AX SET BY SYSPARSE
       CMP  AX,ZERO		   ;WERE THERE ANY ERRORS?
;  $EXITIF NE			   ;HAD A PROBLEM
   JE $$IF1
       CALL PARSE_ERROR 	   ;DISPLAY REASON FOR ERROR

;  $ORELSE LONG 		   ;SINCE NO PROBLEM, SO FAR
   JMP $$SR1
$$IF1:
       MOV  ORDINAL,CX		   ;SAVE UPDATED COUNT

       ; Was /? specified?
       ; If so, give the user the options help message

       cmp	[RESULT_SYN], offset SW2_SYN	; /? specified?
       jne	ParserOptionsDone		; skip this if not
       mov	bx, RETCODE_QUESTION		; else flag user help
       jmp	short $$SR1			;  and exit
ParserOptionsDone:

       CMP  FIRST_TIME,ZERO	   ;DO I HAVE A PARM YET?
;      $IF  E			   ;NOT YET, LOOK AT THIS ONE JUST FOUND
       JNE $$IF4
	   MOV	CURRENT_PARM,SI    ;REMEMBER HOW FAR I GOT
	   CMP	RESULT_SYN,ZERO    ;WAS POSITIONAL PARM SPECIFIED?
;	   $IF	E		   ;IF POSITIONAL PARM SPECIFIED,
	   JNE $$IF5
		MOV  CL,RESULT_TAG  ;GET ID OF SPECIFIED PARM
		XOR  CH,CH	   ;CLEAR HIGH BYTE
		   LEA	BX,TABLEUS ;GET WHERE FIRST CODEPAGE STARTS, USING CX
				   ; AS A COUNTER, STEP THRU THE LANGUAGE TABLES
				   ; UNTIL GETTING TO THE SPECIFIED ONE
;		   $DO	COMPLEX    ;
		   JMP SHORT $$SD8
$$DO8:
		       ADD  BX,SIZE LANGUAGE ;POINT TO NEXT TABLE
		       ADD  ACTIVECPID,CPID_L ;SELECT NEXT CPID ENTRY
;		   $STRTDO	   ;
$$SD8:
;		   $ENDDO LOOP	   ;DECREMENT INDEX
		   LOOP $$DO8
				   ;BX-OFFSET TO LANGUAGE TABLE
				   ; INDICATED BY POSITIONAL PARM
;	   $ELSE		   ;SINCE NOT POSITIONAL PARM SPECIFIED
	   JMP SHORT $$EN5
$$IF5:
				   ;RESULT_SYN POINTS TO A SWITCH
	       XOR  BX,BX	   ;  MUST HAVE BEEN THE SWITCH, /STATUS
	       MOV  SW_STA,BLANK   ;AVOID THE DUPLICATION OF THIS SWITCH
	       MOV  SW_STATUS,BLANK ;AVOID THE DUPLICATION OF THIS SWITCH
;	   $ENDIF		   ;POSITIONAL?
$$EN5:
	   INC	FIRST_TIME	   ;INDICATE A PARM HAS BEEN FOUND
;      $ELSE			   ;SINCE ALREADY HAVE A PARM
       JMP SHORT $$EN4
$$IF4:
	   PUSH SI		   ;SAVE NEW INDEX TO COMMAND LINE
	   CALL PARSE_ERROR	   ;FUSS ABOUT TOO MANY PARMS

	   POP	CURRENT_PARM	   ;REMEMBER HOW FAR I GOT

;      $ENDIF			   ;ALREADY HAVE A PARM?
$$EN4:
       MOV  PARSE_RESULT,BX	   ;SAVE THE RESULT OF THIS PARSE
;  $STRTSRCH			   ;
$$SS1:
       LEA  DI,PARMS		   ; ES:DI = PARSE CONTROL DEFINITON
       MOV  SI,CURRENT_PARM	   ; DS:SI = COMMAND STRING, NEXT PARM
       XOR  DX,DX		   ; RESERVED, INIT TO ZERO
       MOV  CX,ORDINAL		   ; OPERAND ORDINAL, INITIALLY ZERO
       CALL SYSPARSE		   ;LOOK AT DOS PARMS
				   ; AX=EXIT CODE
				   ; BL=TERMINATED DELIMETER CODE
				   ; CX=NEW OPERAND ORDINAL
				   ; SI=SET TO PAST SCANNED OPERAND
				   ; DX=SELECTED RESULT BUFFER
       CMP  AX,SYSPRM_EX_EOL	   ; IS THAT THE END OF THE PARMS?
				   ;IF NOT, LOOP BACK AND FIND OUT
				   ; WHAT THAT PARM IS
;  $ENDLOOP E			   ;END OF LIST
   JNE $$DO1
       CMP  FIRST_TIME,ZERO	   ;FIND ANYTHING YET?
;      $IF  E			   ;IF NO PARM SPECIFIED
       JNE $$IF18
	   LEA	BX,TABLEUS	   ;SPECIFY 437 (USA) AS DEFAULT
;      $ELSE			   ;SINCE A PARM WAS FOUND
       JMP SHORT $$EN18
$$IF18:
	   MOV	BX,PARSE_RESULT    ;REMEMBER PARM ALREADY FOUND
;      $ENDIF			   ;
$$EN18:
				   ;BX=-1, "?"; BX=0, "/STATUS";BX>0, CP TABLE
       CMP  BX,ZERO		   ;WAS A CP TABLE FOUND?
;      $IF  A			   ;IF A CP TABLE FOUND
       JNA $$IF21
	   MOV	DX,[BX].LANID	   ;FETCH THE TWO CHAR ID FROM TABLE
;      $ENDIF			   ;
$$IF21:
;  $ENDSRCH			   ;FINISHED WITH DOS COMMAND LINE
$$SR1:
   RET				   ;RETURN TO CALLER
PARSER ENDP			   ;
; =  =	=  =  =  =  =  =  =  =	=  =						;
   HEADER <PARSE_ERROR - DISPLAY REASON FOR PARSE ERROR> ;
PARSE_ERROR PROC NEAR		   ;
;INPUT: "FIRST_TIME" - IF NON-ZERO, FORCE ERROR CODE TO "TOO MANY PARMS"
;	 AX - ERROR NUMBER RETURNED FROM PARSE.
;	 SI - OFFSET INTO COMMAND OF FIRST BYTE BEYOND PARM IN ERROR
;	 "CURRENT_PARM" - OFFSET INTO COMMAND OF WHERE TO START LOOKING FOR PARM
;OUTPUT: APPROPRIATE ERROR MESSAGE IS DISPLAYED.
;	 BX IS SET TO PRETEND THAT THE "?" WAS SPECIFIED.
;	 "EXITFL" SET TO "EXPAR" TO INDICATE PARM ERROR.
; =  =	=  =  =  =  =  =  =  =	=  =

   CMP	FIRST_TIME,ZERO 	   ;ANY PARMS FOUND YET?
;  $IF	NE			   ;IF PARM ALREADY FOUND
   JE $$IF24
       MOV  AX,SYSPRM_EX_MANY	   ;CHANGE RETURN CODE TO "TOO MANY PARMS"
;  $ENDIF			   ;PARMS FOUND?
$$IF24:
   MOV	MSGNUM_PARSE,AX 	   ;PASS MESSAGE NUMBER TO DESCRIPTOR
   MOV	AX,CURRENT_PARM 	   ;GET POINTER TO START OF BAD PARM
   CMP	SI,AX			   ;HAS THE INDEX TO COMMAND LINE MOVED?
;  $IF	NE			   ;YES, THERE IS A FAULTY PARM
   JE $$IF26
       MOV  BYTE PTR [SI],NUL	   ;DELIMIT THE BAD PARM
       MOV  SUBLIST_PARSE.SUB_VALUE,AX ;POINT SUBLIST TO BAD PARM

       MOV  MSGNUM_PARSE.MSG_SUBLIST,OFFSET SUBLIST_PARSE ;POINT TO SUBLIST
       MOV  MSGNUM_PARSE.MSG_COUNT,ONE_SUBS ;SET COUNT OF SUBLISTS TO ONE
;  $ENDIF			   ;INDEX MOVED?
$$IF26:
   LEA	DI,MSGNUM_PARSE 	   ;PASS MESSAGE DESCRIPTOR
   CALL SENDMSG 		   ;DISPLAY ERROR MESSAGE

   MOV	BX,RETCODE_PARSE_ERROR	   ;INDICATE error occurred.
   MOV	EXITFL,EXPAR		   ;ERRORLEVEL CODE TO "PARM ERROR"
   RET				   ;RETURN TO CALLER
PARSE_ERROR ENDP		   ;
; =  =	=  =  =  =  =  =  =  =	=  =
   PATHLABL GRTABPAR		   ;
CSEG ENDS			   ;
   END				   ;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabus.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;A2
	TITLE	GRTABUS - USA CHARACTER SET FOR THE GRAFTABL COMMAND
;This module is to be linked with the OBJ of GRTAB.SAL.  Refer to the
;Prolog of that module for more complete description.

;This module contains the binary description of the pixels that are used
;in graphics mode to define the USA character set when loaded to
;interrupt 1FH by the GRAFTABL command in DOS 3.3.
	IF1
	    %OUT    GRTABUS.ASM...
	ELSE
;    %OUT GRTABUS.ASM...
	ENDIF
CSEG	SEGMENT PARA PUBLIC
TABLEUS EQU	THIS BYTE
	PUBLIC	TABLEUS

;			     128   
	DB	01111000B
	DB	11001100B
	DB	11000000B
	DB	11001100B
	DB	01111000B
	DB	00011000B
	DB	00001100B
	DB	01111000B
;			     129   
	DB	00000000B
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     130   
	DB	00011100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11000000B
	DB	01111000B
	DB	00000000B
;			     131   
	DB	01111110B
	DB	11000011B
	DB	00111100B
	DB	00000110B
	DB	00111110B
	DB	01100110B
	DB	00111111B
	DB	00000000B
;			     132   
	DB	11001100B
	DB	00000000B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     133   
	DB	11100000B
	DB	00000000B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     134   
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     135   
	DB	00000000B
	DB	00000000B
	DB	01111000B
	DB	11000000B
	DB	11000000B
	DB	01111000B
	DB	00001100B
	DB	00111000B
;			     136   
	DB	01111110B
	DB	11000011B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;			     137   
	DB	11001100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11000000B
	DB	01111000B
	DB	00000000B
;			     138   
	DB	11100000B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11000000B
	DB	01111000B
	DB	00000000B
;			     139   
	DB	11001100B
	DB	00000000B
	DB	01110000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B
;			     140   
	DB	01111100B
	DB	11000110B
	DB	00111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;			     141   
	DB	11100000B
	DB	00000000B
	DB	01110000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B
;			     142   
	DB	11000110B
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11111110B
	DB	11000110B
	DB	11000110B
	DB	00000000B
;			     143   
	DB	00110000B
	DB	00110000B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11001100B
	DB	00000000B
;			     144   
	DB	00011100B
	DB	00000000B
	DB	11111100B
	DB	01100000B
	DB	01111000B
	DB	01100000B
	DB	11111100B
	DB	00000000B
;			     145   
	DB	00000000B
	DB	00000000B
	DB	01111111B
	DB	00001100B
	DB	01111111B
	DB	11001100B
	DB	01111111B
	DB	00000000B
;			     146   
	DB	00111110B
	DB	01101100B
	DB	11001100B
	DB	11111110B
	DB	11001100B
	DB	11001100B
	DB	11001110B
	DB	00000000B
;			     147   
	DB	01111000B
	DB	11001100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     148   
	DB	00000000B
	DB	11001100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     149   
	DB	00000000B
	DB	11100000B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     150   
	DB	01111000B
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     151   
	DB	00000000B
	DB	11100000B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     152   
	DB	00000000B
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	01111100B
	DB	00001100B
	DB	11111000B
;			     153   
	DB	11000011B
	DB	00011000B
	DB	00111100B
	DB	01100110B
	DB	01100110B
	DB	00111100B
	DB	00011000B
	DB	00000000B
;			     154   
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     155   
	DB	00011000B
	DB	00011000B
	DB	01111110B
	DB	11000000B
	DB	11000000B
	DB	01111110B
	DB	00011000B
	DB	00011000B
;			     156   
	DB	00111000B
	DB	01101100B
	DB	01100100B
	DB	11110000B
	DB	01100000B
	DB	11100110B
	DB	11111100B
	DB	00000000B
;			     157   
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	11111100B
	DB	00110000B
	DB	11111100B
	DB	00110000B
	DB	00110000B
;			     158   
	DB	11111000B
	DB	11001100B
	DB	11001100B
	DB	11111010B
	DB	11000110B
	DB	11001111B
	DB	11000110B
	DB	11000111B
;			     159   
	DB	00001110B
	DB	00011011B
	DB	00011000B
	DB	00111100B
	DB	00011000B
	DB	00011000B
	DB	11011000B
	DB	01110000B
;			     160   
	DB	00011100B
	DB	00000000B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     161   
	DB	00111000B
	DB	00000000B
	DB	01110000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B
;			     162   
	DB	00000000B
	DB	00011100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     163   
	DB	00000000B
	DB	00011100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     164   
	DB	00000000B
	DB	11111000B
	DB	00000000B
	DB	11111000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	00000000B
;			     165   
	DB	11111100B
	DB	00000000B
	DB	11001100B
	DB	11101100B
	DB	11111100B
	DB	11011100B
	DB	11001100B
	DB	00000000B
;			     166   
	DB	00111100B
	DB	01101100B
	DB	01101100B
	DB	00111110B
	DB	00000000B
	DB	01111110B
	DB	00000000B
	DB	00000000B
;			     167   
	DB	00111000B
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
	DB	01111100B
	DB	00000000B
	DB	00000000B
;			     168   
	DB	00110000B
	DB	00000000B
	DB	00110000B
	DB	01100000B
	DB	11000000B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     169   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111100B
	DB	11000000B
	DB	11000000B
	DB	00000000B
	DB	00000000B
;			     170   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111100B
	DB	00001100B
	DB	00001100B
	DB	00000000B
	DB	00000000B
;			     171   
	DB	11000011B
	DB	11000110B
	DB	11001100B
	DB	11011110B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	00001111B
;			     172   
	DB	11000011B
	DB	11000110B
	DB	11001100B
	DB	11011011B
	DB	00110111B
	DB	01101111B
	DB	11001111B
	DB	00000011B
;			     173   
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
;			     174   
	DB	00000000B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	01100110B
	DB	00110011B
	DB	00000000B
	DB	00000000B
;			     175   
	DB	00000000B
	DB	11001100B
	DB	01100110B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	00000000B
	DB	00000000B
;			     176   
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
;			     177   
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
;			     178   
	DB	11011011B
	DB	01110111B
	DB	11011011B
	DB	11101110B
	DB	11011011B
	DB	01110111B
	DB	11011011B
	DB	11101110B
;			     179   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     180   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     181   
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     182   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     183   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     184   
	DB	00000000B
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     185   
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     186   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     187   
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     188   
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     189   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     190   
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     191   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     192   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     193   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     194   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     195   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     196   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     197   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     198   
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     199   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     200   
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     201   
	DB	00000000B
	DB	00000000B
	DB	00111111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     202   
	DB	00110110B
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     203   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     204   
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     205   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     206   
	DB	00110110B
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     207   
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     208   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     209   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     210   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     211   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     212   
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     213   
	DB	00000000B
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     214   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     215   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     216   
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     217   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     218   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     219   
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
;			     220   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
;			     221   
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
;			     222   
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
;			     223   
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     224   
	DB	00000000B
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	11001000B
	DB	11011100B
	DB	01110110B
	DB	00000000B
;			     225   
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111000B
	DB	11001100B
	DB	11111000B
	DB	11000000B
	DB	11000000B
;			     226   
	DB	00000000B
	DB	11111100B
	DB	11001100B
	DB	11000000B
	DB	11000000B
	DB	11000000B
	DB	11000000B
	DB	00000000B
;			     227   
	DB	00000000B
	DB	11111110B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00000000B
;			     228   
	DB	11111100B
	DB	11001100B
	DB	01100000B
	DB	00110000B
	DB	01100000B
	DB	11001100B
	DB	11111100B
	DB	00000000B
;			     229   
	DB	00000000B
	DB	00000000B
	DB	01111110B
	DB	11011000B
	DB	11011000B
	DB	11011000B
	DB	01110000B
	DB	00000000B
;			     230   
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01111100B
	DB	01100000B
	DB	11000000B
;			     231   
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
;			     232   
	DB	11111100B
	DB	00110000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00110000B
	DB	11111100B
;			     233   
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11111110B
	DB	11000110B
	DB	01101100B
	DB	00111000B
	DB	00000000B
;			     234   
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11000110B
	DB	01101100B
	DB	01101100B
	DB	11101110B
	DB	00000000B
;			     235   
	DB	00011100B
	DB	00110000B
	DB	00011000B
	DB	01111100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     236   
	DB	00000000B
	DB	00000000B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	00000000B
	DB	00000000B
;			     237   
	DB	00000110B
	DB	00001100B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	01100000B
	DB	11000000B
;			     238   
	DB	00111000B
	DB	01100000B
	DB	11000000B
	DB	11111000B
	DB	11000000B
	DB	01100000B
	DB	00111000B
	DB	00000000B
;			     239   
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	00000000B
;			     240   
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	00000000B
;			     241   
	DB	00110000B
	DB	00110000B
	DB	11111100B
	DB	00110000B
	DB	00110000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
;			     242   
	DB	01100000B
	DB	00110000B
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
;			     243   
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	00110000B
	DB	00011000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
;			     244   
	DB	00001110B
	DB	00011011B
	DB	00011011B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     245   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11011000B
	DB	11011000B
	DB	01110000B
;			     246   
	DB	00110000B
	DB	00110000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	00110000B
	DB	00110000B
	DB	00000000B
;			     247   
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	00000000B
;			     248   
	DB	00111000B
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     249   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     250   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     251   
	DB	00001111B
	DB	00001100B
	DB	00001100B
	DB	00001100B
	DB	11101100B
	DB	01101100B
	DB	00111100B
	DB	00011100B
;			     252   
	DB	01111000B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     253   
	DB	01110000B
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	01111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     254   
	DB	00000000B
	DB	00000000B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00000000B
	DB	00000000B
;			     255   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
ENDTABL EQU	THIS BYTE
	PUBLIC	ENDTABL
	DW	437			;TABLE ID
;	include graftusm.inc
	DB	"USA",0 		;LANGUAGE NAME, IN ASCIIZ FORMAT
;(the above "DB" is an example of the ENGLISH version of the above include file)
	IF	($-CSEG) MOD 16 	;IF NOT ALREADY ON 16 BYTE BOUNDARY
	    DB	    (16-(($-CSEG) MOD 16)) DUP(0) ;ADD PADDING TO GET TO 16 BYTE BOUNDARY
	ENDIF
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\graphics.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Command Entry Point
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; MS DOS GRAPHICS Command
;;                                      
;;										;AN000;
;; File Name:  GRAPHICS.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the GRAPHICS command entry point.			;AN000;
;;	 A jump is made to the GRAPHICS_INSTALL procedure			;AN000;
;;	 in file GRINST.ASM to begin installation processing.			;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRINST.EXT - Externals for GRINST.ASM					;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRINST.ASM: 						;AN000;
;;	      GRAPHICS_INSTALL - Main module for installation.			;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 LINK GRAPHICS GRINT2FH GRPATTRN GRCTRL GRCPSD GRCOLPRT GRBWPRT 	;AN000;
;;	      GRINST GRPARSE grparms GRLOAD GRLOAD2 GRLOAD3;			;AN000;
;;	 EXE2BIN GRAPHICS.EXE GRAPHICS.COM					;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;	A000 - Denotes 4.00 level source.					;AN000;
;;	A001 - PTM1779 - invalid parm msg followed by garbage			;AN001;
;;	       Module affected: GRPARMS.ASM					;AN001;
;;	A002 - PTM2666 - Release environment string before terminating. 	;AN002;
;;	       Module affected: GRINST.ASM					;AN002;
;;	A003 - PTM3915 - Change to include common copyright file.
;;	       Module affected: GRAPHICS.ASM
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
	ORG   100H		       ;; required for .COM			;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
START:				       ;;					;AN000;
				       ;;					;AN000;
	JMP   GRAPHICS_INSTALL	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;
;	INCLUDE COPYRIGH.INC	       ;; included in message services		;AN003;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
CODE   ENDS									;AN000;
       END    START								;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grcommon.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I modified the procedures STORE_BOX, PRINT_BUFFER,
;**                GET_SCREEN_INFO, DET_CUR_SCAN_LNE_LENGTH, and NEW_PRT_LINE
;**                as follows.
;**  
;**                For STORE_BOX:
;**                  if data_type = data_row, then store printbox in print buffer
;**                     in row format - not column format.
;**  
;**                For PRINT_BUFFER:
;**                  if data_type = data_row, then print one byte at a time.
;**  
;**                For GET_SCREEN_INFO:
;**                  if data_type = data_row
;**                          nb_boxes_per_prt_buf = 8/box_height
;**                          if print_options = rotate
;**                                  nb_scan_lines = screen_width
;**                          else
;**                                  nb_scan_lines = screen_height
;**                          endif
;**                  endif
;**  
;**                For DET_CUR_SCAN_LNE_LENGTH:
;**                  if data_type = data_row
;**                          don't go down the columns to determine the scan_line_length
;**                  endif
;**  
;**                For NEW_PRT_LINE:
;**                  Altered it so send escape number sequence, COUNT or LOWCOUNT and
;**                  HIGHCOUNT, if they are specified before the new keyword DATA.
;**  
;**  
;**                I added the the procedures END_PRT_LINE and GET_COUNT, which
;**                are described below.
;**            
;**                END_PRT_LINE sends escape number sequence, COUNT or LOWCOUNT and
;**                HIGHCOUNT, if they are specified after the new keyword DATA
;**                in the GRAPHICS statement of the profile.  It also sends a
;**                CR & LF for IBM type printers if needed.
;**  
;**                GET_COUNT gets the number of bytes that are going to be sent to the
;**                printer and converts the number to ASCII if DATA_TYPE = DATA_ROW.
;**  
;**  BUG NOTES:     The   following   bug   was  fixed   for   the   pre-release  
;**                 version Q.01.02.
;**  
;**  BUG (mda003)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints  a CR & LF after  each  scan line unless it  is 
;**            loaded twice.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD3.ASM - PARSE_GRAPHICS
;**                                GRCOMMON.ASM - END_PRT_LINE
;**                                GRSHAR.STR - N/A
;**  
;**  CAUSES:   The local variables LOWCOUNT_FOUND, HIGHCOUNT_FOUND CR_FOUND  and 
;**            LF_FOUND used for loading, were incorrectly being used as  global 
;**            variables during printing.
;**  
;**  FIX:      Created  a new variable Printer_Needs_CR_LF in GRSHAR.STR,  which 
;**            is  used  to  determine  in GRCOMMON.ASM  if  it's  necessary  to 
;**            manually  send  a  CR  & LF to the printer  at  print  time.  The 
;**            variable  is  set at load time in GRLOAD3.ASM, if  the  variables 
;**            Data_Found and Build_State are set. 
;**  
;**  DOCUMENTATION NOTES:  This version of GRCOMMON.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;************************************************************
	PAGE	,132								;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCOMMON.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;										;AN000;
;;	 This file contains the modules common to the Print Screen		;AN000;
;;	 process of GRAPHICS.COM.						;AN000;
;;	 This file is included by both set of Print modules.			;AN000;
;;										;AN000;
;;	 This file MUST BE COMPILED WITH EACH SET OF MODULES since,		;AN000;
;;	 one set is relocated in memory at installation time; all		;AN000;
;;	 references to the common procedures must be resolved from		;AN000;
;;	 within each set of print modules.					;AN000;
;;										;AN000;
;;	 The set of common modules is relocated in memory along with		;AN000;
;;	 the selected set of print modules.					;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	READ_DOT								;AN000;
;;	LOC_MODE_PRT_INFO							;AN000;
;;	STORE_BOX								;AN000;
;;	PRINT_BUFFER								;AN000;
;;	GET_SCREEN_INFO 							;AN000;
;;	SETUP_PRT								;AN000;
;;	RESTORE_PRT								;AN000;
;;	NEW_PRT_LINE								;AN000;
;;	PRINT_BYTE								;AN000;
;;	DET_CUR_SCAN_LNE_LENGTH 						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;;              Added the following procedures to support printers with horizontal
;;              printer heads, such as an HP PCL printers.
;;      GET_COUNT
;;      END_PRT_LINE
; /\ ~~mda(001) -----------------------------------------------------------------------
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRCTRL.ASM: 						;AN000;
;;	      PRT_SCR	       - Main module for printing the screen.		;AN000;
;;	 FROM FILE  GRBWPRT.ASM:						;AN000;
;;	      PRT_BW_APA       - Main module for printing on BW printer.	;AN000;
;;	 FROM FILE  GRCOLPRT.ASM:						;AN000;
;;	      PRINT_COLOR      - Main module for printing on COLOR printer.	;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;										;AN000;
;;	 This file is included by both GRBWPRT.ASM and GRCOLPRT.ASM and is	;AN000;
;;	 compiled with each of them. However, only one copy is made resident.	;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; LOC_MODE_PRT_INFO: LOCATE DISPLAYMODE PRINTER INFO. FOR THE CURRENT		;AN000;
;		     MODE							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	BP		= Offset of the shared data area		;AN000;
;		CUR_MODE	= Current video mode				;AN000;
;										;AN000;
;	OUTPUT: CUR_MODE_PTR	= Absolute Offset of the			;AN000;
;				  current DISPLAYMODE INFO record.		;AN000;
;										;AN000;
;		ERROR_CODE	= DISPLAYMODE_INFO_NOT_FOUND if not found.	;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRINT_BW_APA 						;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:	DISPLAYMODE_PTR is pointing to the first DISPLAYMODE		;AN000;
; INFO record within the Shared Data Area.					;AN000;
;										;AN000;
; This (chained) list of DISPLAYMODE records is scanned until the record	;AN000;
; for the current mode is found.						;AN000;
;										;AN000;
; Note: All pointers in the DISPLAYMODE records are relative to the beginning	;AN000;
;	of the shared data area. Therefore, we must add the offset of the	;AN000;
;	shared data area (in BP) in order to access the data these pointers	;AN000;
;	are referencing.							;AN000;
;										;AN000;
;	The CUR_MODE_PTR is relative to the segment and references the		;AN000;
;	DISPLAYMODE record for the video mode currently set at print screen	;AN000;
;	time.									;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; FOUND := FALSE								;AN000;
; DO UNTIL FOUND OR END_OF_LIST 						;AN000;
;   Get a display mode information record					;AN000;
;   IF record.DISP_MODE = CUR_MODE						;AN000;
;     THEN FOUND := TRUE							;AN000;
;   ELSE									;AN000;
;     CUR_MODE_PTR := record.NEXT_DISP_MODE					;AN000;
;										;AN000;
;										;AN000;
										;AN000;
LOC_MODE_PRT_INFO PROC NEAR							;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
										;AN000;
	MOV	BX,DS:[BP].DISPLAYMODE_PTR	; [BX] := Current DISPLAYMODE	;AN000;
	ADD	BX,BP				;	   record		;AN000;
	MOV	DL,CUR_MODE			; DL := Current mode		;AN000;
										;AN000;
SCAN_1_DISPLAYMODE_RECORD:							;AN000;
	MOV	SI,[BX].DISP_MODE_LIST_PTR	; [SI] : First mode covered	;AN000;
	ADD	SI,BP				;    by this DISPLAYMODE record ;AN000;
	MOV	CL,[BX].NUM_DISP_MODE		; Scan each mode in the list	;AN000;
	XOR	CH,CH								;AN000;
SCAN_LIST_OF_MODES:								;AN000;
	CMP	CS:[SI],DL			; FOUND ?			;AN000;
	JE	FOUND								;AN000;
	INC	SI				; NO, get next mode in		;AN000;
	LOOP	SCAN_LIST_OF_MODES		;      DISPLAYMODE record	;AN000;
										;AN000;
	CMP	[BX].NEXT_DISP_MODE,-1		; END OF DISPLAYMODE LIST ?	;AN000;
	JE	NOT_FOUND			; Yes, this mode not supported	;AN000;
NEXT_RECORD:					; No,				;AN000;
	MOV	BX,[BX].NEXT_DISP_MODE		;     [BX] := Next record	;AN000;
	ADD	BX,BP				;				;AN000;
	JMP	SHORT SCAN_1_DISPLAYMODE_RECORD 				;AN000;
										;AN000;
FOUND:						; Found:			;AN000;
	MOV	CUR_MODE_PTR,BX 		; Update pointer to current	;AN000;
	JMP	SHORT LOC_MODE_PRT_INFO_END	; DISPLAYMODE record.		;AN000;
										;AN000;
NOT_FOUND:					; Not found:			;AN000;
	MOV	ERROR_CODE,DISPLAYMODE_INFO_NOT_FOUND ; Return error condition	;AN000;
										;AN000;
LOC_MODE_PRT_INFO_END:								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
LOC_MODE_PRT_INFO ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; STORE_BOX : STORE ONE BOX IN THE PRINT BUFFER.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SI	   = OFFSET OF THE BOX TO BE PRINTED			;AN000;
;		BOX_W	   = BOX WIDTH IN BITS					;AN000;
;		BOX_H	   = BOX HEIGHT IN BITS 				;AN000;
;										;AN000;
;	OUTPUT: PRT_BUF  = THE PRINT BUFFER					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: The print buffer is first shifted left in order to make		;AN000;
; room for the new box (Note: the MSB's are lost; they are assumed to           ;AN000;
; have been printed), then the box is inserted in the low-order bits of 	;AN000;
; the printer buffer.								;AN000;
;										;AN000;
PAGE										;AN000;
;			      EXAMPLE						;AN000;
;			      -------						;AN000;
; BEFORE:				     AFTER:				;AN000;
;										;AN000;
; BOX: 0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      0    0	0								;AN000;
;      b1  b2  b3								;AN000;
;      b4  b5  b6								;AN000;
;										;AN000;
; PRT_BUF: byte1 byte2 byte3		     PRT_BUF:  byte1 byte2 byte3	;AN000;
;	     0	   1	 0				 1     1     1		;AN000;
;	     1	   0	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 1     1     1		;AN000;
;	     1	   1	 1				 b1    b2    b3 	;AN000;
;    LSB --> 1	   1	 1				 b4    b5    b6 	;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; FOR each byte of the buffer (BOX_W)						;AN000;
;   BEGIN									;AN000;
;   Make room for the box to be inserted					;AN000;
;   Insert the box								;AN000;
;   END 									;AN000;
;										;AN000;
STORE_BOX PROC NEAR								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	DI,OFFSET PRT_BUF ; DI := Offset of the Print buffer		;AN000;
       	XOR	BX,BX		        ; BX := Byte index number			;AN000;

; \/ ~~mda(001) -----------------------------------------------------------------------
;               Added the following modification to support printers with
;               vertical print heads, such as HP PCL printers.  The code
;               as is does not work for these printers because the data
;               is being stored in the print buffer with the assumption
;               that the print head is vertical.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>
                PUSH    AX              ; 
                PUSH    DX              ;
                PUSH    BP              ;
                MOV     CL,BOX_W        ; Make room for the bits to be inserted.
                SHL     BYTE PTR [BX][DI],CL    ;
                MOV     CL,DS:[BP].ROW_TO_EXTRACT       ; CL determines which row we're extracting
                XOR     BP,BP           ; Point to first column.
                XOR     DX,DX           ; Clear counter
                XOR     AX,AX           ; Clear register
                                        ;
EXTRACT_NEXT_BIT:                       ;
                                        ;
                SHL     AH,1            ; Make room for next bit
                MOV     AL,DS:[SI][BP]  ; Read column
                SHR     AL,CL           ; Get bit from row we're extracting
                AND     AL,1            ; Isolate bit we got from row we're extracting
                OR      AH,AL           ; Place it in AH
                INC     BP              ; Advance to next column
                INC     DL              ; Inc. counter
                CMP     DL,BOX_W        ; Check if have more bits to extract from the row
                JL      EXTRACT_NEXT_BIT; We do
                OR      DS:[DI][BX],AH  ; We don't so place the row we extracted in the 
                                        ; print buffer.
                POP     BP              ;
                POP     DX              ; 
                POP     AX              ;
       .ELSE                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
										        ;AN000;
	        MOV	CL,BOX_H	        ; CL := Number of BITS to be shifted		;AN000;
; FOR each column (byte) of the box to be stored in the buffer: 		;AN000;
STORE_1_BYTE:				        					;AN000;
	        SHL	BYTE PTR [BX][DI],CL	; Make room for the bits to be inserted ;AN000;
	        MOV	CH,[BX][SI]		; CH := column of the box to be inserted;AN000;
	        OR	[BX][DI],CH		; Insert the box column in the buffer	;AN000;
	        INC	BL			; Get next column (byte) of the box	;AN000;
	        CMP	BL,BOX_W		; All columns (bytes) of box stored ?	;AN000;
	        JL	STORE_1_BYTE		; No, store next one.			;AN000;
       .ENDIF                                   ; ~~mda(001) Close the IF stmt										        ;AN000;
STORE_BOX_END:									;AN000;
	POP	DI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
STORE_BOX ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BUFFER : PRINT THE BUFFER						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	PRT_BUF  = BYTES TO BE PRINTED					;AN000;
;		BOW_W	 = BOX WIDTH						;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Prints BOX_W bytes.						;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; DO for each column in one pattern						;AN000;
;   BEGIN									;AN000;
;   Print one byte from the buffer						;AN000;
;   END 									;AN000;
;										;AN000;
PRINT_BUFFER PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,OFFSET PRT_BUF						;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               If DATA_TYPE = DATA_ROW then the most we store in the print
;               buffer at one time is one byte.
.IF <DS:[BP].DATA_TYPE EQ DATA_ROW>     ;
	MOV	AL,[BX] 	        ; Print one byte				
	CALL	PRINT_BYTE		;					
	JC	PRINT_BUFFER_END        ; If printer error, quit the loop	
.ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------
	XOR	CX,CX								;AN000;
	MOV	CL,BOX_W							;AN000;
PRINT_1_BUF_COLUMN:								;AN000;
	MOV	AL,[BX] 	; Print one byte				;AN000;
	CALL	PRINT_BYTE							;AN000;
	JC	PRINT_BUFFER_END; If printer error, quit the loop		;AN000;
	INC	BX		; Get next byte 				;AN000;
	LOOP	PRINT_1_BUF_COLUMN						;AN000;
.ENDIF                          ;~~mda(001) close IF stmt
PRINT_BUFFER_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BUFFER ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; GET_SCREEN_INFO : GET INFORMATION ABOUT HOW TO READ THE SCREEN.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	SCREEN_HEIGHT	  = Number of pixel rows on the screen		;AN000;
;		SCREEN_WIDTH	  = Number of pixel columns on screen		;AN000;
;		CUR_MODE_PTR	  = Offset of the current DISPLAYMODE info rec. ;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;		SCAN_LINE_MAX_LENGTH = Maximum length of Screen scan line.	;AN000;
;		NB_SCAN_LINES	  = Number of SCAN LINES on the screen		;AN000;
;		CUR_ROW,CUR_COLUMN = Coordinates of the first pixel to be	;AN000;
;					 read on the screen			;AN000;
;		NB_BOXES_PER_PRT_BUF = Number of boxes fitting in the Print	;AN000;
;				       buffer					;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION:									;AN000;
;										;AN000;
;    1) Determine where to start reading the screen.				;AN000;
;	For non-rotated printing, it should start with the top-left		;AN000;
;	corner pixel.								;AN000;
;	For rotated printing, it should start with the low-left corner		;AN000;
;	pixel.									;AN000;
;										;AN000;
;    2) Determine the length of a scan line.					;AN000;
;	For non-rotated printing, it is the WIDTH of the screen.		;AN000;
;	For rotated printing, it is the HEIGHT of the screen.			;AN000;
;										;AN000;
;    3) Determine the number of scan lines on the screen.			;AN000;
;	For non-rotated printing, it is the HEIGHT of the screen divided	;AN000;
;	by the number of boxes fitting in the print buffer.			;AN000;
;	For rotated printing, it is the WIDTH of the screen divided by		;AN000;
;	the number of boxes fitting in the print buffer.			;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; CUR_COLUMN   := 0								;AN000;
; IF printing is sideways							;AN000;
;   THEN									;AN000;
;     CUR_ROW := SCREEN_HEIGHT - 1	  ; Low-left pixel			;AN000;
;     SCAN_LINE_MAX_LENGTH := SCREEN_HEIGHT					;AN000;
;     NB_SCAN_LINES :=	SCREEN_WIDTH / NB_BOXES_PER_PRT_BUF			;AN000;
;   ELSE									;AN000;
;     CUR_ROW := 0			  ; Top-left pixel			;AN000;
;     SCAN_LINE_MAX_LENGTH := SCREEN_WIDTH					;AN000;
;     NB_SCAN_LINES :=	SCREEN_HEIGHT / NB_BOXES_PER_PRT_BUF			;AN000;
;										;AN000;
;										;AN000;
GET_SCREEN_INFO PROC NEAR							;AN000;
	PUSH	AX								;AN000;
	PUSH	BX			; Used for DIV				;AN000;
	PUSH	DX			; Used for DIV				;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Offset DISPLAYMODE info record	;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Calculate how many printer boxes fit in the print buffer:			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_BOXES_PER_PRT_BUF depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If DATA_TYPE is DATA_COL, then we have a vertical
;               print head.  If DATA_TYPE is DATA_ROW, then we have a 
;               horizontal print head.
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is horizontal
            MOV	AX,8			; Num := 8 bits / Box width		
            MOV	DL,[BX].BOX_WIDTH	;					
            DIV	DL			;					
            MOV	NB_BOXES_PER_PRT_BUF,AL ;					
       .ELSE                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
	    MOV	AX,8			; Num := 8 bits / Box heigth		;AN000;
	    MOV	DL,[BX].BOX_HEIGHT						;AN000;
	    DIV	DL								;AN000;
	    MOV	NB_BOXES_PER_PRT_BUF,AL 					;AN000;
       .ENDIF                           ; ~~mda(001) Close IF stmt.
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Determine where to start reading the screen:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	CUR_COLUMN,0		; Reading always start from left of scr ;AN000;
.IF <[BX].PRINT_OPTIONS EQ ROTATE>						;AN000;
.THEN										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Printing is sideways; screen must be read starting in low-left corner.	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,SCREEN_HEIGHT						;AN000;
	MOV	SCAN_LINE_MAX_LENGTH,AX ; Scan line length := screen height	;AN000;
	DEC	AX								;AN000;
	MOV	CUR_ROW,AX		; First row := screen height - 1	;AN000;
										;AN000;
;-------Calculate the number of scan lines:					;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_SCAN_LINES depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If the printer head is horizontal, then we can't
;               make use of the concept of scan lines.  However, we can still
;               use the symbol NB_SCAN_LINES by just stuffing into it the
;               screen width.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is horizontal
            MOV	        AX,SCREEN_WIDTH ; DX AX = Screen width			
            CWD                         ;
            MOV         NB_SCAN_LINES,AX;
       .ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------        
            MOV	        AX,SCREEN_WIDTH         ; DX AX = Screen width			;AN000;
	    CWD				        ;					;AN000;
	    XOR	        BX,BX		        ; BX	= Number of boxes per print buf ;AN000;
	    MOV	        BL,NB_BOXES_PER_PRT_BUF ;					;AN000;
	    DIV	        BX			; Screen width / number boxes per buff	;AN000;
	    MOV	        NB_SCAN_LINES,AX	; Number of scan lines := result	;AN000;
           .ENDIF                               ; ~~mda(001) Close IF stmt.

.ELSE										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Printing is not sideways; screen must be read starting in top-left corner	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,SCREEN_WIDTH 						;AN000;
	MOV	SCAN_LINE_MAX_LENGTH,AX ; Scan line length := screen width	;AN000;
	MOV	CUR_ROW,0		; First row := 0			;AN000;
										;AN000;
;-------Calculate the number of scan lines:					;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               The NB_SCAN_LINES depends on if the printer head is
;               vertical, as in IBM's case, or if it's horizontal, as in
;               HP's case.  If the printer head is horizontal, then we can't
;               make use of the concept of scan lines.  However, we can still
;               use the symbol NB_SCAN_LINES by just stuffing into it the
;               screen height.
;
       .IF <DS:[BP].DATA_TYPE EQ DATA_ROW>      ; Print head is vertical
            MOV	        AX,SCREEN_HEIGHT; DX AX = Screen height			
            CWD                         ;
            MOV         NB_SCAN_LINES,AX;
       .ELSE
; /\ ~~mda(001) -----------------------------------------------------------------------        
 
	MOV	AX,SCREEN_HEIGHT	; DX AX = Screen height 		;AN000;
	CWD				;					;AN000;
	XOR	BX,BX			; BX  = Number of boxes per print buff	;AN000;
	MOV	BL,NB_BOXES_PER_PRT_BUF ;					;AN000;
	DIV	BX			; Screen height/number boxes per buff.	;AN000;
	MOV	NB_SCAN_LINES,AX	; Number of scan lines := result	;AN000;
       .ENDIF                           ; ~~mda(001) Close IF stmt.

.ENDIF										;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
GET_SCREEN_INFO ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; DET_CUR_SCAN_LNE_LENGTH : Determine where is the last non-blank "scan line    ;AN000;
;				column" on the current scan line.               ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;     INPUT:  CUR_ROW,								;AN000;
;	      CUR_COLUMN	  = Coordinates of the top pixel of the current ;AN000;
;				    scan line.					;AN000;
;	      XLT_TAB		  = Color translation table			;AN000;
;										;AN000;
;     OUTPUT: CUR_SCAN_LNE_LENGTH = Number of "columns" of pixels from the      ;AN000;
;				    beginning of the scan line up to		;AN000;
;				    the last non-blank pixel.			;AN000;
;										;AN000;
; DATA	      SCREEN_WIDTH,							;AN000;
; REFERENCED: SCREEN_HEIGHT	  = Dimensions of the screen in pels		;AN000;
;	      SCAN_LINE_MAX_LENGTH= Maximum length of the scan line		;AN000;
;	      ROTATE_SW 	  = ON if printing is sideways			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Determine where is the last non-blank "column" by reading        ;AN000;
; the scan line backwards, one column at a time.				;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; ; Obtain coordinates for the top pixel of the last column on the current	;AN000;
; ; scan line:									;AN000;
; IF printing is sideways							;AN000;
;   THEN									;AN000;
;   CUR_ROW := 0								;AN000;
; ELSE										;AN000;
;   CUR_COLUMN := SCREEN_WIDTH - 1						;AN000;
;										;AN000;
; CUR_SCAN_LNE_LENGTH := SCAN_LINE_MAX_LENGTH					;AN000;
; ; Read a column of pixels on the scan line until a non-blank is found:	;AN000;
; For each column on the screen 						;AN000;
;   CALL FILL_BUFF								;AN000;
; ; Check if PRT_BUF is empty							;AN000;
;   IF buffer is empty								;AN000;
;     THEN DEC	CUR_SCAN_LNE_LENGTH						;AN000;
;	   ; Get next column							;AN000;
;	   IF printing sideways THEN DEC CUR_ROW				;AN000;
;				ELSE DEC CUR_COLUMN				;AN000;
;   ELSE quit the loop								;AN000;
;										;AN000;
DET_CUR_SCAN_LNE_LENGTH PROC NEAR						;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
	PUSH	CUR_COLUMN							;AN000;
	PUSH	CUR_ROW 							;AN000;
										;AN000;
	MOV	BX,OFFSET XLT_TAB	; BX := Offset of XLT_TAB		;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Obtain coordinates of the top pixel for the last column of the current	;AN000;
; scan line:									;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then, 				;AN000;
	  MOV	  CUR_ROW,0		;   CUR_ROW := 0			;AN000;
       .ELSE				; else, 				;AN000;
	  MOV	  CX,SCREEN_WIDTH	;   CUR_COLUMN := SCREEN_WIDTH - 1	;AN000;
	  DEC	  CX			;					;AN000;
	  MOV	  CUR_COLUMN,CX 	;					;AN000;
       .ENDIF									;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Read the scan line backwards "column" by "column" until a non-blank is found: ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	CX,SCAN_LINE_MAX_LENGTH ; CX := current length			;AN000;
;										;AN000;
;-------For each "column"                                                       ;AN000;
CHECK_1_COLUMN: 								;AN000;
	MOV	SI,CUR_ROW		; Save coordinates of the column	;AN000;
	MOV	DI,CUR_COLUMN		; in SI, DI				;AN000;
	XOR	DL,DL			; DL := Number of pixels verified in	;AN000;
					;	  one "column"                  ;AN000;
;										;AN000;
;-------For each pixel within that "column"                                     ;AN000;
CHECK_1_PIXEL:									;AN000;
	CALL	READ_DOT		; AL := Index into translation table	;AN000;
	XLAT	XLT_TAB 		; AL := Band mask or Intensity		;AN000;
										;AN000;
;-------Check if pixel will map to an empty box:				;AN000;
       .IF <DS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; If BLACK AND WHITE printer	;AN000;
       .THEN				; then, check for intensity of white	;AN000;
	  CMP	  AL,WHITE_INT		;      If curent pixel not blank	;AN000;
	  JNE	  DET_LENGTH_END	;      THEN, LEAVE THE LOOP		;AN000;
       .ELSE				; else, COLOR printer			;AN000;
	  OR	  AL,AL 		;      IF Band mask not blank		;AN000;
	  JNZ	  DET_LENGTH_END	;      THEN, LEAVE THE LOOP		;AN000;
       .ENDIF									;AN000;
										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Only if DATA_TYPE is DATA_COL do we have "columns",
;               so skip this section otherwise.
       .IF <DS:[BP].DATA_TYPE EQ DATA_COL> ; Print head is vertical
; /\ ~~mda(001) ----------------------------------------------------------------------- 
;-------All pixels so far on this "column" are blank, get next pixel:           ;AN000;
               .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
               .THEN				;					;AN000;
	                INC CUR_COLUMN		; then, increment column number 	;AN000;
               .ELSE				;					;AN000;
	                INC CUR_ROW			; else, increment row number		;AN000;
               .ENDIF				;					;AN000;
	        INC	DL			; One more pixel checked		;AN000;
	        CMP	DL,NB_BOXES_PER_PRT_BUF ; All pixels for that column done ?	;AN000;
	        JL	CHECK_1_PIXEL		;   No, check next one. 		;AN000;
       .ENDIF                                   ;~~mda(001) Close IF stmt.
										;AN000;
;-------Nothing to print for this column, get next column			;AN000;
       .IF <ROTATE_SW EQ ON>		; If printing sideways			;AN000;
       .THEN				; then, 				;AN000;
	  MOV CUR_COLUMN,DI		;   Restore column number		;AN000;
	  INC CUR_ROW			;   Get next row			;AN000;
       .ELSE				; else, 				;AN000;
	  MOV CUR_ROW,SI		;   Restore row number			;AN000;
	  DEC CUR_COLUMN		;   Get next column			;AN000;
       .ENDIF				;					;AN000;
	LOOP CHECK_1_COLUMN		; CX (length) := CX - 1 		;AN000;
										;AN000;
DET_LENGTH_END: 								;AN000;
	MOV	CUR_SCAN_LNE_LENGTH,CX	; Get current length			;AN000;
										;AN000;
	POP	CUR_ROW 							;AN000;
	POP	CUR_COLUMN							;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
DET_CUR_SCAN_LNE_LENGTH ENDP							;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; SETUP_PRT : SET UP THE PRINTER FOR PRINTING IN GRAPHIC MODE			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;			      record for the current mode			;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the SETUP escape sequence from the DISPLAYMODE		;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_SETUP_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; SI := CUR_MODE_PTR.SETUP_ESC_PTR						;AN000;
;										;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
SETUP_PRT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
	XOR	CX,CX			; CX := Number of bytes to print	;AN000;
	MOV	CL,[BX].NUM_SETUP_ESC	;					;AN000;
.IF <CL G 0>				; If there is at least one		;AN000;
.THEN					; byte to be printed:			;AN000;
	MOV	BX,[BX].SETUP_ESC_PTR	; BX := Offset sequence to send 	;AN000;
	ADD	BX,BP								;AN000;
										;AN000;
SEND_1_SETUP_BYTE:								;AN000;
	MOV	AL,[BX] 		; AL := byte to print			;AN000;
	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
	JC	SETUP_PRT_END		; If printer error, quit the loop	;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_SETUP_BYTE						;AN000;
.ENDIF										;AN000;
SETUP_PRT_END:									;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
SETUP_PRT ENDP									;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; RESTORE_PRT : RESTORE THE PRINTER TO ITS INITIAL STATUS			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;				 record for the current mode			;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_COLOR							;AN000;
;		   PRT_BW_APA							;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the RESTORE escape sequence from the DISPLAYMODE 	;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_RESTORE_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; SI := CUR_MODE_PTR.RESTORE_ESC_PTR						;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
RESTORE_PRT PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
	XOR	CX,CX			; CX := Number of bytes to print	;AN000;
	MOV	CL,[BX].NUM_RESTORE_ESC 					;AN000;
.IF <CL G 0>				; If there is at least one		;AN000;
.THEN					; byte to be printed:			;AN000;
	MOV	BX,[BX].RESTORE_ESC_PTR ; BX := Offset sequence to send 	;AN000;
	ADD	BX,BP								;AN000;
										;AN000;
SEND_1_RESTORE_BYTE:								;AN000;
	MOV	AL,[BX] 		; AL := byte to print			;AN000;
	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
	JC	RESTORE_PRT_END 	; If printer error, quit the loop	;AN000;
	INC	BX			; Get next byte 			;AN000;
	LOOP	SEND_1_RESTORE_BYTE						;AN000;
.ENDIF										;AN000;
RESTORE_PRT_END:								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
RESTORE_PRT ENDP								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; NEW_PRT_LINE : INITIALIZE THE PRINTER FOR A GRAPHIC LINE			;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		;AN000;
;				 record for the current mode			;AN000;
;	       CUR_SCAN_LNE_LENGTH = Number of bytes to send to the printer.	;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;										;AN000;
;	CALLED BY: PRINT_BAND							;AN000;
;		   PRT_BW_APA							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Extract the GRAPHICS escape sequence from the DISPLAYMODE	;AN000;
; information record; Send this escape sequence to the printer. 		;AN000;
; Then, send the number of bytes that will follow.				;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Number of bytes to print := CUR_MODE_PTR.NUM_GRAPHICS_ESC			;AN000;
;										;AN000;
; Get the escape sequence:							;AN000;
; Set up the 2 bytes containing the number of bytes to send in this sequence.	;AN000;
; SI := CUR_MODE_PTR.GRAPHICS_ESC_PTR						;AN000;
;										;AN000;
; FOR each byte to be printed							;AN000;
;   PRINT_BYTE [SI]			; Send the byte to the printer		;AN000;
;   INC SI				; Get the next byte			;AN000;
;										;AN000;
; Send the byte count								;AN000;
;										;AN000;
										;AN000;
NEW_PRT_LINE PROC NEAR								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	DI								;AN000;
										;AN000;
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set up the 2 bytes containing the number of bytes to send in the GRAPHICS seq.;AN000;
; NOTE: number of bytes to send is "CUR_SCAN_LNE_LENGTH * BOX_W"                ;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AL,BOX_W		;   cur_scan_lne_length *		;AN000;
	CBW				;   printer box width = nb bytes to send;AN000;
	MUL	CUR_SCAN_LNE_LENGTH	;     (result in DX AX) 		;AN000;
;-------AX := Number of bytes to print						;AN000;

; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we have added the key words DATA and COUNT to the		
;               list of allowable words for the GRAPHICS statement
;               we have to take into consideration if the esc. sequence
;               numbers come before of after the word DATA.  Also we have
;               to take into consideration if the printer is expecting
;               to receive the COUNT in binary form or in ASCII form.
;               Note this section of code replaces the section of code
;               which follows it.
        MOV     DI,[BX].GRAPHICS_ESC_PTR        ; DI := offset seq. to send
	XOR	CX,CX				; CX := Length of the escape seq
        MOV	CL,[BX].NUM_GRAPHICS_ESC	;	before the word DATA			
        
       .WHILE <CX NE 0>         ; Doing while loop just in case DATA is the 
                                ; first word after  GRAPHICS.  In that case 
                                ; skip this and send the actual data.
                 MOV    BL,BYTE PTR DS:[BP+DI]            ; Get code.
                                                          ;
                .SELECT                                   ; Case statement
                .WHEN <BL EQ ESC_NUM_CODE>                ; We have an esc. number
       	                PUSH      AX                      ; Save count
                        INC       DI                      ; Point to esc. number
                        MOV       AL,DS:[BP+DI]           ;
                        CALL      PRINT_BYTE              ; Send esc. number
                        JC        NEW_PRT_LINE_ENDP_1     ; If printer error then quit 
                                                          ; the loop and restore registers
                        INC       DI                      ; Point to next tag
                        POP       AX                      ; Restore the count
                        DEC       CX                      ;
                .WHEN <BL EQ COUNT_CODE>                  ; Need to send count in ascii form
       	                PUSH      AX                      ; Save count
                        PUSH      SI                      ;
                        CALL      GET_COUNT               ; Get # bytes to send to printer
                        PUSH      CX                      ; Save counter for outside loop
                        XOR       CH,CH                   ;
                        MOV       CL,DS:[BP].NUM_BYTES_FOR_COUNT        ;
                        LEA       SI,DS:[BP].COUNT        ; Get ptr. to count
                        SUB       SI,CX                   ; Need to send MSB first
                        INC       SI                      ;
                        CLD                               ;
SEND_ASCII_COUNT:                                         ;
                        LODSB                             ;
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP_2     ; If printer error then quit 
                                                          ; the loop and restore registers
                        LOOP      SEND_ASCII_COUNT        ;
                        POP       CX                      ; Restore outside loop counter
                        ADD       DI,2                    ; Point to next tag
                        POP       SI                      ;
                        POP       AX                      ; Restore COUNT
                        DEC       CX                      ;
                .WHEN <BL EQ LOWCOUNT_CODE>               ; Sending lowbyte of COUNT 
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP       ; If printer error then quit 
                        ADD       DI,2                    ; Point to next tag
                        DEC       CX                      ;
                .WHEN <BL EQ HIGHCOUNT_CODE>              ; Sending highbyte of COUNT
       	                PUSH      AX                      ; Save count 
                        CWD                               ;
                        MOV       BX,100h                 ;
                        DIV       BX                      ; Put highbyte in AL
                        CALL      PRINT_BYTE              ; Print it
                        JC        NEW_PRT_LINE_ENDP_1     ; If printer error then quit 
                                                          ; the loop and restore registers
                        ADD       DI,2                    ; Point to next tag
                                                          ; the loop.
                        POP       AX                      ; Restore count
                        DEC       CX                      ;
                .ENDSELECT                                ;
       .ENDWHILE                                          ;
        ADD	DI,2                                      ; Skip over DATA tag and byte 
                                                          ; so pointing to correct place when 
                                                          ; get to END_PRT_LINE proc.
; /\ ~~mda(001) -----------------------------------------------------------------------

; \/ ~~mda(001) -----------------------------------------------------------------------
;               The following piece of code is replaced by the above piece
;               of code.
;
;;;;    MOV	DI,[BX].LOW_BYT_COUNT_PTR; DI := Offset of LOW byte of		;AN000;
;;;;	ADD	DI,BP			;	 byte count			;AN000;
;;;;	MOV	[DI],AL 		; Store low byte			;AN000;
;;;;	MOV	DI,[BX].HGH_BYT_COUNT_PTR; DI := Offset of HIGH byte of 	;AN000;
;;;;	ADD	DI,BP			;	 byte count			;AN000;
;;;;	MOV	[DI],AH 		; Store high byte			;AN000;
;;;;										;AN000;
;;;;;-------------------------------------------------------------------------------;AN000;
;;;;; Send the GRAPHICS escape sequence to the printer:				;AN000;
;;;;;-------------------------------------------------------------------------------;AN000;
;;;;	XOR	CX,CX				; CX := Length of the escape seq;AN000;
;;;;	MOV	CL,[BX].NUM_GRAPHICS_ESC					;AN000;
;;;;	MOV	BX,[BX].GRAPHICS_ESC_PTR	; BX := Offset sequence to send ;AN000;
;;;;	ADD	BX,BP								;AN000;
;;;;										;AN000;
;;;;SEND_1_GRAPHICS_BYTE:							;AN000;
;;;;	MOV	AL,[BX] 		; AL := byte to print			;AN000;
;;;;	CALL	PRINT_BYTE		; Send it to the printer		;AN000;
;;;;	JC	NEW_PRT_LINE_ENDP	; If printer error, quit the loop	;AN000;
;;;;	INC	BX			; Get next byte 			;AN000;
;;;;	LOOP	SEND_1_GRAPHICS_BYTE						;AN000;
; /\ ~~mda(001) -----------------------------------------------------------------------
JMP     SHORT  NEW_PRT_LINE_ENDP               ; ~~mda(001) Restore registers
        JMP     SHORT  NEW_PRT_LINE_ENDP       ;
NEW_PRT_LINE_ENDP_2:                    ; ~~mda(001) 
        POP     SI
NEW_PRT_LINE_ENDP_1:			; ~~mda(001) 
        POP     AX
NEW_PRT_LINE_ENDP:								;AN000;
	POP	DI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
NEW_PRT_LINE ENDP								;AN000;
PAGE										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we have the keyword DATA, and we allow it to be anywhere
;               on the GRAPHICS line, then it is possible to have an
;               esc. sequence to send to the printer after the data has been
;               sent.  Therefore we need this new procedure.
;===============================================================================
;										
; END_PRT_LINE : SEND THE REST OF THE GRAPHICS LINE			        
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: CUR_MODE_PTR = Offset of the DISPLAYMODE information		
;    			      record for the current mode			
;              DI           = Points to the section of the esc. seq that
;                             comes after the keyword DATA.
;										
;	OUTPUT: PRINTER 							
;										
;	CALLED BY: PRT_BW_APA							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: Extract the GRAPHICS escape sequence that comes after the keyword
; DATA from the DISPLAYMODE information record; Send this escape sequence to the
; printer. 		                                                        
;										
;										

CR_FOUND        DB      ?       ; So we know if a carriage return has been sent
LF_FOUND        DB      ?       ; So we know if a line feed has been sent

END_PRT_LINE PROC NEAR								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
        MOV     CR_FOUND,NO             ; Initialize
        MOV     LF_FOUND,NO             ; 
	MOV	BX,CUR_MODE_PTR 	; BX := Displaymode info record.	
										
;-------------------------------------------------------------------------------
; Set up the 2 bytes containing the number of bytes to send in the GRAPHICS seq.
; NOTE: number of bytes to send is "CUR_SCAN_LNE_LENGTH * BOX_W"                
;-------------------------------------------------------------------------------
	MOV	AL,BOX_W		;   cur_scan_lne_length *		
	CBW				;   printer box width = nb bytes to send
	MUL	CUR_SCAN_LNE_LENGTH	;     (result in DX AX) 		
;-------AX := Number of bytes to print						

	XOR	CX,CX				        ; CX := Length of the escape seq
        MOV	CL,[BX].NUM_GRAPHICS_ESC_AFTER_DATA	;after the word DATA		
        

       .WHILE <CX NE 0>         ; Doing a while loop just in case DATA is the 
                                ; last word on the GRAPHICS line.  In that case 
                                ; skip this and send a CR or LF if needed.
                 MOV    BL,BYTE PTR DS:[BP+DI]            ; Get code.

                .SELECT                                   ; Case statement
                .WHEN <BL EQ ESC_NUM_CODE>                ; We have an esc. number
       	                PUSH      AX                      ; Save count
                        INC       DI                      ; Point to esc. number
                        MOV       AL,DS:[BP+DI]           ;
                       .IF <AL EQ CR>                     ; Check if a CR is 
                            MOV     CR_FOUND,YES          ; explicitly stated
                       .ENDIF
                       .IF <AL EQ LF>                     ; Check if a LF is 
                            MOV     LF_FOUND,YES          ; explicitly stated
                       .ENDIF
                        CALL      PRINT_BYTE              ; Send esc. number
                        JC        GOTO_END_PRT_LINE_ENDP_1; If printer error then quit 
                                                          ; the loop and restore registers
                        INC       DI                      ; Point to next tag
                        POP       AX                      ; Restore the count
                        DEC       CX                      ;
                .WHEN <BL EQ COUNT_CODE>                  ; Need to send count in ascii form
       	                PUSH      AX                      ; Save count
                        PUSH      SI                      ;
                        CALL      GET_COUNT               ; Get # of bytes to send to printer
                        PUSH      CX                      ; Save counter for outside loop
                        XOR       CH,CH                   ;
                        MOV       CL,DS:[BP].NUM_BYTES_FOR_COUNT     ;
                        LEA       SI,DS:[BP].COUNT        ; Get ptr. to count
                        SUB       SI,CX                   ; Need to send MSB first
                        INC       SI                      ;
                        CLD                               ;
SEND_THE_ASCII_COUNT:                                     ;
                        LODSB                             ;
                        CALL      PRINT_BYTE              ; Print it
                        JC        GOTO_END_PRT_LINE_ENDP_2     ; If printer error then quit 
                                                          ; the loop and restore registers.
                        LOOP      SEND_THE_ASCII_COUNT    ;
                        POP       CX                      ; Restore outside loop counter
                        ADD       DI,2                    ; Point to next tag
                        POP       SI                      ;
                        POP       AX                      ; Restore COUNT
                        DEC       CX                      ;
                .WHEN <BL EQ LOWCOUNT_CODE>               ; Sending lowbyte of COUNT 
                        CALL      PRINT_BYTE              ; Print it
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
                        ADD       DI,2                    ; Point to next tag
                        DEC       CX                      ;
                .WHEN <BL EQ HIGHCOUNT_CODE>              ; Sending highbyte of COUNT
       	                PUSH      AX                      ; Save count
                        CWD                               ;
                        MOV       BX,100h                 ;
                        DIV       BX                      ; Put highbyte in AL
                        CALL      PRINT_BYTE              ; Print it
                        JC        END_PRT_LINE_ENDP_1     ; If printer error then quit
                                                          ; the loop and restore registers
                        ADD       DI,2                    ; Point to next tag
                                                          ; the loop.
                        POP       AX                      ; Restore count
                        DEC       CX                      ;
                .ENDSELECT                                ;
       .ENDWHILE                                          ;
        JMP     SHORT  CR_LF                              ;
GOTO_END_PRT_LINE_ENDP_2:                                 ; Conditional jump was out of range
        JMP     SHORT  END_PRT_LINE_ENDP_2                ;
GOTO_END_PRT_LINE_ENDP_1:                                 ; Conditional jump was out of range
        JMP     SHORT END_PRT_LINE_ENDP_1                 ;
CR_LF:                                                    ;
       .IF <DS:[BP].PRINTER_NEEDS_CR_LF EQ YES>           ; ~~mda(003) We have an IBM type printer  
                                                          ; so we need to do a CR and LF if it 
                                                          ; already hasn't been done.
               .IF <CR_FOUND EQ NO>                       ; It hasn't been done.
                        MOV       AL,CR                   ;
                        CALL      PRINT_BYTE              ;
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
               .ENDIF                                     ;
               .IF <LF_FOUND EQ NO>                       ; It hasn't been done.
                        MOV       AL,LF                   ;
                        CALL      PRINT_BYTE              ;
                        JC        END_PRT_LINE_ENDP       ; If printer error then quit 
               .ENDIF                                     ;       
                                                          ;
       .ENDIF                                             ;
JMP     NEW_PRT_LINE_ENDP                                 ; Restore registers
        JMP     SHORT   END_PRT_LINE_ENDP                 ;
END_PRT_LINE_ENDP_2:                                      ; Restore registers										
        POP     SI                                        ;
END_PRT_LINE_ENDP_1:			                  ; Restore registers							
        POP     AX                                        ;
END_PRT_LINE_ENDP:					  ;			
	POP	DI					  ;			
	POP	DX					  ;			
	POP	CX					  ;			
	POP	BX					  ;			
	POP	AX					  ;			
	RET						  ;			
END_PRT_LINE ENDP					  ;			
; /\ ~~mda(001) -----------------------------------------------------------------------
PAGE										;AN000;
; \/ ~~mda(001) -----------------------------------------------------------------------
;               Since we now can do HP PCL, we have to get the number of
;               bytes that are going to be sent to the printer and convert 
;               the number to ASCII if DATA_TYPE = DATA_ROW.
;===============================================================================;AN000;
;										;AN000;
; GET_COUNT : GET THE NUMBER OF BYTES TO SEND TO THE PRINTER 
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT: CUR_SCAN_LNE_LENGTH
;              NB_BOXES_PER_PRT_BUF                                            ;AN000;
;										;AN000;
;       output : si	pointer to ascii string
;
;	         si  --> len=4    (hex = 4d2h)
;		         1
;		         2
;		         3
;		         4
;
;	         count (from shared_data_area)
;
;										;AN000;
;	CALLED BY: NEW_PRT_LINE
;                  END_PRT_LINE
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_COUNT 	proc	near
		push	ax	       ;
		push	bx	       ;
		push	cx	       ;
		push	dx	       ;
                push    si             ;

                mov     ax,cur_scan_lne_length  ; Get # bytes to send to
                cwd                             ; the printer
                xor     bh,bh                   ;
                mov     bl,nb_boxes_per_prt_buf ; 
                div     bx                      ;
               .IF <DX NE 0>                    ; So don't lose data when
                     INC        AX              ; have a remainder.
               .ENDIF                           ;

                                                ;
;--------- AX is the # bytes to send to the printer. Now convert it to ascii.
                                                ;
		xor	dx,dx	                ;clear upper 16 bits
		lea	si,ds:[bp].count        ;get pointer
                PUSH    SI                      ; Save ptr.
                MOV     CX,5                    ; Init. COUNT
INIT_COUNT:                                     ;
                MOV     BYTE PTR [SI],0         ;
                DEC     SI                      ;
                LOOP    INIT_COUNT              ;
                POP     SI                      ;
                                                ;
		mov	bx,10	                ; mod 10, div 10
		xor	cx,cx	                ;length counter = 0
hx_asc:                                         ;
		div	bx	                ;div, mod
		add	dl,'0'                  ;add 48 for ASCII
		mov	[si],dl                 ;store it
		dec	si	                ;point to next string element
		inc	cx	                ;inc length counter
		xor	dx,dx	                ;consider only div part for next loop
		cmp	ax,0	                ;end of loops ? (div=0)
		jnz	hx_asc	                ;no
                mov     ds:[bp].num_bytes_for_count,cl     ;save the length
                                                ;
                pop     si                      ;
		pop	dx	                ;
		pop	cx	                ;
		pop	bx	                ;
		pop	ax	                ;
		ret                             ;
GET_COUNT 	endp                            ;
; /\ ~~mda(001) -----------------------------------------------------------------------
PAGE                                            
;
;===============================================================================;AN000;
;										;AN000;
; PRINT_BYTE : SEND A BYTE TO THE PRINTER AT LPT1				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	AL		= Byte to be printed				;AN000;
;										;AN000;
;	OUTPUT: PRINTER 							;AN000;
;		ERROR_CODE	= PRINTER_ERROR if an error is detected.	;AN000;
;		Carry flag is set in case of error.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINT_BYTE PROC    NEAR 							;AN000;
	PUSH	AX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
	MOV	DX,0000 	; PRINTER NUMBER				;AN000;
	MOV	AH,00		; REQUEST PRINT 				;AN000;
	INT	17H		; CALL BIOS : SEND THE CHARACTER		;AN000;
										;AN000;
	AND	AH,00101001B	; Test error code returned in AH for		;AN000;
				;   "Out of paper", "I/O error" and "Time-out". ;AN000;
	JNZ	PRINT_BYTE_ERROR; Set the error code if error			;AN000;
	JMP	SHORT PRINT_BYTE_END ; else, return normally			;AN000;
PRINT_BYTE_ERROR:								;AN000;
	MOV	ERROR_CODE,PRINTER_ERROR					;AN000;
	STC			; Set the carry flag to indicate ERROR		;AN000;
PRINT_BYTE_END: 								;AN000;
	POP	DX								;AN000;
	POP	AX								;AN000;
	RET									;AN000;
PRINT_BYTE ENDP 								;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; READ_DOT: READ A PIXEL - RETURN A COLOR TRANSLATION TABLE INDEX		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	CUR_MODE   = Current video mode.				;AN000;
;		CUR_ROW,							;AN000;
;		CUR_COLUMN = Coordinates of the pixel to be read.		;AN000;
;		CUR_PAGE   = Active page number 				;AN000;
;										;AN000;
;	OUTPUT: AL	   = Index into COLOR TRANSLATION TABLE.		;AN000;
;										;AN000;
;	DEPENDENCIES : COLOR TRANSLATION TABLE entries must be bytes		;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Use VIDEO BIOS INTERRUPT 10H "READ DOT CALL".                    ;AN000;
;										;AN000;
; Depending on the video hardware, the dot returned by BIOS has 		;AN000;
; different meanings.								;AN000;
; With an EGA it is an index into the Palette registers,			;AN000;
; With a CGA it is a number from 0 to 3,  mapping to a specific color		;AN000;
; depending on the background color and the color palette currently		;AN000;
; selected.									;AN000;
;										;AN000;
; The Color Translation table has been set up to hold the correct color 	;AN000;
; mapping for any "dot" in any mode.  Therefore, the dot number returned        ;AN000;
; by INT 10H can be used with any mode as a direct index within that		;AN000;
; table.									;AN000;
;										;AN000;
; With APA Monochrome mode 0FH there are 4 different dots: white,		;AN000;
; blinking white, high-intensity white, and black.				;AN000;
;										;AN000;
; For mode 0FH, the dot returned by interrupt 10 "read dot" call is a byte      ;AN000;
; where only bits 0 and 2 are significant.  These 2 bits must be appended	;AN000;
; together in order to obtain a binary number (from 0 to 3) that will be used	;AN000;
; as an index in the Color Translation table.					;AN000;
;										;AN000;
; For mode 11H, the dot is either 0 (for background color) or 7 (for the	;AN000;
; foreground color) only the LSB is returned.  That is, we return either	;AN000;
; 0 or 1.									;AN000;
;										;AN000;
; LOGIC:									;AN000;
;										;AN000;
; Call VIDEO BIOS "READ DOT"                                                    ;AN000;
; IF CUR_MODE = 0FH								;AN000;
; THEN										;AN000;
;   Append bits 1 and 3.							;AN000;
; IF CUR_MODE = 11H								;AN000;
; THEN										;AN000;
;   Wipe out bits 1 and 2.							;AN000;
;										;AN000;
READ_DOT PROC NEAR								;AN000;
	PUSH	BX			; Save registers			;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
										;AN000;
	MOV	BH,CUR_PAGE							;AN000;
	MOV	DX,CUR_ROW							;AN000;
	MOV	CX,CUR_COLUMN							;AN000;
	MOV	AH,READ_DOT_CALL						;AN000;
	INT	10H			; Call BIOS: AL <-- Dot read		;AN000;
										;AN000;
	CMP	CUR_MODE,0FH		; Is it Mode 0fH ?			;AN000;
	JNE	MODE_11H?		; No, look for mode 11h.		;AN000;
;-------Mode 0Fh is the current mode:						;AN000;
;-------Convert bits 2 and 0 into a 2 bit number:				;AN000;
	MOV	BL,AL			; BL := AL = "Pixel read"               ;AN000;
	AND	BL,00000100B		; Wipe off all bits but bit 2 in BL	;AN000;
	AND	AL,00000001B		; Wipe off all bits but bit 0 in AL	;AN000;
	SHR	BL,1			;  Move bit 2 to bit 1 in BL		;AN000;
	OR	AL,BL			;  Append bit 1 and bit 0		;AN000;
	JMP	SHORT READ_DOT_END	;  Quit.				;AN000;
										;AN000;
MODE_11H?:									;AN000;
	CMP	CUR_MODE,11H		; Is it Mode 0fH ?			;AN000;
	JNE	READ_DOT_END		; No, quit				;AN000;
										;AN000;
;-------Mode 11H is the current mode:						;AN000;
	AND	AL,00000001B		; Keep only the Least significant bit	;AN000;
										;AN000;
READ_DOT_END:									;AN000;
	POP	DX			; Restore registers			;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
READ_DOT ENDP									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grcpsd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Copy Shared Data
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                              
;;										;AN000;
;; File Name:  GRCPSD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the COPY_SHARED_DATA module.			;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 COPY_SHARED_DATA - Copy the Shared Data Area from temporary		;AN000;
;;			    build area to resident memory & exit to DOS 	;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 None									;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME CS:CODE,DS:CODE	       ;;					;AN000;
	INCLUDE GRCTRL.EXT	       ;; Bring in external declarations	;AN000;
	INCLUDE GRCTRL.STR	       ;;  for transient command processing	;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC COPY_SHARED_DATA	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   COPY_SHARED_DATA								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   DS : SI - points to the Temporary Shared Data Area 			;AN000;
;;   ES : DI - destination for resident Shared Data Area			;AN000;
;;   BP      - offset for new Shared Data Area (same as DI)			;AN000;
;;   AH    - Function code for exiting to DOS:					;AN000;
;;	     31H : Terminate & Stay Resident - if first time			;AN000;
;;	     4CH : Terminate - if already installed				;AN000;
;;   DX    - resident data segment size in paragraphs				;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Control Variables								;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Copy the Temporary Shared Data area over the installation modules		;AN000;
;;   and terminate (stay resident).  The data is copied immediately		;AN000;
;;   following this module.							;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   GRAPHICS_INSTALL								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   Copy Temporary Shared Data Area						;AN000;
;;   Set PRINT_SCREEN_ALLOWED to YES						;AN000;
;;   Exit to DOS (Function Code 31 or 4C setup by caller)			;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COPY_SHARED_DATA  PROC NEAR	       ;;					;AN000;
				       ;;					;AN000;
	REP	MOVSB		       ;; Copy Shared Data from temporary	;AN000;
				       ;;  build area to resident memory	;AN000;
				       ;; Allow print screens now		;AN000;
	MOV	ES:PRINT_SCREEN_ALLOWED,YES					;AN000;
				       ;;					;AN000;
	INT	21H		       ;; Exit					;AN000;
				       ;;					;AN000;
COPY_SHARED_DATA  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
CODE	ENDS									;AN000;
	END COPY_SHARED_DATA							;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grload.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I added an entry in the VERB_JMP_TAB and the equate DEF to 
;**                handle the new statement DEFINE.  I also made the new variable
;**                DATA_TYPE have the default of DATA_COL in the procedure
;**                LOAD_PROFILE, so the default assumes IBM type printers.
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules		;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                     
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRLOAD2.EXT	       ;;					;AN000;
	INCLUDE GRLOAD3.EXT	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC  LOAD_PROFILE 							;AN000;
   PUBLIC  GROW_SHARED_DATA							;AN000;
   PUBLIC  BLOCK_START								;AN000;
   PUBLIC  BLOCK_END								;AN000;
   PUBLIC  FIRST_BLOCK								;AN000;
   PUBLIC  MAX_BLOCK_END							;AN000;
   PUBLIC  GROUPS_DONE								;AN000;
   PUBLIC  STMTS_DONE								;AN000;
   PUBLIC  STMTS_DONE								;AN000;
   PUBLIC  PTD_FOUND								;AN000;
   PUBLIC  BUILD_STATE								;AN000;
   PUBLIC  STMT_ERROR								;AN000;
   PUBLIC  FILE_ERROR								;AN000;
   PUBLIC  PARSE_ERROR								;AN000;
   PUBLIC  END_OF_FILE								;AN000;
   PUBLIC  MEM_OVERFLOW 							;AN000;
   PUBLIC  STMT_BUFFER								;AN000;
   PUBLIC  CUR_STMT								;AN000;
   PUBLIC  PREV_STMT								;AN000;
   PUBLIC  PRT_BOX_ERROR							;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   LOAD_PROFILE								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   DS,ES,SS - points to our transient segment 				;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   Temporary Shared Data Area 						;AN000;
;;   Carry flag set if errors in profile.					;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;   Shared Data Area								;AN000;
;;   Profile Load Variables							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Build the profile information in the Temporary Shared Data Area.		;AN000;
;;   The information will be built for the printer type parsed off		;AN000;
;;   the command line.	ALL Printer Type Descriptions will be			;AN000;
;;   parsed to issue error messages and determine the maximum			;AN000;
;;   amount of resident memory required for initial load.			;AN000;
;;   The Shared Data Area begins with a fixed length section			;AN000;
;;   and then has several variable length sections.  PROFILE_BUILD_PTR		;AN000;
;;   is used to build the variable length sections by serving			;AN000;
;;   as a running pointer to the sections as they are built.			;AN000;
;;										;AN000;
;; Register Usage:								;AN000;
;;   BP - points to beginning of Temp Shared Data				;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   GRAPHICS_INSTALL								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   PARSE_PRINTER, PARSE_DISPLAYMODE, PARSE_SETUP, PARSE_RESTORE		;AN000;
;;   PARSE_PRINTBOX, PARSE_GRAPHICS, PARSE_COLORSELECT, 			;AN000;
;;   PARSE_COLORPRINT, GET_STATEMENT						;AN000;
;;   SYSPARSE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   IF profile path not specified  THEN					;AN000;
;;	PROFILE_PATH := "GRAPHICS.PRO"  /* Current directory */                 ;AN000;
;;	Open profile using PROFILE_PATH 					;AN000;
;;	IF error during open THEN						;AN000;
;;	   PROFILE_PATH := ARG(V0) with "GRAPHICS.COM" replaced                 ;AN000;
;;	     by "GRAPHICS.PRO"                                                  ;AN000;
;;	   Open profile using PROFILE_PATH					;AN000;
;;	   IF error during open THEN						;AN000;
;;	      Issue "Cannot find profile" msg                                   ;AN000;
;;	      Set carry flag							;AN000;
;;	      RETURN								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;   ELSE									;AN000;
;;	Open profile using specified path					;AN000;
;;	IF error during open THEN						;AN000;
;;	   Issue "Cannot find profile" msg                                      ;AN000;
;;	   Set carry flag							;AN000;
;;	   RETURN								;AN000;
;;	ENDIF									;AN000;
;;   ENDIF									;AN000;
;;   /* don't start building until we find our printer type*/                   ;AN000;
;;   PARSE_MODE := NOBUILD							;AN000;
;;   MAX_BUILD_PTR := 0 							;AN000;
;;   CALL GROW_SHARED_DATA(PROFILE-BUILD_PTR,size of FIXED PART 		;AN000;
;;     of Shared Data Area)							;AN000;
;;   WHILE (not end of file) AND (no I/O error) DO				;AN000;
;;	CALL GET_STATEMENT							;AN000;
;;	IF I/O error THEN							;AN000;
;;	   Issue error message							;AN000;
;;	ELSE									;AN000;
;;	   CALL SYSPARSE to parse the statement verb				;AN000;
;;	   IF verb found THEN							;AN000;
;;	      IF invalid verb THEN						;AN000;
;;		 Issue error message						;AN000;
;;		 PARSE_MODE := ERROR						;AN000;
;;	      ELSE								;AN000;
;;		 CASE statement verb						;AN000;
;;		    PRINTER:							;AN000;
;;		       CALL PARSE_PRINTER					;AN000;
;;		    DISPLAYMODE:						;AN000;
;;		       CALL PARSE_DISPLAYMODE					;AN000;
;;		    PRINTBOX:							;AN000;
;;		       CALL PARSE_PRINTBOX					;AN000;
;;		    SETUP:							;AN000;
;;		       CALL PARSE_SETUP 					;AN000;
;;		    RESTORE:							;AN000;
;;		       CALL PARSE_RESTORE					;AN000;
;;		    GRAPHICS:							;AN000;
;;		       CALL PARSE_GRAPHICS					;AN000;
;;		    COLORPRINT: 						;AN000;
;;		       CALL PARSE_COLORPRINT					;AN000;
;;		    COLORSELECT:						;AN000;
;;		       CALL PARSE_COLORSELECT					;AN000;
;;		 ENDCASE							;AN000;
;;		 IF error on statement THEN					;AN000;
;;		    IF OVERFLOW bit set in RETURN_CODE THEN			;AN000;
;;		       Issue "Insufficient memory" message                      ;AN000;
;;		       RETURN to caller 					;AN000;
;;		    ELSE							;AN000;
;;		       IF MISSING bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "required statement missing" message            ;AN000;
;;		       ENDIF							;AN000;
;;		       IF INVALID bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "statement invalid" message                     ;AN000;
;;		       ENDIF							;AN000;
;;		       IF SEQUENCE bit set in RETURN_CODE THEN			;AN000;
;;			  Issue "out of sequence" message                       ;AN000;
;;		       ENDIF							;AN000;
;;		       display the statement in error				;AN000;
;;		    ENDIF							;AN000;
;;		    PARSE_MODE := ERROR 					;AN000;
;;		 ENDIF								;AN000;
;;	      ENDIF								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;   ENDWHILE									;AN000;
;;										;AN000;
;;   /* Check length of last PTD */						;AN000;
;;   IF PROFILE_BUILD_PTR > MAX_BUILD_PTR THEN					;AN000;
;;	MAX_BUILD_PTR := PROFILE_BUILD_PTR					;AN000;
;;   ENDIF									;AN000;
;;										;AN000;
;;   /* Make sure all required statements were in previous */			;AN000;
;;   /* Printer Type Description */						;AN000;
;;   /* Must have completed PRINTER, DISPLAYMODE, PRINTBOX and */		;AN000;
;;   /* GRAPHICS statements */							;AN000;
;;   IF PRT+DISP+BOX+GR bits not all set in STMTS_DONE THEN			;AN000;
;;	Issue "required statement missing" message                              ;AN000;
;;	Display "END OF FILE."                                                  ;AN000;
;;   ENDIF									;AN000;
;;										;AN000;
;;   IF errors during build THEN						;AN000;
;;	set carry flag								;AN000;
;;   ELSE									;AN000;
;;	SD_TOTAL_SIZE := MAX_BUILD_PTR - TEMP_SHARED_DATA_PTR			;AN000;
;;   ENDIF									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
FILE_NOT_FOUND	EQU  2		       ;; DOS Int21H error codes		;AN000;
PATH_NOT_FOUND	EQU  3		       ;;					;AN000;
				       ;;					;AN000;
SUBLIST     LABEL  BYTE 	       ;; Message substituion list for stmt #	;AN000;
	    DB	11		       ;; sublist size				;AN000;
	    DB	0		       ;;					;AN000;
	    DW	STMT_NUM	       ;; \ Dword pointer to item		;AN000;
SUBLIST_SEG DW	?		       ;; /					;AN000;
	    DB	1		       ;; Substitution #			;AN000;
;; Flag format	a0sstttt	       ;;					;AN000;
	    DB	00100001B	       ;; Unsigned binary word - left align	;AN000;
;;;;	    DB	00000000B	       ;; charcater				;AN000;
	    DB	0		       ;; max field width			;AN000;
	    DB	1		       ;; min width width			;AN000;
	    DB	' '                    ;; pad characeter                        ;AN000;
				       ;;					;AN000;
STMT_NUM    DW	0		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
FILE_ERROR  DB	0		       ;; Error opening or reading PROFILE	;AN000;
PARSE_ERROR DB	0		       ;; Syntax errors in PROFILE		;AN000;
END_OF_FILE	DB  0		       ;; 1 if end of file			;AN000;
MEM_OVERFLOW  DB  0		       ;; 1 if insufficient memory		;AN000;
				       ;;					;AN000;
STMT_ERROR  DB	0		       ;; Error flag for individual stmt errors ;AN000;
MISSING     EQU 1		       ;; Required statement missing		;AN000;
INVALID     EQU 2		       ;; Invalid statement format		;AN000;
SEQUENCE    EQU 4		       ;; Statement out of sequence		;AN000;
				       ;;					;AN000;
DEFAULT_PATH	  DB "GRAPHICS.PRO",0  ;;                                       ;AN000;
BUFFER	    DB	64 DUP("$")            ;;                                       ;AN000;
				       ;;					;AN000;
HANDLE	    DW	0		       ;; Profile handle			;AN000;
				       ;;					;AN000;
BUILD_STATE DB	0		       ;; 1 if we are currently building	;AN000;
				       ;;  data.  0 means syntax checking	;AN000;
				       ;;   only				;AN000;
				       ;;					;AN000;
				       ;; Keep track of whether this PTD	;AN000;
				       ;;  matches the type requested		;AN000;
PTD_FOUND   DB	0		       ;; Values are NO (0), YES (1) and	;AN000;
PROCESSED   EQU 2		       ;;  PROCESSED (2)			;AN000;
				       ;;					;AN000;
VERB	    DB	0		       ;; PTR into VERB_JMP_TAB 		;AN000;
				       ;;					;AN000;
VERB_JMP_TAB  LABEL WORD	       ;;					;AN000;
	DW  OFFSET PARSE_PRINTER       ;;					;AN000;
	DW  OFFSET PARSE_DISPLAYMODE   ;;					;AN000;
	DW  OFFSET PARSE_PRINTBOX      ;;					;AN000;
	DW  OFFSET PARSE_SETUP	       ;;					;AN000;
	DW  OFFSET PARSE_RESTORE       ;;					;AN000;
	DW  OFFSET PARSE_GRAPHICS      ;;					;AN000;
	DW  OFFSET PARSE_COLORPRINT    ;;					;AN000;
	DW  OFFSET PARSE_COLORSELECT   ;;					;AN000;
	DW  OFFSET PARSE_DARKADJUST    ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the following so that LOAD_PROFILE will parse the
;               DEFINE statement.
;
        DW  OFFSET PARSE_DEFINE         ;
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
STMTS_DONE   DW  0		       ;;					;AN000;
GROUPS_DONE  DW  0		       ;;					;AN000;
PREV_STMT    DW  0		       ;;					;AN000;
CUR_STMT     DW  0		       ;;					;AN000;
				       ;;					;AN000;
PRT	EQU  1			       ;; Bit masks for STMTS_DONE and		;AN000;
DISP	EQU  2			       ;;  GROUPS_DONE.  There is one		;AN000;
BOX	EQU  4			       ;;   bit for each statement except	;AN000;
GR	EQU  8			       ;;    DARKADJUST 			;AN000;
SET	EQU  10H		       ;;					;AN000;
REST	EQU  20H		       ;;					;AN000;
COLS	EQU  40H		       ;;					;AN000;
COLP	EQU  80H		       ;;					;AN000;
DARK	EQU  100H		       ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the following for the DEFINE statement.
;
DEF     EQU  200H
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
BLOCK_START  DW  ?		       ;; Extents of the variable size block	;AN000;
BLOCK_END    DW  ?		       ;;  currently being built		;AN000;
				       ;; These are relative to the		;AN000;
				       ;;  start of the Shared Data Area	;AN000;
				       ;;   so the area can be relocated	;AN000;
MAX_BLOCK_END	DW  0		       ;; End of largest PTD contained		;AN000;
				       ;;  in profile				;AN000;
FIRST_BLOCK  DW  ?		       ;; Pointer to first variable block	;AN000;
				       ;;  (end of fixed part)			;AN000;
PRT_BOX_ERROR  DB  0		       ;;					;AN000;
				       ;;					;AN000;
LOAD_PROFILE  PROC NEAR 	       ;;					;AN000;
				       ;;					;AN000;
  PUSH	CS			       ;;					;AN000;
  POP	SUBLIST_SEG		       ;; setup segment for message sublist	;AN000;
				       ;;					;AN000;
  CALL OPEN_FILE		       ;;					;AN000;
 .IF <FILE_ERROR EQ YES>	       ;; Check for error during open		;AN000;
     STC			       ;;					;AN000;
     RET			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  BP,TEMP_SHARED_DATA_PTR	       ;; BP points to START of Shared Data	;AN000;
  MOV  AX,SIZE SHARED_DATA_AREA_STR    ;; size of fixed part of Shared Data	;AN000;
  MOV  BLOCK_END,0		       ;; Initialize BLOCK_START,BLOCK_END	;AN000;
  MOV  [BP].DARKADJUST_VALUE,0	       ;; Init some values in the fixed 	;AN000;
  MOV  [BP].NUM_PRT_COLOR,0	       ;;  area 				;AN000;
  MOV  [BP].COLORPRINT_PTR,-1	       ;;					;AN000;
  MOV  [BP].NUM_PRT_BANDS,0	       ;;					;AN000;
  MOV  [BP].COLORSELECT_PTR,-1	       ;;					;AN000;
  MOV  [BP].PRINTER_TYPE,BLACK_WHITE   ;;					;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Make the default DATA_TYPE be DATA_COL for the IBM printers.
;
  MOV [BP].DATA_TYPE,DATA_COL           ;
;/\  ~~mda(001) ----------------------------------------------------------
  CALL GROW_SHARED_DATA 	       ;;  to the first byte after the		;AN000;
				       ;;   fixed part of Shared Data		;AN000;
     MOV  AX,BLOCK_END		       ;; Variable size data will be built	;AN000;
     MOV  BLOCK_START,AX	       ;;  starting at BLOCK_START		;AN000;
     MOV  FIRST_BLOCK,AX	       ;; Save start of variable data		;AN000;
				       ;;					;AN000;
     MOV  SI,BUFFER_PTR 	       ;; Set up SI for GET_BYTE		;AN000;
     CALL GET_BYTE		       ;; Get first byte from file		;AN000;
     MOV  NEXT_BYTE,AL		       ;;  and store it 			;AN000;
     MOV  BUFFER_PTR,SI 	       ;; Save SI for next GET_BYTE		;AN000;
    .WHILE <END_OF_FILE EQ NO> AND     ;; Keep parsing until end of file or	;AN000;
    .WHILE <FILE_ERROR EQ NO>	       ;;  file error occurs			;AN000;
       MOV STMT_ERROR,0 	       ;; Clear parse error flags		;AN000;
       CALL GET_STATEMENT	       ;; Get next profile statement		;AN000;
       INC  STMT_NUM		       ;;					;AN000;
      .IF NC			       ;; Carry flag set if get unsuccessful	;AN000;
	  CALL PARSE_VERB	       ;; Index into verb jump table returned	;AN000;
				       ;;  in BX				;AN000;
	 .IF <AX EQ 0> THEN	       ;; AX=0 if there is a recognized 	;AN000;
	    MOV  AX,CUR_STMT	       ;;					;AN000;
	    MOV  PREV_STMT,AX	       ;; Save last statement verb		;AN000;
	    CALL VERB_JMP_TAB[BX]      ;;  statement to parse			;AN000;
	 .ELSEIF <AX NE -1> THEN       ;;					;AN000;
	    OR	 STMT_ERROR,INVALID    ;;					;AN000;
	    MOV  PARSE_ERROR,YES       ;;					;AN000;
	    MOV  BUILD_STATE,NO        ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	 .IF <STMT_ERROR NE 0>	       ;; An error was detected 		;AN000;
	    CALL SHOW_PARSE_ERROR      ;;					;AN000;
	    MOV PARSE_ERROR,YES        ;;					;AN000;
	    MOV STMT_ERROR,0	       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
    .ENDWHILE			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE  AND PRT>	       ;; Must have at least one PRINTER	;AN000;
     CALL TERMINATE_DISPLAYMODE        ;; Terminate the last PRINTER and	;AN000;
     CALL TERMINATE_PRINTER	       ;;  DISPLAYMODE sections 		;AN000;
 .ELSE				       ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
 .IF <STMT_ERROR NE 0>		       ;;					;AN000;
     CALL  SHOW_PARSE_ERROR	       ;; Issue Profile syntax messages 	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,3E00H 		       ;; Close the file			;AN000;
  MOV  BX,HANDLE		       ;;					;AN000;
  INT  21H			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PARSE_ERROR EQ YES>	       ;;					;AN000;
      MOV  AX,SYNTAX_ERRORS	       ;; Issue "Syntax errors found in         ;AN000;
      MOV  CX,0 		       ;;  profile" message.                    ;AN000;
      CALL DISP_ERROR		       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PTD_FOUND EQ NO>		       ;; Did we find the requested printer	;AN000;
      MOV  AX,INVALID_PRT	       ;;  type?  If not issue error		;AN000;
      MOV  CX,0 		       ;;  message.				;AN000;
      CALL DISP_ERROR		       ;;					;AN000;
      MOV  PARSE_ERROR,YES	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <PARSE_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <PRT_BOX_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <FILE_ERROR EQ YES>	       ;; Set carry flag if profile load	;AN000;
     STC			       ;;  was unsuccessful			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <MEM_OVERFLOW EQ YES>	       ;; Everthing else was OK BUT we ran	;AN000;
	.IF <INSTALLED EQ YES>	       ;;  out of memory!!!			;AN000;
	    MOV   AX,NB_FREE_BYTES     ;;					;AN000;
	   .IF <AX LT RESIDENT_SHARED_DATA_SIZE>				;AN000;
	       MOV   AX,NO_MEMORY      ;; We ran out of physical memory!	;AN000;
	   .ELSE		       ;;					;AN000;
	       MOV   AX,UNABLE_RELOAD  ;; Allocated shared data is too small	;AN000;
	   .ENDIF		       ;;					;AN000;
	.ELSE			       ;;					;AN000;
	    MOV   AX,NO_MEMORY	       ;; We ran out of physical memory 	;AN000;
	.ENDIF			       ;;					;AN000;
	 MOV   CX,0		       ;;					;AN000;
	 CALL  DISP_ERROR	       ;;					;AN000;
	 STC			       ;; Indicate unsuccessful 		;AN000;
    .ELSE			       ;;					;AN000;
	 MOV  AX,MAX_BLOCK_END	       ;; Extent of largest PRINTER section	;AN000;
	 MOV  [BP].SD_TOTAL_SIZE,AX    ;;  we parsed.				;AN000;
	 CLC			       ;; SUCCESSFUL LOAD!!!!			;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
LOAD_PROFILE  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   SHOW_PARSE_ERROR								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
CARRAIGE_RET   EQU  13		       ;;					;AN000;
LINE_FEED      EQU  10		       ;;					;AN000;
				       ;;					;AN000;
SHOW_PARSE_ERROR   PROC 	       ;;					;AN000;
				       ;;					;AN000;
  MOV  ERROR_DEVICE,STDOUT	       ;; profile syntax messages to STDOUT	;AN000;
				       ;;					;AN000;
 .IF <BIT STMT_ERROR AND MISSING>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,MISSING_STMT    ;;							;AN000;
    MOV  CX,1		    ;;							;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;							;AN000;
 .IF <BIT STMT_ERROR AND INVALID>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,INVALID_STMT    ;;							;AN000;
    MOV  CX,1									;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;							;AN000;
 .IF <BIT STMT_ERROR AND SEQUENCE>						;AN000;
    PUSH SI		    ;;							;AN000;
    MOV  AX,OUT_SEQ_STMT    ;;							;AN000;
    MOV  CX,1									;AN000;
    MOV  SI,OFFSET SUBLIST  ;;							;AN000;
    CALL DISP_ERROR	    ;;							;AN000;
    POP  SI		    ;;							;AN000;
 .ENDIF 		    ;;	                                                ;AN000;
				       ;;					;AN000;
  MOV  DI,STMT_END_INDEX  ;;							;AN000;
  MOV  STMT_BUFFER[DI],'$'           ;; For display                             ;AN000;
  MOV  AH,9			     ;; 					;AN000;
  MOV  DX,OFFSET STMT_BUFFER							;AN000;
  INT  21H			     ;; 					;AN000;
  MOV  DL,CARRIAGE_RET		     ;; 					;AN000;
  MOV  AH,2			     ;; 					;AN000;
  INT  21H			     ;; 					;AN000;
  MOV  DL,LINE_FEED		     ;; 					;AN000;
  MOV  AH,2			     ;; 					;AN000;
  INT  21H			     ;; 					;AN000;
				       ;;					;AN000;
  MOV  ERROR_DEVICE,STDERR	       ;; reset to STDERR			;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
SHOW_PARSE_ERROR   ENDP 	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   OPEN_FILE									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
OPEN_FILE     PROC NEAR 	       ;;					;AN000;
				       ;;					;AN000;
 .IF <PROFILE_PATH NE 0>	       ;; If a path was specified then		;AN000;
     MOV  DX,OFFSET PROFILE_PATH       ;;  try and open it			;AN000;
     MOV  AX,3D00H		       ;;					;AN000;
     INT  21H			       ;; Open it				;AN000;
    .IF C			       ;; Open error if carry flag set		;AN000;
       .IF <AX EQ FILE_NOT_FOUND> OR   ;; Check for error other than		;AN000;
       .IF <AX EQ PATH_NOT_FOUND>      ;;  file not found			;AN000;
	   MOV	 AX,PROFILE_NOT_FOUND  ;;					;AN000;
	   MOV	 CX,0		       ;;					;AN000;
	   CALL  DISP_ERROR	       ;; Issue "File not found" common msg     ;AN000;
	   MOV	 FILE_ERROR,YES        ;;					;AN000;
       .ELSE			       ;;					;AN000;
	   CALL  FILE_ERROR_PROC       ;; Issue "Open error"                    ;AN000;
       .ENDIF			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  HANDLE,AX		       ;;					;AN000;
    .ENDIF			       ;; File opened OK			;AN000;
 .ELSE				       ;; No path parameter			;AN000;
     MOV  DX,OFFSET DEFAULT_PATH       ;; Try and open "GRAPHICS.PRO"           ;AN000;
     MOV  AX,3D00H		       ;;					;AN000;
     INT  21H			       ;; Open it				;AN000;
    .IF C			       ;; Open error if carry flag set		;AN000;
       .IF <AX EQ FILE_NOT_FOUND> OR   ;; Check for file not found error	;AN000;
       .IF <AX EQ PATH_NOT_FOUND>      ;;					;AN000;
	   CALL COPY_ARGV0	       ;;					;AN000;
	   MOV	DX,OFFSET PROFILE_PATH ;; Try and open "GRAPHICS.PRO" in        ;AN000;
	   MOV	AX,3D00H	       ;;  ARGV0 directory			;AN000;
	   INT	21H		       ;;					;AN000;
	  .IF C 		       ;; Issue "File not found" common msg     ;AN000;
	     .IF <AX EQ FILE_NOT_FOUND> OR					;AN000;
	     .IF <AX EQ PATH_NOT_FOUND> 					;AN000;
		 MOV   AX,PROFILE_NOT_FOUND  ;; 				;AN000;
		 MOV   CX,0		     ;; 				;AN000;
		 CALL  DISP_ERROR	     ;; Issue "File not found"common MSG;AN000;
		 MOV   FILE_ERROR,YES	     ;; 				;AN000;
	     .ELSE		       ;;					;AN000;
		 CALL  FILE_ERROR_PROC ;; Issue "Open error"                    ;AN000;
	     .ENDIF		       ;;					;AN000;
	  .ELSE 		       ;;					;AN000;
	      MOV  HANDLE,AX	       ;;					;AN000;
	  .ENDIF		       ;; File opened OK			;AN000;
       .ELSE			       ;;					;AN000;
	   CALL  FILE_ERROR_PROC       ;; Issue "Open error"                    ;AN000;
       .ENDIF			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  HANDLE,AX		       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
OPEN_FILE     ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   COPY_ARGV0 								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COPY_ARGV0  PROC		       ;;					;AN000;
				       ;;					;AN000;
  PUSH	 ES			       ;;					;AN000;
  PUSH	 DI			       ;;					;AN000;
  PUSH	 SI			       ;;					;AN000;
				       ;;					;AN000;
  MOV	 DI,2CH 		       ;; Locate environment string		;AN000;
  MOV	 ES,[DI]		       ;;					;AN000;
  XOR	 SI,SI			       ;;					;AN000;
  .WHILE <<WORD PTR ES:[SI]> NE 0>     ;;					;AN000;
     INC   SI			       ;;					;AN000;
  .ENDWHILE			       ;;					;AN000;
  ADD	 SI,4			       ;;					;AN000;
  LEA	 DI,PROFILE_PATH	       ;; Move string to work area		;AN000;
  .REPEAT			       ;;					;AN000;
     MOV    AL,ES:[SI]		       ;;					;AN000;
     MOV    [DI],AL		       ;;					;AN000;
     INC    SI			       ;;					;AN000;
     INC    DI			       ;;					;AN000;
  .UNTIL <<BYTE PTR ES:[SI]> EQ 0>     ;;					;AN000;
  MOV	 BYTE PTR [DI],0	       ;;					;AN000;
  MOV	 BYTE PTR [DI]-3,"P"           ;; Change COM to PRO                     ;AN000;
  MOV	 BYTE PTR [DI]-2,"R"           ;;                                       ;AN000;
  MOV	 BYTE PTR [DI]-1,"O"           ;;                                       ;AN000;
				       ;;					;AN000;
  POP	    SI			       ;;					;AN000;
  POP	    DI			       ;;					;AN000;
  POP	    ES			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
COPY_ARGV0  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   FILE_ERROR_PROC								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
FILE_ERROR_PROC  PROC		       ;;					;AN000;
  MOV	AX,FILE_ERRORS		       ;;					;AN000;
  MOV	CX,0			       ;;					;AN000;
  CALL	DISP_ERROR		       ;;					;AN000;
  MOV	FILE_ERROR,YES		       ;;					;AN000;
  RET				       ;;					;AN000;
FILE_ERROR_PROC  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GET_STATEMENT								;AN000;
;;										;AN000;
;; Input Parameters:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Output Parameters:								;AN000;
;;   PROFILE_LINE								;AN000;
;;   RETURN CODE : 0 - successfull read 					;AN000;
;;		 : 1 - end of file						;AN000;
;;		 : 2 - error during read					;AN000;
;;										;AN000;
;;										;AN000;
;; Data Structures Referenced:							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;   Get a statement from the profile.						;AN000;
;;   The file read in 512 byte buffers and parsed into				;AN000;
;;   lines by the presence of a carriage return at the end of each line.	;AN000;
;;										;AN000;
;; Called By:									;AN000;
;;   LOAD_PROFILE								;AN000;
;;										;AN000;
;; External Calls:								;AN000;
;;   NONE									;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;   FOUND := FALSE								;AN000;
;;   RETURN_CODE := 0								;AN000;
;;   WHILE NOT FOUND DO 							;AN000;
;;	IF end of buffer THEN							;AN000;
;;	   Read next profile record into buffer 				;AN000;
;;	   IF successful read THEN						;AN000;
;;	      point to first byte in buffer					;AN000;
;;	   ELSE 								;AN000;
;;	      IF end of file THEN						;AN000;
;;		 Close profile							;AN000;
;;		 RETURN_CODE := 1						;AN000;
;;		 FOUND := TRUE							;AN000;
;;	      ELSE								;AN000;
;;		 RETURN_CODE := 2						;AN000;
;;		 FOUND := TRUE							;AN000;
;;	      ENDIF								;AN000;
;;	   ENDIF								;AN000;
;;	ENDIF									;AN000;
;;	copy byte to PROFILE_LINE						;AN000;
;;	IF byte in buffer is a CR THEN						;AN000;
;;	   FOUND := TRUE							;AN000;
;;	ENDIF									;AN000;
;;   ENDWHILE									;AN000;
;;   RETURN									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
FOUND  DB   0			       ;;					;AN000;
				       ;;					;AN000;
CARRIAGE_RET	EQU 13		       ;;					;AN000;
LINE_FEED	EQU 10		       ;;					;AN000;
NEXT_BYTE	DB  0		       ;; Save area for byte just read		;AN000;
BUFFER_SIZE	EQU 512 	       ;;					;AN000;
FILE_BUFFER	DB  512 DUP(0)	       ;;					;AN000;
BUFFER_PTR	DW  512 	       ;;					;AN000;
BUFFER_END	DW  512 	       ;;					;AN000;
STMT_BUFFER	DB  255 DUP(0)	       ;;					;AN000;
		DB  ?		       ;; In case we have to insert a CR	;AN000;
		DB  ?		       ;;  and a LF				;AN000;
		DB  ?		       ;; Too put the "$" for displaying the    ;AN000;
				       ;;  line.				;AN000;
				       ;;					;AN000;
STMT_END_INDEX	DW  ?		       ;;					;AN000;
MAX_STMT_LEN	EQU 255 	       ;;					;AN000;
CR_FOUND	DB  0		       ;; 1 if we found a line terminator	;AN000;
				       ;;					;AN000;
GET_STATEMENT PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  FOUND,NO 		       ;;					;AN000;
  MOV  STMT_ERROR,0		       ;; Clear error flags			;AN000;
  XOR  DI,DI			       ;; Index for extracted statement 	;AN000;
  MOV  SI,BUFFER_PTR		       ;; Init file buffer ptr			;AN000;
				       ;;					;AN000;
  MOV  AL,NEXT_BYTE		       ;; Restore current byte			;AN000;
  MOV  CR_FOUND,NO		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
 .WHILE <FOUND EQ NO> AND	       ;; Keep parsing until we find a stmt	;AN000;
 .WHILE <FILE_ERROR EQ NO> AND	       ;;  or a file error occurs		;AN000;
 .WHILE <END_OF_FILE EQ NO>	       ;;   or we reach end of file		;AN000;
   .IF <CR_FOUND EQ YES>	       ;;					;AN000;
      .IF <AL EQ LINE_FEED>	       ;; Return the line feed as well		;AN000;
	 .IF <DI NA MAX_STMT_LEN>      ;; Truncate lines longer than MAX	;AN000;
	     MOV  STMT_BUFFER[DI],AL   ;;  MOVE TO statement buffer		;AN000;
	     INC  DI		       ;; Point to next byte in file buffr	;AN000;
	  .ELSE 		       ;;					;AN000;
	      OR   STMT_ERROR,INVALID  ;; Line has been truncated > ERROR	;AN000;
	      MOV  PARSE_ERROR,YES     ;;					;AN000;
	      MOV  BUILD_STATE,NO      ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  CALL GET_BYTE 	       ;; Get the first byte of next statement	;AN000;
      .ENDIF			       ;;					;AN000;
       MOV  FOUND,YES		       ;; Time to leave this WHILE		;AN000;
       MOV  NEXT_BYTE,AL	       ;; Save the byte we just read		;AN000;
   .ELSE			       ;;					;AN000;
      .IF <DI NA MAX_STMT_LEN>	       ;; Truncate lines longer than MAX	;AN000;
	  MOV  STMT_BUFFER[DI],AL      ;; move byte to statement buffer 	;AN000;
	  INC  DI		       ;; Point to next byte in file buffer	;AN000;
      .ELSE			       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; Line has been truncated > ERROR	;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
      .IF <AL EQ CARRIAGE_RET>	       ;; Found a line terminator		;AN000;
	  MOV  CR_FOUND,YES	       ;; Indicate carriage return found	;AN000;
      .ENDIF			       ;;  and go through once more to		;AN000;
       CALL GET_BYTE		       ;;   check for a line feed		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDWHILE			       ;;					;AN000;
				       ;;					;AN000;
 .IF <STMT_BUFFER[DI-1] NE CARRIAGE_RET> AND		 ;;			;AN000;
 .IF <STMT_BUFFER[DI-1] NE LINE_FEED>		      ;;			;AN000;
     MOV  STMT_BUFFER[DI],CARRIAGE_RET ;;					;AN000;
     MOV  STMT_BUFFER[DI+1],LINE_FEED  ;;					;AN000;
     INC  DI			       ;;					;AN000;
     INC  DI			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  MOV STMT_END_INDEX,DI 	       ;;					;AN000;
  MOV BUFFER_PTR,SI		       ;; Save buffer ptr for next time 	;AN000;
				       ;;					;AN000;
 .IF <END_OF_FILE EQ YES>	       ;;					;AN000;
     .IF <DI EQ 0>		       ;; Clear carry if we read something	;AN000;
	STC			       ;;  and no file error occured otherwise	;AN000;
     .ELSE			       ;;   set carry indicating unsuccessful	;AN000;
	CLC			       ;;    get.				;AN000;
     .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <FILE_ERROR EQ YES>	       ;;					;AN000;
	 STC			       ;;					;AN000;
     .ELSE			       ;;					;AN000;
	 CLC			       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
GET_STATEMENT ENDP		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GET_BYTE									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GET_BYTE      PROC		       ;;					;AN000;
				       ;;					;AN000;
 .IF <SI EQ BUFFER_END> 	       ;; If buffer empty do another read	;AN000;
     MOV  AH,3FH		       ;;					;AN000;
     MOV  DX,OFFSET FILE_BUFFER        ;;					;AN000;
     MOV  CX,BUFFER_SIZE	       ;;					;AN000;
     MOV  BX,HANDLE		       ;;					;AN000;
     INT  21H			       ;;					;AN000;
    .IF C			       ;; Carry set by DOS if file error	;AN000;
	CALL FILE_ERROR_PROC	       ;;					;AN000;
    .ELSE			       ;;					;AN000;
       .IF <AX EQ 0>		       ;; End of file if AX=0			;AN000;
	   MOV	END_OF_FILE,YES        ;;					;AN000;
	   MOV	AH,3EH		       ;; Close the file			;AN000;
	   MOV	BX,HANDLE	       ;;					;AN000;
	   INT	21H		       ;;					;AN000;
       .ELSE			       ;;					;AN000;
	   MOV BUFFER_END,AX	       ;; Number of bytes read			;AN000;
	   XOR SI,SI		       ;; Buffer pointer := 0			;AN000;
       .ENDIF			       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <FILE_ERROR EQ YES> OR	       ;;					;AN000;
 .IF <END_OF_FILE EQ YES>	       ;;					;AN000;
     STC			       ;; Unsuccessful get			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <<FILE_BUFFER[SI]> EQ 1AH>	;; cHECK for EOF marker 		;AN000;
	MOV END_OF_FILE,YES	       ;;					;AN000;
	STC			       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	MOV  AL,FILE_BUFFER[SI] 	  ;; Return byte in AL			;AN000;
	INC  SI 			  ;;					;AN000;
	CLC				  ;; Successful get			;AN000;
    .ENDIF				  ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
GET_BYTE      ENDP		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   GROW_SHARED_DATA								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GROW_SHARED_DATA  PROC		       ;;					;AN000;
  PUSH BX			       ;;					;AN000;
  ADD  BLOCK_END,AX		       ;; Grow the current block by AX		;AN000;
  MOV  BX,BLOCK_END		       ;;					;AN000;
 .IF <BX A NB_FREE_BYTES>	       ;; Check for overflow			;AN000;
     MOV  BUILD_STATE,NO	       ;; Stop building shared data		;AN000;
     MOV  MEM_OVERFLOW,YES	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  POP  BX			       ;;					;AN000;
  RET				       ;;					;AN000;
GROW_SHARED_DATA  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grint2fh.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Interrupt 2FH Driver		;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                             
;;										;AN000;
;; File Name:  GRINT2FH.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the Interrupt 2FH driver.				;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 INT_2FH_DRIVER - Interrupt 2FH driver					;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRLOAD.EXT - Externals for profile load				;AN000;
;;	 GRCTRL.EXT - Externals for print screen control			;AN000;
;;	 GRPRINT.EXT - Externals for print modules				;AN000;
;;	 GRCPSD.EXT - Externals for COPY_SHARED_DATA module			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 Calls next Int 2FH handler in the chain.				;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:	
;; ---------------
;;	M001	NSM 	1/30/91	  New int 10 handler to trap alt-prt-sc select
;;				   calls made by ANSI.SYS. For these calls, we
;;				   we need to reinstall our int 5 handler again
;;	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
	PUBLIC	OLD_INT_2FH	       ;;					;AN000;
	PUBLIC	INT_2FH_DRIVER	       ;;					;AN000;
	PUBLIC	INT_10H_DRIVER	       ;;					;AN000;
	PUBLIC	PRT_SCR_2FH_NUMBER     ;;					;AN000;
	PUBLIC	RESIDENT_CODE_SEG      ;;					;AN000;
	PUBLIC	SHARED_DATA_AREA_PTR   ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
.XLIST										;AN000;
INCLUDE STRUC.INC								;AN000;
INCLUDE GRINST.EXT								;AN000;
INCLUDE GRCTRL.EXT								;AN000;
INCLUDE GRCPSD.EXT								;AN000;
.LIST										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module: INT_2FH_DRIVER							;AN000;
;;										;AN000;
;; Description: 								;AN000;
;;     Respond to GRAPHICS Int 2FH calls.					;AN000;
;;     The following calls are handled: 					;AN000;
;;										;AN000;
;;	AL = 0  Install Check							;AN000;
;;										;AN000;
;; Invoked By:									;AN000;
;;     INT 2FH instruction.							;AN000;
;;										;AN000;
;; Modules Called:								;AN000;
;;     Lower level INT 2FH handlers.						;AN000;
;;										;AN000;
;; Input Registers:								;AN000;
;;     Install Check - AH=ACH  AL=0						;AN000;
;;										;AN000;
;;										;AN000;
;; Output Registers:								;AN000;
;;     Install Check:  IF GRAPHICS installed					;AN000;
;;			  AH=FFH  AL=FFH					;AN000;
;;			  ES : DI points to Shared Data Area			;AN000;
;;		       ELSE							;AN000;
;;			  AH=ACH  AL=0						;AN000;
;;										;AN000;
;; Logic:									;AN000;
;;     IF AH=ACH THEN								;AN000;
;;	  IF AL=0 THEN								;AN000;
;;	     AH,AL := -1							;AN000;
;;	     ES : DI := SHARED_DATA_AREA_PTR					;AN000;
;;	  ENDIF 								;AN000;
;;	  IRET									;AN000;
;;     ELSE									;AN000;
;;	  IF OLD_INT_2FH is a valid pointer THEN				;AN000;
;;	      Jump to Old Int 2FH						;AN000;
;;	  ELSE									;AN000;
;;	      IRET								;AN000;
;;	  ENDIF 								;AN000;
;;     ENDIF									;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
INT_2FH_DRIVER	PROC  NEAR							;AN000;
	JMP	SHORT	INT_2FH 							;AN000;
PRT_SCR_2FH_NUMBER EQU	       0ACH	; 2FH Multiplex interrupt number	;AN000;
					;  assigned to Print Screen.		;AN000;
OLD_INT_2FH	DD    ? 		; Pointer to next 2FH interrupt handler ;AN000;
RESIDENT_CODE_SEG	DW   ?	; Segment for installed stuff			;AN000;
SHARED_DATA_AREA_PTR	DW   ?	; Offset of the start of the			;AN000;
				;  Shared Data Area				;AN000;
										;AN000;
INT_2FH:									;AN000;
;-------------------------------------------------------------------------------;AN000;
; Verify if the 2FH Interrupt call is for our interrupt handler:		;AN000;
;-------------------------------------------------------------------------------;AN000;
       .IF <AH EQ PRT_SCR_2FH_NUMBER> AND;If 2FH call is for us 		;AN000;
       .IF <ZERO AL>			;  and request is "Get install state"   ;AN000;
       .THEN				; then, 				;AN000;
;-------------------------------------------------------------------------------;AN000;
; Yes: return results								;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	DI,CS:SHARED_DATA_AREA_PTR ;  ES:DI :=	Pointer to shared	;AN000;
	PUSH	CS:RESIDENT_CODE_SEG	   ;		 data area		;AN000;
	POP	ES			;					;AN000;
	MOV	AH,0FFH 		; AL and AH := "We are installed"       ;AN000;
	MOV	AL,AH			;					;AN000;
	IRET				; Return to interrupted process 	;AN000;
;-------------------------------------------------------------------------------;AN000;
; No, pass control to next 2FH interrupt handler:				;AN000;
;-------------------------------------------------------------------------------;AN000;
       .ELSE				; else, this call is not for us:	;AN000;
	 .IF <<WORD PTR CS:OLD_INT_2FH> NE 0> AND ;if there is another		;AN000;
	 .IF <<WORD PTR CS:OLD_INT_2FH+2> NE 0> ;  2FH driver			;AN000;
	 .THEN				;	below us then,			;AN000;
	    JMP CS:OLD_INT_2FH		;	  pass control to it		;AN000;
	 .ELSE				;	else, there is nobody to pass	;AN000;
	    IRET			;	  control to, just return.	;AN000;
	 .ENDIF 			;     END If there is a driver below us.;AN000;
      .ENDIF				;  END If this call is for us.		;AN000;
INT_2FH_DRIVER	ENDP								;AN000;
										;AN000;

;/*M001 BEGIN */
;========================================================================
; INT_10h_Driver :
;    int 10 handler to check for alt-prt-sc-select calls (ah=12,bl=20h)
;    Other int 10 calls are passed on. For alt-prt-sc-select calls,
;    old int 10 is called and after return, we reinstall our int 5 (prt_sc)
;    vector back again ( if it was changed by ANSI.SYS).
;=======================================================================
INT_10H_DRIVER	PROC	NEAR

	sti 					; restore interrupts
	cmp	ah,ALTERNATE_SELECT		; see if the call is for
	jnz	go_old_int10			; alt_prt_sc; if so
	cmp	bl,ALT_PRT_SC_SELECT		; call int 10 and then
	jz	Set_Our_Int5_handler		; restore out PRT_SC vector
go_old_int10:						; other int 10 calls
	jmp	DWORD PTR cs:OLD_INT_10H		; ...pass it on.

; the call is for alternate prt Screen int 10
; call the old int 10 handler and then restore our int 5 vector back again

Set_Our_Int5_handler:
	pushf
	call	DWORD PTR cs:OLD_INT_10H	; call the prev.int 10 handler
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	xor	ax,ax		
	mov	ds,ax			; ds-> 0 to get at int.vector table
	mov	si,5 * 4		; ds:si  -> ptr to int 5 vector
	mov	cx,cs		
	mov	dx,offset PRT_SCR

	cli
	mov	ax,ds:[si+2]		; segment for current int 5 vector
	cmp	ax,cx			; is it changed by ROM BIOS
	je	no_int5_chg		
	mov	bx,ds:[si]		
	cmp	bx, dx	;further sanity check  for offset
	je	no_int5_chg		

; cx:dx = our int 5 handler
; ax:bx = current int 5 handler
; store the current int 5 handler as the old handler and install ourselves
; again	

	mov	ds:[si],dx		; store offset
	mov	ds:[si+2],cx		; store segment
	mov	CS:[BIOS_INT_5H],bx	; store old int5 vector
	mov	CS:[BIOS_INT_5H +2],ax

no_int5_chg:
	sti
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	iret

INT_10H_DRIVER	ENDP

; /* M001 END */

CODE   ENDS									;AN000;
       END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grctrl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I  fixed  a  MS bug.  MS did  not  initialize  the  variable 
;**                 ROTATE_SW.  Consequently, if you do a non-rotate after doing 
;**                 a  rotate,  the picture would be printed  incorrectly  as  a 
;**                 rotated picture.  Note this bug was in Q.01.01 and fixed for 
;**                 Q.01.02.
;**  
;**  NOTES:    The   following  bug  was  fixed  for  the  pre-release   version 
;**            Q.01.02.
;**  
;**  BUG (mda004)
;**  ------------
;**  
;**  NAME:     After  GRAPHICS prints a rotated  picture  it will print pictures 
;**            which are not supposed to be rotated as rotated junk.
;**  
;**  FILES AFFECTED:     GRCTRL.ASM
;**  
;**  CAUSE:    MicroSoft  was  failing to initialize the variable  ROTATE_SW  to 
;**            OFF.  Consequently, if you printed a picture whose  corresponding 
;**            printbox did NOT specify a rotate after printing a picture  whose 
;**            corresponding  printbox did specify a rotate, the  picture  would 
;**            print as rotated junk.
;**  
;**  FIX:      Initialize the variable ROTATE_SW  to OFF right before going into 
;**            the print procedure Print_Color or Print_BW_APA.
;**  
;**  DOCUMENTATION NOTES:  This version of GRCTRL.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								
										
	TITLE	DOS GRAPHICS Command  -	Print screen Control module
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;; DOS - GRAPHICS Command
;;                                 
;;										
;; File Name:  GRCTRL.ASM							
;; ----------									
;;										
;; Description: 								
;; ------------ 								
;;	 This file contains the code for the Print Screen control module.	
;;										
;; Documentation Reference:							
;; ------------------------							
;;	 OASIS High Level Design						
;;	 OASIS GRAPHICS I1 Overview						
;;										
;; Procedures Contained in This File:						
;; ----------------------------------						
;;	PRT_SCR 								
;;	  DET_HW_CONFIG 							
;;	  DET_MODE_STATE							
;;	  GET_MODE_ATTR 							
;;	  SET_UP_XLT_TAB							
;;	    SET_CGA_XLT_TAB							
;;	      CGA_COL2RGB							
;;	      RGB2XLT_TAB							
;;	    SET_EGA_XLT_TAB							
;;	      EGA_COL2RGB							
;;	    SET_MODE_F_XLT_TAB							
;;	    SET_MODE_13H_XLT_TAB						
;;	    SET_ROUNDUP_XLT_TAB 						
;;	 SET_BACKG_IN_XLT_TAB							
;;	 RGB2BAND								
;;	 RGB2INT								
;;										
;;										
;; Include Files Required:							
;; -----------------------							
;;	 GRINST.EXT - Externals for GRINST.ASM					
;;										
;;										
;; External Procedure References:						
;; ------------------------------						
;;	 FROM FILE  GRINST.ASM: 						
;;	      GRAPHICS_INSTALL - Main module for installation.			
;;										
;; Linkage Instructions:							
;; -------------------- 							
;;	 Refer to GRAPHICS.ASM							
;;										
;; Change History:								
;; ---------------								
;;  M001	NSM	1/30/91		New var to store the old int 10 handler
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
CODE	SEGMENT PUBLIC 'CODE'                                                   
	ASSUME		CS:CODE,DS:CODE 					
										
.XLIST										
INCLUDE GRINT2FH.EXT								
INCLUDE GRBWPRT.EXT								
INCLUDE GRCOLPRT.EXT								
INCLUDE GRSHAR.STR								
INCLUDE GRPATTRN.STR								
INCLUDE GRPATTRN.EXT								
INCLUDE STRUC.INC								
.LIST										
PRT_SCR PROC NEAR								
	JMP PRT_SCR_BEGIN							
PAGE										
;===============================================================================
;										
; GRAPHICS INTERRUPT DRIVER'S DATA:                                             
;										
;===============================================================================
.xlist										
PUBLIC PRT_SCR,ERROR_CODE,XLT_TAB,MODE_TYPE					
PUBLIC CUR_MODE_PTR,CUR_MODE,NB_COLORS,SCREEN_HEIGHT,SCREEN_WIDTH		
PUBLIC CUR_PAGE,CUR_COLUMN,CUR_ROW,NB_SCAN_LINES,SCAN_LINE_MAX_LENGTH		
PUBLIC CUR_SCAN_LNE_LENGTH							
PUBLIC PRT_BUF,NB_BOXES_PER_PRT_BUF,CUR_BOX,BOX_H,BOX_W 			
PUBLIC PRINT_SCREEN_ALLOWED,RGB 						
PUBLIC BIOS_INT_5H								
PUBLIC OLD_INT_10H			; /* M001 */
PUBLIC ROTATE_SW								
PUBLIC DET_HW_CONFIG								
PUBLIC NB_CHAR_COLUMNS								
PUBLIC RGB2INT									
PUBLIC RGB2BAND 								
.list										
INCLUDE GRCTRL.STR								
;-------------------------------------------------------------------------------
;										
; ENTRY POINT TO BIOS HARDWARE INTERRUPT 5 HANDLER				
;										
;-------------------------------------------------------------------------------
BIOS_INT_5H	DW	?		; Pointer to BIOS int 5h		
		DW	?							
										
;/* M001 BEGIN */ --------------------------------------------------------------
;										
; ENTRY POINT TO BIOS HARDWARE INTERRUPT 10 HANDLER				
;										
;-------------------------------------------------------------------------------
OLD_INT_10H	DW	?		; Pointer to BIOS int 10h		
		DW	?							
; /* M001 END */ 
;-------------------------------------------------------------------------------
;										
; PRINT SCREEN ERROR CODE (Used at print screen time, see GRCTRL.STR for	
;			   error codes allowed) 				
;										
;-------------------------------------------------------------------------------
ERROR_CODE	DB	0		; ERROR CODE 0 = NO ERROR		
										
;-------------------------------------------------------------------------------
;										
; SCREEN PIXEL: INTERNAL REPRESENTATION 					
;										
;-------------------------------------------------------------------------------
RGB	PIXEL_STR < , , >	  ; PIXEL := RED, GREEN, BLUE Values		
										
;-------------------------------------------------------------------------------
;										
; COLOR TRANSLATION TABLE:							
;										
; This table is used to translate the color numbers returned by 		
; Interrupt 10H Read Dot and Read Character calls into print			
; information.	The table consists of 256 entries, one byte each,		
; indexed by color number.							
; In the case of black and white printing, the table				
; entries are grey scale intensities from 0 to 63.  In the case 		
; of color printing each table entry contains a "band mask" indicating          
; which color print bands are required to generate the required color.		
; The band masks are simply bit masks where each bit corresponds to one 	
; of the printer bands. 							
;										
; The table is set up at the beginning of the print screen processing,		
; before any data is read from the screen.  From then on, translating		
; from screen information into print information is done quickly by		
; accessing this table.  Not all 256 entries are initialized for each		
; screen print.  The number of entries used is equal to the number		
; of colors available concurrently with the given display mode. 		
;-------------------------------------------------------------------------------
XLT_TAB DB	  256 DUP(32)  ; COLOR TRANSLATION TABLE			
			       ; This table is used to translate the Color Dot	
			       ; or Byte Attribute to a Band Mask for color	
			       ; printing or to a Grey Intensity for Mono-	
			       ; chrome printing.				
										
;-------------------------------------------------------------------------------
;										
; CURRENT VIDEO MODE ATTRIBUTES 						
;										
;-------------------------------------------------------------------------------
MODE_TYPE	DB	?	; Mode types (bit mask) APA or TXT		
										
CUR_MODE_PTR	DW	?	; DISPLAYMODE INFO RECORD for the current	
				;   mode (defined in the shared data area).	
CUR_MODE	DB	?	; Current video mode number			
NB_COLORS	DW	?	; Number of colors supported by this mode	
SCREEN_HEIGHT	DW	?	; Number of rows on the screen (chars or pixels)
SCREEN_WIDTH	DW	?	; Number of columns on the screen (chars/pixels)
				;  (for text modes is equal to NB_CHAR_COLUMNS) 
NB_CHAR_COLUMNS DB	?	; Number of columns on the screen if in txt mode
CUR_PAGE	DB	?	; Active page number				
ROTATE_SW	DB	?	; Switch: if "ON" then, must print sideways     
										
;-------------------------------------------------------------------------------
;										
; ACTIVE SCREEN ATTRIBUTES							
;										
;-------------------------------------------------------------------------------
CUR_COLUMN	DW	?	; Current pixel/char column number		
CUR_ROW 	DW	?	; Current pixel/char row number 		
NB_SCAN_LINES	DW	?	; Number of screen scan lines			
SCAN_LINE_MAX_LENGTH DW ?	; Maximum number of dots/chars per scan line	
CUR_SCAN_LNE_LENGTH DW	?	; Length in pels/chars of the current scan line 
										
;-------------------------------------------------------------------------------
;										
; PRINTER VARIABLES								
;										
;-------------------------------------------------------------------------------
PRT_BUF DB	?,?,?,? 	; PRINT BUFFER					
NB_BOXES_PER_PRT_BUF DB ?	; Number of boxes fitting in the print buffer	
CUR_BOX DB	?,?,?,? 	; BOX = PRINTER REPRESENTATION OF 1 PIXEL	
BOX_H	DB	?		; HEIGHT OF THE BOX				
BOX_W	DB	?		; WIDTH OF THE BOX				
										
;-------------------------------------------------------------------------------
;										
; CONTROL VARIABLES:								
;										
; This data is used to communicate between the Installation Modules		
; and the Resident Print Screen Modules.					
;-------------------------------------------------------------------------------
PRINT_SCREEN_ALLOWED	DB   YES; Used to avoid print screens			
				;  while the GRAPHICS installation		
				;   (or re-install) is in progress		
				; Set by GRAPHICS_INSTALL module.		
										
										
PAGE										
;===============================================================================
;										
; INTERRUPT 5 DRIVER'S CODE:                                                    
;										
;-------------------------------------------------------------------------------
;===============================================================================
;										
; PRT_SCR : PRINT THE ACTIVE SCREEN						
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: SHARED_DATA_AREA_PTR = Offset of the data area used for		
;				      passing data between the			
;				      Installation process and the Print	
;				      Screen process.				
;	      PRINT_SCREEN_ALLOWED  = Switch. Set to "No" if currently          
;				      installing GRAPHICS.COM			
;										
;				NOTE: These 2 variables are declared within	
;				      PRT_SCR but initialized by the		
;				      Installation process GRAPHICS_INIT	
;	OUTPUT: PRINTER 							
;										
;	CALLED BY: INTERRUPT 5							
;										
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION:									
;										
; PRINT THE ACTIVE SCREEN for all TEXT and  All Points Addressable (APA)	
; display modes  available  with  either  a MONO, CGA, EGA, or VGA video	
; adapter on a Black and White or Color printer.				
;										
; INITIALIZATION:								
;										
; Each pixel  or  character  on the screen has a color attribute.  These	
; colors must be translated into different internal representations:		
;										
;	For printing in colors, each color is translated to a BAND MASK.	
;	The Band Mask indicates how to obtain this color on the printer.	
;										
;	For printing  in  Black and White, each color is translated to a	
;	GREY INTENSITY number between 0 (black) and 63 (white). 		
;										
; The  BAND  MASK  or  the  GREY INTENSITIES  are  found  in  the  COLOR	
; TRANSLATION TABLE.  This  table is initialized  before  calling any of	
; the print screen modules.							
;										
; PRINT SCREEN TIME:								
;										
; When a pixel or character  is read  off the screen by one of the print	
; screen modules, its  color is  used as  an index  into the translation	
; table.									
;										
;										
; LOGIC:									
;										
; IF SCREEN_PRINTS_ALLOWED=NO	; Block print screens until Installation	
;   THEN IRET			;  Process (or re-install!) is finished.	
; ELSE										
;										
;   CALL DET_HW_CONFIG		  ; Determine hardware configuration		
;   CALL DET_MODE_STATE 	  ; Determine video mode and active page	
;   CALL GET_MODE_ATTR		  ; Get video attributes (TXT or APA, etc)	
;										
;  IF MODE_TYPE = TXT AND Number of colors = 0					
;    THEN Invoke BIOS INTERRUPT 5						
;  ELSE 									
;    IF PRINTER_TYPE = BLACK_WHITE						
;      THEN									
;      IF MODE_TYPE = TXT							
;	 THEN Invoke BIOS INTERRUPT 5						
;      ELSE ; Mode is APA							
;	 CALL SET_UP_XLT_TAB	 ; Set up the color translation table		
;	 CALL PRINT_BW_APA	 ; Print the active screen on a B&W printer	
;    ELSE ; Color printer attached						
;      CALL SET_UP_XLT_TAB	 ; Set up the color translation table		
;      CALL PRINT_COLOR 	 ; Print the active screen on a Color prt.	
;    IRET									
;										
PRT_SCR_BEGIN:									
  PUSH	  AX		  ; Save Registers					
  PUSH	  BX		  ;							
  PUSH	  CX		  ;							
  PUSH	  DX		  ;							
  PUSH	  SI		  ;							
  PUSH	  DI		  ;							
  PUSH	  BP		  ;							
  PUSH	  DS		  ;							
  PUSH	  ES		  ;							
			  ;							
  CLD			  ; Clear direction flag				
  PUSH	  CS		  ; DS := CS						
  POP	  DS									
										
;-------------------------------------------------------------------------------
; Verify if we are allowed to print (not allowed if currently installing	
; GRAPHICS or printing a screen):						
;-------------------------------------------------------------------------------
  CMP	  PRINT_SCREEN_ALLOWED,NO	  ; IF not allowed to print		
  JE	  PRT_SCR_RETURN		  ; THEN quit				
					  ; ELSE print the screen:		
;-------------------------------------------------------------------------------
; INITIALIZATION:								
;-------------------------------------------------------------------------------
PRT_SCR_INIT:				  ; Disable print screen while		
  MOV	  PRINT_SCREEN_ALLOWED,NO	  ;  we are printing the current	
					  ;   screen.				
  MOV	  BP,SHARED_DATA_AREA_PTR	  ; BP := Offset Shared Data Area	
  MOV	  ERROR_CODE,NO_ERROR		  ; No error so far.			
  CALL	  DET_HW_CONFIG   ; Determine the type of display adapter		
  CALL	  DET_MODE_STATE  ; Init CUR_PAGE, CUR_MODE				
  CALL	  GET_MODE_ATTR   ; Determine if APA or TXT, nb. of colors,		
			  ;  and screen dimensions in pels or characters.	
 ;										
 ; Test the error code returned by GET_MODE_ATTR:				
 ;										
  TEST	  ERROR_CODE,MODE_NOT_SUPPORTED    ;If mode not supported then, 	
  JNZ	  DO_BEEP			   ; let BIOS give it a try.		
										
 ;------------------------------------------------------------------------------
 ; Check the printer type:							
 ;------------------------------------------------------------------------------
 .IF <DS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; Is a black and white printer	
 .THEN					   ;  attached ?			
 ;------------------------------------------------------------------------------
 ; A Black and White printer is attached					
 ;------------------------------------------------------------------------------
   CMP	   MODE_TYPE,TXT	   ; Is the screen in text mode ?		
   JNE	   INVOKE_PRINT_ROUTINE    ; No, call GRAPHICS B&W routine		
   JMP	   SHORT EXIT_TO_BIOS	   ; Yes, give control to BIOS INTERRUPT 5	
 .ELSE										
 ;------------------------------------------------------------------------------
 ; A Color printer is attached							
 ;------------------------------------------------------------------------------
   CMP	   NB_COLORS,0		   ; Is the screen in a Monochrome		
   JNE	   INVOKE_PRINT_ROUTINE 						
   TEST    MODE_TYPE,TXT	   ;   text mode ?				
   JNZ	   INVOKE_PRINT_ROUTINE 						
   JMP	   SHORT EXIT_TO_BIOS	   ; Yes, let BIOS INTERRUPT 5 handle it	
				   ; No, we handle it.				
.ENDIF				   ; ENDIF black and white or color printer	
;-------------------------------------------------------------------------------
;										
; Call the print routine (which is either PRINT_COLOR or PRINT_BW_APA)		
;										
;-------------------------------------------------------------------------------
INVOKE_PRINT_ROUTINE:								
   CALL    SET_UP_XLT_TAB	   ; Set up the color translation table 	
; \/ ~~mda(004) ----------------------------------------------------------------
;               The following fixes a MS bug.  MS was failing to initialize
;               the variable ROTATE_SW to off.  Consequently, if you printed a
;               picture whose corresponding printbox did NOT specify a rotate
;               after printing a picture whose corresponding printbox did 
;               specify a rotate, the picture would print rotated.
   MOV     ROTATE_SW,OFF           ; Set printing to standard unless otherwise
                                   ; set to rotate via PRINT_OPTIONS.
; /\ ~~mda(004) ----------------------------------------------------------------
   CALL    PRINT_MODULE_START	   ; Call the print modules that were		
				   ;  made resident at Install time.		
   MOV	   PRINT_SCREEN_ALLOWED,YES; Enable PrtScr for next calls		
  ;-----------------------------------------------------------------------------
  ; Test the error code returned by either PRINT_COLOR or PRT_BW_APA		
  ;-----------------------------------------------------------------------------
   TEST    ERROR_CODE,UNABLE_TO_PRINT ; If unable to print the screen		
   JNZ	   SHORT EXIT_TO_BIOS	      ; then, let BIOS give it a try		
										
PRT_SCR_RETURN: 								
				   ; Restore registers				
  POP	  ES			   ;						
  POP	  DS			   ;						
  POP	  BP			   ;						
  POP	  DI			   ;						
  POP	  SI			   ;						
  POP	  DX			   ;						
  POP	  CX			   ;						
  POP	  BX			   ;						
  POP	  AX			   ;						
				   ;						
  IRET				   ; Return control to interrupted		
				   ;  process					

; give a beep for modes not supported by graphics

DO_BEEP:
  mov	ah,2			   ; console output
  mov	dx,7			   ; ^G - beep  for modes not supported
  int	21h			

EXIT_TO_BIOS:									
				   ; Restore registers				
  POP	  ES			   ;						
  POP	  DS			   ;						
  POP	  BP			   ;						
  POP	  DI			   ;						
  POP	  SI			   ;						
  POP	  DX			   ;						
  POP	  CX			   ;						
  POP	  BX			   ;						
  POP	  AX			   ;						
  CLI				   ; Disable interrupts 			
  MOV	  CS:PRINT_SCREEN_ALLOWED,YES ; Enable PrtScr for next calls		
  JMP	  DWORD PTR CS:BIOS_INT_5H ; Exit to BIOS INTERRUPT 5			
										
PRT_SCR ENDP									
										
										
;===============================================================================
;										
; PRT_SCR MODULES:								
;										
;-------------------------------------------------------------------------------
PAGE										
;===============================================================================
;										
; DET_HW_CONFIG : DETERMINE WHAT TYPE OF VIDEO HARDWARE IS PRESENT		
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	   BP		   = Offset of the shared data area		
;										
;	OUTPUT:    HARDWARE_CONFIG is updated in the shared data area		
;										
;	CALLED BY: PRT_SCR							
;										
;	EXTERNAL CALLS: BIOS INT 10H						
;										
;-------------------------------------------------------------------------------
;										
; LOGIC:									
;    Issue BIOS INT10H Get Display Configuration Code (AX=1A00H)		
;    IF AL = 1AH THEN	 /* VGA (PS/2 OR BRECON-B)	  */			
;	/* BL = active DCC				  */			
;	/* BH = alternate DCC				  */			
;	/* Display Code:				  */			
;	/*   1 - Mono Adapter				  */			
;	/*   2 - CGA					  */			
;	/*   4 - EGA with Mono Display			  */			
;	/*   5 - EGA with Color Display 		  */			
;	/*   7 - PS/2 Mod 50,60,80 OR BRECON-B with Mono Display */		
;	/*   8 - PS/2 Mod 50,60,80 OR BRECON-B with Color Display */		
;	/*   B - PS/2 Mod 30 with Mono Display		  */			
;	/*   C - PS/2 Mod 30 with Color Display 	  */			
;    IF AL = 1AH THEN	 /* Call is supported */				
;	Set HARDWARE_CONFIG byte based on DCC returned in DL			
;    ELSE									
;	Issue INT 10H EGA Info (AH=12H BL=10H)					
;	IF BL <> 10H  THEN     /* EGA  */					
;	   Set EGA bit in HARDWARE_CONFIG					
;	ELSE		  /* CGA or */						
;	  Issue INT 10H PC CONVERTIBLE Physical display description param.	
;	  request. (AH=15H)							
;	  IF ES:[DI] = 5140H							
;	  THEN									
;	   Set PC_CONVERTIBLE bit in HARDWARE_CONFIG				
;	  ELSE									
;	   Set OLD_ADAPTER bit in HARDWARE_CONFIG				
;	  ENDIF 								
;	ENDIF									
;    ENDIF									
;    RETURN									
;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
DET_HW_CONFIG PROC NEAR 							
										
;-------------------------------------------------------------------------------
;										
; Try to read display combination code (PS/2 call):				
;										
;-------------------------------------------------------------------------------
	MOV	AX,READ_CONFIG_CALL						
	INT	10H			; Call video BIOS			
										
       .IF <AL EQ 1AH>			; If call is supported			
       .THEN									
;-------------------------------------------------------------------------------
;										
; Call is supported, PS/2 BIOS is present (Model 39,50,60,80 or BRECON-B card), 
; Determine what is the primary video adapter:					
;										
;-------------------------------------------------------------------------------
	 .SELECT								
	   .WHEN    <BL EQ 1> OR	    ; MONO or				
	   .WHEN    <BL EQ 2>		    ; CGA				
	      MOV     DS:[BP].HARDWARE_CONFIG,OLD_ADAPTER			
	   .WHEN    <BL EQ 4> OR	    ; EGA with Mono or			
	   .WHEN    <BL EQ 5>		    ; EGA with Color			
	      MOV     DS:[BP].HARDWARE_CONFIG,EGA				
	   .WHEN    <BL EQ 7> OR	    ; BRECON-B with Mono or		
	   .WHEN    <BL EQ 8>		    ; BRECON-B with Color		
	      MOV     DS:[BP].HARDWARE_CONFIG,ROUNDUP				
	   .WHEN    <BL EQ 0Bh> OR	    ; PS/2 Model 30 with Mono or	
	   .WHEN    <BL EQ 0Ch> 	    ; PS/2 Model 30 with Color		
	      MOV     DS:[BP].HARDWARE_CONFIG,PALACE				
	 .ENDSELECT								
;-------------------------------------------------------------------------------
;										
; PS/2 call is not supported, try the EGA info call:				
;										
;-------------------------------------------------------------------------------
       .ELSE									
	  MOV	  AH,ALT_SELECT_CALL	  ; Request Alternate select's          
	  MOV	  BL,EGA_INFO_CALL	  ;  "return EGA information call"      
	  INT	  10H			  ; Call video BIOS			
	 .IF	  <BL NE EGA_INFO_CALL>   ; If a memory value is returned	
	 .THEN				  ; then, there is an EGA		
	    MOV     DS:[BP].HARDWARE_CONFIG,EGA 				
	 .ELSE				  ; else, call is not supported:	
;-------------------------------------------------------------------------------
;										
; EGA call is not supported, try the PC CONVERTIBLE display description call:	
;										
;-------------------------------------------------------------------------------
	    MOV     AH,DISP_DESC_CALL						
	    INT     10H 		    ; Call BIOS, ES:DI :=Offset of parms
	   .IF	    <ES:[DI] EQ 5140H>	    ; If LCD display type,		
	   .THEN			    ;	set LCD bit in Shared Data area 
	      MOV     DS:[BP].HARDWARE_CONFIG,PC_CONVERTIBLE			
	   .ELSE			    ; else, we have an old adapter.	
	      MOV     DS:[BP].HARDWARE_CONFIG,OLD_ADAPTER ; (either MONO or CGA)
	   .ENDIF   ; Display type is LCD					
	 .ENDIF ; EGA BIOS is present						
       .ENDIF ; PS/2 BIOS is present						
	RET									
DET_HW_CONFIG ENDP								
PAGE										
;=======================================================================	
;										
; DET_MODE_STATE : Determine the current video mode and the active page.	
;										
;-----------------------------------------------------------------------	
;										
;	INPUT:	HARDWARE_CONFIG = Type of video hardware attached		
;										
;	OUTPUT: CUR_MODE = Video mode number (0-13H)				
;		CUR_PAGE = Video page number (0-8)				
;		NB_CHAR_COLUMNS = Number of columns if in a text mode.		
;										
;										
;	CALLED BY: PRT_SCR							
;										
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION:	Use the BIOS interface to					
; obtain the current mode and active page.					
;										
; LOGIC:									
;										
;   Call BIOS INTERRUPT 10H: "Return current video state" (AH = 0fh)            
;										
DET_MODE_STATE PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	MOV	AH,GET_STATE_CALL						
	INT	10H			; CALL BIOS				
	MOV	CUR_MODE,AL							
	MOV	NB_CHAR_COLUMNS,AH						
	MOV	CUR_PAGE,BH							
										
	POP	BX								
	POP	AX								
	RET									
DET_MODE_STATE ENDP								
										
PAGE										
;=======================================================================	
;										
; GET_MODE_ATTR: Obtain attributes of current video mode.			
;										
;-----------------------------------------------------------------------	
;										
;	INPUT:	CUR_MODE   = Current video mode (1 BYTE)			
;										
;	OUTPUT: MODE_TYPE  = Video mode type (TXT or APA)			
;		NB_COLORS  = Maximum number of colors (0-256) (0=B&W)		
;		ERROR_CODE = Error code if error occurred.			
;		SCREEN_HEIGHT= Number of rows (in pixels if APA or char if TEXT)
;		SCREEN_WIDTH = Number of columns (in pixels/char)		
;										
;	CALLED BY: PRT_SCR							
;										
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: Scan the 2 local video mode attribute tables until the		
; current mode is located.  Return the attributes.				
; For APA modes SCREEN_HEIGHT and SCREEN_WIDTH are in pixels,			
; for TEXT modes they are in characters.					
;										
;										
; LOGIC:									
;										
; Scan the APA_ATTR_TABLE							
; IF FOUND									
;   MODE_TYPE  := APA								
;   NB_COLORS  := mode.MAX_COLORS						
;   SCREEN_HEIGHT := mode.NB_L							
;   SCREEN_WIDTH  := mode.NB_C							
; ELSE										
;   Scan the TXT_ATTR_TABLE							
;   When FOUND									
;     MODE_TYPE := TXT								
;     NB_COLORS := mode.NUM_COLORS						
;     SCREEN_WIDTH := NB_CHAR_COLUMNS						
;     SCREEN_HEIGHT := Byte in ROM BIOS at 40:84				
;										
;-----------------------------------------------------------------------	
GET_MODE_ATTR	PROC	NEAR							
	JMP	SHORT GET_MODE_ATTR_BEGIN					
;-----------------------------------------------------------------------	
;										
; LOCAL DATA									
;										
;-----------------------------------------------------------------------	
										
APA_ATTR   STRUC      ; ATTRIBUTES FOR APA MODES:				
  APA_MODE   DB ?     ;   Mode number						
  NB_C	     DW ?     ;   Number of columns					
  NB_L	     DW ?     ;   Number of lines					
  MAX_COLORS DW ?     ;   Maximum number of colors available (0=B&W)		
APA_ATTR   ENDS 								
										
TXT_ATTR   STRUC      ; ATTRIBUTES FOR TXT MODES:				
  TXT_MODE   DB ?     ;   Mode number						
  NUM_COLORS DB ?     ;   Number of colors					
TXT_ATTR   ENDS 								
										
;-----------------------------------------------------------------------	
;										
; APA MODE ATTRIBUTES:								
;										
;-----------------------------------------------------------------------	
NB_APA_MODES	DW  10								
APA_ATTR_TABLE LABEL WORD							
MODE04	APA_ATTR <  4,320,200,	4>						
MODE05	APA_ATTR <  5,320,200,	4>						
MODE06	APA_ATTR <  6,640,200,	2>						
MODE0D	APA_ATTR <0DH,320,200, 16>						
MODE0E	APA_ATTR <0EH,640,200, 16>						
MODE0F	APA_ATTR <0FH,640,350,	4>						
MODE10H APA_ATTR <10H,640,350, 16>						
MODE11H APA_ATTR <11H,640,480,	2>						
MODE12H APA_ATTR <12H,640,480, 16>						
MODE13H APA_ATTR <13H,320,200,256>						
										
;-----------------------------------------------------------------------	
;										
; TXT MODE ATTRIBUTES:								
;										
;-----------------------------------------------------------------------	
NB_TXT_MODES	DW  5								
TXT_ATTR_TABLE LABEL WORD							
MODE00 TXT_ATTR <  0, 16>							
MODE01 TXT_ATTR <  1, 16>							
MODE02 TXT_ATTR <  2, 16>							
MODE03 TXT_ATTR <  3, 16>							
MODE07 TXT_ATTR <  7,  0>							
										
;-----------------------------------------------------------------------	
;										
; BEGIN OF GET_MODE_ATTR							
;										
;-----------------------------------------------------------------------	
GET_MODE_ATTR_BEGIN:								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	MOV	DL,CUR_MODE		; DL = CURRENT MODE			
;										
; Scan the APA_ATTR_TABLE							
;										
	MOV	CX,NB_APA_MODES 	; CS <-- Number of APA modes		
	MOV	BX,OFFSET APA_ATTR_TABLE; BX <-- Offset of APA mode table	
      SCAN_APA: 								
	CMP	DL,[BX].APA_MODE	; IF mode found 			
	JE	SHORT ITS_APA		; THEN get its attributes		
	ADD	BX,SIZE APA_ATTR						
      LOOP    SCAN_APA			; ELSE keep scanning			
	JMP	SHORT SCAN_TXT_INIT	; NOT in this table: scan txt modes	
ITS_APA:									
	MOV	MODE_TYPE,APA		; MODE = APA				
	MOV	AX,[BX].MAX_COLORS						
	MOV	NB_COLORS,AX		; Get number of colors			
	MOV	AX,[BX].NB_L							
	MOV	SCREEN_HEIGHT,AX	; Get number of lines			
	MOV	AX,[BX].NB_C							
	MOV	SCREEN_WIDTH,AX 	; Get number of columns 		
	JMP	SHORT GET_MODE_ATTR_END 					
										
;										
; Scan the TXT_ATTR_TABLE							
;										
SCAN_TXT_INIT:									
	MOV	CX,NB_TXT_MODES 	; CX <-- Number of TXT modes		
	MOV	BX,OFFSET TXT_ATTR_TABLE; BX <-- Offset of TXT mode table	
      SCAN_TXT: 								
	CMP	DL,[BX].TXT_MODE	; IF mode found 			
	JE	SHORT ITS_TXT		; THEN get its attributes		
	ADD	BX,SIZE TXT_ATTR						
      LOOP    SCAN_TXT			; ELSE keep scanning			
ITS_TXT:									
	MOV	MODE_TYPE,TXT		; MODE = TXT				
	MOV	AL,[BX].NUM_COLORS						
	CBW									
	MOV	NB_COLORS,AX		; Get number of colors			
	MOV	AL,NB_CHAR_COLUMNS	; Get number of columns 		
	CBW									
	MOV	SCREEN_WIDTH,AX 						
       .IF  <DS:[BP].HARDWARE_CONFIG EQ OLD_ADAPTER>; If an old adapter is there
       .THEN ; The number of lines is 25					
	  MOV	  SCREEN_HEIGHT,25						
       .ELSE									
	  MOV	  AX,BIOS_SEG		; Get number of rows			
	  MOV	  ES,AX 		;  from BIOS Data Area			
	  MOV	  BX,NB_ROWS_OFFSET	;   at 0040:0084			
	  MOV	  AL,ES:[BX]							
	  CBW									
	  INC	  AX								
	  MOV	  SCREEN_HEIGHT,AX						
       .ENDIF									
	JMP	SHORT GET_MODE_ATTR_END 					
										
;										
; The current mode was not found in any of the tables				
;										
	MOV	ERROR_CODE,MODE_NOT_SUPPORTED					
										
GET_MODE_ATTR_END:								
	POP	AX								
	POP	BX								
	POP	CX								
	POP	DX								
	RET									
GET_MODE_ATTR ENDP								
PAGE										
;=======================================================================	
;										
; SET_UP_XLT_TABLE : SET UP A COLOR MAPPING FOR EACH COLOR AVAILABLE		
;		     WITH THE CURRENT MODE					
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: CUR_MODE        = Current video mode.				
;	       HARDWARE_CONFIG = Type of display adapter.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       XLT_TAB	       = Color translation table.			
;	       CUR_PAGE        = Active page number				
;	       BP	       = Offset of the shared data area 		
;										
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: PRT_SCR							
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: The table is updated to hold a mapping for each color		
; available in the current video mode either TEXT or APA.			
;										
; For example, if the current mode supports 16 colors then the first		
; sixteen bytes of the table will hold the corresponding Color printer		
; or Black and White printer mappings for these colors. 			
;										
;										
; LOGIC:									
;										
; IF HARDWARE_CONFIG = CGA OR HARDWARE_CONFIG = PC_CONVERTIBLE			
; THEN										
;   CALL SET_CGA_XLT_TAB							
;										
; ELSE IF HARDWARE_CONFIG = EGA 						
;   THEN									
;   CALL SET_EGA_XLT_TAB							
;										
; ELSE IF CUR_MODE = 0FH							
;   THEN									
;   CALL SET_MODE_F_XLT_TAB							
;										
; ELSE IF CUR_MODE = 19 							
;   THEN									
;   CALL SET_MODE_13H_XLT_TAB							
;										
; ELSE										
;   CALL SET_ROUNDUP_XLT_TAB							
;										
; CALL SET_BACKG_IN_XLT_TAB   ; Update the background in the translation table	
;										
SET_UP_XLT_TAB PROC NEAR							
;-------------------------------------------------------------------------------
; For old display modes: set up translation table as for a Color Graphics Adapt.
; Either 4 or 16 colors are set up depending if the mode is an APA or text mode.
;										
; NOTE: SET_UP_XLT_TAB cannot be invoked if the display adater is a Monochrome	
;	display adater. (When a Mono. adapter is attached, a jump is made to	
;	the ROM BIOS for printing the screen, and no translation table is set). 
;-------------------------------------------------------------------------------
.IF <BIT DS:[BP].HARDWARE_CONFIG  NZ OLD_ADAPTER> OR ; IF it is a CGA		
.IF <BIT DS:[BP].HARDWARE_CONFIG  NZ PC_CONVERTIBLE> ; or a PC convertible	
.THEN						     ; THEN set up CGA colors	
   CALL    SET_CGA_XLT_TAB			     ;				
.ELSEIF <BIT DS:[BP].HARDWARE_CONFIG NZ EGA>	     ; ELSEIF it is an EGA	
   CALL    SET_EGA_XLT_TAB			     ;	  set up EGA colors.	
.ELSEIF <CUR_MODE EQ 0FH>			     ; ELSEIF we are in mode 15 
   CALL    SET_MODE_F_XLT_TAB			     ;	  set up its 4 shades	
;-------------------------------------------------------------------------------
; A PS/2 system is attached: (we either have a PALACE [Model 30] or a ROUNDUP)	
;-------------------------------------------------------------------------------
.ELSEIF <CUR_MODE EQ 13H>			    ; ELSEIF current mode is 13h
   CALL    SET_MODE_13H_XLT_TAB 		    ;	  set up 256 colors	
.ELSEIF <BIT DS:[BP].HARDWARE_CONFIG NZ PALACE>     ; ELSEIF PS/2 Model 30(MCGA)
   CALL    SET_CGA_XLT_TAB			    ;	  handle it like a CGA	
.ELSE						    ; ELSE we have a ROUNDUP	
;-------------------------------------------------------------------------------
; A PS/2 model 50, 60 or 80 or an ADA 'B' card is attached (in 16 color mode):  
;-------------------------------------------------------------------------------
   CALL    SET_ROUNDUP_XLT_TAB			;   set up 16 colors		
.ENDIF										
;-------------------------------------------------------------------------------
; Finish setting up the translation table:					
;-------------------------------------------------------------------------------
										
CALL SET_BACKG_IN_XLT_TAB   ; Update the background in the translation table	
			    ;  according to the command line switch setting	
			    ;	(i.e.,/R /B)					
   RET										
SET_UP_XLT_TAB ENDP								
PAGE										
;===============================================================================
;										
; SET_BACKG_IN_XLT_TAB : ADJUST THE MAPPING FOR THE BACKGROUND COLOR IN THE	
;			 XLT_TAB ACCORDING TO PRINTER TYPE AND /R /B.		
;										
;										
;-------------------------------------------------------------------------------
;										
; INPUT:  BP = Offset of shared data area  (SWITCHES)				
;	  XLT_TAB = The color translation table.				
;										
; OUTPUT: XLT_TAB IS UPDATED							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: If there is a black and white printer and /R is NOT specified	
; then the background color should not be printed and it is replaced in the	
; translation table by the Intensity for white (will print nothing).		
;										
; If a color printer is attached and /B is not specified then the background	
; color is replaced by the Print Band mask for white.				
;										
; LOGIC:									
; IF  (a black and white printer is attached) AND (/R is OFF)			
; THEN										
;   MOV 	XLT_TAB, WHITE_INT	; Store white in translation table	
; ELSE (a color printer is attached)						
;   IF (/B is ON)								
;   THEN									
;      RGB.R := MAX_INT 							
;      RGB.G := MAX_INT 							
;      RGB.B := MAX_INT 							
;      CALL RGB2BAND			; Convert RGB for white to a Band Mask	
;      MOV	XLT_TAB,AL		; Store the band mask in the xlt table	
;										
;										
;-------------------------------------------------------------------------------
SET_BACKG_IN_XLT_TAB PROC NEAR							
;-------------------------------------------------------------------------------
;										
; Test if a black and white printer is attached.				
;										
;-------------------------------------------------------------------------------
.IF <BIT DS:[BP].PRINTER_TYPE NZ BLACK_WHITE> AND    ; IF black and white	
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW> 	     ;	   printer and not /R	
.THEN						     ; then, map background	
	MOV	XLT_TAB,WHITE_INT		     ;	   to white.		
;-------------------------------------------------------------------------------
;										
; A Color printer is attached:							
;										
;-------------------------------------------------------------------------------
.ELSEIF <BIT DS:[BP].PRINTER_TYPE NZ COLOR> AND      ; else, if color printer	
.IF <BIT DS:[BP].SWITCHES Z BACKGROUND_SW>	     ;	      and  /B if OFF	
.THEN						     ;				
						     ; Store a null band mask	
	MOV	XLT_TAB,0			     ;	the translation table.	
.ENDIF										
	RET									
SET_BACKG_IN_XLT_TAB  ENDP							
PAGE										
;=======================================================================	
;										
; SET_EGA_XLT_TAB : SET UP COLOR TRANSLATION TABLE FOR ENHANCED GRAPHIC 	
;		    ADAPTER							
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB = Color translation table.				
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the EGA, "VIDEO BIOS READ DOT call" returns an index into         
; the 16 EGA palette registers. 						
;										
; These registers contain the actual colors stored as rgbRGB components 	
; (see EGA_COL2RGB for details) for mode hex 10.  Under mode hex E these	
; registers contain the actual colors as I0RGB components (see CGA_COL2RGB	
; for details). 								
;										
; These registers can be Revised by the user but, are 'WRITE ONLY'.            
; However, it is possible to define a SAVE AREA where BIOS will maintain	
; a copy of the palette registers.						
;										
; This area is called the "DYNAMIC SAVE AREA" and is defined via the            
; BIOS EGA SAVE_PTR AREA. Whenever the palette registers are changed by 	
; the user, BIOS updates the EGA_SAVE_AREA.					
;										
; The 16 palette registers are the first 16 bytes of the DYNAMIC SAVE AREA.	
;										
; This program takes advantage of this feature and consults the EGA DYNAMIC	
; SAVE AREA in order to obtain the colors used in the active screen.		
;										
;										
; DESCRIPTION: Obtain each color available with an EGA by reading its		
; palette register in the EGA_SAVE_AREA:					
;										
; Calculate the mapping for this color, either a BAND_MASK or a 		
; GREY INTENSITY and store it in the color translation table.			
;										
;										
; LOGIC:									
;										
; Obtain the DYNAMIC EGA SAVE AREA offset from the BIOS SAVE_PTR_AREA.		
;										
; If current mode is either 4,5 or 6						
; Then, 									
;   CALL SET_CGA_XLT_TAB							
;   Get the background color by reading palette register number 0		
; Else, 									
;   For each register number (0 to 15): 					
;     Get the register contents (rgbRGB values) from the EGA SAVE AREA		
;     CALL EGA_COL2RGB		  ; Obtain the Red, Green, Blue values		
;     CALL RGB2XLT_TAB		  ; Obtain a Band Mask or a Grey Intensity	
;				  ; and store the result in the XLT_TAB 	
;										
SET_EGA_XLT_TAB PROC NEAR							
	PUSH	AX			; Save the registers used		
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
;-------------------------------------------------------------------------------
;										
; Obtain the pointer to the DYNAMIC SAVE AREA from the SAVE AREA POINTER TABLE: 
;										
;-------------------------------------------------------------------------------
EGA_SAVE_PTR	EQU	4A8H		; EGA BIOS pointer to table of		
					; pointer to save areas.		
	XOR	AX,AX			; ES segment := paragraph 0		
	MOV	ES,AX								
										
	LES	BX,ES:DWORD PTR EGA_SAVE_PTR ; ES:BX := Pointer to ptr table	
	LES	BX,ES:[BX]+4		; ES:BX :=  Pointer to dynamic save area
					;  (NOTE: It is the second pointer in	
					;   the table)				
										
;-------------------------------------------------------------------------------
;										
; Set up one entry in the translation table for each color available.		
;										
;-------------------------------------------------------------------------------
.IF <CUR_MODE EQ 4> OR			; If the current mode is an old CGA	
.IF <CUR_MODE EQ 5> OR			;  GRAPHICS mode:			
.IF <CUR_MODE EQ 6>								
.THEN										
;-------------------------------------------------------------------------------
; Current mode is either mode 4, 5 or 6;					
; Store each color of the old CGA All Points Addressable mode:			
;-------------------------------------------------------------------------------
	CALL	SET_CGA_XLT_TAB 	; Set up  colors in the translation	
					;  table, NOTE: The background color	
					;   will not be set properly since the	
					;    EGA BIOS does not update memory	
					;     location 40:66 with the value	
					;      of the background color as CGA	
					;	does.				
;------Adjust the background color in the translation table:			
;------The background color is obtained from the EGA DYNAMIC SAVE AREA		
;------ES:BX = Address of the EGA DYNAMIC SAVE AREA				
;------NOTE : For CGA compatible modes EGA BIOS stores the color in the 	
;------DYNAMIC SAVE AREA as a I0RGB value.					
	XOR	DI,DI			; DI:=register number = index in XLT_TAB
	MOV	AL,ES:[BX][DI]		; AL:=Palette register 0 = Back. color	
	MOV	AH,AL			;  Convert I0RGB to IRGB (CGA color)	
	AND	AL,111B 		;    Isolate RGB bits			
	AND	AH,10000B		;    Isolate I bit			
	SHR	AH,1			;    Move I bit from position 5 to 4	
	OR	AL,AH			;    Get IRGB byte.			
	CALL	CGA_COL2RGB		; Convert IRGB to R,G,B values		
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
										
.ELSE					; ELSE, we have an EGA graphics mode:	
;-------------------------------------------------------------------------------
; The current mode is a either a text mode or one of the EGA enhanced mode;	
; Store in the translation table each color available (these modes have 16 col.)
;-------------------------------------------------------------------------------
	MOV	CX,16			; CX := Number of palette registers	
					;	to read 			
	XOR	DI,DI			; DI := Palette register number 	
					;  and index in the translation table	
STORE_1_EGA_COLOR:								
	MOV	AL,ES:[BX][DI]		; AL := Palette register		
       .IF   <CUR_MODE EQ 14> OR	; If mode E (hex) OR mode D (hex)	
       .IF   <CUR_MODE EQ 13>		; the colors are			
       .THEN				;  stored as I0CGA colors		
	  MOV	  AH,AL 		;  Convert I0RGB to IRGB (CGA color)	
	  AND	  AL,111B		;    Isolate RGB bits			
	  AND	  AH,10000B		;    Isolate I bit			
	  SHR	  AH,1			;    Move I bit from position 5 to 4	
	  OR	  AL,AH 		;    Get IRGB byte.			
	  CALL	  CGA_COL2RGB		;  Convert IRGB to R,G,B values 	
       .ELSE				; Else, they are stored as (rgbRGB);	
	  CALL	  EGA_COL2RGB		;   Convert register to R,G,B values	
       .ENDIF									
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
	INC	DI			; Get next palette register number	
	LOOP	STORE_1_EGA_COLOR						
.ENDIF					; ENDIF 4 colors or 16 colors		
										
	POP	DI			; Restore the registers 		
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
SET_EGA_XLT_TAB ENDP								
PAGE										
;=======================================================================	
;										
; SET_CGA_XLT_TAB : SET UP COLOR TRANSLATION TABLE FOR COLOR GRAPHIC		
;		    ADAPTER							
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	       = Color translation table.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the CGA, the "VIDEO BIOS READ DOT call" returns a number          
; from 0 to 3. A dot of value 0 is of the background color.			
;										
; The actual value of the background color is stored in BIOS VIDEO		
; DISPLAY DATA AREA as a PIIRGB value (see CGA_COL2RGB for details) and 	
; can be any of 16 colors.							
;										
; A dot of value 1,2, or 3 represents any of 2 specific colors depending	
; on the current color palette. 						
;										
; The palette number is obtained from the BIOS VIDEO DISPLAY DATA AREA		
; (It is the "P" bit or bit number 5)                                           
;										
; The dot values 1,2,3 expressed in binary actually represent the RG		
; (Red, Green) components of the color. 					
;										
; The palette number represents the B (Blue) component therefore, when		
; the palette number is appended to the color number we obtain the RGB		
; components for that color.							
;										
;  (E.G.,  COLOR  =  010	; COLOR # 2					
;	   PALETTE=    0	; PALETTE # 0					
;										
;	   IRGB   =  0100	; Intensity = 0  Ŀ				
;				; Red	    = 1   > color = Red		
;				; Green     = 0   				
;				; Blue	    = 0  				
;										
;										
; DESCRIPTION:									
;										
; For each color available with a CGA:						
;	 Calculate the color mapping, either a BAND_MASK or a GREY		
;	 INTENSITY and store it in the color translation table. 		
;										
; LOGIC:									
;										
; ; Obtain the background color from VIDEO BIOS DATA AREA			
; ;  and the paletter number							
;										
; ; Store the Background color: 						
; CALL CGA_COL2RGB		  ; Convert IRGB components to RGB values	
; CALL RGB2XLT_TAB		  ; Convert RGB to an entry in the translation	
;				  ; table					
; ; Store all other colors:							
; FOR IRG := 1 TO 3		  ; Obtain the color number			
;   Append palette number (B) to IRG						
;   CALL CGA_COL2RGB		  ; Convert color to RGB values 		
;   CALL RGB2XLT_TAB		  ; Convert RGB to an entry in the translation	
;				  ; table					
;										
SET_CGA_XLT_TAB  PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DI								
	PUSH	ES								
										
.IF <CUR_MODE EQ 4> OR								
.IF <CUR_MODE EQ 5>								
;===============================================================================
;										
; THE CURRENT MODE IS MODE 4 OR 5						
;										
;-------------------------------------------------------------------------------
.THEN										
;-------------------------------------------------------------------------------
; Read the CRT palette from the BIOS ROM to obtain the background color and	
; the current palette number; store the palette number in BL			
;-------------------------------------------------------------------------------
ROM_BIOS_SEG	EQU 40H    ; CGA BIOS SEGMENT					
CRT_PALETTE_OFF EQU 66H    ; BIOS Current palette setting			
P_BIT_MASK   EQU 100000B   ;   bit 5 = Current palette				
I_BIT_MASK   EQU   1000B   ;   bit 4 = Intensity bit				
R_BIT_MASK   EQU    100B   ;   bit 2 = Red bit					
G_BIT_MASK   EQU     10B   ;   bit 1 = Green bit				
B_BIT_MASK   EQU      1B   ;   bit 0 = Blue bit 				
										
	MOV	AX,ROM_BIOS_SEG      ; ES := ROM BIOS SEGMENT			
	PUSH	AX								
	POP	ES								
										
	MOV	AL,ES:CRT_PALETTE_OFF; AL := CRT Palette  (00PIIRGB)		
	MOV	BL,P_BIT_MASK	     ; LOW NIBBLE = BACKGROUND COLOR		
	AND	BL,AL		     ; BL := Palette number			
	MOV	CL,5								
	SHR	BL,CL								
										
	XOR	DI,DI		     ; DI := Index in the XLT_TAB		
;-------------------------------------------------------------------------------
; Store the background color, (obtained from low 4 bits of the byte at 40:66)	
;-------------------------------------------------------------------------------
	CALL	CGA_COL2RGB	     ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	     ; Convert RGB to an entry in XLT_TAB	
;-------------------------------------------------------------------------------
; Store the 3 foreground colors for mode 4 and 5				
;-------------------------------------------------------------------------------
	MOV	CX,3		     ; For each color, but the background:	
STORE_1_CGA_MODE4_COLOR:							
	INC	DI		     ; Increment index in the translation table 
	MOV	AX,DI		     ; AL := IRG				
	SHL	AL,1								
	OR	AL,BL		     ; AL := IRGB				
	CALL	CGA_COL2RGB	     ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	     ; Convert RGB to an entry in XLT_TAB	
	LOOP	STORE_1_CGA_MODE4_COLOR 					
.ELSEIF <CUR_MODE EQ 6> 							
;===============================================================================
;										
; THE CURRENT MODE IS MODE 6							
;										
;-------------------------------------------------------------------------------
.THEN										
;-------------------------------------------------------------------------------
; Store background color for mode 6 (mode 6 is a 2 colors, APA mode)		
; Background is stored as BLACK 						
;-------------------------------------------------------------------------------
	XOR	DI,DI		  ; DI := Index of color in translation table	
	MOV	RGB.R,BLACK_INT   ; Foreground color is white			
	MOV	RGB.G,BLACK_INT   ; RGB := RGB of white 			
	MOV	RGB.B,BLACK_INT   ;						
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
;-------------------------------------------------------------------------------
; Store foreground color for mode 6 (mode 6 is a 2 colors, APA mode)		
;-------------------------------------------------------------------------------
	INC	DI		  ; DI := Index of color in translation table	
	MOV	RGB.R,WHITE_INT   ; Background color is BLACK			
	MOV	RGB.G,WHITE_INT   ; RGB := RGB of BLACK 			
	MOV	RGB.B,WHITE_INT   ;						
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
.ELSE										
;===============================================================================
;										
; THE CURRENT MODE IS A TEXT MODE:						
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI		  ; DI := Index in the translation table	
	MOV	CX,16		  ; For each of the 16 colors:			
STORE_1_CGA_TEXT_COLOR: 							
	MOV	AX,DI		  ; AL := IRGB					
	CALL	CGA_COL2RGB	  ; Convert color (in AL) to R, G, B values	
	CALL	RGB2XLT_TAB	  ; Convert RGB to an entry in XLT_TAB		
	INC	DI		  ; Increment index in the translation table	
	LOOP	STORE_1_CGA_TEXT_COLOR						
.ENDIF				  ;						
										
	POP	ES								
	POP	DI								
	POP	CX								
	POP	BX								
	POP	AX								
										
	RET									
SET_CGA_XLT_TAB  ENDP								
PAGE										
;===============================================================================
;										
; RGB2XLT_TAB: CONVERT R,G,B VALUES TO EITHER A BAND MASK OR AN INTENSITY	
;	   STORE THE RESULT IN THE TRANSLATION TABLE				
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	 DI  = Index in the translation table				
;		 RGB = Red Green Blue values of the color to be stored. 	
;										
;	OUTPUT:  XLT_TAB is updated						
;										
;-------------------------------------------------------------------------------
; DESCRIPTION: Convert the RGB values to either a Band mask or an intensity	
; depending on the printer type; store the result in the translation table.	
;										
; LOGIC:									
;   IF PRINTER_TYPE = COLOR							
;     THEN									
;     CALL RGB2BAND		  ; Obtain a Band Mask				
;   ELSE ; Printer is Monochrome						
;     CALL RGB2INT		  ; Obtain a Grey Intensity			
;   Store the result in the XLT_TAB						
;										
RGB2XLT_TAB PROC NEAR								
       .IF <DS:[BP].PRINTER_TYPE EQ COLOR>; Color printer ?			
       .THEN									
;-------A color printer is attached:						
	  CALL	  RGB2BAND		; Yes, convert RGB to color band (in AL)
       .ELSE									
;-------A black and white printer is attached:					
	  CALL	  RGB2INT		; No, RGB to an intensity in AL 	
       .ENDIF									
;-------Store the result							
	MOV	XLT_TAB[DI],AL							
       RET									
RGB2XLT_TAB ENDP								
PAGE										
;===============================================================================
;										
; CGA_COL2RGB : CONVERT A COLOR FROM THE CGA TO RED GREEN BLUE VALUES		
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: AL      = 0000IRGB    ONE BYTE WHERE BIT:			
;										
;					I = Intensity bit			
;					R = Red component			
;					G = Green component			
;					B = Blue component			
;										
;										
;	OUTPUT: RGB.R	    = RED   component (0-63)				
;		RGB.G	    = GREEN component (0-63)				
;		RGB.B	    = BLUE  component (0-63)				
;										
;	CALLED BY: SET_UP_CGA_XLT_TABLE 					
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: If either the RED, GREEN, or BLUE bit is on (in an IRGB		
; byte) then, the corresponding color gun on the display is firing 2/3		
; of its capacity, giving a color intensity of "2/3".                           
;										
; If the INTENSITY bit is on, then 1/3 is added to EACH color.			
;										
; (E.G.,		       IRGB		 R    G    B			
;	   BLACK	 = 00000000	      (  0,   0,   0)			
;	   WHITE	 = 00001111	      (3/3, 3/3, 3/3)			
;	   RED		 = 00000100	      (2/3,   0,   0)			
;	   HIGH INT. RED = 00001100	      (3/3, 1/3, 1/3)			
;										
; Since we want an intensity from 0 to 63,					
; "2/3" of RED means:                                                           
;		       2/3 * 63 = 42						
;										
;										
; LOGIC:									
; Get the intensity.								
; Get the red component 							
; Get the green component							
; Get the blue component							
;										
CGA_COL2RGB PROC NEAR								
;-----------------------------------------------------------------------	
;										
; Init the R,G,B values:							
;										
;-----------------------------------------------------------------------	
	MOV	RGB.R,0 							
	MOV	RGB.G,0 							
	MOV	RGB.B,0 							
;-----------------------------------------------------------------------	
;										
; Test the Intensity bit:							
;										
;-----------------------------------------------------------------------	
       .IF <BIT AL AND I_BIT_MASK>	; IF, I is on				
       .THEN									
	  ADD	  RGB.R,ONE_THIRD	; Then, add one third to each		
	  ADD	  RGB.G,ONE_THIRD	; color.				
	  ADD	  RGB.B,ONE_THIRD						
       .ENDIF									
;-----------------------------------------------------------------------	
;										
; Test the RGB bits:								
;										
;-----------------------------------------------------------------------	
       .IF <BIT AL AND R_BIT_MASK>	; If, Red is on 			
       .THEN									
	  ADD	  RGB.R,TWO_THIRD	; then, add two third RED		
       .ENDIF									
										
       .IF <BIT AL AND G_BIT_MASK>	; If, Green is on			
       .THEN									
	  ADD	  RGB.G,TWO_THIRD	; then, add two third GREEN		
       .ENDIF									
										
       .IF <BIT AL AND B_BIT_MASK>	; If, Blue is on			
       .THEN									
	  ADD	  RGB.B,TWO_THIRD	; then, add two third BLUE		
       .ENDIF									
										
	RET									
CGA_COL2RGB ENDP								
PAGE										
;=======================================================================	
;										
; SET_MODE_F_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR MONOCHROME		
;		      MODE "F"                                                  
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	     = Color translation table. 			
;	       PRINTER_TYPE  = Type of printer attached (Color or B&W)		
;	       SWITCHES      = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-------------------------------------------------------------------------------
;										
; NOTES: In mode F the "VIDEO BIOS READ DOT call" returns a byte where          
; bit 1 and 3 represent the value of plane 1 and 3.				
; The following colors are available using this mode:				
;										
;		plane 2:   plane 0:	   color:				
;		   0	      0 	   black				
;		   0	      1 	   white				
;		   1	      0 	   blinking white			
;		   1	      1 	   high-intensity white 		
;										
;										
; DESCRIPTION: A local table holds the Red, Green, Blue values for each of	
; the 4 Mono colors available in Mode Fh.					
; Each color is stored as either a Grey intensity if printing in Monochrome	
; or as a Band Mask if printing in color.					
; Black is stored as black.							
; White is stored as a light gray						
; High-intensity white and blinking white are stored as white.			
;										
;										
; LOGIC:									
; FOR EACH "COLOR" AVAILABLE WITH MODE F                                        
; GET ITS R,G,B VALUES								
; CALL RGB2XLT_TAB		; Convert RGB to an entry in the translation	
;				; table 					
;										
SET_MODE_F_XLT_TAB PROC NEAR							
	PUSH	AX								
	PUSH	SI								
	PUSH	DI								
	JMP	SHORT SET_MODE_F_BEGIN						
;-------------------------------------------------------------------------------
;										
; TABLE OF R,G,B VALUES WE ASSIGN TO THE 4 COLORS AVAILABLE IN MODE F:		
;										
;-------------------------------------------------------------------------------
MODE_F_RGB	LABEL	BYTE							
	DB	BLACK_INT,BLACK_INT,BLACK_INT ; Black is mapped to black.	
	DB	TWO_THIRD,TWO_THIRD,TWO_THIRD ; White		--> light grey	
	DB	WHITE_INT,WHITE_INT,WHITE_INT ; Blinking	--> white	
	DB	WHITE_INT,WHITE_INT,WHITE_INT ; High-int. White --> white	
;-------------------------------------------------------------------------------
;										
; STORE THE COLORS AVAILABLE WITH MODE F					
;										
;-------------------------------------------------------------------------------
SET_MODE_F_BEGIN:								
	MOV	SI,OFFSET MODE_F_RGB	; SI <-- Offset of RGB table		
	XOR	DI,DI			; DI <-- Index into translation table	
										
;-------For each color available in mode F:					
STORE_1_MODE_F_COLOR:								
	MOV	AL,[SI] 		; Get the Red component 		
	MOV	RGB.R,AL							
	MOV	AL,[SI]+1		; Get the Green component		
	MOV	RGB.G,AL							
	MOV	AL,[SI]+2		; Get the Blue component		
	MOV	RGB.B,AL							
										
;-------Convert pixel to either a Color band or an Intensity:			
	CALL	RGB2XLT_TAB		; Convert and store in the xlt table	
										
	ADD	SI,3			; Get next R,G,B values 		
	INC	DI			; One more color has been stored	
	CMP	DI,NB_COLORS		; All stored ?				
	JL	STORE_1_MODE_F_COLOR						
										
	POP	DI								
	POP	SI								
	POP	AX								
	RET									
SET_MODE_F_XLT_TAB ENDP 							
PAGE										
;=======================================================================	
;										
; SET_MODE_13H_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR PALACE VIDEO 	
;		      ADAPTER IN MODE 13H					
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: XLT_TAB	      = Color translation table.			
;	       PRINTER_TYPE   = Type of printer attached (Color or B&W) 	
;	       SWITCHES       = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-----------------------------------------------------------------------	
;										
; NOTES: With the PALACE the "VIDEO BIOS READ DOT call" returns a direct        
; index to the 256 COLOR REGISTERS.						
;										
; These COLORS REGISTERS hold the R,G,B (Red, Green, Blue) values for		
; each of the 256 colors available at the same time on the screen.		
; Color register number 0 holds the background color.				
;										
; DESCRIPTION: Store a color mapping for each color register.			
; If the REVERSE_SW is off,  exchange white and black.				
;										
; LOGIC:									
;										
; For each color (0 to 255)							
;   Read the color register	; get the RGB values for this color num.	
;   Store the result in the XLT_TAB						
;										
SET_MODE_13H_XLT_TAB PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	DI								
										
	MOV	NB_COLORS_TO_READ,256	; Read 256 color registers		
										
;-------------------------------------------------------------------------------
;										
; Store in the translation table each color available for mode 13h:		
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI			; DI := Palette register number 	
					;  and index in the translation table	
STORE_1_M13H_COLOR:								
	MOV	BX,DI			; BX := Color register to be read	
	MOV	AX,GET_C_REG_CALL	; AX := BIOS Get color register call	
	INT	10H			; Call BIOS				
	MOV	RGB.R,DH		; Get Red value 			
	MOV	RGB.G,CH		; Get Green value			
	MOV	RGB.B,CL		; Get Blue value			
	CALL	RGB2XLT_TAB		; Convert RGB to an entry in XLT_TAB	
	INC	DI			; Get next palette register number	
	CMP	DI,NB_COLORS_TO_READ	; All colors stored ?			
	JL	STORE_1_M13H_COLOR	; No, get next one			
										
										
	POP	DI								
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
NB_COLORS_TO_READ DW ?		; Number of colors registers to read with a PS/2
SET_MODE_13H_XLT_TAB ENDP							
PAGE										
;===============================================================================
;										
; SET_ROUNDUP_XLT_TAB: SET UP COLOR TRANSLATION TABLE FOR ROUNDUP VIDEO 	
;		       ADAPTER							
;										
;-------------------------------------------------------------------------------
;										
;	INPUT: XLT_TAB	       = Color translation table.			
;	       PRINTER_TYPE    = Type of printer attached (Color or B&W)	
;	       SWITCHES        = GRAPHICS command line parameters.		
;										
;	OUTPUT: XLT_TAB IS UPDATED						
;										
;	CALLED BY: SET_UP_XLT_TABLE						
;										
;-------------------------------------------------------------------------------
;										
; NOTES: With the ROUNDUP the "VIDEO BIOS READ DOT call" returns an             
; index into the 16 PALETTE REGISTERS.						
;										
; Each palette register holds an index into the current "color page"            
; within the 256 COLOR REGISTERS.						
;										
; These "color pages" represent all the colors from WHICH TO CHOOSE the         
; screen colors for an active page; 16 colors can be displayed at the		
; same time on the screen.							
;										
; There are 2 paging modes: either 64 color pages or 16 color pages:		
;										
; In 64 color mode, there are 4 color pages available (the 256 palette		
; registers are partitioned in 4 blocks of 64 colors).				
;										
; The 16 screen colors for the active page are selected from these 64		
; color registers.								
;										
; This scheme allows for quickly changing the contents of the screen by 	
; changing the active page.							
;										
; The COLOR REGISTERS contains the color information stored as RGB (Red,	
; Green, Blue) components. There is one byte for each of these 3		
; components.  The value for each component ranges from 0 to 63 (where		
; 0 = color not present).							
;										
;										
; DESCRIPTION: Determine the paging mode and the active color page.		
; For each color available with the current mode, get the palette		
; register and then, read the corresponding color register in order to		
; obtain its RGB components.							
;										
; For mode 11h, 2 colors only are available. These colors are obtained from	
; palette register 0 (background) and 7 (foreground color). The contents	
; of these 2 palette registers is also used as an index within the color	
; registers.									
;										
; If printing is Monochrome, map the RGB to a Grey Intensity.			
; If printing is in colors, map the RGB to a Band Mask. 			
; Store the result in the translation table					
;										
; LOGIC:									
;										
; Read color page state (BIOS INT 10H - AL = 1AH)				
;										
; If mode 4,5 or 6								
; Then										
;   CALL SET_CGA_XLT_TAB							
;   Adjust the background color.						
; else										
; If mode 11h									
; then										
; For PALETTE_INDEX := 0 to 15							
; IF PAGE_MODE = PAGE_64_REGISTERS						
;   THEN									
;   Read the palette register number "PALETTE_INDEX"                            
;   COLOR_INDEX := Palette register contents					
;   COLOR_INDEX := (CUR_PAGE_NUM * 64) + COLOR_INDEX				
;   Read color register number "COLOR_INDEX"    ; Obtain R,G,B values.          
;   CALL    RGB2XLT_TAB       ; Convert RGB to an entry in XLT_TAB		
;										
; ELSE IF PAGE_MODE = PAGE_16_REGISTERS 					
;   COLOR_INDEX := (CUR_PAGE_NUM * 16) + PALETTE_INDEX				
;   Read color register number "COLOR_INDEX"                                    
;   CALL    RGB2XLT_TAB       ; Convert RGB to an entry in XLT_TAB		
;										
;										
SET_ROUNDUP_XLT_TAB PROC NEAR							
PAGING_MODE_64 EQU 0								
										
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DI								
										
;-------------------------------------------------------------------------------
; Obtain the color page state							
;-------------------------------------------------------------------------------
	MOV	AX,PAGE_STATE_CALL	  ; Call BIOS				
	INT	10H			  ;  BL := Paging mode			
					  ;  BH := Current page 		
										
;-------------------------------------------------------------------------------
; Check the video mode: 							
;-------------------------------------------------------------------------------
.SELECT 									
.WHEN <CUR_MODE EQ 4> OR		  ; If the current mode is an old CGA	
.WHEN <CUR_MODE EQ 5> OR		  ;  mode:				
.WHEN <CUR_MODE EQ 6>			  ;					
;-------------------------------------------------------------------------------
;										
; Old CGA graphics mode (mode 4, 5 or 6)					
;										
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Store colors of the old CGA modes:						
;-------------------------------------------------------------------------------
	CALL	SET_CGA_XLT_TAB 	; Set up colors in the translation	
					;  table, NOTE: The background color	
					;   will not be set properly since the	
					;    PS/2 BIOS does not update memory	
					;     location 40:66 with the value	
					;      of the background color as CGA	
					;	does for modes 4 and 5. However 
					;	 40:66 holds the current palette
					;	  selected.			
;-------------------------------------------------------------------------------
; Adjust the background color for modes 4,5 or 6				
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,0	; Read the palette register number 0	
	CALL	GET_PALETTE_RGB 	;  this register points to the color	
					;   register that contains the RGB	
					;    values of the BACKGROUND color.	
	MOV	DI,0			; DI := Index in the translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
										
.WHEN  <CUR_MODE EQ 11H>							
;-------------------------------------------------------------------------------
;										
; Mode 11h (2 colors out of 256,000 colors)					
;										
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Get the background color:							
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,0	; Read the palette register number 0	
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
	MOV	DI,0			; DI := Index in translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
;-------------------------------------------------------------------------------
; Get the foreground color:							
;-------------------------------------------------------------------------------
	MOV	PAL_REGISTER_NB,7	; Read the palette register for the	
					;  FOREGROUND color (palette register 7)
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
	MOV	DI,1			; DI := Index in translation table	
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
.OTHERWISE									
;-------------------------------------------------------------------------------
;										
; The current mode is a 16 color mode						
;										
;-------------------------------------------------------------------------------
	XOR	DI,DI			; DI := Index in translation table	
	MOV	CX,16			; 16 colors to read and store		
	MOV	PAL_REGISTER_NB,0	; Palette register to read		
STORE_1_PS2_COLOR:								
	CALL	GET_PALETTE_RGB 	; Get the RGB values for this color	
;										
;-------Convert the RGB values to band mask or intensity and store in XLT_TAB:	
										
	CALL	RGB2XLT_TAB		; Store mapping in the translation table
	INC	DI			; Get next palette register number	
	INC	PAL_REGISTER_NB 	;					
	LOOP	STORE_1_PS2_COLOR	; Read it.				
.ENDSELECT									
										
	POP	DI								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
PAL_REGISTER_NB DB  ?			; Number of the palette register to read
SET_ROUNDUP_XLT_TAB ENDP							
										
PAGE										
;===============================================================================
;										
; GET_PALETTE_RGB:  ON THE PS/2 MODEL 50, 60 AND 80, GET THE RGB VALUES FOR A	
;		    PALETTE REGISTER BY READING THE CORRESPONDING COLOR REGISTER
;										
;-------------------------------------------------------------------------------
;										
;      INPUT:  PAL_REGISTER_NB = Palette register number			
;	       BH	       = Current page number				
;	       BL	       = Current paging mode				
;										
;      OUTPUT: RGB.R	       = The RGB values obtained from the color register
;	       RGB.G		 corresponding to the palette register specified
;	       RGB.B								
;										
;      CALLED BY: SET_ROUNDUP_XLT_TAB						
;										
;-------------------------------------------------------------------------------
GET_PALETTE_RGB PROC								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
	PUSH	SI								
										
	MOV	AL,BH			;  SI := Current page number		
	CBW				;					
	MOV	SI,AX			;					
;-------------------------------------------------------------------------------
;										
; Calculte the absolute number of the first Color Register for the current page:
; (calculated in SI)								
;										
;-------------------------------------------------------------------------------
.IF <BL EQ PAGING_MODE_64>		; If mode is 64 Color page		
.THEN					; then					
	MOV	CL,6			;    SI := Current page num * 64	
	SHL	SI,CL			;					
.ELSE					; else, Mode is 16 Color page		
	MOV	CL,4			;    SI := Current page num * 16	
	SHL	SI,CL			;					
.ENDIF										
										
;										
;-------Read the PALETTE REGISTER						
	MOV	BL,PAL_REGISTER_NB	; BL := Palette register to be read	
	MOV	AX,GET_P_REG_CALL	; Read palette register call		
	INT	10H			; Call BIOS,				
					;   BH := Color register index		
					;	  WITHIN the current page and is
					;	  either (0-15) or (0-63)	
					;  NOTE: SI = Absolute index (0-255) to 
					;  the first color register of the	
					;   current page and is a multiple of	
					;    either 16 or 64			
	MOV	BL,BH			; BX := Index within current color page 
	XOR	BH,BH			;					
										
;										
;-------Read the Color register:						
	OR	BX,SI			; BX := Index of Color register to read 
	MOV	AX,GET_C_REG_CALL	; Read the color register		
	INT	10H			; Call BIOS,				
	MOV	RGB.R,DH		; DH := Red value read			
	MOV	RGB.G,CH		; CH := Green value read		
	MOV	RGB.B,CL		; CL := Blue value read 		
										
	POP	SI								
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	RET									
GET_PALETTE_RGB ENDP								
PAGE										
;=======================================================================	
;										
; EGA_COL2RGB : CONVERT A COLOR FROM THE EGA TO RED GREEN BLUE VALUES		
;										
;-----------------------------------------------------------------------	
;										
;	INPUT: AL      = 00rgbRGB    ONE BYTE WHERE BIT:			
;										
;					r = 1/3 of Red component		
;					g = 1/3 of Green component		
;					b = 1/3 of Blue component		
;					R = 2/3 of Red component		
;					G = 2/3 of Green component		
;					B = 3/3 of Blue component		
;										
;										
;	OUTPUT: RGB.R	    = RED   component (0-63)				
;		RGB.G	    = GREEN component (0-63)				
;		RGB.B	    = BLUE  component (0-63)				
;										
;	CALLED BY: SET_UP_EGA_XLT_TABLE 					
;										
;-----------------------------------------------------------------------	
;										
; DESCRIPTION: Sums up the values for each color component.			
; "2/3 of RED" means that the red gun in the display attached to the EGA        
; is firing at 2/3 of full intensity.						
;										
; Since the color intensities range from 0 to 63, "1/3" means an                
; intensity of: 								
;		 1/3 * 63 = 21							
;										
; LOGIC:									
;										
; Get the red component 							
; Get the green component							
; Get the blue component							
;										
EGA_COL2RGB PROC NEAR								
;										
;-------Get the RED component	(bit 5 and 2)					
;										
;-------Check bit 2								
	MOV	RGB.R,0 							
	TEST	AL,100B 		; "R" is on ?                           
	JZ	CHECK_BIT_5		; No, check "r"                         
	ADD	RGB.R,TWO_THIRD 	; Yes, add 2/3 RED			
CHECK_BIT_5:									
	TEST	AL,100000B		; "r" is on ?                           
	JZ	CHECK_BIT_1		; No, check Green			
	ADD	RGB.R,ONE_THIRD 	; Yes, add 1/3 RED			
;										
;-------Get the GREEN component (bit 4 and 1)					
;										
CHECK_BIT_1:									
	MOV	RGB.G,0 							
	TEST	AL,10B			; "G" is on ?                           
	JZ	CHECK_BIT_4		; No, check "g"                         
	ADD	RGB.G,TWO_THIRD 	; Yes, add 2/3 GREEN			
CHECK_BIT_4:									
	TEST	AL,10000B		; "g" is on ?                           
	JZ	CHECK_BIT_0		; No, check for Blue			
	ADD	RGB.G,ONE_THIRD 	; Yes, add 1/3 GREEN			
;										
;-------Get the BLUE component (bit 3 and 0)					
;										
CHECK_BIT_0:									
	MOV	RGB.B,0 							
	TEST	AL,1B			; "B" is on ?                           
	JZ	CHECK_BIT_3		; No, check "b"                         
	ADD	RGB.B,TWO_THIRD 	; Yes, add 2/3 BLUE			
CHECK_BIT_3:									
	TEST	AL,1000B		; "b" is on ?                           
	JZ	EGA_COL2RGB_RETURN	; No, return				
	ADD	RGB.B,ONE_THIRD 	; Yes, add 1/3 BLUE			
EGA_COL2RGB_RETURN:								
	RET									
EGA_COL2RGB ENDP								
										
PAGE										
;===============================================================================
;										
; RGB2INT : MAP RED GREEN BLUE VALUES TO AN INTENSITY.				
;										
;-------------------------------------------------------------------------------
;										
;	INPUT:	RGB.R		= A RED value (0-63)				
;		RGB.G		= A GREEN value (0-63)				
;		RGB.B		= A BLUE value (0-63)				
;		DARKADJUST_VALUE= THE DARKNESS VALUE (In shared data area).	
;		SWITCHES	= Command line switches 			
;										
;	OUTPUT: AL  = THE INTENSITY  (0-63)  NOTE: 0  = BLACK			
;						   63 = BRIGHT WHITE		
;										
;	WARNING: AH IS LOST							
;										
;-------------------------------------------------------------------------------
;										
; DESCRIPTION: When the RGB values for a pixel are at their maximum		
; value, what we obtain is a bright white pixel on the screen; this is		
; the brightest color achievable and therefore, its intensity is 63.		
;										
; When no color gun is firing on the display: RGB values are 0,0,0 this 	
; is no color at all and therefore maps to intensity 0. 			
;										
; For intermediate colors, experimentation has shown that the eye will		
; see blue as darker than red and red as darker than green.			
;										
; On a grey rainbow from 0 - 10  where 0 is black and 10 is white:		
;										
;     Blue  corresponds to a grey of intensity 1				
;     Red   corresponds to a grey of intensity 3				
;     Green corresponds to a grey of intensity 6				
;										
; Therefore, if we mix all 3 colors we obtain a grey of 			
; intensity 1 + 3 + 6 = 10 (i.e.,white).					
;										
;										
; LOGIC:									
;										
; Calculate the intensity							
;										
;   AL = (.6 * G) + (.3 * R) + (.1 * B) 					
;										
; Adjust Darkness								
;										
;   AL = AL + DARKADJUST_VALUE							
;										
RGB2INT PROC NEAR								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
										
	XOR	AX,AX			; AL := Current component intensity	
	XOR	BX,BX			; BX is used for calculations		
	XOR	DX,DX			; DL := Running sum for grey intensity	
										
;-------Process /R   (Reverse black and white)					
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW>  ; IF reverse is OFF			
.THEN					 ; THEN REVERSE BLACK AND WHITE:	
;-------Test if the color is BLACK						
       .IF     <RGB.R EQ BLACK_INT> AND ; If black				
       .IF     <RGB.G EQ BLACK_INT> AND ;					
       .IF     <RGB.B EQ BLACK_INT>	;					
       .THEN				; then, replace it with white		
	  MOV	  AL,WHITE_INT							
	  JMP	  SHORT RGB2INT_END						
       .ELSEIF <RGB.R EQ WHITE_INT> AND ; else if, high-intensity white 	
       .IF     <RGB.G EQ WHITE_INT> AND ;					
       .IF     <RGB.B EQ WHITE_INT>	;					
       .THEN				; then, replace it with black		
	  MOV	  AL,BLACK_INT							
	  JMP	  SHORT RGB2INT_END						
       .ELSEIF <RGB.R EQ TWO_THIRD> AND ; else if, white			
       .IF     <RGB.G EQ TWO_THIRD> AND ;					
       .IF     <RGB.B EQ TWO_THIRD>	;					
       .THEN				; then, replace it with black		
	  MOV	  AL,BLACK_INT							
	  JMP	  SHORT RGB2INT_END						
       .ENDIF									
.ENDIF										
										
;-------Calculate Green component						
	MOV	AL,RGB.G		; AL := Green component 		
	MOV	BH,6			;					
	MUL	BH			; AX := Green * 6			
	MOV	BH,10			;					
	DIV	BH			; AL := (GREEN * 6) /  10		
	ADD	DL,AL			; DL := Cumulative intensity		
	MOV	CH,AH			; CH := Cumulative remainder		
										
;-------Calculate Red component 						
	MOV	AL,RGB.R		; AL := Red component			
	MOV	BH,3			;					
	MUL	BH			; AX := Red * 3 			
	MOV	BH,10			;					
	DIV	BH			; AL := (RED * 3) /  10 		
	ADD	DL,AL			; DL := Cumulative intensity		
	ADD	CH,AH			; CH := Cumulative remainder		
										
;-------Calculate Blue component						
	MOV	AL,RGB.B		; AX := Blue component			
	XOR	AH,AH			;					
	DIV	BH			; AL := BLUE / 10			
	ADD	DL,AL			; DL := Cumulative intensity		
	ADD	CH,AH			; CH := Cumulative remainder		
										
;-------Adjust intensity with cumulative remainder				
	XOR	AX,AX								
	MOV	AL,CH			; AX := Cumulative remainder		
	MOV	BH,10			; BH := 10				
	DIV	BH			; AL := Total remainder / 10		
	ADD	DL,AL			; DL := Cumulative intensity		
       .IF <AH GT 4>			; If remainder > 4			
       .THEN				; Then, add 1				
	INC	DL			;  to the intensity			
       .ENDIF									
										
;-------Adjust darkness 							
	ADD	DL,DS:[BP].DARKADJUST_VALUE					
										
;-------Return result								
	MOV	AL,DL			; AL := sum of R,G,B intensities	
										
RGB2INT_END:									
	POP	DX								
	POP	CX								
	POP	BX								
	RET									
RGB2INT ENDP									
										
PAGE										
;============================================================================== 
;										
; RGB2BAND: MAP RED GREEN BLUE VALUES TO A "SELECT COLOR BAND" MASK FOR         
;	    THE COLOR PRINTER.							
;										
;------------------------------------------------------------------------------ 
;										
;	INPUT:	RGB.R		= A RED value (0-63)				
;		RGB.G		= A GREEN value (0-63)				
;		RGB.B		= A BLUE value (0-63)				
;		BP		= Offset of the Shared Data Area.		
;										
;	OUTPUT: AL = The Band Mask, one byte where:				
;										
;				  bit 0 = Color Band 1 is needed		
;				  bit 1 = Color Band 2 is needed		
;				  bit 2 = Color Band 3 is needed		
;				  bit 3 = Color Band 4 is needed		
;										
;										
;	CALLED BY: SET_CGA_XLT_TAB						
;		   SET_EGA_XLT_TAB						
;		   SET_ROUNDUP_XLT_TAB						
;		   SET_MODE_13H_XLT_TAB 					
;		   SET_MODE_F_XLT_TAB						
;										
;------------------------------------------------------------------------------ 
;										
; NOTES: The RGB values in input describe a color from the screen.		
; Up to 256K different colors can be described with these RGB values.		
;										
; On the color printer, the print ribbon is composed of 4 color bands,		
; each of a different color.  By overlapping these 4 bands when 		
; printing, more colors can be obtained.  However, the number of colors 	
; that can be achieved by overlapping print bands is very limited (4 or 	
; 8 colors).									
;										
; THIS MODULE SELECT THE PRINTER COLOR THAT IS THE CLOSEST TO THE		
; DESIRED SCREEN COLOR. 							
;										
; The Band Mask specifies which color bands have to be overlapped to		
; obtain a color on the printer.						
;										
;										
; DESCRIPTION: Go through the list of printer colors in the SHARED DATA 	
; AREA, for each of these colors, compare its RGB values with those in		
; input.									
; Get the BAND_MASK of the closest printer color.				
;										
; LOGIC:									
;										
; Locate the printer colors info structure in the shared data area:		
; COLORPRINT_PTR := BP + COLORPRINT_PTR 					
;										
; Get the number of printer colors from the COLORPRINT info in the Shared	
; data area:									
; Number of colors  := COLORPRINT_PTR.NUM_PRT_COLOR				
;										
; CURRENT_COLOR_PTR : First record in the COLORPRINT info structure		
; BEST_CHOICE := CURRENT_RECORD_PTR.BAND_MASK					
; MIN_DIFF    := Maximum positive value 					
;										
; FOR each printer color:							
;   CUR_DIFF	:= 0								
; (* Calculate the geometric distance between the RGB values from the *)	
; (* input and those of the printer color.			      *)	
;   Red difference   := (R - CURRENT_COLOR_PTR.RED)				
;   Red difference   := Red difference * Red difference 			
;   CUR_DIFF	     := CUR_DIFF + Red difference				
;										
;   Green difference := (G - CURRENT_COLOR_PTR.GREEN)				
;   Green difference := Green difference * Green difference			
;   CUR_DIFF	     := CUR_DIFF + Green difference				
;										
;   Blue difference  := (B - CURRENT_COLOR_PTR.BLUE)				
;   Blue difference  := Blue difference  * Blue difference			
;   CUR_DIFF	     := CUR_DIFF + Blue difference				
;										
;   IF CUR_DIFF < MIN_DIFF							
;   THEN BEGIN									
;	 MIN_DIFF	:=  CUR_DIFF						
;	 BEST_CHOICE	:=  printer color.BAND_MASK				
;	 END									
;										
;   CURRENT_COLOR_PTR := Offset of next color					
; END (For each printer color)							
;										
; Return BEST_CHOICE								
;										
;										
RGB2BAND PROC NEAR								
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	DX								
										
;-------Process /R   (Reverse black and white)					
.IF <BIT DS:[BP].SWITCHES Z REVERSE_SW>  ; IF reverse is OFF			
.THEN					 ; THEN REVERSE BLACK AND WHITE:	
;------------------------------------------------------------------------------ 
;										
; REVERSE BLACK AND WHITE:							
;										
;------------------------------------------------------------------------------ 
;-------Test if the color is BLACK						
       .IF     <RGB.R EQ BLACK_INT> AND ; If black				
       .IF     <RGB.G EQ BLACK_INT> AND ;					
       .IF     <RGB.B EQ BLACK_INT>	;					
       .THEN				; then, replace it with the		
	  MOV	  BEST_CHOICE,0 	;	band mask for white		
	  JMP	  RGB2BAND_END		;	return this band mask		
       .ELSEIF <RGB.R EQ WHITE_INT> AND ; else if, high-intensity white 	
       .IF     <RGB.G EQ WHITE_INT> AND ;					
       .IF     <RGB.B EQ WHITE_INT>	;					
       .THEN				; then, replace it with the		
	  MOV	  RGB.R,BLACK_INT	;	RGB values of black		
	  MOV	  RGB.G,BLACK_INT						
	  MOV	  RGB.B,BLACK_INT						
       .ELSEIF <RGB.R EQ TWO_THIRD> AND ; else if, white			
       .IF     <RGB.G EQ TWO_THIRD> AND ;					
       .IF     <RGB.B EQ TWO_THIRD>	;					
       .THEN				; then, replace it with the		
	  MOV	  RGB.R,BLACK_INT	;	RGB values of black		
	  MOV	  RGB.G,BLACK_INT						
	  MOV	  RGB.B,BLACK_INT						
       .ENDIF									
.ENDIF										
;------------------------------------------------------------------------------ 
;										
; CALCULATE THE GEOMETRIC DISTANCE BETWEEN THE COLORS OF THE PIXEL AND THOSE OF 
; THE PRINTER:									
;										
;------------------------------------------------------------------------------ 
	MOV	BX,DS:[BP].COLORPRINT_PTR	; BX := OFFSET of COLORPRINT	
	ADD	BX,BP								
	MOV	MIN_DIFF,7FFFh			; No match yet, minimum diff.	
						;  is maximum POSITIVE value.	
	XOR	CX,CX								
	MOV	CL,DS:[BP].NUM_PRT_COLOR	; CX := Number of print colors	
										
										
INSPECT_1_PRINT_COLOR:								
	MOV	CUR_DIFF,0			; Current difference := 0	
;------------------------------------------------------------------------------ 
;	Calculate the Red difference:						
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.R							
	SUB	AL,[BX].RED							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Red diff.		
										
;------------------------------------------------------------------------------ 
;	Calculate the Green difference: 					
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.G							
	SUB	AL,[BX].GREEN							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Green diff.	
										
;------------------------------------------------------------------------------ 
;	Calculate the Blue difference:						
;------------------------------------------------------------------------------ 
	MOV	AL,RGB.B							
	SUB	AL,[BX].BLUE							
;-------Elevate at the power of two						
	MOV	DL,AL				; DX := Red difference		
	IMUL	DL				; AX := Red diff. square	
	ADD	CUR_DIFF,AX			; CURR_DIF + Blue diff. 	
										
;------------------------------------------------------------------------------ 
;	Check how close is this print color to the screen color:		
;------------------------------------------------------------------------------ 
	MOV	AX,CUR_DIFF		; If this color is better than what we	
       .IF <AX L MIN_DIFF>		;  had before.				
       .THEN				;					
	  MOV	  MIN_DIFF,AX		; then, new minimum distance;		
	  MOV	  AL,[BX].SELECT_MASK	;	get its band mask.		
	  MOV	  BEST_CHOICE,AL	;					
       .ENDIF				;					
										
;------------------------------------------------------------------------------ 
;	Get offset of next COLORPRINT info record:				
;------------------------------------------------------------------------------ 
	ADD	BX,SIZE COLORPRINT_STR						
	LOOP	INSPECT_1_PRINT_COLOR						
										
;------------------------------------------------------------------------------ 
;	BEST_CHOICE contains the print color with the closest RGB values	
;------------------------------------------------------------------------------ 
RGB2BAND_END:									
	POP	DX								
	POP	CX								
	POP	BX								
	POP	AX								
	MOV	AL,BEST_CHOICE							
	RET									
BEST_CHOICE	DB	?							
MIN_DIFF	DW	?							
CUR_DIFF	DW	?							
RGB2BAND ENDP									
CODE	ENDS									
	END									

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grload3.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I restructured the procedure PARSE_GRAPHICS so it can handle 
;**                 the keywords LOWCOUNT, HIGHCOUNT, the new keywords COUNT and 
;**                 DATA, and the escape sequence bytes in any order.
;**  
;**  BUG NOTES:     The   following   bug   was  fixed   for   the   pre-release  
;**                 version Q.01.02.
;**  
;**  BUG (mda003)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints  a CR & LF after  each  scan line unless it  is 
;**            loaded twice.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD3.ASM - PARSE_GRAPHICS
;**                                GRCOMMON.ASM - END_PRT_LINE
;**                                GRSHAR.STR - N/A
;**  
;**  CAUSES:   The local variables LOWCOUNT_FOUND, HIGHCOUNT_FOUND CR_FOUND  and 
;**            LF_FOUND used for loading, were incorrectly being used as  global 
;**            variables during printing.
;**  
;**  FIX:      Created  a new variable Printer_Needs_CR_LF in GRSHAR.STR,  which 
;**            is  used  to  determine  in GRCOMMON.ASM  if  it's  necessary  to 
;**            manually  send  a  CR  & LF to the printer  at  print  time.  The 
;**            variable  is  set at load time in GRLOAD3.ASM, if  the  variables 
;**            Data_Found and Build_State are set. 
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD3.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules #2 	;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                    
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;;					;AN000;
	INCLUDE GRLOAD.EXT	       ;;					;AN000;
	INCLUDE GRLOAD2.EXT	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRPATTRN.STR	       ;;					;AN000;
	INCLUDE GRPATTRN.EXT	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC PARSE_GRAPHICS	       ;;					;AN000;
   PUBLIC PARSE_COLORSELECT	       ;;					;AN000;
   PUBLIC PARSE_COLORPRINT	       ;;					;AN000;
   PUBLIC PARSE_DARKADJUST	       ;;					;AN000;
   PUBLIC LIMIT 		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
RESULT_BUFFER	LABEL BYTE	       ;; general purpose result buffer 	;AN000;
		    DB	 ?	       ;; operand type				;AN000;
RESULT_TAG	    DB	 0	       ;; operand tag				;AN000;
		    DW	 ?	       ;; pointer to synonym/keyword		;AN000;
RESULT_VAL	    DB	 ?,?,?,?       ;; returned numeric value		;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_GRAPHICS								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
GRAPHICS_PARSE_PARMS  LABEL WORD       ;; Parser control blocks 		;AN000;
	    DW	 GRAPHICS_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
GRAPHICS_P   DB   0,1		       ;; Required, max parms			;AN000;
	    DW	 GRAPHICS_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
GRAPHICS_P1 DW	 0A000H 	       ;; Numeric OR string			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 GRAPHICS_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
GRAPHICS_P1V	DB   3		       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
	    DB	 0		       ;; 0 - no actual numerics		;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Changed the # of string values from 2 to 4 because of the new
;               keywords COUNT and DATA.
	    DB	 4		       ;; 4 STRING VALUES			;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
	    DB	 2		       ;; tag					;AN000;
	    DW	 LOWCOUNT_STR	       ;; ptr					;AN000;
	    DB	 3		       ;; tag					;AN000;
	    DW	 HIGHCOUNT_STR	       ;; ptr					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Added the following valid string values because of the new
;               keywords COUNT and DATA.
            DB  4                       ; tag
            DW  COUNT_STR               ; ptr
            DB  5                       ; tag
            DW  DATA_STR                ; ptr

COUNT_STR     DB  'COUNT',0             ;
DATA_STR      DB  'DATA',0              ;
;
;/\  ~~mda(001) -----------------------------------------------------------------------
				       ;;					;AN000;
lowcount_str  db  'LOWCOUNT',0         ;;                                       ;AN000;
HIGHcount_str  db  'HIGHCOUNT',0       ;;                                       ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
LOWCOUNT_FOUND	 DB  NO 	       ;;					;AN000;
HIGHCOUNT_FOUND  DB  NO 	       ;;				  	;AN000;

;\/  ~~mda(001) -----------------------------------------------------------------------
;                Added the following so know when get COUNT and DATA.
COUNT_FOUND      DB  NO                 ;
DATA_FOUND       DB  NO                 ;
;
;/\  ~~mda(001) -----------------------------------------------------------------------
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_GRAPHICS	PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,GR		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
	
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     MOV  DI,BLOCK_START	       ;;					;AN000;
     MOV  AX,BLOCK_END		       ;;				;AN000;
     MOV  [BP+DI].GRAPHICS_ESC_PTR,AX  ;; Set pointer to GRAPHICS seq		;AN000;
     MOV  [BP+DI].NUM_GRAPHICS_ESC,0   ;; Init sequence size			;AN000;
     MOV  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA,0   ;;~~mda(001) Init sequence size			;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  LOWCOUNT_FOUND,NO	       ;; Flags to indicate whether the LOW	;AN000;
  MOV  HIGHCOUNT_FOUND,NO	       ;;  and HIGHCOUNT parms were found	;AN000;
  MOV  COUNT_FOUND,NO                  ;;~~mda(001) Flags to indicate the COUNT 
  MOV  DATA_FOUND,NO 		       ;;~~mda(001) and DATA parms were found					;AN000;
                                       ;;
  OR   STMTS_DONE,GR		       ;; Indicate GRAPHICS found		;AN000;
				       ;;					;AN000;
  MOV  AX,PREV_STMT		       ;; Terminate any preceeding groups	;AN000;
  OR   GROUPS_DONE,AX		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET GRAPHICS_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
				       ;;					;AN000;
   .IF <AX EQ 0> NEAR		       ;; If PARM is valid			;AN000;
	MOV  BL,RESULT_TAG	       ;;					;AN000;
       .SELECT			       ;;					;AN000;
       .WHEN <BL EQ 1>		       ;; Escape byte				;AN000;
	  PUSH AX		       ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               Changed the 1 to a 2 in the following instruction cause
;               need an extra byte in the sequence to hold the tag that
;               corresponds to esc seq., so during printing we know what to
;               send and in what order.

	  MOV	AX,2		       ;; Add a byte to the sequence		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               During printing we need to know how many things (things being
;               esc #s, count, lowcount, or highcount) come before
;               the data and how many things go after the data, - not just
;               how many bytes are in the sequence.  So check if dealing with 
;               things that come before the data.

            .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	        INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.       	
            .ELSE                       ; Bump # of things in seq. that
                INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	    .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------
	     MOV  DI,BLOCK_END	       ;;					;AN000;
             MOV  BYTE PTR [BP+DI-2],ESC_NUM_CODE;
	     MOV  AL,RESULT_VAL        ;; Get esc byte from result buffer	;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
       .WHEN <BL EQ 2>		       ;; LOWCOUNT				;AN000;
	   CMP LOWCOUNT_FOUND,NO       ;; ~~mda(001) If no LOWCOUNT or COUNT   ;AN000;
           JNE LOWCNT_ERROR             ; ~~mda(001) then proceed.  Not using
           CMP COUNT_FOUND,NO           ; ~~mda(001) .IF macro cause jump is 
           JNE LOWCNT_ERROR             ; ~~mda(001) out of range
	       MOV   LOWCOUNT_FOUND,YES ;;					;AN000;
	       PUSH AX		       ;;					;AN000;
	       MOV   AX,2	       ;; ~~mda(001) Changed a 1 to a 2 cause	;AN000;
                                        ; ~~mda(001) need extra byte for tag
	       CALL  GROW_SHARED_DATA  ;; Update block end			;AN000;
	      .IF <BUILD_STATE EQ YES> ;;					;AN000;
		  PUSH DI	       ;;					;AN000;
		  MOV  DI,BLOCK_START  ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
                 .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
        	     INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.      
                 .ELSE                       ; Bump # of things in seq. that
                     INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	         .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------
	
		  MOV  DI,BLOCK_END    ;; ~~mda(001) Put BLOCK_END in DI not AX.;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
;               No longer need following 3 instruction cause will have COUNT
;               at a known fixed location in the SHARED_DATA_AREA.
;
;;		  DEC  AX	       ;; Save pointer to low byte		;AN000;
;;		  MOV  [BP+DI].LOW_BYT_COUNT_PTR,AX				;AN000;
;;		  MOV  DI,AX	       ;;			 		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
                  MOV  BYTE PTR [BP+DI-2],LOWCOUNT_CODE;
		  MOV  BYTE PTR[BP+DI-1],0 ;; ~~mda(001) Added the -1. Store 0 in ;AN000;
		  POP  DI	       ;;		 in place of count      ;AN000;
	      .ENDIF		       ;;					;AN000;
	       POP  AX		       ;;					;AN000;
               JMP  CK_NEXT_PARM        ;~~mda(001) Added jump since can't use .IF macro
 LOWCNT_ERROR:  		       ;;~~mda(001) Added label since can't use .IF macro 
	       OR  STMT_ERROR,INVALID  ;; Duplicate LOWCOUNT parms              ;AN000;
	       MOV  PARSE_ERROR,YES    ;;~~mda(001) or combo of LOWCOUNT & COUNT;AN000;
	       MOV  BUILD_STATE,NO     ;;					;AN000;
       .WHEN <BL EQ 3>		       ;; HIGHCOUNT				;AN000;
	   CMP HIGHCOUNT_FOUND,NO       ;; ~~mda(001) If no HIGHCOUNT or COUNT   ;AN000;
           JNE HIGHCNT_ERROR             ; ~~mda(001) then proceed.  Not using
           CMP COUNT_FOUND,NO           ;  ~~mda(001) .IF macro cause jump is 
           JNE HIGHCNT_ERROR             ; ~~mda(001) out of range
	      MOV   HIGHCOUNT_FOUND,YES ;;					;AN000;
	      PUSH AX		       ;;					;AN000;
	      MOV   AX,2	       ;; ~~mda(001) Changed a 1 to a 2 cause	;AN000;
                                        ; ~~mda(001) need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			;AN000;
	     .IF <BUILD_STATE EQ YES>  ;;					;AN000;
		 PUSH DI	       ;;					;AN000;
		 MOV  DI,BLOCK_START   ;;					;AN000;
;\/  ~~mda(001) -----------------------------------------------------------------------
                .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	            INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.    
                .ELSE                       ; Bump # of things in seq. that
                    INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	        .ENDIF
;/\  ~~mda(001) -----------------------------------------------------------------------

        	 MOV  DI,BLOCK_END    ;; ~~mda(001) Put BLOCK_END in DI not AX. ;AN000;	
;\/  ~~mda(001) -----------------------------------------------------------------------
;               No longer need following 3 instructions cause will have COUNT
;               at a known fixed location in the SHARED_DATA_AREA.
;
;;		 DEC  AX	       ;; Save pointer to low byte		;AN000;
;;		 MOV  [BP+DI].LOW_BYT_COUNT_PTR,AX				;AN000;
;;	         MOV  DI,AX	       ;;			 		;AN000;
;/\  ~~mda(001) -----------------------------------------------------------------------
                 MOV  BYTE PTR [BP+DI-2],HIGHCOUNT_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; ~~mda(001) Added the -1. Store 0 in  ;AN000;
		 POP  DI	       ;; place of count					;AN000;
	     .ENDIF		       ;;					;AN000;
	      POP  AX		       ;;					;AN000;
              JMP  CK_NEXT_PARM        ;~~mda(001) Added jump since can't use .IF macro
	
 HIGHCNT_ERROR: 		       ;;~~mda(001) Added label cause can't use .IF macro.					;AN000;
	       OR  STMT_ERROR,INVALID  ;; Duplicate HIGHCOUNT parms	       
	       MOV  PARSE_ERROR,YES    ;; ~~mda(001) or combo of HIGHCOUNT and  ;AN000;
	       MOV  BUILD_STATE,NO     ;; ~~mda(001) COUNT parms                ;AN000;

;\/  ~~mda(001) -----------------------------------------------------------------------
;               Added the following two cases for when have COUNT or DATA on
;               GRAPHICS line.
 
       .WHEN <BL EQ 4>		       ;; COUNT				        
          .IF <COUNT_FOUND EQ NO> AND   ; If haven't found a type of count
	  .IF <LOWCOUNT_FOUND EQ NO> AND;;then proceed.                         
          .IF <HIGHCOUNT_FOUND EQ NO>   ; 
                                        ; 
	      MOV   COUNT_FOUND,YES    ;;					
	      PUSH AX		       ;;					
	      MOV   AX,2	       ;; Add 2 bytes to the seq. cause         
                                        ; need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			
	     .IF <BUILD_STATE EQ YES>  ;;					
		 PUSH DI	       ;;					
		 MOV  DI,BLOCK_START   ;;					
                .IF <DATA_FOUND EQ NO>      ; Bump # of things in seq. that 
	            INC  [BP+DI].NUM_GRAPHICS_ESC ;; come before data.       	
                .ELSE                       ; Bump # of things in seq. that
                    INC  [BP+DI].NUM_GRAPHICS_ESC_AFTER_DATA  ; go after data
	        .ENDIF
        	 MOV  DI,BLOCK_END    ;;                                        	
                 MOV  BYTE PTR [BP+DI-2],COUNT_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; Store 0 in place of count          
		 POP  DI	       ;; 					
	     .ENDIF		       ;;					
	      POP  AX		       ;;					
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate COUNT parms or combo of     
	       MOV  PARSE_ERROR,YES    ;; COUNT, LOWCOUNT or HIGHCOUNT parms    
	       MOV  BUILD_STATE,NO     ;;                                       
	  .ENDIF		       ;;					

       .WHEN <BL EQ 5>		       ;; DATA				        
          .IF <DATA_FOUND EQ NO>        ; If haven't found data then proceed
	      MOV   DATA_FOUND,YES     ;;					
	      PUSH AX		       ;;					
	      MOV   AX,2	       ;; Add 2 bytes to the seq. cause         
                                        ; need extra byte for tag
	      CALL  GROW_SHARED_DATA   ;; Update block end			
	     .IF <BUILD_STATE EQ YES>  ;;					
                 PUSH DI               ;;
        	 MOV  DI,BLOCK_END    ;;                                        
                 MOV  BYTE PTR [BP+DI-2],DATA_CODE;
		 MOV  BYTE PTR[BP+DI-1],0 ;; Store 0 in place of data           
		 POP  DI	       ;; 					
	     .ENDIF		       ;;					
	      POP  AX		       ;;					
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate DATA parms                  
	       MOV  PARSE_ERROR,YES    ;;                                       
	       MOV  BUILD_STATE,NO     ;;                                       
	  .ENDIF		       ;;					
;/\  ~~mda(001) -----------------------------------------------------------------------

       .ENDSELECT		       ;;					;AN000;
   .ELSE NEAR			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;

CK_NEXT_PARM:                           ;~~mda(001) Added label since can't use
                                        ;~~mda(001) .IF macro.
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;

;\/  ~~mda(003) -----------------------------------------------------------------------
 .IF  <DATA_FOUND EQ NO>               ;; We have a printer that requires a					;AN000;
      .IF <BUILD_STATE EQ YES>         ;;
           MOV  [BP].PRINTER_NEEDS_CR_LF,YES; CR, LF to be sent to it
      .ENDIF                           ;;
 .ENDIF                                ;;
;/\  ~~mda(003) -----------------------------------------------------------------------

				       ;;					;AN000;
 .IF  <LOWCOUNT_FOUND EQ NO> OR        ;;					;AN000;
 .IF  <HIGHCOUNT_FOUND EQ NO>	       ;; Missing LOWCOUNT/HIGHCOUNT parms	;AN000;
      .IF  <COUNT_FOUND EQ NO>         ;; ~~mda(001) or missing COUNT parm
           OR   STMT_ERROR,INVALID	       ;;					;AN000;
           MOV  PARSE_ERROR,YES	       ;;					;AN000;
           MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_GRAPHICS	ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_COLORSELECT								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COLORSELECT_PARSE_PARMS  LABEL WORD    ;; Parser control blocks 		;AN000;
	    DW	 COLORSELECT_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COLORSELECT_P	   LABEL BYTE	       ;;					;AN000;
CS_NUM_REQ    DB   1,1		       ;; Required, max parms			;AN000;
COLORSELECT_PARM   LABEL  WORD	       ;;					;AN000;
CS_POSITIONAL DW   ?		       ;; Pointer to our positional		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
COLORSELECT_P0	DW   2000H	       ;; sTRING - display type 		;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORSELECT_P0V       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORSELECT_P0V    DB	0		   ;; # of value lists			;AN000;
;	    DB	 0		       ;; # of range numerics			;AN000;
;	    DB	 0		       ;; # of discrete numerics		;AN000;
;	    DB	 1		       ;; # of strings				;AN000;
;	    DB	 1		       ;; tag					;AN000;
;COLORSELECT_P0V1 DW   ?		   ;; string				;AN000;
				       ;;					;AN000;
COLORSELECT_P1	DW   8001H		  ;; Numeric - escape sequence byte	;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORSELECT_P1V	  ;; Value list 			;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORSELECT_P1V    DB	1		  ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 1,255		       ;; range 1..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
SEQ_LENGTH_PTR	DW   0		       ;; Number of colorselect statements	;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORSELECT  PROC 	       ;;					;AN000;
				      ;;					;AN000;
  MOV  CUR_STMT,COLS		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND DISP+COLP>    ;; DISDPLAYMODE and COLORPRINT  stmts	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  should NOT have been processed	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND COLS>        ;; Check for a previous group of 	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  COLORSELECTS within this PTD 	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND COLS>        ;; If first COLORSELECT...		;AN000;
      MOV  NUM_BANDS,0		       ;; Init number of COLORSELECT bands	;AN000;
     .IF <BUILD_STATE EQ YES>	       ;; Update count and pointer in the	;AN000;
	 MOV  AX,BLOCK_END	       ;;  Shared Data Area header		;AN000;
	 MOV  [BP].COLORSELECT_PTR,AX  ;; Set pointer to COLORSELECT info	;AN000;
	 MOV  [BP].NUM_PRT_BANDS,0     ;; Init NUMBER OF COLORSELECTS		;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,COLS		       ;; Indicate found			;AN000;
 .IF <PREV_STMT NE COLS> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for COLORSELECT		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV	AX,1			       ;; Make room for sequence length field	;AN000;
  CALL	GROW_SHARED_DATA	       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     INC  [BP].NUM_PRT_BANDS	       ;; Inc number of selects 		;AN000;
     MOV  DI,BLOCK_END		       ;;					;AN000;
     MOV  BYTE PTR [BP+DI-1],0	       ;; Init sequence length field		;AN000;
     LEA  AX,[DI-1]		       ;;					;AN000;
     MOV  SEQ_LENGTH_PTR,AX	       ;; Save pointer to length of sequence	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET COLORSELECT_PARSE_PARMS  ;; parse parms			;AN000;
  MOV  CS_NUM_REQ,1		       ;; Change to 1 required parameters	;AN000;
  MOV  AX,OFFSET COLORSELECT_P0        ;; Point to control block for the band	;AN000;
  MOV  CS_POSITIONAL,AX 	       ;;  ID.	(Dealing with only 1 positional ;AN000;
				       ;;  parameter at a time was the only way ;AN000;
				       ;;   I could get SYSPARSE to handle	;AN000;
				       ;;    the COLORSELECT syntax!)		;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the band ID			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
     RET			       ;;  statement.				;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  PUSH	ES			       ;; We got a band id........		;AN000;
  PUSH	DI			       ;;					;AN000;
				       ;;					;AN000;
  LES	DI,DWORD PTR RESULT_VAL        ;; Get pointer to the parsed band id	;AN000;
 .IF <<BYTE PTR ES:[DI+1]> NE 0>       ;; Make sure the band id is only 	;AN000;
     OR  STMT_ERROR,INVALID	       ;;  one byte long			;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  BL,NUM_BANDS		       ;;					;AN000;
  XOR  BH,BH			       ;;					;AN000;
 .IF <BX EQ MAX_BANDS> THEN	       ;; Watch out for too many COLORSELECTs	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     SHL  BX,1			       ;; calc index to store band in value list;AN000;
     MOV  AL,ES:[DI]		       ;; get BAND ID FROM PARSEr		;AN000;
     MOV  BAND_VAL_LIST[BX],AL	       ;;					;AN000;
     INC  NUM_BANDS		       ;; bump number of bands			;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  POP  DI			       ;;					;AN000;
  POP  ES			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,OFFSET COLORSELECT_P1        ;; Switch to numeric positional parm!!!	;AN000;
  MOV  CS_POSITIONAL,AX 	       ;;					;AN000;
  MOV  CS_NUM_REQ,0		       ;; Change to 0 required parameters	;AN000;
  XOR  DX,DX			       ;; PARSE the sequence of escape bytes	;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,SEQ_LENGTH_PTR    ;;					;AN000;
	     INC  byte ptr [BP+DI]     ;; Bump number of bytes in sequence	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL        ;; Get esc byte from result buffer	;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORSELECT  ENDP 	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_COLORPRINT								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
COLORPRINT_PARSE_PARMS	LABEL WORD    ;; Parser control blocks			;AN000;
	    DW	 COLORPRINT_P	      ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
COLORPRINT_P	  LABEL BYTE	       ;;					;AN000;
	      DB   3,4		       ;; Required,MAX				;AN000;
	      DW   COLORPRINT_P0       ;; Numeric: Red value			;AN000;
	      DW   COLORPRINT_P0       ;; Green value				;AN000;
	      DW   COLORPRINT_P0       ;; Blue value				;AN000;
	      DW   COLORPRINT_P1       ;; Band ID ... REPEATING 		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
COLORPRINT_P0  DW   8000H	       ;; Numeric - RGB value			;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORPRINT_P0V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORPRINT_P0V	 DB   1 	       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,63		       ;; range 0..63				;AN000;
				       ;;					;AN000;
COLORPRINT_P1  DW   2001H	       ;; sTRING - Band ID			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 COLORPRINT_P1V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
COLORPRINT_P1V	  DB   3	       ;; # of value lists			;AN000;
	    DB	 0		       ;; 0 - no range numerics 		;AN000;
	    DB	 0		       ;; 0 - no actual numerics		;AN000;
NUM_BANDS   DB	 0		       ;; number of band values 		;AN000;
	    DB	 01H		       ;; tag: TAGS ARE BAND MASKS		;AN000;
	    DW	 BAND_PTR_1	       ;; ptr					;AN000;
	    DB	 02H		       ;; tag					;AN000;
	    DW	 BAND_PTR_2	       ;; ptr					;AN000;
	    DB	 04H		       ;; tag					;AN000;
	    DW	 BAND_PTR_3	       ;; ptr					;AN000;
	    DB	 08H		       ;; tag					;AN000;
	    DW	 BAND_PTR_4	       ;; ptr					;AN000;
	    DB	 10H		       ;; tag					;AN000;
	    DW	 BAND_PTR_5	       ;; ptr					;AN000;
	    DB	 20H		       ;; tag					;AN000;
	    DW	 BAND_PTR_6	       ;; ptr					;AN000;
	    DB	 40H		       ;; tag					;AN000;
	    DW	 BAND_PTR_7	       ;; ptr					;AN000;
	    DB	 80H		       ;; tag					;AN000;
	    DW	 BAND_PTR_8	       ;; ptr					;AN000;
				       ;;					;AN000;
MAX_BANDS   EQU  8		       ;;					;AN000;
				       ;;					;AN000;
BAND_VAL_LIST  LABEL BYTE	       ;;					;AN000;
BAND_PTR_1  DB	 ?,0		       ;;					;AN000;
BAND_PTR_2  DB	 ?,0		       ;;					;AN000;
BAND_PTR_3  DB	 ?,0		       ;;					;AN000;
BAND_PTR_4  DB	 ?,0		       ;;					;AN000;
BAND_PTR_5  DB	 ?,0		       ;;					;AN000;
BAND_PTR_6  DB	 ?,0		       ;;					;AN000;
BAND_PTR_7  DB	 ?,0		       ;;					;AN000;
BAND_PTR_8  DB	 ?,0		       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORPRINT  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,COLP		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND DISP>	       ;; DISPLAYMODE stmts			;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  should NOT have been processed	;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND COLP>        ;; Check for a previous group of 	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  COLORPRINTS within this PTD		;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_PRINTER_TYPE,COLOR	       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND COLP>        ;; If first COLORPRINT...		;AN000;
     .IF <BUILD_STATE EQ YES>	       ;; Update count and pointer in the	;AN000;
	 MOV  AX,BLOCK_END	       ;;  Shared Data Area header		;AN000;
	 MOV  [BP].COLORPRINT_PTR,AX   ;; Set pointer to COLORPRINT info	;AN000;
	 MOV  [BP].PRINTER_TYPE,COLOR  ;;					;AN000;
	 MOV  [BP].NUM_PRT_COLOR,0     ;; Init NUMBER OF COLORPRINTS		;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     INC  [BP].NUM_PRT_COLOR	       ;; Inc number of selects 		;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,COLP		       ;; Indicate found			;AN000;
 .IF <PREV_STMT NE COLP> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for COLORPRINT		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV	AX,BLOCK_END		       ;; Start a new block			;AN000;
  MOV	BLOCK_START,AX		       ;;					;AN000;
  MOV	AX,SIZE COLORPRINT_STR	       ;; Make room for COLORPRINT info 	;AN000;
  CALL	GROW_SHARED_DATA	       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET COLORPRINT_PARSE_PARMS  ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the RED value			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store RED value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].RED,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the GREEN value 		;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store GREEN value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].GREEN,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the BLUE value			;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 PUSH  DI		       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;; Store BLUE value in COLORPRINT info	;AN000;
	 MOV  [BP+DI].BLUE,AL	       ;;					;AN000;
	 POP  DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     PUSH  DI			       ;;					;AN000;
     MOV   DI,BLOCK_START	       ;;					;AN000;
     MOV   [BP+DI].SELECT_MASK,0       ;; Initialize band select mask		;AN000;
     POP   DI			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  XOR  DX,DX			       ;; For each band found "OR" the item     ;AN000;
 .REPEAT			       ;;  tag into the select mask		;AN000;
    MOV  CX,3			       ;; Avoid getting too many parms error	;AN000;
    CALL SYSPARSE		       ;;  from parser				;AN000;
   .IF <AX EQ 0>		       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	  PUSH	DI		       ;;					;AN000;
	  MOV	DI,BLOCK_START	       ;;					;AN000;
	  MOV	AL,RESULT_TAG	       ;;					;AN000;
	  OR	[BP+DI].SELECT_MASK,AL ;; OR the mask for this band into the	;AN000;
				       ;;  select mask for this color		;AN000;
	  POP	DI		       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_COLORPRINT  ENDP		       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_DARKADJUST								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
										;AN000;
DARKADJUST_PARSE_PARMS	LABEL WORD    ;; Parser control blocks			;AN000;
	    DW	 DARKADJUST_P	      ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
DARKADJUST_P	  LABEL BYTE	       ;;					;AN000;
	      DB   1,1		       ;; Required,MAX				;AN000;
	      DW   DARKADJUST_P0       ;; Numeric: adjust value 		;AN000;
	      DB   0		       ;; # Switches				;AN000;
	      DB   0		       ;; # keywords				;AN000;
				       ;;					;AN000;
DARKADJUST_P0  DW   4000H	       ;; Signed Numeric - adjust value 	;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 DARKADJUST_P0V        ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
DARKADJUST_P0V	 DB   1 	       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 -63,63 	       ;; range -63,63				;AN000;
;;;;***********************************;;					;AN000;
				       ;;					;AN000;
										;AN000;
PARSE_DARKADJUST  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,DARK		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;; PRINTER  statemnet must have been	;AN000;
     OR  STMT_ERROR,MISSING	       ;;  processed				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,DARK		       ;; Indicate found			;AN000;
				       ;; Terminate any preceeding groups	;AN000;
  MOV  AX,PREV_STMT		       ;;					;AN000;
  OR   GROUPS_DONE,AX		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET DARKADJUST_PARSE_PARMS  ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE the ADJUST VALUE		;AN000;
 .IF <AX NE 0>			       ;;					;AN000;
     OR  STMT_ERROR,INVALID	       ;;					;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  AL,RESULT_VAL	       ;;					;AN000;
	 MOV  [BP].DARKADJUST_VALUE,AL ;;					;AN000;
     .ENDIF			       ;;					;AN000;
      CALL SYSPARSE		       ;; CHECK FOR EXTRA PARMS 		;AN000;
     .IF <AX NE -1>		       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_DARKADJUST  ENDP		       ;;					;AN000;
										;AN000;
LIMIT	LABEL NEAR		       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grload2.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:   I  altered  the  procedure  PARSE_VERB  and  added  the  new 
;**                 procedure PARSE_DEFINE and made it public in order to handle 
;**                 the  new  statement DEFINE.  I also made  the  new  variable 
;**                 DATA_TYPE  have  the  default of DATA_COL,  so  the  default 
;**                 assumes  IBM type printers.  
;**  
;**  BUG NOTES:     Bug  mda002  was  completely fixed   for   the   pre-release  
;**                 version  Q.01.02,  whereas  bug mda005  was  only  partially 
;**                 fixed.   In  other  words,  part of bug  mda005  is  in  the 
;**                 released versions D.01.01 & D.01.02.
;**  
;**  BUG (mda002)
;**  ------------
;**  
;**  NAME:     GRAPHICS   prints garbage on PCL  printers  if IBM  printers  are 
;**            listed after HP printers  in the GRAPHICS profile.  
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD2.ASM - PARSE_PRINTER
;**                                GRLOAD2.ASM - PARSE_DEFINE
;**  
;**  CAUSES:   1)   In  the  procedure Parse_Define I was moving values  in  the 
;**                 variable  DATA_TYPE for every DEFINE statement,  instead  of 
;**                 just  for  the  DEFINE statement that  corresponded  to  the 
;**                 printer we were using.
;**  
;**            2)   In the procedure Parse_Printer I was resetting DATA_TYPE  to 
;**                 DATA_COL  if  BUILD_STATE  = YES, but I was doing  it  in  a 
;**                 section  of  code  where BUILD_STATE  would  never  be  YES.  
;**  
;**  FIXES:     1)  Made  a couple of changes in the procedure  Parse_Define  so 
;**                 that  values are moved into the variable DATA_TYPE just  for 
;**                 the  DEFINE  statement  that  corresponds  to  the   printer 
;**                 currently being used.
;**  
;**            2)   I  moved a section of code from the procedure  Parse_Printer 
;**                 to  the  end of the procedure, because this is where  it  is 
;**                 possible for BUILD_STATE to equal YES.  
;**  
;**  BUG (mda005)
;**  ------------
;**  
;**  NAME:     If  a  picture is printed using a 3,1 printbox, the  picture  has 
;**            blank lines throughout  the picture,  which has  the wrong aspect
;**            ratio. 
;**  
;**  FILES & PROCEDURES AFFECTED:  GRLOAD2.ASM - PARSE_PRINTBOX
;**  
;**  CAUSE:    The print buffer was being filled as follows,
;**  
;**                      --------------------------
;**                      | o  o  o  o  o  o  o  o |
;**                      --------------------------
;**                        |_____|  |  |_____|  |
;**                           |     |     |     |              
;**                           |     |     |     |
;**            FROM:       pixel 1  |  pixel 2  |
;**                                 |           |
;**                                 |___________|
;**                                       |
;**                                       |
;**                                       |
;**                               Always left blank
;**  
;**            instead of as follows,
;**  
;**                      --------------------------
;**                      | o  o  o  o  o  o  o  o |
;**                      --------------------------
;**                        |_____|  |_____|  |__|
;**                           |        |       |     
;**                           |        |       |
;**            FROM:       pixel 1  pixel 2  pixel 3
;**  
;**            Note  that  this not only resulted in a strange  picture,  but  a 
;**            picture with the incorrect aspect ratio.  Because in essence  the 
;**            picture  was printed indirectly with a 4,1 printbox  because  for 
;**            every pixel read four bits were sent to the printer.
;**  
;**  FIX:      Because  of time constraints it was decided to print the  picture 
;**            directly  with a 4,1 printbox.  So even though the picture  still 
;**            has the wrong aspect ratio, it at least does not have funny blank 
;**            lines throughout the entire picture.  This fix was implemented by 
;**            changing a 3,1 printbox to a 4,1 printbox.
;**  
;**  DOCUMENTATION NOTES:  This version of GRLOAD2.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Profile Load Modules #2 	;AN000;
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                   
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE' BYTE     ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;; Bring in external declarations	;AN000;
				       ;;  for transient command processing	;AN000;
	INCLUDE GRSHAR.STR	       ;;					;AN000;
	INCLUDE GRMSG.EQU	       ;;					;AN000;
	INCLUDE GRINST.EXT	       ;;					;AN000;
	INCLUDE GRLOAD.EXT	       ;;					;AN000;
	INCLUDE GRPARSE.EXT	       ;;					;AN000;
	INCLUDE GRPATTRN.STR	       ;;					;AN000;
	INCLUDE GRPATTRN.EXT	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
   PUBLIC PARSE_VERB		       ;;					;AN000;
   PUBLIC PARSE_PRINTER 	       ;;					;AN000;
; \/ ~~mda(001) ---------------------------------
;		Added procedure PARSE_DEFINE
;
   PUBLIC PARSE_DEFINE			;
; /\ ~~mda(001) ---------------------------------
   PUBLIC PARSE_DISPLAYMODE	       ;;					;AN000;
   PUBLIC PARSE_PRINTBOX	       ;;					;AN000;
   PUBLIC PARSE_SETUP		       ;;					;AN000;
   PUBLIC PARSE_RESTORE 	       ;;					;AN000;
   PUBLIC TERMINATE_DISPLAYMODE        ;;					;AN000;
   PUBLIC TERMINATE_PRINTER	       ;;					;AN000;
   PUBLIC CUR_PRINTER_TYPE	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Profile Load Variables							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
NO	      EQU   0		       ;;					;AN000;
YES	      EQU   1		       ;;					;AN000;
				       ;;					;AN000;
RESULT_BUFFER	LABEL BYTE	       ;; general purpose result buffer 	;AN000;
		    DB	 ?	       ;; operand type				;AN000;
RESULT_TAG	    DB	 0	       ;; operand tag				;AN000;
		    DW	 ?	       ;; pointer to synonym/keyword		;AN000;
RESULT_VAL	    DB	 ?,?,?,?       ;; returned numeric value		;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   TERMINATE_DISPLAYMODE							;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_DISPLAYMODE	PROC	       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,STMTS_DONE		       ;;					;AN000;
 .IF <PTD_FOUND EQ YES> AND	       ;; For the matched PTD			;AN000;
 .IF <BIT AX NAND BOX> AND	       ;;  issue "Invalid parm value"           ;AN000;
 .IF <PRT_BOX_ERROR EQ NO>	       ;;  message if PRINTBOX ID not		;AN000;
				       ;;  matched in each DISPLAYMODE section	;AN000;
	 PUSH AX		       ;; Save STMT_DONE flags			;AN000;
	 MOV  AX,INVALID_PB	       ;;					;AN000;
	 MOV  CX,0		       ;;					;AN000;
	 CALL DISP_ERROR	       ;;					;AN000;
	 MOV  BUILD_STATE,NO	       ;;					;AN000;
	 MOV  PRT_BOX_ERROR,YES        ;; Issue this message only once		;AN000;
	 POP  AX		       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  AND  AX,GR			       ;; Check for missing statements is last	;AN000;
 .IF <AX NE GR> 		       ;;  DISPLAYMODE section: 		;AN000;
     OR  STMT_ERROR,MISSING	       ;;    GRAPHICS stmt is required		;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_DISPLAYMODE	ENDP	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   TERMINATE_PRINTER								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
TERMINATE_PRINTER	PROC	       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,BLOCK_END		       ;;					;AN000;
 .IF <AX A MAX_BLOCK_END>	       ;; Keep track of the largest PRINTER	;AN000;
    MOV  MAX_BLOCK_END,AX	       ;;  section so we can allow space for	;AN000;
 .ENDIF 			       ;;  reload with a different printer	;AN000;
				       ;;  type.				;AN000;
				       ;;					;AN000;
				       ;; Check for missing statements		;AN000;
  MOV  AX,STMTS_DONE		       ;;					;AN000;
  AND  AX,DISP			       ;; At least one DISPLAYMODE		;AN000;
 .IF <AX NE DISP>		       ;;  must have been found in last 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;   PRINTER section			;AN000;
     MOV  PARSE_ERROR,YES	       ;;					;AN000;
     MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
TERMINATE_PRINTER	ENDP	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_PRINTER								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
PRINTER_PARSE_PARMS  LABEL WORD        ;; Parser control blocks 		;AN000;
	    DW	 PRINTER_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
PRINTER_P   DB	 0,1		       ;; Required, max parms			;AN000;
	    DW	 PRINTER_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
PRINTER_P1  DW	 2000H		       ;; simple string 			;AN000;
	    DW	 0002H		       ;; Capitalize using character table	;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTER_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTER_P1V    DB   3		       ;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag: index into verb jump table	;AN000;
PRINTER_P1V1  DW   ?		       ;; string offset 			;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CUR_PRINTER_TYPE   DB  0	       ;; Type of printer currently being	;AN000;
				       ;;  parsed:  1-color 2-b&w		;AN000;
				       ;;					;AN000;
PARSE_PRINTER  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,PRT		       ;;					;AN000;
  MOV  CUR_PRINTER_TYPE,BLACK_WHITE    ;; Assume black & white until we hit	;AN000;
				       ;;  a COLORPRINT 			;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE AND PRT>	       ;; If not the first PRINTER section	;AN000;
     CALL  TERMINATE_DISPLAYMODE       ;;  then clean up the last one and	;AN000;
     CALL  TERMINATE_PRINTER	       ;;    the last DISPLAYMODE section.	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 MOV  AX,FIRST_BLOCK		       ;;					;AN000;
 MOV  BLOCK_START,AX		       ;; Reset block pointers to start 	;AN000;
 MOV  BLOCK_END,AX		       ;;  of variable area			;AN000;
				       ;;					;AN000;
  MOV  STMTS_DONE,PRT		       ;; Clear all bits except for PRT 	;AN000;
  MOV  GROUPS_DONE,0		       ;; Clear 				;AN000;
				       ;;					;AN000;
 .IF <PTD_FOUND EQ YES> 	       ;; PRINTER statement marks the end of	;AN000;
     MOV  PTD_FOUND,PROCESSED	       ;;  the previous PTD			;AN000;
     MOV  BUILD_STATE,NO	       ;; Stop building shared data		;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  CL,TAB_DIR_NB_ENTRIES	       ;; Reset the pattern table copy		;AN000;
  XOR  CH,CH			       ;;  pointers.  These pointers		;AN000;
  MOV  BX,OFFSET TAB_DIRECTORY	       ;;   are established when a pattern	;AN000;
 .REPEAT			       ;;    table is copied to the shared	;AN000;
    MOV [BX].TAB_COPY,-1	       ;;     data area.  Initially they	;AN000;
    ADD BX,SIZE TAB_ENTRY	       ;;      are -1.				;AN000;
 .LOOP				       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,OFFSET PRINTER_TYPE_PARM     ;; Store printer type from command	;AN000;
  MOV  PRINTER_P1V1,AX		       ;;  line in value list			;AN000;
  MOV  DI,OFFSET PRINTER_PARSE_PARMS   ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
				       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
     XOR  CX,CX 		       ;; Don't worry about number of operands  ;AN000;
     CALL SYSPARSE		       ;;					;AN000;
    .IF <AX EQ 9>		       ;; Syntax error is the only thing	;AN000;
	OR  STMT_ERROR,INVALID	       ;;  which can go wrong			;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ 0> OR		       ;;					;AN000;
 .UNTIL <AX EQ -1>		       ;;					;AN000;
				       ;; Printer type parm matched one coded	;AN000;
				       ;;  on the PRINTER statement		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    .IF <PTD_FOUND EQ NO>	       ;;					;AN000;
	MOV  PTD_FOUND,YES	       ;; If the printer type matches and	;AN000;
       .IF <PARSE_ERROR EQ NO> AND     ;;  no errors have been found yet	;AN000;
       .IF <PRT_BOX_ERROR EQ NO> AND   ;;					;AN000;
       .IF <MEM_OVERFLOW EQ NO>        ;;					;AN000;
	   MOV BUILD_STATE,YES	       ;;   then start building the shared	;AN000;
       .ENDIF			       ;;    data				;AN000;
    .ENDIF			       ;;					;AN000;
 .ELSE				       ;; No match				;AN000;
    MOV  BUILD_STATE,NO 	       ;;					;AN000;
   .IF <AX NE -1>		       ;; Error during parse			;AN000;
      OR  STMT_ERROR,INVALID	       ;; set error flag for caller		;AN000;
      MOV PARSE_ERROR,YES	       ;; set error flag for caller		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
; \/ ~~mda(002) -----------------------------------------------------------------------
 .IF <BUILD_STATE EQ YES>              ;;
      MOV	[BP].DATA_TYPE,DATA_COL;; Set DATA_TYPE back to default of DATA_COL
 .ENDIF                                ;; for new PTD.
; /\ ~~mda(002) -----------------------------------------------------------------------
				       ;;					;AN000;
  RET										;AN000;
				       ;;					;AN000;
PARSE_PRINTER  ENDP								;AN000;
										;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;


;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_DISPLAYMODE								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
DISPMODE_PARSE_PARMS  LABEL WORD       ;; Parser control blocks 		;AN000;
	    DW	 DISPMODE_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
DISPMODE_P   DB   0,1		       ;; Required, max parms			;AN000;
	    DW	 DISPMODE_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
DISPMODE_P1  DW   8000H 	       ;; Numeric				;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 DISPMODE_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
DISPMODE_P1V	DB   1			;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,19		       ;; range 0..19				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_DISPLAYMODE  PROC 	       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,DISP		       ;;					;AN000;
				       ;; Check for a preceeding PRINTER	;AN000;
 .IF <BIT STMTS_DONE NAND PRT>	       ;;					;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; If first DISPLAYMODE...		;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP].DISPLAYMODE_PTR,AX  ;; Set pointer to first DISPLAYMODE	;AN000;
	 MOV  BLOCK_START,AX	       ;; New block starts after last one	;AN000;
     .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
     CALL TERMINATE_DISPLAYMODE        ;; If not the first DISPLAYMODE then	;AN000;
				       ;;  clean up the last one.		;AN000;
     MOV  DI,BLOCK_START	       ;; DI=pointer to DISPLAYMODE block just	;AN000;
     MOV  AX,BLOCK_END		       ;;  built				;AN000;
    .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	MOV  [BP+DI].NEXT_DISP_MODE,AX ;; Add new block to DISPLAYMODE chain	;AN000;
    .ENDIF			       ;;					;AN000;
     MOV  BLOCK_START,AX	       ;; New block starts after last one	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,SIZE DISPLAYMODE_STR	       ;; Allocate space for new DISPLAYMODE	;AN000;
  CALL	GROW_SHARED_DATA	       ;;  block				;AN000;
 .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
     MOV  DI,BLOCK_START	       ;; Start of new block			;AN000;
     MOV  [BP+DI].NUM_SETUP_ESC,0	  ;; SETUP, RESTORE are optional so set ;AN000;
     MOV  [BP+DI].NUM_RESTORE_ESC,0	  ;;  to defaults			;AN000;
     MOV  [BP+DI].SETUP_ESC_PTR,-1	  ;;					;AN000;
     MOV  [BP+DI].RESTORE_ESC_PTR,-1	  ;;					;AN000;
     MOV  [BP+DI].BOX_WIDTH,0		  ;;					;AN000;
     MOV  [BP+DI].BOX_HEIGHT,0		  ;;					;AN000;
     MOV  [BP+DI].PRINT_OPTIONS,0	  ;; Default to NO print options	;AN000;
     MOV  [BP+DI].NUM_DISP_MODE,0      ;; Get ready to INC this sucker		;AN000;
     MOV  [BP+DI].NEXT_DISP_MODE,-1    ;; This is the last DISPLAYMODE for now! ;AN000;
     MOV  AX,BLOCK_END		       ;;					;AN000;
     MOV  [BP+DI].DISP_MODE_LIST_PTR,AX;; Start mode list at end of new block	;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,DISP		       ;; Indicate DISPLAYMODE found		;AN000;
  AND  STMTS_DONE,NOT (BOX+GR+SET+REST) ;; Reset flags for PRINTBOX, GRAPHICS	;AN000;
				       ;;  stmts found				;AN000;
  AND  GROUPS_DONE,NOT (GR+SET+REST)   ;; Reset flags for GRAPHICS, SETUP,	;AN000;
				       ;;  RESTORE groups processed		;AN000;
  MOV  DI,OFFSET DISPMODE_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If mode is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a mode to the list		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_DISP_MODE   ;; Bump number of modes in list	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL   ;; Get mode from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store the mode at end of list 	;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID	  ;; Mode is invalid			;AN000;
	  MOV  PARSE_ERROR,YES		  ;;					;AN000;
	  MOV  BUILD_STATE,NO		  ;;					;AN000;
      .ENDIF				  ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1>		       ;;					;AN000;
				       ;;					;AN000;
  RET										;AN000;
				       ;;					;AN000;
PARSE_DISPLAYMODE  ENDP 							;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_SETUP								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
SETUP_PARSE_PARMS  LABEL WORD	     ;; Parser control blocks			;AN000;
	    DW	 SETUP_P	     ;; 					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
SETUP_P   DB   0,1		    ;; Required, max parms			;AN000;
	    DW	 SETUP_P1	    ;;						;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
SETUP_P1 DW   08000H		    ;; Numeric					;AN000;
	    DW	 0		       ;; nO Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	    ;; Result buffer				;AN000;
	    DW	 SETUP_P1V	    ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
SETUP_P1V    DB   1		    ;; # of value lists 			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_SETUP  PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,SET		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed this 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND SET>	       ;; Check for previous group of SETUP	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  stmts				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND SET>	       ;; If first SETUP...			;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP+DI].SETUP_ESC_PTR,AX ;; Set pointer to SETUP seq		;AN000;
	 MOV  [BP+DI].NUM_SETUP_ESC,0  ;; Init sequence size			;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,SET		       ;; Indicate SETUP found			;AN000;
 .IF <PREV_STMT NE SET> THEN	       ;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for SETUP group		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET SETUP_PARSE_PARMS     ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_SETUP_ESC   ;; Bump number of bytes in sequence	;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL  ;; Get esc byte from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_SETUP  ENDP		    ;;						;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_RESTORE								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
RESTORE_PARSE_PARMS  LABEL WORD        ;; Parser control blocks 		;AN000;
	    DW	 RESTORE_P	       ;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
RESTORE_P   DB	 0,1		      ;; Required, max parms			;AN000;
	    DW	 RESTORE_P1	      ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
RESTORE_P1 DW	08000H		      ;; Numeric				;AN000;
	    DW	 0		       ;; nO Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	    ;; Result buffer				;AN000;
	    DW	 RESTORE_P1V	      ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
RESTORE_P1V    DB   1		      ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 0,255		       ;; range 0..255				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_RESTORE  PROC			 ;;					;AN000;
				       ;;					;AN000;
  MOV  CUR_STMT,SET		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed this 	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT GROUPS_DONE AND REST>        ;; Check for previous group of RESTORE	;AN000;
     OR  STMT_ERROR,SEQUENCE	       ;;  stmts				;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND REST>        ;; If first RESTORE...			;AN000;
     .IF <BUILD_STATE EQ YES>	       ;;					;AN000;
	 MOV  DI,BLOCK_START	       ;;					;AN000;
	 MOV  AX,BLOCK_END	       ;;					;AN000;
	 MOV  [BP+DI].RESTORE_ESC_PTR,AX ;; Set pointer to RESTORE seq		;AN000;
	 MOV  [BP+DI].NUM_RESTORE_ESC,0  ;; Init sequence size			;AN000;
     .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  OR   STMTS_DONE,REST		       ;; Indicate RESTORE found		;AN000;
 .IF <PREV_STMT NE REST> THEN		;; Terminate any preceeding groups	;AN000;
     MOV  AX,PREV_STMT		       ;;  except for RESTORE group		;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET RESTORE_PARSE_PARMS	 ;; parse parms 			;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
 .REPEAT			       ;;					;AN000;
    XOR  CX,CX			       ;;					;AN000;
    CALL SYSPARSE		       ;;					;AN000;
   .IF <AX EQ 0>		       ;; If esc byte is valid			;AN000;
	  PUSH AX		       ;;					;AN000;
	  MOV	AX,1		       ;; Add a byte to the sequence		;AN000;
	  CALL	GROW_SHARED_DATA       ;; Update block end			;AN000;
	 .IF <BUILD_STATE EQ YES>      ;;					;AN000;
	     PUSH DI		       ;;					;AN000;
	     MOV  DI,BLOCK_START       ;;					;AN000;
	     INC  [BP+DI].NUM_RESTORE_ESC   ;; Bump number of bytes in sequence ;AN000;
	     MOV  DI,BLOCK_END	       ;;					;AN000;
	     MOV  AL,RESULT_VAL  ;; Get esc byte from result buffer		;AN000;
	     MOV  [BP+DI-1],AL	       ;; Store at end of sequence		;AN000;
	     POP  DI		       ;;					;AN000;
	 .ENDIF 		       ;;					;AN000;
	  POP  AX		       ;;					;AN000;
   .ELSE			       ;;					;AN000;
      .IF <AX NE -1>		       ;;					;AN000;
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			;AN000;
	  MOV  PARSE_ERROR,YES	       ;;					;AN000;
	  MOV  BUILD_STATE,NO	       ;;					;AN000;
      .ENDIF			       ;;					;AN000;
   .ENDIF			       ;;					;AN000;
 .UNTIL <AX EQ -1> NEAR 	       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
PARSE_RESTORE  ENDP		      ;;					;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_PRINTBOX								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
PRINTBOX_PARSE_PARMS  LABEL WORD	;; Parser control blocks		;AN000;
	    DW	 PRINTBOX_P		;;					;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
PRINTBOX_P  DB	 1,4		       ;; Required, max parms			;AN000;
	    DW	 PRINTBOX_P0	       ;; LCD/STD				;AN000;
	    DW	 PRINTBOX_P1	       ;; width 				;AN000;
	    DW	 PRINTBOX_P1	       ;; height				;AN000;
	    DW	 PRINTBOX_P2	       ;; rotate				;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
PRINTBOX_P0  DW   2000H 	       ;; sTRING - display type 		;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P0V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P0V	DB   3			;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag					;AN000;
PRINTBOX_P0V1 DW   ?		       ;; string				;AN000;
				       ;;					;AN000;
PRINTBOX_P1  DW   8001H 	       ;; Numeric - BOX DIMENSIONS		;AN000;
	    DW	 0		       ;; No Capitalize 			;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P1V	DB   1		       ;; # of value lists			;AN000;
	    DB	 1		       ;; # of range numerics			;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DD	 1,9		       ;; range 1..9				;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PRINTBOX_P2  DW   2001H 	       ;; sTRING - ROTATE PARM			;AN000;
	    DW	 2		       ;; Capitalize				;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 PRINTBOX_P2V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
PRINTBOX_P2V	DB   3			;; # of value lists			;AN000;
	    DB	 0		       ;; # of range numerics			;AN000;
	    DB	 0		       ;; # of discrete numerics		;AN000;
	    DB	 1		       ;; # of strings				;AN000;
	    DB	 1		       ;; tag					;AN000;
	    DW	 ROTATE_STR	       ;; string				;AN000;
ROTATE_STR  DB	 'ROTATE',0            ;;                                       ;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PROF_BOX_W  DB	0		       ;; Box width and height extracted from	;AN000;
PROF_BOX_H  DB	0		       ;;  the profile				;AN000;
PRINTBOX_MATCH	     DB  0	       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_PRINTBOX	PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  PRINTBOX_MATCH,NO	       ;; Start out assuming the PRINTBOX ID	;AN000;
  MOV  PROF_BOX_W,0		       ;;  does not match the one requested	;AN000;
  MOV  PROF_BOX_H,0		       ;;					;AN000;
  MOV  CUR_STMT,BOX		       ;;					;AN000;
 .IF <BIT STMTS_DONE NAND DISP>        ;; DISPLAYMODE must preceed PRINTBOX	;AN000;
     OR  STMT_ERROR,MISSING	       ;;					;AN000;
	MOV  PARSE_ERROR,YES	       ;;					;AN000;
	MOV  BUILD_STATE,NO	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;; Multiple PRINTBOX stmts may be coded	;AN000;
				       ;;  We must decide if this one		;AN000;
				       ;;   matches the requested display type	;AN000;
				       ;;    If not, ignore the statement	;AN000;
  MOV  DI,OFFSET PRINTBOX_PARSE_PARMS  ;; parse parms				;AN000;
				       ;; SI => the line to parse		;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
				       ;;					;AN000;
  MOV  AX,PRINTBOX_ID_PTR	       ;; Insert requested display type in	;AN000;
  MOV  PRINTBOX_P0V1,AX 	       ;;  parser value list			;AN000;
  CALL SYSPARSE 		       ;; PARSE display type			;AN000;
 .IF <AX EQ 0>			       ;; If ID matches then set this flag.	;AN000;
     MOV  PRINTBOX_MATCH,YES	       ;;					;AN000;
     OR   STMTS_DONE,BOX	       ;; Indicate PRINTBOX found		;AN000;
     MOV  AX,PREV_STMT		       ;; Terminate any preceeding groups	;AN000;
     OR   GROUPS_DONE,AX	       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE horizontal dimension		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
     MOV  BL,RESULT_VAL 	       ;;					;AN000;

; \/ ~~mda(005) -----------------------------------------------------------------------
;           Presently a 3,1 printbox is not supported for HP PCL printers, but
;           a 4,1 printbox is supported.  The reason for this is that one byte
;           is printed at a time and only two 3,1 print boxes are placed in
;           the one byte print buffer, leaving two blank bits.  This causes
;           the picture to have blank lines running through it and results in
;           a 4,1 printbox.  Instead of placing only two 3,1 print boxes in 
;           the print buffer, two 3,1 print boxes plus a partial 3,1 printbox
;           should be placed in the print buffer.  Another solution is to
;           make the print buffer be three bytes long, and place eight 3,1 
;           print boxes in the three byte long print buffer.  Since the present
;           implementation results in a faulty 4,1 printbox, we change the 3,1
;           printbox to a 4,1 printbox up front.  So even though we still
;           have a 4,1 printbox, at least we will have an accurate picture.
    .IF <[BP].DATA_TYPE EQ DATA_ROW> AND
    .IF <BL EQ 3>
         MOV BL,4
    .ENDIF
; /\ ~~mda(005) -----------------------------------------------------------------------
              
     MOV  PROF_BOX_W,BL 	       ;; Save in local var			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  PRINTBOX_DONE	       ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; PARSE vertical dimension		;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
     MOV  BL,RESULT_VAL 	       ;;					;AN000;
     MOV  PROF_BOX_H,BL 	       ;; Save in local var			;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  SHORT   PRINTBOX_DONE     ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; Parse ROTATE parm			;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    .IF <BUILD_STATE EQ YES> AND       ;;					;AN000;
    .IF <PRINTBOX_MATCH EQ YES>        ;;					;AN000;
	PUSH DI 		       ;;					;AN000;
	MOV  DI,BLOCK_START	       ;;					;AN000;
	OR   [BP+DI].PRINT_OPTIONS,ROTATE ;;					;AN000;
	POP  DI 		       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ELSE				       ;;					;AN000;
    .IF <AX EQ -1>		       ;;					;AN000;
	JMP  SHORT   PRINTBOX_DONE     ;;					;AN000;
    .ELSE			       ;;					;AN000;
	OR  STMT_ERROR,INVALID	       ;;					;AN000;
	MOV PARSE_ERROR,YES	       ;;					;AN000;
	MOV BUILD_STATE,NO	       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
  CALL SYSPARSE 		       ;; CHECK FOR EXTRA PARMS 		;AN000;
 .IF <AX NE -1> 		    ;;						;AN000;
    OR	STMT_ERROR,INVALID	   ;;						;AN000;
    MOV PARSE_ERROR,YES 	   ;;						;AN000;
    MOV BUILD_STATE,NO		   ;;						;AN000;
 .ENDIF 			       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PRINTBOX_DONE:			       ;;					;AN000;
				       ;;					;AN000;
 .IF <BUILD_STATE EQ YES> AND	    ;; Store the PRINTBOX dimensions		;AN000;
 .IF <PRINTBOX_MATCH EQ YES>	    ;;						;AN000;
     PUSH DI			    ;;	in the DISPLAYMODE block		;AN000;
     MOV  DI,BLOCK_START	    ;;						;AN000;
     MOV  AL,PROF_BOX_W 	    ;;						;AN000;
     MOV  [BP+DI].BOX_WIDTH,AL	    ;;						;AN000;
     MOV  AL,PROF_BOX_H 	    ;;						;AN000;
     MOV  [BP+DI].BOX_HEIGHT,AL     ;;						;AN000;
     POP  DI			    ;;						;AN000;
 .ENDIF 			    ;;						;AN000;
				       ;; If we have a B&W printer then 	;AN000;
				       ;;   load the grey patterns for the	;AN000;
				       ;;    requested print box size.		;AN000;
 .IF <CUR_PRINTER_TYPE EQ BLACK_WHITE> NEAR					;AN000;
				       ;;					;AN000;
    .IF <PROF_BOX_W NE 0> AND NEAR	  ;; Dimensions could also be 0 if the	;AN000;
    .IF <PROF_BOX_H NE 0> NEAR		  ;;  printbox ID does not apply to this;AN000;
					  ;;   displaymode, so don't try for    ;AN000;
					  ;;	a pattern!			;AN000;
	MOV  BX,OFFSET TAB_DIRECTORY	  ;;					;AN000;
	MOV  CL,TAB_DIR_NB_ENTRIES	  ;;					;AN000;
	XOR  CH,CH			  ;;					;AN000;
	MOV  DI,BLOCK_START		  ;;					;AN000;
	MOV  AL,PROF_BOX_W		  ;; Requested box width		;AN000;
	MOV  AH,PROF_BOX_H		  ;; Requested box height		;AN000;
       .REPEAT				  ;;					;AN000;
	  .IF <[BX].BOX_W_PAT EQ AL> AND  ;;					;AN000;
	  .IF <[BX].BOX_H_PAT EQ AH>	  ;;					;AN000;
	     .LEAVE			  ;;					;AN000;
	  .ELSE 			  ;;					;AN000;
	      ADD  BX,SIZE TAB_ENTRY	  ;;					;AN000;
	  .ENDIF			  ;;					;AN000;
       .LOOP				  ;;					;AN000;
       .IF <ZERO CX>			  ;;					;AN000;
	   OR  STMT_ERROR,INVALID	  ;; Unsupported box size		;AN000;
	   MOV PARSE_ERROR,YES		  ;;					;AN000;
	   MOV BUILD_STATE,NO		  ;;					;AN000;
       .ELSE NEAR			  ;; Box size OK - pattern tab found	;AN000;
	  .IF <[BX].TAB_COPY NE -1>	  ;; Pointer is NOT null if the table	;AN000;
	      MOV  AX,[BX].TAB_COPY	  ;;  has already been copied to	;AN000;
					  ;;   the shared data area.		;AN000;
	     .IF <BUILD_STATE EQ YES> AND ;;	Point to the copy.		;AN000;
	     .IF <PRINTBOX_MATCH EQ YES>  ;; Establish pointer to table ONLY	;AN000;
		 MOV  [BP+DI].PATTERN_TAB_PTR,AX ;; if the PB ID matched.	;AN000;
		 MOV  AL,[BX].NB_INT	  ;; Number of table entries (intensitie;AN000;
		 MOV  [BP+DI].NUM_PATTERNS,AL ;;				;AN000;
	     .ENDIF			  ;;					;AN000;
	  .ELSE 			  ;; Otherwise we have to copy it.	;AN000;
	   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
	   ;; Copy the table even if the printbox ID didn't match!              ;AN000;
	   ;; This is a simple way to reserve enough space to allow reloading	;AN000;
	   ;; with a different PRINTBOX ID specified on the command line.	;AN000;
	   ;; This scheme avoids storing					;AN000;
	   ;; duplicate tables but may reserve slightly more space		;AN000;
	   ;; (probably only a hundred bytes or so) than			;AN000;
	   ;; could ever be required.  The optimal solution (too		;AN000;
	   ;; complicated!) would involve keeping running totals for each	;AN000;
	   ;; PRINTBOX ID coded.						;AN000;
	   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
					  ;;					;AN000;
	      MOV  DI,BLOCK_END 	  ;; Copy it onto the end of the	;AN000;
					  ;;  current block			;AN000;
	      MOV  DX,DI		  ;; Save start addr of the copy	;AN000;
	      MOV  [BX].TAB_COPY,DX	  ;; Store ptr to copy in the directory ;AN000;
	      MOV  AX,[BX].TAB_SIZE	  ;;					;AN000;
	      CALL GROW_SHARED_DATA	  ;; Allocate room for the table	;AN000;
	     .IF <BUILD_STATE EQ YES>	  ;;					;AN000;
		 MOV  CX,AX		  ;; Number of bytes to copy		;AN000;
		 PUSH SI		  ;; Save parse pointer 		;AN000;
		 MOV  SI,[BX].TAB_OFFSET  ;; Source pointer			;AN000;
		 ADD  DI,BP		  ;; make DI an absolute pointer (dest) ;AN000;
		 REP  MOVSB		  ;; Move it!				;AN000;
		 POP  SI		  ;;					;AN000;
		.IF <PRINTBOX_MATCH EQ YES>  ;; Establish pointer to table ONLY ;AN000;
		    MOV  DI,BLOCK_START      ;; Establish pointer in DISPLAYMODE;AN000;
		    MOV  [BP+DI].PATTERN_TAB_PTR,DX  ;;  info			;AN000;
		    MOV  AL,[BX].NB_INT      ;; Number of table entries (intens);AN000;
		    MOV  [BP+DI].NUM_PATTERNS,AL ;;				;AN000;
		.ENDIF			     ;; 				;AN000;
	     .ENDIF			  ;;					;AN000;
	  .ENDIF			   ;;					;AN000;
       .ENDIF			       ;;					;AN000;
    .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET				       ;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_PRINTBOX	ENDP								;AN000;
										;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Module Name: 								;AN000;
;;   PARSE_VERB 								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
VERB_PARSE_PARMS  LABEL WORD	       ;; Parser control blocks to parse verb	;AN000;
	    DW	 VERB_P 	       ;; Parser control blocks to parse verb	;AN000;
	    DB	 2		       ;; # of lists				;AN000;
	    DB	 0		       ;; # items in delimeter list		;AN000;
	    DB	 1		       ;; # items in end-of-line list		;AN000;
	    DB	 ';'                   ;; ';' used for comments                 ;AN000;
				       ;;					;AN000;
VERB_P	    DB	 0,1		       ;; Required, max parms			;AN000;
	    DW	 VERB_P1	       ;;					;AN000;
	    DB	 0		       ;; # Switches				;AN000;
	    DB	 0		       ;; # keywords				;AN000;
				       ;;					;AN000;
VERB_P1     DW	 2000H		       ;; simple string 			;AN000;
	    DW	 0002H		       ;; Capitalize using character table	;AN000;
	    DW	 RESULT_BUFFER	       ;; Result buffer 			;AN000;
	    DW	 VERB_P1V	       ;; Value list				;AN000;
	    DB	 0		       ;; Synomyms				;AN000;
				       ;;					;AN000;
VERB_P1V    DB	 3			  ;; # of value lists			;AN000;
	    DB	 0			  ;; # of range numerics		;AN000;
	    DB	 0			  ;; # of discrete numerics		;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Changed the number of strings from 9 to 10 because of the
;               new DEFINE statement.
	    DB	 10			  ;; # of strings			;AN000;
;/\  ~~mda(001) ----------------------------------------------------------
	    DB	 0			  ;; tag: index into verb jump table	;AN000;
	    DW	 PRINTER_STRING 	  ;; string offset			;AN000;
	    DB	 2			  ;; tag				;AN000;
	    DW	 DISPLAYMODE_STRING	  ;; string offset			;AN000;
	    DB	 4			  ;; tag				;AN000;
	    DW	 PRINTBOX_STRING	  ;; string offset			;AN000;
	    DB	 6			  ;; tag				;AN000;
	    DW	 SETUP_STRING		  ;; string offset			;AN000;
	    DB	 8			  ;; tag				;AN000;
	    DW	 RESTORE_STRING 	  ;; string offset			;AN000;
	    DB	 10			  ;; tag				;AN000;
	    DW	 GRAPHICS_STRING	  ;; string offset			;AN000;
	    DB	 12			  ;; tag				;AN000;
	    DW	 COLORPRINT_STRING	  ;; string offset			;AN000;
	    DB	 14			  ;; tag				;AN000;
	    DW	 COLORSELECT_STRING	  ;; string offset			;AN000;
	    DB	 16			  ;; tag				;AN000;
	    DW	 DARKADJUST_STRING	  ;; string offset			;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added DEFINE_STRING to the value list.
;
            DB   18                       ;; tag
            DW   DEFINE_STRING            ;; string offset
;/\  ~~mda(001) ----------------------------------------------------------
PRINTER_STRING	    DB 'PRINTER',0        ;;                                    ;AN000;
DISPLAYMODE_STRING  DB 'DISPLAYMODE',0    ;;                                    ;AN000;
PRINTBOX_STRING     DB 'PRINTBOX',0       ;;                                    ;AN000;
SETUP_STRING	    DB 'SETUP',0          ;;                                    ;AN000;
RESTORE_STRING	    DB 'RESTORE',0        ;;                                    ;AN000;
GRAPHICS_STRING     DB 'GRAPHICS',0       ;;                                    ;AN000;
COLORPRINT_STRING   DB 'COLORPRINT',0     ;;                                    ;AN000;
COLORSELECT_STRING  DB 'COLORSELECT',0    ;;                                    ;AN000;
DARKADJUST_STRING   DB 'DARKADJUST',0     ;;                                    ;AN000;
;\/  ~~mda(001) ----------------------------------------------------------
;               Added the DEFINE_STRING.
;
DEFINE_STRING       DB 'DEFINE',0         ;;
;/\  ~~mda(001) ----------------------------------------------------------
				       ;;					;AN000;
				       ;;					;AN000;
PARSE_VERB     PROC		       ;;					;AN000;
				       ;;					;AN000;
  MOV  DI,OFFSET VERB_PARSE_PARMS      ;; parse parms				;AN000;
  MOV  SI,OFFSET STMT_BUFFER	       ;; the line to parse			;AN000;
  XOR  DX,DX			       ;;					;AN000;
  XOR  CX,CX			       ;;					;AN000;
  CALL SYSPARSE 		       ;;					;AN000;
 .IF <AX EQ 0>			       ;;					;AN000;
    MOV  BL,RESULT_TAG		       ;;					;AN000;
    XOR  BH,BH			       ;; return tag in BX			;AN000;
 .ELSE				       ;;					;AN000;
   .IF <AX NE -1>		       ;; syntax error				;AN000;
      OR  STMT_ERROR,INVALID	       ;; set error flag for caller		;AN000;
   .ENDIF			       ;;					;AN000;
 .ENDIF 			       ;;					;AN000;
  RET										;AN000;
PARSE_VERB     ENDP								;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

;\/ ~~mda(001)  -----------------------------------------------------------------------
;               This procedure parses the new statement DEFINE in the
;               graphics profile.  The reason for this new statement
;               is to be able to define the new keyword, DATA, as DATA_ROW
;               or DATA_COL.  This is necessary in order to support HP PCL
;               printers since they print in row format and IBM printers
;               print in column format.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; Module Name: 								
;;   PARSE_DEFINE								
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
DEFINE_PARSE_PARMS  LABEL WORD         ;; Parser control blocks 		
	    DW	 DEFINE_P	       ;;					
	    DB	 2		       ;; # of lists				
	    DB	 0		       ;; # items in delimeter list		
	    DB	 1		       ;; # items in end-of-line list		
	    DB	 ';'                   ;; ';' used for comments                 
				       ;;					
DEFINE_P    DB   0,1		       ;; Required, max parms.  If have DEFINE	
				       ;; then must have DEFINE DATA,ROW or
				       ;; DEFINE DATA,COLUMN
	    DW	 DEFINE_P1	       ;;					
	    DB	 0		       ;; # Switches				
	    DB	 0		       ;; # keywords				
				       ;;					
DEFINE_P1   DW	 2000H 	       	       ;; simple string				
	    DW	 2		       ;; Capitalize				
	    DW	 RESULT_BUFFER	       ;; Result buffer 			
	    DW	 DEFINE_P1V	       ;; Value list				
	    DB	 0		       ;; Synomyms				
				       ;;					
				       ;;					
DEFINE_P1V  DB   3		       ;; # of value lists			
	    DB	 0		       ;; # of range numerics			
	    DB	 0		       ;; # of discrete numerics		
	    DB	 3		       ;; 3 STRING VALUES			
	    DB	 1		       ;; tag					
	    DW	 DATA_STR	       ;; ptr					
	    DB	 2		       ;; tag					
	    DW	 ROW_STR	       ;; ptr					
	    DB	 3		       ;; tag					
	    DW	 COL_STR	       ;; ptr					
				       ;;					
DATA_STR    DB  'DATA',0               ;;                                       
ROW_STR     DB  'ROW',0                ;;                                       
COL_STR     DB  'COLUMN',0             ;;                                       
				       ;;					
				       ;;					
ROW_FOUND	 DB  NO 	       ;;					
COL_FOUND        DB  NO 	       ;; Assume column until told otherwise	
DATA_FOUND	 DB  NO		       ;;
				       ;;					
				       ;;					
PARSE_DEFINE	PROC		       ;;					
				       ;;					
  MOV  CUR_STMT,DEF		       ;; 					
 .IF <BIT STMTS_DONE NAND PRT>         ;; If no preceeding PRT stmt		
     OR   STMT_ERROR,MISSING	       ;; then issue error			
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
 .IF <BIT STMTS_DONE AND DISP>	       ;; DISPLAYMODE stmts			
     OR   STMT_ERROR,SEQUENCE	       ;; should NOT have been processed	
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
 .IF <BIT STMTS_DONE AND DEF>	       ;; If another DEF stmt within in this
     OR   STMT_ERROR,INVALID           ;; PTD then issue error			
     MOV  PARSE_ERROR,YES	       ;;					
     MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
				       ;;					
				       ;;					
  MOV  ROW_FOUND,NO	               ;; Flags to indicate whether the ROW,	
  MOV  COL_FOUND,NO		       ;; COLUMN, or DATA parms were found.  	
  MOV  DATA_FOUND,NO                   ;;
				       ;;					
  OR   STMTS_DONE,DEF		       ;; Indicate DEFINE found			
				       ;;					
  MOV  DI,OFFSET DEFINE_PARSE_PARMS    ;; parse parms				
				       ;; SI => the line to parse		
  XOR  DX,DX			       ;;					
 .REPEAT			       ;;					
    XOR  CX,CX			       ;;					
    CALL SYSPARSE		       ;;					
				       ;;					
   .IF <AX EQ 0> NEAR		       ;; If PARM is valid			
	MOV  BL,RESULT_TAG	       ;;					
       .SELECT			       ;;					
       .WHEN <BL EQ 1>		       ;; DATA string				
	   CMP DATA_FOUND,NO           ;; .IF <DATA_FOUND EQ NO> ... .ELSE ...  
	   JNE DATA_ERROR	       ;; Not using .IF macro because jump is 
	   MOV DATA_FOUND,YES	       ;; out of range.
	   JMP CONT_PARSE              ;;
DATA_ERROR:                            ;;
	   OR  STMT_ERROR,INVALID      ;; Duplicate DATA parms			
	   MOV  PARSE_ERROR,YES        ;;					
	   MOV  BUILD_STATE,NO         ;;					
	                               ;;
       .WHEN <BL EQ 2>		       ;; ROW					
	  .IF <ROW_FOUND EQ NO> AND    ;;					
	  .IF <COL_FOUND EQ NO>        ;;					
	       MOV   ROW_FOUND,YES     ;;					
              .IF <BUILD_STATE EQ YES> ;; ~~mda(002) If this is the DEFINE stmt we're using
	           MOV  [BP].DATA_TYPE,DATA_ROW ;; Set DATA_TYPE to DATA_ROW. 	
              .ENDIF
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate ROW parms or combo of	
				       ;; parms ROW and COLUMN
	       MOV  PARSE_ERROR,YES    ;;					
	       MOV  BUILD_STATE,NO     ;;					
	  .ENDIF		       ;;					
                                       ;;
       .WHEN <BL EQ 3>		       ;; COLUMN				
	  .IF <COL_FOUND EQ NO> AND    ;;					
	  .IF <ROW_FOUND EQ NO>        ;;					
	       MOV   COL_FOUND,YES     ;;					
              .IF <BUILD_STATE EQ YES> ;; ~~mda(002) If this is the DEFINE stmt we're using
     	           MOV  [BP].DATA_TYPE,DATA_COL	;; Set DATA_TYPE to DATA_COL. 	
              .ENDIF                   ;;
	  .ELSE 		       ;;					
	       OR  STMT_ERROR,INVALID  ;; Duplicate COLUMN parms or combo of	
				       ;; parms COLUMN and ROW
	       MOV  PARSE_ERROR,YES    ;;					
	       MOV  BUILD_STATE,NO     ;;					
	  .ENDIF		       ;;					
       .ENDSELECT		       ;;					
   .ELSE NEAR			       ;;					
      .IF <AX NE -1>		       ;;					
	  OR   STMT_ERROR,INVALID      ;; parm is invalid			
	  MOV  PARSE_ERROR,YES	       ;;					
	  MOV  BUILD_STATE,NO	       ;;					
      .ENDIF			       ;;					
   .ENDIF			       ;;					
CONT_PARSE:                            ;;
 .UNTIL <AX EQ -1> NEAR 	       ;;					
				       ;;					
 .IF  <DATA_FOUND EQ NO>               ;; Missing DATA parm			
      OR   STMT_ERROR,INVALID	       ;;					
      MOV  PARSE_ERROR,YES	       ;;					
      MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
                                       ;;
                                       ;;
 .IF  <ROW_FOUND EQ NO> AND	       ;; Missing ROW or COLUMN parm		
 .IF  <COL_FOUND EQ NO>                ;;
      OR   STMT_ERROR,INVALID	       ;;					
      MOV  PARSE_ERROR,YES	       ;;					
      MOV  BUILD_STATE,NO	       ;;					
 .ENDIF 			       ;;					
				       ;;					
  RET				       ;;					
				       ;;					
PARSE_DEFINE	ENDP		       ;;					
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;/\ ~~mda(001)  -----------------------------------------------------------------------
										;AN000;
LIMIT	LABEL NEAR		       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grinst.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;************************************************************
;**  
;**  
;**  NAME:  Support for HP PCL printers added to GRAPHICS.
;**  
;**  DESCRIPTION:  I changed the default printer type from GRAPHICS to HPDEFAULT 
;**                because we have a section in the profile under 'HPDEFAULT' that
;**                will satisfactorily handle all of our printers.  I also changed
;**                the number of bytes for the printer type from 9 to 16 because
;**                of the RUGGEDWRITERWIDE.
;**  
;**  DOCUMENTATION NOTES:  This version of GRINST.ASM differs from the previous
;**                        version only in terms of documentation. 
;**  
;**  
;************************************************************
	PAGE	,132								
	TITLE	DOS - GRAPHICS Command  -	Installation Modules		
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;; DOS - GRAPHICS Command
;;                                   
;;										
;; File Name:  GRINST.ASM							
;; ----------									
;;										
;; Description: 								
;; ------------ 								
;;	 This file contains the installation modules for the			
;;	 GRAPHICS command.							
;;										
;;	 GRAPHICS_INSTALL is the main module.					
;;										
;;	 GRAPHICS_INSTALL calls modules in GRLOAD.ASM to load			
;;	 the GRAPHICS profile and GRPARMS.ASM to parse the command line.	
;;										
;;										
;; Documentation Reference:							
;; ------------------------							
;;	 OASIS High Level Design						
;;	 OASIS GRAPHICS I1 Overview						
;;	 DOS 3.3 Message Retriever Interface Supplement. 			
;;	 TUPPER I0 Document - PARSER HIGH LEVEL DESIGN REVIEW			
;;										
;; Procedures Contained in This File:						
;; ----------------------------------						
;;	 GRAPHICS_INSTALL - Main installation module				
;;	 CHAIN_INTERRUPTS - Chain interrupts 5, 2F, EGA Save Pointers		
;;	 COPY_PRINT_MODULES - Throw away one set of print modules		
;;										
;;										
;; Include Files Required:							
;; -----------------------							
;;	 GRLOAD.EXT   - Externals for profile load				
;;	 GRLOAD2.EXT  - Externals for profile load				
;;	 GRCTRL.EXT   - Externals for print screen control			
;;	 GRPRINT.EXT  - Externals for print modules				
;;	 GRCPSD.EXT   - Externals for COPY_SHARED_DATA module			
;;	 GRPARMS.EXT  - External for GRAPHICS command line parsing		
;;	 GRPARSE.EXT  - External for DOS parser 				
;;	 GRBWPRT.EXT  - Externals for Black and white printing modules		
;;	 GRCOLPRT.EXT - Externals for color printing modules			
;;	 GRINT2FH.EXT - Externals for Interrupt 2Fh driver.			
;;										
;;	 GRMSG.EQU    - Equates for the GRAPHICS error messages 		
;;	 SYSMSG.INC   - DOS message retriever					
;;										
;;	 GRSHAR.STR   - Shared Data Area Structure				
;;										
;;	 STRUC.INC    - Macros for using structured assembly language		
;;										
;; External Procedure References:						
;; ------------------------------						
;;	 FROM FILE  GRLOAD.ASM: 						
;;	      LOAD_PROFILE - Main module for profile loading			
;;	 SYSPARSE   - DOS system parser 					
;;	 SYSDISPMSG - DOS message retriever					
;;										
;; Linkage Instructions:							
;; -------------------- 							
;;	 Refer to GRAPHICS.ASM							
;;										
;; Change History:								
;; ---------------								
;; M001	NSM	1/30/91		Install our int 10 handler also along with
;;				int 2f and int 5 handlers to take care of alt
;;				prt-sc select calls made by ANSI.SYS
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       
	ASSUME	CS:CODE,DS:CODE        ;;					
				       ;;					
.XLIST				       ;;					
	INCLUDE GRSHAR.STR	       ;; Include the Shared data area structure
	INCLUDE SYSMSG.INC	       ;; Include DOS message retriever 	
	INCLUDE STRUC.INC	       ;; Include macros - Structured Assembler 
	INCLUDE GRLOAD.EXT	       ;; Bring in external declarations	
	INCLUDE GRLOAD2.EXT	       ;;					
	INCLUDE GRLOAD3.EXT	       ;;					
	INCLUDE GRCTRL.EXT	       ;;					
	INCLUDE GRBWPRT.EXT	       ;;					
	INCLUDE GRCOLPRT.EXT	       ;;					
	INCLUDE GRCPSD.EXT	       ;;					
	INCLUDE GRINT2FH.EXT	       ;;					
	INCLUDE GRCTRL.EXT	       ;;					
	INCLUDE GRPARSE.EXT	       ;;					
	INCLUDE GRPARMS.EXT	       ;;					
	INCLUDE GRMSG.EQU	       ;;					
				       ;;					
MSG_UTILNAME <GRAPHICS> 	       ;; Identify ourself to Message retriever.
				       ;; Include messages			
MSG_SERVICES <MSGDATA>		       ;;					
MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg>  ;;				
MSG_SERVICES <GRAPHICS.CL1,GRAPHICS.CL2,GRAPHICS.CLA,GRAPHICS.CLB,GRAPHICS.CLC> 
.LIST				       ;;					
				       ;;					
PUBLIC GRAPHICS_INSTALL 	       ;;					
PUBLIC CHAIN_INTERRUPTS
PUBLIC TEMP_SHARED_DATA_PTR	       ;;					
PUBLIC PRINTER_TYPE_PARM	       ;;					
PUBLIC PRINTER_TYPE_LENGTH	       ;;					
PUBLIC PROFILE_PATH		       ;;					
PUBLIC PRINTBOX_ID_PTR		       ;;					
PUBLIC PRINTBOX_ID_LENGTH	       ;;					
PUBLIC DEFAULT_BOX		       ;;					
PUBLIC LCD_BOX			       ;;					
PUBLIC NB_FREE_BYTES		       ;;					
PUBLIC SYSDISPMSG		       ;;					
PUBLIC DISP_ERROR		       ;;					
PUBLIC INSTALLED		       ;;					
PUBLIC ERROR_DEVICE		       ;;					
PUBLIC STDERR			       ;;					
PUBLIC STDOUT			       ;;					
PUBLIC RESIDENT_SHARED_DATA_SIZE       ;;					
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; Install Variables								
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
NO		      EQU   0	       ;;					
YES		      EQU   1	       ;;					
INSTALLED	      DB    NO	       ;; YES if GRAPHICS already installed	
				       ;;					
				       ;;					
BYTES_AVAIL_PSP_OFF   EQU   6	       ;; Word number 6 of the PSP is the	
				       ;;  number of bytes available in the	
				       ;;   current segment			
				       ;;					
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;;										
;; GRLOAD (PROFILE LOADING) INPUT PARMS:					
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
;\/ ~~mda ----------------------------------------------------------------------------
;               Changed the default printer type from GRAPHICS to HPDEFAULT,
;               which really isn't a printer type.  In the GRAPHICS.PRO
;               file there is a section that starts 'PRINTER HPDEFAULT'
;               that has all the necessary parms to support all HP printers
;               satisfactorily.  Also changed the number of bytes for the
;               printer type from 9 to 16 because of the RUGGEDWRITERWIDE.
;
;	MD 6/4/90 - this is a backwards compatibility problem.	Changed default
;		    back to Graphics

PRINTER_TYPE_PARM    DB    "GRAPHICS",9 DUP(0) ; Printer type			
				       ;;  (default=Graphics)			
;/\ ~~mda -----------------------------------------------------------------------------
PRINTER_TYPE_LENGTH  DB    17	       ;; Printer type maximum length of ASCIIZ 
PROFILE_PATH	     DB    128 DUP(0)  ;;  Profile name with full path		
				       ;;   (Max size for ASCIIZ is 128)	
PRINTBOX_ID_PTR      DW    DEFAULT_BOX ;;  Offset of ASCIIZ string containing	
DEFAULT_BOX	     DB    "STD",14 DUP(0);  the printbox id. (DEFAULT = STD)   
LCD_BOX 	     DB    "LCD",14 DUP(0); ASCIIZ string for the LCD printboxID
PRINTBOX_ID_LENGTH   DB    17	       ;;  Max. length for the printbox id.	
				       ;;   ASCIIZ string			
NB_FREE_BYTES	     DW    ?	       ;;  Number of bytes available in our	
				       ;;   resident segment			
RESIDENT_SHARED_DATA_SIZE  DW ?        ;;  Size in bytes of the RESIDENT Shared 
				       ;;   data area (if GRAPHICS already	
				       ;;    installed).			
END_OF_RESIDENT_CODE DW    ?	       ;; Offset of the end of the code that	
				       ;;  has to be made resident.		
TEMP_SHARED_DATA_PTR DW    ?	       ;; Offset of the temporary Shared area	
				       ;;					
ERROR_DEVICE   DW   STDERR	       ;; Device DISP_ERROR will output 	
				       ;;  messages to (STDERR or STDOUT)	
PAGE										
;===============================================================================
;										
; GRAPHICS_INSTALL : INSTALL GRAPHICS.COM					
;										
;-------------------------------------------------------------------------------
;										
;  INPUT:   Command line parameters						
;	    GRAPHICS profile - A file describing printer characteristics and	
;			       attributes.					
;										
;  OUTPUT:  If first time invoked:						
;	      INT 5 VECTOR and INT 2FH VECTOR are replaced; only the required	
;	      code for printing the screen is made resident.			
;	    else,								
;	      The resident code is updated to reflect changes in printing	
;	      options.								
;										
;-------------------------------------------------------------------------------
;;										
;; DESCRIPTION: 								
;;										
;;   This module intalls GRAPHICS code and data.				
;;										
;;   An INT 2FH driver is also installed.					
;;										
;;   If this driver is already present then, we assume GRAPHICS was installed	
;;   and do not install it again but, simply update the resident code.		
;;										
;;   The resident code contains ONLY the code and data needed for Printing	
;;   the screen. The code needed is determined according to the command line	
;;   parameters and the information extracted from the printer profile. 	
;;										
;;   The printer profile is parsed according to the current hardware setting	
;;   and also to the command line options. The information extracted from	
;;   the profile is stored in a Data area shared between the installation	
;;   process and the Print Screen process.					
;;										
;;   A temporary Shared Data Area is FIRST built at the end of the .COM file	
;;   Before building it, we verify that there is				
;;   enough memory left in the current segment.  If not, the installation	
;;   process is aborted.							
;;										
;;   This temporary Data area when completed will be copied over the		
;;   installation code. Therefore, the file comprising GRAPHICS must be 	
;;   linked in a specific order with the installation modules being last.	
;;										
;;   These modules will be overwritten by the Shared Data area and the EGA	
;;   dynamic save area before we exit and stay resident.			
;;										
;;   The end of the resident code is the end of the Shared Data area, anything	
;;   else beyond that is not made resident.					
;;										
;;   The pointer to the resident Shared Data area is declared within the	
;;   Interrupt 2Fh driver. This pointer is initialized by the installation	
;;   process and points to the shared data area at Print Screen time.		
;;										
;;   Depending on the type of printer attached (i.e., Black and white or Color) 
;;   only one set of modules is made resident during the installation.		
;;										
;;   The set of print modules required is copied over the previous one at	
;;   location "PRINT_MODULE_START". This location is declared within            
;;   GRCOLPRT which must be linked before GRBWPRT				
;;										
;;   When copying one of the 2 sets of print modules we reserve enough space	
;;   for the larger of them. Therefore, if GRAPHICS is already installed but	
;;   is reinvoked with a different printer type which needs a bigger set of	
;;   modules: this new set of modules is simply recopied over the existing	
;;   one in the resident code.							
;;										
;;   The Shared Data area is copied rigth after the set of modules that we keep 
;;   that is, over the unused set of modules.					
;;										
;;										
;-------------------------------------------------------------------------------
;;										
;; Register Conventions:							
;;   BP - points to start of Temp Shared Data (Transiant code)			
;;										
;; Called By:									
;;   Entry point for GRAPHICS command processing.				
;;										
;; External Calls:								
;;   INT 2FH, LOAD_MESSAGES, LOAD_PROFILE, PARSE_PARMS				
;;   CHAIN_INTERRUPTS, COPY_SHARED_DATA, DISPLAY_MESSAGE			
;;   COPY_PRINT_MODULES 							
;;										
;-------------------------------------------------------------------------------
;;										
;; LOGIC:									
;;   Load the message retriever 						
;;   IF carry flag is set (incorrect DOS version) THEN				
;;	Issue message (COMMON1) 						
;;	Exit									
;;   ENDIF									
;;										
;;   Get number of bytes available in the segment from PSP (word 6)		
;;   /* This is needed since we construct a temporary Shared data area at the	
;;   of the .COM file */							
;;										
;;   /* Build Shared Data in temporary area */					
;;   END_OF_RESIDENT_CODE := (end of .COM file) 				
;;   NB_FREE_BYTES    := Number of bytes availables				
;;										
;;   CALL PARSE_PARMS								
;;   IF error THEN	/* PARSE_PARMS will issue messages */			
;;	Exit									
;;   ENDIF									
;;										
;;   CALL LOAD_PROFILE								
;;   IF profile errors THEN							
;;	Exit		/* LOAD_PROFILE will issue messages */			
;;   ENDIF									
;;										
;;   Issue INT 2FH Install Check call (AX=AC00H)				
;;   /* INT 2FH returns ES:[DI] pointing to the shared data area */		
;;   IF already installed THEN							
;;   THEN									
;;	Move NO to PRINT_SCREEN_ALLOWED in resident Shared Data 		
;;	SHARED_DATA_AREA_PTR := DI						
;;   ELSE									
;;	MOV PRINT_SCREEN_ALLOWED,NO						
;;	CALL CHAIN_INTERRUPTS	/* Install INT 5 and INT 2FH vectors */ 	
;;	ES := Our segment							
;;   ENDIF									
;;   /* Keep only Print Black and White or Print Color: */			
;;   CALL COPY_PRINT_MODULES							
;;	/* COPY_SHARED_DATA will terminate & stay resident */			
;;	Set up registers for copy & terminate call				
;;	/* reserve enough memory to handle any printer in the profile*/ 	
;;	jump to COPY_SHARED_DATA module 					
;;   ELSE									
;;	/* Shared Data has been built in place */				
;;	move YES to PRINT_SCREEN_ALLOWED					
;;	Return to DOS								
;;   ENDIF									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
GRAPHICS_INSTALL     PROC NEAR		;					
										
;-------------------------------------------------------------------------------
; Load the error messages							
;-------------------------------------------------------------------------------
   CALL    SYSLOADMSG		    ; Load messages				
  .IF C 			    ; If error when loading messages		
  .THEN 			    ; then,					
     MOV     CX,0		    ;	CX := No substitution in message	
     MOV     AX,1		    ;	AX := msg nb. for "Invalid DOS version" 
     CALL DISP_ERROR		    ;	Display error message			
     JMP     ERROR_EXIT 	    ;	 and quit				
  .ENDIF									
										
;-------------------------------------------------------------------------------
; Get offset of where to build the TEMPORARY Shared Data area (always built)	
;-------------------------------------------------------------------------------
   MOV	   BP,OFFSET LIMIT	     ; Build it at the end of this .COM file	
				     ;	(LIMIT = the offset of the last byte	
				     ;	  of the last .OBJ file linked with	
				     ;	   GRAPHICS)				
   MOV	   TEMP_SHARED_DATA_PTR,BP   ;						
										
;-------------------------------------------------------------------------------
; Determine if GRAPHICS is already installed; get the resident segment value	
;-------------------------------------------------------------------------------
    MOV     AH,PRT_SCR_2FH_NUMBER    ; Call INT 2FH (the Multiplex interrupt)	
    XOR     AL,AL		     ;	for Print Screen handler		
    INT     2FH 		     ;						
										
   .IF <AH EQ 0FFH>		     ; IF already installed			
   .THEN			     ; then,					
   ;----------------------------------------------------------------------------
   ; GRAPHICS is already installed: Get pointer to the EXISTING Shared Data area
   ;----------------------------------------------------------------------------
      MOV     INSTALLED,YES	    ;	Say it's installed                      
      MOV     AX,ES		    ;	Get the segment and offset of the	
      MOV     SHARED_DATA_AREA_PTR,DI;	 resident Shared Data area.		
      MOV     RESIDENT_CODE_SEG,AX  ;	  (returned in ES:DI)			

      MOV  AX,ES:[DI].SD_TOTAL_SIZE ; CX := Size of the existing Shared area	
      MOV  MAX_BLOCK_END, AX

				    ;	Disable print screen because we will	
      MOV     ES:PRINT_SCREEN_ALLOWED,NO ; be updating the resident code.	
   .ELSE			    ; ELSE, not installed:			
   ;------------------------------------------------------------------------	
   ; GRAPHICS is NOT installed: RESIDENT shared data area is in OUR segment	
   ;------------------------------------------------------------------------	
      PUSH    CS		    ; The Shared Data area will be in our	
      POP     RESIDENT_CODE_SEG     ;  segment. 				
   .ENDIF									
;-------------------------------------------------------------------------------
; Determine in AX how many bytes are available for building the TEMPORARY SHARED
; DATA AREA:									
;-------------------------------------------------------------------------------

;   MOV     AX,ES:BYTES_AVAIL_PSP_OFF;AX := Number of bytes availables in	
				    ;  the current segment (as indicated in PSP)
;M000;    mov     ax,0FFFFh		    ; Assume available to top of seg
;M000;
;Check for amount of memory that is free without assuming 64K. This causes
;crashes if it is loaded into UMBs.
;
	push	cx
	mov	ax,offset Limit
	add	ax,15
	mov	cl,4
	shr	ax,cl			;round up to nearest para
	mov	cx,es			;get our PSP seg
	add	ax,cx			;end of load image
	sub	ax,es:[2]		;es:[2] = top of our memory block
	neg	ax			;ax = # of paras free
	test	ax,0f000h		;greater than 64K bytes?
	jz	lt64K			;no
	mov	ax,0ffffh		;stop at 64K
	jmp	short gotfree
lt64K:
	mov	cl,4
	shl	ax,cl			;ax = # of bytes free above us
gotfree:
	pop	cx
;
;M000; End changes;
;

;;;   .IF	<AX B <OFFSET LIMIT>>	    ; If there is no bytes available past	
;;;   .THEN			    ;	the end of our .COM file		
;;;      XOR     AX,AX		    ; then, AX := 0 bytes available		
;;;   .ELSE			    ;						
;;;      SUB     AX,OFFSET LIMIT	    ; else,  AX := Number of FREE bytes 	
;;;   .ENDIF			    ;	     in this segment			
										
;---AX = Number of bytes in our segment available for building the Temp Shared	
;---data area.									
;---IF ALREADY INSTALLED: Get the size of the existing Shared data area.	
;---Since the temporary shared data area will be copied over the resident	
;---shared data area, we do not want to build it any bigger than the one	
;---it will overwrite. Therefore we do not give to LOAD_PROFILE more space	
;---than the size of the existing Shared data area.				
   .IF <INSTALLED EQ YES>	    ; If already installed then,		
   .THEN									
      PUSH CS:RESIDENT_CODE_SEG     ; ES:[DI] := Resident Shared data area	
      POP  ES			    ;						
      MOV  DI,SHARED_DATA_AREA_PTR  ;						
      MOV  CX,ES:[DI].SD_TOTAL_SIZE ; CX := Size of the existing Shared area	
      MOV  RESIDENT_SHARED_DATA_SIZE,CX ; Save size for LOAD_PROFILE		
     .IF <AX A CX>		    ; If AX > size of existing SDA		
	MOV AX,CX		    ; then, AX := Size of existing Shared area	
     .ENDIF			    ;						
   .ENDIF									
				    ;  NB_FREE_BYTES := Number of bytes 	
    MOV     NB_FREE_BYTES,AX	    ;	available for				
				    ;	 building the TEMPORARY shared area	
;-------------------------------------------------------------------------------
; Parse the command line parameters						
;-------------------------------------------------------------------------------
   MOV	   BYTE PTR CS:[BP].SWITCHES,0 ; Init. the command line switches	
   PUSH    CS			   ; Set ES to segment containing the PSP	
   POP	   ES									
   CALL    PARSE_PARMS		   ; Set switches in the Temp. Shared Area	
  .IF C 			   ; If error when parsing the command		
    .THEN			   ; line then, EXIT				
     JMP     ERROR_EXIT 							
  .ENDIF									
;-------------------------------------------------------------------------------
; Parse the printer profile - Build the temporary Shared data area		
;-------------------------------------------------------------------------------
 CALL  LOAD_PROFILE	            ;  Builds profile info in Temporary Shared	
				    ;	Data					
   .IF C			    ; If error when loading the profile 	
   .THEN			    ; then, EXIT				
      JMP     ERROR_EXIT							
   .ENDIF									
										
;-------------------------------------------------------------------------------
; Check if /B was specified with a BLACK and WHITE printer:(invalid combination)
;-------------------------------------------------------------------------------
   .IF <CS:[BP].PRINTER_TYPE EQ BLACK_WHITE> AND				
   .IF <BIT CS:[BP].SWITCHES NZ BACKGROUND_SW>					
   .THEN									
      MOV     AX,INVALID_B_SWITCH     ; Error := /B invalid with B&W prt.	
      MOV     CX,0		      ; No substitution 			
      CALL    DISP_ERROR	      ; Display error message			
      JMP     SHORT ERROR_EXIT	      ;  and quit				
   .ENDIF									
										
;-------------------------------------------------------------------------------
;										
; RELOCATE THE TEMPORARY SHARED DATA AREA AND THE SET OF REQUIRED PRINT MODULES 
;										
; (Discard the set of print modules not needed with the printer attached and	
;  discard all the code not used at print screen time). 			
;										
; If GRAPHICS is already installed then, we copy the				
; Shared Data area and the print modules over the previous ones installed in	
; resident memory.								
;										
; If we are installed for the first time then, we copy those over the		
; installation modules before we exit and stay resident.			
;										
; A temporaty Shared Data area is always created even if a resident one 	
; already exist (it is then, copied over), a set of print modules is recopied	
; only if needed.								
;										
; NOTE: END_OF_RESIDENT_CODE points to the first location over which code	
;	may be relocated.  After data or code is relocated, END_OF_RESIDENT_CODE
;	is updated and points to the next available location for copying code	
;	that will stay resident.						
;-------------------------------------------------------------------------------
;-------------------------------------------------------------------------------
; Initialize the pointer to the next available location for resident code:	
;-------------------------------------------------------------------------------
   .IF <INSTALLED EQ NO>	    ; If not installed				
   .THEN			    ; then,					
      MOV     END_OF_RESIDENT_CODE,OFFSET PRINT_MODULE_START			
   .ENDIF			    ;	we make everything up to the print	
				    ;	 modules resident code. 		
;-------------------------------------------------------------------------------
; Keep only the set of print modules that is needed:				
;-------------------------------------------------------------------------------
    CALL    COPY_PRINT_MODULES	    ; Updates END_OF_RESIDENT_CODE		
;-------------------------------------------------------------------------------
; Replace the interrupt vectors and install the EGA dynamic area (if needed)	
;-------------------------------------------------------------------------------
   .IF <INSTALLED EQ NO>	    ; If not already installed			
   .THEN			    ; then,					
;------Release evironment vector						;AN002;
      CALL RELEASE_ENVIRONMENT	    ;	release unneeded environment vector	;AN002;
;------Replace the interrupt vectors						
      MOV   PRINT_SCREEN_ALLOWED,NO ;	Disable Print Screen			
      CALL  CHAIN_INTERRUPTS	    ;	Replace the interrupt vectors		
				    ;	 (END_OF_RESIDENT_CODE is updated)	
      CALL  DET_HW_CONFIG	    ;	Find what display adapter we got	
     .IF <CS:[BP].HARDWARE_CONFIG EQ EGA>;If EGA is present			
     .THEN			    ;	then,					
	 CALL INST_EGA_SAVE_AREA    ;	  Install the EGA dynamic save area	
     .ENDIF			    ;	  (END_OF_RESIDENT_CODE is updated)	
;------Calculate the size of the resident code					
      MOV   DX,END_OF_RESIDENT_CODE ; DX := End of resident code		
      ADD   DX,CS:[BP].SD_TOTAL_SIZE; Add size of Shared Data area		
      MOV   CL,4		    ;						
      SHR   DX,CL		    ; convert to paragraphs			
      INC   DX			    ;  and add 1				
;------Set AX to DOS exit function call - (COPY_SHARED_DATA will exit to DOS)	
      MOV   AH,31H		    ; Function call to terminate but stay	
      XOR   AL,AL		    ;	resident				
   .ELSE									
      MOV   AH,4CH		    ; Function call to terminate		
      XOR   AL,AL		    ; (EXIT to calling process) 		
   .ENDIF									
										
;-------------------------------------------------------------------------------
; Copy the temporary shared data area in the resident code			
;-------------------------------------------------------------------------------
    MOV     CX,CS:[BP].SD_TOTAL_SIZE; CX := MOVSB count for COPY_SHARED_DATA	
    MOV     SI,BP		    ; DS:SI := Temporary Shared data area	
    PUSH    RESIDENT_CODE_SEG	    ; ES:DI := Resident Shared data area:	
    POP     ES			    ;						
   .IF <INSTALLED EQ NO>	    ; If not installed				
   .THEN			    ; then,					
      MOV     DI,END_OF_RESIDENT_CODE;	 DI := End of resident code		
      MOV     BP,DI		    ;	BP := New resident Shared data area	
      MOV     SHARED_DATA_AREA_PTR,DI;	 Update pointer to resident Shar. area	
   .ELSE			    ; else,					
      MOV     DI,SHARED_DATA_AREA_PTR ;   DI := Existing Shared data area	
      MOV     BP,DI		    ;	BP = DI:= Existing Shared data area	
   .ENDIF									
      JMP   COPY_SHARED_DATA	    ; Jump to proc that copies area in new	
				    ;  part of memory and exits to DOS		
ERROR_EXIT:									
   .IF <INSTALLED EQ YES>	    ; If we are already installed, re-enable	
      MOV   ES,RESIDENT_CODE_SEG    ;  print screens				
      MOV   ES:PRINT_SCREEN_ALLOWED,YES 					
   .ENDIF			    ;						
				    ;						
    MOV     AH,4CH		    ; Function call to terminate		
    MOV     AL,1		    ; (EXIT to calling process) 		
    INT     21H 								
GRAPHICS_INSTALL     ENDP							
										
PAGE										
;===============================================================================
;										
; INST_EGA_SAVE_AREA : INSTALL A DYNAMIC SAVE AREA FOR THE EGA PALETTE REGISTERS
;										
;-------------------------------------------------------------------------------
;										
; INPUT:   DS			= Data segment for our code			
;	   END_OF_RESIDENT_CODE = Offset of the end of the resident code	
;										
; OUTPUT:  END_OF_RESIDENT_CODE is updated to point to the end of the code	
;				   that will stay resident.			
;	   SAVE_AREA_PTR in BIOS segment is updated.				
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Shared Data Area								
;;										
;; Description: 								
;;   ************* The EGA Dynamic Save Area will be built over top		
;;   **  NOTE	** of the profile loading modules (file GRLOAD.ASM)		
;;   ************* to avoid having to relocate this area just before		
;;   terminating.  This is safe since the maximum memory used is		
;;   288 bytes and the profile loading modules are MUCH larger than		
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		
;;   GRPRINT.ASM.								
;;										
;; BIOS will update the dynamic save area whenener it's aware the palette       
;; registers have been updated. 						
;;										
;; BIOS 4A8H		BIOS SAVE	       EGA DYNAMIC			
;; POINTER:		POINTER TABLE	       SAVE AREA			
;; Ŀ		Ŀ	       (16 first bytes are the 16	
;;    *>	     		EGA palette registers)		
;; 		Ĵ	       Ŀ			
;;			     *>Ĵ			
;;			Ĵ	       Ĵ			
;;				     	       Ĵ			
;;			Ĵ		     .				
;;				     		     .				
;;			Ĵ		     .	    256 bytes		
;;				     		     .				
;;			Ĵ		     .				
;;				     	       Ĵ			
;;			Ĵ	       Ĵ			
;;				     	       Ĵ			
;;			Ĵ	       Ĵ			
;;				     	       Ĵ			
;;				       			
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; External Calls:								
;;										
;; Logic:									
;;   IF EGA Dynamic Save Area NOT established THEN				
;;	  /* Required since default table is in ROM */				
;;	  IF Save Table is in ROM						
;;	     Replicate all the Save Area Table in resident RAM just before	
;;	      the Shared Data Area						
;;	  ENDIF 								
;;	  Allocate 256 bytes for EGA Dynamic Save Area just before the		
;;	  Shared Data Area							
;;	  Update END_OF_RESIDENT_CODE						
;;     ENDIF									
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
BIOS_SAVE_PTR	     EQU    4A8H       ;; Offset of the BIOS Save Ptr area	
SAVE_AREA_LEN	     EQU    8*4        ;; There are 8 pointers in the Save area 
EGA_DYNAMIC_LEN      EQU    256        ;; Length of the EGA dynamic save area	
; Standard default colours for the Enhanced Graphics Adapter: (rgbRGB values)	
; The following table is necessary in order to initialize the EGA DYNAMIC	
; SAVE AREA when creating it.							
EGA_DEFAULT_COLORS   DB     00h        ;; Black 				
		     DB     01h        ;; Blue					
		     DB     02h        ;; Green 				
		     DB     03h        ;; Cyan					
		     DB     04h        ;; Red					
		     DB     05h        ;; Magenta				
		     DB     14h        ;; Brown 				
		     DB     07h        ;; White 				
		     DB     38h        ;; Dark Grey				
		     DB     39h        ;; Light Blue				
		     DB     3Ah        ;; Light Green				
		     DB     3Bh        ;; Light Cyan				
		     DB     3Ch        ;; Light Red				
		     DB     3Dh        ;; Light Magenta 			
		     DB     3Eh        ;; Yellow				
		     DB     3Fh        ;; Bright white				
		     DB     00h        ;; OVERSCAN register			
										
INST_EGA_SAVE_AREA PROC NEAR							
PUSH	AX									
PUSH	CX									
PUSH	DX									
PUSH	SI									
PUSH	DI									
PUSH	ES									
;-------------------------------------------------------------------------------
; Get the BIOS save pointer table						
;-------------------------------------------------------------------------------
XOR	AX,AX			      ; ES := segment 0 			
MOV	ES,AX									
LES	SI,ES:DWORD PTR BIOS_SAVE_PTR ; ES:[SI] =Current BIOS save table	
.IF <<WORD PTR ES:[SI]+4> EQ 0> AND   ; IF the dynamic save are pointer is	
.IF <<WORD PTR ES:[SI]+6> EQ 0>       ;  null then, it's not defined            
.THEN				      ;   and we have to define it:		
    ;---------------------------------------------------------------------------
    ; The Dynamic EGA save area is NOT DEFINED: 				
    ;---------------------------------------------------------------------------
     MOV   BYTE PTR ES:[SI]+4,0FFH    ; Try to write a byte in the table	
     PUSH  AX			      ; (PUSH AX, POP AX used to create a	
     POP   AX			      ;  small delay)				
    .IF <<WORD PTR ES:[SI]+4> NE 0FFH>;If we can't read our byte back then,     
    .THEN			      ;  the Save Ptrs table is in ROM		
       ;------------------------------------------------------------------------
       ; The Save pointer table is in ROM;					
       ; Copy the BIOS save pointer table from ROM to within our .COM file	
       ;------------------------------------------------------------------------
	PUSH  ES		      ; DS:SI := Offset of BIOS save ptrs table 
	POP   DS		      ; 					
	PUSH  CS		      ; ES:DI := The next available location	
	POP   ES		      ; 	  for installing resident code	
	MOV   DI,CS:END_OF_RESIDENT_CODE ;	   within our .COM file 	
	MOV   CS:OUR_SAVE_TAB_OFF,DI  ; 					
	MOV   CX,SAVE_AREA_LEN	      ;     CX := Length of the table to copy	
	REP   MOVSB		      ;  Replicate the Save Table		
	PUSH  CS								
	POP   DS		      ; Reestablish our data segment		
       ;------------------------------------------------------------------------
       ; Adjust END_OF_RESIDENT_CODE to the next offset available for copying	
       ; resident code and data.						
       ;------------------------------------------------------------------------
	ADD   END_OF_RESIDENT_CODE,SAVE_AREA_LEN				
       ;------------------------------------------------------------------------
       ; Set the pointer in OUR Save ptr table to our EGA dynamic save area	
       ; which we create right after the Save pointer table.			
       ;------------------------------------------------------------------------
	MOV	DI,OUR_SAVE_TAB_OFF    ; DS:[DI] := Our BIOS save ptr tab	
	MOV	AX,END_OF_RESIDENT_CODE; Store its offset			
	MOV	DS:[DI]+4,AX	       ;					
	MOV	WORD PTR DS:[DI]+6,DS  ; Store its segment			
       ;------------------------------------------------------------------------
       ; Initialize our DYNAMIC SAVE AREA with the 16 standard EGA colors	
       ;------------------------------------------------------------------------
										
	LEA  SI,EGA_DEFAULT_COLORS	; DS:[SI] := EGA 16 Default colors	
	MOV  DI,END_OF_RESIDENT_CODE	; ES:[DI] := DYNAMIC SAVE AREA		
	MOV  CX,17			; CX := Number of colors		
	REP  MOVSB			; Initialize the Dynamic save area	
       ;------------------------------------------------------------------------
       ; Set the BIOS Save Pointer to our table of Save pointers:		
       ;------------------------------------------------------------------------
	CLI									
	XOR	AX,AX		       ; ES:BIOS_SAVE_PTR := Our save table:	
	MOV	ES,AX								
	MOV	AX,OUR_SAVE_TAB_OFF						
	MOV	ES:BIOS_SAVE_PTR,AX						
	MOV	ES:BIOS_SAVE_PTR+2,DS						
	STI									
    .ELSE			       ; ELSE save pointer table is in RAM	
       ;------------------------------------------------------------------------
       ; ELSE, the BIOS save pointer table is in RAM:				
       ;------------------------------------------------------------------------
       ;------------------------------------------------------------------------
       ; Set the pointer in THEIR Save ptr table to OUR EGA dynamic save area	
       ;------------------------------------------------------------------------
	MOV   WORD PTR ES:[SI]+6,DS    ; ES:[SI] = The existing table in RAM	
	MOV   AX,END_OF_RESIDENT_CODE						
	MOV   ES:[SI]+4,AX							
    .ENDIF			       ; ENDIF save pointer table is in ROM	
  ;-----------------------------------------------------------------------------
  ; Adjust END_OF_RESIDENT_CODE to the next offset available for copying	
  ; resident code and data.							
  ;-----------------------------------------------------------------------------
   ADD	END_OF_RESIDENT_CODE,EGA_DYNAMIC_LEN					
.ENDIF										
POP	 ES									
POP	 DI									
POP	 SI									
POP	 DX									
POP	 CX									
POP	 AX									
										
RET										
OUR_SAVE_TAB_OFF DW	?							
INST_EGA_SAVE_AREA ENDP 							
PAGE										
;===============================================================================
;										
; CHAIN_INTERRUPTS : INSTALL INT 5 ,INT 10 AND INT 2FH VECTORS				
;										
;-------------------------------------------------------------------------------
;										
; INPUT:   DS			= Data segment for our code			
;	   END_OF_RESIDENT_CODE = Offset of the end of the resident code	
;										
; OUTPUT:  OLD_INT_2FH		  (within INT_2FH_DRIVER)			
;	   BIOS_INT_5H		  (within PRT_SCR module)			
; 	   OLD_INT_10H
;	   END_OF_RESIDENT_CODE is updated to point to the end of the code	
;				   that will stay resident.			
;	   SAVE_AREA_PTR in BIOS segment is updated if an EGA adapter is found	
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Shared Data Area								
;;										
;; Description: 								
;;   Install Interrupts 5 ,10 and 2FH. The old vectors are saved.
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; External Calls:								
;;   DOS INT 21H Replace vector AH=25h						
;;   DOS INT 21H Get vector AH=35h						
;;										
;; Logic:									
;;   Save interrupt 5 vector in BIOS_INT_5H					
;;   Point interrupt 5 to PRT_SCR module					
;;   Save interrupt 2FH vector in BIOS_INT_2FH					
;;   Point interrupt 2FH to INT_2FH_DRIVER module				
;;   Save interrupt 10h vector in OLD_INT_10h
;;   point interrupt 10h to INT_10H_DRIVER
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
				       ;;					
CHAIN_INTERRUPTS  PROC NEAR	       ;;					
	PUSH	ES								
	PUSH	BX								
										
;-------------------------------------------------------------------------------
; Replace INTERRUPT 5 vector							
;-------------------------------------------------------------------------------
	MOV	AX,3505H		; Get vector for int 5 request
	INT	21H			; Call DOS				

	MOV	CS:BIOS_INT_5H,BX	; Save the old vector
	MOV	CS:BIOS_INT_5H+2,ES			
						
	MOV	DX,OFFSET PRT_SCR	; DS:DX := Offset of our Print Screen

	MOV	AX,2505H		; Replace vector for int 5 request
	INT	21H			; Call DOS	
										
;-------------------------------------------------------------------------------
; Replace INTERRUPT 2FH vector							
;-------------------------------------------------------------------------------
	MOV	AX,352FH		; Get vector for int 2FH request
	INT	21H			; Call DOS				
										
	MOV	WORD PTR OLD_INT_2FH,BX ; Save the old vector			
	MOV	WORD PTR OLD_INT_2FH+2,ES					
										
	MOV	DX,OFFSET INT_2FH_DRIVER; DS:DX := Offset of our 2FH handler	
										
	MOV	AX,252FH		; Replace vector for int 2FH request
	INT	21H			; Call DOS				
; /* M001 BEGIN */
;------------------------------------------------------------------------------
; Replace INTERRUPT 10 vector						
;------------------------------------------------------------------------------
	MOV	AX,3510H		; Get vector for int10h request
	INT	21H			; Call DOS	
						
	MOV	WORD PTR OLD_INT_10H,BX ; Save the old vector
	MOV	WORD PTR OLD_INT_10H+2,ES		
						
	MOV	DX,OFFSET INT_10H_DRIVER; DS:DX := Offset of our 2FH handler
				
	MOV	AX,2510H		; Replace vector for int10H request
	INT	21H			; Call DOS	
; /* M001 END */
						
	POP	BX			
	POP	ES		
	RET		

CHAIN_INTERRUPTS  ENDP	
;===============================================================================
;										
; COPY_PRINT_MODULES: COPY THE SET OF PRINT MODULES NEEDED OVER THE PREVIOUS ONE
;										
;-------------------------------------------------------------------------------
;										
; INPUT:  BP		       = Offset of the temporary Shared Data area	
;	  END_OF_RESIDENT_CODE = Location of the set of COLOR modules		
;				 (if first time installed)			
;	  CS:[BP].PRINTER_TYPE = Printer type NEEDED				
;	  RESIDENT_CODE_SEG    = Segment containing the resident code		
;										
; OUTPUT: END_OF_RESIDENT_CODE = End of the print modules IS UPDATED		
;				 (If first time installed)			
;										
;-------------------------------------------------------------------------------
;;										
;; Data Structures Referenced:							
;;   Control Variables								
;;   Shared Data Area								
;;										
;; Description: 								
;;   This module trashes one set of print modules (Color or Black & White)	
;;   depending on the type of printer attached.  Since the Shared Data		
;;   (resident version) will reside immediately after the print modules,	
;;   END_OF_RESIDENT_CODE will be set by this modules.				
;;										
;;   The set of COLOR modules is already at the rigth located when installing	
;;   GRAPHICS for the first time. This is true since, the color modules are	
;;   linked before the black and white modules. 				
;;										
;;   Therefore, if we are installing GRAPHICS for the first time and we need	
;;   the color modules then, we do not need to relocate any print modules.	
;;										
;;   When installing GRAPHICS again we first check what is the resident set,	
;;   we recopy a new set only if needed.					
;;										
;; Called By:									
;;   GRAPHICS_INSTALL								
;;										
;; Logic:									
;;   IF color printer THEN							
;;	SI := Offset of BW_PRINT_MODULES					
;;   ELSE									
;;	SI := Offset of COLOR_PRINT_MODULES					
;;   ENDIF									
;;   REP MOVSB		; Copy the set of modules				
;;   END_OF_RESIDENT_CODE := end of the set of modules				
;;   RETURN									
;;										
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					
COPY_PRINT_MODULES  PROC NEAR							
	PUSH	AX								
	PUSH	BX								
	PUSH	CX								
	PUSH	SI								
	PUSH	DI								
	PUSH	ES								
										
;-------------------------------------------------------------------------------
; Determine if we need to relocate the set of print modules, if so, set the	
; source address (DS:SI), the destination address (ES:DI) and the number of	
; bytes to copy (CX).								
;-------------------------------------------------------------------------------
   PUSH    CS:RESIDENT_CODE_SEG 	; ES := Segment containing the resident 
   POP	   ES				;	 code  (Where to copy modules)	
   MOV	   DI,OFFSET PRINT_MODULE_START ; ES:[DI] := Resident print modules	
										
  .IF <INSTALLED EQ NO> 		; IF not installed			
  .THEN 				; THEN, 				
					;   We relocate the print modules	
					;    at the end of the resident code:	
					;     (this is where the color set is)	
     .IF <CS:[BP].PRINTER_TYPE EQ BLACK_WHITE> ; IF we don't want the color set 
     .THEN				;   THEN,				
	MOV NEED_NEW_PRINT_MODULES,YES	;     Say we need new modules		
	MOV SI,OFFSET PRINT_BW_APA	;     DS:[SI] := Black and white modules
	MOV CX,LEN_OF_BW_MODULES	;     CX      := Length of B&W modules	
     .ENDIF				;					
										
  .ELSE 				; ELSE, (We are already installed)	
      MOV     BX,SHARED_DATA_AREA_PTR	;   BX := Offset of Shared Data area	
      MOV     AL,ES:[BX].PRINTER_TYPE	;   AL := Type of the resident set	
     .IF <AL NE CS:[BP].PRINTER_TYPE>	;   IF resident set is not the one	
     .THEN				;   we need THEN,			
	MOV NEED_NEW_PRINT_MODULES,YES	;     Say we need a new set.		
       .IF <CS:[BP].PRINTER_TYPE EQ COLOR>;   IF its color we need then,	
	  MOV SI,OFFSET PRINT_COLOR	;	DS:[SI] := Color set		
	  MOV CX,LEN_OF_COLOR_MODULES	;	CX	:= Length of color mod. 
       .ELSE				;     ELSE				
	  MOV SI,OFFSET PRINT_BW_APA	;	DS:[SI] := B&W set		
	  MOV CX,LEN_OF_BW_MODULES	;	CX	:= Length of B&W mod.	
       .ENDIF				;     ENDIF we need the color set	
     .ENDIF				;   ENDIF we need a new set		
  .ENDIF				; ENDIF we are not installed		
										
										
;-------------------------------------------------------------------------------
; If needed: Copy the required set of print modules				
;-------------------------------------------------------------------------------
  .IF <NEED_NEW_PRINT_MODULES EQ YES>						
  .THEN 									
     CLD			       ; Clear the direction flag		
     REP     MOVSB		       ; Copy the set of print modules		
  .ENDIF			       ; ENDIF needs to copy the print modules	
										
;-------------------------------------------------------------------------------
; Set END_OF_RESIDENT_CODE pointer to the end of the print modules:		
; (Reserve enough space to store the larger set of modules on a 		
;  subsequent install)								
;-------------------------------------------------------------------------------
  .IF <INSTALLED EQ NO> 		; IF first time installed		
  .THEN 				; THEN, 				
     MOV     CX,LEN_OF_COLOR_MODULES	;   Adjust END_OF_RESIDENT_CODE to	
    .IF <CX G LEN_OF_BW_MODULES>	;   contains the larger set of modules. 
    .THEN				;					
       ADD     END_OF_RESIDENT_CODE,LEN_OF_COLOR_MODULES			
    .ELSE									
       ADD     END_OF_RESIDENT_CODE,LEN_OF_BW_MODULES				
    .ENDIF				;					
  .ENDIF									
										
	POP ES									
	POP DI									
	POP SI									
	POP CX									
	POP BX									
	POP AX									
	RET									
NEED_NEW_PRINT_MODULES DB   NO		; True if print modules needed must be	
					;  copied over the other set of print	
					;   modules				
COPY_PRINT_MODULES  ENDP							
										;AN002;
PAGE										;AN002;
;===============================================================================;AN002;
;										;AN002;
; PROCEDURE_NAME: RELEASE_ENVIRONMENT						;AN002;
;										;AN002;
; INPUT:  None. 								;AN002;
;										;AN002;
; OUTPUT: Environment vector released.						;AN002;
;										;AN002;
;-------------------------------------------------------------------------------;AN002;
RELEASE_ENVIRONMENT PROC NEAR							;AN002;
	PUSH	AX			; save regs				;AN002;
	PUSH	BX								;AN002;
	PUSH	ES								;AN002;
	MOV	AH,62H			; function for get the PSP segment	;AN002;
	INT	21H			; invoke INT 21h			;AN002;
	MOV	ES,BX			; BX contains PSP segment - put in ES	;AN002;
	MOV	BX,WORD PTR ES:[2CH]	; get segment of environmental vector	;AN002;
	MOV	ES,BX			; place segment in ES for Free Memory	;AN002;
	MOV	AH,49H			; Free Allocated Memory function call	;AN002;
	INT	21H			; invoke INT 21h			;AN002;
	POP	ES			; restore regs				;AN002;
	POP	BX								;AN002;
	POP	AX								;AN002;
	RET									;AN002;
RELEASE_ENVIRONMENT ENDP							;AN002;
										
PAGE										
;===============================================================================
;										
; PROCEDURE_NAME: DISP_ERROR							
;										
; INPUT:  AX := GRAPHICS message number (documented in GRMSG.EQU)		
;	  CX := Number of substitutions (Needed by SYSDISPMSG)			
;	  DS:[SI] := Substitution list (needed only if CX <> 0) 		
;										
; OUTPUT: Error message is displayed on STANDARD ERROR OUTPUT (STDERR)		
;										
;-------------------------------------------------------------------------------
DISP_ERROR    PROC   NEAR							
	PUSH	BX								
	PUSH	DI								
	PUSH	SI								
	PUSH	BP								
										
	MOV	BX,ERROR_DEVICE    ; Issue message to standard error		
	XOR	DL,DL		   ; No input					
	MOV	DH,UTILITY_MSG_CLASS;It's one of our messages                   
	CALL	SYSDISPMSG	   ; display error message			
										
	POP	BP								
	POP	SI								
	POP	DI								
	POP	BX								
	RET									
DISP_ERROR    ENDP								

include msgdcl.inc										
										
CODE   ENDS									
       END									


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grparms.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Command line parsing module	;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                   
;;										;AN000;
;; File Name:  GRPARMS.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;										;AN000;
;;	 This file contains modules for parsing the GRAPHICS.COM		;AN000;
;;	 command line; using the DOS PARSER.					;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;	 DOS 3.3 Message Retriever Interface Supplement. 			;AN000;
;;	 TUPPER I0 Document - PARSER HIGH LEVEL DESIGN REVIEW			;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 PARSE_PARMS	  - Parse the command line				;AN000;
;;	 GET_R		  - Get /R						;AN000;
;;	 GET_B		  - Get /B						;AN000;
;;	 GET_LCD	  - Get /LCD						;AN000;
;;	 GET_PRINTBOX	  - Get /PRINTBOX					;AN000;
;;	 GET_PROFILE	  - Get the profile path and file name			;AN000;
;;	 GET_TYPE	  - Get the printer type				;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 GRINST.EXT  - Externals for installation modules			;AN000;
;;	 GRPARSE.EXT - Externals for the DOS parser code			;AN000;
;;	 GRSHAR.STR  - Shared Data Area Structure				;AN000;
;;	 GRMSG.EQU   - Equates for GRAPHICS.COM error messages			;AN000;
;;	 STRUC.INC   - Macros for using structured assembly language		;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 FROM FILE  GRINST.ASM: 						;AN000;
;;	      GRAPHICS_INSTALL - Main module for the installation of GRAPHICS	;AN000;
;;	 SYSPARSE - DOS system parser						;AN000;
;;	 SYSDISPMSG - DOS message retriever					;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME	CS:CODE,DS:CODE 						;AN000;

PARSE_PARMS PROC NEAR								;AN000;
	jmp	PARSE_PARMS_START						;AN000;
PUBLIC PARSE_PARMS								;AN000;

	EXTRN	ERROR_DEVICE: WORD	; grinst.asm

.XLIST										;AN000;
INCLUDE GRMSG.EQU		; Include GRAPHICS error messages equates	;AN000;
INCLUDE GRSHAR.STR		; Include the Shared data area structure	;AN000;
INCLUDE GRINST.EXT		; Include externals for the installation module ;AN000;
INCLUDE GRPARSE.EXT		; Include externals for the DOS parse code	;AN000;
INCLUDE STRUC.INC		; Include macros for using STRUCTURES		;AN000;
.LIST										;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PARSE_PARMS : PARSE THE COMMAND LINE PARAMETERS.				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
;	INPUT:	DS,ES		= SEGMENT CONTAINING THE PROGRAM PREFIX SEGMENT ;AN000;(PSP)
;										;AN000;
;	OUTPUT: SWITCHES	= A bit mask in the shared data area indicating ;AN000;
;				  which command line switches are set.		;AN000;
;		PROFILE_PATH	= The profile file name and path (ASCIIZ string);AN000;
;		PRINTBOX_ID_PTR = Offset of the printbox id (ASCIIZ string)	;AN000;
;		PRINTER_TYPE_PARM = printer type (ASCIIZ string)		;AN000;
;		CARRY FLAG IS SET if an error occurred				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; DESCRIPTION: Call the DOS parser to parse the command line parameters 	;AN000;
; of the GRAPHICS  command line which is obtained from the PSP (Program Segment ;AN000;
; Prefix).									;AN000;
;										;AN000;
; The format of the command line is:						;AN000;
;										;AN000;
;										;AN000;
;	GRAPHICS  {prt_type {profile}}	 {/R}  {/B}  {[/LCD | /PRINTBOX:id]}	;AN000;
;										;AN000;
;	(All arguments are optional, /PRINTBOX can be spelled /PB.)		;AN000;
;										;AN000;
; If no printer type is specified then, a null pointer is returned.		;AN000;
; If no profile name is supplied then, a null string is returned.		;AN000;
; If "/LCD" is specified then, a pointer to the printbox id: "LCD" is returned. ;AN000;
;										;AN000;
;										;AN000;
; LOGIC:									;AN000;
; Set addressibility to the command line parameters in the PSP			;AN000;
; CALL SYSPARSE       ; Call the system parser					;AN000;
; While not (End Of Line) AND no error						;AN000;
;   IF argument is the profile name						;AN000;
;   THEN Get the profile name							;AN000;
;   IF argument is the printbox switch						;AN000;
;   THEN Get the printbox id							;AN000;
;   IF argument is a /r 							;AN000;
;   THEN Get /r 								;AN000;
;   IF argument is /b								;AN000;
;   THEN Get /b 								;AN000;
;   IF argument /lcd								;AN000;
;   THEN Get /lcd								;AN000;
;   CALL SYSPARSE								;AN000;
; If error									;AN000;
; Then display the appropriate error message					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; BIT MASK INDICATING THE COMMAND LINE SWITCHES PARSED SO FAR:			;AN000;
;-------------------------------------------------------------------------------;AN000;
SWITCH_PARSED DB   0								;AN000;
GOT_R	      EQU  1			; Found /R				;AN000;
GOT_B	      EQU  2			; Found /B				;AN000;
GOT_LCD       EQU  4			; Found /LCD				;AN000;
GOT_PRINTBOX  EQU  8			; Found /PB:id or /PRINTBOX:id		;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; CONTROL BLOCK DEFINITIONS FOR THE PARSER:					;AN000;
;										;AN000;
;===============================================================================;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; PARMS INPUT BLOCK								;AN000;
;-------------------------------------------------------------------------------;AN000;
PARMS LABEL WORD								;AN000;
	DW	PARMSX			; Offset of parms extension block	;AN000;
	DB	0			; No delimiters to define		;AN000;
					;  or end of line markers.		;AN000;
										;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; PARMS EXTENSION BLOCK : Describe what's on the command line                   ;AN000;
;-------------------------------------------------------------------------------;AN000;
PARMSX	LABEL BYTE								;AN000;
	DB	0,2			; Max. 2 positional parameters		;AN000;
	DW	TYPE_CTL		; Offset of type control block		;AN000;
	DW	PROF_CTL		; Offset of profile control block	;AN000;
										;AN000;
	DB	5			; Max. 4 switch types			;AN000;
	DW	PRINTBOX_CTL		; Offset of control for Printbox	;AN000;
	DW	R_CTL			; Offset of control for /R		;AN000;
	DW	B_CTL			; Offset of control for /B		;AN000;
	DW	LCD_CTL 		; Offset of control for /LCD		;AN000;
	DW	?_CTL                   ; offset of control for /?
										;AN000;
	DB	0			; No keywords				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the printer type parameter:						;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
TYPE_CTL LABEL	WORD								;AN000;
	DW	2001H		 ; Optional simple string			;AN000;
	DW	0002H		 ; Capitalize it				;AN000;
	DW	TYPE_RESULT	 ; Offset of result buffer for printer type	;AN000;
	DW	NO_VALUES	 ; No values (NOTE: The type returned is checked;AN000;
	DB	0		 ;		   for validity by LOAD_PROFILE);AN000;
										;AN000;
NO_VALUES	DB	0							;AN000;
										;AN000;
TYPE_RESULT	LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Pointer to string found			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of the PROFILE parameter: 				;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
PROF_CTL LABEL WORD								;AN000;
	DW	0201H		; File spec. - Optional 			;AN000;
	DW	0001h		; Capitalize					;AN000;
	DW	PROFILE_RESULT	; Offset of result buffer for Profile		;AN000;
	DW	NO_VALUES	; No values needed				;AN000;
	DB	0								;AN000;
										;AN000;
										;AN000;
PROFILE_RESULT	LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of string				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /R							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
R_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	R_RESULT	; Offset of result buffer for a simple switch	;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name for this switch			;AN000;
	DB	"/R",0          ;   Reverse                                     ;AN000;
										;AN000;
R_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;

;----------------------------------------------------------------------------
;			
; Describe the format of /?
;			
;----------------------------------------------------------------------------
?_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	?_RESULT	; Offset of result buffer for a simple switch
	DW	NO_VALUES	; No values can be given with these switches.
	DB	1		; 1 name for this switch	
	DB	"/?",0   
										;AN000;
?_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;

;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /B							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
B_CTL	LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	B_RESULT	; Offset of result buffer for a simple switch	;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name allowed for this switch		;AN000;
	DB	"/B",0          ;   Background                                  ;AN000;
										;AN000;
B_RESULT LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of /LCD							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
LCD_CTL LABEL WORD								;AN000;
	DW	0		;						;AN000;
	DW	0		;						;AN000;
	DW	LCD_RESULT	; Offset of result buffer for a /LCD		;AN000;
	DW	NO_VALUES	; No values can be given with these switches.	;AN000;
	DB	1		; 1 name:					;AN000;
	DB	"/LCD",0        ;  /LCD                                         ;AN000;
										;AN000;
LCD_RESULT  LABEL BYTE								;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; Describe the format of the PRINTBOX switch:					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PRINTBOX_CTL LABEL WORD 							;AN000;
	DW	2001H		; Optional simple string			;AN000;
	DW	0001H		; Capitalize					;AN000;
	DW	PRINTBOX_RESULT ; Offset of result buffer for Printbox		;AN000;
	DW	NO_VALUES	; Values will be validated when loading profile ;AN000;
	DB	2		; 2 synomym for this switch:			;AN000;
	DB	"/PRINTBOX",0   ;                                               ;AN000;
	DB	"/PB",0                                                         ;AN000;
										;AN000;
PRINTBOX_RESULT LABEL BYTE							;AN000;
	DB	?		; Type						;AN000;
	DB	?		; Item tag					;AN000;
	DW	?		; Offset of synomym				;AN000;
	DD	?		; Offset of value				;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; DOS "MESSAGE RETRIEVER" Substitution list control block:                      ;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
SUBLIST        LABEL DWORD		   ; List for substitution:		;AN000;
	       DB	11		   ; Size of this list			;AN000;
	       DB	0		   ; Reserved				;AN000;
SAVE_SI        DD	?		   ; Ptr to data item			;AN001;
	       DB	1		   ; Variable to be substitued: %1	;AN000;
	       DB	00010000B	   ; %1 is an ASCIIZ string left justifi;AN000;ed
	       DB	0		   ; Unlimited size for %1		;AN000;
	       DB	1		   ; Minimum size is 1 character	;AN000;
	       DB	" "                ; Delimiter is "space"               ;AN000;
										;AN000;
;===============================================================================;AN000;
;										;AN000;
; START OF EXECUTABLE CODE:							;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
										;AN000;
PARSE_PARMS_START:								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
	PUSH	ES								;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set up addressibility for the parser						;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	SI,81H			; DS:SI := Command line parameters	;AN000;
					;  to be parsed 			;AN000;
	PUSH	CS								;AN000;
	POP	ES								;AN000;
	LEA	DI,PARMS		; ES:DI := Parms control block		;AN000;
;(deleted ;AN001;) XOR DX,DX		; CX,DX must be zero for the		;AN000;
	XOR	CX,CX			; Initially, CX should be zero		;AN001;
	MOV	AX,0			; No error yet				;AN000;
;-------------------------------------------------------------------------------;AN000;
; Parse FIRST argument								;AN000;
;-------------------------------------------------------------------------------;AN000;
;(deleted ;AN001;) CALL SYSPARSE	; Get one argument from the command line;AN000;
	CALL	CALL_SYSPARSE		; Get one argument from the command line;AN001;
;(deleted ;AN001;) MOV BX,DX		; BX := Offset of result block		;AN000;
.WHILE <AX EQ RC_NO_ERROR>		; While there is no error		;AN000;
;-------------------------------------------------------------------------------;AN000;
; Get the argument:								;AN000;
;-------------------------------------------------------------------------------;AN000;
       .SELECT									;AN000;
       .WHEN <BX EQ <OFFSET ?_RESULT>>
          MOV	[ERROR_DEVICE], STDOUT       ; output to stdout
	  MOV	AX, MSG_OPTIONS_FIRST        ; number of first 'option' msg
	  XOR	CX, CX                       ; specify no subst
PRMORE:	  CALL  DISP_ERROR                   ; DISP_ERROR is a mistaken name
; in this case.  I use it because it is the existing routine for printing out
; messages, and it is named so because the only messages graphics would 
; display are error messages.  Hence disp_error writes out to STDERR.  I 
; could write another message-display interface to sysdispmsg, but this one 
; works fine, I just wanted to note that the name disp_error gives the wrong
; impression here.
	  INC	AX
	  CMP	AX, MSG_OPTIONS_LAST + 1     ; another msg to do
	  JB	PRMORE
          MOV	[ERROR_DEVICE], STDERR       ; set output back to stderr
	  STC                                ; pretend to have an error so
; that graphics now cleans up and goes home without further action
	  JMP   PPST
       .WHEN <BX EQ <OFFSET TYPE_RESULT>>					;AN000;
	  CALL	GET_TYPE							;AN000;
       .WHEN <BX EQ <OFFSET PROFILE_RESULT>>					;AN000;
	  CALL	GET_PROFILE_NAME						;AN000;
       .WHEN <BX EQ <OFFSET LCD_RESULT >>					;AN000;
	  CALL	GET_LCD 							;AN000;
       .WHEN <BX EQ <OFFSET R_RESULT>>						;AN000;
	  CALL	GET_REVERSE							;AN000;
       .WHEN <BX EQ <OFFSET B_RESULT>>						;AN000;
	  CALL	GET_BACKGROUND							;AN000;
       .WHEN <BX EQ <OFFSET PRINTBOX_RESULT>>					;AN000;
	  CALL	GET_PRINTBOX_ID 						;AN000;
       .OTHERWISE								;AN000;
;-------No result block was returned by the parser				;AN000;
	STC				; Set error				;AN000;
       .ENDSELECT								;AN000;
       .LEAVE C 			; IF error occurred while parsing the	;AN000;
					;  previous argument, exit the loop:	;AN000;
					;   stop parsing the command line.	;AN000;
;-------------------------------------------------------------------------------;AN000;
; Parse next argument:								;AN000;
;-------------------------------------------------------------------------------;AN000;
;(deleted ;AN001;) XOR DX,DX		;					;AN000;
;(deleted ;AN001;) CALL SYSPARSE	; Get one argument from the command line;AN000;
	CALL	CALL_SYSPARSE		; Get one argument from the command line;AN001;
;(deleted ;AN001;) MOV BX,DX		; ES:BX := Offset of result block	;AN000;
.ENDWHILE									;AN000;

;-------------------------------------------------------------------------------;AN000;
; Check for error, select and display an error message				;AN000;
;-------------------------------------------------------------------------------;AN000;
.IF <AL NE RC_EOL>			; IF an error occurred			;AN000;
.THEN					; then, display error message		;AN000;
    MOV 	CX,0			; Assume no substitutions		;AN000;
   .SELECT				; (CX := Number of substitutions	;AN000;
   .WHEN <AL EQ RC_TOO_MANY>		; When RC = Too many parameters 	;AN000;
	MOV	AX,TOO_MANY_PARMS	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_Not_In_Val>		; When RC = Not in value list provided	;AN000;
	MOV	AX,VALUE_NOT_ALLOWED	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_Not_In_Sw>		; When RC = Not in switch list provided ;AN000;
	MOV	CX,1			;   1 substitution in this message	;AN000;
	MOV	BYTE PTR [SI],0 	; PUT NUL AT END OF THIS PARM		;AN001;
	LEA	SI,SUBLIST		;   DS:[SI]:="Invalid parm" Substitution;AN000; list
;(deleted ;AN001;) LES DX,ES:[BX+4]	;   ES:DX := Offset of offending parm.	;AN000;
;(deleted ;AN001;) MOV [SI]+2,DX	;   Store offset to this offender in the;AN000;
	MOV	[SI]+4,ES		;    substitution list control block	;AN000;
	MOV	AX,INVALID_PARM 	;   AL := 'Invalid parameter' msg number;AN000;
   .WHEN <AL EQ RC_INVLD_COMBINATION>	; When RC = Invalid combination of parms;AN000;
	MOV	AX,INVALID_COMBINATION	;   (AL = Message number to display)	;AN000;
   .WHEN <AL EQ RC_DUPLICATE_PARMS>	; When RC = Invalid combination of parms;AN000;
	MOV	AX,DUPLICATE_PARM	;   (AL = Message number to display)	;AN000;
   .OTHERWISE				;					;AN000;
	MOV	AX,FORMAT_NOT_CORRECT	; RC = Anything else, tell the user	;AN000;
					;	something is wrong with his	;AN000;
   .ENDSELECT				;	 command line.			;AN000;
    CALL DISP_ERROR			; Display the selected error message	;AN000;
    STC 				; Indicate parse error occurred 	;AN000;
.ENDIF										;AN000;
										;AN000;
PPST:	POP	ES								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	RET				; Return to GRAPHICS_INSTALL		;AN000;
										;AN000;
PARSE_PARMS ENDP								;AN000;
CALL_SYSPARSE PROC NEAR 		;COMMON INVOCATION OF SYSPARSE		;AN001;
;INPUT: - CX=ORDINAL VALUE							;AN001;
;	  DS:SI=WHERE COMMAND LINE IS, SAVED IN "SAVE_SI"                       ;AN001;
;	  ES:DI=WHERE PARMS DESCRIPTOR BLOCK IS 				;AN001;
;OUTPUT:  CX=NEW ORDINAL VALUE							;AN001;
;	  BX=OFFSET OF RESULT BLOCK, IF ONE IS RETURNED 			;AN001;
;	  SI=OFFSET OF CHAR BEYOND PARSED PARM IN COMMAND LINE			;AN001;
										;AN001;
	XOR	DX,DX			;CLEAR DX FOR PARSER			;AN001;
	MOV	WORD PTR SAVE_SI,SI	;REMEMBER WHERE TO START LOOKING	;AN001;
	CALL	SYSPARSE		;GO PARSE THE NEXT PARM 		;AN001;
										;AN001;
	MOV	BX,DX			; BX := Offset of result block		;AN001;
	RET				;RETURN TO CALLER			;AN001;
CALL_SYSPARSE ENDP								;AN001;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_PROFILE							;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;										;AN000;
; OUTPUT: PROFILE_PATH = The profile file name and path (ASCIIZ string) 	;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_PROFILE_NAME PROC								;AN000;
	PUSH	AX								;AN000;
	PUSH	BX								;AN000;
	PUSH	DX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Get the name of the profile path found on the command line:			;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	DI,ES:[BX+4]	; DI := Offset of filename found		;AN000;
	XOR	BX,BX		; BX := Byte index				;AN000;
	MOV	SI,OFFSET PROFILE_PATH	; [BX][SI] := Where to store it 	;AN000;
										;AN000;
.IF <<BYTE PTR [DI]> NE 0>	; Don't copy a NULL parm                        ;AN000;
  .REPEAT			; While not end of path name (NULL terminated)	;AN000;
	MOV	AL,[BX][DI]	; Copy the byte (including the NULL)		;AN000;
	MOV	[BX][SI],AL							;AN000;
	INC	BX		; Get next one					;AN000;
  .UNTIL <<BYTE PTR [BX-1][DI]> EQ 0> ; 					;AN000;
.ENDIF										;AN000;
										;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	DX								;AN000;
	POP	BX								;AN000;
	POP	AX								;AN000;
	CLC									;AN000;
	RET									;AN000;
GET_PROFILE_NAME ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_TYPE							;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;	  PRINTER_TYPE_LENGTH := Maximum length for the printer type string	;AN000;
;										;AN000;
; OUTPUT: PRINTER_TYPE_PARM = ASCIIZ string containing				;AN000;
;			       the Printer type.				;AN000;
;	  AX		    = Error code					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_TYPE PROC									;AN000;
	PUSH	BX								;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;---------------------------------------------------------------------- 	;AN000;
; Overwrite the DEFAULT TYPE with the type found on the command line		;AN000;
;---------------------------------------------------------------------- 	;AN000;
  MOV	  SI,ES:[BX+4]		       ; DS:SI := Offset of printer type found	;AN000;
 .IF <<BYTE PTR [SI]> NE 0>	       ; Do not copy an empty string		;AN000;
 .THEN				       ;					;AN000;
    MOV     CL,PRINTER_TYPE_LENGTH     ; CX := Maximum number of bytes		;AN000;
    XOR     CH,CH		       ;	to copy 			;AN000;
    MOV     DI,OFFSET PRINTER_TYPE_PARM; ES:DI := Where to store it		;AN000;
    REP     MOVSB		       ; Copy the string			;AN000;
  ;----------------------------------------------------------------------	;AN000;
  ; Verify that the string supplied is not too long:				;AN000;
  ;----------------------------------------------------------------------	;AN000;
   .IF	<<BYTE PTR [DI-1]> EQ 0>       ; If the last byte is a null		;AN000;
   .THEN			       ; then, the string was not longer	;AN000;
				       ;       than the maximum 		;AN000;
      CLC			       ;   Clear the carry flag = No error	;AN000;
   .ELSE			       ; else, string provided is too long	;AN000;
      MOV  AX,RC_Not_In_Sw	       ;   Error := RC for Invalid parm 	;AN000;
      STC			       ; Set error				;AN000;
   .ENDIF			       ; ENDIF string too long			;AN000;
 .ENDIF 			       ; ENDIF string provided			;AN000;
										;AN000;
GET_TYPE_END:									;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	POP	BX								;AN000;
	RET									;AN000;
GET_TYPE  ENDP									;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_REVERSE							;AN000;
;										;AN000;
; INPUT:  ES:[BX]	:= Result block 					;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: CS:[BP].SWITCHES (Bit mask in the Shared data area) is updated	;AN000;
;			    with the value of the switch found. 		;AN000;
;	  GOT_R is set in SWITCH_PARSED 					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_REVERSE	PROC								;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_R		; If already parsed this switch ;AN000;
	JNZ	DUPLICATE_R			; then, error			;AN000;
	OR	SWITCH_PARSED,GOT_R		; else, say we parsed it.	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the Reverse switch in the Shared data area				;AN000;
;-------------------------------------------------------------------------------;AN000;
	OR	CS:[BP].SWITCHES,REVERSE_SW	; Set the command line switch	;AN000;
	CLC					; Clear the error flag		;AN000;
	JMP	SHORT GET_REVERSE_END		; Return			;AN000;
										;AN000;
DUPLICATE_R:					; Already got this switch	;AN000;
	MOV	AX,RC_DUPLICATE_PARMS		; AX := error message number	;AN000;
	STC					; SET ERROR			;AN000;
GET_REVERSE_END:								;AN000;
										;AN000;
	RET									;AN000;
GET_REVERSE	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_BACKGROUND						;AN000;
;										;AN000;
; INPUT:  ES:[BX] := Result block						;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: CS:[BP].SWITCHES (Bit mask in the Shared data area) is updated	;AN000;
;			    with the value of the switch found. 		;AN000;
;										;AN000;
;	  GOT_B is set in SWITCH_PARSED 					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_BACKGROUND	PROC								;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_B		; If already parsed this switch ;AN000;
	JNZ	DUPLICATE_B			; then, error			;AN000;
	OR	SWITCH_PARSED,GOT_B		; else, say we parsed it.	;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the switch in the Shared data area					;AN000;
;-------------------------------------------------------------------------------;AN000;
	OR	CS:[BP].SWITCHES,BACKGROUND_SW	; Set the command line switch	;AN000;
	CLC					; Clear the error flag		;AN000;
	JMP	SHORT GET_BACKGROUND_END	; Return			;AN000;
										;AN000;
DUPLICATE_B:					; Already got this switch	;AN000;
	MOV	AX,RC_DUPLICATE_PARMS		; AX := error message number	;AN000;
	STC					; SET ERROR			;AN000;
										;AN000;
GET_BACKGROUND_END:								;AN000;
	RET									;AN000;
GET_BACKGROUND	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_LCD							;AN000;
;										;AN000;
; INPUT:  SWITCH_PARSED   := The command line switches parsed so far (bit mask) ;AN000;
;										;AN000;
; OUTPUT: PRINTBOX_ID_PTR := Point to /LCD ASCIIZ string.			;AN000;
;	  GOT_B is set in SWITCH_PARSED 					;AN000;
;	  AX		  := Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Data Referenced:								;AN000;
;										;AN000;
;	  LCD_BOX = An ASCIIZ string representing the LCD printbox id.		;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_LCD PROC									;AN000;
										;AN000;
	TEST	SWITCH_PARSED,GOT_LCD	   ; If already parsed this switch	;AN000;
	JNZ	DUPLICATE_LCD		   ; then, error: Duplicate switch	;AN000;
	TEST	SWITCH_PARSED,GOT_PRINTBOX ; If printbox already mentioned	;AN000;
	JNZ	BAD_COMBINATION 	   ; then, error: Invalid combination	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set the pointer to the print box id to "LCD"                                  ;AN000;
;-------------------------------------------------------------------------------;AN000;
	MOV	AX,OFFSET LCD_BOX	   ; PRINTBOX id := LCD 		;AN000;
	MOV	PRINTBOX_ID_PTR,AX	   ; Save pointer to this printbox id.	;AN000;
	OR	SWITCH_PARSED,GOT_LCD	   ; Say we found this switch		;AN000;
	CLC				   ; Clear the error flag		;AN000;
	JMP	SHORT GET_LCD_END	   ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /LCD was already parsed:							;AN000;
;-------------------------------------------------------------------------------;AN000;
DUPLICATE_LCD:				   ; Already got this switch		;AN000;
	MOV	AX,RC_DUPLICATE_PARMS	   ; AX := error message number 	;AN000;
	STC				   ; SET ERROR				;AN000;
	JMP	SHORT GET_LCD_END	   ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /PRINTBOX was already parsed: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
BAD_COMBINATION:			   ; /LCD and /PRINTBOX invalid at same ;AN000;
	MOV	AX,RC_INVLD_COMBINATION    ;  time, Set the error flag		;AN000;
	STC				   ;   AX := Error code 		;AN000;
										;AN000;
GET_LCD_END:									;AN000;
	RET									;AN000;
GET_LCD 	ENDP								;AN000;
										;AN000;
PAGE										;AN000;
;===============================================================================;AN000;
;										;AN000;
; PROCEDURE_NAME: GET_PRINTBOX							;AN000;
;										;AN000;
; INPUT:  ES:[BX]	:= Result block 					;AN000;
;	  SWITCH_PARSED := The command line switches parsed so far (bit mask)	;AN000;
;										;AN000;
; OUTPUT: DEFAULT_BOX	:= Is overwritten to contain the printbox id. found on	;AN000;
;			    the command line.					;AN000;
;	  GOT_PRINTBOX is set in SWITCH_PARSED					;AN000;
;	  AX		:= Error message number.				;AN000;
;	  CARRY FLAG IS SET IF ERROR FOUND					;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
GET_PRINTBOX_ID PROC								;AN000;
										;AN000;
	PUSH	CX								;AN000;
	PUSH	SI								;AN000;
	PUSH	DI								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; Test for error in the printbox statement:					;AN000;
;-------------------------------------------------------------------------------;AN000;
	TEST	SWITCH_PARSED,GOT_LCD	    ; If /LCD	  already mentioned	;AN000;
	JNZ	BAD_COMBINATION2	    ; then, error: Invalid combination	;AN000;
	TEST	SWITCH_PARSED,GOT_PRINTBOX  ; If already parsed this switch	;AN000;
	JNZ	DUPLICATE_PRINTBOX	    ; then, error: Duplicate switch	;AN000;
										;AN000;
	MOV	DI,ES:[BX+4]		    ; DI := Offset of switch VALUE found;AN000;
										;AN000;
       .IF <<BYTE PTR [DI]> EQ 0>	    ; IF no printbox id 		;AN000;
       .THEN				    ; then,				;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; No printbox id. was found:						;AN000;
	 ;----------------------------------------------------------------------;AN000;
	  MOV	  AX,FORMAT_NOT_CORRECT     ;	AX := Error code		;AN000;
	  STC				    ;	Set the error flag		;AN000;
       .ELSE				    ; else,				;AN000;
	  OR	  SWITCH_PARSED,GOT_PRINTBOX;	Say we found this switch	;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; Overwrite DEFAULT_BOX with the Printbox id. found			;AN000;
	 ;----------------------------------------------------------------------;AN000;
	  MOV	  CL,PRINTBOX_ID_LENGTH     ;	  CX := Maximum number of bytes ;AN000;
	  XOR	  CH,CH 		    ;		 to copy		;AN000;
	  MOV	  SI,DI 		    ;	  [DS][SI] :=  Value found	;AN000;
	  MOV	  DI,OFFSET DEFAULT_BOX     ;	  [ES][DI] :=  Default value	;AN000;
	  REP	  MOVSB 		    ;	  Copy the string		;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 ; Verify that the Printbox id. string is not too long: 		;AN000;
	 ;----------------------------------------------------------------------;AN000;
	 .IF  <<BYTE PTR [DI-1]> EQ 0>	    ; If the last byte is a null	;AN000;
	 .THEN				    ; then, the string was not longer	;AN000;
					    ;	    than the maximum		;AN000;
	    CLC 			    ;	Clear the carry flag = No error ;AN000;
	 .ELSE				    ; else, string provided is too long ;AN000;
	    MOV  AX,RC_Not_In_Sw	    ;	Error := RC for Invalid parm	;AN000;
	    STC 			    ; Set error 			;AN000;
	 .ENDIF 			    ; ENDIF printbox id. too long	;AN000;
       .ENDIF				    ; ENDIF printbox id. provided	;AN000;
										;AN000;
	JMP	SHORT GET_PRINTBOX_END	    ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /PRINTBOX was already parsed: 						;AN000;
;-------------------------------------------------------------------------------;AN000;
DUPLICATE_PRINTBOX:			    ; Already got this switch		;AN000;
	MOV	AX,RC_DUPLICATE_PARMS	    ; AX := error message number	;AN000;
	STC				    ; SET ERROR 			;AN000;
	JMP	SHORT GET_PRINTBOX_END	    ; Return				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
; /LCD was already parsed:							;AN000;
;-------------------------------------------------------------------------------;AN000;
BAD_COMBINATION2:			    ; /LCD and /PRINTBOX invalid at same;AN000;
	MOV	AX,RC_INVLD_COMBINATION     ;  time, Set the error flag 	;AN000;
	STC				    ;	AX := Error code		;AN000;
										;AN000;
GET_PRINTBOX_END:								;AN000;
	POP	DI								;AN000;
	POP	SI								;AN000;
	POP	CX								;AN000;
	RET									;AN000;
GET_PRINTBOX_ID ENDP								;AN000;
										;AN000;
CODE  ENDS									;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grparse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS GRAPHICS Command  -	Profile Load Modules #2 
										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                                
;;										;AN000;
;; File Name:  GRLOAD.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;   This file contains the modules used to load the				;AN000;
;;   GRAPHICS profile into resident memory.					;AN000;
;;										;AN000;
;;   ************* The EGA Dynamic Save Area will be built (by			;AN000;
;;   **  NOTE	** CHAIN_INTERRUPTS in file GRINST.ASM) over top of these	;AN000;
;;   ************* modules to avoid having to relocate this save just before	;AN000;
;;   terminating.  This is safe since the maximum memory used is		;AN000;
;;   288 bytes and the profile loading modules are MUCH larger than		;AN000;
;;   this.  So GRLOAD.ASM MUST be linked before GRINST.ASM and after		;AN000;
;;   GRPRINT.ASM.								;AN000;
;;										;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 PLACID Functional Specifications					;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	 LOAD_PROFILE - Main module for profile loading 			;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	 ?????????? - Externals for profile loading modules			;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;	 None									;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; ---------------------							;AN000;
;;	 Refer to GRAPHICS.ASM							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
CODE	SEGMENT PUBLIC 'CODE'          ;;                                       ;AN000;
				       ;;					;AN000;
	INCLUDE STRUC.INC	       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;;										;AN000;
;; Public Symbols								;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
	ASSUME	CS:CODE,DS:CODE        ;;					;AN000;
				       ;;					;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
				       ;;					;AN000;
;-------------------------------------------------------------------------------;AN000;
; Set assemble switches for parse code that is not required!!			;AN000;
;-------------------------------------------------------------------------------;AN000;
DateSW	      EQU     0 							;AN000;
TimeSW	      EQU     0 							;AN000;
CmpxSW	      EQU     0 							;AN000;
DrvSW	      EQU     0 							;AN000;
QusSW	      EQU     0 							;AN000;
KeySW	      EQU     0 							;AN000;
;Val1SW        EQU     0							;AN000;
;Val2SW        EQU     0							;AN000;

	include version.inc										;AN000;
       PUBLIC  SYSPARSE 	       ;;					;AN000;
       INCLUDE PARSE.ASM	       ;; parser code				;AN000;
				       ;;					;AN000;
CODE	ENDS			       ;;					;AN000;
	END									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\help\proto.h ===
extern  int main(int argc,char * *argv);
extern  void help_on_help(void );
extern  int dump_list(void );
extern  struct _iobuf *find_help_file(void );
extern  int get_next_record(struct _iobuf *help_handle,char *rec_buf);
extern  void send_record(char *rec_buf,int out_con, int screen_height);
extern  int check_console(struct _iobuf *fp);
extern  int dump_command(char *name);
extern  int lookup_name(char *name,struct _iobuf *help_handle);
extern  void dos_toupper(char *string);
extern  void get_ucase_tab(void );
extern  char make_upper(char );
extern  int get_screen_height(void );
extern  int is_internal(char *name); 

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\join\join.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*
 *  This file contains the constants, globals, structure definitions,
 *  extern declarations, and macro definitions for the join utility.
 *
 *  Date:       10-12-90
 */

 
/*
 *  Parse Equates
 */
#define ASCII_DRIVE       'A'-1        /* Convert to Ascii drive */
#define CAPRESULT         0x0001       /* Cap result by file table */
#define DRVONLY_OPT       0x0101       /* Drive only & optional */
#define ERRORLEVEL1       1            /* Parsing error occurred */
#define FILESPEC_OPT      0x0201       /* File spec & optional */
#define MAXPOSITION       2            /* Max positionals in cmdline */
#define MINPOSITION       0            /* Min positionals in cmdline */
#define NOCAPPING         0x0000       /* Do not cap result */
#define SWITCH_OPT        0x0000       /* Optional switch */


/*
 *  Message Equates
 */
#define MSG_NOMEM         1            /* Insufficient memory */
#define MSG_PARMNUM       2            /* Too many parameters */
#define MSG_DIRNEMP       3            /* Directory not empty */
#define MSG_BADPARM       4            /* Invalid parameter */
#define MSG_NETERR        5            /* Cannot %1 a network drive */
#define MSG_INVSWTCH      6            /* Invalid switch */
#define MSG_OPTIONS_FIRST 300          
#define MSG_OPTIONS_LAST  307          
                                       
#define BLNK              ' '          /* For sublist.pad_char */
#define CARRY             0x0001       /* Check carry flag */
#define D_SWITCH          "/D"         /* Only 1 switch */
#define O_SWITCH          "/?"         /* Only 1 switch */
#define EXT_ERR_CLASS     0x01         /* DOS Extended error class */
#define FALSE             0            
#define MAX               256          
#define MAXWIDTH          0            /* 0 ensures no padding */
#define MINWIDTH          1            /* At least 1 char in parm */
#define NO_HANDLE         0xffff       /* No handle specified */
#define NO_INPUT          0x00         /* No input characters */
#define NO_REPLACE        0x00         /* No replacable parameters */
#define NULL              0            
#define PARSE_ERR_CLASS   0x02         /* Parse error class */
#define RESERVED          0            /* Reserved byte field */
#define STDERR            0x0002       /* Standard error device handle */
#define STDOUT            0x0001       /* Std output device handle */
#define STR_INPUT         16           /* Byte def for sublist.flags */
#define SUB_ID1           1            /* Only 1 replaceable parameter */
#define SUBCNT0           0            /* 0 substitutions in message */
#define SUBCNT1           1            /* 1 substitution in message */
#define SUBLIST_LENGTH    11           /* Length of sublist structure */
#define UTILITY_CLASS     0x0ff        /* Utility message class */

                                       
/*                                     
 *  Miscellaneous                      
 */                                    
char cmdln_drive[64]   = {0};          /* Save user's input in   */
char cmdln_flspec[64]  = {0};          /* order to pass to error */
char cmdln_invalid[64] = {0};          
char fix_es_reg[1];                    /* Corrects es reg after type-"far" */
char p_drive[3]        = {0};          /* Recvs drive ltr from parser */
char p_filespec[64]    = {0};          /* Recvs filespec from parser */
char replparm_JOIN[]   = "JOIN";       /* Cannot JOIN a network drv */
                                      
unsigned char source[MAX] = {0};       /* buffer for string manipulation */

struct sysVarsType SysVars;


/*
 *  Parse Structures
 */
struct p_parms  p_p;                   /* # of extras & pts to descrptn */
struct p_parmsx p_px;                  /* min/max parms & pts to controls */
struct p_control_blk p_con1;           /* 1st posit parm in cmd str */
struct p_control_blk p_con2;           /* 2nd posit parm in cmd str */
struct p_switch_blk p_swi1;            /* /D switch in cmd str */
struct p_switch_blk p_swi2;            /* /D switch in cmd str */
struct p_result_blk rslt1;             /* Result blk rtrnd from parser */
struct p_fresult_blk rslt2;            /* Result blk rtrnd from parser */
struct p_result_blk rslt3;             /* Result blk rtrnd from parser */
struct noval novals = {0};             /* Value list not used */
                                       
union REGS inregs, outregs;            /* Define register variables */

                                       
/*                                     
 *  External Function Prototypes       
 */                                    
extern  void  exit(int);                 
extern  int   ffirst(char *, unsigned int, struct findType *);
extern  int   fNet(int);
extern  int   fPathErr(char *);
extern  int   fPhysical(int);
extern  int   fShared(int);
extern  int   getdrv(void);
extern  void  GetVars(struct sysVarsType *);
extern  int   mkdir(char *);
extern  void  parse(union REGS *, union REGS *);
extern  void  PutVars(struct sysVarsType *);
extern  void  rootpath(char *, char *);
extern  char  *strbscan(char *, char *);                                                      /* SM extern'd */
extern  void  sysdispmsg(union REGS *, union REGS *);
extern  void  sysloadmsg(union REGS *, union REGS *);

/* these are already declared extern in cds.h */
   char fGetCDS(int, struct CDSType *);
   char fPutCDS(int, struct CDSType *);


/*
 *  Internal Function Prototypes
 */
extern  int   main(int, char **);
extern  int   ParseIt(void);
extern  void  DoList(void);
extern  void  Delete(struct CDSType,int);
extern  void  Insert(struct CDSType,int);
extern  void  load_msg(void);
extern  void  display_msg(int, char *);
extern  void  DisplayOptionsExit(void);
extern  void  dispmsg_terminate(int, char *);
extern  void  Parser_Prep(char *);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graphics\grpattrn.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132								;AN000;
	TITLE	DOS - GRAPHICS Command  -	Common modules			;AN000;
.xlist										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
;; DOS - GRAPHICS Command
;;                               
;;										;AN000;
;; File Name:  GRPATTRN.ASM							;AN000;
;; ----------									;AN000;
;;										;AN000;
;; Description: 								;AN000;
;; ------------ 								;AN000;
;;	 This file contains the grey patterns used by PRT_BW_APA for printing	;AN000;
;;	 on a Black and White printer.						;AN000;
;;										;AN000;
;; Documentation Reference:							;AN000;
;; ------------------------							;AN000;
;;	 OASIS High Level Design						;AN000;
;;	 OASIS GRAPHICS I1 Overview						;AN000;
;;										;AN000;
;; Procedures Contained in This File:						;AN000;
;; ----------------------------------						;AN000;
;;	none									;AN000;
;;										;AN000;
;; Include Files Required:							;AN000;
;; -----------------------							;AN000;
;;	GRPATTRN.STR	- Structures for patterns.				;AN000;
;;										;AN000;
;;										;AN000;
;; External Procedure References:						;AN000;
;; ------------------------------						;AN000;
;;										;AN000;
;;	Called by PRT_BW_APA from file GRBWPRT.ASM				;AN000;
;;										;AN000;
;; Linkage Instructions:							;AN000;
;; -------------------- 							;AN000;
;;										;AN000;
;; Change History:								;AN000;
;; ---------------								;AN000;
;;										;AN000;
;;										;AN000;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;					;AN000;
.list										;AN000;
CODE	SEGMENT PUBLIC 'CODE'                                                   ;AN000;
	ASSUME		CS:CODE,DS:CODE 					;AN000;
INCLUDE GRPATTRN.STR								;AN000;
										;AN000;
PUBLIC	TAB_DIRECTORY								;AN000;
PUBLIC	TAB_DIR_NB_ENTRIES							;AN000;
PUBLIC	PAT_4X2 								;AN000;
PUBLIC	PAT_4X4 								;AN000;
PUBLIC	PAT_6X2 								;AN000;
PUBLIC	PAT_8X2 								;AN000;
PUBLIC	PAT_6X4 								;AN000;
PUBLIC	PAT_8X4 								;AN000;
PUBLIC	PAT_8X6 								;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; PATTERN DIRECTORY:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
TAB_DIR_NB_ENTRIES DB 7 							;AN000;
TAB_DIRECTORY LABEL BYTE							;AN000;
; ENTRY = <OFFSET PATTERN TABLE, TABLE SIZE, BOX_W, BOX_H,			;AN000;
;	   NUNBER OF PATTERNS(INTENSITIES) >					;AN000;
	TAB_ENTRY <OFFSET PAT_4X2,-1,40,2,1,8 > 				;AN000;
	TAB_ENTRY <OFFSET PAT_4X4,-1,40,2,2,8 > 				;AN000;
	TAB_ENTRY <OFFSET PAT_6X2,-1,70,3,1,10> 				;AN000;
	TAB_ENTRY <OFFSET PAT_8X2,-1,108,4,1,12>				;AN000;
	TAB_ENTRY <OFFSET PAT_6X4,-1,119,3,2,17>				;AN000;
	TAB_ENTRY <OFFSET PAT_8X4,-1,162,4,2,18>				;AN000;
	TAB_ENTRY <OFFSET PAT_8X6,-1,171,4,3,19>				;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 4X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_4X2 LABEL BYTE								;AN000;
; PATTERN=<MAXIMUM INTENSITY, 1ST COLUMN (top is left bit), 2ND, 3RD, 4TH >	;AN000;
	    PAT_4X2_STR < 5,11B,11B,11B,11B>					;AN000;
	    PAT_4X2_STR <13,11B,10B,01B,11B>					;AN000;
	    PAT_4X2_STR <20,10B,11B,01B,10B>					;AN000;
	    PAT_4X2_STR <28,10B,01B,01B,10B>					;AN000;
	    PAT_4X2_STR <36,10B,00B,01B,10B>					;AN000;
	    PAT_4X2_STR <47,10B,00B,01B,00B>					;AN000;
	    PAT_4X2_STR <58,10B,00B,00B,00B>					;AN000;
	    PAT_4X2_STR <63,00B,00B,00B,00B>					;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 4X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_4X4 LABEL BYTE								;AN000;
; PATTERN=<MAXIMUM INTENSITY, 1ST COLUMN (top is left bit), 2ND, 3RD, 4TH >	;AN000;
	    PAT_4X4_STR < 5,1111B,1111B,1111B,1111B>				;AN000;
	    PAT_4X4_STR <13,1111B,1010B,0101B,1111B>				;AN000;
	    PAT_4X4_STR <20,1010B,1111B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <28,1010B,0101B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <36,1010B,0000B,0101B,1010B>				;AN000;
	    PAT_4X4_STR <47,1010B,0000B,0101B,0000B>				;AN000;
	    PAT_4X4_STR <58,1010B,0000B,0000B,0000B>				;AN000;
	    PAT_4X4_STR <63,0000B,0000B,0000B,0000B>				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 6X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_6X2 LABEL BYTE								;AN000;
	    PAT_6X2_STR < 3,11B,11B,11B,11B,11B,11B>				;AN000;
	    PAT_6X2_STR < 8,11B,11B,10B,11B,11B,01B>				;AN000;
	    PAT_6X2_STR <15,10B,01B,10B,11B,10B,01B>				;AN000;
	    PAT_6X2_STR <21,01B,10B,10B,01B,10B,10B>				;AN000;
	    PAT_6X2_STR <28,01B,10B,10B,01B,10B,00B>				;AN000;
	    PAT_6X2_STR <36,10B,01B,00B,10B,01B,00B>				;AN000;
	    PAT_6X2_STR <45,00B,10B,00B,01B,00B,10B>				;AN000;
	    PAT_6X2_STR <53,10B,00B,00B,01B,00B,00B>				;AN000;
	    PAT_6X2_STR <60,10B,00B,00B,00B,00B,00B>				;AN000;
	    PAT_6X2_STR <63,00B,00B,00B,00B,00B,00B>				;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X2 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X2 LABEL BYTE								;AN000;
	    PAT_8X2_STR < 3,11B,11B,11B,11B,11B,11B,11B,11B>			;AN000;
	    PAT_8X2_STR < 9,11B,11B,10B,11B,11B,10B,11B,01B>			;AN000;
	    PAT_8X2_STR <15,10B,11B,01B,11B,10B,11B,00B,11B>			;AN000;
	    PAT_8X2_STR <21,10B,01B,11B,10B,01B,10B,01B,10B>			;AN000;
	    PAT_8X2_STR <27,10B,01B,01B,10B,10B,01B,01B,10B>			;AN000;
	    PAT_8X2_STR <33,00B,10B,01B,10B,00B,01B,10B,01B>			;AN000;
	    PAT_8X2_STR <39,10B,00B,10B,01B,00B,10B,00B,01B>			;AN000;
	    PAT_8X2_STR <45,10B,00B,01B,00B,10B,00B,01B,00B>			;AN000;
	    PAT_8X2_STR <51,10B,00B,00B,01B,00B,00B,10B,00B>			;AN000;
	    PAT_8X2_STR <56,10B,00B,00B,00B,01B,00B,00B,00B>			;AN000;
	    PAT_8X2_STR <61,10B,00B,00B,00B,00B,00B,00B,00B>			;AN000;
	    PAT_8X2_STR <63,00B,00B,00B,00B,00B,00B,00B,00B>			;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 6X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_6X4 LABEL BYTE								;AN000;
	    PAT_6X4_STR < 3,1111B,1111B,1111B,1111B,1111B,1111B>		;AN000;
	    PAT_6X4_STR < 8,1111B,1111B,1101B,1111B,1111B,1011B>		;AN000;
	    PAT_6X4_STR <13,1111B,1111B,0101B,1011B,1111B,1010B>		;AN000;
	    PAT_6X4_STR <16,0101B,1111B,0101B,1010B,0101B,1010B>		;AN000;
	    PAT_6X4_STR <20,0101B,1110B,0101B,1010B,0101B,1010B>		;AN000;
	    PAT_6X4_STR <24,1010B,0101B,1010B,0101B,0010B,0101B>		;AN000;
	    PAT_6X4_STR <28,1010B,0101B,1000B,0101B,0010B,0101B>		;AN000;
	    PAT_6X4_STR <32,1010B,0101B,1000B,1001B,0010B,0100B>		;AN000;
	    PAT_6X4_STR <37,1010B,0000B,1010B,0101B,0000B,0101B>		;AN000;
	    PAT_6X4_STR <40,0100B,0001B,1000B,0010B,1000B,0101B>		;AN000;
	    PAT_6X4_STR <45,0100B,0010B,1000B,0010B,0100B,0001B>		;AN000;
	    PAT_6X4_STR <49,1010B,0000B,1000B,0101B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <52,1010B,0000B,0000B,0101B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <55,0000B,1000B,0000B,0010B,0000B,0100B>		;AN000;
	    PAT_6X4_STR <58,1000B,0000B,0000B,0010B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <61,1000B,0000B,0000B,0000B,0000B,0000B>		;AN000;
	    PAT_6X4_STR <63,0000B,0000B,0000B,0000B,0000B,0000B>		;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X4 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X4 LABEL BYTE								;AN000;
	    PAT_8X4_STR < 1,1111B,1111B,1111B,1111B,1111B,1111B,1111B,1111B>	;AN000;
	    PAT_8X4_STR < 4,1010B,1111B,1111B,1111B,1010B,1111B,1111B,1111B>	;AN000;
	    PAT_8X4_STR < 7,1010B,1111B,1101B,1111B,1010B,1111B,0111B,1111B>	;AN000;
	    PAT_8X4_STR <10,1010B,0111B,1110B,0101B,1010B,1101B,1011B,0101B>	;AN000;
	    PAT_8X4_STR <13,1001B,1110B,0110B,1001B,0110B,1011B,1001B,0110B>	;AN000;
	    PAT_8X4_STR <18,1010B,0101B,1110B,0101B,1010B,0101B,1010B,0101B>	;AN000;
	    PAT_8X4_STR <24,1010B,0101B,0101B,1010B,1010B,0101B,0101B,1010B>	;AN000;
	    PAT_8X4_STR <30,1010B,0101B,1010B,0000B,0101B,1010B,0101B,0000B>	;AN000;
	    PAT_8X4_STR <36,1010B,0000B,1010B,0101B,0000B,1010B,0000B,0101B>	;AN000;
	    PAT_8X4_STR <42,1010B,0000B,0101B,0000B,1010B,0000B,0101B,0000B>	;AN000;
	    PAT_8X4_STR <46,0010B,1000B,0000B,0010B,1000B,0001B,0100B,0001B>	;AN000;
	    PAT_8X4_STR <48,1010B,0000B,0101B,0000B,0000B,1010B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <50,0010B,0000B,1000B,0010B,0000B,0100B,0001B,0000B>	;AN000;
	    PAT_8X4_STR <53,1010B,0000B,0000B,0000B,0101B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <56,0000B,1000B,0000B,0000B,0100B,0000B,0000B,0010B>	;AN000;
	    PAT_8X4_STR <59,1000B,0000B,0000B,0000B,0010B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <62,1000B,0000B,0000B,0000B,0000B,0000B,0000B,0000B>	;AN000;
	    PAT_8X4_STR <63,0000B,0000B,0000B,0000B,0000B,0000B,0000B,0000B>	;AN000;
										;AN000;
;-------------------------------------------------------------------------------;AN000;
;										;AN000;
; 8X6 GREY PATTERNS:								;AN000;
;										;AN000;
;-------------------------------------------------------------------------------;AN000;
PAT_8X6 LABEL BYTE								;AN000;
	  PAT_8X6_STR < 1,111111B,111111B,111111B,111111B,111111B,111111B,111111B,111111B>;AN000;
	  PAT_8X6_STR < 4,011011B,111111B,111111B,111111B,110110B,111111B,111111B,111111B>;AN000;
	  PAT_8X6_STR < 7,101010B,011111B,111111B,110101B,101010B,011111B,111111B,110101B>;AN000;
	  PAT_8X6_STR <10,101010B,010101B,111111B,101010B,010101B,101010B,111111B,010101B>;AN000;
	  PAT_8X6_STR <13,011011B,100100B,111011B,100100B,011011B,100100B,011111B,100100B>;AN000;
	  PAT_8X6_STR <17,101010B,010101B,101010B,010101B,101010B,010101B,101010B,010101B>;AN000;
	  PAT_8X6_STR <21,101010B,010101B,101010B,010101B,001010B,010101B,101010B,010101B>;AN000;
	  PAT_8X6_STR <25,010100B,101010B,010101B,001010B,100100B,010001B,101110B,000001B>;AN000;
	  PAT_8X6_STR <29,000000B,010101B,101010B,010101B,000000B,101010B,010101B,101010B>;AN000;
	  PAT_8X6_STR <33,010010B,100101B,011000B,100010B,001101B,100000B,001010B,100100B>;AN000;
	  PAT_8X6_STR <37,100100B,001010B,010000B,001001B,100010B,001101B,010000B,001010B>;AN000;
	  PAT_8X6_STR <41,100000B,010010B,100100B,000010B,101000B,000101B,010000B,001010B>;AN000;
	  PAT_8X6_STR <45,100010B,001000B,000010B,100000B,010100B,000001B,100100B,000000B>;AN000;
	  PAT_8X6_STR <49,101000B,000001B,000100B,010000B,000010B,100000B,001000B,000101B>;AN000;
	  PAT_8X6_STR <53,101010B,000000B,000000B,000000B,010101B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <57,000000B,010000B,000000B,000100B,000000B,100000B,000000B,000010B>;AN000;
	  PAT_8X6_STR <60,100000B,000000B,000000B,000000B,000100B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <62,100000B,000000B,000000B,000000B,000000B,000000B,000000B,000000B>;AN000;
	  PAT_8X6_STR <63,000000B,000000B,000000B,000000B,000000B,000000B,000000B,000000B>;AN000;
CODE	ENDS										  ;AN000;
	END										  ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\help\helper.asm ===
page    ,132
        title   Helper routines for HELP

; get screen height - return current height of display.  Use ANSI to
; report height if it is present, otherwise reach into ROM BIOS data
; area.  Code taken from MORE.COM
;
; make upper - convert character to upper case using the DOS uppercase
; table.  Code taken from FIND.

        .xlist
        include rombios.inc
        include version.inc
        .list

; miscellaneous equates for detecting screen size

ANSI_GET	EQU    440CH					     
GET_SUBFUNC	EQU    037FH					     
LINESPERPAGE	EQU    24		; default screen size
TEXT_MODE	EQU    1				       
DATA_LENGTH	EQU    14				       
STDERR          EQU    2                ; Standard error handle

ifdef JAPAN
LINELENGTH	EQU	80		; default line length
endif

;								     
ANSI_STR    STRUC						     
	    DB	  0						     
	    DB	  0						     
	    DW	  DATA_LENGTH					     
	    DW	  ?						     
D_MODE	    DB	  ?						     
	    DB	  ?						     
	    DW	  ?						     
	    DW	  ?						     
	    DW	  ?						     
SCR_COLS    DW	  ?						     
SCR_ROWS    DW	  ?						     
ANSI_STR    ENDS						     
        

        .MODEL SMALL
        .DATA
MAXROW	DB	25
MAXCOL	DB	80

ANSI_BUF ANSI_STR <>			;buffer for IOCTL call


        .CODE

; get height of screen from device driver or ROM BIOS
; returns height in rows in AL, width in columns in AH

        public  _get_screen_height
_get_screen_height      proc    near

        push    bp                      ; standard prelude
        mov     bp,sp
        push    si
        push    di

ifdef JAPAN

	mov	MAXROW,LINESPERPAGE 	; assume 24 rows
	mov	MAXCOL,LINELENGTH	; assume 80 columns

else

	push	ds
	mov	ax,ROMBIOS_DATA 	  ;Get ROM Data segment
	mov	ds,ax
	Assume	DS:ROMBIOS_DATA

	mov	al,CRT_Rows		  ;Get max rows
	pop	ds
	Assume	DS:Dgroup

	or	al,al			  ;If zero specified
	jnz	@F
	mov	al,LINESPERPAGE 	  ;assume 24 rows

@@:
	mov	maxrow,al		  ;set lines per page from ROM BIOS
endif

;
; Check if ANSI is loaded, and if so, use it to find screen dimensions
;

	MOV	AX,ANSI_GET		  ;prepare for device characteristics..
	MOV	BX,STDERR		  ;request.
	MOV	CX,GET_SUBFUNC		  ;get subfunction..
	LEA	DX,ANSI_BUF		  ;point to buffer.
	INT	21H
	jc	no_ansi

;
; ANSI is around and get tell us the screen dimensions
;

	LEA	DI,ANSI_BUF
	cmp	[di].d_mode, TEXT_MODE	  ;if we are in a text mode then..
	jne	no_ansi 		  ;default already initialized
	MOV	AX,[DI].SCR_ROWS	  ;store the screen length...else..
	MOV	MAXROW,AL		  ;default (25) is assumed.

ifdef JAPAN
	mov	ax,[di].SCR_COLS
        mov     ah,al                     ; return cols in AH                           
no_ansi:

else

no_ansi:
	MOV	AH,0FH
	INT	10H                       ; returns cols in AH
        
endif
        mov     al,maxrow                 ; get the max rows      
        
        pop     di
        pop     si
        pop     bp
        ret

_get_screen_height      endp


; routines to get DOS upper case table, and to map chars to upper
; case in a language independent way.

        .DATA

GET_UPPER_TABLE equ     6502h           ; DOS get upper case table call    
ucasetab_bias   dw      0               ; value of (256-table size)
uppercase_table db      5 dup (?)       ; buffer for upper case table
                                        ; used of DOS Function 65h,
                                        ; and to store real table address


        .CODE


; Get pointer to upper case table and store as local data
; Must call this before calling _make_upper below

        public  _get_ucase_tab
_get_ucase_tab  proc    near
        push    bp                      ; Standard prologue
        mov     bp,sp
        push    si
        push    di

        push    es
        mov     ax,GET_UPPER_TABLE
        mov     bx,-1                   ; current code page
        mov     cx,5                    ; size of info for upper case table
        mov     dx,bx                   ; current country id
        push    ds
        pop     es

        mov     di,offset uppercase_table ; point at buffer for table
        int     21h
                                        ; assume no error
        inc     di                      ; point at start of table
        les     di,[di]                 ; load table address

        assume  es:nothing

        mov     bx,es:[di]              ; load table size
        mov     ax,256                  ; compute table size bias
        sub     ax,bx
        mov     ucasetab_bias,ax        ; save it for later
        add     di,2                    ; point at translation table
        mov     word ptr uppercase_table,di   ; save tranlation table address
        mov     word ptr uppercase_table+2,es
        pop     es                                        
        pop     di
        pop     si
        pop     bp
        ret

_get_ucase_tab  endp


; convert character to upper case using DOS uppercase table.
; NOTE: program must have called _get_ucase_tab before calling this.
;
;       Entry: char in AL
;       Exit : modified char in AL

        public  _make_upper
_make_upper     proc    near

        cmp     al,80h                  ; if AL is extended char, get mapping
        jb      not_al_high             ; AL not extended char
        jmp     short use_table         ; get mapping

not_al_high:
        cmp     al,'a'                  ; make sure it is lower case
        jb      not_al_lower            ; jump if no remapping needed
        cmp     al,'z'
        ja      not_al_lower
        and     al,0DFh                 ; remap normal character

not_al_lower:
        ret

use_table:                              ; do lookup in DOS ucase table
        push    bx
        push    di
        push    es

        les     di,dword ptr uppercase_table      ; get the table

        assume  es:nothing

        mov     bl,al
        xor     bh,bh
        sub     bx,ucasetab_bias        ; get the index
        mov     al,es:[di+bx]           ; get the char

        pop     es
        pop     di
        pop     bx
        ret

_make_upper     endp


        end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\help\help.c ===
/* Help command for DOS 5.0
*
*  This help command has two functions: it displays a list of commands
*  with one line descriptions of what they do, and it tries to display
*  more detailed help for any individual command by invoking it with
*  the /? option.  It is driven from a help database text file, DOSHELP.HLP,
*  which contains the list of recognized commands and their one-line
*  descriptions.  Since the help file is a simple text file, it can be
*  easily extended by third parties.
*
*  The help file has a simple format: each line is a separate record,
*  terminated by a CR-LF combination.  A record can be a comment, which
*  is preceded by an at sign in the first column, or a command name,
*  beginning in the first column, followed by whitespace and the command
*  description.
*
*  Revision History
*  ================
*  MD  10/3/90              First version
*/

#include <dos.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <io.h>
#include <process.h>
#include <string.h>
#include <conio.h>
#include "proto.h"
#include "message.h"

/* name of help text database file */
#define  HELP_FILE_NAME     "DOSHELP.HLP"

/* marker used to preface comments in help file */
#define  COMMENT_MARK       '@'
                              
/* maximum size of line in help file */
#define  MAX_LINE           160

/* return codes for various functions */
#define  READ_ERROR         2             /* file i/o error occurred */
#define  FILE_ERROR         2             /* file i/o error occurred */
#define  OK                 1             /* OK return result */
#define  NO_HELP            3             /* couldn't find help on command */

/* bits used for DOS Device Information IOCTL */
#define  DEVICE_BIT         0x80          /* handle is device */
#define  STDOUT_BIT         0x02          /* handle is standard output */

#define  TRUE               1
#define  FALSE              0

/* table of names of internal commands, used by is_internal() */
char *name_table[] = {
       "BREAK",
       "CALL",
       "CD",
       "CHCP",
       "CHDIR",
       "CLS",
       "COPY",
       "CTTY",
       "DATE",
       "DEL",
       "DIR",
       "ECHO",
       "ERASE",
       "EXIT",
       "FOR",
       "GOTO",
       "IF",
       "LH",
       "LOADHIGH",
       "MD",
       "MKDIR",
       "PATH",
       "PAUSE",
       "PROMPT",
       "RD",
       "REM",
       "REN",
       "RENAME",
       "RMDIR",
       "SET",
       "SHIFT",
       "TIME",
       "TYPE",
       "VER",
       "VERIFY",
       "VOL",
       NULL
};


int
main(int argc, register char *argv[])
{

       if (argc == 1)                     /* generic help requested */
              return(dump_list());        /* display the whole help file */

       else if (argv[1][0] == '/' && argv[1][1] == '?') /* help /? */
       {
              help_on_help();             /* display help on help */
              return(0);
       }
       else
       {
              return(dump_command(argv[1]));
       }
}


/* display help text for this command */
void help_on_help()
{
       fputs(usage,stdout);
}


/*** dump_list - display contents of entire help file.  Search for the file,
* display each valid record.
*
*      Entry: nothing
*      Exit : returns 0 if everything is okay
*             returns FILE_ERROR if read error occurred
*/
int
dump_list()
{
       register FILE *help_handle;        /* handle for help file */
       char rec_buf[MAX_LINE];            /* buffer for record read */
       register int  read_result;         /* return code from file read */
       int  out_con;                      /* boolean: output device is CON */
       int  screen_height;                /* height of screen in rows */

       /* go get the file, error if not found */
       if ((help_handle = find_help_file()) == NULL)
       {
              fputs(file_not_found,stdout);
              return(FILE_ERROR);
       }

       /* check to see if our output is to CON or something else.
       *  This info is used in send_record to determine if we
       *  should monitor screen length
       */
       out_con = check_console(stdout);

       /* also get the screen height for send_record 
       *  get_screen_height returns rows in low byte, cols in high byte.
       *  just use the low byte here.
       */
       screen_height = get_screen_height() & 0xff;

       /* read each record from the file and display it */
       while ((read_result = get_next_record(help_handle,rec_buf)) == OK)
              send_record(rec_buf, out_con, screen_height);

       /* report read error if one occurred */
       if (read_result == READ_ERROR)
       {
              fputs(read_error,stdout);
              fclose(help_handle);
              return(FILE_ERROR);
       }

       fclose(help_handle);
       return(0);                         /* everything okay */
}


/*** find_help_file - locate the help file, and return a file pointer
*    to it.
*
*      Entry: nothing
*      Exit : file pointer to opened file if found
*             NULL if file not found
*/
FILE *
find_help_file()
{
       char pathname[_MAX_PATH];          /* storage for pathname */

       /* check the current directory for the file */
       if (access(HELP_FILE_NAME,4) == 0)
              /* file found in current directory, return pointer */
              return(fopen(HELP_FILE_NAME,"r"));
       
       else                                /* not in curdir, check path */
       {
                                           /* search the path for the file */
              _searchenv(HELP_FILE_NAME,"PATH",pathname);

              if (*pathname == '\0')        /* return NULL if not found */
                     return(NULL);
              
              /* have the path now, return pointer to file */
              return(fopen(pathname,"r"));
       }
}



/*** get_next_record - read record from help file into supplied buffer.
*    Skip over any comment records, which begin with semicolon.  Record
*    length is limited to MAX_LINE size, but this is not checked.  Compress
*    any leading white space.
*
*      Entry: pointer to help file, address of record buffer
*      Exit : OK if no error, record buffer filled in
*             NULL on EOF
*             READ_ERROR if read error occurs
*/
int
get_next_record(FILE *help_handle, register char *rec_buf)
{
       register char *p;                           

       if (fgets(rec_buf, MAX_LINE, help_handle) != NULL)
       {                                  /* read the record fine */
              p = rec_buf;                /* start of record */

#ifdef NO_WHITE_SPACE
              /* skip any white space at start of record */
              while (isspace(*p))
                     p++;                 /* skip white space */
#endif

              if (*p == COMMENT_MARK)     /* if this record is a comment */
                                          /* get next record recursively */
                     return(get_next_record(help_handle, rec_buf));

#ifdef NO_WHITE_SPACE
              else if (p != rec_buf)      /* compress white space if any */
                          strcpy(rec_buf, p);
#endif                     

              return(OK);                 /* everything's fine */
       }

       /* abnormal return from fgets.  Check if error or just EOF */
       if (feof(help_handle))
              return(NULL);               /* return NULL on end of file */
       else
              return(READ_ERROR);         /* assume some read problem */
}



/*** send_record - display record on screen.  Output is paged based on
*    screen size.  Top line is used to display general instructions.
*    ANSI is used to determine screen height, if present, or else the
*    ROM BIOS data area is examined.
*
*    Screen height stuff is ignored if output is not to display.
*
*      Entry: rec_buf contains text to be displayed, help_handle is file pointer
*             out_con is 0 if output device is not CON
*             screen_height is height of screen in rows
*      Exit : nothing
*/
void
send_record(register char *rec_buf, int out_con, int screen_height)
{
       static int lines_out = 0;       /* number of lines already displayed */
       char c;

       /* check if output redirected, and just dump buffer to stdout if so */
       if (!out_con)
       {
              fputs(rec_buf,stdout);
              return;
       }

       /* this path if output is not redirected */

       if (lines_out == 0)                /* if nothing displayed yet */
       {
              fputs(general_help,stdout);         /* send the general instructions */
              lines_out++;                /* count the line */
       }

       fputs(rec_buf,stdout);                     /* display this record */
       lines_out++;                       /* count the line */

       if (lines_out == screen_height - 2) /* if displayed a screen full */
       {
            /* display the prompt for more */
              fputs(more_prompt, stdout);

              /* get the key to continue */
              if ((c = (char) getch()) == (char) 0x00 || c == (char) 0xE0)
                     getch();             /* two gets needed if first not ASCII */
              putchar('\n');              /* echo a new line */
              lines_out = 0;              /* reset the line count */
       }
}


/*** check_console - check this file pointer to see if it is really the
*    console device.  NOTE assumption that C file handle obtained from
*    fileno() is the same as the DOS file handle
*
*      Entry: file pointer of file to check
*      Exit : TRUE if file is console, FALSE if not
*/
int
check_console(FILE *fp)
{
       union REGS inregs, outregs;

       inregs.x.ax = 0x4400;              /* IOCTL Get Device Information */
       inregs.x.bx = fileno(fp);          /* file handle */
       intdos(&inregs, &outregs);         /* call DOS */
       if (outregs.x.cflag)               /* carry set, error occurred */
              return(TRUE);               /* assume console */
       if (!(outregs.x.dx & DEVICE_BIT))  /* bit not set, indicates file */
              return(FALSE);
       if (outregs.x.dx & STDOUT_BIT)     /* device is standard output? */
              return(TRUE);               /* then assume it is CON */
       return(FALSE);                     /* else assume some other device */
}


/*** dump_command - display help text for named command.  Works by
*    invoking the named command with the /? option.  We check the help
*    text database for the command name first, as an assurance that
*    the command supports /?
*
*      Entry: name contains name of command to display
*      Exit : 0 if everything OK
*             FILE_ERROR if file not found
*             NO_HELP if no help available
*/
int
dump_command(register char *name)
{
       register FILE *help_handle;               /* pointer to help file */
       int exec_err;                             /* return from spawn call */           

       /* go get the file, error if not found */
       if ((help_handle = find_help_file()) == NULL)
       {
              fputs(file_not_found,stdout);
              return(FILE_ERROR);
       }

       /* ensure name passed in is in upper case for lookups */
       get_ucase_tab();                   /* prepare for case mapping */
       dos_toupper(name);

       /* search help database for name of command */
       if (!lookup_name(name, help_handle))
       {
              fputs(help_not_available,stdout);
              return(NO_HELP);
       }

       /* command is in database, so we assume it supports /?.  Exec it
        * using COMMAND if it is internal, directly if external.
        *
        * M000 - APPEND is treated as internal, because it handles its 
        * command line through private channels with COMMAND.COM.
        */
       if (is_internal(name) || !(strcmp(name,"APPEND")))
              exec_err = spawnlp(P_WAIT, "COMMAND.COM", "COMMAND", "/c",
                                 name, "/?", NULL);
       else
              exec_err = spawnlp(P_WAIT, name, name, "/?", NULL);

       if (exec_err == -1)
       {
              fputs(help_not_available,stdout);
              return(NO_HELP);
       }

       return(0);
}
       


/*** lookup_name - search for a particular command name in the help text
*    database.  Just uses a dumb linear search for now.  Assumes the
*    commands in the database are in alphabetical order, excluding comments
*    Also assumes passed in name is in upper case.
*
*      Entry: name to search for, pointer to help file
*      Exit : TRUE if name found, FALSE if not
*/
int
lookup_name(register char *name, FILE *help_handle)
{
       char rec_buf[MAX_LINE];            /* buffer for records read */
       register char *p;
       int  lex_val;                      /* lexical value from strcmp() */

       while (get_next_record(help_handle, rec_buf) == OK)
       {
              /* we now have a valid help record in the buffer.
               * Check the name at the record start against the one
               * we are looking for.  We assume the records are
               * alphabetical, so if the record in the file is lexically
               * greater than the name, then we know we won't find it,
               * and can quit.
               *
               * To do the comparison, first insert a null in place of
               * the first white space in the record, to form a null
               * terminated string.  If the record starts with white
               * space, we assume it is not a command, and just skip
               * the record.  Then map record to upper case using
               * the DOS conversion table.
               */
#ifndef NO_WHITE_SPACE              /* if get_next_record eliminates white
                                     * space, this code is not needed 
                                     */
              if (*rec_buf == ' ')
                     continue;      /* just get next record */
#endif

              p = rec_buf;
              while (!isspace(*p))
                     p++;
              *p = '\0';           /* insert null over first space */

              dos_toupper(rec_buf); /* convert record text to upper case */
              
              if ((lex_val = strcmp(name,rec_buf)) == 0)
                     return(TRUE);        /* name found, okay to launch it */
              else if (lex_val < 0)
                     return(FALSE);       /* passed the name, won't find it */
       }

       /* get here if EOF or error occurred before found name */
       return(FALSE);
}



/*** dos_toupper - convert a string to upper case using the DOS upper case
*    table.
*
*      Entry: string to be converted
*      Exit : string is remapped as needed
*/
void
dos_toupper(register char *string)
{
       while (*string)
       {                           
              *string = make_upper(*string);
              string++;
       }
}



/*** is_internal - determine if a given command represents an internal
*    or external command.  If we try to exec an internal command on
*    its own, without COMMAND/C, we are told the command can't be found.
*    If we exec an external command using Command, Command puts up an
*    unpleasant error message if it can't find it, and doesn't tell us.
*    So we have a special hack here to distinguish between internal and
*    external commands.
*
*      Entry: pointer to command name
*      Exit : TRUE if command is internal, FALSE if not
*/
int
is_internal(register char *name)
{
       register int i = 0;                /* index into internal name table */
       int lex_val;                       /* lexical value from strcmp() */

       while (name_table[i] != NULL)      /* while still more entries */
       {
              if (lex_val = strcmp(name, name_table[i++]) == 0)
                     return(TRUE);        /* found name, is internal */
              if (lex_val < 0)
                     return(FALSE);       /* passed name, won't find it */
       }
       
       return(FALSE);                     /* reached end of table, not found */
}



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\join\joinpars.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*  */
/*----------------------------------------------------------------------+
|                                                                       |
| This file contains the structures and defines that are needed to use  |
| the parser from a C program.                                          |
|   ** customized for the JOIN and SUBST utilities **                   |
|                                                                       |
| Date:         5-21-87                                                 |
|                                                                       |
|                                                                       |
+----------------------------------------------------------------------*/


struct p_parms
        {
        struct p_parmsx *p_parmsx_address;      /* address of p_parmsx */
        unsigned char   p_num_extra;            /* number of extra stuff */
        };

struct p_parmsx
        {
        unsigned char   p_minp;                 /* Minimum positional number */
        unsigned char   p_maxp;                 /* Maximum positional number  */
        struct p_control_blk *p_control1;       /* Address of the 1st CONTROL block */
        struct p_control_blk *p_control2;       /* Address of the 2nd CONTROL block */
        unsigned char   p_maxs;                 /* Maximun switches */
        struct p_switch_blk *p_switch1;         /* Address of the SWITCH block */
        struct p_switch_blk *p_switch2;         /* Address of the SWITCH block */
        unsigned char   p_maxk;                 /* Maximum keywords */
        };


struct p_control_blk
        {
        unsigned int    p_match_flag;           /* Controls type matched */
        unsigned int    p_function_flag;        /* Function should be taken */
        unsigned int    p_result_buf;           /* Result buffer address */
        unsigned int    p_value_list;           /* Value list address */
        unsigned char   p_nid;                  /* # of keyword/SW synonyms */
        };

struct p_switch_blk
        {
        unsigned int   sp_match_flag;           /* Controls type matched */
        unsigned int   sp_function_flag;        /* Function should be taken */
        unsigned int   sp_result_buf;           /* Result buffer address */
        unsigned int   sp_value_list;           /* Value list address */
        unsigned char  sp_nid;                  /* # of keyword/SW synonyms */
        unsigned char  sp_keyorsw[3];           /* keyword or sw */
        };

/* Match_Flags */

#define P_Num_Val               0x8000          /* Numeric Value */
#define P_SNum_Val              0x4000          /* Signed numeric value */
#define P_Simple_S              0x2000          /* Simple string */
#define P_Date_S                0x1000          /* Date string */
#define P_Time_S                0x0800          /* Time string */
#define P_Cmpx_S                0x0400          /* Complex string */
#define P_File_Spc              0x0200          /* File Spec */
#define P_Drv_Only              0x0100          /* Drive Only */
#define P_Qu_String             0x0080          /* Quoted string */
#define P_Ig_Colon              0x0010          /* Ignore colon at end in match */
#define P_Repeat                0x0002          /* Repeat allowed */
#define P_Optional              0x0001          /* Optional */

/*----------------------------------------------------------------------+
|                                                                       |
|  Function flags                                                       |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_CAP_File              0x0001          /* CAP result by file table */
#define P_CAP_Char              0x0002          /* CAP result by character table */
#define P_Rm_Colon              0x0010          /* Remove ":" at the end */



#define P_nval_None             0               /* no value list ID */
#define P_nval_Range            1               /* range list ID */
#define P_nval_Value            2               /* value list ID */
#define P_nval_String           3               /* string list ID */
#define P_Len_Range             9               /* Length of a range choice(two DD plus one DB) */
#define P_Len_Value             5               /* Length of a value choice(one DD plus one DB) */
#define P_Len_String            3               /* Length of a string choice(one DW plus one DB) */


/*----------------------------------------------------------------------+
|                                                                       |
|  Result block structure                                               |
|                                                                       |
+----------------------------------------------------------------------*/

struct p_result_blk
        {
        unsigned char   P_Type;                 /* Type returned */
        unsigned char   P_Item_Tag;             /* Matched item tag */
        unsigned int    P_SYNONYM_Ptr;          /* pointer to Synonym list returned */
        unsigned int    p_result_buff[2];       /* result value */
        };

struct p_fresult_blk
        {
        unsigned char  fP_Type;                 /* Type returned */
        unsigned char  fP_Item_Tag;             /* Matched item tag */
        unsigned int   fP_SYNONYM_Ptr;          /* pointer to Synonym list returned */
        char far *     fp_result_buff;          /* result value */
        };

/*----------------------------------------------------------------------+
|                                                                       |
|  type                                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_EOL                   0               /* End of line */
#define P_Number                1               /* Number */
#define P_List_Idx              2               /* List Index */
#define P_String                3               /* String */
#define P_Complex               4               /* Complex */
#define P_File_Spec             5               /* File Spec */
#define P_Drive                 6               /* Drive */
#define P_Date_F                7               /* Date */
#define P_Time_F                8               /* Time */
#define P_Quoted_String         9               /* Quoted String */

#define P_No_Tag                0x0FF           /* No ITEM_TAG found */

/*----------------------------------------------------------------------+
|                                                                       |
|  Value list structure                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

struct noval
        {
        unsigned char   null;
        };

/*----------------------------------------------------------------------+
|                                                                       |
|  following return code will be returned in the AX register.           |
|                                                                       |
+----------------------------------------------------------------------*/

#define P_No_Error              0               /* No error */
#define P_Too_Many              1               /* Too many operands */
#define P_Op_Missing            2               /* Required operand missing */
#define P_Not_In_SW             3               /* Not in switch list provided */
#define P_Not_In_Key            4               /* Not in keyword list provided */
#define P_Out_Of_Range          6               /* Out of range specified */
#define P_Not_In_Val            7               /* Not in value list provided */
#define P_Not_In_Str            8               /* Not in string list provided */
#define P_Syntax                9               /* Syntax error */
#define P_RC_EOL                0x0ffff         /* End of command line */



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\join\join.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*    */
/**************************************************************************/
/*                                                                        */
/*  UTILITY NAME:      Join                                               */
/*                                                                        */
/*  SOURCE FILE NAME:  Join.C                                             */
/*                                                                        */
/*  STATUS:            Join Utility, DOS Version 4.0                      */
/*                                                                        */
/*  FUNCTIONAL DESCRIPTION:  This utility allows the splicing of a        */
/*    physical drive to a pathname on another physical drive such that    */
/*    operations performed using the pathname as an argument take place   */
/*    on the physical drive.                                              */
/*                                                                        */
/*  SYNTAX:            [d:][path]JOIN                      or             */
/*                     [d:][path]JOIN d: d:\directory      or             */
/*                     [d:][path]JOIN d: /D                               */
/*            where:                                                      */
/*                     [d:][path] to specify the drive and path that      */
/*                     contains the JOIN command file, if it is not       */
/*                     in the current directory of the default drive.     */
/*                                                                        */
/*                     d: to specify the drive to be connected to a       */
/*                     directory on another drive.                        */
/*                                                                        */
/*                     d:\directory to specify the directory that         */
/*                     you will join a drive under.  The directory        */
/*                     must be at the root and only one level deep.       */
/*                                                                        */
/*                     /D to disconnect a join.  You must specify the     */
/*                        drive letter of the drive whose join you        */
/*                        want to delete.                                 */
/*                                                                        */
/*  LINKS:                                                                */
/*    CDS.C       - Functions to get/set DOS CDS structures               */
/*    DPB.C       - Functions to get DOS DPB structures                   */
/*    ERRTST.C    - Drive and path validity testing functions             */
/*    SYSVAR.C    - Functions to get/set DOS System Variable structures   */
/*    COMSUBS.LIB - DOS DBCS function calls                               */
/*    MAPPER.LIB  - DOS function calls                                    */
/*    SLIBC3.LIB  - C library functions                                   */
/*    _MSGRET.SAL - Assembler interface for common DOS message services   */
/*    _PARSE.SAL  - Assembler interface for common DOS parser             */
/*                                                                        */
/*  ERROR HANDLING:    Error message displayed and utility is terminated. */
/*                                                                        */
/**************************************************************************/

#include <string.h>

#include "cds.h"
#include "ctype.h"
#include "dos.h"
#include "joinpars.h"                  /* Parser structures */
#include "jointype.h"
#include "stdio.h"
#include "sysvar.h"
#include "join.h"


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   main (program entry point)                         */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Preload message file                            */
/*                        Get the command line parameters                 */
/*                        Parse the command line by calling SYSPARSEC     */
/*                        Verify the correctness of the parameters        */
/*                        Check for splice deletion switch                */
/*                        Determine if directory not empty                */
/*                        Check source and destination drives not same    */
/*                        Determine if network or shared drive            */
/*                        Determine if currently spliced                  */
/*                        Determine if existing dir or can't mkdir        */
/*                        Print messages by calling SYSDISPMSG            */
/*                                                                        */
/*  EXTERNAL ROUTINES:    SYSLOADMSG                                      */
/*                        SYSDISPMSG                                      */
/*                        SYSPARSE                                        */
/*                                                                        */
/**************************************************************************/

int main(c, v)
int c;
char *v[];
{
  struct CDSType CDS;                  /* pointer to CDS structure */
  int delflag;                         /* delete splice flag */
  int drv;                             /* drive number */
  int index;                           /* loop counter */

  
  load_msg();                               /* Point to msgs & chks DOS ver */
  for (index = 1; index <= c; index++)      /* Loop through end of cmd line */
  {
    strcat(source,v[index]);                /* Add the argument */
    strcat(source," ");                     /* Separate with a space */
  }
  Parser_Prep(source);                      /* Initialization for the parser */

  delflag = ParseIt();

  GetVars(&SysVars);                        /* Access to DOS data structures */
  strcpy(fix_es_reg,NULL);                  /* (Set es reg correct) */

  if (c == 1)
    DoList();                               /* list splices */
  else
  {
    drv = p_drive[0] - 'A';                 /* Convert to drive # */
    if (!fGetCDS(drv, &CDS))
      dispmsg_terminate(MSG_BADPARM,cmdln_drive);

    strcpy(fix_es_reg,NULL);                /* (Set es reg correct) */
    if (delflag)                            /* Deassigning perhaps? */
      Delete(CDS,drv);
    else
      Insert(CDS,drv);
  }
  exit(0);
  return(0);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   ParseIt                                            */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Parse the command line entered by the user.     */
/*                        Returns whether or not the /d switch was used.  */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            command line is parsed                             */
/*                     returns whether or not /d switch was used          */
/*                                                                        */
/**************************************************************************/

int ParseIt()
{
  char far * fptr;                     /* Pointer to parser's buffer */
  int delflag       = FALSE;           /* delete splice flag */
  int fchar         = 0;               /* Parser filespec chars */
  int index;                           /* Used in creating cmdline string */
  int more_to_parse = TRUE;            /* While parsing cmdline */
  int pdrive_flg    = FALSE;           /* Is there a drive letter? */
  int pflspec_flg   = FALSE;           /* Is there a filespec? */

  
  while (more_to_parse)                      /* test the flag */
  {
    index = 0;                              /* Init array index */
    parse(&inregs,&outregs);                /* call the parser */
    if (outregs.x.ax == P_No_Error)         /* if no error */
    {
      /* if result is drive letter */
      if (outregs.x.dx == (unsigned short)&rslt1)
      {
        /* save the drive letter */
        p_drive[0] = (char)*(rslt1.p_result_buff);
        p_drive[0] += (char)ASCII_DRIVE;
        p_drive[1] = COLON;
        pdrive_flg = TRUE;                  /* and set the flag */
        /* Copy whatever parser just parsed */
        for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
        {
          cmdln_drive[index] = *(char *)inregs.x.si;
          index++;
        }
      }
      else
      {
        /* if result is filespec */
        if (outregs.x.dx == (unsigned short)&rslt2)
        {
          /* Point to parser's buffer */
          for (fptr = rslt2.fp_result_buff; (char)*fptr != NULL; fptr++)
          {
            p_filespec[fchar] = (char)*fptr;     /* Copy char */
            fchar++;
          }
          strcpy(fix_es_reg,NULL);               /* (Set es reg correct) */
          pflspec_flg = TRUE;                    /* and set the flag */
          /* Copy whatever parser just parsed */
          for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
          {
            cmdln_flspec[index] = *(char *)inregs.x.si;
            index++;
          }
        }
        else   /* must be &rslt3 (switches) */
        {
	  if ((char *)rslt3.P_SYNONYM_Ptr == p_swi1.sp_keyorsw)      /* /D */
	  {
	    if (!delflag)                   /* Check for dup switch */
	      delflag = TRUE;               /* it's /D switch */
	    else                            /* else it's a dup switch */
	      dispmsg_terminate(MSG_INVSWTCH, p_swi1.sp_keyorsw);
	  }
	  else   /* assume it's /? */
            DisplayOptionsExit();
        }
      }
    }
    else
    {
      if (outregs.x.ax != P_RC_EOL)         /* there must be an error */
      {
        /* Copy whatever parser just parsed */
        for (inregs.x.si; inregs.x.si < outregs.x.si; inregs.x.si++)
        {
          cmdln_invalid[index] = *(char *)inregs.x.si;
          index++;
        }
        switch (outregs.x.ax)               /* See what error parser may have found */
        {
          case P_Too_Many :
              /* Too Many Parameters - more_to_parse = FALSE */
              dispmsg_terminate(MSG_PARMNUM,cmdln_invalid);
              break;
          case P_Not_In_SW :
              /* Invalid Switch - more_to_parse = FALSE */
              dispmsg_terminate(MSG_INVSWTCH,cmdln_invalid);
              break;
          case P_Op_Missing   :             /* Required operand missing */
          case P_Not_In_Key   :             /* Not in kywrd list provided */
          case P_Out_Of_Range :             /* Out of range specified */
          case P_Not_In_Val   :             /* Not in val list provided */
          case P_Not_In_Str   :             /* Not in strg list provided */
          case P_Syntax       :             /* Incorrect syntax */
              /* more_to_parse = FALSE */
              dispmsg_terminate(MSG_BADPARM,cmdln_invalid);
              break;
          default :
              /* more_to_parse = FALSE */
              dispmsg_terminate(MSG_BADPARM,cmdln_invalid);
              break;
        }
      }
      else
        more_to_parse = FALSE;               /* End of the cmdline */
    }
    inregs.x.cx = outregs.x.cx;             /* Move the count */
    inregs.x.si = outregs.x.si;             /* Move the pointer */
  }

  /* If drive & no flspec or delete, then display error msg & exit utility */
  if (pdrive_flg && !(pflspec_flg || delflag))
    dispmsg_terminate(MSG_BADPARM,cmdln_drive);

  /* If filespec & no drive, then display error msg & exit utility */
  if (pflspec_flg && !pdrive_flg)
    dispmsg_terminate(MSG_BADPARM,cmdln_flspec);

  /* If delete & no drive, then display error msg & exit utility */
  if (delflag && !pdrive_flg)
    dispmsg_terminate(MSG_BADPARM, p_swi1.sp_keyorsw);

  /* If drive, filespec, & /D, then display error msg & exit utility */
  if (pdrive_flg && pflspec_flg && delflag)
    dispmsg_terminate(MSG_PARMNUM, p_swi1.sp_keyorsw);

  return(delflag);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   DoList                                             */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Prints list of current joins                    */
/*                                                                        */
/*  INPUT:             none                                               */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void DoList()
{
  int i;                                    /* loop counter */
  struct CDSType CDS;                       /* pointer to CDS structure */

  for (i=0; fGetCDS(i, &CDS); i++)
  {
    if (TESTFLAG(CDS.flags,CDSSPLICE))
      printf("%c: => %s\n", i+'A', CDS.text);
  }
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   Delete                                             */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Cancel join command for drive specified.        */
/*                                                                        */
/*  INPUT:             CDS - pointer to CDS structure                     */
/*                     drv - drive number                                 */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void Delete(CDS,drv)
struct CDSType CDS;
int drv;
{
  if (!TESTFLAG(CDS.flags, CDSSPLICE))  /* If NOT spliced */
    dispmsg_terminate(MSG_BADPARM, p_swi1.sp_keyorsw);

  if (fPathErr(CDS.text))               /* If prefix of current directory */
    dispmsg_terminate(MSG_BADPARM,cmdln_drive);

  CDS.text[0] = (char)(drv) + 'A';
  CDS.text[1] = ':';
  CDS.text[2] = '\\';
  CDS.text[3] = 0;
  CDS.cbEnd = 2;

  if (drv >= SysVars.cDrv)
    CDS.flags = FALSE;
  else
    CDS.flags = CDSINUSE;
  GetVars(&SysVars);
  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
  SysVars.fSplice--;
  PutVars(&SysVars);
  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
  fPutCDS(drv, &CDS);
  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   Insert                                             */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Joins a disk drive to a directory on another    */
/*                        disk drive.                                     */
/*                                                                        */
/*  INPUT:             CDS - pointer to CDS structure                     */
/*                     drv - drive number                                 */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/**************************************************************************/

void Insert(CDS,drv)
struct CDSType CDS;
int drv;
{
  struct findType findbuf;             /* findfirst structure */
  char path [MAXPATHLEN],*p;           /* pointers to path */
  int dstdrv;                          /* dest. drive number */

  
  if (TESTFLAG(CDS.flags,CDSSPLICE))    /* If now spliced */
    dispmsg_terminate(MSG_BADPARM,cmdln_drive);

  rootpath(p_filespec,path);            /* Get root path */

  /* Start - Can't move current drive */
  if (drv == getdrv() || !fPhysical(drv) || fShared(drv))
  {                                     /* Determine if NET error */
    if (fNet(drv) || fShared(drv))
      dispmsg_terminate(MSG_NETERR, NULL);
    dispmsg_terminate(MSG_BADPARM,cmdln_drive);
  }

  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
  /* OR current directory prefix */
  if (fPathErr(path) || *strbscan(path+3, "/\\") != 0)
    dispmsg_terminate(MSG_BADPARM,cmdln_flspec);

  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
  if (fNet(path[0] - 'A') || fShared(path[0] - 'A'))
    dispmsg_terminate(MSG_NETERR, NULL);

  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
  dstdrv = *path - 'A';                 /* Check src and dst drvs different */
  if (drv == dstdrv)                      
    dispmsg_terminate (MSG_BADPARM,cmdln_flspec);
  if (mkdir(path) == -1)                /* If can't mkdir or if no dir or */
  {                                     /* if note is file  */
    if (ffirst(path, A_D, &findbuf) == -1 || !TESTFLAG(findbuf.attr,A_D))
      dispmsg_terminate(MSG_BADPARM,cmdln_flspec);

    p = path + strlen(path);
    strcat(p, "\\*.*");

    if (ffirst(path, 0, &findbuf) != -1)     /* If dir not empty */
      dispmsg_terminate(MSG_DIRNEMP,cmdln_flspec);

    *p = 0;
  }

  strcpy(CDS.text, path);
  CDS.flags = CDSINUSE | CDSSPLICE;
  fPutCDS(drv, &CDS);
  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
  GetVars(&SysVars);
  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
  SysVars.fSplice++;
  PutVars(&SysVars);
  strcpy(fix_es_reg,NULL);              /* (Set es reg correct) */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   load_msg                                           */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Load the set of SUBST Utility messages to       */
/*                        become available for display_msg call.          */
/*                                                                        */
/*  ERROR EXIT:        Utility will be terminated by sysloadmsg if        */
/*                     version check is incorrect.                        */
/*                                                                        */
/*  EXTERNAL REF:      SYSLOADMSG                                         */
/*                                                                        */
/**************************************************************************/

void load_msg()
{
   sysloadmsg(&inregs,&outregs);            /* Load utility messages */
   if (outregs.x.cflag & CARRY)             /* If problem loading msgs */
   {
     sysdispmsg(&outregs,&outregs);         /* then display the err msg */
     exit(ERRORLEVEL1);                     /* and exit utility */
   }
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   display_msg                                        */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  The correct message called by main is displayed */
/*                        to standard out.                                */
/*                                                                        */
/*  INPUT:             msg_num   (message number to display)              */
/*                     outline   (substitution parameter)                 */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/*  ERROR EXIT:        Display error message corresponding to number      */
/*                     returned in AX.                                    */
/*                                                                        */
/*  EXTERNAL REF:      SYSDISPMSG                                         */
/*                                                                        */
/**************************************************************************/

void display_msg(msg_num,outline)
int msg_num;                                /* Message number #define'd */
char *outline;                              /* Substitution parameter */
{
  unsigned char function;                   /* Y/N response or press key? */
  unsigned int message,                     /* Message number to display */
               msg_class,                   /* Which class of messages? */
               sub_cnt,                     /* Number of substitutions? */
               handle;                      /* Display where? */

  struct sublist
  {
    unsigned char size;                     /* Points to next sublist */
    unsigned char reserved;                 /* Required for disp msg */
    unsigned far *value;                    /* Data pointer */
    unsigned char id;                       /* Id of substitution parm (%1) */
    unsigned char flags;                    /* Format of data - (a0sstttt) */
    unsigned char max_width;                /* Maximum field width */
    unsigned char min_width;                /* Minimum field width */
    unsigned char pad_char;                 /* char to pad field */
  } sublist;

  switch (msg_num)                          /* Which msg to display? */
  {
    case MSG_NOMEM :
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 8;                      /* Message number to display */
        msg_class = EXT_ERR_CLASS;          /* Which class of messages? */
        sub_cnt   = SUBCNT0;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_PARMNUM :
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 1;                      /* Message number to display */
        msg_class = PARSE_ERR_CLASS;        /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_DIRNEMP :
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 2;                      /* Message number to display */
        msg_class = UTILITY_CLASS;          /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_BADPARM :
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 10;                     /* Message number to display */
        msg_class = PARSE_ERR_CLASS;        /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_NETERR :
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 12;                     /* Message number to display */
        msg_class = UTILITY_CLASS;          /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;
    case MSG_INVSWTCH :
        function  = NO_INPUT;               /* Y/N response or press key? */
        message   = 3;                      /* Message number to display */
        msg_class = PARSE_ERR_CLASS;        /* Which class of messages? */
        sub_cnt   = SUBCNT1;                /* Number of substitutions? */
        handle    = STDERR;                 /* Display where? */
        break;

    default:
        if (msg_num >= MSG_OPTIONS_FIRST && msg_num <= MSG_OPTIONS_LAST)
        {
          function  = NO_INPUT;
          message   = msg_num;
          msg_class = UTILITY_CLASS;
          sub_cnt   = SUBCNT0;
          handle    = STDOUT;
        }
        else
          exit(ERRORLEVEL1);
        break;
  }

  switch (msg_num)
  {
    case MSG_NOMEM :
        inregs.x.ax = message;                   /* Insufficient memory */
        inregs.x.bx = handle;                    /* STDERR */
        inregs.x.cx = sub_cnt;                   /* SUBCNT0 */
        inregs.h.dl = function;                  /* NO_INPUT */
        inregs.h.dh = (unsigned char)msg_class;  /* Extended, Parse or Utility */
        sysdispmsg(&inregs,&outregs);            /* Call common msg service */
        break;
    case MSG_INVSWTCH :                          /* Invalid switch */
    case MSG_DIRNEMP  :                          /* Directory not empty */
    case MSG_PARMNUM  :                          /* Too many parameters */
    case MSG_BADPARM  :
        sublist.value = (unsigned far *)outline;      /* Invalid parameter */
        sublist.size = SUBLIST_LENGTH;
        sublist.reserved = RESERVED;
        sublist.id = 0;
        sublist.flags = STR_INPUT;
        sublist.max_width = MAXWIDTH;
        sublist.min_width = MINWIDTH;
        sublist.pad_char = (unsigned char)BLNK;
        inregs.x.ax = message;                   /* Cannot JOIN a network drive */
        inregs.x.bx = handle;                    /* STDERR */
        inregs.x.si = (unsigned int)&sublist;    /* Point to substitution buffer */
        inregs.x.cx = sub_cnt;                   /* SUBCNT1 */
        inregs.h.dl = function;                  /* STR_INPUT */
        inregs.h.dh = (unsigned char)msg_class;  /* Extended, Parse or Utility */
        sysdispmsg(&inregs,&outregs);            /* Call common msg service */
        break;
    case MSG_NETERR :
        sublist.value = (unsigned far *)replparm_JOIN;  /* Cannot JOIN net drive */
        sublist.size = SUBLIST_LENGTH;
        sublist.reserved = RESERVED;
        sublist.id = SUB_ID1;
        sublist.flags = STR_INPUT;
        sublist.max_width = MAXWIDTH;
        sublist.min_width = MINWIDTH;
        sublist.pad_char = (unsigned char)BLNK;
        inregs.x.ax = message;                   /* Cannot JOIN network drive */
        inregs.x.bx = handle;                    /* STDERR */
        inregs.x.si = (unsigned int)&sublist;    /* Point to substitution buffer */
        inregs.x.cx = sub_cnt;                   /* SUBCNT1 */
        inregs.h.dl = function;                  /* STR_INPUT */
        inregs.h.dh = (unsigned char)msg_class;  /* Extended, Parse or Utility */
        sysdispmsg(&inregs,&outregs);            /* Call common msg service */
        break;
    default:
        if (msg_num >= MSG_OPTIONS_FIRST && msg_num <= MSG_OPTIONS_LAST)
        {
          inregs.x.ax = message;
          inregs.x.bx = handle;
          inregs.x.cx = sub_cnt;
          inregs.h.dl = function;
          inregs.h.dh = (unsigned char)msg_class;
          sysdispmsg(&inregs,&outregs);
        }
        else
          exit(ERRORLEVEL1);
        break;
  }

  if (outregs.x.cflag & CARRY)              /* Is the carry flag set? */
  {                                         /* Then setup regs for extd-err */
    inregs.x.bx = STDERR;
    inregs.x.cx = SUBCNT0;
    inregs.h.dl = NO_INPUT;
    inregs.h.dh = EXT_ERR_CLASS;
    sysdispmsg(&inregs,&outregs);           /* Call to display ext_err msg */
    exit(ERRORLEVEL1);
  }
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   DisplayOptionsExit                                 */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Display the options help message to the user,   */
/*                        and then exit so they may try again.            */
/*                                                                        */
/*  INPUT:             no value passed.                                   */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/*  ERROR EXIT:        none                                               */
/*                                                                        */
/*  EXTERNAL REF:      display_msg()                                      */
/*                     exit()                                             */
/*                                                                        */
/**************************************************************************/

void DisplayOptionsExit()
{
  int MsgNbr;

  /*
   * Display all the message lines in the
   * options help message.
   */
  for (MsgNbr = MSG_OPTIONS_FIRST; MsgNbr <= MSG_OPTIONS_LAST; MsgNbr++)
    display_msg(MsgNbr, (char *)0);

  /*
   * Exit so the user may try again.
   */
  exit(0);
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   dispmsg_terminate                                  */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Display the message, then terminate the utility.*/
/*                                                                        */
/*  INPUT:             msg_num     (#define'd message to display)         */
/*                     outline     (substitution parameter)               */
/*                                                                        */
/**************************************************************************/

void dispmsg_terminate(msg_num,outline)
int msg_num;                                /* Message number #define'd */
char *outline;                              /* Substitution parameter */
{
  display_msg(msg_num,outline);             /* First, display the msg */
  exit(ERRORLEVEL1);                        /* Then, terminate utility */
}


/**************************************************************************/
/*                                                                        */
/*  SUBROUTINE NAME:   Parser_Prep                                        */
/*                                                                        */
/*  SUBROUTINE FUNCTION:  Initialize all structures for the parser.       */
/*                                                                        */
/*  INPUT:             source (command line string)                       */
/*                                                                        */
/*  OUTPUT:            none                                               */
/*                                                                        */
/*  EXTERNAL REF:      parse                                              */
/*                                                                        */
/**************************************************************************/

void Parser_Prep(source)
char *source;                                    /* Commandline */
{
  p_p.p_parmsx_address = &p_px;                  /* Addr of extended parm list */
  p_p.p_num_extra = 0;                           /* No extra declarations */

  p_px.p_minp = MINPOSITION;
  p_px.p_maxp = MAXPOSITION;
  p_px.p_control1 = &p_con1;                     /* Point to 1st control blk */
  p_px.p_control2 = &p_con2;                     /* Point to 2nd control blk */
  p_px.p_maxs = 2;                               /* Specify # of switches */
  p_px.p_switch1 = &p_swi1;                      /* Point to the switch blk */
  p_px.p_switch2 = &p_swi2;                      /* Point to the switch blk */
  p_px.p_maxk = 0;                               /* Specify # of keywords */

  p_con1.p_match_flag = DRVONLY_OPT;             /* Drive only & optional */
  p_con1.p_function_flag = NOCAPPING;            /* Cap result by file table */
  p_con1.p_result_buf = (unsigned int)&rslt1;    /* Point to result blk */
  p_con1.p_value_list = (unsigned int)&novals;   /* Point to no value list */
  p_con1.p_nid = 0;                              /* Not a switch id */

  p_con2.p_match_flag = FILESPEC_OPT;            /* File spec & optional */
  p_con2.p_function_flag = CAPRESULT;            /* Cap result by file table */
  p_con2.p_result_buf = (unsigned int)&rslt2;    /* Point to result blk */
  p_con2.p_value_list = (unsigned int)&novals;   /* Point to no value list */
  p_con2.p_nid = 0;                              /* Not a switch id */

  p_swi1.sp_match_flag = SWITCH_OPT;             /* Optional (switch) */
  p_swi1.sp_function_flag = NOCAPPING;           /* Cap result by file table */
  p_swi1.sp_result_buf = (unsigned int)&rslt3;   /* Point to result blk */
  p_swi1.sp_value_list = (unsigned int)&novals;  /* Point to no value list */
  p_swi1.sp_nid = 1;                             /* One switch allowed */
  strcpy(p_swi1.sp_keyorsw,D_SWITCH);            /* Identify the switch */

  p_swi2.sp_match_flag = SWITCH_OPT;             /* Optional (switch) */
  p_swi2.sp_function_flag = NOCAPPING;           /* Cap result by file table */
  p_swi2.sp_result_buf = (unsigned int)&rslt3;   /* Point to result blk */
  p_swi2.sp_value_list = (unsigned int)&novals;  /* Point to no value list */
  p_swi2.sp_nid = 1;                             /* One switch allowed */
  strcpy(p_swi2.sp_keyorsw,O_SWITCH);            /* Identify the switch */

  inregs.x.cx = 0;                               /* Operand ordinal */
  inregs.x.di = (unsigned int)&p_p;              /* Address of parm list */
  inregs.x.si = (unsigned int)source;            /* Make DS:SI point to source */
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\join\_parse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
page	60,132
name	_parse
title	C	to PARSER interface
;-------------------------------------------------------------------
;
;	MODULE: 	_parse
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 parser
;
;		      **(Customized for the JOIN utility)
;
;	CALLING FORMAT:
;			parse(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

;	extrn	sysparse:far

	public	_parse								;AN000;

;-------------------------------------------------------------------

; set for JOIN
; -------------

FarSW	equ	0			; make sysparse be a NEAR proc		;AN000;
TimeSW	equ	0			; Check time format			;AN000;
FileSW	equ	1			; Check file specification		;AN000;
CAPSW	equ	1			; Perform CAPS if specified		;AN000;
CmpxSW	equ	0			; Check complex list			;AN000;
NumSW	equ	0			; Check numeric value			;AN000;
KeySW	equ	0			; Support keywords			;AN000;
SwSW	equ	1			; Support switches			;AN000;
Val1SW	equ	0			; Support value definition 1		;AN000;
Val2SW	equ	0			; Support value definition 2		;AN000;
Val3SW	equ	0			; Support value definition 3		;AN000;
DrvSW	equ	1			; Support drive only format		;AN000;
QusSW	equ	0			; Support quoted string format		;AN000;
;-------------------------------------------------------------------

DGROUP	GROUP	_DATA
PGROUP	GROUP	_TEXT

_DATA	segment byte public 'DATA'	;AN000;
BASESW	=	1			;SPECIFY, PSDATA POINTED TO BY "DS"
INCSW	=	0			;PSDATA.INC IS ALREADY INCLUDED
	include version.inc
	INCLUDE PSDATA.INC		;PARSER'S WORK SPACE
_DATA	ends				;AN000;

_TEXT	segment byte public 'CODE'	;AN000;

	ASSUME	CS: PGROUP		;AN000;
	ASSUME	DS: DGROUP		;AN000;

;-------------------------------------------------------------------
include parse.asm			; include the parser			;AN000;
;-------------------------------------------------------------------

_parse	proc	near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysparse		; call the parser			;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_parse	endp									;AN000;

_TEXT	ends				; end code segment			;AN000;
	end									;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\join\_msgret.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
page	60,132
name	_msgret
title	C	to Message Retriever
;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			sysloadmsg(&inregs,&outregs);
;			sysgetmsg(&inregs,&outregs);
;			sysdispmsg(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION;AN000;

	MSG_UTILNAME <JOIN>		;IDENTIFY THE COMPONENT 		;AN000;

	.8087									;AN000;
_TEXT	SEGMENT BYTE PUBLIC 'CODE'						;AN000;
_TEXT	ENDS									;AN000;
_DATA	SEGMENT WORD PUBLIC 'DATA'						;AN000;
_DATA	ENDS									;AN000;
CONST	SEGMENT WORD PUBLIC 'CONST'						;AN000;
CONST	ENDS									;AN000;
_BSS	SEGMENT WORD PUBLIC 'BSS'						;AN000;
_BSS	ENDS									;AN000;
DGROUP	GROUP	CONST, _BSS, _DATA						;AN000;
	ASSUME	CS: _TEXT, DS: _TEXT, SS: DGROUP, ES: DGROUP			;AN000;


	public	_sysloadmsg							;AN000;
	public	_sysgetmsg							;AN000;
	public	_sysdispmsg							;AN000;

;-------------------------------------------------------------------
;-------------------------------------------------------------------

_DATA	segment 								;AN000;
.XLIST										;AN000;
.XCREF										;AN000;
	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	;AN000;
.LIST										;AN000;
.CREF										;AN000;
_DATA	ends									;AN000;


_TEXT	segment 								;AN000;

;-------------------------------------------------------------------

; =  =	=  =  =  =  =  =  =  =	=  =

					;DEFAULT=CHECK DOS VERSION		;AN000;
					;DEFAULT=NEARmsg			;AN000;
					;DEFAULT=INPUTmsg			;AN000;
					;DEFAULT=NUMmsg 			;AN000;
					;DEFAULT=NO TIMEmsg			;AN000;
					;DEFAULT=NO DATEmsg			;AN000;
;	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,INPUTmsg,FARmsg>;AN000;
;	MSG_SERVICES <JOIN.CLA,JOIN.CL1,JOIN.CL2> ;MSG TEXT			;AN000;
.XLIST										;AN000;
.XCREF										;AN000;
;	MSG_SERVICES <MSGDATA>		;DATA AREA FOR THE MESSAGE HANDLER	;AN000;
	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,TIMEmsg,DATEmsg,INPUTmsg,FARmsg>;AN000;
	MSG_SERVICES <JOIN.CLA,JOIN.CL1,JOIN.CL2> ;MSG TEXT			;AN000;
.LIST										;AN000;
.CREF										;AN000;
;-------------------------------------------------------------------

_sysloadmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysloadmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysloadmsg endp								;AN000;


_sysgetmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysgetmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysgetmsg endp 								;AN000;

_sysdispmsg proc near								;AN000;

	push	bp			; save user's base pointer              ;AN000;
	mov	bp,sp			; set bp to current sp			;AN000;
	push	di			; save some registers			;AN000;
	push	si								;AN000;

;	copy C inregs into proper registers

	mov	di,[bp+4]		; fix di (arg 0)			;AN000;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di				;AN000;
	push	ax			; the di value from inregs is now on stack;AN000;

	mov	ax,[di+00]		; get inregs.x.ax			;AN000;
	mov	bx,[di+02]		; get inregs.x.bx			;AN000;
	mov	cx,[di+04]		; get inregs.x.cx			;AN000;
	mov	dx,[di+06]		; get inregs.x.dx			;AN000;
	mov	si,[di+08]		; get inregs.x.si			;AN000;
	pop	di			; get inregs.x.di from stack		;AN000;

	push	bp			; save base pointer			;AN000;

;-------------------------------------------------------------------
	call	sysdispmsg		; call the message retriever		;AN000;
;-------------------------------------------------------------------

	pop	bp			; restore base pointer			;AN000;
	push	di			; the di value from call is now on stack;AN000;
	mov	di,[bp+6]		; fix di (arg 1)			;AN000;

	mov	[di+00],ax		; load outregs.x.ax			;AN000;
	mov	[di+02],bx		; load outregs.x.bx			;AN000;
	mov	[di+04],cx		; load outregs.x.cx			;AN000;
	mov	[di+06],dx		; load outregs.x.dx			;AN000;
	mov	[di+08],si		; load outregs.x.si			;AN000;

	lahf				; get flags into ax			;AN000;
	mov	al,ah			; move into low byte			;AN000;
	mov	[di+0ch],ax		; load outregs.x.cflag			;AN000;

	pop	ax			; get di from stack			;AN000;
	mov	[di+0ah],ax		; load outregs.x.di			;AN000;

;-------------------------------------------------------------------

	pop	si			; restore registers			;AN000;
	pop	di								;AN000;
	mov	sp,bp			; restore sp				;AN000;
	pop	bp			; restore user's bp                     ;AN000;
	ret									;AN000;

_sysdispmsg endp								;AN000;

include msgdcl.inc

_TEXT	ends				; end code segment			;AN000;
	end									;AN000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\kbmsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
									      ;;

;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;

ACT_KEYB    DB	  'Current keyboard code: ','$'                               ;;
ACT_KEYB_CP DB	  '  code page: ','$'                                         ;;
ACT_CON_CP  DB	  'Current CON code page: ','$'                               ;;
INV_L	    DB	  'Invalid keyboard code specified',10,13,'$'                 ;;
INV_I	    DB	  'Invalid keyboard ID specified',10,13,'$'                 ;;
INV_CP	    DB	  'Invalid code page specified',10,13,'$'                     ;;
INV_S	    DB	  'Invalid syntax',10,13,'$'                                  ;;
INV_FN	    DB	  'Bad or missing Keyboard Definition File',10,13,'$'         ;;
INV_KEYB_Q  DB	  'KEYB has not been installed',10,13,'$'                     ;;
INV_CON_Q   DB	  'Active code page not available from CON device',10,13,'$'  ;;
NOT_DESIG   DB	  'Code page specified has not been prepared',10,13,'$'       ;;
NOT_SUPP    DB	  'One or more CON code pages invalid for given keyboard code',10,13,'$' ;;
NOT_VALID1  DB	  'Code page requested (','$'                                 ;;
NOT_VALID2  DB	  ') is not valid for given keyboard code',10,13,'$'               ;;
WARNING_1   DB	  'Code page specified is inconsistent with the selected code page',10,13,'$'  ;;
INV_COMBO   DB	  'ID code specified is inconsistent with the selected keyboard code',13,'$'  ;;
MEMORY_OVERF DB   'Unable to create KEYB table in resident memory',10,13,'$'  ;;
CR_LF	    DB	  10,13,'$'                                                   ;;
									      ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\commsubs.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
	TITLE	 MS DOS 5.0 - NLS Support - KEYB Command

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  MS DOS 5.0 - NLS Support - KEYB Command
;                                                    
;
;  File Name:  COMMSUBS.ASM
;  ----------
;
;  Description:
;  ------------
;	 Common subroutines used by NLS support
;
;  Documentation Reference:
;  ------------------------
;	 None
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;	 FIND_HW_TYPE - Determine the keyboard and system unit types and
;	       set the corresponding flags.
;
;  Include Files Required:
;  -----------------------
;	 None
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      ????????? - ???????
;
;  Change History:
;  ---------------
;  Sept 1989 For 4.02.
;		Add required JMP $+2 between OUT/IN in KEYB_SECURE,
;		remove unnecessary code and re-document routine.
;		Remove unnecessary PUSH/POP's around call to KEYB_SECURE.
;		Fix bug in FIND_KEYB_TYPE of READ ID flags not being
;		cleared on PS/2's when keyboard is security locked.
;		Clean up BIOS DATA & Extended DATA area access, use ES:.
;		Arrange KB type checks into special case group and 8042.
;		Fix delay loop timeout bug at WT_ID with REFRESH BIT type
;		fixed timeout delay of 15ms.  When the KBX flag is set
;		by BIOS, the READ_ID is done and PORT 60h is ID_2 byte.
;		AT (FCh) type machines all have the Refresh Bit at 61h.
;		Change SND_DATA_AT proc to a general send command routine
;		with REFRESH BIT timout logic and move the P-Layout test
;		into FIND_KEYB_TYPE.  Allows P-kb on all 8042 systems.
;		Add untranslated ID_2 byte to P-layout support for newer
;		PS/2's with hardware logic instead of 8042 if AT type.
;
;  Feb 1990 For 4.03.
;  PTM 6660	Add default to PC_386 type for new/unsupported system.
;		Move determination code from KEYBI9C.ASM for original PC.
;		Add Patriot/Sebring determination code for HOT Replug
;		so that INT 9 handler can alter keyboard Scan Code set.
;		Unknown system default= PC_386 with Patriot/Sebring test.
;		Add EXT_122 check for 122 key keyboard to SYSTEM_FLAG.
;M005;  ;JP9009 - Sep. 1990  DBCS keyboard support
;M005;  ;JP9010 - Oct. 1990  Server password mode support
;M005;  ;JP9011 - Nov. 1990  Mumlock LED incorrectly turns on with P-keyboard,
;M005;                       if system is started up in server password mode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	FIND_SYS_TYPE
	PUBLIC	FIND_KEYB_TYPE
	PUBLIC	HW_TYPE 
	PUBLIC	SECURE_FL

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBCPSD.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBI9C.INC
	INCLUDE KEYBCMD.INC
	INCLUDE DSEG.INC
	INCLUDE POSTEQU.INC
        INCLUDE KEYBDCL.INC             ; M005 -- JP9009

CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_SYS_TYPE
;
;  Description:
;      Determine the type of system we are running on.
;      SYSTEM_FLAG (in active SHARED_DATA) are set to
;      indicate the system type.
;      This routine is only called the first time KEYB is being installed.
;
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ROM	SEGMENT AT	0F000H
		ORG	0FFFBH
SYSROM_DATE	DW	?		; OFFSET OF ROM YEAR DIGIT

PC1DATE_ID	EQU	03138H		; YEAR ROM WAS RELEASED IN ASCII

		ORG	0FFFEH
ROMID		DB	?
					; SEGMENT F000. (F000:FFFE)

ROMPC1		EQU	0FFH		; ID OF PC1 hardware
ROMXT		EQU	0FEH		; ID OF PC-XT/PORTABLE hardware
ROMAT		EQU	0FCH		; ID OF PCAT
ROMXT_ENHAN	EQU	0FBH		; ID OF ENHANCED PCXT
ROMPAL		EQU	0FAH		; ID FOR PALACE
ROMLAP		EQU	0F9H		; ID FOR PC LAP (P-14)
ROM_RU_386	EQU	0F8H		; ID FOR ROUNDUP-386

ROM	ENDS

RTN_EXT_BIOS_DATA_SEG   EQU     0C1H    ; INT15H SUB FUNCTION  M005 -- JP9009
ROMEXT	SEGMENT AT 00000H		; ADDRESS SHOULD NOT BE FIXED AT 09FC0H
					; This just a dummy segment value, as
		ORG	0003BH		;  INT 15h - function C1 call will load
KEYBID1 	DB	?		;  ES: dynamically depending on where
					;  the ROMEXT segment is located.
					;  (9FC0 was only for old 640K systems)

;	M005 -- begin changes
;JP9009 ROMEXT  ENDS                    ;  ( ES:003B )
                ORG     00117H          ;                    ;JP9009
EXT_BIOS_DATA_KBD_ID    DW      ?       ; KEYBOARD ID(xxABH) ;JP9009
ROMEXT  ENDS                            ;                    ;JP9009
        EXTRN   SCAN_CODE_SET:BYTE      ; 01 for non SBCS keyboard(default)
                                        ; 81h or 82h for DBCS keyboard
                                        ; This value is used at hot replug.

;	M005 -- end changes

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_SYS_TYPE	       PROC  NEAR

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AX,SYSROM_DATE		; Get BIOS year date
	PUSH	AX			; save it on stack
	MOV	AL,ROMID		; Get hardware ID
	PUSH	AX			; save it

	PUSH	CS			; Set data seg back to code
	POP	DS
	ASSUME	DS:CODE 

	MOV	AH,092H 		; SET INVALID CALL FOR INT16  83 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 101/102
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_16	; Default is extended INT 16 support

	MOV	AH,0A2H 		; SET INVALID CALL FOR INT16  101 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 122/
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_122	; Also extended 122 keyboard support

CHECK_PC_NET:
	MOV	AH,30H			; GET DOS VERSION NUMBER
	INT	21H			; MAJOR # IN AL, MINOR # IN AH
	CMP	AX,0A03H		; SENSITIVE TO 3.10 OR >
	JB	CHECK_SYSTEM		; EARLIER VERSION OF DOS NOTHING
					; WAS ESTABLISHED FOR THIS SITUATION
	PUSH	ES			; Save ES just in case
	MOV	AX,3509H		; GET INT VECTOR 9 CONTENTS
	INT	21H			; ES:BX WILL = CURRENT INT9 VECTOR
					; SEE IF WE ARE THE 1ST ONES LOADED
	MOV	CX,ES			; INTO THE INT 9.  WITH DOS 3.1 WE CAN
	POP	ES			; HANDSHAKE WITH THE PC NETWORK BUT
	CMP	CX,0F000H		; BUT NO ONE ELSE CAN BE HOOK IN FIRST
	JE	CHECK_SYSTEM		; INT VECTOR 9 POINTS TO ROM, OK

	MOV	AX,0B800H		; ASK IF PC NETWORK IS INSTALLED
	INT	2FH
	or	al,al			; not installed if al=0
	JE	CHECK_SYSTEM		; SOMEBODY HAS LINKED THE INT VECTOR 9
					; & I'M GOING TO DROP RIGHT IN AS USUAL
	OR	SD.SYSTEM_FLAG,PC_NET	; INDICATE PC NET IS RUNNING

CHECK_SYSTEM:
	POP	AX			; get code back
	POP	BX			; get date back off of stack
					; Is the hardware a PCjr
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT		; IF (FE) OR (FF) THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF (FB) IT IS ALSO AN XT
	JNE	TEST_PC_AT		; IF not then check for next type

ITS_AN_XT:
	OR	SD.SYSTEM_FLAG,PC_XT	; system type
					; Check the ROM level in the system
	CMP	BX,PC1DATE_ID		; Is it the ORIGINAL PC1 version?
	JNE	SHORT FIND_SYS_END	; Done if not

	OR	SD.SYSTEM_FLAG,PC_81	; Else set the Original PC1 flag
	JMP	SHORT FIND_SYS_END

TEST_PC_AT:
					; Is the hardware an AT ?
	CMP	AL,ROMAT		; (FC)
	JNE	TEST_P12		; IF not then check for next type

	OR	SD.SYSTEM_FLAG,PC_AT	; system type with 8042 V2 interface

	JMP	SHORT FIND_SYS_END

TEST_P12:
	CMP	AL,ROMLAP		; IS this a Convertible (F9) (P12)?
	JNE	TEST_PAL		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_LAP	; system type
	JMP	SHORT FIND_SYS_END

TEST_PAL:
	CMP	AL,ROMPAL		; IS this a Model 30 (FA) (PALACE)?
	JNE	TEST_RU_386		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_PAL	; system type
	JMP	SHORT FIND_SYS_END

TEST_RU_386:
	CMP	AL,ROM_RU_386		; IS this a PS/2 with a 386 (F8)?
	JNE	TEST_SYS_NEW		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_386	; System type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring
	JMP	SHORT FIND_SYS_END

TEST_SYS_NEW:
					; ASSUME 8042 TYPE IF UNKNOWN
	OR	SD.SYSTEM_FLAG,PC_386	; Default system type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring


FIND_SYS_END:

	RET

FIND_SYS_TYPE	    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_KEYB_TYPE
;
;  Description:
;      Determine the type of keyboard we are running on.
;      KEYB_TYPE (in SHARED_DATA) is set to indicate the keyboard type.
;      This routine is only called the first time KEYB is being installed.
;      It is called after the new Interrupt 9 handler is installed.
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HW_TYPE 	DW	0
SECURE_FL	DB	0

;RESERVED ADDRESS 013h BITS 1 & 2

PASS_MODE	equ	00000001B
SERVER_MODE	equ	00000010B
SECRET_ADD	equ	13h
PORT_70 	equ	70h		; CMOS ADDRESS PORT
PORT_71 	equ	71h		; CMOS DATA PORT

ID_1		EQU	0ABh			; Keyboard ID_1 for FERRARI
TID_2		EQU	041h	   ;;AB41	; Keyboard ID_2 for FERRARI_G
ID_2U		EQU	083h	   ;;AB83	; Keyboard ID_2 for FERRARI_G
TID_2A		EQU	054h	   ;;AB54	; Keyboard ID_2 for FERRARI_P
ID_2AU		EQU	084h	   ;;AB84	; Keyboard ID_2 for FERRARI_P
ID_2JG		EQU	090h	   ;;AB90	; Keyboard ID_2 for JPN G
ID_2JP		EQU	091h	   ;;AB91	; Keyboard ID_2 for JPN P
ID_2JA		EQU	092h	   ;;AB92	; Keyboard ID_2 for JPN A

P_KB_ID 	DB	08

	extrn	pswitches:byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_KEYB_TYPE	      PROC  NEAR

	PUSH	ES
	PUSH	DS

	MOV	AX,DATA 
	MOV	ES,AX			; ES points to BIOS data
	ASSUME	ES:DATA 

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AL,ROMID		; Get hardware ID

	PUSH	CS			; Set data segment to CODE
	POP	DS
	ASSUME	DS:CODE 

	test	pswitches,2		; /e switch true?
	jz	no_force_enh
	or	es:KB_FLAG_3,KBX	; force enhanced kbd support on
no_force_enh:

	MOV	HW_TYPE,G_KB		; Default keyboard is G_KB

	CMP	AL,ROMLAP		; IS this a P12? (CONVERTABLE)
	JNE	TEST_PC_XT_2		; IF not then check for next type

	MOV	HW_TYPE,P12_KB		; IF yes then set flag
	JMP	FIND_KEYB_END		; Done

TEST_PC_XT_2:
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT_2		; IF FE OR FF THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF FB IT IS ALSO AN XT
	JNE	TEST_PS_30_2		; IF not then check for next type

ITS_AN_XT_2:
	TEST	ES:KB_FLAG_3,KBX	; IS THE ENHANCED KEYBOARD INSTALLED?
	JZ	ITS_AN_XT_3
;M005 ;JP9009 	JMP	SHORT FIND_KEYB_END	; Yes, exit
	jmp	FIND_KEYB_END	; M005 ;JP9009	; Yes, exit

ITS_AN_XT_3:
	MOV	HW_TYPE,XT_KB		; NO, normal XT keyboard
;M005 ;JP9009	JMP	SHORT FIND_KEYB_END
	jmp	FIND_KEYB_END	; M005 ;JP9009

TEST_PS_30_2:
	CMP	AL,ROMPAL		; IS this a PS/2 MODEL 30 or 25
	JNE	TEST_PC_AT_2		; IF not then check for next type

	MOV	AH,0C1H 		; Make extended bios data area call to
	INT	15H			; get the segment address for accessing
	JNC	ITS_AN_PS2_30		; the PALACE (only) keyboard byte area.
	JMP	SHORT FIND_KEYB_END	; JC   Assume Keyboard type G if error,
					; Otherwise EXTENDED BIOS DATA RETURNED
					; in the ES: and ES:003Bh is keyboard

ITS_AN_PS2_30:				; ID byte reserved for PALACE.
					; Set segment to look at extended ROM
	ASSUME	ES:ROMEXT		;    using the ES: segment
					; SEG ES: value returned by INT15h - C1
	MOV	AL,KEYBID1		; Get keyboard ID

	ASSUME	ES:NOTHING		; Don't use ES: for anything else

	AND	AL,0FH			; Remove high nibble
	CMP	AL,P_KB_ID		; IF keyboard is a FERRARI P THEN
	JNE	ITS_AN_PS2_30G
	OR	HW_TYPE,P_KB		;    Set the HW_TYPE flag to P keyboard

ITS_AN_PS2_30G: 
	JMP	SHORT FIND_KEYB_END	; Done

					; (Insert any more special cases here.)

;	At this point, all special case or older keyboard/system
;	types have been determined and HW_TYPE correctly set.
;	(PC, XT, XT Enhansed, CONVERTABLE, Model 30/25)
;
;	Assume now that the system has an 8042 type keyboard
;	interface and can be sent a READ ID command to determine
;	the type of keyboard installed.  The old AT keyboard is
;	handled as a special case of no security bits set and no
;	response to a READ ID command.	If security bits are set
;	and no KBX flag is set as a result of the READ ID, then
;	the interface is assumed to be locked and the default of
;	G-keyboard is taken as the keyboard ID can not be read.

TEST_PC_AT_2:

	ASSUME	ES:DATA 		; READ ID COMMAND TO TEST FOR A KBX

	MOV	ES:KB_FLAG_3,RD_ID	; INDICATE THAT A READ ID IS BEING DONE
					;  and clear KBX flag if set
	MOV	AL,0F2H 		; SEND THE READ ID COMMAND
	CALL	SND_DATA_AT
					; Wait 40ms for READ ID to complete
	MOV	CX,DLY_15ms		; Load count for 15ms (15,000/15.086)

WT_ID:					;      Fixed time wait loop on AT's
	TEST	ES:KB_FLAG_3,KBX	; TEST FOR KBX SET by BIOS interrupt 9h
	JNZ	DONE_AT_2		; Exit wait loop if/when flag gets set

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	WT_ID			; No, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	LOOP	WT_ID			; WAIT OTHERWISE

					; BE SURE READ ID FLAGS GOT RESET
	AND	ES:KB_FLAG_3,NOT RD_ID+LC_AB ; Clear READ ID state flags
					; As no KBX flag set
	CALL	KEYB_SECURE		; SEE IF THE KEYBOARD SECURITY IS
					; ACTIVATED AT THIS POINT
	JNC	ASSUME_AT		; SECURITY UNAVAILABLE OR AN AT KB

;	M005 -- begin changed section

        MOV     AL,0EEH                 ; We're in server password mode. We    ;JP9011
        CALL    SND_DATA_AT             ; should avoid keyboard from responding;JP9011
                                        ; to us with keyboard ID, when the     ;JP9011
                                        ; security is released. Otherwise, we  ;JP9011
                                        ; may be receiving keyboard ID bytes   ;JP9011
                                        ; as normal keyboard scan codes.       ;JP9011
                                        ; If we receive 'AB','54' as SCAN CODE,;JP9011
                                        ; we'll enter "SYSREQ key pressed"     ;JP9011
                                        ; state.                               ;JP9011
        OR      SD.SYSTEM_FLAG, SECURITY_ACTIVE ; THIS BIT BECOMES OFF WHEN    ;JP9010
                                        ;  SERVER PASSWORD MODE IS EXITED.     ;JP9010
        OR      ES:KB_FLAG_3, KBX       ; Behave as an extended keyboard.      ;JP9011
        MOV     SECURE_FL,1             ; SECURITY IS ACTIVE
        JMP     SHORT ASK_ROM_BIOS      ; TRY TO ASK ROM BIOS WHAT KEYBOARD    ;JP9010
                                        ; IS ATTACHED                          ;JP9010
;JP9010 JMP     SHORT FIND_KEYB_END     ; ASSUME IT IS A G_KB  WITH
                                        ; NUM LOCK OFF

;	M005 -- end changed section

ASSUME_AT:
	MOV	HW_TYPE,AT_KB		; NO, AT KBD if no KBX and no security
	JMP	SHORT FIND_KEYB_END	; EXIT

DONE_AT_2:				;      LAST PORT 60h VALUE IS ID_2 BYTE
	IN	AL,PORT_A		; Re-read last byte from keyboard input

;	M005 -- begin changed section

        CALL    SET_KBD_ID_TO_ROM_EXT   ; This is DBCS requirement. There are  ;JP9009
                                        ; five kinds of DBCS keyboards. We     ;JP9009
                                        ; need to distinguish them.            ;JP9009
        CMP     AL, ID_2JG              ; Was it old DBCS keyboards?           ;JP9009
        JAE     CHECK_WHAT_DBCS_KBD     ; Check what it is.                    ;JP9009
DONE_AT_FOR_G_P_TYPE:                                                          ;JP9011

;	M005 -- end changed section

	CMP	AL,TID_2A		; Was it the P-layout keyboard
	JE	DONE_AT_3		; Go set P type keyboard

	CMP	AL,ID_2AU		; Was it the P-layout untranslated
	JNE	DONE_AT_4		; Continue if not

DONE_AT_3:
	OR	HW_TYPE,P_KB		; Set HW_TYPE for P-layout keyboard
DONE_AT_4:
					; EXIT


FIND_KEYB_END:				; EXIT POINT
	MOV   AX,HW_TYPE		;      Get default or determined type

;	M005 -- begin changed section

;                                                                      ;JP9009
; New DBCS keyboards' ID is the same as that of SBCS 101/102 key       ;JP9009
; keyboard. So, we can distinguish them only by the language parameter ;JP9009
; string.                                                              ;JP9009
;                                                                      ;JP9009
        MOV     CX, WORD PTR [BP].LANGUAGE_PARM; Get language specified.       ;JP9009
        CMP     CX, 'PJ'                ; Japanese keyboard?                   ;JP9009
        JE      DBCS_KEYBOARD                                                  ;JP9009
        CMP     CX, 'OK'                ; Korea keyboard?                      ;JP9009
        JE      DBCS_KEYBOARD                                                  ;JP9009
        CMP     CX, 'RP'                ; PRC keyboard?                        ;JP9009
        JE      DBCS_KEYBOARD                                                  ;JP9009
        CMP     CX, 'AT'                ; Taiwan keyboard?                     ;JP9009
        JNE     SBCS_KEYBOARD                                                  ;JP9009
DBCS_KEYBOARD:                                                                 ;JP9009
        OR      AX, DBCS_KB             ; Set it as DBCS keyboard              ;JP9009
SBCS_KEYBOARD:                                                                 ;JP9009

;	M005 -- end changed section

	MOV   SD.KEYB_TYPE,AX		;      Place into shared data area

	POP   DS
	POP   ES
	RET

;	M005 -- begin changed section

ASK_ROM_BIOS:                                                                  ;JP9010
        PUSH    ES                      ;                                      ;JP9011
        MOV     AH, RTN_EXT_BIOS_DATA_SEG; GET EXTENDED BIOS DATA AREA SEGMENT ;JP9010
        INT     15H                     ;                                      ;JP9010
        ASSUME  ES:ROMEXT               ;                                      ;JP9009
        MOV     AL, BYTE PTR ES:EXT_BIOS_DATA_KBD_ID + 1;                      ;JP9010
        ASSUME  ES:DATA                 ;                                      ;JP9009
        POP     ES                      ; AL = HIGH BYTE OF KEYBOARD ID        ;JP9011
        JC      FIND_KEYB_END           ;      0 IF NOT SUPPORTED              ;JP9011
         CMP     AL, ID_2JG             ;                                      ;JP9010
         JB      DONE_AT_FOR_G_P_TYPE   ; WE GOT KEYB_TYPE FROM ROM BIOS, SO   ;JP9011
                                        ; RETURN TO NORMAL PROCEDURE           ;JP9011
CHECK_WHAT_DBCS_KBD:                                                           ;JP9009
        MOV     HW_TYPE, (DBCS_OLD_G_KB or DBCS_OLD_P_KB)                      ;JP9009
        CMP     AL, ID_2JA              ; Was it old DBCS A keyboard?          ;JP9009
        JNE     SET_SCAN_TABLE          ; Go if old DBCS G/P keyboard.         ;JP9009
        MOV     HW_TYPE, DBCS_OLD_A_KB                                         ;JP9009
SET_SCAN_TABLE:                                                                ;JP9009
        MOV     AL,82h                  ; SELECT SCAN CODE SET 82              ;JP9009
        TEST    SD.SYSTEM_FLAG,PS_8042   ; If in passthru mode without 8042    ;JP9009
        JZ      CHANGE_SCAN_TABLE       ; then set scan code set 81            ;JP9009
        MOV     AL,81h                  ; SELECT SCAN CODE SET 81              ;JP9009
CHANGE_SCAN_TABLE:                                                             ;JP9009
        MOV     SCAN_CODE_SET, AL       ; 81h or 82h for old DBCS keyboard     ;JP9009
                                        ; This is also used at hot replug.     ;JP9009
        CMP     SECURE_FL, 1            ; IF SECURITY ACTIVE, RETURN           ;JP9010
        JE      FIND_KEYB_END           ;                                      ;JP9010
        MOV     AL,SCAN_CODE_CMD        ; SELECT SCAN CODE SET COMMAND         ;JP9009
        CALL    SND_DATA_AT             ; SEND IT DIRECTLY TO THE KEYBOARD     ;JP9009
        MOV     AL, SCAN_CODE_SET       ; SCAN CODE SET                        ;JP9009
        CALL    SND_DATA_AT             ; SEND IT TO THE KEYBOARD              ;JP9009
        JMP     SHORT DONE_AT_4                                                ;JP9009


;  Module: SET_KBD_ID_TO_ROM_EXT
;  Description:
;       This routine sets keyboard ID to the corresponding extended BIOS
;       data area, even if ROM BIOS does not support 'Return Keyboard ID
;       (INT16H, AH=0AH)'. DBCS DOS supports it by some software if ROM
;       BIOS does not support it.
;       Input:
;               AL = High byte of keyboard ID
;                    Assumes low byte is 'ABH'.
;       Output:
;               none
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   PROC    NEAR    ;                                      ;JP9009
        PUSH    ES                      ;                                      ;JP9009
        PUSH    AX                      ;                                      ;JP9009
        MOV     AH, RTN_EXT_BIOS_DATA_SEG;                                     ;JP9009
        INT     15H                     ; Get extended BIOS data area          ;JP9009
        JC      NOT_SET_KBD_ID          ;                                      ;JP9009
            ASSUME  ES:ROMEXT           ; EXTENDED BIOS DATA AREA              ;JP9009
            MOV     AH, AL              ; AH = KBD ID 2ND BYTE                 ;JP9009
            MOV     AL, 0ABH            ; ASSUME KBD ID = xxABH                ;JP9009
            MOV     ES:EXT_BIOS_DATA_KBD_ID, AX; Set KBD ID to ext. BIOS data  ;JP9009
            ASSUME  ES:DATA             ; NORMAL BIOS DATA AREA                ;JP9009
NOT_SET_KBD_ID:                                                                ;JP9009
        POP     AX                      ;                                      ;JP9009
        POP     ES                      ;                                      ;JP9009
        RET                             ;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   ENDP            ;                                      ;JP9009
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
;	M005 -- end changed section

FIND_KEYB_TYPE		ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: SND_DATA_AT
;
;  Description:
;	THIS ROUTINE HANDLES TRANSMISSION OF PC/AT COMMAND AND DATA BYTES
;	TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;	HANDLES ANY RETRIES IF REQUIRED
;
;
;  Input Registers:
;      DS - points to our data segment
;      ES - points to the BIOS data segment
;
;  Output Registers:
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA_AT PROC   NEAR 
	PUSH	AX			; SAVE REGISTERS
	PUSH	BX			; *
	PUSH	CX
	MOV	BH,AL			; SAVE TRANSMITTED BYTE FOR RETRIES
	MOV	BL,3			; LOAD RETRY COUNT

;----  WAIT FOR 8042 INTERFACE NOT BUSY

SD0:					; RETRY entry
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; DISABLE INTERRUPTS
	AND	ES:KB_FLAG_2,NOT (KB_FE+KB_FA+KB_ERR)	; CLEAR ACK, RESEND AND
							; ERROR FLAGS
	MOV	AL,BH			; REESTABLISH BYTE TO TRANSMIT
	OUT	PORT_A,AL		; SEND BYTE

	JMP	$+2			; Delay for 8042 to accept command
	STI				; ENABLE INTERRUPTS

;-----	WAIT FOR COMMAND TO BE ACCEPTED BY KEYBOARD

	MOV	CX,DLY_15ms		; Timout for 15 ms (15,000/15.086)

SD1:					;	Fixed timout wait loop on AT's
	TEST	ES:KB_FLAG_2,KB_FE+KB_FA; SEE IF EITHER BIT SET
	JNZ	SD3			; IF SET, SOMETHING RECEIVED GO PROCESS

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JE	SD1			; No, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	LOOP	SD1			; OTHERWISE WAIT

SD2:
	DEC	BL			; DECREMENT RETRY COUNT
	JNZ	SD0			; RETRY TRANSMISSION

	OR	ES:KB_FLAG_2,KB_ERR	; TURN ON TRANSMIT ERROR FLAG
	JMP	SHORT SD4		; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:
	TEST	ES:KB_FLAG_2,KB_FA	; SEE IF THIS IS AN ACKNOWLEDGE
	JZ	SD2			; IF NOT, GO RESEND

SD4:
	POP	CX			; RESTORE REGISTERS
	POP	BX
	POP	AX			; *
	RET				; RETURN, GOOD TRANSMISSION

SND_DATA_AT ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; KEYBOARD SECURITY LOGIC
;
; CHECK THE CMOS RAM BYTE AT CMOS LOCATION HEX 013H
; CHECK TO SEE IF EITHER BITS 1 (PASSWORD) OR 2 (SERVER MODE) ARE SET ON
; IF EITHER BIT IS SET ON THE SYSTEM IS A MOD 50 on up
;    RETurn CARRY FLAG ON indicating keyboard interface may be disabled.
; OTHERWISE NO SECURITY ENABLED OR THE SYSTEM IS AN OLD AT.
;    RETurn CARRY FLAG OFF indicating keyboard interface not disabled.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_SECURE	PROC	NEAR

	CLI				; DISABLE INTERRUPTS WHILE DOING
					; ADDRESS WRITE AND CMOS READ
	MOV	AL,SECRET_ADD		; WRITE ADDRESS OF CMOS BYTE WITH
	OUT	PORT_70,AL		; BITS FOR THE PASSWORD AND SERVER
					; MODE STATE TO PORT 70H
	JMP	$+2			; I/O Delay required
	IN	AL,PORT_71		; READ CMOS DATA BYTE WITH THE
					; PASSWORD AND SERVER SECURITY
	STI				; ENABLE THE INTERRUPTS
	TEST	AL,PASS_MODE+SERVER_MODE; CHECK & SEE IF THE BITS ARE ON
					; TEST clears CARRY flag
	JZ	SECURE_RET		; EXIT NO CARRY if neither set

	STC				; SET THE SECURITY FLAG ON
					; System is NOT an AT but the
SECURE_RET:				; keyboard interface maybe locked

	RET

KEYB_SECURE	ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; 8042 TYPE DETERMINATION
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SP_8042 PROC	NEAR			; Determine if 8042 is Patriot/Sebring
	PUSH	AX			; Save work register
	PUSH	CX			; Save count register

;	M005 -- begin changed section

        IN      AL, STATUS_PORT         ; In server password mode, no answer   ;JP9010
        TEST    AL, KYBD_INH            ; is returned from the following logic.;JP9010
        JZ      GET_FROM_ROM_BIOS       ; So, ask ROM BIOS.                    ;JP9010

;	M005 -- end changed section

	MOV	CX,24			; Limit AUX inputs if they are playing
					;  with the mouse while loading KEYB

SP__2:
	MOV	AL,DIS_KBD		; Disable command to clear 8042 output
	OUT	STATUS_PORT,AL		; Sending allows receive to complete
	STI				; Allow any pending AUX interrupt
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; Block interrupts until password set
	IN	AL,STATUS_PORT		; Read 8042 status byte
	TEST	AL,MOUSE_OBF		; Check for AUX data pending at output
	LOOPNZ	SP__2			; Loop till AUX inputs are cleared

	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	MOV	AL,20h			; Read 8042 controller's command byte
	OUT	STATUS_PORT,AL		; Send command to 8042 interface
	CALL	CHK_IBF 		; Wait for command to be accepted
	MOV	CX,DLY_15ms		; Timeout 15 milliseconds (15000/15.086

SP__5:
	IN	AL,PORT_B		; Read current refresh output bit
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	SHORT SP__5		; No?, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	IN	AL,STATUS_PORT		; Read status (command) port
	TEST	AL,OUT_BUF_FULL 	; Check for output buffer empty
	LOOPZ	SP__5			; Loop until OBF is on or timeout

	IN	AL,PORT_A		; Get the command byte
	TEST	AL,01000000b		; Check for translate bit on
	JNZ	SP_EXIT 		; Done if it is on to begin with

SP_EXIT_0:				; M005 ;JP9010
	OR	SD.SYSTEM_FLAG,PS_8042	; Set PATRIOT/SEBRING type 8042
					;  with Translate scan codes set OFF
SP_EXIT:
	MOV	AL,ENA_KBD		; Enable command for keyboard
	OUT	STATUS_PORT,AL		; Send to 8042
	CALL	CHK_IBF 		; Wait for command to be accepted
	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	POP	CX			; Recover user register
	POP	AX			; Recover user register
	STI				; Enable inteerutps again
	RET				; Return to caller

;	M005 -- begin added section

RTN_SYSTEM_CONFIG       EQU     0C0H    ; INT15H SUB FUNCTION                  ;JP9010
FEATURE_INFO_2          EQU     006H    ; FEATURE INFO2 OFFSET IN CONFIG DATA  ;JP9010
NON_8042_CONTROLLER     EQU     004H    ; THIS BIT ON IF NON-8042 CONTROLLER   ;JP9010
GET_FROM_ROM_BIOS:                      ; WE CAN ONLY ASK ROM BIOS WHICH TYPE  ;JP9010
        PUSH    ES                      ; OF KEYBOARD CONTROLLER IS ATTACHED.  ;JP9010
        PUSH    BX                      ;                                      ;JP9010
        MOV     AH, RTN_SYSTEM_CONFIG   ;                                      ;JP9010
        INT     15H                     ;                                      ;JP9010
        JC      RTN_SYS_CONFIG_NOT_SUPPORTED; IN CASE NOT SUPPORTED, IT MUST   ;JP9010
                                        ; BE 8042. BELIEVE IT.                 ;JP9010
        TEST    BYTE PTR  ES:[BX+FEATURE_INFO_2], NON_8042_CONTROLLER          ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JNZ     SP_EXIT_0               ; IF NON-8042, SET THE FLAG            ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010
RTN_SYS_CONFIG_NOT_SUPPORTED:           ;                                      ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010

;	M005 -- end added section


SP_8042 ENDP

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\commsubs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                           
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  CONVERT.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    FIND_SYS_TYPE   :NEAR ;;
        EXTRN    FIND_KEYB_TYPE  :NEAR ;;
                                       ;;
        EXTRN    HW_TYPE         :WORD ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
        PAGE    ,132
        TITLE   MS-DOS 5.0 KEYB Command  -  Root Module

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MS-DOS 5.0 - NLS Support - KEYB Command
;                                                  
;
; File Name:  KEYB.ASM
; ----------
;
;
; Description:
; ------------
;       Contains root module for KEYB command.  This module is the
;       KEYB command entry point.  KEYB is an external command included
;       with MS DOS 5.0 to provide keyboard support for 14 languages.
;       KEYB will jump immediately into the command processing in
;       file KEYBCMD.  All resident code is included before KEYBCMD
;       in the linkage list.
;
;
; Procedures Contained in This File:
; ----------------------------------
;
;
; Include Files Required:
; -----------------------
;       KEYBCMD.INC - External declarations for transient command
;           processing routines
;
; External Procedure References:
; ------------------------------
;       FROM FILE  KEYCMD.ASM:
;            KEYB_COMMAND - Main routine for transient command processing.
;
; Linkage Instructions:
; --------------------
;       Link in .COM format.  Resident code/data is in files KEYB thru
;       KEYBCPSD.
;
;       LINK KEYB+KEYBI9+KEYBI9C+KEYBI2F+KEYBCPSD+KEYBMSG+
;            COMMSUBS+KEYBTBBL+KEYBCMD;
;       EXE2BIN KEYB.EXE KEYB.COM
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CODE    SEGMENT PUBLIC 'CODE' BYTE

        INCLUDE KEYBCMD.INC            ; Bring in external declarations
                                       ;  for transient command processing
        ASSUME  CS:CODE,DS:CODE
        ORG   100H                     ; required for .COM


START:

        JMP   KEYB_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CODE   ENDS
       END    START

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybcmd.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                         
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCMD.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                              ;;
        EXTRN    KEYB_COMMAND        :NEAR    ;;
                                              ;;
        EXTRN    KEYBSYS_FILE_HANDLE:WORD     ;;
        EXTRN    CP_TAB_OFFSET:DWORD          ;;
        EXTRN    STATE_LOGIC_OFFSET:DWORD     ;;
        EXTRN    SYS_CODE_PAGE:WORD           ;;
        EXTRN    KEYBCMD_LANG_ENTRY_PTR:DWORD ;;
        EXTRN    DESIG_CP_BUFFER:WORD         ;;
        EXTRN    DESIG_CP_OFFSET:WORD         ;;
        EXTRN    NUM_DESIG_CP:WORD            ;;
        EXTRN    TB_RETURN_CODE:WORD          ;;
        EXTRN    FILE_BUFFER:BYTE             ;;
;****************CNS****************************
        EXTRN    ID_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    LANG_PTR_SIZE:WORD           ;;
        EXTRN    CP_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    NUM_ID:WORD                  ;;
;****************CNS****************************
        EXTRN    NUM_LANG:WORD                ;;
        EXTRN    NUM_CP:WORD                  ;;
        EXTRN    SHARED_AREA_PTR:DWORD        ;;
        EXTRN    SD_SOURCE_PTR:BYTE           ;;
        EXTRN    TEMP_SHARED_DATA:BYTE        ;;
                                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybcpsd.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                             
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCPSD.INC
;; ----------
;;
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBCPSD.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    COPY_SD_AREA:NEAR     ;;
                                       ;;
        EXTRN    SD_DEST_PTR :BYTE     ;;
        EXTRN    SHARED_DATA :BYTE     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybcmd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
;
;                                             
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
; File Name:  KEYBCMD.ASM
; ----------
;
;
; Description:
; ------------
;	 Contains transient command processing modules for KEYB command.
;
; Procedures contained in this file:
; ----------------------------------
;	KEYB_COMMAND:	 Main routine for command processing.
;	PARSE_PARAMETERS:  Validate syntax of parameters included
;	    on command line.
;	BUILD_PATH: Find KEYBOARD.SYS file and validate language and/or
;	    code page.
;	INSTALL_INT_VECTORS:  Install our INT 9, INT 2F Drivers
;	NUMLK_ON:  Turn on the NUM LOCK LED
;	FIND_FIRST_CP: Determine first code page for given language in the
;	    Keyboard Definition file.
;
; Include Files Required:
; -----------------------
;	KEYBMSG.INC
;	KEYBEQU.INC
;	KEYBSYS.INC
;	KEYBI9C.INC
;	KEYBI9.INC
;	KEYBI2F.INC
;	KEYBSHAR.INC
;	KEYBDCL.INC
;	KEYBTBBL.INC
;	COMMSUBS.INC
;	KEYBCPSD.INC
;	POSTEQU.SRC
;	DSEG.SRC
;
; External Procedure References:
; ------------------------------
;	FROM FILE  KEYBTBBL.ASM:
;	      TABLE_BUILD - Create the shared area containing all keyboard tables.
;	      STATE_BUILD - Build all states within the table area
;	 FROM FILE  KEYBMSG.ASM:
;	      KEYB_MESSAGES - All messages
;
; Change History:
;
;  Modified for DOS 3.40 -	Nick Savage , IBM Corporation
;				Wilf Russell, IBM Canada Laboratory
;				DCR ???? -KEYBAORD SECURITY LOCK - CNS
;
;
;			        PTM 3906 - KEYB messages do not conform
;					   to spec. Error message does
;				3/24/88	   not pass back the bogus command
;					   line argument.	      - CNS
;
; PTMP3955 ;KEYB component to free environment and close handles 0 - 4
;
; 3/24/88
;
; 9/26/89 jwg Moved code from resident module and reduce code size.
;
;;;;;;;;;;;;;

	PUBLIC	KEYB_COMMAND

;*****************CNS********************
	PUBLIC	ID_TAB_OFFSET
;*****************CNS********************

	PUBLIC	CP_TAB_OFFSET
	PUBLIC	STATE_LOGIC_OFFSET
	PUBLIC	SYS_CODE_PAGE
	PUBLIC	KEYBCMD_LANG_ENTRY_PTR
	PUBLIC	DESIG_CP_BUFFER
	PUBLIC	DESIG_CP_OFFSET
	PUBLIC	KEYBSYS_FILE_HANDLE
	PUBLIC	NUM_DESIG_CP
	PUBLIC	TB_RETURN_CODE
	PUBLIC	FILE_BUFFER
	PUBLIC	FB

;*****************CNS********************
	PUBLIC	ID_PTR_SIZE
	PUBLIC	LANG_PTR_SIZE
	PUBLIC	CP_PTR_SIZE
	PUBLIC	NUM_ID
	PUBLIC	NUM_LANG
	PUBLIC	NUM_CP
	PUBLIC	SHARED_AREA_PTR
;*****************CNS********************

	PUBLIC	SD_SOURCE_PTR
	PUBLIC	TEMP_SHARED_DATA

	PUBLIC	FOURTH_PARM
	PUBLIC	ONE_PARMID
	PUBLIC	FTH_PARMID
	PUBLIC	ID_FOUND
	PUBLIC	BAD_ID
	PUBLIC	ALPHA
	EXTRN	PARSE_PARAMETERS:NEAR
	extrn	pswitches:byte

;***CNS
	EXTRN	SECURE_FL:BYTE
	EXTRN	CUR_PTR:WORD
	EXTRN	OLD_PTR:WORD
	EXTRN	ERR_PART:WORD
;***CNS

	.xlist
	INCLUDE SYSMSG.INC	       ;  message retriever
	.list

MSG_UTILNAME <KEYB>		       ;  identify to message retriever

CODE	SEGMENT PUBLIC 'CODE'

	.xlist
	INCLUDE KEYBEQU.INC
	INCLUDE KEYBSYS.INC
	INCLUDE KEYBI9.INC
	INCLUDE KEYBI9C.INC
	INCLUDE KEYBI2F.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBDCL.INC
	INCLUDE KEYBTBBL.INC
	INCLUDE COMMSUBS.INC
	INCLUDE KEYBCPSD.INC
	.xlist
	INCLUDE POSTEQU.INC
	INCLUDE DSEG.INC

	.list
	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;
;
; Module: KEYB_COMMAND
;
; Description:
;     Main routine for transient command processing.
;
; Input Registers:
;     DS - points to our data segment
;
; Output Registers:
;     Upon termination, if an error has occurred in which a keyboard table
;     was not loaded, the AL register will contain the a error flag. This
;     flag is defined as follows:
;	      AL:= 1 - Invalid language, code page, or syntax
;		   2 - Bad or missing Keyboard Definition File
;		   3 - KEYB could not create a table in resident memory
;		   4 - An error condition was received when communicating
;		       with the CON device
;		   5 - Code page requested has not been designated
;		   6 - The keyboard table for the requested code page cannot
;		       be found in resident keyboard table.
;
; Logic:
;     IF KEYB has NOT been previously loaded THEN
;	  Set SHARED_AREA_PTR to TEMP_SHARED_AREA
;	  INSTALLED_KEYB := 0
;	  Get HW_TYPE (set local variable)
;     ELSE
;	  Set SHARED_AREA_PTR to ES:SHARED_AREA
;	  Get HW_TYPE (set local variable)
;	  Set TABLE_OK := 0
;	  INSTALLED_KEYB := 1
;
;     IF CPS-CON has been loaded THEN
;	  INSTALLED_CON := 1
;
;*********************************** CNS *************************************
;     Call PARSE_PARAMETERS := Edit ID or language, code page,
;					    and path parameters,ID on command line
;*********************************** CNS *************************************
;     Check all return codes:
;     IF any parameters are invalid THEN
;	  Display ERROR message
;     ELSE
;	  IF no language parm specified
;				 AND code page is not invalid
;						     AND syntax is valid THEN
;	     Process QUERY:
;	     IF KEYB is installed THEN
;		 Get and display active language from SHARED_DATA_AREA
;		 Get invoked code page from SHARED_DATA_AREA
;		 Convert to ASCII
;		 Display ASCII representation of code page, CR/LF
;*********************************** CNS *************************************
;	     IF ALTERNATE FLAG SET
;		 Get and display active ID from SHARED_DATA_AREA
;		 Convert to ASCII
;		 Display ASCII representation of ID, CR/LF
;*********************************** CNS *************************************
;	     IF CPS-CON is installed THEN
;		 Get selected code page info from CON
;		 Convert to ASCII
;		 Display ASCII representation of code page, CR/LF
;	     EXIT without staying resident
;
;	  ELSE
;	     Call BUILD_PATH := Determine location of Keyboard definition file
;	     Open the file
;	     IF error in opening file THEN
;		Display ERROR message and EXIT
;	     ELSE
;		Save handle
;		Set address of buffer
;		READ header of Keyboard definition file
;		IF error in reading file THEN
;		   Display ERROR message and EXIT
;		ELSE
;		   Check signature for correct file
;		   IF file signature is correct THEN
;		      READ language table
;		      IF error in reading file THEN
;			  Display ERROR message and EXIT
;		      ELSE
;			  Use table to verify language parm
;			  Set pointer values
;			  IF code page was specified
;			      READ language entry
;			      IF error in reading file THEN
;				   Display ERROR message and EXIT
;			      ELSE
;				   READ Code page table
;				   IF error in reading file THEN
;				       Display ERROR message and EXIT
;				   ELSE
;				       Use table to verify code page parm
;				       Set pointer values
;     IF CPS-CON is not installed THEN
;	    Set number of code pages = 1
;	    IF CODE_PAGE_PARM was specified THEN
;	       Copy CODE_PAGE_PARM into table of code pages to build
;	    ELSE
;	       Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;	       Copy SYSTEM_CP into table of code pages to build
;     ELSE
;	    Issue INT 2F ; 0AD03H  to get table of Designated code pages
;	    Set number of designated code pages (HWCP + Desig CP)
;	    Issue INT 2F ; 0AD02H  to get invoked code page
;	    IF CODE_PAGE_PARM was specified THEN
;	       Check that CODE_PAGE_PARM is in the list of designated code pages
;	       IF CODE_PAGE_PARM is in the list of designated code pages THEN
;		    Copy specified CP into table of code pages to build
;		    IF a CP has been selected AND is inconsistent with specified CP
;			Issue WARNING message
;	       ELSE
;		    Display ERROR message
;	    ELSE
;	       IF a code page has been invoked THEN
;		    Copy invoked code page into table of code pages to build
;	       ELSE
;		    Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;		    Copy SYSTEM_CP into table of code pages to build
;
;     IF KEYB has not been previously installed THEN
;	  Call FIND_SYS_TYPE := Determine system type
;	  Call INSTALL_INT_9 := Install INT 9 handler
;	  Call FIND_KEYB_TYPE := Determine the keyboard type
;
;     Call TABLE_BUILD := Build the TEMP_SHARED_DATA_AREA
;
;     IF return codes from TABLE_BUILD are INVALID THEN
;	  IF KEYB_INSTALLED := 0 THEN
;	      Call REMOVE_INT_9
;	  Display corresponding ERROR message
;	  EXIT without staying resident
;     ELSE
;	  IF any of the designated CPs were invalid in the build THEN
;	      Issue WARNING message
;	  Close the Keyboard definition file
;	  IF KEYB had NOT already been installed THEN
;	      IF keyboard is a Ferrari_G AND system is not an XT THEN
;	      Call NUMLK_ON := Turn the NUM LOCK LED on
;	      IF extended INT 16 support required THEN
;		 Install extended INT 16 support
;	      Call INSTALL_INT_9_NET := Let network know about INT 9
;	      Call INSTALL_INT_2F := Install the INT 2F driver
;	      Activate language
;	      Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;	      EXIT but stay resident
;	  ELSE
;	      IF this was not a query call AND exit code was valid THEN
;		 Activate language
;		 Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;	      EXIT without staying resident
;     END
;
;;;;;;;;;;;;;

INVALID_PARMS	     EQU  1	      ;  EXIT return codes
BAD_KEYB_DEF_FILE    EQU  2
MEMORY_OVERFLOW      EQU  3
CONSOLE_ERROR	     EQU  4
CP_NOT_DESIGNATED    EQU  5
KEYB_TABLE_NOT_LOAD  EQU  6
BAD_DOS_VER	     EQU  7	
EXIT_RET_CODE	     DB   0

;******************** CNS ***********
ID_VALID	     EQU  0
ID_INVALID	     EQU  1
NO_ID		     EQU  2
LANGUAGE_VALID	     EQU  0
LANGUAGE_INVALID     EQU  1		;  Return Codes
NO_LANGUAGE	     EQU  2		;    from
NO_IDLANG	     EQU  3
;******************** CNS ***********

CODE_PAGE_VALID      EQU  0		;     EDIT_LANGUAGE_CODE
CODE_PAGE_INVALID    EQU  1
NO_CODE_PAGE	     EQU  2
VALID_SYNTAX	     EQU  0
INVALID_SYNTAX	     EQU  1	

ACT_KEYB	     EQU  2
ACT_ID		     EQU  3
ACT_KEYB_CP	     EQU  4
ACT_CON_CP	     EQU  5
INV_L		     EQU  6		;  message numbers...
INV_I		     EQU  7
INV_CP		     EQU  8
INV_S		     EQU  18
INV_FN		     EQU  9
INV_KEYB_Q	     EQU  10
INV_CON_Q	     EQU  11
NOT_DESIG	     EQU  12
NOT_SUPP	     EQU  13
NOT_VALID	     EQU  14
WARNING_1	     EQU  15
INV_COMBO	     EQU  16
MEMORY_OVERF	     EQU  17
help_1st	     equ  300
help_last	     equ  306
CR_LF		     DB   10,13,'$'

FOURTH_PARM	DB	0		;  switch was specified
ONE_PARMID	DB	0		;  id given as positional
FTH_PARMID	DB	0		;  id given as switch
ID_FOUND	DB	0		;  id was good (in k.d. file)
BAD_ID		DB	0		;  id was bad (from parse)
ALPHA		DB	0		;  first parm a language id

ID_DISPLAYED	DB	0		;  Indicating ID already displayed

SUBLIST_NUMBER LABEL BYTE		;  sublist for numbers
	       DB	11		;  size
	       DB	0
PTR_TO_NUMBER  DW	?		;  offset ptr
SEG_OF_NUMBER  DW	?		;  segment
	       DB	1
	       DB	10100001B	;  flag
	       DB	3		;  max width
	       DB	1		;  min width
	       DB	" "		;  filler


SUBLIST_ASCIIZ LABEL BYTE		;  sublist for asciiz
	       DB	11		;  size
	       DB	0
PTR_TO_ASCIIZ  DW	?		;  offset ptr
SEG_OF_ASCIIZ  DW	?		;  segment
	       DB	1
	       DB	00010000B	;  flag
	       DB	2		;  max width
	       DB	2		;  min width
	       DB	" "		;  filler

NUMBER_HOLDER  DW	?		;  used for message retriever

;***CNS
SUBLIST_COMLIN LABEL BYTE		;  sublist for asciiz
	       DB	11		;  size
	       DB	0
PTR_TO_COMLIN  DW	?		;  offset ptr
SEG_OF_COMLIN  DW	?
	       DB	0
	       DB	LEFT_ALIGN+CHAR_FIELD_ASCIIZ  ;  flag

	       DB	0		;  max width
	       DB	1		;  min width
	       DB	" "		;  filler


STRING_HOLDER  DB	64 DUP(0)
;***CNS

FILE_BUFFER	     DB   FILE_BUFFER_SIZE dup (0); Buffer for Keyboard Def file
FB		     EQU  FILE_BUFFER	;m for 32 language entries)
DESIG_CP_BUFFER      DW   28 DUP(?)	; (Room for 25 code pages)
DESIG_CP_BUF_LEN     DW   $-DESIG_CP_BUFFER ; Length of code page buffer
NUM_DESIG_CP	     DW   0
CP_TAB_OFFSET	     DD   ?

;******************  CNS  ******************
TOTAL_SIZE	     DW   0
PASS_LANG	     DW   0
ID_TAB_OFFSET	     DD   ?
;******************  CNS  ******************

STATE_LOGIC_OFFSET   DD   -1
KEYBSYS_FILE_HANDLE  DW   ?
TB_RETURN_CODE	     DW   1
DESIG_CP_OFFSET      DW   OFFSET DESIG_CP_BUFFER
SYS_CODE_PAGE	     DW   0
DESIG_LIST	     DW   0
QUERY_CALL	     DB   0

KB_MASK 	     EQU  02h

SIGNATURE	     DB   0FFh,'KEYB   '
SIGNATURE_LENGTH     DW   8

;******************  CNS  ***************************
NUM_ID		     DW   0
ERR4ID		     DB   0
NUM_LANG	     DW   0
NUM_CP		     DW   0
ID_PTR_SIZE	     DW   SIZE KEYBSYS_ID_PTRS
;******************  CNS  ***************************

LANG_PTR_SIZE	     DW   SIZE KEYBSYS_LANG_PTRS
CP_PTR_SIZE	     DW   SIZE KEYBSYS_CP_PTRS
KEYBCMD_LANG_ENTRY_PTR DD ?

KEYB_INSTALLED	     DW   0
CON_INSTALLED	     DW   0
SHARED_AREA_PTR      DD   0
GOOD_MATCH	     DW   0

;******************  CNS  ***************************;
LANGUAGE_ASCII	     DB   '??',0

CMD_PARM_LIST	     PARM_LIST <>

;----------  TABLES FOR EXTENDED KEYBOARD SUPPORT CTRL CASE  ---------


RPL_K8	LABEL	BYTE			;-------- CHARACTERS ---------
	DB	27,-1,00,-1,-1,-1	; Esc, 1, 2, 3, 4, 5
	DB	30,-1,-1,-1,-1,31	; 6, 7, 8, 9, 0, -
	DB	-1,127,148,17,23,5	; =, Bksp, Tab, Q, W, E
	DB	18,20,25,21,09,15	; R, T, Y, U, I, O
	DB	16,27,29,10,-1,01	; P, [, ], Enter, Ctrl, A
	DB	19,04,06,07,08,10	; S, D, F, G, H, J
	DB	11,12,-1,-1,-1,-1	; K, L, ;, ', `, LShift
	DB	28,26,24,03,22,02	; \, Z, X, C, V, B
	DB	14,13,-1,-1,-1,-1	; N, M, ,, ., /, RShift
	DB	150,-1,' ',-1           ; *, Alt, Space, CL
					;--------- FUNCTIONS ---------
	DB	94,95,96,97,98,99	; F1 - F6
	DB	100,101,102,103,-1,-1	; F7 - F10, NL, SL
	DB	119,141,132,142,115,143 ; Home, Up, PgUp, -, Left, Pad5
	DB	116,144,117,145,118,146 ; Right, +, End, Down, PgDn, Ins
	DB	147,-1,-1,-1,137,138	; Del, SysReq, Undef, WT, F11, F12
L_CTRL_TAB	EQU	$-RPL_K8

;;;;;;;;;;;;;;;;
;    Program Code
;;;;;;;;;;;;;;;;

KEYB_COMMAND  PROC NEAR

	CALL	SYSLOADMSG		;load messages
	JNC	VERSION_OK		;if no carry then version ok

	CALL	SYSDISPMSG		;error..display version error
	MOV	AL,BAD_DOS_VER		;bad DOS version
	MOV	EXIT_RET_CODE,AL
	JMP	KEYB_EXIT_NOT_RESIDENT	;exit..non resident

VERSION_OK:
	MOV	SEG_OF_NUMBER,CS	;initialize..
	MOV	SEG_OF_ASCIIZ,CS	;  ..sublists
	MOV	BP,OFFSET CMD_PARM_LIST	;pointer for parm list
	MOV	WORD PTR SHARED_AREA_PTR,ES ; ES segment

KEYB_INSTALL_CHECK:
	MOV	AX,0AD80H		; KEYB install check
	INT	2FH
	CMP	AL,-1			; If flag is not 0FFh THEN
	JE	INSTALLED_KEYB

	MOV	WORD PTR SHARED_AREA_PTR+2,OFFSET TSD
	JMP	short CON_INSTALL_CHECK

INSTALLED_KEYB:
	MOV	KEYB_INSTALLED,1	; Set KEYB_INSTALLED flag = YES
	MOV	WORD PTR SHARED_AREA_PTR,ES ; Save segment of SHARED_DATA_AREA
	MOV	WORD PTR SHARED_AREA_PTR+2,DI ;Save offset of SHARED_DATA_AREA

	MOV	AX,ES:[DI].KEYB_TYPE
	MOV	HW_TYPE,AX
	MOV	ES:[DI].TABLE_OK,0	; Do not allow processing
	PUSH	CS			;	  while building table
	POP	ES			; Reset ES until required

CON_INSTALL_CHECK:		
	MOV	AX,0AD00H		; CONSOLE install check
	INT	2FH
	CMP	AL,-1			; If flag is not 0FFh THEN
	jnz	call_first_stage

	MOV	CON_INSTALLED,1		; Set CON_INSTALLED flag = YES

CALL_FIRST_STAGE:
	PUSH	CS
	POP	ES
	CALL	PARSE_PARAMETERS	; Validate parameter list

	test	pswitches,1		; /? option?
	jz	no_help			; brif not

	mov	ax,help_1st		; first help msg
help_loop:
	push	ax
	MOV	BX,STDOUT		; to standard out
	xor	cx,cx			; no replacements
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_ASCIIZ	; ptr to sublist
	CALL	SYSDISPMSG
	pop	ax
	inc	ax
	cmp	ax,help_last
	jbe	help_loop

	mov	exit_ret_code,invalid_parms ; return "invalid parms"
	jmp	KEYB_EXIT_NOT_RESIDENT



no_help:

BEGIN_PARM_CHECK:			; CHECK ALL RETURN CODES
	MOV	DL,[BP].RET_CODE_3
	CMP	DL,1			; Check for invalid syntax
	JNE	VALID1
	JMP	ERROR3

VALID1:
	MOV	DL,[BP].RET_CODE_1	; Check for invalid language parm
	CMP	DL,1
	JNE	VALID2
	JMP	ERROR1

VALID2:
	MOV	DL,[BP].RET_CODE_2	; Check for invalid code page parm
	CMP	DL,1
	JNE	VALID3
	JMP	ERROR2

VALID3:
	MOV	DL,[BP].RET_CODE_1	; Check for query command
	CMP	DL,2
	JE	QUERY


;******************************* CNS **
	CMP	DL,3			; Get a status of the codepage
	JE	QUERY			; language, and possible ID code
;******************************* CNS **

	JMP	NOT_QUERY
					; IF QUERY is requested THEN
QUERY:
	MOV	QUERY_CALL,DL
	MOV	AX,KEYB_INSTALLED	;     If KEYB is installed THEN
	or	ax,ax
	JE	QUERY_CONTINUE1

	MOV	DI,WORD PTR SHARED_AREA_PTR+2	; Get offset of
	MOV	ES,WORD PTR SHARED_AREA_PTR	;	 shared area
	MOV	BX,WORD PTR ES:[DI].ACTIVE_LANGUAGE ; Get active language
	or	bx,bx				; if no language...
	JE	I_MESSAGE			;  then id was specified


L_MESSAGE:
	MOV	WORD PTR LANGUAGE_ASCII,BX ; Display Language
	LEA	SI,LANGUAGE_ASCII	; sublist points to...
	MOV	PTR_TO_ASCIIZ,SI	; language code asciiz string
	MOV	AX,ACT_KEYB		; display 'Current keyboard code'
	MOV	BX,STDOUT		; to standard out
	MOV	CX,1			; one replacement
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_ASCIIZ	; ptr to sublist
	CALL	SYSDISPMSG
	JMP	short KEYB_L_FINISHED
					
I_MESSAGE:
	MOV	BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
	MOV	NUMBER_HOLDER,BX	;  transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	;  sublist points to...
	MOV	PTR_TO_NUMBER,SI	;  code page word
	MOV	AX,ACT_ID		;  display 'Current ID:  '
	MOV	BX,STDOUT		;  to standard out
	MOV	CX,1			;  one replacement
	MOV	DH,UTILITY_MSG_CLASS	;  utility message
	XOR	DL,DL			;  no input
	LEA	SI,SUBLIST_NUMBER	;  ptr to sublist
	CALL	SYSDISPMSG
	MOV	ID_DISPLAYED,1		;  ID was displayed.
	JMP	short KEYB_L_FINISHED

QUERY_CONTINUE1:
	MOV	AX,INV_KEYB_Q
	MOV	BX,STDOUT		;  Else
	XOR	CX,CX			;   Display message that KEYB
	MOV	DH,UTILITY_MSG_CLASS	;   has not been installed
	XOR	DL,DL
	CALL	SYSDISPMSG
	JMP	short KEYB_CP_FINISHED

KEYB_L_FINISHED:
	MOV	BX,ES:[DI].INVOKED_CP_TABLE ; Get invoked code page

	MOV	NUMBER_HOLDER,BX	;  transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	;  sublist points to...
	MOV	PTR_TO_NUMBER,SI	;  code page word
	MOV	AX,ACT_KEYB_CP		;  display '  code page: '
	MOV	BX,STDOUT		;  to standard out
	MOV	CX,1			;  one replacement
	MOV	DH,UTILITY_MSG_CLASS	;  utility message
	XOR	DL,DL			;  no input
	LEA	SI,SUBLIST_NUMBER	;  ptr to sublist
	CALL	SYSDISPMSG
	CMP	ID_DISPLAYED,1		;  was id displayed?
	JE	KEYB_CP_FINISHED	;  yes..continue.

	MOV	BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
	or	bx,bx			;  no id given
	JE	KEYB_CP_FINISHED

	MOV	NUMBER_HOLDER,BX	;  transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	;  sublist points to...
	MOV	PTR_TO_NUMBER,SI	;  code page word
	MOV	AX,ACT_ID		;  display 'Current ID:  '
	MOV	BX,STDOUT		;  to standard out
	MOV	CX,1			;  one replacement
	MOV	DH,UTILITY_MSG_CLASS	;  utility message
	XOR	DL,DL			;  no input
	LEA	SI,SUBLIST_NUMBER	;  ptr to sublist
	CALL	SYSDISPMSG

	MOV	AH,09H			;  need a CR_LF here.
	MOV	DX,OFFSET CR_LF
	INT	21H

KEYB_CP_FINISHED:
	MOV	AX,CON_INSTALLED	;  If CON has been installed THEN
	or	ax,ax
	JNE	GET_ACTIVE_CP
	JMP	short CON_NOT_INSTALLED

GET_ACTIVE_CP:
	MOV	AX,0AD02H		;  Get active code page
	INT	2FH			;   information from the console
	JNC	DISPLAY_ACTIVE_CP
	JMP	ERROR5

DISPLAY_ACTIVE_CP:
	MOV	NUMBER_HOLDER,BX	; transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	; sublist points to...
	MOV	PTR_TO_NUMBER,SI	; code page word
	MOV	AX,ACT_CON_CP		; display 'Current CON code page: '
	MOV	BX,STDOUT		; to standard out
	MOV	CX,1			; one replacement
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_NUMBER	; ptr to sublist
	CALL	SYSDISPMSG

	JMP	KEYB_EXIT_NOT_RESIDENT	;  Exit from Proc

CON_NOT_INSTALLED:			; ELSE
	MOV	AX,INV_CON_Q
	MOV	BX,STDOUT		; Else
	XOR	CX,CX			;	Display message that CON does
	MOV	DH,UTILITY_MSG_CLASS	;	  not have active code page
	XOR	DL,DL
	CALL	SYSDISPMSG
	JMP	KEYB_EXIT_NOT_RESIDENT	; Exit from Proc

NOT_QUERY:				; IF not a query function requested
	CALL	BUILD_PATH		; Determine location of KEYBOARD.SYS
					;  ...and open file.

	JNC	VALID4			; If no error in opening file then
	JMP	ERROR4

VALID4:
	MOV	KEYBSYS_FILE_HANDLE,AX	; Save handle
	MOV	BP,OFFSET CMD_PARM_LIST ; Set base pointer for structures
	MOV	BX,KEYBSYS_FILE_HANDLE	; Retrieve the file handle
	MOV	DX,OFFSET FILE_BUFFER	; Set address of buffer

;************************* CNS ********;
	cmp	[BP].RET_CODE_4,ID_VALID ; CNS is there an ID available
	je	ID_TYPED		; if so go find out if it is
	jmp	short GET_LANG		; a 1st or 4th parm, if not must
					; must be a language
ID_TYPED:

	call	SCAN_ID			; scan the table for the ID
	cmp	ID_FOUND,1		; if a legal ID check and see if
	jne	LOST_ID			; it is a first or fourth parm

	cmp	FTH_PARMID,1		; if it is a fourth parm go
	je	GET_ID			; check for language compatibility
	jmp	short Language_found	; otherwise it must be a first
					; parm id value

LOST_ID:				; otherwise must be a bogus match
					; between language and ID codes
					;  or the ID code does not exist
	jmp	ERR1ID			; in the table
;************************* CNS ***********;

GET_LANG:				 ; Must be a language/or a 1st parm ID
				

	XOR	DI,DI			; Set number
	LEA	CX,[DI].KH_NUM_LANG+2	;	 bytes to read header

	MOV	AH,3FH			; Read header of the Keyb Def file
	INT	21H
	JNC	VALID5			; If no error in opening file then
	JMP	ERROR4

VALID5:
	CLD				;  all moves/scans forward
	MOV	CX,SIGNATURE_LENGTH
	MOV	DI,OFFSET SIGNATURE	; Verify matching
	MOV	SI,OFFSET FB.KH_SIGNATURE ;	     signatures
	REPE	CMPSB
	JE	LANGUAGE_SPECIFIED
	JMP	ERROR4
					; READ the language table
LANGUAGE_SPECIFIED:
	MOV	AX,FB.KH_NUM_LANG
	MOV	NUM_LANG,AX		; Save the number of languages
	MUL	LANG_PTR_SIZE		; Determine # of bytes to read
	MOV	DX,OFFSET FILE_BUFFER	; Establish beginning of buffer
	MOV	CX,AX
	CMP	CX,SIZE FILE_BUFFER	; Make sure buffer is not to small
	JBE	READ_LANG_TAB
	JMP	ERROR4

READ_LANG_TAB:
	MOV	AH,3FH			; Read language table from
	INT	21H			;	       Keyb Def file
	JNC	READ_VALID		; If no error in opening file then
	JMP	ERROR4			; Else display ERROR message

READ_VALID:
	MOV	CX,NUM_LANG		;    Number of valid codes
	MOV	DI,OFFSET FILE_BUFFER	;    Point to correct word in table

SCAN_LANG_TABLE:			; FOR language parm
	MOV	AX,[BP].LANGUAGE_PARM	;    Get parameter
	CMP	[DI].KP_LANG_CODE,AX	;    Valid Code ??
	JE	LANGUAGE_FOUND		; If not found AND more entries THEN

	ADD	DI,LANG_PTR_SIZE	;	  Check next entry
	DEC	CX			;    Decrement count of entries
	JNE	SCAN_LANG_TABLE		; Else
	JMP	ERROR1			;    Display error message

;**************************** CNS ****
GET_ID: 				; CNS - Must be an ID value
	mov	cx,1			; initialize ctr value for # of ids

SEARCH_ID:				; minimum per country
;					; There is atleast 1 ID for each country
	or	cx,cx			; check for any more IDs left to check
	jne	FINDID			; Country has more than one ID check
	jmp	END_IDCHK		; Country & ID has been found or value
					; is zero
FINDID:

	push	di			; save the current language entry ptr
	push	cx			; save the minimum # of ids before
					; reading the table data from the disk
;**************************** CNS ***********

LANGUAGE_FOUND:
	MOV	CX,WORD PTR [DI].KP_ENTRY_PTR+2	; Get offset of lang entry
	MOV	DX,WORD PTR [DI].KP_ENTRY_PTR	;	in the Keyb Def file
	MOV	WORD PTR KEYBCMD_LANG_ENTRY_PTR,DX ; Save
	MOV	WORD PTR KEYBCMD_LANG_ENTRY_PTR+2,CX ;	offset
	MOV	AH,42H				; Move file pointer to
	MOV	AL,0				;  location of language
	INT	21H				;  entry
	JNC	LSEEK_VALID
	JMP	ERROR4

LSEEK_VALID:
	MOV	DI,AX
	MOV	CX,SIZE KEYBSYS_LANG_ENTRY-1	; Set number
						;  bytes to read header
	MOV	DX,OFFSET FILE_BUFFER
	MOV	AH,3FH			; Read language entry in
	INT	21H			;  Keyb Def file
	JNC	VALID6a			; If no error in file then
	JMP	ERROR4

;**************************** CNS **********************************************


valid6a:
	cmp	FOURTH_PARM,1		; Is the ID a 4th Parm
	jne	VALID6			; if not get out of routine, otherwise
	pop	cx			; restore # of ids for the country
					; Check to see if this is the first
					; time checking the primary ID
	cmp	cx,1			; if there is just one ID check to make
	jne	CHK4PARM		; sure both flags are not set
					; this should not be necessary w/ new parser

	cmp	FTH_PARMID,1		; is the ID flag for switch set
	jne	CHK1N4			; is the flag set only for the 4th
	cmp	FOURTH_PARM,1		; if set only for the switch proceed
	jne	CHK1N4			; if not must be a positional
	mov	cl,fb.kl_num_id		; get the number of IDs available from the table
	mov	FTH_PARMID,0		; turn switch flag off so the table
					; counter will not be reset

					;ids available for the
CHK1N4: 				;country
	cmp	ONE_PARMID,1		; this was to be done if
	jne	CHK4PARM		; two the positional
	cmp	FOURTH_PARM,0		; and switch was specified
	jne	CHK4PARM		; this should never happen

	pop	di			; if the parser is intact
	jmp	error3			; report error & exit

CHK4PARM:				; check on the first ID
	cmp	FOURTH_PARM,1		; ID was a switch
	jne	ABORT_LOOP		; otherwise get out of routine
	call	IDLANG_CHK		; check the ID
	jmp	short ADVANCE_PTR	; advance to the next position

ABORT_LOOP:
	xor	cx,cx			; end loop

ADVANCE_PTR:
	pop	di			;restore entry value

	dec	cx			; # of ids left to check
	je	NO_ADVANCE		; if 0, don't advance table position
	cmp	GOOD_MATCH,1		; check to see if ID matched language
	je	NO_ADVANCE		; if equal do not advance

	add	di,LANG_PTR_SIZE	; step to the next entry
					; in the table

NO_ADVANCE:

	jmp	SEARCH_ID		; for the country

;					; end of ID check for country

END_IDCHK:

	cmp	FOURTH_PARM,1		; see if id was found
	jne	VALID6
	cmp	GOOD_MATCH,0		; none found
	jne	VALID6			; report error

	mov	[bp].ret_code_4,1	; incompatible lang code
	mov	al,[bp].ret_code_4	; id combo
	jmp	err2id

					; otherwise found it
					; continue to build tbl
;**************************** CNS **********************************************

VALID6:
	MOV	AX,WORD PTR FB.KL_LOGIC_PTR	; Save the offset of the state
	MOV	WORD PTR STATE_LOGIC_OFFSET,AX	;    logic section
	MOV	AX,WORD PTR FB.KL_LOGIC_PTR+2	; Save the offset of the state
	MOV	WORD PTR STATE_LOGIC_OFFSET+2,AX ;   logic section

	MOV	DL,[BP].RET_CODE_2	; IF code page was specified
	CMP	DL,2
	JNE	CODE_PAGE_SPECIFIED
	JMP	short DONE

CODE_PAGE_SPECIFIED:		      ;  Then

;************************** CNS ***************************************
	xor	ah,ah
	MOV	Al,FB.KL_NUM_CP
;************************** CNS ***************************************

	MOV	NUM_CP,AX		; Save the number of code pages
	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	MOV	DX,OFFSET FILE_BUFFER	; Establish beginning of buffer
	MOV	CX,AX
	CMP	CX,SIZE FILE_BUFFER	; Make sure buffer is not to small
	JBE	VALID7
	JMP	ERROR4

VALID7:
	MOV	AH,3FH			; Read code page table from
	INT	21H			;	Keyb Def file
	JNC	VALID8			; If no error in opening file then
	JMP	ERROR4

VALID8:
	MOV	CX,NUM_CP		;    Number of valid codes
	MOV	DI,OFFSET FILE_BUFFER	;    Point to correct word in table

SCAN_CP_TABLE:				; FOR code page parm
	MOV	AX,[BP].CODE_PAGE_PARM	;    Get parameter
	CMP	[DI].KC_CODE_PAGE,AX	;    Valid Code ??
	JE	CODE_PAGE_FOUND		; If not found AND more entries THEN

	ADD	DI,CP_PTR_SIZE		;    Check next entry
	DEC	CX			;    Decrement count of entries
	JNE	SCAN_CP_TABLE		; Else
	JMP	ERROR2			;    Display error message
				
CODE_PAGE_FOUND:
	MOV	AX,WORD PTR [DI].KC_ENTRY_PTR
	MOV	WORD PTR CP_TAB_OFFSET,AX
	MOV	AX,WORD PTR [DI].KC_ENTRY_PTR+2
	MOV	WORD PTR CP_TAB_OFFSET+2,AX

DONE:
	MOV	SI,OFFSET DESIG_CP_BUFFER

	MOV	AX,CON_INSTALLED	;  If CON is NOT installed THEN
	or	ax,ax
	JE	SYSTEM_CP
	JMP	short GET_DESIG_CPS

SYSTEM_CP:
	MOV	CX,1
	MOV	NUM_DESIG_CP,CX		; Set number of CPs = 1
	MOV	[SI].NUM_DESIGNATES,CX

	MOV	DL,[BP].RET_CODE_2	; Check if code page parm
	or	dl,dl			;    was specified
	JNE	SET_TO_SYSTEM_CP

	MOV	DX,[BP].CODE_PAGE_PARM
	MOV	[SI].DESIG_CP_ENTRY,DX	; Load specified code page into
	JMP	READY_TO_BUILD_TABLE	;      designated code page list

SET_TO_SYSTEM_CP:
	CALL	FIND_FIRST_CP		; Call routine that sets the first
	or	ax,ax			;   table found in the Keyb Def file
	JE	SET_TO_SYSTEM_CP2	;	to the system code page
	JMP	ERROR4

SET_TO_SYSTEM_CP2:
	MOV	SYS_CODE_PAGE,BX
	MOV	[BP].CODE_PAGE_PARM,BX
	MOV	[SI].DESIG_CP_ENTRY,BX	;    Move sys CP into desig list
	JMP	READY_TO_BUILD_TABLE

GET_DESIG_CPS:				;  ELSE
	MOV	AX,0AD03H
	PUSH	CS			; Make sure ES is set
	POP	ES
	LEA	DI,DESIG_CP_BUFFER
	MOV	CX,DESIG_CP_BUF_LEN
	INT	2FH			; Get all designated code pages
	JNC	SET_DESIG_VARIABLES	;  from console
	JMP	ERROR5

SET_DESIG_VARIABLES:
	MOV	CX,[SI].NUM_DESIGNATES
	ADD	CX,[SI].NUM_HW_CPS
	MOV	NUM_DESIG_CP,CX		; Set number of Designated CPs

BUFFER_CREATED:
	MOV	AX,0AD02H
	INT	2FH			; Get invoked code page

SET_TO_CP_INVOKED:
	MOV	DL,[BP].RET_CODE_2	; IF code page parm was specified
	or	dl,dl
	JNE	SET_TO_INVOKED_CP

	MOV	CX,NUM_DESIG_CP
	MOV	DESIG_LIST,SI
	JMP	short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP:
	CMP	AX,1			; IF a code page has been invoked
	JNE	SET_TO_INVOKED_CP3

	CALL	FIND_FIRST_CP		; Call the routine that sets the
	or	ax,ax			; first code page in the Keyb Def
	JE	SET_TO_INVOKED_CP2	;  file to the system code page
	JMP	ERROR4

SET_TO_INVOKED_CP2:
	MOV	[BP].CODE_PAGE_PARM,BX
	MOV	SYS_CODE_PAGE,BX

	JMP	short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP3:
	MOV	[BP].CODE_PAGE_PARM,BX

TEST_IF_DESIGNATED:
	MOV	DX,[BP].CODE_PAGE_PARM
	CMP	[SI].DESIG_CP_ENTRY,DX	; Is Code page specified in the list
	JE	CODE_PAGE_DESIGNATED	;   of designated code pages ?

NEXT_DESIG_CP:
	ADD	SI,2			; Check next code page
	DEC	CX			; If all designated code pages have
	JNZ	TEST_IF_DESIGNATED	;   been checked Then ERROR
	JMP	ERROR6

CODE_PAGE_DESIGNATED:
	CMP	SYS_CODE_PAGE,0
	JNE	READY_TO_BUILD_TABLE
	CMP	AX,1			; IF a code page has been invoked
	JE	READY_TO_BUILD_TABLE
	CMP	[BP].CODE_PAGE_PARM,BX	; IF Invoked CP <> Specified CP
	JE	READY_TO_BUILD_TABLE	;	 Issue warning

;***************************************************************************
	PUSH	BX
	PUSH	CX
	MOV	AX,WARNING_1
	MOV	BX,STDOUT
	XOR	CX,CX
	MOV	DH,UTILITY_MSG_CLASS
	XOR	DL,DL
	CALL	SYSDISPMSG
	POP	CX
	POP	BX
;***************************************************************************


READY_TO_BUILD_TABLE:

	MOV	AX,KEYB_INSTALLED
	or	ax,ax			; Else if KEYB has not been installed
	JNE	BUILD_THE_TABLE

	CALL	FIND_SYS_TYPE		; Determine system type for INT 9 use

;------ LOAD IN SPECIAL INT 9 HANDLER AND SPECIAL TABLES

	CALL	INSTALL_INT_9		; Install INT 9

	CALL	FIND_KEYB_TYPE		; Determine keyboard type table use

BUILD_THE_TABLE:
	CALL	TABLE_BUILD		; Build the TEMP_SHARED_DATA_AREA

CHECK_ERRORS:
					; Take appropriate action considering
	MOV	CX,TB_RETURN_CODE	;  return codes from TABLE_BUILD
	jcxz	CHECK_FOR_INV_CP	; If return code is not 0

	MOV	AX,KEYB_INSTALLED	; If KEYB has not been installed,
	or	ax,ax
	JNE	CHECK_ERROR_CONTINUE

	CALL	REMOVE_INT_9		;     remove installed vector

CHECK_ERROR_CONTINUE:
	CMP	CX,1			; If return code = 1
	JNE	CHECK_ERROR2
	JMP	ERROR1			;     display error message

CHECK_ERROR2:
	CMP	CX,2			; If return code = 2
	JNE	CHECK_ERROR3
	JMP	ERROR2

CHECK_ERROR3:
	CMP	CX,3			; If return code = 3
	JNE	CHECK_ERROR4
	JMP	ERROR3			;     display error message

CHECK_ERROR4:
	CMP	CX,4			; If return code = 4
	JNE	CHECK_ERROR5A
	JMP	ERROR4			;     display error message

CHECK_ERROR5A:
	CMP	CX,5			; If return code = 5
	JNE	CHECK_ERROR6A
	JMP	ERROR5A			;     display error message

CHECK_ERROR6A:
	JMP	ERROR6A			; If return code not 0,1,2,3,4 then
					;      display error message
CHECK_FOR_INV_CP:
	MOV	CX,CPN_INVALID		; Check if any CPs were not loaded
	jcxz	TERMINATE		;   If some were invalid, issue
					;	warning message

;***************************************************************************
	PUSH	BX
	PUSH	CX
	MOV	AX,NOT_SUPP
	MOV	BX,STDOUT		;  WARNING
	XOR	CX,CX			;   MESSAGE
	MOV	DH,UTILITY_MSG_CLASS
	XOR	DL,DL
	CALL	SYSDISPMSG
	POP	CX
	POP	BX
;***************************************************************************

TERMINATE:
	MOV	AH,3EH			;  Close the KEYBOARD.SYS file
	MOV	BX,KEYBSYS_FILE_HANDLE	;  if open
	or	bx,bx
	JE	KEYB_EXIT
	INT	21H

	MOV	AX,KEYB_INSTALLED
	or	ax,ax
	JE	KEYB_EXIT
	JMP	KEYB_EXIT_NOT_RESIDENT

KEYB_EXIT:
	TEST	SD.KEYB_TYPE,G_KB	; Q..FERRARI G??
	JZ	NO_FERRARI_G		; N..LEAVE NUMLK ALONE
	TEST	SD.SYSTEM_FLAG,PC_XT	;   Q..PC/XT?
	JNZ	NO_FERRARI_G		;   Y..LEAVE NUMLK ALONE
	TEST	SD.KEYB_TYPE,P_KB	;      Q..FERRARI P??
	JNZ	NO_FERRARI_G		;      Y..LEAVE NUMLK ALONE

;***CNS
	CMP	SECURE_FL,1		; IF SECURITY FLAG SET
	JNE	NO_FERRARI_G		; DON'T TURN ON NUM_LK

;***CNS
	CALL	NUMLK_ON		;    N..TURN NUMLK ON

NO_FERRARI_G:
	TEST	SD.SYSTEM_FLAG,EXT_16	; extended INT 16 support?
	JZ	SKIP_CTRL_COPY
				       ; Yes, load extened CTRL case table

	MOV	CX,L_CTRL_TAB	       ; CX = LENGTH OF EXTENDED TABLE
	MOV	SI,OFFSET CS:RPL_K8    ; POINT TO EXT. CTRL TABLES
	MOV	DI,OFFSET CS:K8        ; POINT TO REGULAR CTRL TABLE
	CLD			
	REP	MOVSB		       ; OVERLAY WITH EXT. CTRL TABLE
				
SKIP_CTRL_COPY: 		
	CALL	INSTALL_INT_9_NET	; Let the network know about INT 9
					;     (if the network is installed)
	CALL	INSTALL_INT_2F		; Install INT 2F
				
	MOV	AX,0AD82H		; Activate language
	MOV	BL,-1
	INT	2FH
				
	MOV	AH,31H			; Function call to terminate but stay
	XOR	AL,AL			;   resident
	MOV	DI,OFFSET SD_DEST_PTR	; Initialize destination ptr
				
	MOV	DX,ES:TSD.RESIDENT_END	; Get resident end
				
	CALL	COPY_SDA_SETUP		; Set up move common code
				
	JMP	COPY_SD_AREA		; Jump to proc that copies area in new
					;	part of memory

;***************************** CNS **************************************
ERR1ID:
;************************************************************************

	MOV	AX,INV_I		; invalid ID message
	MOV	BX,STDOUT		;  to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	KEYB_EXIT_NOT_RESIDENT
ERR2ID:
;***************************************************************************

	MOV	AX,INV_COMBO		; invalid combination message
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;**************************************************************************
	JMP	KEYB_EXIT_NOT_RESIDENT
;***************************** CNS ****************************************

ERROR1:
;***************************************************************************
	MOV	AX,INV_L		; invalid language code
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message

	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL
;***************************************************************************

	JMP	KEYB_EXIT_NOT_RESIDENT
ERROR2:
;***************************************************************************
	MOV	AX,INV_CP		; invalid code page message
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message

	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	KEYB_EXIT_NOT_RESIDENT
ERROR3:
;***************************************************************************

	MOV	AX,INV_S		; invalid syntax message
	MOV	BX,STDOUT		; to standard out
;***CNS

	LEA	DI,STRING_HOLDER	;Set PTR to look at the STRING
	PUSH	SI			;Save current SI index
	PUSH	AX
	MOV	AX,OLD_PTR		;Last locale of the end of a PARAM
	SUB	CUR_PTR,AX		;Get the length via the PSP
	MOV	SI,CUR_PTR
	MOV	CX,SI			;Save it in CX to move in the chars
	POP	AX			;Restore the PTR to the command line position

	MOV	SI,OLD_PTR		;Last locale of the end of a PARAM
	REP	MOVSB			;Move in the chars until no more

	LEA	DI,STRING_HOLDER	;Set PTR to look at the STRING


	POP	SI			;Restore the PTR to the command line position

	MOV	CX,1			;One replacement
	MOV	PTR_TO_COMLIN,DI	; language code asciiz string


	PUSH	AX
	MOV	AX,DS			; language code asciiz string
	MOV	SEG_OF_COMLIN,AX
	POP	AX

	MOV	AX,ERR_PART
	LEA	SI,SUBLIST_COMLIN
	MOV	DH,PARSE_ERR_CLASS	; parse error message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR4:
;***************************************************************************

	MOV	AX,INV_FN		; bad or missing file message
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,BAD_KEYB_DEF_FILE
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR5:
;***************************************************************************

	MOV	AX,INV_CON_Q		; CON code page not available.
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,CONSOLE_ERROR
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR5A:
;***************************************************************************

	MOV	AX,MEMORY_OVERF		; not enough resident memory.
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,MEMORY_OVERFLOW
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR6:
;***************************************************************************

	MOV	AX,NOT_DESIG		; code page not prepared.
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,CP_NOT_DESIGNATED
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR6A:
;***************************************************************************

	MOV	NUMBER_HOLDER,BX	; transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	; sublist points to...
	MOV	PTR_TO_NUMBER,SI	; code page word
	MOV	AX,NOT_VALID		; display 'Code page requested....'
	MOV	BX,STDOUT		; to standard out
	MOV	CX,1			; one replacement
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_NUMBER	; ptr to sublist
	CALL	SYSDISPMSG

	MOV	AL,KEYB_TABLE_NOT_LOAD
	MOV	EXIT_RET_CODE,AL

;***************************************************************************

KEYB_EXIT_NOT_RESIDENT:
	MOV	AH,04CH
	MOV	AL,QUERY_CALL		; Check if this was a query call
	or	al,al
	JNE	KEYB_EXIT3		;  IF yes then EXIT

	MOV	AL,EXIT_RET_CODE	; Check if return code was valid
	or	al,al
	JNE	KEYB_EXIT3		;  IF not then EXIT

COPY_INTO_SDA:
	MOV	AX,0AD82H		; Activate language
	MOV	BL,-1
	INT	2FH

	MOV	AH,04CH
	MOV	AL,EXIT_RET_CODE
	MOV	DI,WORD PTR SHARED_AREA_PTR+2	; Initialize destination ptr
	MOV	ES,WORD PTR SHARED_AREA_PTR
	MOV	DX,[BP].RESIDENT_END

	CALL	COPY_SDA_SETUP	       ; Set up move common code

	JMP	COPY_SD_AREA	       ; Jump to proc that copies area in new

KEYB_EXIT3:
	MOV	AL,EXIT_RET_CODE
	MOV	DI,WORD PTR SHARED_AREA_PTR+2	; Initialize destination ptr
	MOV	ES,WORD PTR SHARED_AREA_PTR
	MOV	ES:[DI].TABLE_OK,1
	INT	21H

KEYB_COMMAND  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: COPY_SDA_SETUP
;
; Description:
;     Common setup logic for exit
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SDA_SETUP	PROC	NEAR

	push	ax			;save existing values
	push	es
	mov	ax,cs:[2ch]		;check offset for address containin environ.
	or	ax,ax
	je	NO_FREEDOM

	mov	es,ax
	mov	ax,4900H		;make the free allocate mem func
	int	21h

NO_FREEDOM:
	pop	es			;restore existing values
	push	bx
					;Terminate and stay resident
	mov	bx,4			;1st close file handles
					;STDIN,STDOUT,STDERR
closeall:
	mov	ah,3eh
	int	21h
	dec	bx
	jnz	closeall

	pop	bx
	pop	ax

	MOV	CL,4			; Convert into paragrahs
	SHR	DX,CL
	INC	DX

	MOV	SI,OFFSET SD_SOURCE_PTR	; Initialize source ptr
	XOR	BP,BP
	LEA	BX,[BP].ACTIVE_LANGUAGE
	ADD	DI,BX			; Adjust for portion not copied
	ADD	SI,BX			; Adjust for portion not copied

	MOV	CX,SD_LENGTH		; Set length of SHARED_DATA_AREA
	SUB	CX,BX			; Adjust for portion not copied

	RET

COPY_SDA_SETUP	ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: NUMLK_ON
;
; Description:
;     Turn  Num Lock On.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Set Num Lock bit in BIOS KB_FLAG
;     Issue Int 16 to update lights
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NUMLK_ON     PROC

	PUSH	ES
	PUSH	AX

	MOV	AX,DATA
	MOV	ES,AX

	OR	ES:KB_FLAG,NUM_STATE	; Num Lock state active
	MOV	AH,1			; Issue keyboard query call to
	INT	16H			;  have BIOS update the lights

	POP	AX
	POP	ES
	RET

NUMLK_ON   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9
;
; Description:
;     Install our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	Get existing vector
;	Install our vector
;	Return
;

INSTALL_INT_9	     PROC

	PUSH	ES

	MOV	AH,35H			; Get int 9 vector
	MOV	AL,9
	INT	21H			; Vector in ES:BX

	PUSH	ES			; Save segment ES:
	PUSH	CS
	POP	ES
	MOV	WORD PTR ES:SD.OLD_INT_9,BX ; Offset
	POP	AX			; Recover ES: segment
	MOV	WORD PTR ES:SD.OLD_INT_9+2,AX ; Segment

	MOV	AH,25H
	MOV	AL,9
	MOV	DX,OFFSET KEYB_INT_9	; Let DOS know about our handler
	INT	21H

	POP	ES
	RET

INSTALL_INT_9	     ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9_NET
;
; Description:
;
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	IF network is installed THEN
;	  Let it know about our INT 9
;	Return
;

INSTALL_INT_9_NET    PROC

	PUSH	ES

	TEST	SD.SYSTEM_FLAG,PC_NET	; TEST FOR PC_NETWORK
					; IF NOT THE NETWORK INSTALLED
	JZ	INSTALL_9_DONE_NET	; SKIP THE PC NETWORK HANDSHAKE

					; ES:BX TO CONTAIN INT 9 ADDR
	MOV	BX,OFFSET KEYB_INT_9
	MOV	AX,0B808H		; FUNCTION FOR PC NETWORK TO INSTALL
					; THIS ADDRESS FOR THEIR JUMP TABLE
	INT	2FH			; TELL PC_NET TO USE MY ADDR TO CHAIN TO

INSTALL_9_DONE_NET:
	POP	ES
	RET

INSTALL_INT_9_NET    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_2F
;
; Description:
;     Install our INT 2F drivers.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	Get existing vectors
;	Install our vectors
;	Return
;
;
INSTALL_INT_2F    PROC

	MOV	AH,35H			; Get int 2f vector
	MOV	AL,2FH
	INT	21H			; Vector in ES:BX

	PUSH	ES			; Save segment ES:
	PUSH	CS
	POP	ES
	MOV	WORD PTR ES:SD.OLD_INT_2F,BX ; Offset
	POP	AX			; Recover ES: segment
	MOV	WORD PTR ES:SD.OLD_INT_2F+2,AX ; Segment

	MOV	AH,25H			; Set int 9 vector
	MOV	AL,2FH
	MOV	DX,OFFSET KEYB_INT_2F	; Vector in DS:DX
	INT	21H


	RET

INSTALL_INT_2F    ENDP

;
;
; Module: REMOVE_INT_9
;
; Description:
;     Remove our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	Get old vector
;	Install old vector
;	Return
;

REMOVE_INT_9	    PROC

	PUSH	DS
	PUSH	ES
	MOV	ES,WORD PTR SHARED_AREA_PTR
	MOV	AX,WORD PTR ES:SD.OLD_INT_9+2	; int 9 vector - segment
	MOV	DS,AX
	MOV	DX,WORD PTR ES:SD.OLD_INT_9	; int 9 vector - offset

	MOV	AH,25H			; Set int 9 vector
	MOV	AL,9
	INT	21H

REMOVE_9_DONE:
	POP	ES
	POP	DS
	RET

REMOVE_INT_9		 ENDP



IDLANG_CHK	PROC	NEAR

	mov	ax,fb.kl_id_code	;get the id code from the table
	cmp	ax,[bp].id_parm 	;compare it to value taken
	jne	end_match		;from the switch-- if found
	cmp	ALPHA,0 		;a keyboard code was specified
	je	a_match 		;no lang & a match

	mov	ax,fb.kl_lang_code	;compare lang codes
	cmp	ax,[BP].LANGUAGE_PARM	;they are equal
	je	a_match

	jmp	short end_match		;if not found go check next
					;id for the same country

a_match:
	mov	good_match,1		;report the ids match

end_match:
	ret

    IDLANG_CHK	ENDP
;*********************** CNS *******************;

;**********************************SCAN_ID***********************;
; New variables defined - NUM_ID,ADRSS_LANG,ID_PTR_SIZE,ID_FOUND
;****************************************************************;


SCAN_ID PROC	NEAR

	xor	di,di			;clear di to set at the
					;beginning of KEYBSYS STRUCTURE


	lea	cx,[di].kh_num_ID+4	; set number of bytes to read header

	mov	ah,3fh
	int	21h
	jnc	VAL5ID
	jmp	short BAD_TAB 		 ;bad table message

 VAL5ID:

	mov	cx,SIGNATURE_LENGTH
	mov	di,offset SIGNATURE
	mov	si,offset FB.KH_SIGNATURE
	repe	CMPSB
	je	ID_SPECIFIED
	jmp	short BAD_TAB



 ID_SPECIFIED:

	mov	ax,FB.KH_NUM_ID
	mov	NUM_ID,ax		; save # of IDs
	mul	ID_PTR_SIZE		; determine # of bytes to read
	push	ax			; save current # of bytes to read for
					; ID values only
	mov	ax,FB.KH_NUM_LANG	; add on lang data in table
	mul	LANG_PTR_SIZE		; data that comes before the ID data
	mov	cx,ax			; save that value for the size compare
	mov	PASS_LANG,cx
	pop	ax			; restore the info for # of ID bytes to read

	add	cx,ax			; add that value to get total in CX
	mov	TOTAL_SIZE,cx		; save the total size
	cmp	cx,size FILE_BUFFER
	jbe	READ_ID_TAB
	jmp	short BAD_TAB


READ_ID_TAB:
	mov	dx,offset FILE_BUFFER
	mov	ah,3fh			;read language table from
	int	21h			;keyb defn file
	jnc	READ_IDVAL
	jmp	short BAD_TAB

READ_IDVAL:

	mov	cx,NUM_ID
	mov	di,offset FILE_BUFFER
	add	di,PASS_LANG

SCAN_ID_TAB:

	mov	ax,[bp].ID_PARM
	cmp	[di].KP_ID_CODE,ax
	je	ID_HERE

	add	di,ID_PTR_SIZE
	dec	cx
	jne	SCAN_ID_TAB

	jmp	short FINALE

BAD_TAB:
	mov	ERR4ID,1
	jmp	short FINALE

ID_HERE:
	mov	ID_FOUND,1		;reset ptr for
					;current country
FINALE:
	ret

SCAN_ID	ENDP

;*******************************SCAN_ID END******;
;
; Module: BUILD_PATH
;
; Description:
;     Build the complete filename of the Keyboard Definition File
;*************************************WGR*********************
;     and open the file.
;+++++++++++++++++++++++++++++++++++++WGR+++++++++++++++++++++
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;************************************WGR**********************
;     CARRY CLEAR
;	    AX = HANDLE
;     CARRY SET (ERROR)
;	    NONE
;++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++++++
;    The complete filename will be available in FILE_NAME
;
; Logic:
;
;    Determine whether path parameter was specified
;    IF length is zero THEN
;****************************************WGR******************
;	Try to open file in ACTIVE directory
;	IF failed THEN
;	  Try to open file in ARGV(0) directory
;	  IF failed THEN
;	    Try to open file in ROOT directory (for DOS 3.3 compatibility)
;	    ENDIF
;	  ENDIF
;	ENDIF
;    ELSE
;	Copy path from PSP to FILE_NAME memory area
;	Try to open USER SPECIFIED file
;++++++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++
;
;

KEYBOARD_SYS	DB   '\KEYBOARD.SYS',00
KEYB_SYS_ACTIVE DB   'KEYBOARD.SYS',00
KEYB_SYS_LENG	EQU  14
KEYB_SYS_A_LENG EQU  13

FILE_NAME	DB   128 DUP(0)

FILE_NOT_FOUND	EQU  2
PATH_NOT_FOUND	EQU  3
;
;  Program Code
;

BUILD_PATH    PROC  NEAR

	CLD
	MOV	DI,OFFSET FILE_NAME	; Get the offset of the filename
	MOV	CX,[BP].PATH_LENGTH	; If path is specified then
	jcxz	APPEND_KEYB_SYS

	MOV	SI,[BP].PATH_OFFSET	;   Get the offset of the path

	REPE	MOVSB			;   Copy each char of the specified

	MOV	AX,3D00H		; Open the KEYBOARD.SYS file
	MOV	DX,OFFSET FILE_NAME
	INT	21H
	RET				;   path into the filename location

APPEND_KEYB_SYS:
	MOV	SI,OFFSET KEYB_SYS_ACTIVE ;  copy name for active directory
	MOV	CX,KEYB_SYS_A_LENG	;  to file name variable.
	REPE	MOVSB

	MOV	AX,3D00H		; try to open it.
	MOV	DX,OFFSET FILE_NAME
	INT	21H

	jnc	opened_ok		; brif no error opening

	cmp	ax,PATH_NOT_FOUND	; was it path?
	jz	open_err_1
	cmp	ax,FILE_NOT_FOUND	; or file not found?
	jnz	open_err_2

open_err_1:
	CALL	COPY_ARGV0		; yes....try ARGV(0) directory.
	MOV	AX,3D00H
	MOV	DX,OFFSET FILE_NAME
	INT	21H

	jnc	opened_ok		; done if open ok

	cmp	ax,PATH_NOT_FOUND	; if path or file not found, try root
	jz	open_err_3
	cmp	ax,FILE_NOT_FOUND
	jnz	open_err_2

open_err_3:
	MOV	SI,OFFSET KEYBOARD_SYS	; try ROOT directory.
	MOV	DI,OFFSET FILE_NAME
	MOV	CX,KEYB_SYS_LENG
	REPE	MOVSB

	MOV	AX,3D00H
	MOV	DX,OFFSET FILE_NAME
	INT	21H

	jmp	short opened_ok

open_err_2:
	stc				; some other error, set error flag

opened_ok:

	RET

BUILD_PATH	ENDP


COPY_ARGV0  PROC

	PUSH	ES
	PUSH	DI
	PUSH	SI
	PUSH	CX

	MOV	DI,2CH		       ; Locate environment string
	MOV	ES,[DI]
	XOR	SI,SI

carv0_loop:
	cmp	word ptr es:[si],0	; find ARGV(0) string
	jz	carv0_loop_exit
	inc	si
	jmp	carv0_loop

carv0_loop_exit:
	ADD	SI,4
	LEA	DI,FILE_NAME		; move string to work area

carv0_loop1:
	MOV	AL,ES:[SI]
	MOV	[DI],AL
	INC	SI
	INC	DI
	cmp	byte ptr es:[si],0
	jnz	carv0_loop1

carv0_loop2:
	dec	di
	cmp	byte ptr [di],'\'	; scan back to first character after "\"
	jz	carv0_loop2_exit
	cmp	byte ptr [di],0
	jnz	carv0_loop2

carv0_loop2_exit:
	INC	DI
	PUSH	CS
	POP	ES
	LEA	SI,KEYB_SYS_ACTIVE	; copy in "KEYBOARD.SYS"
	MOV	CX,KEYB_SYS_A_LENG
	REPE	MOVSB

	POP	CX
	POP	SI
	POP	DI
	POP	ES
	RET

COPY_ARGV0  ENDP

;
;
; Module: FIND_FIRST_CP
;
; Description:
;     Check the keyboard definition file for the first code page
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;	    NONE
;
; Logic:
;   Open the file
;   IF error in opening file THEN
;	Display ERROR message and EXIT
;   ELSE
;	Save handle
;	Set address of buffer
;	READ header of Keyboard definition file
;	IF error in reading file THEN
;	   Display ERROR message and EXIT
;	ELSE
;	   Check signature for correct file
;	   IF file signature is correct THEN
;	      READ language table
;	      IF error in reading file THEN
;		  Display ERROR message and EXIT
;	      ELSE
;		  Use table to verify language parm
;		  Set pointer values
;		  IF code page was specified
;		      READ language entry
;		      IF error in reading file THEN
;			   Display ERROR message and EXIT
;		      ELSE
;			   READ first code page
;			   IF error in reading file THEN
;			       Display ERROR message and EXIT
;   RET
;
;

FIND_FIRST_CP PROC  NEAR

	PUSH	CX			; Save everything that
	PUSH	DX			;  that will be changed
	PUSH	SI
	PUSH	DI

	MOV	BX,KEYBSYS_FILE_HANDLE	; Get handle
	MOV	DX,WORD PTR KEYBCMD_LANG_ENTRY_PTR   ; LSEEK file pointer
	MOV	CX,WORD PTR KEYBCMD_LANG_ENTRY_PTR+2 ;	to top of language entry
	MOV	AH,42H
	MOV	AL,0			; If no problem with
	INT	21H			;     Keyb Def file Then
	JNC	FIND_FIRST_BEGIN
	JMP	short FIND_FIRST_CP_ERROR4

FIND_FIRST_BEGIN:
	MOV	DI,AX
	MOV	CX,SIZE KEYBSYS_LANG_ENTRY-1 ; Set number
					;	bytes to read header
	MOV	DX,OFFSET FILE_BUFFER
	MOV	AH,3FH			; Read language entry in
	INT	21H			;	 keyboard definition file
	JNC	FIND_FIRST_VALID4	; If no error in opening file then
	JMP	short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID4:

;************************** CNS *******;
	xor	ah,ah
	MOV	Al,FB.KL_NUM_CP
;************************** CNS *******;

	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	MOV	DX,OFFSET FILE_BUFFER	; Establish beginning of buffer
	MOV	CX,AX
	CMP	CX,SIZE FILE_BUFFER	; Make sure buffer is not to small
	JBE	FIND_FIRST_VALID5

	JMP   short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID5:
	MOV	AH,3FH			; Read code page table from
	INT	21H			;	     keyboard definition file
	JNC	FIND_FIRST_VALID6	; If no error in opening file then
	JMP	short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID6:
	MOV	CX,NUM_CP		; Number of valid codes
	MOV	DI,OFFSET FILE_BUFFER	; Point to correct word in table

	MOV	BX,[DI].KC_CODE_PAGE	; Get parameter
	XOR	AX,AX
	JMP	short FIND_FIRST_RETURN

FIND_FIRST_CP_ERROR4:
	MOV	AX,4

FIND_FIRST_RETURN:
	POP	DI
	POP	SI
	POP	DX
	POP	CX

	RET

FIND_FIRST_CP  ENDP

	.xlist
MSG_SERVICES <MSGDATA>
MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg>
MSG_SERVICES <KEYB.CL1>
MSG_SERVICES <KEYB.CL2>
MSG_SERVICES <KEYB.CLA>
	.list
;
; Temp Shared Data Area
; Contains data which is required by
; both the resident and transient KEYB code.
; All keyboard tables are stored in this area
; Structures for this area are in file KEYBSHAR.INC
;
	db	'TEMP SHARED DATA'
SD_SOURCE_PTR	LABEL	   BYTE
TEMP_SHARED_DATA SHARED_DATA_STR <>

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybcpsd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                               
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;  File Name:  KEYBCPSD.ASM
;  ----------
;
;
;  Description:
;  ------------
;	 Copies the SHARED_DATA_AREA into a part of memory that
;	 can be left resident. All relative pointers must already
;	 be recalculated to this new position.
;	 THIS FILE MUST BE THE LAST OF THE RESIDENT FILES WHEN KEYB IS LINKED.
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;  Include Files Required:
;  -----------------------
;	INCLUDE KEYBSHAR.INC
;	INCLUDE KEYBCMD.INC
;	INCLUDE KEYBTBBL.INC
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      procedure - description???
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	SD_DEST_PTR
	PUBLIC	COPY_SD_AREA
	PUBLIC	SHARED_DATA

	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBTBBL.INC

CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: COPY_SD_AREA
;
;  Description:
;
;  Input Registers:
;
;  Output Registers:
;      N/A
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SD		EQU   SHARED_DATA
TSD		EQU  TEMP_SHARED_DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SD_AREA	PROC   NEAR

   REP	MOVS	ES:BYTE PTR [DI],DS:[SI]	; Copy SHARED_DATA_AREA to
						;	new part of memory

	MOV	BYTE PTR ES:SD.TABLE_OK,1	; Activate processing flag
	INT	21H				; Exit


COPY_SD_AREA	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db	'SHARED DATA'
SD_DEST_PTR	LABEL	BYTE

SHARED_DATA   SHARED_DATA_STR <>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE   ENDS
       END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                             
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBEQU.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing equates used by all KEYB modules.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
YES		EQU	1		;;
NO		EQU	0		;;
					;;
INT_2F_SUB_FUNC EQU	0ADH		;; our subfunction code for int 2f
SD		EQU	SHARED_DATA	;;
TSD		EQU	TEMP_SHARED_DATA;;
					;;
DLY_15ms	EQU	995		;; 15mS DELAY = (15000/15.086)
MOUSE_OBF	EQU	00100000b	;; AUX DATA PRESENT BIT AT STATUS_PORT
SCAN_CODE_CMD	EQU	0F0h		;; SELECT SCAN CODE SET COMMAND TO KB
					;;
FILE_BUFFER_SIZE equ    300             ;; buffer used for reading keyboard.sys
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybdcl.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */



.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBDCL.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Common declarations for structures in procedures for KEYB.COM
;;
;; Change History:
;; ---------------
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
PARM_LIST	 STRUC		       ;;
;*******************CNS******************
;*******************CNS******************
    RET_CODE_1	    DB	 0	       ;;  \
    RET_CODE_2	    DB	 0	       ;;  |
    RET_CODE_3	    DB	 0	       ;;  |
;*******************CNS******************
    RET_CODE_4	    DB	 0	       ;;  |;AN000;
;*******************CNS******************
    LANGUAGE_PARM   DW	 ?	       ;;   }  PARAMETER
    CODE_PAGE_PARM  DW	 ?	       ;;  |	    LIST
    PATH_OFFSET     DW	 ?	       ;;  |
    PATH_LENGTH     DW	 0	       ;;  /
;*******************CNS******************
    ID_PARM	    DW	 ?	       ;AN000;
;*******************CNS******************
PARM_LIST	 ENDS		       ;;
				       ;;
DESIG_CP_STRUC	 STRUC		       ;;
    NUM_DESIGNATES  DW	 ?	       ;;
    NUM_FONTS	    DW	 ?	       ;;
    NUM_HW_CPS	    DW	 ?	       ;;
    DESIG_CP_ENTRY  DW	 ?	       ;;
DESIG_CP_STRUC	  ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybi9.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
        PAGE    ,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                              
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI9.ASM
; ----------
;
; Description:
; ------------
;       Converts scan codes to ASCII for non-US keyboards.
;       This orutine uses the tables loaded into the SHARED_DATA_AREA
;       from KEYBOARD.SYS by the KEYB_COMMAND module.
;
;
; Procedures Contained in This File:
; ----------------------------------
;       KEYB_STATE_PROCESSOR - Scan to ASCII translator.
;
; External Procedure References:
; ------------------------------
;       None.
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE KEYBEQU.INC
        INCLUDE DSEG.INC               ; System data segments
        INCLUDE POSTEQU.INC            ; System equates
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBI9C.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBCMD.INC

        PUBLIC KEYB_STATE_PROCESSOR

CODE    SEGMENT PUBLIC 'CODE'

        ASSUME  CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: KEYB_STATE_PROCESSOR
;
; Description:
;     Convert scan to ASCII using the tables loaded into the
;     SHARED_DATA_AREA.  Conversion is directed by the STATE LOGIC
;     commands contained in the SHARED_DATA_AREA.  This routine
;     interprets those commands.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Enable interrupts
;     Save registers
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BREAK_CODE    EQU  80H

HOT_KEY_ACTIVE  DB   0                 ; 1 if hot key is active


                                       ; These are copies of the BIOS FLAGS
FLAGS_TO_TEST    LABEL BYTE            ;  KB_FLAG, KB_FLAG_1,2,3
KB_SHADOW_FLAGS  DB   NUM_BIOS_FLAGS DUP(0)
EXT_KB_FLAG      DB   0                ; Extended KB Flag for shift states
NLS_FLAG_1       DB   0                ; NLS Flags for dead key etc
NLS_FLAG_2       DB   0                ;  .

SAVED_NLS_FLAGS  DB   0,0              ; Saved copy of the NLS flags

OPTION_BYTE     DB    0                ; Set by OPTION command

KB_FLAG_PTRS    DW   OFFSET KB_FLAG    ; These are pointers to the BIOS flags
                DW   OFFSET KB_FLAG_1  ;  we must test
                DW   OFFSET KB_FLAG_2
                DW   OFFSET KB_FLAG_3

XLAT_TAB_PTR    DW   0                 ; pointer to xlat tables for cur state

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


NEST_LEVEL      DB   0
PROCESS_LEVEL   DB   0
TAKE_ELSE       DB   0
BUSY_FLAG       DB   0                 ; Flag to prevent re-entry

CMD_JUMP_TABLE  LABEL  WORD
        DW   OFFSET  IFF_PROC          ; CODE  0
        DW   OFFSET  ANDF_PROC         ;       1
        DW   OFFSET  ELSEF_PROC        ;       2
        DW   OFFSET  ENDIFF_PROC       ;       3
        DW   OFFSET  XLATT_PROC        ;       4
        DW   OFFSET  OPTION_PROC       ;       5
        DW   OFFSET  SET_FLAG_PROC     ;       6
        DW   OFFSET  PUT_ERROR_PROC    ;       7
        DW   OFFSET  IFKBD_PROC        ;       8
        DW   OFFSET  GOTO_PROC         ;       9
        DW   OFFSET  BEEP_PROC         ;       A
        DW   OFFSET  RESET_NLS_PROC    ;       B
        DW   OFFSET  UNKNOWN_COMMAND   ;       C
        DW   OFFSET  UNKNOWN_COMMAND   ;       D
        DW   OFFSET  UNKNOWN_COMMAND   ;       E
        DW   OFFSET  UNKNOWN_COMMAND   ;       F


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_STATE_PROCESSOR   PROC   NEAR

        TEST   byte ptr CS:SD.TABLE_OK,1
        JNZ    WE_HAVE_A_TABLE
        CLC                            ; BACK TO US INT 9
        RET
WE_HAVE_A_TABLE:

        PUSH   DS                      ; save DS
        PUSH   ES                      ; save ES
        PUSH   AX                      ; save scan code for caller
        PUSH   BX                      ; save shift states for caller

        PUSH   CS
        POP    DS                      ; DS = our seg
        MOV    BX,DATA
        MOV    ES,BX                   ; addressability to BIOS data


        CMP     COUNTRY_FLAG,0FFH      ; Q..country mode?
        JE      INIT_STATE_PROCESSING  ; Y..continue
        JMP     GOTO_BIOS              ; N..exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; -------STATE SECTION PROCESSING-------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INIT_STATE_PROCESSING:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set NLS shift flags EITHER_SHIFT, EITHER_ALT, EITHER_CTRL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                       ; Q..in shift state?
        TEST   ES:KB_FLAG,RIGHT_SHIFT+LEFT_SHIFT
        JNZ    IN_SHIFT_STATE          ; Y..go set bit
        AND    EXT_KB_FLAG,NOT EITHER_SHIFT ; N..clear bit
        JMP    SHORT TEST_CTL
IN_SHIFT_STATE:
        OR     EXT_KB_FLAG,EITHER_SHIFT
TEST_CTL:
        TEST   ES:KB_FLAG,CTL_SHIFT    ; Q..in control state?
        JNZ    IN_CTL_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_CTL_SHIFT ; Q..how bout the right ctl?
        JNZ    IN_CTL_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_CTL ; N..clear the bit
        JMP    SHORT TEST_ALT
IN_CTL_STATE:
        OR     EXT_KB_FLAG,EITHER_CTL
TEST_ALT:
        TEST   ES:KB_FLAG,ALT_SHIFT    ; Q..in alt state?
        JNZ    IN_ALT_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_ALT_SHIFT ; Q..how bout the right alt?
        JNZ    IN_ALT_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_ALT ; N..clear the bit
        JMP    SHORT COPY_FLAGS
IN_ALT_STATE:
        OR     EXT_KB_FLAG,EITHER_ALT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copy BIOS KB flags from BIOS data seg into the
; FLAGS_TO_TEST structure.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_FLAGS:
        MOV    CX,NUM_BIOS_FLAGS
        xor    si,si                    ; pointers to the BIOS flags
        xor    di,di                    ; create shadow copies
MOVE_NEXT_FLAG:
        MOV    BX,KB_FLAG_PTRS[SI]     ; pointer to next flag
        MOV    AL,ES:[BX]              ; flag in AL
        MOV    KB_SHADOW_FLAGS[DI],AL  ; save it in the shadow table
        INC    DI
        INC    SI
        INC    SI
        LOOP   MOVE_NEXT_FLAG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Interpret State Logic Commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_STATES:
        MOV    OPTION_BYTE,0           ; clear options
        MOV    SI,SD.LOGIC_PTR
        LEA    SI,[SI].SL_LOGIC_CMDS
NEXT_COMMAND:
        MOV    BL,[SI]                 ; command byte in BL
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1                    ; ISOLATE COMMAND CODE
        SHL    BL,1                    ; command code * 2
        JMP    CMD_JUMP_TABLE[BX]      ; go process command
UNKNOWN_COMMAND:
        JMP    FATAL_ERROR             ; bad news


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFKBD_DONE              ; N..don't process

        MOV    AX,[SI+1]               ; Keyboard Type Flag

        TEST   SD.KEYB_TYPE,AX         ; Q..are we the right system?
        JNZ    IFKBD_TEST_OK           ; Y..
IFKBD_TEST_FAILED:
        MOV    TAKE_ELSE,YES           ; test failed - take ELSE
        JMP    SHORT IFKBD_DONE
IFKBD_TEST_OK:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO
IFKBD_DONE:
        INC    NEST_LEVEL              ; IFKBD increments nest level
        INC    SI                      ; bump past IFKBD
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PUT_ERROR_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    PUT_ERROR_DONE          ; N..don't process
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        CALL   PUT_ERROR               ; check active section
        JC     PUT_ERROR_DONE          ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   PUT_ERROR

PUT_ERROR_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

PUT_ERROR      PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the PUT_ERROR command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
PE_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     PE_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     PE_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT PE_NEXT_STATE

PE_STATE_MATCH:
        MOV    AX,[DI].XS_ERROR_CHAR   ; get error char in AX
        CALL   BUFFER_FILL
        STC                            ; indicate that we found the state
PE_EXIT:
        RET

PUT_ERROR   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GOTO_BIOS:
        CLC                            ; clear carry flag indicating
        POP   BX                       ;  we should continue INT 9
        POP   AX                       ;   processing
        POP   ES
        POP   DS
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IFF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFF_DONE                ; N..don't process IFF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ITS_A_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    IFF_MATCH
        JZ     IFF_NO_MATCH
ITS_A_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     IFF_MATCH
IFF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        JMP    SHORT IFF_DONE
IFF_MATCH:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO

IFF_DONE:
        INC    NEST_LEVEL              ; IFF increments nest level
        INC    SI                      ; bump past IFF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELSEF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    CHECK_TAKE_ELSEF        ; N..check for take_else
        DEC    PROCESS_LEVEL           ; Y..we just finished the "IF" block
        JMP    short ELSEF_DONE        ;    so we are finished with IFF/ELSEF
CHECK_TAKE_ELSEF:
        CMP    TAKE_ELSE,YES           ; Q..are we scanning for ELSE?
        JNE    ELSEF_DONE              ; N..done
        DEC    NEST_LEVEL              ; ELSEF itself is back a level
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    NOT_THIS_ELSEF          ; N..this else is not the one
        INC    PROCESS_LEVEL           ; Y..process ELSEF block
        MOV    TAKE_ELSE,NO            ; reset
NOT_THIS_ELSEF:
        INC    NEST_LEVEL              ; stuff within the ELSEF is up a level

ELSEF_DONE:
        INC    SI                      ; bump past ELSEF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    ENDIFF_DONE             ; N..don't adjust process level
        DEC    PROCESS_LEVEL           ; Y..we just finished the IF/ELSE
ENDIFF_DONE:
        DEC    NEST_LEVEL              ; ENDIF decrements nest level
        INC    SI                      ; bump past ENDIF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translations may be in the Common or Specific
; Sections.  Search the Specific section first
; then the common section.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    XLATT_DONE              ; N..next command
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE               ; check active section
        JC     XLATT_FOUND             ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE
        JNC    XLATT_DONE
XLATT_FOUND:
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched
        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     XLATT_DONE
        JMP    EXIT                    ; Y..BYE

XLATT_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

TRANSLATE PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the XLATT command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
TP_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     TP_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     TP_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT TP_NEXT_STATE

TP_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to first xlat table
        MOV    XLAT_TAB_PTR,SI         ; start of XLAT tables
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        JMP    SHORT NEXT_XLAT_TAB
TP_DONE:                               ; return here from XLAT
        POP    SI
TP_EXIT:
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check xlate tables for matching scan code
; The xlate table can be in one of two forms:
;    Type 1 = Table contains buffer entries only.
;             Scan code is used as an index into xlat table
;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;             Table must be searched for matching scan.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NEXT_XLAT_TAB:
        MOV    SI,XLAT_TAB_PTR         ; pointer to xlat tables
        CMP    [SI].XLAT_TAB_SIZE,0    ; Q..any more xlat tables?
        JNE    PROCESS_XLAT_TAB        ; Y..check um
        JMP    TP_DONE                 ; N..done
PROCESS_XLAT_TAB:
        MOV    DL,[SI].XLAT_OPTIONS    ; save translate options IN DL
        MOV    BX,[SI].XLAT_TAB_SIZE   ; Y..calc pointer to next xlat tab
        ADD    BX,SI
        MOV    XLAT_TAB_PTR,BX         ; pointer to next xlat tab
        TEST   DL,TYPE_2_TAB           ; Q..is this a type 2 table?
        JZ     TYPE_1_LOOKUP           ; N..go do table lookup
TYPE_2_SEARCH:                         ; Y..search table
        XOR    CH,CH
        MOV    CL,[SI].XLAT_NUM        ; number of xlat entries
        MOV    BX,DEFAULT_TAB_2_ENT_SZ ; default entry size
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JZ     NEXT_TAB_2_ENTRY        ; N..continue
        MOV    BX,ASC_ONLY_TAB_2_ENT_SZ ; Y..set size in BX
NEXT_TAB_2_ENTRY:                      ; entry size is in BX
	jcxz	next_xlat_tab		;   brif last entry
        CMP    AL,[SI].XLAT_SCAN       ; Q..scan match?
        JE     FOUND_TAB_2_ENTRY       ; Y..go create buffer entry
        ADD    SI,BX                   ; point to next entry
        LOOP   NEXT_TAB_2_ENTRY
        JMP    SHORT NEXT_XLAT_TAB
FOUND_TAB_2_ENTRY:                     ; Q..set scan code to 0?
        MOV    AH,AL                   ; default scan code in AH
        MOV    AL,[SI].XLAT_2_BUF_ENTRY ; ASCII code from table in AL
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JNZ    BUFFER_ENTRY_READY      ; Y..buffer entry is ready
        MOV    AH,[SI].XLAT_2_BUF_ENTRY+1 ; N..scan code from table as well
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer

TYPE_1_LOOKUP:
        CMP    AL,[SI].XLAT_SCAN_LO    ; Q..is scan in range of this table?
        JB     NEXT_XLAT_TAB           ; N..next table
        CMP    AL,[SI].XLAT_SCAN_HI    ; Q..is scan in range of this table?
        JA     NEXT_XLAT_TAB           ; N..next table
        SUB    AL,[SI].XLAT_SCAN_LO    ; convert scan code to xlat index
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..ASCII only in xlat ?
        JZ     TWO_BYTE_LOOKUP         ; N..go do 2-byte lookup
        LEA    BX,[SI].XLAT_1_BUF_ENTRY ; Y..do 1-byte lookup
        XLAT   [SI].XLAT_1_BUF_ENTRY   ; ASCII code in AL
        MOV    AH,SCAN_CODE            ; SCAN in AH
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer
TWO_BYTE_LOOKUP:
        MOV    BL,2                    ; multiply scan index
        MUL    BL                      ;  by two
        MOV    BX,AX                   ; real index in BX
        MOV    AX,WORD PTR [SI].XLAT_1_BUF_ENTRY[BX] ; get 2-byte buffer entry
                                       ;  AL=ASCII  AH=SCAN
BUFFER_ENTRY_READY:
        TEST   DL,ZERO_SCAN            ; Q..set scan part to zero?
        JZ     NO_ZERO_SCAN            ; N..
        XOR    AH,AH                   ; scan = 0
NO_ZERO_SCAN:
        CALL   BUFFER_FILL             ; go put entry in buffer
        STC                            ; indicate translation found
        JMP    TP_DONE

TRANSLATE ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    DONE_OPTION             ; N..done
        MOV    AL,[SI]+1               ; mask in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT?
        JNZ    AND_MASK
        OR     OPTION_BYTE,AL          ; N..OR in the mask bits
        JMP    short DONE_OPTION
AND_MASK:
        NOT    AL
        AND    OPTION_BYTE,AL          ; Y..AND out the mask bits
DONE_OPTION:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    RN_DONE                 ; N..don't process
        MOV    NLS_FLAG_1,0
        MOV    NLS_FLAG_2,0
RN_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    BP_DONE                 ; N..don't process
        MOV    BEEP_PENDING,YES        ; set beep pending flag. the beep
                                       ;  will be done just before iret
BP_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    GOTO_DONE               ; N..don't process
        MOV    BL,[SI]                 ; command byte in BL
        AND    BL,NOT COMMAND_BITS     ; remove command code
        OR     BL,BL                   ; Q..goto label?
        JZ     GOTO_LABEL              ; Y..go jump
        CMP    BL,EXIT_INT_9_FLAG      ; Q..SPECIAL - Exit Int 9?
        JNE    NOT_EXIT_INT_9          ; N..
        JMP    EXIT                    ; Y..bye bye
NOT_EXIT_INT_9:
        CMP    BL,EXIT_STATE_LOGIC_FLAG ; Q..SPECIAL - Exit State Logic?
        JNE    NOT_EXIT_S_L            ; N..
        JMP    GOTO_BIOS               ; Y..goto bios
NOT_EXIT_S_L:
        JMP    FATAL_ERROR             ; garbage in that command
GOTO_LABEL:
        ADD    SI,[SI]+1               ; bump by relative offset
        MOV    PROCESS_LEVEL,0         ; reset process and nest level
        MOV    NEST_LEVEL,0
GOTO_DONE:
        ADD    SI,3                    ; bump to next command
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ANDF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    ANDF_DONE               ; N..don't process ANDF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ANDF_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    ANDF_DONE               ; if set then remain in IFF
        JZ     ANDF_NO_MATCH
ANDF_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     ANDF_DONE               ; if clear then remain in IFF
ANDF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        DEC    PROCESS_LEVEL           ; IFF would have inc'd - so dec
ANDF_DONE:
        INC    SI                      ; bump past ANDF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SET_FLAG Command.
; Flag Table must be in the Common Section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SET_FLAG_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    SF_DONE                 ; N..don't process

        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
SF_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     SF_DONE                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     SF_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT SF_NEXT_STATE

SF_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to table
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        MOV    CX,[SI]                 ; number of entries
	jcxz	sf_restore		; done if no entries
        INC    SI                      ; Y..Bump to first entry
        INC    SI
NEXT_SF_ENTRY:
        CMP    AL,[SI]                 ; Q..scan match?
        JE     FOUND_SF_ENTRY          ; Y..go set flag
        ADD    SI,3                    ; point to next entry
        LOOP   NEXT_SF_ENTRY
        JMP    SHORT SF_RESTORE        ; no match found
FOUND_SF_ENTRY:
        MOV    NLS_FLAG_1,0            ; clear all NLS bits
        MOV    NLS_FLAG_2,0
        MOV    BL,[SI]+1               ; flag id in BX
        XOR    BH,BH
        MOV    AL,[SI]+2               ; mask in AL
        OR     FLAGS_TO_TEST[BX],AL    ; set the bit
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched
        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     SF_RESTORE
        POP    SI
        JMP    short EXIT
SF_RESTORE:
        POP    SI
SF_DONE:
        INC    SI                      ; bump past command
        INC    SI
        JMP    NEXT_COMMAND


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fatal Error routine.  Come here when
; we have a critical error such as an
; invalid State Logic Command.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FATAL_ERROR:
        JMP   SHORT EXIT               ; end the int 9 processing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exit point.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EXIT:
        MOV   BUSY_FLAG,NO
        STC                            ; indicate we should end INT 9
        POP   BX                       ;  processing
        POP   AX
        POP   ES
        POP   DS
        RET

KEYB_STATE_PROCESSOR   ENDP



CODE   ENDS
       END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybi2f.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
;
;                                           
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI2F.ASM
; ----------
;
; Description:
; ------------
;	Contains Interrupt 2F handler.
;
; Procedures Contained in This File:
; ----------------------------------
;	KEYB_INT_2F - Interupt 2F handler
;
; Include Files Required:
; -----------------------
;	INCLUDE KEYBEQU.INC
;	INCLUDE KEYBSHAR.INC
;M004	INCLUDE KEYBMAC.INC
;	INCLUDE KEYBCMD.INC
;	INCLUDE KEYBCPSD.INC
;	INCLUDE KEYBI9C.INC
;
; External Procedure References:
; ------------------------------
;	FROM FILE  ????????.ASM:
;		procedure - description????????????????????????????????
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------

	INCLUDE KEYBEQU.INC		
	INCLUDE KEYBSHAR.INC		
;M004	INCLUDE KEYBMAC.INC		
	INCLUDE KEYBCMD.INC		
	INCLUDE KEYBCPSD.INC		
	INCLUDE KEYBI9C.INC		
					
	PUBLIC KEYB_INT_2F		
					
	EXTRN  ERROR_BEEP:NEAR	 
					
CODE	SEGMENT PUBLIC 'CODE'	  
					
	ASSUME  CS:CODE,DS:nothing

; Module: KEYB_INT_2F
;
; Description:
;
; Input Registers:
;	AH = 0ADH
;	AL = 80,81,82,83	; M003
;
; Output Registers:
;	N/A
;
; Logic:
;	IF AH = 0ADh THEN	 (this call is for us)
;	Set carry flag to 0
;	IF AL = 80 THEN
;	  Get major and minor
;	  Get SEG:OFFSET of SHARED_DATA_AREA
;
;	IF AL = 81 THEN
;	  Get FIRST_XLAT_PTR
;	  FOR each table
;		IF code page requested = code page value at pointer THEN
;		Set INVOKED_CODE_PAGE
;		Set ACTIVE_XLAT_PTR
;		EXIT
;		ELSE
;		Get NEXT_SECT_PTR
;	  NEXT table
;	  IF no corresponding code page found THEN
;		Set carry flag
;
;	IF AL = 82 THEN
;	  IF BL = 00 THEN
;		Set COUNTRY_FLAG = 00
;	  ELSE IF BL = 0FFH THEN
;		Set COUNTRY_FLAG = 0FFH
;	  ELSE
;		Set carry flag
;
;	IF AL = 83 THEN              ; M003
;	  Return BL=COUNTRY_FLAG     ; M003
;
;	JMP to previous INT 2FH handler

CP_QUERY	EQU	80H		
CP_INVOKE	EQU	81H		
CP_LANGUAGE	EQU	82H		
CP_QLANGUAGE	EQU	83H		; M003
					
VERSION_MAJOR	EQU	01H		
VERSION_MINOR	EQU	00H		
					
CARRY_FLAG	EQU	01H		 
					
KEYB_INT_2F	PROC			

	cmp	ah,INT_2F_SUB_FUNC	; is it for us?
	jz	our_i2f_interrupt

i2f_chain:

;	Under DOS 5, it is always safe for us to assume that there was
;	  an existing Int2f vector for us to continue to.

	jmp	cs:sd.old_int_2f
					
our_i2f_interrupt:
	push	bp
	mov	bp,sp
	and	word ptr [bp]+6,not carry_flag ; pre-clear carry
	call	do_our_i2f		; pass bp.6 -> flags to functions

	pop	bp
	jmp	i2f_chain

do_our_i2f:
	CMP	AL,CP_QUERY		; Q..query CP?
	JNE	INT_2F_CP_INVOKE	; N..next

	MOV	AX,-1			; Y..process query
	mov	bx,(version_major shl 8) + version_minor
	MOV	DI,OFFSET SD		
	PUSH	CS
	POP	ES			
	ret
					
INT_2F_CP_INVOKE:			
	CMP	AL,CP_INVOKE		; Q..invoke CP?
	JNE	INT_2F_CP_LANGUAGE	; N..next
					
	MOV	SI,cs:SD.FIRST_XLAT_PTR	; Get FIRST_XLAT_PTR
					
INT_2F_NEXT_SECTION:			
	CMP	SI,-1			
	JE	INT_2F_ERROR_FLAG

	cmp	bx,cs:[SI].XS_CP_ID	; is this the code page we want?
	JNE	INT_2F_CP_INVOKE_CONT1

	MOV	cs:SD.ACTIVE_XLAT_PTR,SI ; IF Yes, Set the ACTIVE_XLAT_PTR
	MOV	cs:SD.INVOKED_CP_TABLE,BX ;	record new code page
	ret
					
INT_2F_CP_INVOKE_CONT1:
	MOV	SI,cs:[SI].XS_NEXT_SECT_PTR ; Chain to NEXT_SECT_PTR
	JMP	INT_2F_NEXT_SECTION	;	NEXT_SECTION
					
INT_2F_ERROR_FLAG:			
	mov	ax,1			; ***???  why do we return error code
;					;   only in this case?????
i2f_reterror:
	or	word ptr [bp]+6,carry_flag ; set carry to int2f caller
	ret
					
INT_2F_CP_LANGUAGE:			
	CMP	AL,CP_LANGUAGE		; Q..Set default language??
;M003	jnz	int2f_ret		; don't handle undefined functions
	jnz	INT_2F_CP_QLANG		; go check for query language ;M003
					
;	Now, if BL=0 or 0ffh, we'll set COUNTRY_FLAG to that value.

	inc	bl
	cmp	bl,2			; set carry if bl is legal
	dec	bl			; restore old value, preserve carry
	jnc	i2f_reterror		; done if error

	MOV	cs:COUNTRY_FLAG,BL	;	Set COUNTRY_FLAG to 0 or 0ffh

;	M003 -- added code

	ret


INT_2F_CP_QLANG:
	CMP	AL,CP_QLANGUAGE
	jnz	int2f_ret

	mov	bl,cs:COUNTRY_FLAG

;	M003 -- end added code

int2f_ret:
	ret
KEYB_INT_2F	ENDP			

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybi2f.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                                
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI2F.INC
;; ----------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI2F.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_INT_2F:NEAR      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybi9.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                             
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI9.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_STATE_PROCESSOR:NEAR
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybi9c.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9C.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 External declarations and equates for procedures in file
;;	 KEYBI9C.ASM
;;
;; Change History:
;; ---------------
;; Delete unused externs
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	EXTRN	KEYB_INT_9:NEAR 	;;
	EXTRN	K8:BYTE 		;;
	EXTRN	BUFFER_FILL:NEAR	;;
	EXTRN	COUNTRY_FLAG:BYTE	;;
	EXTRN	BEEP_PENDING:BYTE	;;
	EXTRN	SCAN_CODE:BYTE		;;
	EXTRN	CHK_IBF:NEAR		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\commsubs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                           
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  CONVERT.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    FIND_SYS_TYPE   :NEAR ;;
        EXTRN    FIND_KEYB_TYPE  :NEAR ;;
                                       ;;
        EXTRN    HW_TYPE         :WORD ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybmsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBMSG.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM (KEYB.ASM)
;; ---------------
;;
;; Description:
;; ------------
;;	 External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	EXTRN	 ACT_KEYB_CP :BYTE     ;;
	EXTRN	 ACT_CON_CP  :BYTE     ;;
	EXTRN	 ACT_KEYB    :BYTE     ;;
	EXTRN	 INV_L	     :BYTE     ;;
	EXTRN	 INV_I	     :BYTE     ;;
	EXTRN	 INV_CP      :BYTE     ;;
	EXTRN	 INV_S	     :BYTE     ;;
	EXTRN	 INV_FN      :BYTE     ;;
	EXTRN	 INV_KEYB_Q  :BYTE     ;;
	EXTRN	 INV_CON_Q   :BYTE     ;;
	EXTRN	 NOT_DESIG   :BYTE     ;;
	EXTRN	 NOT_SUPP    :BYTE     ;;
	EXTRN	 NOT_VALID1  :BYTE     ;;
	EXTRN	 NOT_VALID2  :BYTE     ;;
	EXTRN	 WARNING_1   :BYTE     ;;
	EXTRN	 INV_COMBO   :BYTE     ;;
	EXTRN	 CR_LF	     :BYTE     ;;
	EXTRN	 MEMORY_OVERF :BYTE    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\kbmsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
									      ;;

;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;

ACT_KEYB    DB	  'Current keyboard code: ','$'                               ;;
ACT_KEYB_CP DB	  '  code page: ','$'                                         ;;
ACT_CON_CP  DB	  'Current CON code page: ','$'                               ;;
INV_L	    DB	  'Invalid keyboard code specified',10,13,'$'                 ;;
INV_I	    DB	  'Invalid keyboard ID specified',10,13,'$'                 ;;
INV_CP	    DB	  'Invalid code page specified',10,13,'$'                     ;;
INV_S	    DB	  'Invalid syntax',10,13,'$'                                  ;;
INV_FN	    DB	  'Bad or missing Keyboard Definition File',10,13,'$'         ;;
INV_KEYB_Q  DB	  'KEYB has not been installed',10,13,'$'                     ;;
INV_CON_Q   DB	  'Active code page not available from CON device',10,13,'$'  ;;
NOT_DESIG   DB	  'Code page specified has not been prepared',10,13,'$'       ;;
NOT_SUPP    DB	  'One or more CON code pages invalid for given keyboard code',10,13,'$' ;;
NOT_VALID1  DB	  'Code page requested (','$'                                 ;;
NOT_VALID2  DB	  ') is not valid for given keyboard code',10,13,'$'               ;;
WARNING_1   DB	  'Code page specified is inconsistent with the selected code page',10,13,'$'  ;;
INV_COMBO   DB	  'ID code specified is inconsistent with the selected keyboard code',13,'$'  ;;
MEMORY_OVERF DB   'Unable to create KEYB table in resident memory',10,13,'$'  ;;
CR_LF	    DB	  10,13,'$'                                                   ;;
									      ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keyb.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
        PAGE    ,132
        TITLE   MS-DOS 5.0 KEYB Command  -  Root Module

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MS-DOS 5.0 - NLS Support - KEYB Command
;                                                  
;
; File Name:  KEYB.ASM
; ----------
;
;
; Description:
; ------------
;       Contains root module for KEYB command.  This module is the
;       KEYB command entry point.  KEYB is an external command included
;       with MS DOS 5.0 to provide keyboard support for 14 languages.
;       KEYB will jump immediately into the command processing in
;       file KEYBCMD.  All resident code is included before KEYBCMD
;       in the linkage list.
;
;
; Procedures Contained in This File:
; ----------------------------------
;
;
; Include Files Required:
; -----------------------
;       KEYBCMD.INC - External declarations for transient command
;           processing routines
;
; External Procedure References:
; ------------------------------
;       FROM FILE  KEYCMD.ASM:
;            KEYB_COMMAND - Main routine for transient command processing.
;
; Linkage Instructions:
; --------------------
;       Link in .COM format.  Resident code/data is in files KEYB thru
;       KEYBCPSD.
;
;       LINK KEYB+KEYBI9+KEYBI9C+KEYBI2F+KEYBCPSD+KEYBMSG+
;            COMMSUBS+KEYBTBBL+KEYBCMD;
;       EXE2BIN KEYB.EXE KEYB.COM
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


CODE    SEGMENT PUBLIC 'CODE' BYTE

        INCLUDE KEYBCMD.INC            ; Bring in external declarations
                                       ;  for transient command processing
        ASSUME  CS:CODE,DS:CODE
        ORG   100H                     ; required for .COM


START:

        JMP   KEYB_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CODE   ENDS
       END    START

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybi9c.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                              
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;  File Name:  KEYBI9C.ASM
;  ----------
;
;
;  Description:
;  ------------
;	 Interrupt 9 mainline.
;	 This routine handles all US keyboard support for the following
;	 system units:	PC, PC-XT, PC-AT, PC Convertible, PC-XT/286
;			Models 25 and 30 (PALACE),
;			PS/2's - all 8042 based 80286, 80386 and 80486.
;			       - all PATRIOT and SEBRING based systems.
;	 KEYB_STATE_PROCESSOR is called for non-US keyboard support.
;
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;	 KEYB_INT_9 - Interrupt 9
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  KEYBI9.ASM:
;	      KEYB_STATE_PROCESSOR - Non US keyboard support.
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;  ; - DCR 478 -	KEYBOARD INT SPLICING Nick Savage  ;deleted by AN005
;  ; - PTM 3090	ENABLING RIGHT CTL FOR RE-BOOTING
;  ; - PTM 60XX	PICK UP ALL KEYBOARD BIOS PTR's AND DCR's TO BRING
;			INT 9h	UP TO THE TOPHAT (80486) SUPPORT LEVEL. '89  jwg
;	   PTR 6600736	Keep INT's disabled till after PORT 60h read.
;	   PTR 6600756	EXTRA EOI ISSUED IF INTERRUPTS SATURATED **********
;			   NOTE: This is a fix for a BIOS bug that goes all
;			    the way back to the first AT.  The rationale for
;			    the fix is as follows:
;	    (deleted AN005)	A stack frame is created upon entry (BP) and
;				CHK_EOI is called to check the frame. If no
;				EOI has been issued, CHK_EOI does it and
;				resets the frame, preventing any additinal
;				EOI's from being issued on subsequent calls
;				to CHK_EOI.  All direct EOI's in the code
;				have been replaced with calls to CHK_EOI.
;
;  ;Ax004; - PTM 2555	KEYB command locks keyboard. 10/5/89;cja
;			; jwg 11/09/98 Updates - Wild Mouse, etc workaround.....
;  ; - PTM 5802	Restructure Interrupt Splicing to correct lost Mouse
;			interrupt when LED's are updated.  Make it apply to
;			all systems. Essentially remove all code added by AN001.
;			Remove stack frame logic of AN003 and PTR 6600756 and do
;			an early EOI.  Requires a CLI at K38B and other places.
;			Remove Chk_ibf before 60h.
;			Re-write ERROR_BEEP to make processor speed independent
;			for AT and PS/2 systems and right tone if interrupts.
;			Make SHIP_IT handle call on PC machines.
;			Use BP to hold system flags during interrupt processing.
;	   PTR 6602049	Fix problem with Pause Key hanging system if Mouse
;			driver is using polled mode.  (Port 60h hangs.)
;	   PTR 6602247	Change JMP at K40 to stop extra Enable Keyboard cmd.
;	   PTR 6602319	Fix interrupt window on System Request key allowing
;			following scan code(s) to be processed out of sequence.
;	   PTR 6602355	Fix Print Screen clearing E0 state flags too late.
;  ; - ;deleted	Add code the clear "Wild Mouse" condition at PAUSE wait.
;  ; -  PTM 6660	Move determination code for original PC1 to COMMSUBS.ASM
;	   - ;jwg 2/90	Add Patriot/Sebring HOT REPLUG code so keyboard can be
;			switched back to Scan Code Set 1 if repluged.  LIB LITE
;  ; -  PTM 6680	Remove code attempting to re-sync BIOS flags with reset
;			Keyboard.  Test case simulators can/are sending invalid
;			sequence of AA,AA.  Must leave BIOS flags alone on POR.
;  ; -  PTM 6716	MicroSoft WORKS (German version) reentrancy problem with
;	   - ;jwg 3/90	NLS state processor and save scan code.  LED update ACK
;			overlays memory before NLS processing of scan code.
;			Remove AN006 "Wild Mouse" reset code, field tests done.
;  ; -  PTM ????	Fix read ID logic to recognize 122 keyboards and set the
;	     ;jwg 8/90	KBX flag on any enhansed keyboard.
;  ; -  PTM ????	Add 122 Keyboard key support tables.

;	M005 -- Begin Kermit revision merge

;  ;JP9009 - Sep. 1990  DBCS keyboard support
;  ;JP9010 - Oct. 1990  Server password mode support
;  ;JP901024 - Oct. 24th 1990
;                       During setting keyboard scan code table, if mouse is
;                       enabled, the setting command failed. This problem was
;                       produced as follows. Sets server password mode, and
;                       starts the DOS 4.0 with mouse(DOSSHELL starts). And
;                       presses password. At this moment, setting scan code
;                       table and enabling mouse proceed concurrently, and
;                       setting scan code table fails.
;  ;JP901025 - Oct. 25th 1990
;                       Read keyboard ID sometimes failed on 486 machine. Puts
;                       some wait(CPU independent) before reading from port 60h
;                       for 386 or over machines.
;
;	M005 -- end revision merge
;       M007 -- change jump condition so ROM BIOS variables used correctly
;       M008 -- require Ctrl+Alt+F1/2 to toggle keyboard mapping
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	INCLUDE KEYBEQU.INC
	INCLUDE DSEG.INC		; System data segments
	INCLUDE POSTEQU.INC		; System equates
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBI2F.INC
	INCLUDE KEYBI9.INC
	INCLUDE KEYBCPSD.INC
	INCLUDE KEYBCMD.INC

	PUBLIC	KEYB_INT_9
	PUBLIC	K8			; CTRL case tables
	PUBLIC	SCAN_CODE
	PUBLIC	BUFFER_FILL
	PUBLIC	COUNTRY_FLAG
	PUBLIC	BEEP_PENDING
	PUBLIC	ERROR_BEEP
	PUBLIC	CHK_IBF


ID_1		EQU	0ABH		; 1ST ID CHARACTER FOR KBX
TID_2		EQU	041H		; US G-LAYOUT
TID_2A		EQU	054H		; US P-LAYOUT

;UNTRANSLATED 2ND ID CHAR FOR KBDX
ID_2U		EQU	083H		; US G-LAYOUT (PATRIOT)
ID_2AU		EQU	084H		; US P-LAYOUT (PATRIOT)
ID_122		EQU	086H		; 2ND ID CHARACTER FOR 122-KEYBOARD
ID_2JG		EQU	090H		; JPN G-LAYOUT
ID_2JP		EQU	091H		; JPN P-LAYOUT
ID_2JA		EQU	092H		; JPN A-LAYOUT


DIAGS	SEGMENT AT 0FFFFH
	ORG	0
RESET	LABEL	FAR
DIAGS	ENDS


CODE	SEGMENT PUBLIC 'CODE'
	ASSUME	CS:CODE,DS:DATA


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   TABLE OF SHIFT KEYS AND MASK VALUES
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;------ KEY_TABLE
K6	LABEL	BYTE
	DB	INS_KEY 		; INSERT KEY
	DB	CAPS_KEY,NUM_KEY,SCROLL_KEY,ALT_KEY,CTL_KEY
	DB	LEFT_KEY,RIGHT_KEY
K6L	EQU	$-K6

;------ MASK_TABLE
K7	LABEL	BYTE
	DB	INS_SHIFT		; INSERT MODE SHIFT
	DB	CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT,ALT_SHIFT,CTL_SHIFT
	DB	LEFT_SHIFT,RIGHT_SHIFT

;----------  TABLES FOR ALT CASE  -----
;------ ALT-INPUT-TABLE
K30	LABEL	BYTE
	DB	82,79,80,81,75
	DB	76,77,71,72,73		; 10 NUMBERS ON KEYPAD
;------ SUPER-SHIFT-TABLE
	DB	16,17,18,19,20,21	; A-Z TYPEWRITER CHARS
	DB	22,23,24,25,30,31
	DB	32,33,34,35,36,37
	DB	38,44,45,46,47,48
	DB	49,50
K30_LEN 	EQU	$-K30-10

;------ ALT-INPUT-FUNCTION-TABLE   53H - 7EH
K30A	LABEL	BYTE
	DB	-1,-1,-1,-1,139,140	; Del, SysReq, Undef, WT, F11, F12
	DB	-1,235,218,219,220	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	221,222,223,226,227	; F16, F17, F18, F19, F20,
	DB	228,229,230,231 	; F21, F22, F23, F24,
	DB	-1,243,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,253			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef

H_LAST_SCAN	EQU	$-K30A+52h	; Largest valid scan code in table
					;  K30A K8 K15 K14 must have same ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  K8 is overlaid by K8_RPL (from module KEYB_COMMAND)
;  if extended INT 16 support is available
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

K8	LABEL	BYTE			;-------- CHARACTERS ---------
	DB	27,-1,00,-1,-1,-1	; Esc, 1, 2, 3, 4, 5
	DB	30,-1,-1,-1,-1,31	; 6, 7, 8, 9, 0, -
	DB	-1,127,-1,17,23,5	; =, Bksp, Tab, Q, W, E
	DB	18,20,25,21,09,15	; R, T, Y, U, I, O
	DB	16,27,29,10,-1,01	; P, [, ], Enter, Ctrl, A
	DB	19,04,06,07,08,10	; S, D, F, G, H, J
	DB	11,12,-1,-1,-1,-1	; K, L, ;, ', `, LShift
	DB	28,26,24,03,22,02	; \, Z, X, C, V, B
	DB	14,13,-1,-1,-1,-1	; N, M, ,, ., /, RShift
	DB	'*',-1,' ',-1           ; *, Alt, Space, CL
					;--------- FUNCTIONS ---------
	DB	94,95,96,97,98,99	; F1 - F6
	DB	100,101,102,103,-1,-1	; F7 - F10, NL, SL
	DB	119,-1,132,-1,115,-1	; Home, Up, PgUp, -, Left, Pad5
	DB	116,-1,117,-1,118,-1	; Right, +, End, Down, PgDn, Ins
	DB	-1,-1,-1,-1,137,138	; Del, SysReq, Undef, WT, F11, F12
					;---------- 122 KEYBOARD not overlaid
	DB	-1,234,206,207,208	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	209,210,211,212,213	; F16, F17, F18, F19, F20,
	DB	214,215,216,217 	; F21, F22, F23, F24,
	DB	-1,242,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,252			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef

;-----	TABLES FOR LOWER CASE (USA)  --

K10	LABEL	BYTE
	DB	27,'12345'
	DB	'67890-'
	DB	'=',08,09,'qwe'
	DB	'rtyuio'
	DB	'p[]',0DH,-1,'a'        ; LETTERS, Return, Ctrl
	DB	'sdfghj'
	DB	"kl;'`",-1              ; LETTERS, L Shift
	DB	'\zxcvb'
	DB	'nm,./'
	DB	-1,'*',-1,' \'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ LC TABLE SCAN
	DB	59,60,61,62,63		; BASE STATE OF F1 - F10
	DB	64,65,66,67,68
	DB	-1,-1			; NL, SL

;------ KEYPAD TABLE
K15	LABEL	BYTE
	DB	71,72,73,-1,75,-1	; Home, Up, PgUp, -1, Left, -1
	DB	77,-1,79,80,81,82	; Right, -1, End, Down, PgDn, Ins
	DB	83			; Del
	DB	-1,-1,'\',133,134       ; SysRq, Undef, WT, F11, F12
	DB	-1,232,182,183,184	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	185,186,187,188,189	; F16, F17, F18, F19, F20,
	DB	190,191,192,193 	; F21, F22, F23, F24,
	DB	-1,240,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef

;-------  TABLES FOR UPPER CASE (USA)

K11	LABEL	BYTE
	DB	27,'!@#$%'
	DB	'^&*()_'
	DB	'+',08,00,'QWE'
	DB	'RTYUIO'
	DB	'P{}',0DH,-1,'A'        ; LETTERS, Return, Ctrl
	DB	'SDFGHJ'
	DB	'KL:"~',-1              ; LETTERS, L Shift
	DB	'|ZXCVB'
	DB	'NM<>?'
	DB	-1,'*',-1,' |'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ UC TABLE SCAN
K12	LABEL	BYTE
	DB	84,85,86,87,88		; SHIFTED STATE OF F1 - F10
	DB	89,90,91,92,93
	DB	-1,-1			; NL, SL

;------ NUM STATE TABLE
K14	LABEL	BYTE
	DB	'789-456+1230.'         ; NUMLOCK STATE OF KEYPAD KEYS
	DB	-1,-1,'|',135,136       ; SysRq, Undef, WT, F11, F12
	DB	-1,233,194,195,196	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	197,198,199,200,201	; F16, F17, F18, F19, F20,
	DB	202,203,204,205 	; F21, F22, F23, F24,
	DB	-1,241,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef
PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: KEYB_INT_9
;
;  Description:
;      Entry point for interrupt 9 processing.
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		EVEN			; Keep KEYB_INT_9 entry on even boundry
BEEP_PENDING	DB	NO		; YES if a beep is needed
SCAN_CODE	DB	0		; Last SCAN code read

KEYB_INT_9	PROC   NEAR
					; THIS JUMP AND ENSUING BYTE MUST BE
	JMP	short KB_INT_1		; HERE TO BE COMPATIBLE WITH APL.
					; APL WILL FORCE THIS BYTE TO BE ZERO,
					; ONLY BECAUSE IT'S 3 BYTES  AWAY FROM
COUNTRY_FLAG	DB	-1		; WHERE THE INT9 VECTOR POINTS

KB_INT_1:				; Do NOT enable interrupts untill after
					;  PORT 60h has been read.  INT 15h has
					;  interrupt window, do EOI, fast pass.
	PUSH	BP			; Reserved in KEYBi9c for SD.SYSTEM_FLAG
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI
	PUSH	DS
	PUSH	ES
	CLD				; FORWARD DIRECTION
	MOV	BX,DATA 		; SET UP ADDRESSING
	MOV	DS,BX			; DS POINTS AT THE ROM BIOS DATA AREA
	MOV	BP,CS:SD.SYSTEM_FLAG	; GET CS:SD.SYSTEM_FLAG, AND USE BP



;/* --	WAIT TILL KEYBOARD DISABLE COMMAND CAN BE ACCEPTED
	MOV	AL,DIS_KBD		; DISABLE THE KEYBOARD COMMAND
	CALL	SHIP_IT 		; EXECUTE DISABLE

;	M005 -- Begin additions

        TEST    BP, PC_386              ; 386 OR OVER?                 ;JP901025
        JZ      KB_INT_00_2             ; IF NOT, CONTINUE             ;JP901025
        CALL    CHK_IBF                 ; PUT SOME WAIT FOR HIGH SPEED ;JP901025
KB_INT_00_2:                            ; MACHINES                     ;JP901025

;	M005 -- End additions


	IN	AL,PORT_A		; READ IN THE CHARACTER
					; ENABLE INTERRUPTS moved from top P768

;/* --	SYSTEM HOOK  INT 15H - FUNCTION 4FH  (ON HARDWARE INTERRUPT LEVEL 9H)

	MOV	AH,04FH 		; SYSTEM INTERCEPT - KEY CODE FUNCTION
	STC				; SET CY= 1 (IN CASE OF IRET)
	INT	15H			; CASSETTE CALL   (AL)= KEY SCAN CODE
					;  RETURNS CY= 1 FOR INVALID FUNCTION
					; EARLY  EOI for all interrupts done
					;  after INT 15h to prevent re-entrancy
	XCHG	BX,AX			; SAVE SCAN CODE
	MOV	AL,EOI			; END OF INTERRUPT COMMAND (EARLY EOI)
	OUT	INTA00,AL		; SEND EOI TO INTERRUPT CONTROL PORT
	XCHG	BX,AX			; RECOVER SCAN CODE

	JC	KB_INT_02		; CONTINUE IF CARRY FLAG SET ((AL)=CODE)
	JMP	K26			; EXIT IF SYSTEM HANDLED SCAN CODE
					;  EXIT HANDLES ENABLE

;/* --- CHECK FOR A POSSIBLE HOT REPLUG AND A POR COMPLETE CODE

KB_INT_02:				;	(AL)= SCAN CODE
					;	CHECK FOR POR

;	M005 -- Begin additions

        TEST    BP, SECURITY_ACTIVE     ; SERVER PASSWORD MODE JUST EXITED?    ;JP9010
        JZ      KB_INT_02_00            ; GO IF NOT                            ;JP9010
         AND     BP, NOT SECURITY_ACTIVE; NEVER COMES HERE!                    ;JP9010
         MOV     CS:SD.SYSTEM_FLAG, BP  ; REFLECT IT TO SYSTEM_FLAG            ;JP9010
         JMP     SHORT KB_INT_02_01     ;                                      ;JP9010
KB_INT_02_00:                           ;                                      ;JP9010

;	M005 -- End additions

	CMP	AL,KB_OK		; CHECK FOR POSSIBLE KEYBOARD POR CHAR
	JNE	KB_INT_03		; CONTINUE NOT A POR OF AA
					;	CHECK FOR ENHANSED KEYB
	TEST	KB_FLAG_3,LC_E0		; WAS E0h LAST SCAN CODE?    DCR467
	JNZ	KB_INT_03		; SKIP KB POR IF IT WAS
					;	CHECK FOR LEFT SHIFT BREAK
	TEST	KB_FLAG,LEFT_SHIFT	; IS LEFT SHIFT ACTIVE?
	JNZ	KB_INT_03		; SKIP KB POR IF IT WAS
					;	KEYBOARD POWER ON DETECTED
	MOV	CS:BEEP_PENDING,YES	; INDICATE WE NEED A BEEP
KB_INT_02_01:			; M005 ;JP9010
	MOV	KB_FLAG_2,0		; CLEAR ALL LED FLAGS TO FORCE UPDATE
					; LEAVE OTHERS SO KB SIMULATORS WORK

;	M005 -- Begin additions

        TEST    CS:SD.KEYB_TYPE, DBCS_OLD_KB                                   ;JP9009
        JZ      KB_INT_02_1             ; If, DBCS old keyboard is attached,   ;JP9009
          JMP     SHORT KB_INT_02_2     ;   always set scan code table.        ;JP9009
                                        ;                                      ;JP9009
        PUBLIC  SCAN_CODE_SET           ; This is the default scan code set.   ;JP9009
SCAN_CODE_SET   DB      01              ; In case of old DBCS keyboards, this  ;JP9009
                                        ;  may be 81h or 82h.                  ;JP9009
KB_INT_02_1:                            ;                                      ;JP9009

;	M005 -- End additions

	TEST	BP,PS_8042		; SYSTEM USING 8042 & SCAN CODE SET 01?
	JZ	KB_INT_03		; SKIP IF SYSTEM USES DEFAULT SCS 02
					;	PATRIOT/SEBRING 8042 GATE ARRAY

;	M005 -- Begin additions

KB_INT_02_2:                            ;                                      ;JP9009
        PUSH    AX                      ; SAVE SCAN CODE                       ;JP9010
        MOV     AL, DISABLE_AUX         ; DISABLE AUX DEVICE WHILE CHANGING    ;JP901024
        CALL    SHIP_IT                 ; SCAN CODE TABLE                      ;JP901024

;	M005 -- End additions

	MOV	AL,SCAN_CODE_CMD	; SELECT SCAN CODE SET COMMAND
	CALL	SND_DATA		; SEND IT DIRECTLY TO THE KEYBOARD

;	M005 -- Begin changes

;JP9009 MOV     AL,01h                  ; SELECT SCAN CODE SET 01
        MOV     AL, CS:SCAN_CODE_SET    ; GET SCAN CODE SET                    ;JP9009
        CALL    SND_DATA                ; SEND IT TO THE KEYBOARD
        MOV     AL, ENABLE_AUX          ; DISABLE AUX DEVICE WHILE CHANGING    ;JP901024
        CALL    SHIP_IT                 ; SCAN CODE TABLE                      ;JP901024
;JP9010 MOV     AL,KB_OK                ; RESTORE POR SCAN CODE IN (AL)
        POP     AX                      ; RESTORE SCAN CODE                    ;JP9010


;	M005 -- End changes

KB_INT_03:

;/* --- CHECK FOR A RESEND COMMAND TO KEYBOARD

	STI				; ENABLE INTERRUPTS AGAIN
	CMP	AL,KB_RESEND		; IS THE INPUT A RESEND
	JE	KB_INT_4		; GO IF RESEND

;/* --- CHECK FOR RESPONSE TO A COMMAND TO KEYBOARD

	CMP	AL,KB_ACK		; IS THE INPUT AN ACKNOWLEDGE
	JNZ	KB_INT_2		; GO IF NOT

;/* --- A COMMAND TO THE KEYBOARD WAS ISSUED

	CLI				; DISABLE INTERRUPTS
	OR	KB_FLAG_2,KB_FA	; INDICATE ACK RECEIVED
	JMP	K26			; RETURN IF NOT (ACK RETURNED FOR DATA)

;/* --- RESEND THE LAST BYTE

KB_INT_4:
	CLI				; DISABLE INTERRUPTS
	OR	KB_FLAG_2,KB_FE	; INDICATE RESEND RECEIVED
	JMP	K26			; RETURN IF NOT (ACK RETURNED FOR DATA)


;/* --- UPDATE MODE INDICATORS IF CHANGE IN STATE

KB_INT_2:
	PUSH	AX			; SAVE DATA IN
	CALL	MAKE_LED		; GO GET MODE INDICATOR DATA BYTE
	MOV	BL, KB_FLAG_2		; GET PREVIOUS BITS
	XOR	BL,AL			; SEE IF ANY DIFFERENT
	AND	BL,KB_LEDS		; ISOLATE INDICATOR BITS
	JZ	UP0			; IF NO CHANGE BYPASS UPDATE
	CALL	SND_LED 		; GO TURN ON MODE INDICATORS
UP0:	POP	AX			; RESTORE DATA IN

;---------------------------------------------------------------------
;	      START OF KEY PROCESSING				     -
;---------------------------------------------------------------------

	MOV	AH,AL			; SAVE SCAN CODE IN AH ALSO
					; END OF RE-ENTRANT CODE PATHS
	MOV	CS:SCAN_CODE,AL 	; SAVE SCAN CODE TO BE PROCESSED BY KEYB

;------ TEST FOR OVERRUN SCAN CODE FROM KEYBOARD

	CMP	AL,KB_OVER_RUN		; IS THIS AN OVERRUN CHAR?
	JNZ	K16			; NO, TEST FOR SHIFT KEY

	MOV	CS:BEEP_PENDING,YES
	JMP	K26			; BUFFER_FULL_BEEP, EXIT

K16:

	PUSH	CS
	POP	ES			; ESTABLISH ADDRESS OF TABLES
	MOV	BH, KB_FLAG_3		; LOAD FLAGS FOR TESTING

;------ TEST TO SEE IF A READ_ID IS IN PROGRESS

	TEST	BH,RD_ID+LC_AB		; ARE WE DOING A READ ID?
	JZ	NOT_ID			; CONTINUE IF NOT
	JNS	TST_ID_2		; IS THE RD_ID FLAG ON?
	CMP	AL,ID_1 		; IS THIS THE 1ST ID CHARACTER?
	JNE	RST_RD_ID
	OR	KB_FLAG_3,LC_AB	; INDICATE 1ST ID WAS OK
RST_RD_ID:
	AND	KB_FLAG_3,NOT RD_ID	; RESET THE READ ID FLAG
	JMP	SHORT ID_EX		; AND EXIT


;------ CHECK 2ND US KBD ID - FOR SETTING NUM LOCK ON
TST_ID_2:
	AND	KB_FLAG_3,NOT LC_AB	; RESET FLAG

;	M005 -- Kermit merge changes
;
;		Note:  IBM's code diverged rather significantly from
;			Microsoft's here.  Mostly, theirs was adopted.
;			The primary differences are:
;
;			IBM recognized the ID_2JP keyboard type
;			MS  recognized the ID_122 type
;			IBM explicitly checked for all of the known
;			    extended keyboards and did NOT set the
;			    extended bit if it didn't recognize the code.
;			IBM hooks into the DBCS support routines

;M005		OR	KB_FLAG_3,KBX		; INDICATE ENHANCED KEYBOARD WAS FOUND
;M005		CMP	AL,TID_2		; IS THIS US G-LAYOUT KBD  w 8042
;M005		JE	NUM_LOCK_000		;  JUMP IF SO
;M005		CMP	AL,ID_2U		; IS THIS US G-LAYOUT KBD  w/o 8042
;M005		JE	NUM_LOCK_000		;  JUMP IF SO
;M005		CMP	AL,ID_122		; IS THIS THE 122 KEY ENHANCED KEYBOARD
;M005		JE	NUM_LOCK_000		;  JUMP IF SO
;M005	
;M005	;------ CHECK 2ND JAPANESE KBD ID	;DCR355
;M005	
;M005		CMP	AL,ID_2JG		; IS THIS JPN KBD - G ?
;M005		JE	NUM_LOCK_000		; JUMP IF SO
;M005		CMP	AL,ID_2JA		; IS THIS JPN KBD - A ?
;M005		JNE	ID_EX			; EXIT IF NUM LOCK NOT REQUIRED
;M005						;  These ID's do not set NUM LOCK ON
;M005						;  ID_2AU = US P-LAYOUT KBD  w/o 8042
;M005						;  TID_2A = US P-LAYOUT KBD  w 8042
;M005						;  ID_2JP = JPN KBD - P
;M005	
;M005	;------ A READ ID SAID THAT IT WAS ENHANCED KEYBOARD
;M005	
;M005	NUM_LOCK_000:
;M005		TEST	BH,SET_NUM_LK		; SHOULD WE SET NUM LOCK?
;M005		JZ	ID_EX			; EXIT IF NOT
;M005		OR	KB_FLAG,NUM_STATE	; FORCE NUM LOCK ON
;M005		CALL	SND_LED 		; GO SET THE NUM LOCK INDICATOR
;M005	ID_EX:
;M005		JMP	K26			; EXIT
;M005	PAGE
;M005	NOT_ID:

;	Begin IBM's slightly modified code

        CMP     AL,TID_2A               ; IS THIS US P-LAYOUT KBD  w 8042
        JE      KX_BIT                  ;  JUMP IF SO
        CMP     AL,TID_2                ; IS THIS US G-LAYOUT KBD  w 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_2AU               ; IS THIS US P-LAYOUT KBD  w/o 8042
        JE      KX_BIT                  ;  JUMP IF SO
        CMP     AL,ID_2U                ; IS THIS US G-LAYOUT KBD  w/o 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
	CMP	AL,ID_122	; M005	; 122 keyboard from MS merge
	JE	NUM_LOCK_000

;------ CHECK 2ND JAPANESE KBD ID       ;DCR355
        CMP     AL,ID_2JP               ;  IS THIS JPN KBD - P ?
        JE      KX_BIT                  ;  JUMP IF SO
        CMP     AL,ID_2JG               ;  IS THIS JPN KBD - G ?
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_2JA               ;  IS THIS JPN KBD - A ?
        JNE     ID_EX                   ;  LEAVE IF NOT

;------ A READ ID SAID THAT IT WAS ENHANCED KEYBOARD

NUM_LOCK_000:                           ; 4/7/87 A.OSADA
        TEST    BH,SET_NUM_LK           ; SHOULD WE SET NUM LOCK?
        JZ      KX_BIT                  ; EXIT IF NOT
        OR       KB_FLAG,NUM_STATE      ; FORCE NUM LOCK ON
        CALL    SND_LED                 ; GO SET THE NUM LOCK INDICATOR
KX_BIT: OR       KB_FLAG_3,KBX          ; INDICATE ENHANCED KEYBOARD WAS FOUND
ID_EX:  JMP     K26                     ; EXIT
PAGE
NOT_ID:
        mov     bl, KB_FLAG                                             ;JP9009
        call    DBCS_keyboard_support                                   ;JP9009

;	M005 -- End changes

	CMP	AL,MC_E0		; IS THIS THE GENERAL MARKER CODE?
	JNE	TEST_E1
	OR	KB_FLAG_3,LC_E0+KBX	; SET FLAG BIT, SET KBX, AND
	JMP	SHORT EXIT		; THROW AWAY THIS CODE

TEST_E1:
	CMP	AL,MC_E1		; IS THIS THE PAUSE KEY?
	JNE	NOT_HC
	OR	KB_FLAG_3,LC_E1+KBX	; SET FLAG, PAUSE KEY MARKER CODE
EXIT:	JMP	K26A			; THROW AWAY THIS CODE

NOT_HC:
	AND	AL,07FH 		; TURN OFF THE BREAK BIT
	TEST	BH,LC_E0		; LAST CODE THE E0 MARKER CODE?
	JZ	NOT_LC_E0		; JUMP IF NOT

	MOV	CX,2			; LENGTH OF SEARCH
	MOV	DI,OFFSET K6+6		; IS THIS A SHIFT KEY?
	REPNE	SCASB			; CHECK IT
	JNE	K16A			; NO, CONTINUE KEY PROCESSING
	JMP	SHORT K16B		; YES, THROW AWAY & RESET FLAG

NOT_LC_E0:
	TEST	BH,LC_E1		; LAST CODE THE E1 MARKER CODE?
	JZ	T_SYS_KEY		; JUMP IF NOT

	MOV	CX,4			; LENGTH OF SEARCH
	MOV	DI,OFFSET K6+4		; IS THIS AN ALT, CTL, OR SHIFT?
	REPNE	SCASB			; CHECK IT
	JE	EXIT			; THROW AWAY IF SO

	CMP	AL,NUM_KEY		; IS IT THE PAUSE KEY?
	JNE	K16B			; NO, THROW AWAY & RESET FLAG
	TEST	AH,80H			; YES, IS IT THE BREAK OF THE KEY?
	JNZ	K16B			;  YES, THROW THIS AWAY, TOO
	TEST	KB_FLAG_1,HOLD_STATE	;  NO, ARE WE PAUSED ALREADY?
	JNZ	K16B			;      YES, THROW AWAY
	JMP	K39P			;  NO, THIS IS THE REAL PAUSE STATE
PAGE
;------ TEST FOR SYSTEM KEY

T_SYS_KEY:
	CMP	AL,SYS_KEY		; IS IT THE SYSTEM KEY?
	JNE	K16A			; CONTINUE IF NOT

	TEST	AH,080H 		; CHECK IF THIS A BREAK CODE
	CLI				; DISABLE INTERRUPTS	 PTR 6602319
	JNZ	K16C			; DON'T TOUCH SYSTEM INDICATOR IF TRUE

	TEST	KB_FLAG_1,SYS_SHIFT	; SEE IF IN SYSTEM KEY HELD DOWN
	JNZ	K16B			; IF YES, DON'T PROCESS SYSTEM INDICATOR

	OR	KB_FLAG_1,SYS_SHIFT	; INDICATE SYSTEM KEY DEPRESSED

	MOV	AL,ENA_KBD		; INSURE KEYBOARD IS ENABLED
	CALL	SHIP_IT 		; EXECUTE ENABLE
	MOV	AX,08500H		; FUNCTION VALUE FOR MAKE OF SYSTEM KEY
	INT	15H			; USER INTERRUPT
	JMP	K27A			; END PROCESSING

K16B:	JMP	K26			; IGNORE SYSTEM KEY

K16C:	AND	KB_FLAG_1,NOT SYS_SHIFT; TURN OFF SHIFT KEY HELD DOWN

	MOV	AL,ENA_KBD		; INSURE KEYBOARD IS ENABLED
	CALL	SHIP_IT 		; EXECUTE ENABLE
	MOV	AX,08501H		; FUNCTION VALUE FOR BREAK OF SYSTEM KEY
	INT	15H			; USER INTERRUPT
	JMP	K27A			; IGNORE SYSTEM KEY
PAGE
;------ TEST FOR SHIFT KEYS
;
; HERE IS WHERE KB_FLAGS ARE SET.  WHAT HAPPENS IS, THE SYSTEM SEARCHES TABLE
; 'K6' FOR THE KEY.  IF FOUND, IT GETS THE APPROPRIATE BIT FROM TABLE 'K7'
; AND SETS IT ON. (TABLES ARE ALL AT THE TOP OF THIS ROUTINE)  FLAGS FOR THE
; SECOND ALT AND CTRL ARE SET IN KB_FLAG_3 AND HAVE THE SAME BIT POSITIONS AS
; THEIR ORIGINAL COUNTERPARTS IN KB_FLAG

K16A:	MOV	BL, KB_FLAG		; PUT STATE FLAGS IN BL
	MOV	DI,OFFSET K6		; SHIFT KEY TABLE
	MOV	CX,K6L  		; LENGTH
	REPNE	SCASB			; LOOK THROUGH THE TABLE FOR A MATCH
	MOV	AL,AH			; RECOVER SCAN CODE
	JE	K17			; JUMP IF MATCH FOUND
	JMP	K25			; IF NO MATCH, THEN SHIFT NOT FOUND

;------ SHIFT KEY FOUND

K17:	SUB	DI,OFFSET K6+1		; ADJUST PTR TO SCAN CODE MTCH
	MOV	AH,CS:K7[DI]		; GET MASK INTO AH
	MOV	CL,2			; SET UP COUNT FOR FLAG SHIFTS
	TEST	AL,80H			; TEST FOR BREAK KEY
	JZ	K17C
	JMP	K23			; JUMP IF BREAK

;------ SHIFT MAKE FOUND, DETERMINE SET OR TOGGLE

K17C:	CMP	AH,SCROLL_SHIFT
	JAE	K18			; IF SCROLL SHIFT OR ABOVE, TOGGLE KEY

;------ PLAIN SHIFT KEY, SET SHIFT ON

	CMP	COUNTRY_FLAG,0FFh	; ARE WE IN FOREIGN LANG MODE?
	JNE	K17C1			;  NO, US MODE, JUMP
	CMP	AL,ALT_KEY		; IS THIS THE ALT KEY?
	JNE	K17C1			;  NO, NORMAL KEY
					;**CNS

K17C1:	OR	KB_FLAG,AH		; TURN ON SHIFT BIT
K17C2:	TEST	AH,CTL_SHIFT+ALT_SHIFT	; IS IT ALT OR CTRL?
	JZ	K17F			;  NO, JUMP
K17D:	TEST	BH,LC_E0		; IS THIS ONE OF THE NEW KEYS?
	JZ	K17E			;  NO, JUMP
	OR	KB_FLAG_3,AH		; SET BITS FOR RIGHT CTRL, ALT
	JMP	K26			; INTERRUPT_RETURN
K17E:	SHR	AH,CL			; MOVE FLAG BITS TWO POSITIONS
	OR	KB_FLAG_1,AH		; SET BITS FOR LEFT CTRL, ALT
	JMP	K26			; INTERRUPT RETURN

K17F:
	TEST	CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
	JZ	K17G			; N..all done
	CMP	COUNTRY_FLAG,0FFh	; ARE WE IN LANG MODE?
	JNE	K17G			;  NO, ALL DONE WITH SHIFT KEY

;------ If keyboard is P12 then we still need to release caps_lk

	TEST	BP,PC_LAP		;  IS THIS A P12 KEYBOARD?
	JNZ	REMOVE_CAPS_SHIFT

	TEST	BH,KBX			; THIS THE ENHANCED KEYBOARD?
	JZ	K17G			;  NO, ALL DONE WITH SHIFT KEY
REMOVE_CAPS_SHIFT:
	AND	KB_FLAG,NOT CAPS_SHIFT ;  YES, TAKE KB OUT OF C_L STATE
	CALL	SND_LED 		;   AND UPDATE THE LED INDICATORS
K17G:	JMP	K26			;  RETURN

;------ TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT

K18:					; SHIFT-TOGGLE
	TEST	BL,CTL_SHIFT		; CHECK CTL SHIFT STATE
	JZ	K18A			; JUMP IF NOT CTL STATE
	JMP	K25			; JUMP IF CTL STATE
K18A:	CMP	AL,INS_KEY		; CHECK FOR INSERT KEY
	JNE	K22			; JUMP IF NOT INSERT KEY
	TEST	BL,ALT_SHIFT		; CHECK FOR ALTERNATE SHIFT
	JZ	K18B			; JUMP IF NOT ALTERNATE SHIFT
	JMP	K25			; JUMP IF ALTERNATE SHIFT
K18B:	TEST	BH,LC_E0		; IS THIS THE NEW INSERT KEY?
	JNZ	K22			; YES, THIS ONE'S NEVER A "0"
K19:	TEST	BL,NUM_STATE		; CHECK FOR BASE STATE
	JNZ	K21			; JUMP IF NUM LOCK IS ON
	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ; TEST FOR SHIFT STATE
	JZ	K22			   ; JUMP IF BASE STATE
K20:	MOV	AH,AL			; PUT SCAN CODE BACK IN AH
	JMP	K25			; NUMERAL "0", STNDRD. PROCESSING

K21:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ; MIGHT BE NUMERIC
	JZ	K20			   ; IS NUMERIC, STD. PROC.

K22:					; SHIFT TOGGLE KEY HIT; PROCESS IT
	TEST	AH, KB_FLAG_1		; IS KEY ALREADY DEPRESSED?
	JZ	K22A
	JMP	K26			; JUMP IF KEY ALREADY DEPRESSED
K22A:	OR	KB_FLAG_1,AH		; INDICATE THAT THE KEY IS DEPRESSED
	XOR	KB_FLAG,AH		; TOGGLE THE SHIFT STATE

	TEST	CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
	JZ	K22C			; N..all done

;------ If keyboard is P12 then we do not toggle

	TEST	BP,PC_LAP		;  IS THIS A P12 KEYBOARD?
	JNZ	LAP_SO_DONT_TOGGLE

	TEST	BH,KBX			; THIS THE ENHANCED KEYBOARD?
	JZ	K22C			;  NO, ALL DONE WITH TOGGLE KEYS

LAP_SO_DONT_TOGGLE:
	CMP	CS:COUNTRY_FLAG,0FFh	; ARE WE IN FOREIGN LANG MODE?
	JNE	K22C			;  NO, NO SPECIAL STUFF FOR U.S.
	TEST	AH,CAPS_SHIFT		; IS IT THE CAPS_LOCK KEY?
	JZ	K22C			;  NO, NOTHING ELSE TO DO
	OR	KB_FLAG,AH		;  YES, SET CAPS_LOCK (NOT TOGGLE)

K22C:

;------ TOGGLE LED IF CAPS, NUM, OR SCROLL KEY DEPRESSED

	TEST	AH,CAPS_SHIFT+NUM_SHIFT+SCROLL_SHIFT ; SHIFT TOGGLE?
	JZ	K22B			; GO IF NOT
	PUSH	AX			; SAVE SCAN CODE AND SHIFT MASK
	CALL	SND_LED 		; GO TURN MODE INDICATORS ON
	POP	AX			; RESTORE SCAN CODE

K22B:	CMP	AL,INS_KEY		; TEST FOR 1ST MAKE OF INSERT KEY
	JNE	K26			; JUMP IF NOT INSERT KEY
	MOV	AH,AL			; SCAN CODE IN BOTH HALVES OF AX
	JMP	K28			; FLAGS UPDATED, PROC. FOR BUFFER

;------ BREAK SHIFT FOUND

K23:					; BREAK-SHIFT-FOUND
	CMP	AH,SCROLL_SHIFT 	; IS THIS A TOGGLE KEY?
	NOT	AH			; INVERT MASK
	JAE	K24			; YES, HANDLE BREAK TOGGLE
	AND	KB_FLAG,AH		; TURN OFF SHIFT BIT
	CMP	AH,NOT CTL_SHIFT	; IS THIS ALT OR CTL?
	JA	K23D			;  NO, ALL DONE

	TEST	BH,LC_E0		; 2ND ALT OR CTL?
	JZ	K23A			; NO, HANDLE NORMALLY
	AND	KB_FLAG_3,AH		; RESET BIT FOR RIGHT ALT OR CTL
	JMP	SHORT K23B		; CONTINUE
K23A:	SAR	AH,CL			; MOVE THE MASK BIT TWO POSITIONS
	AND	KB_FLAG_1,AH		; RESET BIT FOR LEFT ALT OR CTL
K23B:	MOV	AH,AL			; SAVE SCAN CODE
	MOV	AL, KB_FLAG_3		; GET RIGHT ALT & CTRL FLAGS
	CMP	COUNTRY_FLAG,0FFH	; ARE WE IN LANGUAGE MODE?
	JNE	K23C			;  NO, LEAVE RIGHT FLAGS AS IS
;**CNS
	AND	AL,NOT GRAPH_ON 	;  YES, FILTER OUT THE ALT_GR KEY
;**CNS
K23C:	SHR	AL,CL			; MOVE TO BITS 1 & 0
	OR	AL, KB_FLAG_1		; PUT IN LEFT ALT & CTL FLAGS
	SHL	AL,CL			; MOVE BACK TO BITS 3 & 2
	AND	AL,ALT_SHIFT+CTL_SHIFT	; FILTER OUT OTHER GARBAGE
	OR	KB_FLAG,AL		; PUT RESULT IN THE REAL FLAGS
	MOV	AL,AH			; RECOVER SAVED SCAN CODE

K23D:	CMP	AL,ALT_KEY+80H		; IS THIS ALTERNATE SHIFT RELEASE
	JNE	K26			; INTERRUPT_RETURN

;------ ALTERNATE SHIFT KEY RELEASED, GET THE VALUE INTO BUFFER

	MOV	AL, ALT_INPUT
	xor	ah,ah			; scan code of 0
	MOV	ALT_INPUT,AH		; ZERO OUT THE FIELD
	or	al,al			; was the input = 0?
	JE	K26			; INTERRUPT_RETURN
	CALL	BUFFER_FILL_ANY_CHAR	; Put in buffer, but use this
					;  entry point to avoid trashing
					;   an ASCII code of 255
	JMP	SHORT K26		; INTERRUPT_RETURN

K24:					; BREAK-TOGGLE
	AND	KB_FLAG_1,AH		; INDICATE NO LONGER DEPRESSED
	JMP	SHORT K26		; INTERRUPT_RETURN

;------ TEST FOR HOLD STATE
					; AL, AH = SCAN CODE
K25:					; NO-SHIFT-FOUND
	CMP	AL,80H			; TEST FOR BREAK KEY
	JAE	K26			; NOTHING FOR BREAK CHARS FROM HERE ON
	TEST	KB_FLAG_1,HOLD_STATE	; ARE WE IN HOLD STATE
	JZ	K28			; BRANCH AROUND TEST IF NOT
	CMP	AL,NUM_KEY
	JE	K26			; CAN'T END HOLD ON NUM_LOCK
	AND	KB_FLAG_1,NOT HOLD_STATE  ; TURN OFF THE HOLD STATE BIT

K26:
	AND	KB_FLAG_3,NOT LC_E0+LC_E1 ; RESET LAST CHAR H.C. FLAG

K26A:					; INTERRUPT-RETURN
	CLI				; TURN OFF INTERRUPTS
	CALL	ERROR_BEEP		; CHECK FOR ERROR BEEP PENDING

	CMP	CS:BUFFER_ENTRY_OK,YES	; HAS A CHARACTER BEEN PLACED IN BUFFER
	JNE	K27			;  NO, SKIP POST

	MOV	byte ptr CS:BUFFER_ENTRY_OK,NO	; CLEAR POST CHARACTER IN BUFFER FLAG
	MOV	AX,09102H		; MOVE IN POST CODE & TYPE
	INT	15H			; PERFORM OTHER FUNCTION
K27:
	MOV	AL,ENA_KBD		; ENSURE KEYBOARD IS ENABLED (AT PS/2)
	CALL	SHIP_IT 		; EXECUTE ENABLE

K27A:	CLI				; DISABLE INTERRUPTS
	POP	ES			; RESTORE REGISTERS
	POP	DS			; *
	POP	DI			; *
	POP	SI			; *
	POP	DX			; *
	POP	CX			; *
	POP	BX			; *
	POP	AX			; *
	POP	BP			; *

	IRET				; RETURN
PAGE
;------ NOT IN HOLD STATE
					; AL, AH = SCAN CODE (ALL MAKES)
K28:					; NO-HOLD-STATE
	CMP	AL,H_LAST_SCAN		; TEST FOR OUT-OF-RANGE SCAN CODES
	JA	SHORT K26		; IGNORE IF OUT-OF-RANGE

	TEST	BP,EXT_122		; IS EXTENDED 122 KEYBOARD SUPPORT OK
	JNZ	K28_122 		; SKIP NON-122 OUT-OF-RANGE CHECK

	CMP	AL,88			; TEST FOR OUT-OF-RANGE SCAN CODES
	JA	K26			; IGNORE IF OUT-OF-RANGE
K28_122:
K28_1:			; M005 ;JP9009
	TEST	BL,ALT_SHIFT		; ARE WE IN ALTERNATE SHIFT?
	JZ	K28A			; JUMP IF NOT ALTERNATE

	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K29			; NO, ALT STATE IS REAL

	TEST	KB_FLAG_1,SYS_SHIFT	; YES, IS SYSREQ KEY DOWN?
	JZ	K29			;  NO, ALT STATE IS REAL
;**CNS
	 TEST	 AH,LC_E0		; IS IT THE ALT_GR KEY?
	 JZ	 K28A			; YES,	 DON'T SET KB_FLAG

	 TEST	 AL,R_ALT_SHIFT 	; TURN ON SHIFT BIT
	 JNZ	 K29			; TURN ON SHIFT BIT
;**CNS

K28A:	JMP	K38			;  YES, THIS IS PHONY ALT STATE
					;	DUE TO PRESSING SYSREQ

;------ TEST FOR RESET KEY SEQUENCE (CTL ALT DEL) OR HOT KEY DEPRESSED

K29:					; TEST-RESET
	TEST	BL,CTL_SHIFT		; ARE WE IN CONTROL SHIFT ALSO?
	JZ	K31			; NO_RESET
	CMP	AL,DEL_KEY		; SHIFT STATE IS THERE, TEST KEY
;
;	M000 -- begin changes
;
;	note:  The special mapping of keypad-, keypad+, sp, and tab
;	  must take place in the case of alt-ctrl as well, so the following
;	  branch is moved appropriately.
;	Old instruction commented out
;
;	JNE	K31A			; NO_RESET,  TRANSLATE TABLE SWAP

	jnz	k31			; no_reset,  translate table swap

;	M000 -- end changes

;------ CTL-ALT-DEL HAS BEEN FOUND, DO I/O CLEANUP

	MOV	RESET_FLAG,1234H	; SET FLAG FOR RESET FUNCTION
	AND	WORD PTR  KB_FLAG_3,KBX ; CLEAR ALL FLAG BITS EXCEPT KBX   PED 6-25-86
	JMP	RESET			; JUMP TO POWER ON DIAGNOSTICS

;------ IN ALTERNATE SHIFT, RESET NOT FOUND

K31:					; NO-RESET
	CALL	KEYB_STATE_PROCESSOR
	JC	K26			;    TRANSLATIONS FOUND - EXIT

	CMP	AL,57			; TEST FOR SPACE KEY
	JNE	K311			; NOT THERE
	MOV	AL,' '                  ; SET SPACE CHAR
	JMP	K57			; BUFFER_FILL
K311:
	TEST	BP,EXT_16		; IS EXTENDED INT 16 LOADED?
;M001	JZ	K32			;  NO, SKIP THIS EXTENDED STUFF
	jz	k31a			;  no, skip extended stuff M001
	CMP	AL,15			; TEST FOR TAB KEY
	JNE	K312			; NOT THERE
	MOV	AX,0A500h		; SET SPECIAL CODE FOR ALT-TAB
	JMP	K57			; BUFFER_FILL
K312:
	CMP	AL,74			; TEST FOR KEYPAD -
	JE	K312A			; GO PROCESS
	CMP	AL,78			; TEST FOR KEYPAD +
;M001	JNE	K32			; SKIP TEST FOR LANG SWAP & CONT.
	jnz	k31a			; skip test for lang swap & cont. M001
K312A:	JMP	K37B			; GO PROCESS

;------ SET COUNTRY FLAG TO INDICATE WHICH TABLE WE'RE USING, FOREIGN OR DOMESTIC

K31A:	TEST    BL,CTL_SHIFT            ; Must have Ctrl+Alt to work  M008
        JZ      K31C                    ;                             M008
        CMP	AL,CS:SD.HOT_KEY_ON_SCAN ; TEST FOR HOT KEY TO US
	JNE	K31B
	MOV	CS:COUNTRY_FLAG,00	; SET FLAG FOR DOMESTIC KEY'S
	JMP	K26			; INTERRUPT RETURN

K31B:	CMP	AL,CS:SD.HOT_KEY_OFF_SCAN ; TEST FOR HOT KEY TO FOREIGN
	JNE	K31C			; IF NOT TEST FOR FRONT ENGRAV
	MOV	CS:COUNTRY_FLAG,0FFH	; SET FLAGS FOR FOREIGN KEY'S
	JMP	K26			; INTERRUPT RETURN


;------ ALT, CTRL DOWN ; NO HOT KEY

K31C:	CMP	CS:COUNTRY_FLAG,0FFH
	JNE	K32			; TRY ALT_KEY_PAD
	CALL	KEYB_STATE_PROCESSOR
	JC	K32A	;K26		;    TRANSLATIONS FOUND - EXIT


;------ LOOK FOR KEY PAD ENTRY

K32:					; ALT-KEY-PAD
	MOV	DI,OFFSET K30		; ALT-INPUT-TABLE
	MOV	CX,10			; LOOK FOR ENTRY USING KEYPAD
	REPNE	SCASB			; LOOK FOR MATCH
	JNE	K33			; NO_ALT_KEYPAD
	TEST	BH,LC_E0		; IS THIS ONE OF THE NEW KEYS?
	JNZ	K37C			;  YES, JUMP, NOT NUMPAD KEY
	SUB	DI,OFFSET K30+1 	; DI NOW HAS ENTRY VALUE
	MOV	AL, ALT_INPUT		; GET THE CURRENT BYTE
	MOV	AH,10			; MULTIPLY BY 10
	MUL	AH
	ADD	AX,DI			; ADD IN THE LATEST ENTRY
	MOV	 ALT_INPUT,AL		; STORE IT AWAY
K32A:	JMP	K26			; THROW AWAY THAT KEYSTROKE

;------ LOOK FOR SUPERSHIFT ENTRY

K33:					; NO-ALT-KEYPAD
	MOV	 ALT_INPUT,0		; ZERO ANY PREVIOUS ENTRY INTO INPUT
					; DI,ES ALREADY POINTING
	MOV	CX,K30_LEN      	; NORMALLY 26, BUT 27 FOR FR, DUE
					;  TO THE ";" KEY BEING "M"
	REPNE	SCASB			; LOOK FOR MATCH IN ALPHABET
	JE	K37A			; MATCH FOUND, GO FILL THE BUFFER

;------ LOOK FOR TOP ROW OF ALTERNATE SHIFT

K34:					; ALT-TOP-ROW
	CMP	AL,2			; KEY WITH '1' ON IT
	JB	K37B			; MUST BE ESCAPE
	CMP	AL,13			; IS IT IN THE REGION
	JA	K35			;  NO, ALT-SOMETHING ELSE
	ADD	AH,118			; CONVERT PSEUDO SCAN CODE TO RANGE
	JMP	SHORT K37A		; GO FILL THE BUFFER

;------ TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES

K35:					; ALT-FUNCTION
	CMP	AL,F11_M		; IS IT F11 or GREATER ?
	JB	K35A			;  NO, BRANCH
	SUB	AL,52h			; SET UP TO SEARCH ALT-FUNCTION-TABLE
	MOV	BX,OFFSET K30A		; BASE CASE TABLE
	JMP	K64			; CONVERT TO PSEUDO SCAN

K35A:	TEST	BH,LC_E0		; DO WE HAVE ONE OF THE NEW KEYS?
	JZ	K37			;  NO, JUMP
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K37			;  NO, DO COMPATIBLE OUTPUT
	CMP	AL,28			; TEST FOR KEYPAD ENTER
	JNE	K35B			; NOT THERE
	MOV	AX,0A600h		; SPECIAL CODE
	JMP	K57			; BUFFER FILL
K35B:	CMP	AL,83			; TEST FOR DELETE KEY
	JE	K37C			; HANDLE WITH OTHER EDIT KEYS
	CMP	AL,53			; TEST FOR KEYPAD /
	JNE	K32A			; NOT THERE, NO OTHER E0 SPECIALS
	MOV	AX,0A400h		; SPECIAL CODE
	JMP	K57			; BUFFER FILL

K37:	CMP	AL,59			; TEST FOR FUNCTION KEYS (F1)
	JB	K37B			;  NO FN, HANDLE W/OTHER EXTENDED
	CMP	AL,68			; IN KEYPAD REGION?
					; OR NUMLOCK, SCROLLOCK?
	JA	K32A			; IF SO, IGNORE
	ADD	AH,45			; CONVERT TO PSEUDO SCAN CODE

K37A:	xor	al,al			; ASCII CODE OF ZERO
	JMP	K57			; PUT IT IN THE BUFFER

K37B:
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K32A	;K26		   ;  NO, IGNORE THIS ONE
	MOV	AL,0F0h 		; USE SPECIAL ASCII CODE
	JMP	K57			; PUT IT IN THE BUFFER

K37C:
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K37A			;  NO, DO COMPATIBLE OUTPUT
	ADD	AL,80			; CONVERT SCAN CODE (EDIT KEYS)
	MOV	AH,AL			; (SCAN CODE NOT IN AH FOR INSERT)
	JMP	K37A			; PUT IT IN THE BUFFER
PAGE
;------ NOT IN ALTERNATE SHIFT

K38:					; NOT-ALT-SHIFT
					; BL STILL HAS SHIFT FLAGS
	TEST	BL,CTL_SHIFT		; ARE WE IN CONTROL SHIFT?
	JNZ	K38A			;  YES, START PROCESSING
	JMP	K44			; NOT-CTL-SHIFT

;------ CONTROL SHIFT, TEST SPECIAL CHARACTERS

;------ TEST FOR BREAK

K38A:	CMP	AL,SCROLL_KEY		; TEST FOR BREAK
	JNE	K39			; JUMP, NO-BREAK
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JNZ	K38B			;  YES, THIS IS CTRL-BREAK
	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K38B			;  NO, BREAK IS VALID
	TEST	BH,LC_E0		;  YES, WAS LAST CODE AN E0?
	JZ	K39			;   NO-BREAK, TEST FOR PAUSE

K38B:
	CLI				; Disable interrupts because EOI issued
	MOV	BX, BUFFER_HEAD 	; RESET BUFFER TAIL TO BUFFER HEAD
	MOV	 BUFFER_TAIL,BX
	MOV	 BIOS_BREAK,80H 	; TURN ON BIOS_BREAK BIT

;-------- ENABLE KEYBOARD

	MOV	AL,ENA_KBD		; ENABLE KEYBOARD
	CALL	SHIP_IT 		; EXECUTE ENABLE
	INT	1BH			; BREAK INTERRUPT VECTOR
	SUB	AX,AX			; PUT OUT DUMMY CHARACTER
	JMP	K57			; BUFFER_FILL

;-------- TEST FOR PAUSE

K39:					; NO-BREAK
	CMP	AL,NUM_KEY		; LOOK FOR PAUSE KEY
	JNE	K41			; NO-PAUSE
	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K39P			;  NO, THIS IS A VALID PAUSE
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K41			;  NO, IT'S NOT PAUSE THIS TIME
K39P:	OR	KB_FLAG_1,HOLD_STATE	; TURN ON THE HOLD FLAG

;-------- ENABLE KEYBOARD

	MOV	AL,ENA_KBD		; ENABLE KEYBOARD
	CALL	SHIP_IT 		; EXECUTE ENABLE

;------ DURING PAUSE INTERVAL, TURN CRT BACK ON

	CMP	CRT_MODE,7		; IS THIS BLACK AND WHITE CARD
	JAE	K40			; YES, NOT CGA MODES NOTHING TO DO
	MOV	DX,03D8H		; PORT FOR COLOR CARD
	MOV	AL,CRT_MODE_SET 	; GET THE VALUE OF THE CURRENT MODE
	OUT	DX,AL			; SET THE CRT MODE, SO THAT CRT IS ON
K40:					; PAUSE-LOOP
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K40A			;  NO, SKIP THE BATTERY LIFE STUFF
	MOV	AX,4104H		; FUNCTION 41, AL=04=RETURN IF 0
	MOV	BX,HOLD_STATE*100H	; BH=HOLD_STATE, BL=0=NO TIME OUT
	PUSH	DS			; MAKE ES:DI POINT TO KB_FLAG_1
	POP	ES
	MOV	DI,OFFSET  KB_FLAG_1
	INT	15H			; SLEEP UNTIL OUT OF HOLD

;------ CHECK FOR AUX ADAPTER INPUT PENDING
K40A:
	MOV CX,100			; COUNT FOR WAIT LOOP
K40B:
	TEST	KB_FLAG_1,HOLD_STATE	; ARE WE IN HOLD STATE
	JZ K40E 			; EXIT IF NOT

	TEST	BP,PC_XT+PC_LAP		; Check for systems without AUX BIOS
	JNZ	K40B			; For them, just loop on hold flag

	IN	AL,STATUS_PORT		; READ CURRENT STATUS
	AND	AL,MOUSE_OBF+OUT_BUF_FULL ; MASK OFF ALL BUT MOUSE DATA BITS
	CMP	AL,MOUSE_OBF+OUT_BUF_FULL ; IS THERE STILL MOUSE DATA PENDING?
	LOOPE	K40B			; WAIT FOR MOUSE DATA TO GO
	JNE	K40A			; CONTINUE IF PAUSE STATE	       ;an005
K40E:
	AND	KB_FLAG_1,NOT HOLD_STATE ; CLEAR HOLD STATE FLAG
	JMP	K27A			; INTERRUPT_RETURN_NO_EOI      PTR 2247

;------ TEST SPECIAL CASE KEY 55

K41:					; NO-PAUSE
	CMP	AL,55			; TEST FOR */PRTSC KEY
	JNE	K42			; NOT-KEY-55
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K41B			;  NO, JUMP
	TEST	BH,LC_E0		;  YES, WAS LAST CODE AN E0?
	JZ	K41A			;    NO, THIS IS THE PRTSC KEY
	JMP	SHORT K42B		;    YES, E0 MEANS THE "*" KEY

K41B:	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K41A			;  NO, CTL-PRTSC IS VALID
	TEST	BH,LC_E0		;  YES, WAS LAST CODE AN E0?
	JZ	K42B			;   NO, TRANSLATE TO A FUNCTION
K41A:	MOV	AX,114*256		; START/STOP PRINTING SWITCH
	JMP	K57			; BUFFER_FILL

;------ SET UP TO TRANSLATE CONTROL SHIFT

K42:					; NOT-KEY-55
	CALL	KEYB_STATE_PROCESSOR
	JC	K449	;K26		; TRANSLATIONS FOUND - EXIT

	CMP	AL,15			; IS IT THE TAB KEY?
	JE	K42B			;  YES, XLATE TO FUNCTION CODE
	CMP	AL,53			; IS IT THE / KEY?
	JNE	K42A			;  NO, NO MORE SPECIAL CASES
	TEST	BH,LC_E0		;  YES, IS IT FROM THE KEYPAD?
	JZ	K42A			;   NO, JUST TRANSLATE
	MOV	AX,9500h		;   YES, SPECIAL CODE FOR THIS ONE
	JMP	K57			;   BUFFER FILL

K42A:	MOV	BX,OFFSET K8		; SET UP TO TRANSLATE CTL
	CMP	AL,59			; IS IT IN CHARACTER TABLE?
	JB	K45F			;  YES, GO TRANSLATE CHAR
K42B:	MOV	BX,OFFSET K8		; SET UP TO TRANSLATE CTL
	JMP	K64			;  NO, GO TRANSLATE_SCAN
PAGE
;------ NOT IN CONTROL SHIFT

K44:
	CALL	KEYB_STATE_PROCESSOR
	JC	K449	;K26		; TRANSLATIONS FOUND - EXIT

	CMP	AL,55			; PRINT SCREEN KEY?
	JNE	K45			; NOT-PRINT-SCREEN
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K441			;  NO, JUMP
	TEST	BH,LC_E0		;  YES, WAS LAST CODE THE MARKER?
	JZ	K44A			;	NO, TEST THE SHIFT STATE
	JMP	SHORT K45C		;	YES, XLATE TO "*" CHAR
K441:	TEST	BH,KBX			; IS THIS ENHANCED KEYBOARD?
	JZ	K44A			; NO, TEST FOR SHIFT STATE
	TEST	BH,LC_E0		; YES, LAST CODE A MARKER?
	JNZ	K44B			;  YES, IS PRINT SCREEN
	JMP	SHORT K45C		;  NO, XLATE TO "*" CHARACTER
K44A:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ;NOT 101 KBD, SHIFT KEY DOWN?
	JZ	K45C			   ; NO, XLATE TO "*" CHARACTER

;------ ISSUE INTERRUPT TO PERFORM PRINT SCREEN FUNCTION
K44B:
	CLI				; DISABLE INTERRUPTS	       PTR 2355
	AND	KB_FLAG_3,NOT LC_E0+LC_E1 ;ZERO OUT THESE FLAGS
	MOV	AL,ENA_KBD		; INSURE KEYBOARD IS ENABLED
	CALL	SHIP_IT 		; EXECUTE ENABLE
	PUSH	BP			; SAVE POINTER (compatibility)
	INT	5H			; ISSUE PRINT SCREEN INTERRUPT
	POP	BP			; RESTORE POINTER
	JMP	K27A			; EXIT WITHOUT EXTRA EOI OR ENABLE

K449:
	JMP	K26			; EXIT

;------ HANDLE THE IN-CORE KEYS
K45:					; NOT-PRINT-SCREEN
	CMP	AL,58			; TEST FOR IN-CORE AREA
	JA	K46			; JUMP IF NOT

	TEST	BH,GRAPH_ON		; IS ALT GRAPHICS ON?		   AEV
	JNZ	K449	;K26		; YES, TRASH KEYSTROKE

	CMP	AL,53			; IS THIS THE "/" KEY?
	JNE	K45A			;  NO, JUMP
	TEST	BH,LC_E0		; WAS LAST CODE THE MARKER?
	JNZ	K45C			;  YES, TRANSLATE TO CHARACTER

K45A:	MOV	CX,K30_LEN	        ; LENGTH OF SEARCH
	MOV	DI,OFFSET K30+10	; POINT TO TABLE OF A-Z CHARS
	REPNE	SCASB			; IS THIS A LETTER KEY?
	JNE	K45B			;  NO, SYMBOL KEY

	TEST	BL,CAPS_STATE		; ARE WE IN CAPS_LOCK?
	JNZ	K45D			; TEST FOR SURE
K45B:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT ; ARE WE IN SHIFT STATE?
	JNZ	K45E			  ; YES, UPPERCASE
					  ; NO, LOWERCASE
K45C:	MOV	BX,OFFSET K10		; TRANSLATE TO LOWERCASE LETTERS
	JMP	SHORT K56
K45D:					; ALMOST-CAPS-STATE
	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT ; CL ON. IS SHIFT ON, TOO?
	JNZ	K45C			; SHIFTED TEMP OUT OF CAPS STATE
K45E:	MOV	BX,OFFSET K11		; TRANSLATE TO UPPERCASE LETTERS
K45F:	JMP	SHORT K56


;------ TEST FOR KEYS F1 - F10
K46:					; NOT IN-CORE AREA
	CMP	AL,68			; TEST FOR F1 - F10
	JA	K47			; JUMP IF NOT
	JMP	SHORT K53A		; YES, GO DO FN KEY PROCESS


;------ HANDLE THE NUMERIC PAD KEYS

K47:					; NOT F1 - F10
	CMP	AL,83			; TEST FOR NUMPAD KEYS
	JA	K52			; JUMP IF NOT

;------ KEYPAD KEYS, MUST TEST NUM LOCK FOR DETERMINATION
K48:	CMP	AL,74			; SPECIAL CASE FOR MINUS
	JE	K45E			; GO TRANSLATE (US & WT ARE SAME)
	CMP	AL,78			; SPECIAL CASE FOR PLUS
	JE	K45E			; GO TRANSLATE (US & WT ARE SAME)
	TEST	BH,LC_E0		; IS THIS ONE OF THE NEW KEYS?
	JNZ	K49			;  YES, TRANSLATE TO BASE STATE

	TEST	BL,NUM_STATE		; ARE WE IN NUM_LOCK?
	JNZ	K50			; TEST FOR SURE
	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ; ARE WE IN SHIFT STATE?
	JNZ	K51			   ; IF SHIFTED, REALLY NUM STATE

;------ BASE CASE FOR KEYPAD
K49:	CMP	AL,76			; SPECIAL CASE FOR BASE STATE 5
	JNE	K49A			; CONTINUE IF NOT KEYPAD 5
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K59	;K26		;  NO, INGORE

	MOV	AL,0F0h 		; SPECIAL ASCII CODE
	JMP	SHORT K57		; BUFFER FILL
K49A:	MOV	BX,OFFSET K10		; BASE CASE TABLE
	JMP	SHORT K64		; CONVERT TO PSEUDO SCAN

;------ MIGHT BE NUM LOCK, TEST SHIFT STATUS
K50:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT	;ALMOST-NUM-STATE
	JNZ	K49			; SHIFTED TEMP OUT OF NUM STATE
K51:	JMP	SHORT K45E		; REALLY_NUM_STATE
					; (US & WT ARE SAME)

;------ TEST FOR THE NEW KEY ON WT KEYBOARDS

K52:					; NOT A NUMPAD KEY
	CMP	AL,86			; IS IT THE NEW WT KEY?
	JNE	K53			; JUMP IF NOT
	MOV	AL,58			; WE'RE GOING TO PULL A SNEAKY
	JMP	K45			; TRICK HERE. WT TABLES ARE TOO SHORT TO
					; XLATE 86, SO WE'LL CHANGE IT TO CAPS_LOCK
					; AND PUT THE CHAR IN THE TABLES IN THE C_L
					; POSITION, SINCE C_L SCAN CODES NEVER GET
					; HERE ANYWAY.

;------ MUST BE F11 OR F12

K53:	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 THERE?
	JZ	K59			;  NO, INGORE F11 & F12 (NEAR RET)
					; F1 - F10 COME HERE, TOO
K53A:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT ;TEST SHIFT STATE
	JZ	K49			;   JUMP, LOWERCASE PSEUDO SC'S

	MOV	BX,OFFSET K11		; UPPER CASE PSEUDO SCAN CODES
	JMP	SHORT K64		; TRANSLATE_SCAN
PAGE
;------ TRANSLATE THE CHARACTER

K56:					; TRANSLATE-CHAR
	DEC	AL			; CONVERT ORIGIN
	XLAT	CS:K11			; CONVERT THE SCAN CODE TO ASCII
	TEST	KB_FLAG_3,LC_E0	; IS THIS A NEW KEY?
	JZ	K57			;  NO, GO FILL BUFFER
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 THERE?
	JZ	K57			;  NO, DO COMPATIBLE OUTPUT
	MOV	AH,MC_E0		;  YES, PUT SPECIAL MARKER IN AH
	JMP	SHORT K57		; PUT IT INTO THE BUFFER

;------ TRANSLATE SCAN FOR PSEUDO SCAN CODES

K64:					; TRANSLATE-SCAN-ORGD
	DEC	AL			; CONVERT ORIGIN
	XLAT	CS:K8			; CTL TABLE SCAN
	MOV	AH,AL			; PUT VALUE INTO AH
	xor	al,al			; ZERO ASCII CODE
	TEST	KB_FLAG_3,LC_E0		; IS THIS A NEW KEY?
	JZ	K57			;  NO, GO FILL BUFFER
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 THERE?
	JZ	K57			;  NO, DO COMPATIBLE OUTPUT
	MOV	AL,MC_E0		;  YES, PUT SPECIAL MARKER IN AL

;------ PUT CHARACTER INTO BUFFER

K57:					; BUFFER-FILL
	CALL	BUFFER_FILL
K59:
	JMP	K26			;-- THAT'S ALL FOLKS --

KEYB_INT_9   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: BUFFER_FILL
;
;  Description:
;      Generate keyboard buffer entry
;
;  Input Registers:
;      AX - the buffer entry
;      DS - BIOS data segment
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BUFFER_ENTRY_OK DB	NO		; YES if character put into buffer

BUFFER_FILL	PROC   NEAR

	CMP	AL,-1			; IS THIS AN IGNORE CHAR
	JE	K61B			; YES, EXIT
	CMP	AH,-1			; LOOK FOR -1 PSEUDO SCAN
	JE	K61B			; EXIT
;
;  BUFFER_FILL_ANY_CHAR is an alternate entry point to this PROC.
;  Entry at this point will avoid trashing ASCII values of 255.
;
BUFFER_FILL_ANY_CHAR  LABEL  NEAR

	PUSH	SI
	PUSH	BX
	PUSH	DS			; This routine may be called
					;  externally so make sure DS points
	MOV	BX,DATA 		;   to BIOS data
	MOV	DS,BX

	cli				; disable interrupts  P724
	MOV	BX, BUFFER_TAIL 	; GET THE END POINTER TO THE BUFFER
	MOV	SI,BX			; SAVE THE VALUE
	INC	BX			; MOVE TO NEXT WORD IN LIST
	INC	BX

;; VERIFY IF THE CURRENT ROM LEVEL IN THE SYSTEM IS FOR THE ORIGINAL PC1

	TEST	BP,PC_81		; CHECK FOR '81 DATE FLAG SET
        JZ      NOT_PC1                 ; IF IT'S A LATER ROM RELEASE, BRANCH -- M007

	CMP	BX,OFFSET KB_BUFFER_END ; AT END OF BUFFER?
	JNE	K5			; NO, CONTINUE
	MOV	BX,OFFSET  KB_BUFFER	; YES, RESET TO BUFFER BEGINNING
	JMP	SHORT K5
NOT_PC1:
	CMP	BX, BUFFER_END		; AT END OF BUFFER?
	JNE	K5			; NO, CONTINUE
	MOV	BX, BUFFER_START	; YES, RESET TO BUFFER BEGINNING
K5:
	CMP	 BX,BUFFER_HEAD 	; HAS THE BUFFER WRAPPED AROUND
	JE	K62			; BUFFER_FULL_BEEP
	MOV	[SI],AX 		; STORE THE VALUE
	MOV	 BUFFER_TAIL,BX 	; MOVE THE POINTER UP
	MOV	CS:BUFFER_ENTRY_OK,YES	; INDICATE WE PUT SOMETHING IN BUFFER
	JMP	SHORT K61A
K62:
	MOV	CS:BEEP_PENDING,YES	; INDICATE WE NEED A BEEP
K61A:
	POP	DS
	POP	BX
	POP	SI
	sti				; enable interrupts  P724
K61B:
	RET
BUFFER_FILL	ENDP

PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: ERROR_BEEP
;
;  Description:
;      General routine to generate beep tones
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


ERROR_BEEP	PROC	NEAR

	CMP	CS:BEEP_PENDING,YES	; Q..SHOULD WE BEEP?
	JNE	NO_BEEP

	MOV	CS:BEEP_PENDING,NO	; Reset BEEP required
	MOV	CX,216-32		; NUMBER OF CYCLES FOR 1/8 SECOND TONE
	IN	AL,PORT_B		; Get control info
	PUSH	AX
LOOP01:
	AND	AL,0FCH 		; Turn off timer gate and speaker
	OUT	PORT_B,AL		; output to control - speaker off
	CALL	WAITFB			; half cycle time for tone
	OR	AL,2			; turn on speaker
	CLI				; Disable interrupts for 1/2 cycle, 300u
	OUT	PORT_B,AL		; output to control
	CALL	WAITFB			; another half cycle
	STI				; Enable interrupts between 1/2 cycle
	LOOP	LOOP01

	POP	AX
	OUT	PORT_B,AL		; Restore control
	MOV	CX,32*2 		; Short delay count of 32 cycles
LOOP02:
	CALL	WAITFB			; Add a short delay to complete 1/8 sec
	LOOP	LOOP02			; Repeat
	CLI				; Disable interrupts
NO_BEEP:
	RET				; RETURN
ERROR_BEEP	ENDP

WAITFB	PROC	NEAR			;	DELAY FOR  (CX)*15.085737 US
	PUSH	AX			; SAVE WORK REGISTER (AH)
	PUSH	CX			; SAVE COUNT
	MOV	CX,19			; The half cycle time for 1745 hz
	TEST	BP,PC_AT+PC_386 	; IF THE SYSTEM IS AN 80x86
	JNZ	WAITF1			; SKIP TO REFRESH BIT DELAY

WAITF0:
	NOP				; Force two fetch cycles on Model 30
	LOOP	WAITF0			; SOFTWARE DELAY LOOP ON 808x MACHINES
	JMP	SHORT WAITFE		; EXIT

WAITF1: 				;	USE TIMER 1 OUTPUT BITS
	IN	AL,PORT_B		; READ CURRENT COUNTER OUTPUT STATUS
	AND	AL,REFRESH_BIT		; MASK FOR REFRESH DETERMINE BIT
	CMP	AL,AH			; DID IT JUST CHANGE
	JE	WAITF1			; WAIT FOR A CHANGE IN OUTPUT LINE

	MOV	AH,AL			; SAVE NEW FLAG STATE
	LOOP	WAITF1			; DECREMENT HALF CYCLES TILL COUNT END
WAITFE:
	POP	CX			; RESTORE COUNT
	POP	AX			; RESTORE (AH)
	RET				; RETURN  (CX)= 0

WAITFB	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	SHIP_IT
;
;	THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;	TO THE KEYBOARD CONTROLLER.
;
;	On entry the AL contains the command byte.
;	On Enable keyboard commands, the reset keyboard input latch is done
;	if the system is the old PC type.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SHIP_IT PROC	NEAR

;------- TEST SYSTEM TYPE

	PUSHF				; SAVE FLAGS	P725
	CLI				; DISABLE INTERRUPTS TILL DATA SENT

	TEST	BP,PC_XT+PC_LAP
	JZ	SI5			; USE AT 8042 COMMAND IF NOT PC TYPE

	CMP	AL,ENA_KBD		; CHECK FOR ENABLE KEYBOARD COMMAND
	JNE	SI9			; SKIP ENABLE RESET
					;   FOR PC, XT, P12: RESET THE KEYBOARD
	PUSH	AX			; SAVE AX
	IN	AL,KB_CTL		; GET THE CONTROL PORT
	MOV	AH,AL			; SAVE VALUE
	OR	AL,80H			; RESET BIT FOR KEYBOARD ON PC/PC-XT
	OUT	KB_CTL,AL
	XCHG	AH,AL			; GET BACK ORIGINAL CONTROL
	OUT	KB_CTL,AL		; KB HAS BEEN RESET
	POP	AX			; RESTORE AX
					; EXIT as NOT next system
SI5:
	TEST	BP,PC_AT+PC_386 	; IF THE SYSTEM IS NOT AN 80x86
	JZ	SI9			; MACHINE, EXIT THIS PROC.

;------- WAIT FOR COMMAND TO BE ACCEPTED;

	CALL	chk_ibf 		; GO READ KEYBOARD CONTROLLER STATUS
	OUT	STATUS_PORT,AL		; SEND TO KEYBOARD CONTROLLER
SI9:					; ENABLE INTERRUPTS AGAIN
	POPF				; RESTORE FLAGS P725
	RET				; RETURN TO CALLER
SHIP_IT ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	SND_DATA
;
;	THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;	TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;	HANDLES ANY RETRIES IF REQUIRED
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA PROC	NEAR
	PUSH	AX			; SAVE REGISTERS
	PUSH	BX			; *
	PUSH	CX
	MOV	BH,AL			; SAVE TRANSMITTED BYTE FOR RETRIES

	MOV	BL,3			; LOAD RETRY COUNT
SD0:
	CLI				; DISABLE INTERRUPTS
	AND	KB_FLAG_2,NOT (KB_FE+KB_FA+kb_err) ; CLEAR ACK, RESEND and
						    ; error flags

	CALL	CHK_IBF 		; Wait for command accepted

	MOV	AL,BH			; REESTABLISH BYTE TO TRANSMIT
	OUT	PORT_A,AL		; SEND BYTE
	STI				; ENABLE INTERRUPTS
	MOV	CX,DLY_15MS		; DELAY FOR 15 ms TIMEOUT
SD1:	TEST	KB_FLAG_2,KB_FE+KB_FA	; SEE IF EITHER BIT SET
	JNZ	SD3			; IF SET, SOMETHING RECEIVED GO PROCESS
	IN	AL,PORT_B		; WAIT LOOP USING REFRESH BIT
	AND	AL,REFRESH_BIT
	CMP	AL,AH
	JE	SD1			; KEEP TESTING
	MOV	AH,AL			; DEC CX ON REFRESH TIC
	LOOP	SD1			; KEEP TESTING
					; !! TIMEOUT !!

SD2:	DEC	BL			; DECREMENT RETRY COUNT
	JNZ	SD0			; RETRY TRANSMISSION
	OR	KB_FLAG_2,KB_ERR	; TURN ON TRANSMIT ERROR FLAG
	JMP	SHORT SD4		; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:	TEST	KB_FLAG_2,KB_FA	; SEE IF THIS IS AN ACKNOWLEDGE
	JZ	SD2			; IF NOT, GO RESEND

SD4:	POP	CX			; RESTORE REGISTERS
	POP	BX
	POP	AX			; *
	RET				; RETURN, GOOD TRANSMISSION
SND_DATA ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	SND_LED
;
;	THIS ROUTINE TURNS ON THE MODE INDICATORS.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_LED PROC	NEAR
	CLI				; TURN OFF INTERRUPTS

	TEST	BP,PC_AT+PC_386 	; IF THE SYSTEM IS NOT A 80x86
	JZ	SL1			; MACHINE, EXIT THIS PROC

	TEST	KB_FLAG_2,KB_PR_LED	; CHECK FOR MODE INDICATOR UPDATE
	JNZ	SL1			; DONT UPDATE AGAIN IF UPDATE UNDERWAY
	OR	KB_FLAG_2,KB_PR_LED	; TURN ON UPDATE IN PROCESS
	MOV	AL,LED_CMD		; LED CMD BYTE
	CALL	SND_DATA		; SEND DATA TO KEYBOARD
	CLI
	CALL	MAKE_LED		; GO FORM INDICATOR DATA BYTE
	AND	KB_FLAG_2,0F8H 		; CLEAR MODE INDICATOR BITS
	OR	KB_FLAG_2,AL		; SAVE PRESENT INDICATORS FOR NEXT TIME
	TEST	KB_FLAG_2,KB_ERR	; TRANSMIT ERROR DETECTED
	JNZ	SL2			;  YES, BYPASS SECOND BYTE TRANSMISSION
	CALL	SND_DATA		; SEND DATA TO KEYBOARD
	CLI				; TURN OFF INTERRUPTS
	TEST	KB_FLAG_2,KB_ERR	; TRANSMIT ERROR DETECTED
	JZ	SL3			; IF NOT, DONT SEND AN ENABLE COMMAND
SL2:	MOV	AL,KB_ENABLE		; GET KEYBOARD CSA ENABLE COMMAND
	CALL	SND_DATA		; SEND DATA TO KEYBOARD
	CLI				; TURN OFF INTERRUPTS
SL3:	AND	KB_FLAG_2,NOT(KB_PR_LED+KB_ERR) ; TURN OFF MODE INDICATOR
					; UPDATE AND TRANSMIT ERROR FLAG
SL1:	STI				; ENABLE INTERRUPTS
	RET				; RETURN TO CALLER
SND_LED ENDP
PAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	MAKE_LED
;
;	THIS ROUTINE FORMS THE DATA BYTE NECESSARY TO TURN ON/OFF
;	THE MODE INDICATORS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MAKE_LED PROC	NEAR
	PUSH	CX			; SAVE CX
	MOV	AL, KB_FLAG		; GET CAPS & NUM LOCK INDICATORS
	AND	AL,CAPS_STATE+NUM_STATE+SCROLL_STATE ; ISOLATE INDICATORS
	MOV	CL,4			; SHIFT COUNT
	ROL	AL,CL			; SHIFT BITS OVER TO TURN ON INDICATORS
	AND	AL,07H			; MAKE SURE ONLY MODE BITS ON
	POP	CX
	RET				; RETURN TO CALLER
MAKE_LED ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	CHK_IBF
;
;  Description:
;      Waits for a keyboard command to be accepted
;	wait until ibf = 0   (empty)
;
;  Input Registers:
;      None
;
;  Output Registers:
;	ZF=0	time out & IBF still full
;	ZF=1	IBF is empty
;
;	---------------------------------------------------------------
;	This procedure replaces the previous one which used a software
;	timing loop.   (For 80286, 80386 and 80486 based machines.)
;	---------------------------------------------------------------
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

chk_ibf proc	near

	push	ax			; Save register used
	push	cx
	mov	cx,DLY_15MS		; Timeout 15 milleseconds (15000/15.086;
chk_ibfl:
	in	al,PORT_B		; Read current refresh output bit
	and	al,refresh_bit		; Mask all but refresh bit
	cmp	al,ah			; Did it change? (or first pass thru)
	jz	short chk_ibfl		; No, wait for change, else continue

	mov	ah,al			; Save new refresh bit state
	in	al,status_port		; Read status port
	test	al,inpt_buf_full	; Check for input buffer empty
	loopnz	chk_ibfl		; Loop until input buf empty or timeout;

	pop	cx
	pop	ax			; Restore register used
	ret				; Return to caller

chk_ibf endp

;	M005 -- begin added section

;***********************************************************************;JP9009
;*                                                                     *;JP9009
;*                    DBCS Common Keyboard Support                     *;JP9009
;*                                                                     *;JP9009
;*      The DBCS common keyboard unique scan code is mapped to the     *;JP9009
;*      temporary scan code. It is again mapped to the corresponding   *;JP9009
;*      scan code/character code according the current shift staes.    *;JP9009
;*                                                                     *;JP9009
;***********************************************************************;JP9009
                                                                        ;JP9009
DBCS_keyboard_support   proc    near                                    ;JP9009
        cmp     al, 80h                         ; Ignore break keys     ;JP9009
        jae     leave_it_to_common_method                               ;JP9009
        test    cs:SD.KEYB_TYPE, DBCS_KB        ; DBCS keyboard?        ;JP9009
        jz      leave_it_to_common_method                               ;JP9009
        cmp     cs:SD.INVOKED_CP_TABLE, 932     ; DBCS code page?       ;JP9009
        jb      leave_it_to_common_method                               ;JP9009
                call    DBCS_keyboard_common_support                    ;JP9009
                test    cs:SD.KEYB_TYPE, DBCS_OLD_KB                    ;JP9009
                jz      leave_it_to_common_method_1                     ;JP9009
                        call    DBCS_old_keyboard_support               ;JP9009
    leave_it_to_common_method_1:                                        ;JP9009
                mov     ah, al          ; ah = al = 'make' scan code    ;JP9009
                mov     cs:scan_code, al; Set this because we don't know;JP9009
                                        ; who will use it later.        ;JP9009
    leave_it_to_common_method:                                          ;JP9009
        ret                                                             ;JP9009
DBCS_keyboard_support   endp                                            ;JP9009
                                                                        ;JP9009
PSEUDO_SC_ALPHANUMERIC  equ     7eh                                     ;JP9009
PSEUDO_SC_HIRAGANA      equ     7fh                                     ;JP9009
                                                                        ;JP9009
DBCS_keyboard_common_support    proc    near                            ;JP9009
        ; Check if it is the Alphanumeric key or Kanji NO key           ;JP9009
        ; of the DBCS new keyboard.                                     ;JP9009
        cmp     al, 3ah                         ; CAPS key ?            ;JP9009
        jne     leave_it_to_common_method_2     ; if not                ;JP9009
        test    bl, ALT_SHIFT                                           ;JP9009
        jnz     convert_to_alphanumeric                                 ;JP9009
        test    bl, (LEFT_SHIFT or RIGHT_SHIFT)                         ;JP9009
        jnz     leave_it_to_common_method_2                             ;JP9009
        jmp     short convert_to_alphanumeric_2                         ;JP9009
    convert_to_alphanumeric:                                            ;JP9009
            test    cs:SD.KEYB_TYPE, DBCS_OLD_A_KB                      ;JP9009
            jnz     leave_it_to_common_method_2                         ;JP9009
    convert_to_alphanumeric_2:                                          ;JP9009
                mov     al, PSEUDO_SC_ALPHANUMERIC                      ;JP9009
    leave_it_to_common_method_2:                                        ;JP9009
        ret                                                             ;JP9009
DBCS_keyboard_common_support    endp                                    ;JP9009
                                                                        ;JP9009

;***********************************************************************;JP9009
;*                                                                     *;JP9009
;*                    DBCS Old Keyboard Support                        *;JP9009
;*                                                                     *;JP9009
;*      The old DBCS keyboard unique scan codes is mapped to the       *;JP9009
;*      temporary scan code. It is again mapped to the corresponding   *;JP9009
;*      scan code/character code according the current shift staes.    *;JP9009
;*                                                                     *;JP9009
;***********************************************************************;JP9009
                                                                        ;JP9009
DBCS_old_keyboard_support       proc    near                            ;JP9009
        cmp     al, 38h                                                 ;JP9009
        jne     not_right_ALT_nor_hiragana                              ;JP9009
        test    ds:KB_FLAG_3, LC_E0                                     ;JP9009
        jz      not_right_ALT_nor_hiragana                              ;JP9009
                mov     al, PSEUDO_SC_HIRAGANA                          ;JP9009
                and     ds:KB_FLAG_3, not LC_E0                         ;JP9009
    not_right_ALT_nor_hiragana:                                         ;JP9009
        ret                                                             ;JP9009
DBCS_old_keyboard_support       endp                                    ;JP9009

;	M005 -- end added section

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybcmd.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                         
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCMD.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;;
;; Description:
;; ------------
;;       External declarations for procedures in file KEYCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                              ;;
        EXTRN    KEYB_COMMAND        :NEAR    ;;
                                              ;;
        EXTRN    KEYBSYS_FILE_HANDLE:WORD     ;;
        EXTRN    CP_TAB_OFFSET:DWORD          ;;
        EXTRN    STATE_LOGIC_OFFSET:DWORD     ;;
        EXTRN    SYS_CODE_PAGE:WORD           ;;
        EXTRN    KEYBCMD_LANG_ENTRY_PTR:DWORD ;;
        EXTRN    DESIG_CP_BUFFER:WORD         ;;
        EXTRN    DESIG_CP_OFFSET:WORD         ;;
        EXTRN    NUM_DESIG_CP:WORD            ;;
        EXTRN    TB_RETURN_CODE:WORD          ;;
        EXTRN    FILE_BUFFER:BYTE             ;;
;****************CNS****************************
        EXTRN    ID_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    LANG_PTR_SIZE:WORD           ;;
        EXTRN    CP_PTR_SIZE:WORD             ;;
;****************CNS****************************
        EXTRN    NUM_ID:WORD                  ;;
;****************CNS****************************
        EXTRN    NUM_LANG:WORD                ;;
        EXTRN    NUM_CP:WORD                  ;;
        EXTRN    SHARED_AREA_PTR:DWORD        ;;
        EXTRN    SD_SOURCE_PTR:BYTE           ;;
        EXTRN    TEMP_SHARED_DATA:BYTE        ;;
                                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybcpsd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */

	PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                               
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;  File Name:  KEYBCPSD.ASM
;  ----------
;
;
;  Description:
;  ------------
;	 Copies the SHARED_DATA_AREA into a part of memory that
;	 can be left resident. All relative pointers must already
;	 be recalculated to this new position.
;	 THIS FILE MUST BE THE LAST OF THE RESIDENT FILES WHEN KEYB IS LINKED.
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;  Include Files Required:
;  -----------------------
;	INCLUDE KEYBSHAR.INC
;	INCLUDE KEYBCMD.INC
;	INCLUDE KEYBTBBL.INC
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      procedure - description???
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	SD_DEST_PTR
	PUBLIC	COPY_SD_AREA
	PUBLIC	SHARED_DATA

	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBTBBL.INC

CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: COPY_SD_AREA
;
;  Description:
;
;  Input Registers:
;
;  Output Registers:
;      N/A
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SD		EQU   SHARED_DATA
TSD		EQU  TEMP_SHARED_DATA

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SD_AREA	PROC   NEAR

   REP	MOVS	ES:BYTE PTR [DI],DS:[SI]	; Copy SHARED_DATA_AREA to
						;	new part of memory

	MOV	BYTE PTR ES:SD.TABLE_OK,1	; Activate processing flag
	INT	21H				; Exit


COPY_SD_AREA	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		db	'SHARED DATA'
SD_DEST_PTR	LABEL	BYTE

SHARED_DATA   SHARED_DATA_STR <>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE   ENDS
       END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybcpsd.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                             
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBCPSD.INC
;; ----------
;;
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBCPSD.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    COPY_SD_AREA:NEAR     ;;
                                       ;;
        EXTRN    SD_DEST_PTR :BYTE     ;;
        EXTRN    SHARED_DATA :BYTE     ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybsys.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                         
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSYS.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions and equates
;;	 for the KEYBOARD.SYS file.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; File header - contains pointers to keyboard tables for each language
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_HEADER	STRUC		       ;;
				       ;;
KH_SIGNATURE	DB   0FFh,'KEYB   '    ;; signature
KH_RESV_1	DB   8 DUP(0)	       ;; reserved
KH_MAX_COM_SZ	DW   0	      ;AN000;**chg  ;; maximum size of Common Xlat Sect
KH_MAX_SPEC_SZ	DW   0	      ;AN000;;**chg   ;; max size of Specific Xlat Sect
KH_MAX_LOGIC_SZ DW   0	      ;AN000;;**chg   ;; max size of State Logic
KH_RESV_2	Dw   0	      ;AN000;;**chg   ;; reserved CNS
KH_NUM_ID	Dw   0		       ;AN000;;; ************* CNS
KH_NUM_LANG	DW   0		       ;; number of languages
KH_LANG_PTRS	DB   0		       ;; language pointers start here
;********************* CNS **********************
;KH_NUM_ID	  DW   0		 ;; number of languages
;KH_ID_PTRS	  DB   0		 ;; id pointers start here
;********************* CNS **********************
KEYBSYS_HEADER	ENDS		       ;;
;******************CNS*******************
KEYBSYS_ID_PTRS STRUC

KP_ID_CODE	DW   0		       ;AN000;
KP_LANG_PTR	DD   0		       ;AN000;

KEYBSYS_ID_PTRS ENDS
				       ;;
;*****************CNS********************
KEYBSYS_LANG_PTRS STRUC 	       ;;
				       ;; Next two entries repeat:
KP_LANG_CODE	DW   0		       ;;   language code
KP_ENTRY_PTR	DD   0		       ;;   language entry pointer
				       ;;
KEYBSYS_LANG_PTRS ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Language Entry - pointed to by KH_ENTRY_PTR in KEYBSYS_HEADER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_LANG_ENTRY  STRUC	       ;;
				       ;;
KL_LANG_CODE	DW   'XX'              ;; language code
KL_ID_CODE	DW   0		       ;; reserved (ID CODE)
KL_LOGIC_PTR	DD   0	       ;AC000;;**chg  ;; State Logic pointer
KL_NUM_ID	DB   0	       ;AN000;;CNS    ;; number of valid IDs for this lang
KL_NUM_CP	DB   0		       ;; number of valid CPs for this lang
KL_CP_PTRS	DB   0		       ;; CP table pointers start here
				       ;;
KEYBSYS_LANG_ENTRY  ENDS	       ;;
				       ;;
KEYBSYS_CP_PTRS     STRUC	       ;;
				       ;; Next two entries repeat:
KC_CODE_PAGE	DW   0		       ;;  code page
KC_ENTRY_PTR	DD   0		       ;; ptr to Specific Translate Section
				       ;;
KEYBSYS_CP_PTRS     ENDS	       ;;
				       ;;
				       ;;
;; Everything from here down is new
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic - pointed to by KL_LOGIC_PTR in KEYBSYS_LANG_ENTRY
;; Common Translate Section follows immediately after the State Logic.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE_LOGIC STRUC	       ;;
				       ;;
KT_LOGIC_LEN	DW   ?		       ;; length of state logic
KT_SPECIAL_FEATURES  DW  ?	       ;; Special Features (see KEYBSHAR.INC)
KT_LOGIC_CMDS	DB   0		       ;; state logic commands begin here
				       ;;
KEYBSYS_STATE_LOGIC ENDS	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Section - Common and Specific Translate Sections
;; are both in this form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_XLAT_SECT   STRUC	       ;;
				       ;;
KX_SECTION_LEN	 DW    ?	       ;; Length of this section
KX_CP_ID	 DW    ?	       ;; code page id
KX_FIRST_STATE	 DB    ?	       ;;
				       ;;
KEYBSYS_XLAT_SECT   ENDS	       ;;
				       ;;
				       ;;
KEYBSYS_STATE	    STRUC	       ;;
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Translate Sections contains multiple States.
	     ;; A State contains the translate tables for a single
	     ;; shift state (IE lower case, upper case ....)
	     ;; The last State is a null State containing only the
	     ;; KX_STATE_LEN field with a value of 0.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
KX_STATE_LEN	 DW    ?	       ;; length of state section
KX_STATE_ID	 DB    ?	       ;; State ID
KX_KBD_TYPE	 DW    ?	       ;; Keyboard Type
KX_ERROR_CHAR	 DW    ?	       ;; Buffer entry for error character
KX_FIRST_XLAT	 DB    ?	       ;; XLAT tables begin here
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Each State consists of multiple translate tables.
	     ;; The last translate table within a state is a null
	     ;; table containing only the
	     ;; KX_XLAT_LEN field with a value of 0.
	     ;; Refer to KEYBSHAR.INC for translate table format.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE	    ENDS	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybdcl.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */



.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBDCL.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Common declarations for structures in procedures for KEYB.COM
;;
;; Change History:
;; ---------------
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
PARM_LIST	 STRUC		       ;;
;*******************CNS******************
;*******************CNS******************
    RET_CODE_1	    DB	 0	       ;;  \
    RET_CODE_2	    DB	 0	       ;;  |
    RET_CODE_3	    DB	 0	       ;;  |
;*******************CNS******************
    RET_CODE_4	    DB	 0	       ;;  |;AN000;
;*******************CNS******************
    LANGUAGE_PARM   DW	 ?	       ;;   }  PARAMETER
    CODE_PAGE_PARM  DW	 ?	       ;;  |	    LIST
    PATH_OFFSET     DW	 ?	       ;;  |
    PATH_LENGTH     DW	 0	       ;;  /
;*******************CNS******************
    ID_PARM	    DW	 ?	       ;AN000;
;*******************CNS******************
PARM_LIST	 ENDS		       ;;
				       ;;
DESIG_CP_STRUC	 STRUC		       ;;
    NUM_DESIGNATES  DW	 ?	       ;;
    NUM_FONTS	    DW	 ?	       ;;
    NUM_HW_CPS	    DW	 ?	       ;;
    DESIG_CP_ENTRY  DW	 ?	       ;;
DESIG_CP_STRUC	  ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybtbbl.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */



.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                              
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  KEYBTBBL.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					       ;;
	EXTRN	 TABLE_BUILD   :NEAR	       ;;
	EXTRN	 FIND_CP_TABLE :NEAR	       ;;
					       ;;
	EXTRN	 CPN_INVALID   :WORD	       ;;
	EXTRN	 SD_LENGTH     :WORD	       ;;
					       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                             
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBEQU.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing equates used by all KEYB modules.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
YES		EQU	1		;;
NO		EQU	0		;;
					;;
INT_2F_SUB_FUNC EQU	0ADH		;; our subfunction code for int 2f
SD		EQU	SHARED_DATA	;;
TSD		EQU	TEMP_SHARED_DATA;;
					;;
DLY_15ms	EQU	995		;; 15mS DELAY = (15000/15.086)
MOUSE_OBF	EQU	00100000b	;; AUX DATA PRESENT BIT AT STATUS_PORT
SCAN_CODE_CMD	EQU	0F0h		;; SELECT SCAN CODE SET COMMAND TO KB
					;;
FILE_BUFFER_SIZE equ    300             ;; buffer used for reading keyboard.sys
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybi2f.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
;
;                                           
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI2F.ASM
; ----------
;
; Description:
; ------------
;	Contains Interrupt 2F handler.
;
; Procedures Contained in This File:
; ----------------------------------
;	KEYB_INT_2F - Interupt 2F handler
;
; Include Files Required:
; -----------------------
;	INCLUDE KEYBEQU.INC
;	INCLUDE KEYBSHAR.INC
;M004	INCLUDE KEYBMAC.INC
;	INCLUDE KEYBCMD.INC
;	INCLUDE KEYBCPSD.INC
;	INCLUDE KEYBI9C.INC
;
; External Procedure References:
; ------------------------------
;	FROM FILE  ????????.ASM:
;		procedure - description????????????????????????????????
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------

	INCLUDE KEYBEQU.INC		
	INCLUDE KEYBSHAR.INC		
;M004	INCLUDE KEYBMAC.INC		
	INCLUDE KEYBCMD.INC		
	INCLUDE KEYBCPSD.INC		
	INCLUDE KEYBI9C.INC		
					
	PUBLIC KEYB_INT_2F		
					
	EXTRN  ERROR_BEEP:NEAR	 
					
CODE	SEGMENT PUBLIC 'CODE'	  
					
	ASSUME  CS:CODE,DS:nothing

; Module: KEYB_INT_2F
;
; Description:
;
; Input Registers:
;	AH = 0ADH
;	AL = 80,81,82,83	; M003
;
; Output Registers:
;	N/A
;
; Logic:
;	IF AH = 0ADh THEN	 (this call is for us)
;	Set carry flag to 0
;	IF AL = 80 THEN
;	  Get major and minor
;	  Get SEG:OFFSET of SHARED_DATA_AREA
;
;	IF AL = 81 THEN
;	  Get FIRST_XLAT_PTR
;	  FOR each table
;		IF code page requested = code page value at pointer THEN
;		Set INVOKED_CODE_PAGE
;		Set ACTIVE_XLAT_PTR
;		EXIT
;		ELSE
;		Get NEXT_SECT_PTR
;	  NEXT table
;	  IF no corresponding code page found THEN
;		Set carry flag
;
;	IF AL = 82 THEN
;	  IF BL = 00 THEN
;		Set COUNTRY_FLAG = 00
;	  ELSE IF BL = 0FFH THEN
;		Set COUNTRY_FLAG = 0FFH
;	  ELSE
;		Set carry flag
;
;	IF AL = 83 THEN              ; M003
;	  Return BL=COUNTRY_FLAG     ; M003
;
;	JMP to previous INT 2FH handler

CP_QUERY	EQU	80H		
CP_INVOKE	EQU	81H		
CP_LANGUAGE	EQU	82H		
CP_QLANGUAGE	EQU	83H		; M003
					
VERSION_MAJOR	EQU	01H		
VERSION_MINOR	EQU	00H		
					
CARRY_FLAG	EQU	01H		 
					
KEYB_INT_2F	PROC			

	cmp	ah,INT_2F_SUB_FUNC	; is it for us?
	jz	our_i2f_interrupt

i2f_chain:

;	Under DOS 5, it is always safe for us to assume that there was
;	  an existing Int2f vector for us to continue to.

	jmp	cs:sd.old_int_2f
					
our_i2f_interrupt:
	push	bp
	mov	bp,sp
	and	word ptr [bp]+6,not carry_flag ; pre-clear carry
	call	do_our_i2f		; pass bp.6 -> flags to functions

	pop	bp
	jmp	i2f_chain

do_our_i2f:
	CMP	AL,CP_QUERY		; Q..query CP?
	JNE	INT_2F_CP_INVOKE	; N..next

	MOV	AX,-1			; Y..process query
	mov	bx,(version_major shl 8) + version_minor
	MOV	DI,OFFSET SD		
	PUSH	CS
	POP	ES			
	ret
					
INT_2F_CP_INVOKE:			
	CMP	AL,CP_INVOKE		; Q..invoke CP?
	JNE	INT_2F_CP_LANGUAGE	; N..next
					
	MOV	SI,cs:SD.FIRST_XLAT_PTR	; Get FIRST_XLAT_PTR
					
INT_2F_NEXT_SECTION:			
	CMP	SI,-1			
	JE	INT_2F_ERROR_FLAG

	cmp	bx,cs:[SI].XS_CP_ID	; is this the code page we want?
	JNE	INT_2F_CP_INVOKE_CONT1

	MOV	cs:SD.ACTIVE_XLAT_PTR,SI ; IF Yes, Set the ACTIVE_XLAT_PTR
	MOV	cs:SD.INVOKED_CP_TABLE,BX ;	record new code page
	ret
					
INT_2F_CP_INVOKE_CONT1:
	MOV	SI,cs:[SI].XS_NEXT_SECT_PTR ; Chain to NEXT_SECT_PTR
	JMP	INT_2F_NEXT_SECTION	;	NEXT_SECTION
					
INT_2F_ERROR_FLAG:			
	mov	ax,1			; ***???  why do we return error code
;					;   only in this case?????
i2f_reterror:
	or	word ptr [bp]+6,carry_flag ; set carry to int2f caller
	ret
					
INT_2F_CP_LANGUAGE:			
	CMP	AL,CP_LANGUAGE		; Q..Set default language??
;M003	jnz	int2f_ret		; don't handle undefined functions
	jnz	INT_2F_CP_QLANG		; go check for query language ;M003
					
;	Now, if BL=0 or 0ffh, we'll set COUNTRY_FLAG to that value.

	inc	bl
	cmp	bl,2			; set carry if bl is legal
	dec	bl			; restore old value, preserve carry
	jnc	i2f_reterror		; done if error

	MOV	cs:COUNTRY_FLAG,BL	;	Set COUNTRY_FLAG to 0 or 0ffh

;	M003 -- added code

	ret


INT_2F_CP_QLANG:
	CMP	AL,CP_QLANGUAGE
	jnz	int2f_ret

	mov	bl,cs:COUNTRY_FLAG

;	M003 -- end added code

int2f_ret:
	ret
KEYB_INT_2F	ENDP			

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybi2f.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                                
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI2F.INC
;; ----------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI2F.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_INT_2F:NEAR      ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\commsubs.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
	TITLE	 MS DOS 5.0 - NLS Support - KEYB Command

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  MS DOS 5.0 - NLS Support - KEYB Command
;                                                    
;
;  File Name:  COMMSUBS.ASM
;  ----------
;
;  Description:
;  ------------
;	 Common subroutines used by NLS support
;
;  Documentation Reference:
;  ------------------------
;	 None
;
;  Procedures Contained in This File:
;  ----------------------------------
;
;	 FIND_HW_TYPE - Determine the keyboard and system unit types and
;	       set the corresponding flags.
;
;  Include Files Required:
;  -----------------------
;	 None
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  ????????.ASM:
;	      ????????? - ???????
;
;  Change History:
;  ---------------
;  Sept 1989 For 4.02.
;		Add required JMP $+2 between OUT/IN in KEYB_SECURE,
;		remove unnecessary code and re-document routine.
;		Remove unnecessary PUSH/POP's around call to KEYB_SECURE.
;		Fix bug in FIND_KEYB_TYPE of READ ID flags not being
;		cleared on PS/2's when keyboard is security locked.
;		Clean up BIOS DATA & Extended DATA area access, use ES:.
;		Arrange KB type checks into special case group and 8042.
;		Fix delay loop timeout bug at WT_ID with REFRESH BIT type
;		fixed timeout delay of 15ms.  When the KBX flag is set
;		by BIOS, the READ_ID is done and PORT 60h is ID_2 byte.
;		AT (FCh) type machines all have the Refresh Bit at 61h.
;		Change SND_DATA_AT proc to a general send command routine
;		with REFRESH BIT timout logic and move the P-Layout test
;		into FIND_KEYB_TYPE.  Allows P-kb on all 8042 systems.
;		Add untranslated ID_2 byte to P-layout support for newer
;		PS/2's with hardware logic instead of 8042 if AT type.
;
;  Feb 1990 For 4.03.
;  PTM 6660	Add default to PC_386 type for new/unsupported system.
;		Move determination code from KEYBI9C.ASM for original PC.
;		Add Patriot/Sebring determination code for HOT Replug
;		so that INT 9 handler can alter keyboard Scan Code set.
;		Unknown system default= PC_386 with Patriot/Sebring test.
;		Add EXT_122 check for 122 key keyboard to SYSTEM_FLAG.
;M005;  ;JP9009 - Sep. 1990  DBCS keyboard support
;M005;  ;JP9010 - Oct. 1990  Server password mode support
;M005;  ;JP9011 - Nov. 1990  Mumlock LED incorrectly turns on with P-keyboard,
;M005;                       if system is started up in server password mode
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC	FIND_SYS_TYPE
	PUBLIC	FIND_KEYB_TYPE
	PUBLIC	HW_TYPE 
	PUBLIC	SECURE_FL

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBCPSD.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBI9C.INC
	INCLUDE KEYBCMD.INC
	INCLUDE DSEG.INC
	INCLUDE POSTEQU.INC
        INCLUDE KEYBDCL.INC             ; M005 -- JP9009

CODE	SEGMENT PUBLIC 'CODE'

	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_SYS_TYPE
;
;  Description:
;      Determine the type of system we are running on.
;      SYSTEM_FLAG (in active SHARED_DATA) are set to
;      indicate the system type.
;      This routine is only called the first time KEYB is being installed.
;
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ROM	SEGMENT AT	0F000H
		ORG	0FFFBH
SYSROM_DATE	DW	?		; OFFSET OF ROM YEAR DIGIT

PC1DATE_ID	EQU	03138H		; YEAR ROM WAS RELEASED IN ASCII

		ORG	0FFFEH
ROMID		DB	?
					; SEGMENT F000. (F000:FFFE)

ROMPC1		EQU	0FFH		; ID OF PC1 hardware
ROMXT		EQU	0FEH		; ID OF PC-XT/PORTABLE hardware
ROMAT		EQU	0FCH		; ID OF PCAT
ROMXT_ENHAN	EQU	0FBH		; ID OF ENHANCED PCXT
ROMPAL		EQU	0FAH		; ID FOR PALACE
ROMLAP		EQU	0F9H		; ID FOR PC LAP (P-14)
ROM_RU_386	EQU	0F8H		; ID FOR ROUNDUP-386

ROM	ENDS

RTN_EXT_BIOS_DATA_SEG   EQU     0C1H    ; INT15H SUB FUNCTION  M005 -- JP9009
ROMEXT	SEGMENT AT 00000H		; ADDRESS SHOULD NOT BE FIXED AT 09FC0H
					; This just a dummy segment value, as
		ORG	0003BH		;  INT 15h - function C1 call will load
KEYBID1 	DB	?		;  ES: dynamically depending on where
					;  the ROMEXT segment is located.
					;  (9FC0 was only for old 640K systems)

;	M005 -- begin changes
;JP9009 ROMEXT  ENDS                    ;  ( ES:003B )
                ORG     00117H          ;                    ;JP9009
EXT_BIOS_DATA_KBD_ID    DW      ?       ; KEYBOARD ID(xxABH) ;JP9009
ROMEXT  ENDS                            ;                    ;JP9009
        EXTRN   SCAN_CODE_SET:BYTE      ; 01 for non SBCS keyboard(default)
                                        ; 81h or 82h for DBCS keyboard
                                        ; This value is used at hot replug.

;	M005 -- end changes

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_SYS_TYPE	       PROC  NEAR

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AX,SYSROM_DATE		; Get BIOS year date
	PUSH	AX			; save it on stack
	MOV	AL,ROMID		; Get hardware ID
	PUSH	AX			; save it

	PUSH	CS			; Set data seg back to code
	POP	DS
	ASSUME	DS:CODE 

	MOV	AH,092H 		; SET INVALID CALL FOR INT16  83 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 101/102
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_16	; Default is extended INT 16 support

	MOV	AH,0A2H 		; SET INVALID CALL FOR INT16  101 KEYS
	INT	16H			; CALL BIOS
	CMP	AH,80H			; IS EXTENDED INTERFACE THERE? 122/
	JA	CHECK_PC_NET		;  NO, SKIP FLAG

	OR	SD.SYSTEM_FLAG,EXT_122	; Also extended 122 keyboard support

CHECK_PC_NET:
	MOV	AH,30H			; GET DOS VERSION NUMBER
	INT	21H			; MAJOR # IN AL, MINOR # IN AH
	CMP	AX,0A03H		; SENSITIVE TO 3.10 OR >
	JB	CHECK_SYSTEM		; EARLIER VERSION OF DOS NOTHING
					; WAS ESTABLISHED FOR THIS SITUATION
	PUSH	ES			; Save ES just in case
	MOV	AX,3509H		; GET INT VECTOR 9 CONTENTS
	INT	21H			; ES:BX WILL = CURRENT INT9 VECTOR
					; SEE IF WE ARE THE 1ST ONES LOADED
	MOV	CX,ES			; INTO THE INT 9.  WITH DOS 3.1 WE CAN
	POP	ES			; HANDSHAKE WITH THE PC NETWORK BUT
	CMP	CX,0F000H		; BUT NO ONE ELSE CAN BE HOOK IN FIRST
	JE	CHECK_SYSTEM		; INT VECTOR 9 POINTS TO ROM, OK

	MOV	AX,0B800H		; ASK IF PC NETWORK IS INSTALLED
	INT	2FH
	or	al,al			; not installed if al=0
	JE	CHECK_SYSTEM		; SOMEBODY HAS LINKED THE INT VECTOR 9
					; & I'M GOING TO DROP RIGHT IN AS USUAL
	OR	SD.SYSTEM_FLAG,PC_NET	; INDICATE PC NET IS RUNNING

CHECK_SYSTEM:
	POP	AX			; get code back
	POP	BX			; get date back off of stack
					; Is the hardware a PCjr
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT		; IF (FE) OR (FF) THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF (FB) IT IS ALSO AN XT
	JNE	TEST_PC_AT		; IF not then check for next type

ITS_AN_XT:
	OR	SD.SYSTEM_FLAG,PC_XT	; system type
					; Check the ROM level in the system
	CMP	BX,PC1DATE_ID		; Is it the ORIGINAL PC1 version?
	JNE	SHORT FIND_SYS_END	; Done if not

	OR	SD.SYSTEM_FLAG,PC_81	; Else set the Original PC1 flag
	JMP	SHORT FIND_SYS_END

TEST_PC_AT:
					; Is the hardware an AT ?
	CMP	AL,ROMAT		; (FC)
	JNE	TEST_P12		; IF not then check for next type

	OR	SD.SYSTEM_FLAG,PC_AT	; system type with 8042 V2 interface

	JMP	SHORT FIND_SYS_END

TEST_P12:
	CMP	AL,ROMLAP		; IS this a Convertible (F9) (P12)?
	JNE	TEST_PAL		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_LAP	; system type
	JMP	SHORT FIND_SYS_END

TEST_PAL:
	CMP	AL,ROMPAL		; IS this a Model 30 (FA) (PALACE)?
	JNE	TEST_RU_386		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_PAL	; system type
	JMP	SHORT FIND_SYS_END

TEST_RU_386:
	CMP	AL,ROM_RU_386		; IS this a PS/2 with a 386 (F8)?
	JNE	TEST_SYS_NEW		; IF not then check for next type
	OR	SD.SYSTEM_FLAG,PC_386	; System type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring
	JMP	SHORT FIND_SYS_END

TEST_SYS_NEW:
					; ASSUME 8042 TYPE IF UNKNOWN
	OR	SD.SYSTEM_FLAG,PC_386	; Default system type with 8042 V3
	CALL	SP_8042 		; Determine if 8042 is Patriot/Sebring


FIND_SYS_END:

	RET

FIND_SYS_TYPE	    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: FIND_KEYB_TYPE
;
;  Description:
;      Determine the type of keyboard we are running on.
;      KEYB_TYPE (in SHARED_DATA) is set to indicate the keyboard type.
;      This routine is only called the first time KEYB is being installed.
;      It is called after the new Interrupt 9 handler is installed.
;
;  Input Registers:
;      DS - points to our data segment
;
;  Output Registers:
;      NONE
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

HW_TYPE 	DW	0
SECURE_FL	DB	0

;RESERVED ADDRESS 013h BITS 1 & 2

PASS_MODE	equ	00000001B
SERVER_MODE	equ	00000010B
SECRET_ADD	equ	13h
PORT_70 	equ	70h		; CMOS ADDRESS PORT
PORT_71 	equ	71h		; CMOS DATA PORT

ID_1		EQU	0ABh			; Keyboard ID_1 for FERRARI
TID_2		EQU	041h	   ;;AB41	; Keyboard ID_2 for FERRARI_G
ID_2U		EQU	083h	   ;;AB83	; Keyboard ID_2 for FERRARI_G
TID_2A		EQU	054h	   ;;AB54	; Keyboard ID_2 for FERRARI_P
ID_2AU		EQU	084h	   ;;AB84	; Keyboard ID_2 for FERRARI_P
ID_2JG		EQU	090h	   ;;AB90	; Keyboard ID_2 for JPN G
ID_2JP		EQU	091h	   ;;AB91	; Keyboard ID_2 for JPN P
ID_2JA		EQU	092h	   ;;AB92	; Keyboard ID_2 for JPN A

P_KB_ID 	DB	08

	extrn	pswitches:byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_KEYB_TYPE	      PROC  NEAR

	PUSH	ES
	PUSH	DS

	MOV	AX,DATA 
	MOV	ES,AX			; ES points to BIOS data
	ASSUME	ES:DATA 

	MOV	AX,ROM			; Set segmant to look at ROM
	MOV	DS,AX			;    using the data segment
	ASSUME	DS:ROM

	MOV	AL,ROMID		; Get hardware ID

	PUSH	CS			; Set data segment to CODE
	POP	DS
	ASSUME	DS:CODE 

	test	pswitches,2		; /e switch true?
	jz	no_force_enh
	or	es:KB_FLAG_3,KBX	; force enhanced kbd support on
no_force_enh:

	MOV	HW_TYPE,G_KB		; Default keyboard is G_KB

	CMP	AL,ROMLAP		; IS this a P12? (CONVERTABLE)
	JNE	TEST_PC_XT_2		; IF not then check for next type

	MOV	HW_TYPE,P12_KB		; IF yes then set flag
	JMP	FIND_KEYB_END		; Done

TEST_PC_XT_2:
					; Is the hardware a PC1 or XT ?
	CMP	AL,ROMXT
	JAE	ITS_AN_XT_2		; IF FE OR FF THEN ITS AN XT
	CMP	AL,ROMXT_ENHAN		; IF FB IT IS ALSO AN XT
	JNE	TEST_PS_30_2		; IF not then check for next type

ITS_AN_XT_2:
	TEST	ES:KB_FLAG_3,KBX	; IS THE ENHANCED KEYBOARD INSTALLED?
	JZ	ITS_AN_XT_3
;M005 ;JP9009 	JMP	SHORT FIND_KEYB_END	; Yes, exit
	jmp	FIND_KEYB_END	; M005 ;JP9009	; Yes, exit

ITS_AN_XT_3:
	MOV	HW_TYPE,XT_KB		; NO, normal XT keyboard
;M005 ;JP9009	JMP	SHORT FIND_KEYB_END
	jmp	FIND_KEYB_END	; M005 ;JP9009

TEST_PS_30_2:
	CMP	AL,ROMPAL		; IS this a PS/2 MODEL 30 or 25
	JNE	TEST_PC_AT_2		; IF not then check for next type

	MOV	AH,0C1H 		; Make extended bios data area call to
	INT	15H			; get the segment address for accessing
	JNC	ITS_AN_PS2_30		; the PALACE (only) keyboard byte area.
	JMP	SHORT FIND_KEYB_END	; JC   Assume Keyboard type G if error,
					; Otherwise EXTENDED BIOS DATA RETURNED
					; in the ES: and ES:003Bh is keyboard

ITS_AN_PS2_30:				; ID byte reserved for PALACE.
					; Set segment to look at extended ROM
	ASSUME	ES:ROMEXT		;    using the ES: segment
					; SEG ES: value returned by INT15h - C1
	MOV	AL,KEYBID1		; Get keyboard ID

	ASSUME	ES:NOTHING		; Don't use ES: for anything else

	AND	AL,0FH			; Remove high nibble
	CMP	AL,P_KB_ID		; IF keyboard is a FERRARI P THEN
	JNE	ITS_AN_PS2_30G
	OR	HW_TYPE,P_KB		;    Set the HW_TYPE flag to P keyboard

ITS_AN_PS2_30G: 
	JMP	SHORT FIND_KEYB_END	; Done

					; (Insert any more special cases here.)

;	At this point, all special case or older keyboard/system
;	types have been determined and HW_TYPE correctly set.
;	(PC, XT, XT Enhansed, CONVERTABLE, Model 30/25)
;
;	Assume now that the system has an 8042 type keyboard
;	interface and can be sent a READ ID command to determine
;	the type of keyboard installed.  The old AT keyboard is
;	handled as a special case of no security bits set and no
;	response to a READ ID command.	If security bits are set
;	and no KBX flag is set as a result of the READ ID, then
;	the interface is assumed to be locked and the default of
;	G-keyboard is taken as the keyboard ID can not be read.

TEST_PC_AT_2:

	ASSUME	ES:DATA 		; READ ID COMMAND TO TEST FOR A KBX

	MOV	ES:KB_FLAG_3,RD_ID	; INDICATE THAT A READ ID IS BEING DONE
					;  and clear KBX flag if set
	MOV	AL,0F2H 		; SEND THE READ ID COMMAND
	CALL	SND_DATA_AT
					; Wait 40ms for READ ID to complete
	MOV	CX,DLY_15ms		; Load count for 15ms (15,000/15.086)

WT_ID:					;      Fixed time wait loop on AT's
	TEST	ES:KB_FLAG_3,KBX	; TEST FOR KBX SET by BIOS interrupt 9h
	JNZ	DONE_AT_2		; Exit wait loop if/when flag gets set

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	WT_ID			; No, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	LOOP	WT_ID			; WAIT OTHERWISE

					; BE SURE READ ID FLAGS GOT RESET
	AND	ES:KB_FLAG_3,NOT RD_ID+LC_AB ; Clear READ ID state flags
					; As no KBX flag set
	CALL	KEYB_SECURE		; SEE IF THE KEYBOARD SECURITY IS
					; ACTIVATED AT THIS POINT
	JNC	ASSUME_AT		; SECURITY UNAVAILABLE OR AN AT KB

;	M005 -- begin changed section

        MOV     AL,0EEH                 ; We're in server password mode. We    ;JP9011
        CALL    SND_DATA_AT             ; should avoid keyboard from responding;JP9011
                                        ; to us with keyboard ID, when the     ;JP9011
                                        ; security is released. Otherwise, we  ;JP9011
                                        ; may be receiving keyboard ID bytes   ;JP9011
                                        ; as normal keyboard scan codes.       ;JP9011
                                        ; If we receive 'AB','54' as SCAN CODE,;JP9011
                                        ; we'll enter "SYSREQ key pressed"     ;JP9011
                                        ; state.                               ;JP9011
        OR      SD.SYSTEM_FLAG, SECURITY_ACTIVE ; THIS BIT BECOMES OFF WHEN    ;JP9010
                                        ;  SERVER PASSWORD MODE IS EXITED.     ;JP9010
        OR      ES:KB_FLAG_3, KBX       ; Behave as an extended keyboard.      ;JP9011
        MOV     SECURE_FL,1             ; SECURITY IS ACTIVE
        JMP     SHORT ASK_ROM_BIOS      ; TRY TO ASK ROM BIOS WHAT KEYBOARD    ;JP9010
                                        ; IS ATTACHED                          ;JP9010
;JP9010 JMP     SHORT FIND_KEYB_END     ; ASSUME IT IS A G_KB  WITH
                                        ; NUM LOCK OFF

;	M005 -- end changed section

ASSUME_AT:
	MOV	HW_TYPE,AT_KB		; NO, AT KBD if no KBX and no security
	JMP	SHORT FIND_KEYB_END	; EXIT

DONE_AT_2:				;      LAST PORT 60h VALUE IS ID_2 BYTE
	IN	AL,PORT_A		; Re-read last byte from keyboard input

;	M005 -- begin changed section

        CALL    SET_KBD_ID_TO_ROM_EXT   ; This is DBCS requirement. There are  ;JP9009
                                        ; five kinds of DBCS keyboards. We     ;JP9009
                                        ; need to distinguish them.            ;JP9009
        CMP     AL, ID_2JG              ; Was it old DBCS keyboards?           ;JP9009
        JAE     CHECK_WHAT_DBCS_KBD     ; Check what it is.                    ;JP9009
DONE_AT_FOR_G_P_TYPE:                                                          ;JP9011

;	M005 -- end changed section

	CMP	AL,TID_2A		; Was it the P-layout keyboard
	JE	DONE_AT_3		; Go set P type keyboard

	CMP	AL,ID_2AU		; Was it the P-layout untranslated
	JNE	DONE_AT_4		; Continue if not

DONE_AT_3:
	OR	HW_TYPE,P_KB		; Set HW_TYPE for P-layout keyboard
DONE_AT_4:
					; EXIT


FIND_KEYB_END:				; EXIT POINT
	MOV   AX,HW_TYPE		;      Get default or determined type

;	M005 -- begin changed section

;                                                                      ;JP9009
; New DBCS keyboards' ID is the same as that of SBCS 101/102 key       ;JP9009
; keyboard. So, we can distinguish them only by the language parameter ;JP9009
; string.                                                              ;JP9009
;                                                                      ;JP9009
        MOV     CX, WORD PTR [BP].LANGUAGE_PARM; Get language specified.       ;JP9009
        CMP     CX, 'PJ'                ; Japanese keyboard?                   ;JP9009
        JE      DBCS_KEYBOARD                                                  ;JP9009
        CMP     CX, 'OK'                ; Korea keyboard?                      ;JP9009
        JE      DBCS_KEYBOARD                                                  ;JP9009
        CMP     CX, 'RP'                ; PRC keyboard?                        ;JP9009
        JE      DBCS_KEYBOARD                                                  ;JP9009
        CMP     CX, 'AT'                ; Taiwan keyboard?                     ;JP9009
        JNE     SBCS_KEYBOARD                                                  ;JP9009
DBCS_KEYBOARD:                                                                 ;JP9009
        OR      AX, DBCS_KB             ; Set it as DBCS keyboard              ;JP9009
SBCS_KEYBOARD:                                                                 ;JP9009

;	M005 -- end changed section

	MOV   SD.KEYB_TYPE,AX		;      Place into shared data area

	POP   DS
	POP   ES
	RET

;	M005 -- begin changed section

ASK_ROM_BIOS:                                                                  ;JP9010
        PUSH    ES                      ;                                      ;JP9011
        MOV     AH, RTN_EXT_BIOS_DATA_SEG; GET EXTENDED BIOS DATA AREA SEGMENT ;JP9010
        INT     15H                     ;                                      ;JP9010
        ASSUME  ES:ROMEXT               ;                                      ;JP9009
        MOV     AL, BYTE PTR ES:EXT_BIOS_DATA_KBD_ID + 1;                      ;JP9010
        ASSUME  ES:DATA                 ;                                      ;JP9009
        POP     ES                      ; AL = HIGH BYTE OF KEYBOARD ID        ;JP9011
        JC      FIND_KEYB_END           ;      0 IF NOT SUPPORTED              ;JP9011
         CMP     AL, ID_2JG             ;                                      ;JP9010
         JB      DONE_AT_FOR_G_P_TYPE   ; WE GOT KEYB_TYPE FROM ROM BIOS, SO   ;JP9011
                                        ; RETURN TO NORMAL PROCEDURE           ;JP9011
CHECK_WHAT_DBCS_KBD:                                                           ;JP9009
        MOV     HW_TYPE, (DBCS_OLD_G_KB or DBCS_OLD_P_KB)                      ;JP9009
        CMP     AL, ID_2JA              ; Was it old DBCS A keyboard?          ;JP9009
        JNE     SET_SCAN_TABLE          ; Go if old DBCS G/P keyboard.         ;JP9009
        MOV     HW_TYPE, DBCS_OLD_A_KB                                         ;JP9009
SET_SCAN_TABLE:                                                                ;JP9009
        MOV     AL,82h                  ; SELECT SCAN CODE SET 82              ;JP9009
        TEST    SD.SYSTEM_FLAG,PS_8042   ; If in passthru mode without 8042    ;JP9009
        JZ      CHANGE_SCAN_TABLE       ; then set scan code set 81            ;JP9009
        MOV     AL,81h                  ; SELECT SCAN CODE SET 81              ;JP9009
CHANGE_SCAN_TABLE:                                                             ;JP9009
        MOV     SCAN_CODE_SET, AL       ; 81h or 82h for old DBCS keyboard     ;JP9009
                                        ; This is also used at hot replug.     ;JP9009
        CMP     SECURE_FL, 1            ; IF SECURITY ACTIVE, RETURN           ;JP9010
        JE      FIND_KEYB_END           ;                                      ;JP9010
        MOV     AL,SCAN_CODE_CMD        ; SELECT SCAN CODE SET COMMAND         ;JP9009
        CALL    SND_DATA_AT             ; SEND IT DIRECTLY TO THE KEYBOARD     ;JP9009
        MOV     AL, SCAN_CODE_SET       ; SCAN CODE SET                        ;JP9009
        CALL    SND_DATA_AT             ; SEND IT TO THE KEYBOARD              ;JP9009
        JMP     SHORT DONE_AT_4                                                ;JP9009


;  Module: SET_KBD_ID_TO_ROM_EXT
;  Description:
;       This routine sets keyboard ID to the corresponding extended BIOS
;       data area, even if ROM BIOS does not support 'Return Keyboard ID
;       (INT16H, AH=0AH)'. DBCS DOS supports it by some software if ROM
;       BIOS does not support it.
;       Input:
;               AL = High byte of keyboard ID
;                    Assumes low byte is 'ABH'.
;       Output:
;               none
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   PROC    NEAR    ;                                      ;JP9009
        PUSH    ES                      ;                                      ;JP9009
        PUSH    AX                      ;                                      ;JP9009
        MOV     AH, RTN_EXT_BIOS_DATA_SEG;                                     ;JP9009
        INT     15H                     ; Get extended BIOS data area          ;JP9009
        JC      NOT_SET_KBD_ID          ;                                      ;JP9009
            ASSUME  ES:ROMEXT           ; EXTENDED BIOS DATA AREA              ;JP9009
            MOV     AH, AL              ; AH = KBD ID 2ND BYTE                 ;JP9009
            MOV     AL, 0ABH            ; ASSUME KBD ID = xxABH                ;JP9009
            MOV     ES:EXT_BIOS_DATA_KBD_ID, AX; Set KBD ID to ext. BIOS data  ;JP9009
            ASSUME  ES:DATA             ; NORMAL BIOS DATA AREA                ;JP9009
NOT_SET_KBD_ID:                                                                ;JP9009
        POP     AX                      ;                                      ;JP9009
        POP     ES                      ;                                      ;JP9009
        RET                             ;                                      ;JP9009
SET_KBD_ID_TO_ROM_EXT   ENDP            ;                                      ;JP9009
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;                                      ;JP9009
;	M005 -- end changed section

FIND_KEYB_TYPE		ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Module: SND_DATA_AT
;
;  Description:
;	THIS ROUTINE HANDLES TRANSMISSION OF PC/AT COMMAND AND DATA BYTES
;	TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;	HANDLES ANY RETRIES IF REQUIRED
;
;
;  Input Registers:
;      DS - points to our data segment
;      ES - points to the BIOS data segment
;
;  Output Registers:
;
;  Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA_AT PROC   NEAR 
	PUSH	AX			; SAVE REGISTERS
	PUSH	BX			; *
	PUSH	CX
	MOV	BH,AL			; SAVE TRANSMITTED BYTE FOR RETRIES
	MOV	BL,3			; LOAD RETRY COUNT

;----  WAIT FOR 8042 INTERFACE NOT BUSY

SD0:					; RETRY entry
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; DISABLE INTERRUPTS
	AND	ES:KB_FLAG_2,NOT (KB_FE+KB_FA+KB_ERR)	; CLEAR ACK, RESEND AND
							; ERROR FLAGS
	MOV	AL,BH			; REESTABLISH BYTE TO TRANSMIT
	OUT	PORT_A,AL		; SEND BYTE

	JMP	$+2			; Delay for 8042 to accept command
	STI				; ENABLE INTERRUPTS

;-----	WAIT FOR COMMAND TO BE ACCEPTED BY KEYBOARD

	MOV	CX,DLY_15ms		; Timout for 15 ms (15,000/15.086)

SD1:					;	Fixed timout wait loop on AT's
	TEST	ES:KB_FLAG_2,KB_FE+KB_FA; SEE IF EITHER BIT SET
	JNZ	SD3			; IF SET, SOMETHING RECEIVED GO PROCESS

	IN	AL,PORT_B		; Read current system status port
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JE	SD1			; No, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	LOOP	SD1			; OTHERWISE WAIT

SD2:
	DEC	BL			; DECREMENT RETRY COUNT
	JNZ	SD0			; RETRY TRANSMISSION

	OR	ES:KB_FLAG_2,KB_ERR	; TURN ON TRANSMIT ERROR FLAG
	JMP	SHORT SD4		; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:
	TEST	ES:KB_FLAG_2,KB_FA	; SEE IF THIS IS AN ACKNOWLEDGE
	JZ	SD2			; IF NOT, GO RESEND

SD4:
	POP	CX			; RESTORE REGISTERS
	POP	BX
	POP	AX			; *
	RET				; RETURN, GOOD TRANSMISSION

SND_DATA_AT ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; KEYBOARD SECURITY LOGIC
;
; CHECK THE CMOS RAM BYTE AT CMOS LOCATION HEX 013H
; CHECK TO SEE IF EITHER BITS 1 (PASSWORD) OR 2 (SERVER MODE) ARE SET ON
; IF EITHER BIT IS SET ON THE SYSTEM IS A MOD 50 on up
;    RETurn CARRY FLAG ON indicating keyboard interface may be disabled.
; OTHERWISE NO SECURITY ENABLED OR THE SYSTEM IS AN OLD AT.
;    RETurn CARRY FLAG OFF indicating keyboard interface not disabled.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_SECURE	PROC	NEAR

	CLI				; DISABLE INTERRUPTS WHILE DOING
					; ADDRESS WRITE AND CMOS READ
	MOV	AL,SECRET_ADD		; WRITE ADDRESS OF CMOS BYTE WITH
	OUT	PORT_70,AL		; BITS FOR THE PASSWORD AND SERVER
					; MODE STATE TO PORT 70H
	JMP	$+2			; I/O Delay required
	IN	AL,PORT_71		; READ CMOS DATA BYTE WITH THE
					; PASSWORD AND SERVER SECURITY
	STI				; ENABLE THE INTERRUPTS
	TEST	AL,PASS_MODE+SERVER_MODE; CHECK & SEE IF THE BITS ARE ON
					; TEST clears CARRY flag
	JZ	SECURE_RET		; EXIT NO CARRY if neither set

	STC				; SET THE SECURITY FLAG ON
					; System is NOT an AT but the
SECURE_RET:				; keyboard interface maybe locked

	RET

KEYB_SECURE	ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; 8042 TYPE DETERMINATION
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SP_8042 PROC	NEAR			; Determine if 8042 is Patriot/Sebring
	PUSH	AX			; Save work register
	PUSH	CX			; Save count register

;	M005 -- begin changed section

        IN      AL, STATUS_PORT         ; In server password mode, no answer   ;JP9010
        TEST    AL, KYBD_INH            ; is returned from the following logic.;JP9010
        JZ      GET_FROM_ROM_BIOS       ; So, ask ROM BIOS.                    ;JP9010

;	M005 -- end changed section

	MOV	CX,24			; Limit AUX inputs if they are playing
					;  with the mouse while loading KEYB

SP__2:
	MOV	AL,DIS_KBD		; Disable command to clear 8042 output
	OUT	STATUS_PORT,AL		; Sending allows receive to complete
	STI				; Allow any pending AUX interrupt
	CALL	CHK_IBF 		; Wait for command to be accepted

	CLI				; Block interrupts until password set
	IN	AL,STATUS_PORT		; Read 8042 status byte
	TEST	AL,MOUSE_OBF		; Check for AUX data pending at output
	LOOPNZ	SP__2			; Loop till AUX inputs are cleared

	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	MOV	AL,20h			; Read 8042 controller's command byte
	OUT	STATUS_PORT,AL		; Send command to 8042 interface
	CALL	CHK_IBF 		; Wait for command to be accepted
	MOV	CX,DLY_15ms		; Timeout 15 milliseconds (15000/15.086

SP__5:
	IN	AL,PORT_B		; Read current refresh output bit
	AND	AL,REFRESH_BIT		; Mask all but refresh bit
	CMP	AL,AH			; Did it change? (or first pass thru)
	JZ	SHORT SP__5		; No?, wait for change, else continue

	MOV	AH,AL			; Save new refresh bit state
	IN	AL,STATUS_PORT		; Read status (command) port
	TEST	AL,OUT_BUF_FULL 	; Check for output buffer empty
	LOOPZ	SP__5			; Loop until OBF is on or timeout

	IN	AL,PORT_A		; Get the command byte
	TEST	AL,01000000b		; Check for translate bit on
	JNZ	SP_EXIT 		; Done if it is on to begin with

SP_EXIT_0:				; M005 ;JP9010
	OR	SD.SYSTEM_FLAG,PS_8042	; Set PATRIOT/SEBRING type 8042
					;  with Translate scan codes set OFF
SP_EXIT:
	MOV	AL,ENA_KBD		; Enable command for keyboard
	OUT	STATUS_PORT,AL		; Send to 8042
	CALL	CHK_IBF 		; Wait for command to be accepted
	IN	AL,PORT_A		; Read to clear int's on SX  ;PTR660243
	POP	CX			; Recover user register
	POP	AX			; Recover user register
	STI				; Enable inteerutps again
	RET				; Return to caller

;	M005 -- begin added section

RTN_SYSTEM_CONFIG       EQU     0C0H    ; INT15H SUB FUNCTION                  ;JP9010
FEATURE_INFO_2          EQU     006H    ; FEATURE INFO2 OFFSET IN CONFIG DATA  ;JP9010
NON_8042_CONTROLLER     EQU     004H    ; THIS BIT ON IF NON-8042 CONTROLLER   ;JP9010
GET_FROM_ROM_BIOS:                      ; WE CAN ONLY ASK ROM BIOS WHICH TYPE  ;JP9010
        PUSH    ES                      ; OF KEYBOARD CONTROLLER IS ATTACHED.  ;JP9010
        PUSH    BX                      ;                                      ;JP9010
        MOV     AH, RTN_SYSTEM_CONFIG   ;                                      ;JP9010
        INT     15H                     ;                                      ;JP9010
        JC      RTN_SYS_CONFIG_NOT_SUPPORTED; IN CASE NOT SUPPORTED, IT MUST   ;JP9010
                                        ; BE 8042. BELIEVE IT.                 ;JP9010
        TEST    BYTE PTR  ES:[BX+FEATURE_INFO_2], NON_8042_CONTROLLER          ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JNZ     SP_EXIT_0               ; IF NON-8042, SET THE FLAG            ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010
RTN_SYS_CONFIG_NOT_SUPPORTED:           ;                                      ;JP9010
        POP     BX                      ;                                      ;JP9010
        POP     ES                      ;                                      ;JP9010
        JMP     SHORT SP_EXIT           ;                                      ;JP9010

;	M005 -- end added section


SP_8042 ENDP

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybmsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBMSG.INC
;; ----------
;;
;; Root File Name:  KEYBCMD.ASM (KEYB.ASM)
;; ---------------
;;
;; Description:
;; ------------
;;	 External declarations for procedures in file KEYBCMD.ASM.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
	EXTRN	 ACT_KEYB_CP :BYTE     ;;
	EXTRN	 ACT_CON_CP  :BYTE     ;;
	EXTRN	 ACT_KEYB    :BYTE     ;;
	EXTRN	 INV_L	     :BYTE     ;;
	EXTRN	 INV_I	     :BYTE     ;;
	EXTRN	 INV_CP      :BYTE     ;;
	EXTRN	 INV_S	     :BYTE     ;;
	EXTRN	 INV_FN      :BYTE     ;;
	EXTRN	 INV_KEYB_Q  :BYTE     ;;
	EXTRN	 INV_CON_Q   :BYTE     ;;
	EXTRN	 NOT_DESIG   :BYTE     ;;
	EXTRN	 NOT_SUPP    :BYTE     ;;
	EXTRN	 NOT_VALID1  :BYTE     ;;
	EXTRN	 NOT_VALID2  :BYTE     ;;
	EXTRN	 WARNING_1   :BYTE     ;;
	EXTRN	 INV_COMBO   :BYTE     ;;
	EXTRN	 CR_LF	     :BYTE     ;;
	EXTRN	 MEMORY_OVERF :BYTE    ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keybtbbl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                           
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBTBBL.ASM
; ----------
;
; Description:
; ------------
;	Build SHARED_DATA_AREA with parameters specified
;	in KEYBCMD.ASM
;
; Documentation Reference:
; ------------------------
;	None
;
; Procedures Contained in This File:
; ----------------------------------
;	TABLE_BUILD: Build the header sections of the SHARED_DATA_AREA
;	STATE_BUILD: Build the state sections in the table area
;	FIND_CP_TABLE: Given the language and code page parm, determine the
;		offset of the code page table in KEYBOARD.SYS
;
; Include Files Required:
; -----------------------
;	KEYBSHAR.INC
;	KEYBSYS.INC
;	KEYBDCL.INC
;	KEYBI2F.INC
;
; External Procedure References:
; ------------------------------
;	None
;
; Change History:
; ---------------
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC TABLE_BUILD
	PUBLIC FIND_CP_TABLE
	PUBLIC CPN_INVALID
	PUBLIC SD_LENGTH

CODE	SEGMENT PUBLIC 'CODE'

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBSYS.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBDCL.INC
	INCLUDE COMMSUBS.INC
	INCLUDE KEYBCPSD.INC

	ASSUME  cs:CODE,ds:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: TABLE_BUILD
;
; Description:
;	Create the table area within the shared data structure. Each
;	table is made up of a descriptor plus the state sections.
;	Translate tables are found in the Keyboard definition file and are
;	copied into the shared data area by means of the STATE_BUILD
;	routine.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	bp - points at beginning of CMD_PARM_LIST
;
;	SHARED_DATA_STR must be allocated in memory
;
;	The following variables must also be passed from KEYB_COMMAND
;	 KEYBSYS_FILE_HANDLE is set to file handle after opening file
;	 CP_TAB_OFFSET is the offset of the CP table in the SHARED_DATA_AREA
;	 STATE_LOGIC_OFFSET is the offset of the state section in the SHARED_DATA_AREA
;	 SYS_CODE_PAGE is the binary representation of the system CP
;	 KEYBCMD_LANG_ENTRY_PTR is a pointer to the lang entry in KEY DEF file
;	 DESIG_CP_BUFFER is the buffer which holds a list of designated CPs
;	 DESIG_CP_OFFSET:WORD is the offset of that list
;	 NUM_DESIG_CP is the number of CPs designated
;	 FILE_BUFFER is the buffer to read in the KEY DEF file
;**********CNS ***************************************
;	 ID_PTR_SIZE is the size of the ID ptr structure
;**********CNS ***************************************
;	 LANG_PTR_SIZE is the size of the lang ptr structure
;	 CP_PTR_SIZE is the size of the CP ptr structure
;	 NUM_CP is the number of CPs in the KEYB DEF file for that lang
;	 SHARED_AREA_PTR segment and offset of the SHARED_DATA_AREA
;
;
; Output Registers:
;	cx - RETURN_CODE :=  0  - Table build successful
;			  1  - Table build unsuccessful - ERROR 1
;					(Invalid language parm)
;			  2  - Table build unsuccessful - ERROR 2
;					(Invalid Code Page parm)
;			  3  - Table build unsuccessful - ERROR 3
;					(Machine type unavaliable)
;			  4  - Table build unsuccessful - ERROR 4
;					(Bad or missing keyboard def file)
;			  5  - Table build unsuccessful - ERROR 5
;					(Memory overflow occurred)
; Logic:
;	Calculate Offset difference between TEMP and SHARED_DATA_AREAs
;	Get LANGUAGE_PARM and CODE_PAGE_PARM from parm list
;	Call FIND_CP_TABLE := Determine whether CP is valid for given language
;	IF CP is valid THEN
;	Store them in the SHARED_DATA_AREA
;	Prepare to read Keyboard definition file by LSEEKing to the top
;	READ the header
;	Store maximum table values for calculation of RES_END
;	Set di to point at TABLE_AREA within SHARED_DATA_AREA
;	FOR the state logic section of the specified language:
;		IF STATE_LOGIC_PTR is not -1 THEN
;		LSEEK to state logic section in keyboard definition file
;		READ the state logic section into the TABLE_AREA
;		Set the hot keyb scan codes
;		Set the LOGIC_PTR in the header
;	FOR the common translate section:
;		IF Length parameter is not 0 THEN
;		Build state
;		Set the COMMON_XLAT_PTR in the header
;	FOR the specific translate sections:
;	Establish addressibility to list of designated code pages
;	FOR each code page
;		IF CP_ENTRY_PTR is not -1 THEN
;		Determine offset of CP table in Keyb Def file
;		IF CP table not avaliable THEN
;			Set CPN_INVALID flag
;		ELSE
;			LSEEK to CPn state section in keyboard definition file
;			IF this is the invoked code page THEN
;			Set ACTIVE_XLAT_PTR in SHARED_DATA_AREA
;			Update RESIDENT_END ptr
;			Build state
;	Update RESIDENT_END ptr
;	End
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FB		EQU	FILE_BUFFER
KB_MASK		EQU	02H

FIRST_XLAT_TAB	DW	0
NEXT_SECT_PTR	DW	-1

MAX_COM_SIZE	DW	?
MAX_SPEC_SIZE	DW	?
MAX_LOGIC_SIZE	DW	?

RESIDENT_END_ACC DW	0
SA_HEADER_SIZE	DW	SIZE SHARED_DATA_STR;
PARM_LIST_OFFSET DW	?
;********************CNS*************************
TB_ID_PARM	DW	0
;********************CNS*************************
TB_LANGUAGE_PARM DW	0
TB_CODE_PAGE_PARM DW	0

CPN_INVALID	DW	0

KEYB_INSTALLED	DW	0
SD_AREA_DIFFERENCE DW	0
SD_LENGTH	DW	2000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TABLE_BUILD	  PROC NEAR

	mov	ax,OFFSET SD_SOURCE_PTR	; Setup the difference
	sub	ax,OFFSET SD_DesT_PTR	; value used to calculate
	mov	SD_AREA_DIFFERENCE,ax	; new ptr values for
					;  SHARED_DATA_AREA
	mov	ax,[bp].ID_PARM		; Get id parameter
	mov	TB_ID_PARM,ax
	mov	ax,[bp].LANGUAGE_PARM	; Get language parameter
	mov	TB_LANGUAGE_PARM,ax
	mov	bx,[bp].CODE_PAGE_PARM	; Get code page parameter
	mov	TB_CODE_PAGE_PARM,bx
					; Make sure code page is
	call	FIND_CP_TABLE		;   valid for the language
	jcxz	TB_CHECK_CONTINUE1	; IF code page is found
	jmp	TB_ERROR6		;  for language THEN

TB_CHECK_CONTINUE1:
	mov	bp,OFFSET SD_SOURCE_PTR	; Put language parm and
	mov	ax,TB_ID_PARM		;  id parm and..
	mov	es:[bp].INVOKED_KBD_ID,ax
	mov	bx,TB_CODE_PAGE_PARM
	mov	es:[bp].INVOKED_CP_TABLE,bx	; code page parm into the
	mov	ax,TB_LANGUAGE_PARM		;  SHARED_DATA_AREA
	mov	word ptr es:[bp].ACTIVE_LANGUAGE,ax

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	xor	dx,dx			; LSEEK file pointer
	xor	cx,cx			;  back to top of file
	mov	ax,4200h		; If no problem with
	int	21H			;  Keyboard Def file THEN
	jnc	TB_START
	jmp	TB_ERROR4

TB_START:				; Else
	xor	di,di			; Set number
;M006	LEA	cx,[di].KH_MAX_LOGIC_SZ+2 ;	bytes to read header
	lea	cx,[di].KH_NUM_ID+2	; M006 -- read a few extra entries
	mov	dx,OFFSET FILE_BUFFER	; Move contents into file buffer
	mov	ah,3FH			;  READ
	push	cs
	pop	ds
	int	21H			;  File
	jnc	TB_CONTINUE1
	jmp	TB_ERROR4

TB_CONTINUE1:
	cmp	cx,ax
	je	TB_ERROR_CHECK1
;M002	mov	cx,4
;M002	jmp	TB_CPN_INVALID
tb_err4_j:				; M006
	jmp	TB_ERROR4		; M002

TB_ERROR_CHECK1:
	cmp	FB.KH_NUM_ID,0		; M006 -- is it an old KEYBOARD.SYS?
	jz	tb_err4_j		; M006 --  bomb out if so

	mov	cx,FB.KH_MAX_COM_SZ	; Save values for RESIDENT_END
	mov	MAX_COM_SIZE,cx		;  calculation
	mov	cx,FB.KH_MAX_SPEC_SZ
	mov	MAX_SPEC_SIZE,cx
	mov	cx,FB.KH_MAX_LOGIC_SZ
	mov	MAX_LOGIC_SIZE,cx


	LEA	di,[bp].TABLE_AREA	; Point at beginning of table area
					;		di ---> TABLE_AREA

;	M002 -- begin added section
;
;	Before we go ANY further, let's see if we actually have room
;	   for our worst case memory allocation needs.  Notice that
;	   we're actually trusting the MAX fields from the KEYBOARD
;	   definition file.  If it lies to us and has fields bigger
;	   than these MAX values, we may crash over memory we don't
;	   own during initialization.

	mov	ax,NUM_DESIG_CP
	mul	MAX_SPEC_SIZE
	or	dx,dx			; error if overflowed 16 bits
	jnz	mem_alloc_err

	add	ax,SA_HEADER_SIZE
	jc	mem_alloc_err
	add	ax,MAX_LOGIC_SIZE
	jc	mem_alloc_err
	add	ax,MAX_COM_SIZE
	jc	mem_alloc_err

;	Note that ax could be used for the RESIDENT_END_ACC value,
;	  but since this check is being added late in the testing
;	  cycle, we'll leave that calculation alone.

	add	ax,di			; get the ending offset of temp buffer
	jc	mem_alloc_err

	add	ax,15
	jc	mem_alloc_err
	mov	cl,4			; convert to paragraph
	shr	ax,cl
	mov	cx,ax
	mov	ax,cs			; get our code segment
	add	ax,cx			; this is our ending segment
	cmp	ax,cs:[2]		; compare against psp:2
	jb	mem_alloc_ok
mem_alloc_err:
	jmp	TB_ERROR5
mem_alloc_ok:

;	M002 -- end added section

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR STATE LOGIC SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_STATE_BEGIN:
	mov	bx,KEYBSYS_FILE_HANDLE		; Get handle
	mov	cx,word ptr STATE_LOGIC_OFFSET+2
	mov	dx,word ptr STATE_LOGIC_OFFSET	; Get LSEEK file pointer

	cmp	dx,-1			; If no language table then
	jnz	TB_STATE_CONTINUE1	;  jump to code page begin
	jmp	TB_CP_BEGIN

TB_STATE_CONTINUE1:			; Else
	mov	ax,4200h		; LSEEK to begin of state logic sect
	int	21H			;	Keyboard Def file THEN
	jnc	TB_STATE_CONTINUE2
	jmp	TB_ERROR4

TB_STATE_CONTINUE2:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	sub	di,SD_AREA_DIFFERENCE	; Adjust for relocation
	mov	es:[bp].LOGIC_PTR,di	; Set because this is state
	add	di,SD_AREA_DIFFERENCE	; Adjust for relocation

	mov	cx,4			; Set number bytes to read length and
					;	special features
	mov	dx,OFFSET FILE_BUFFER	; Set the buffer address
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	jnc	TB_STATE_CONTINUE3
	jmp	TB_ERROR4

TB_STATE_CONTINUE3:
	cmp	cx,ax
	je	TB_ERROR_CHECK2
;M002	mov	cx,4
;M002	jmp	TB_CPN_INVALID
	jmp	TB_ERROR4

TB_ERROR_CHECK2:
	mov	ax,FB.KT_SPECIAL_FEATURES	; Save the special features in the
	mov	es:[bp].SPECIAL_FEATURES,ax	;	SHARED_DATA_AREA


	mov	es:[bp].HOT_KEY_ON_SCAN,F1_SCAN
	mov	es:[bp].HOT_KEY_OFF_SCAN,F2_SCAN

HOT_KEY_SET:
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	or	cx,cx
	jnz	TB_STATE_CONTINUE4

	dec	cx			; cx = -1
	mov	es:[bp].LOGIC_PTR,cx
	jmp	short SB_COMM_BEGIN

TB_STATE_CONTINUE4:
	mov	es:[di],cx		; Store length parameter in
	add	di,2			;	  SHARED_DATA_AREA
	mov	cx,FB.KT_SPECIAL_FEATURES ; Save the special features
	mov	es:[di],cx
	add	di,2
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	sub	cx,4			; Adjust for what we have already read
	mov	dx,di			; Set the address of SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH			; Read logic section from the
	int	21H			;	Keyb Def file
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE5
	jmp	TB_ERROR4

TB_STATE_CONTINUE5:
	cmp	cx,ax
	je	TB_ERROR_CHECK3
;M002	mov	cx,4
;M002	jmp	TB_CPN_INVALID
	jmp	TB_ERROR4

TB_ERROR_CHECK3:
	add	di,cx			; Set di at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
	mov	cx,RESIDENT_END_ACC	;	di --->
	add	cx,SA_HEADER_SIZE
	add	cx,MAX_LOGIC_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh Resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR COMMON TRANSLATE SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SB_COMM_BEGIN:
	mov	cx,SIZE KEYBSYS_XLAT_SECT-1 ; Set number bytes to read header
	mov	dx,di			; Set the SHARED_DATA_AREA address
	push	es
	pop	ds
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE6
	jmp	TB_ERROR4

TB_STATE_CONTINUE6:
	mov	cx,es:[di].KX_SECTION_LEN; Set length of section to read
	jcxz	TB_CP_BEGIN

	mov	cx,word ptr SB_STATE_OFFSET	;  Save the offset of the
	add	cx,FB.KT_LOGIC_LEN
	mov	word ptr SB_STATE_OFFSET,cx	;  Save the offset of the
	sub	di,SD_AREA_DIFFERENCE		;   Adjust for relocation
	mov	es:[bp].COMMON_XLAT_PTR,di
	add	di,SD_AREA_DIFFERENCE		;   Adjust for relocation

	call	STATE_BUILD
					; di set at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
					;		COMMON_XLAT_SECTION
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_COM_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	FOR alL DESIGNATED OR INVOKED CODE PAGES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_CP_BEGIN:						; Get the offset to
	mov	cx,OFFSET DESIG_CP_BUFFER.DESIG_CP_ENTRY ; the beginning of the
	mov	DESIG_CP_OFFSET,cx			; table of designated
							; code pages
TB_CPN_BEGIN:
	mov	ax,word ptr es:[bp].ACTIVE_LANGUAGE  ; Get the active language
	mov	cx,NUM_DESIG_CP		; Get the number of CPs
	or	cx,cx			; IF we have done all requested CPs
	jnz	TB_CPN_VALID1
	jmp	TB_DONE			;	Then done

TB_CPN_VALID1:
	mov	si,[DESIG_CP_OFFSET]
	mov	bx,[si]			; Get the CP
	cmp	bx,-1
	jnz	TB_CPN_CONTINUE1
	jmp	short TB_CPN_REPEAT

TB_CPN_CONTINUE1:			; ELSE
	push	di
	call	FIND_CP_TABLE		;	Find offset of code page table
	pop	di

	jcxz	TB_CPN_VALID		;  brif valid code page for language
	mov	CPN_INVALID,cx		;	Set flag and go to next CP
	jmp	short TB_CPN_REPEAT	; Else

TB_CPN_VALID:
	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	cx,word ptr CP_TAB_OFFSET+2  ; Get offset of the code page
	mov	dx,word ptr CP_TAB_OFFSET ;	in the Keyb Def file

	cmp	dx,-1			; Test if code page is blank
	jnz	TB_CPN_CONTINUE2
	jmp	short TB_CPN_REPEAT	; If it is then go get next CP

TB_CPN_CONTINUE2:
	mov	ax,4200h		; LSEEK to table in Keyb Def file
	int	21H			;	Keyb Def file Then
	jnc	TB_CPN_CONTINUE3
	jmp	TB_ERROR4

TB_CPN_CONTINUE3:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	mov	cx,TB_CODE_PAGE_PARM	;  If this code page is the
	mov	si,[DESIG_CP_OFFSET]	;	invoked code page
	cmp	cx,[si]
	jnz	TB_CPN_CONTINUE4	;  Then

	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].ACTIVE_XLAT_PTR,di ;  Set active xlat section
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE4:
	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].FIRST_XLAT_PTR,di ;	  Set flag
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE5:
	CALL	STATE_BUILD		;  Build state
					;		TABLE_AREA
	jcxz	TB_CPN_REPEAT		;    COMMON_XLAT_SECTION,SPECIFIC...
	jmp	short TB_ERROR4	;M006	;	di --->
;M006	jmp	TB_ERROR4		;	di --->

TB_CPN_REPEAT:
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_SPEC_SIZE	;  Refresh resident end size
	mov	RESIDENT_END_ACC,cx

	mov	cx,DESIG_CP_OFFSET
	add	cx,2			; Adjust offset to find next code page
	mov	DESIG_CP_OFFSET,cx

	mov	cx,NUM_DESIG_CP		; Adjust the number of code pages left
	dec	cx
	mov	NUM_DESIG_CP,cx

	jmp	TB_CPN_BEGIN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_DONE:
	mov	cx,RESIDENT_END_ACC	;  Set final calculated value
	add	cx,bp
	sub	cx,SD_AREA_DIFFERENCE		;  Adjust for relocation
	mov	es,word ptr SHARED_AREA_PTR	;	Set segment
	mov	bp,word ptr SHARED_AREA_PTR+2
	cmp	cx,es:[bp].RESIDENT_END
	JNA	TB_DONE_CONTINUE1
	jmp	short TB_ERROR5

TB_DONE_CONTINUE1:
	cmp	es:[bp].RESIDENT_END,-1
	jnz	DONT_REPLACE
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR
	mov	es:[bp].RESIDENT_END,cx ;  Save resident end
	jmp	short CONTINUE_2_END

DONT_REPLACE:
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR

CONTINUE_2_END:
	sub	cx,OFFSET SD_DesT_PTR	;  Calculate # of bytes to copy
	mov	SD_LENGTH,cx

	xor	cx,cx			;  Set valid completion return code
	mov	TB_RETURN_CODE,cx
	ret

;	M002 -- dead code deleted.  The following label was only
;		branched to with cx==4.  Those calls were all
;		replaced with direct JMPs to TB_ERROR4, which was
;		assumed to set cx=4 in other places anyway.

;M002	TB_CPN_INVALID:
;M002		cmp	cx,1			;  Set error 1 return code
;M002		jnz	TB_ERROR2
;M002		mov	TB_RETURN_CODE,cx
;M002		ret
;M002	
;M002	TB_ERROR2:
;M002		cmp	cx,2			;  Set error 2 return code
;M002		jnz	TB_ERROR3
;M002		mov	TB_RETURN_CODE,cx
;M002		ret
;M002	
;M002	TB_ERROR3:
;M002		cmp	cx,3			;  Set error 3 return code
;M002		jnz	TB_ERROR4
;M002		mov	TB_RETURN_CODE,cx
;M002		ret
;M002	

TB_ERROR4:
;M002	cmp	cx,4			;  Set error 4 return code
;M002	jnz	TB_ERROR5
	mov	cx,4		; M002	; set error 4 return code
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR5:
	mov	cx,5			;  Set error 5 return code
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR6:
	mov	bx,TB_CODE_PAGE_PARM
	mov	cx,6
	mov	TB_RETURN_CODE,cx	;  Set error 6 return code
	ret

TABLE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: STATE_BUILD
;
; Description:
;	Create the state/xlat section within the specific translate section.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	SB_STATE_OFFSET - offset to the beginning of the info in Keyb Def SYS
;	di - offset of the beginning of the area used to build states
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	di  - offset of the end of the area used by STATE_BUILD
;
;	cx - Return Code := 0  -  State build successful
;			    4  -  State build unsuccessful
;				    (Bad or missing Keyboard Def file)
;
; Logic:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

END_OF_AREA_PTR	DW	0
SB_FIRST_STATE	DW	0
SB_STATE_LENGTH	DW	0
SB_STATE_OFFSET	DD	0
STATE_LENGTH	DW	0
RESTORE_BP	DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

STATE_BUILD	  PROC NEAR

	mov	si,di			;  Get the tally pointer
	mov	END_OF_AREA_PTR,di	;  Save pointer

	mov	RESTORE_bp,bp		;  Save the base pointer

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr SB_STATE_OFFSET	; LSEEK file pointer
	mov	cx,word ptr SB_STATE_OFFSET+2	;	back to top of XLAT table
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyboard Def file THEN
	jnc	SB_FIRST_HEADER
	jmp	SB_ERROR4

SB_FIRST_HEADER:
	xor	bp,bp
	LEA	cx,[bp].KX_FIRST_STATE	; Set number of bytes to read header
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; read in the header
	int	21H
	push	cs
	pop	ds
	jnc	SB_HEAD_CONTINUE1
	jmp	SB_ERROR4

SB_HEAD_CONTINUE1:
	mov	dx,NEXT_SECT_PTR
	cmp	dx,-1
	je	SB_HEAD_CONTINUE2
	sub	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE2:
	mov	es:[di].XS_NEXT_SECT_PTR,dx
	cmp	dx,-1
	je	SB_HEAD_CONTINUE3
	add	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE3:
	add	di,cx			; Update the di pointer

SB_NEXT_STATE:
	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_STATE_ID	;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1:
	push	cs			; Reset the data segment
	pop	ds
	mov	cx,es:[di].KX_STATE_LEN ; If the length of the state section
	mov	STATE_LENGTH,cx
	add	di,2			;  is zero then done
	jcxz	SB_DONE

	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_FIRST_XLAT-2 ;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1A:
	push	cs			; Reset the data segment
	pop	ds
	sub	di,2
	mov	ax,es:[di].XS_KBD_TYPE	; Get the keyboard type def
	test	ax,HW_TYPE		; Does it match our hardware?
	JNZ	SB_CONTINUE2
	mov	dx,es:[di].XS_STATE_LEN ; No, then
	LEA	cx,[bp].KX_FIRST_XLAT
	sub	dx,cx
	xor	cx,cx
	mov	ah,42H			;  LSEEK past this state
	mov	al,01H
	int	21H
	jmp	SB_NEXT_STATE

SB_CONTINUE2:				; Yes, then
	mov	ax,SIZE STATE_STR-1
	add	di,ax			; Set PTR and end of header

SB_XLAT_TAB_BEGIN:			; Begin getting xlat tables
	mov	bx,KEYBSYS_FILE_HANDLE
	LEA	dx,[bp].KX_FIRST_XLAT	; Adjust for what we have already read
	mov	cx,STATE_LENGTH
	sub	cx,dx
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; Read in the xlat tables
	int	21H
	push	cs
	pop	ds
	jnc	SB_CONTINUE4
	jmp	short SB_ERROR4

SB_CONTINUE4:
	cmp	cx,ax
	je	SB_ERROR_CHECK1
	jmp	short SB_ERROR4

SB_ERROR_CHECK1:
	add	di,cx			; Update the end of area ptr

	mov	si,di
	jmp	SB_NEXT_STATE

SB_DONE:
	mov	ax,-1
	mov	si,END_OF_AREA_PTR
	mov	NEXT_SECT_PTR,si

	mov	bp,RESTORE_bp
	ret

SB_ERROR1:
	mov	cx,1
	ret

SB_ERROR2:
	mov	cx,2
	ret

SB_ERROR3:
	mov	cx,3
	ret

SB_ERROR4:
	mov	cx,4
	ret


STATE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: FIND_CP_TABLE
;
; Description:
;	Determine the offset of the specified code page table in KEYBOARD.SYS
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	ax - ASCII representation of the language parm
;	bx - binary representation of the code page
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	CP_TAB_OFFSET - offset of the CP table in KEYBOARD.SYS
;
;	cx - Return Code := 0  -  State build successful
;			    2  -  Invalid Code page for language
;			    4  -  Bad or missing Keyboard Def file
; Logic:
;
;	READ language table
;	IF error in reading file THEN
;	 Display ERROR message and EXIT
;	ELSE
;	 Use table to verify language parm
;	 Set pointer values
;	 IF code page was specified
;		READ language entry
;		IF error in reading file THEN
;		  Display ERROR message and EXIT
;		ELSE
;		  READ Code page table
;		  IF error in reading file THEN
;			Display ERROR message and EXIT
;		  ELSE
;			Use table to get the offset of the code page parm
;	ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_PARM	  DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_TABLE	  PROC  NEAR


	mov	FIND_CP_PARM,bx	  ; Save Code page

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr KEYBCMD_LANG_ENTRY_PTR ; LSEEK file pointer
	mov	cx,word ptr KEYBCMD_LANG_ENTRY_PTR+2 ;  to top of language entry
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyb Def file Then
	jnc	FIND_BEGIN
	jmp	short FIND_CP_ERROR4

FIND_BEGIN:
	mov	di,ax
	mov	cx,SIZE KEYBSYS_LANG_ENTRY-1	; Set number
						;	bytes to read header
	mov	dx,OFFSET FILE_BUFFER
	mov	ah,3FH			; Read language entry in
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID4		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID4:

;****************************** CNS ****************************************
	xor	ah,ah
	mov	al,FB.KL_NUM_CP
;****************************** CNS ****************************************

	mov	NUM_CP,ax		; Save the number of code pages
	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	mov	dx,OFFSET FILE_BUFFER	; Establish beginning of buffer
	mov	cx,ax
	cmp	cx,FILE_BUFFER_SIZE	; Make sure buffer is not to small
	jbe	FIND_VALID5
	jmp	short FIND_CP_ERROR4

FIND_VALID5:
	mov	ah,3FH			; Read code page table from
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID6		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID6:
	mov	cx,NUM_CP		;  Number of valid codes
	mov	di,OFFSET FILE_BUFFER	;  Point to correct word in table

F_SCAN_CP_TABLE:			; FOR code page parm
	mov	ax,FIND_CP_PARM		;	Get parameter
	cmp	[di].KC_CODE_PAGE,ax	;	Valid Code ??
	je	F_CODE_PAGE_FOUND	; If not found AND more entries THEN
	add	di,LANG_PTR_SIZE	;	Check next entry
	loop	F_SCAN_CP_TABLE		;    Decrement count & loop


	jmp	short FIND_CP_ERROR2	;  Display error message

F_CODE_PAGE_FOUND:
	mov	ax,word ptr [di].KC_ENTRY_PTR
	mov	word ptr CP_TAB_OFFSET,ax
	mov	ax,word ptr [di].KC_ENTRY_PTR+2
	mov	word ptr CP_TAB_OFFSET+2,ax

	xor	cx,cx
	ret

FIND_CP_ERROR1:
	mov	cx,1
	ret

FIND_CP_ERROR2:
	mov	cx,2
	ret

FIND_CP_ERROR3:
	mov	cx,3
	ret

FIND_CP_ERROR4:
	mov	cx,4
	ret

FIND_CP_TABLE	 ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE	ENDS
	END	TABLE_BUILD

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybsys.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                         
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSYS.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions and equates
;;	 for the KEYBOARD.SYS file.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; File header - contains pointers to keyboard tables for each language
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_HEADER	STRUC		       ;;
				       ;;
KH_SIGNATURE	DB   0FFh,'KEYB   '    ;; signature
KH_RESV_1	DB   8 DUP(0)	       ;; reserved
KH_MAX_COM_SZ	DW   0	      ;AN000;**chg  ;; maximum size of Common Xlat Sect
KH_MAX_SPEC_SZ	DW   0	      ;AN000;;**chg   ;; max size of Specific Xlat Sect
KH_MAX_LOGIC_SZ DW   0	      ;AN000;;**chg   ;; max size of State Logic
KH_RESV_2	Dw   0	      ;AN000;;**chg   ;; reserved CNS
KH_NUM_ID	Dw   0		       ;AN000;;; ************* CNS
KH_NUM_LANG	DW   0		       ;; number of languages
KH_LANG_PTRS	DB   0		       ;; language pointers start here
;********************* CNS **********************
;KH_NUM_ID	  DW   0		 ;; number of languages
;KH_ID_PTRS	  DB   0		 ;; id pointers start here
;********************* CNS **********************
KEYBSYS_HEADER	ENDS		       ;;
;******************CNS*******************
KEYBSYS_ID_PTRS STRUC

KP_ID_CODE	DW   0		       ;AN000;
KP_LANG_PTR	DD   0		       ;AN000;

KEYBSYS_ID_PTRS ENDS
				       ;;
;*****************CNS********************
KEYBSYS_LANG_PTRS STRUC 	       ;;
				       ;; Next two entries repeat:
KP_LANG_CODE	DW   0		       ;;   language code
KP_ENTRY_PTR	DD   0		       ;;   language entry pointer
				       ;;
KEYBSYS_LANG_PTRS ENDS		       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Language Entry - pointed to by KH_ENTRY_PTR in KEYBSYS_HEADER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_LANG_ENTRY  STRUC	       ;;
				       ;;
KL_LANG_CODE	DW   'XX'              ;; language code
KL_ID_CODE	DW   0		       ;; reserved (ID CODE)
KL_LOGIC_PTR	DD   0	       ;AC000;;**chg  ;; State Logic pointer
KL_NUM_ID	DB   0	       ;AN000;;CNS    ;; number of valid IDs for this lang
KL_NUM_CP	DB   0		       ;; number of valid CPs for this lang
KL_CP_PTRS	DB   0		       ;; CP table pointers start here
				       ;;
KEYBSYS_LANG_ENTRY  ENDS	       ;;
				       ;;
KEYBSYS_CP_PTRS     STRUC	       ;;
				       ;; Next two entries repeat:
KC_CODE_PAGE	DW   0		       ;;  code page
KC_ENTRY_PTR	DD   0		       ;; ptr to Specific Translate Section
				       ;;
KEYBSYS_CP_PTRS     ENDS	       ;;
				       ;;
				       ;;
;; Everything from here down is new
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic - pointed to by KL_LOGIC_PTR in KEYBSYS_LANG_ENTRY
;; Common Translate Section follows immediately after the State Logic.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE_LOGIC STRUC	       ;;
				       ;;
KT_LOGIC_LEN	DW   ?		       ;; length of state logic
KT_SPECIAL_FEATURES  DW  ?	       ;; Special Features (see KEYBSHAR.INC)
KT_LOGIC_CMDS	DB   0		       ;; state logic commands begin here
				       ;;
KEYBSYS_STATE_LOGIC ENDS	       ;;
				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Section - Common and Specific Translate Sections
;; are both in this form.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_XLAT_SECT   STRUC	       ;;
				       ;;
KX_SECTION_LEN	 DW    ?	       ;; Length of this section
KX_CP_ID	 DW    ?	       ;; code page id
KX_FIRST_STATE	 DB    ?	       ;;
				       ;;
KEYBSYS_XLAT_SECT   ENDS	       ;;
				       ;;
				       ;;
KEYBSYS_STATE	    STRUC	       ;;
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Translate Sections contains multiple States.
	     ;; A State contains the translate tables for a single
	     ;; shift state (IE lower case, upper case ....)
	     ;; The last State is a null State containing only the
	     ;; KX_STATE_LEN field with a value of 0.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
KX_STATE_LEN	 DW    ?	       ;; length of state section
KX_STATE_ID	 DB    ?	       ;; State ID
KX_KBD_TYPE	 DW    ?	       ;; Keyboard Type
KX_ERROR_CHAR	 DW    ?	       ;; Buffer entry for error character
KX_FIRST_XLAT	 DB    ?	       ;; XLAT tables begin here
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	     ;; Each State consists of multiple translate tables.
	     ;; The last translate table within a state is a null
	     ;; table containing only the
	     ;; KX_XLAT_LEN field with a value of 0.
	     ;; Refer to KEYBSHAR.INC for translate table format.
	     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
KEYBSYS_STATE	    ENDS	       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\parser.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
PAGE	,132
TITLE	PARSE CODE AND CONTROL BLOCKS FOR KEYB.COM

;****************** START OF SPECIFICATIONS **************************
;
;  MODULE NAME: PARSER.ASM
;
;  DESCRIPTIVE NAME: PARSES THE COMMAND LINE PARAMETERS FOR KEYB.COM
;
;  FUNCTION: THE COMMAND LINE IN THE PSP IS PARSED FOR PARAMETERS.
;
;  ENTRY POINT: PARSE_PARAMETERS
;
;  INPUT: BP POINTS TO PARAMETER LIST
;	  DS & ES POINT TO PSP
;
;  AT EXIT:
;     PARAMETER LIST FILLED IN AS REQUIRED.
;
;  INTERNAL REFERENCES:
;
;     ROUTINES: SYSPARSE - PARSING CODE
;
;     DATA AREAS: PARMS - PARSE CONTROL BLOCK FOR SYSPARSE
;
;  EXTERNAL REFERENCES:
;
;     ROUTINES: N/A
;
;     DATA AREAS: PARAMETER LIST BLOCK TO BE FILLED.
;
;  NOTES:
;
;  REVISION HISTORY:
;	 A000 - DOS Version 3.40
;  3/24/88 AN003 - P3906 PARSER changes to return "bogus" parameter on the
;	       "Parameter value not allowed " message - CNS
;  5/12/88 AN004 - P4867 /ID:NON-Numeric hangs the sytem as a 1st positional
;
;
;                                                  
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;****************** END OF SPECIFICATIONS ****************************

INCLUDE KEYBDCL.INC

ID_VALID	EQU	0
ID_INVALID	EQU	1
NO_ID		EQU	2

LANGUAGE_VALID	EQU	0
LANGUAGE_INVALID EQU	1
NO_LANGUAGE	EQU	2

NO_IDLANG	EQU	3

CODE_PAGE_VALID EQU	0
CODE_PAGE_INVALID EQU	1
NO_CODE_PAGE	EQU	2
VALID_SYNTAX	EQU	0
INVALID_SYNTAX	EQU	1

COMMAND_LINE_START EQU	81H
RC_EOL		EQU	-1
RC_NO_ERROR	EQU	0
RC_OP_MISSING	EQU	2
RC_NOT_IN_SW	EQU	3

;***CNS P4867 1st CHECK for /ID:ALPHA

RC_SW_FIRST	EQU	9

;***CNS P4867 1st CHECK for /ID:ALPHA

ERROR_COND	EQU	-1
NUMBER		EQU	1
STRING		EQU	3
FILE_SPEC	EQU	5
MAX_ID		EQU	999
LANG_LENGTH	EQU	2

INVALID_SWITCH	EQU	3
TOO_MANY	EQU	1
INVALID_PARAM	EQU	10
VALUE_DISALLOW	EQU	8


	PUBLIC	PARSE_PARAMETERS ; near procedure for parsing command line
	PUBLIC	CUR_PTR 	; near procedure for parsing command line
	PUBLIC	OLD_PTR 	; near procedure for parsing command line
	PUBLIC	ERR_PART	; near procedure for parsing command line

	EXTRN	BAD_ID:BYTE	; WGR to match old code
	EXTRN	FOURTH_PARM:BYTE ; WGR to match old code
	EXTRN	ONE_PARMID:BYTE	; WGR to match old code
	EXTRN	FTH_PARMID:BYTE	; WGR to match old code
	EXTRN	ALPHA:BYTE	; WGR to match old code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Set assemble switches for parse code that is not required!!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DateSW		EQU	0
TimeSW		EQU	0
CmpxSW		EQU	0
DrvSW		EQU	0
QusSW		EQU	0
KeySW		EQU	0
Val1SW		EQU	0
Val2SW		EQU	0
Val3SW		EQU	0


CODE	SEGMENT PUBLIC 'CODE' BYTE
	ASSUME	CS:CODE,DS:CODE

	.XLIST
	INCLUDE	PARSE.ASM	; Parsing code
	.LIST


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PARM control blocks for KEYB
; Parsing command line as follows:
;
; KEYB [lang],[cp],[[d:][path]KEYBOARD.SYS][/ID:id][/e][/?]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARMS	LABEL	WORD
	DW	PARMSX
	DB	0		; no extra delimeters or EOLs.

PARMSX	LABEL	BYTE
	DB	0,3		; min,max positional operands
	DW	LANG		; pointer to control block
	DW	CP		; pointer to control block
	DW	FILE_NAME	; pointer to control block
	DB	3		; 3 switches
	DW	ID_VALUE	; pointer to control block
	dw	help_value	; pointer to control block
	dw	ext_value	; pointer to control block
	DB	0		; no keywords

LANG	LABEL	WORD
	DW	0A001H		; sstring or numeric value (optional)
	DW	0002H		; cap result by char table (sstring)
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

CP	LABEL	WORD
	DW	8001H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

FILE_NAME LABEL WORD
	DW	0201H		; file spec
	DW	0001H		; cap by file table
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

ID_VALUE LABEL	WORD
	DW	8010H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	1		; 1 switch synonym
id_name:
	DB	"/ID",0 	; ID switch

help_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	RESULT_BUF	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
help_name:
	db	"/?",0		; /? switch

ext_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	result_buf	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
ext_name:
	db	"/E",0		; /e switch


NOVALS	LABEL	BYTE
	DB	0		; no value checking done

RESULT_BUF	LABEL BYTE
RESULT_TYPE	DB	0	; type returned (number, string, etc.)
		DB	?	; matched item tag (if applicable)
RESULT_SYN_PTR	DW	?	; synonym ptr (if applicable)
RESULT_VAL	DD	?	; value

LOOP_COUNT	DB	0	; keeps track of parameter position

;***CNS
CUR_PTR        DW	0	; keeps track of parameter position
OLD_PTR        DW	0	; keeps track of parameter position
ERR_PART       DW	0	; keeps track of parameter position
;***CNS
				;..and reports an error condition

	public	pswitches
pswitches	db	0	; bit 0, /?, bit 1 /e

TEMP_FILE_NAME DB	128 DUP(0) ; place for file name

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSE_PARAMETERS
;
; FUNCTION:
; THIS PROCEDURE PARSES THE COMMAND LINE PARAMETERS IN THE PSP FOR
; KEYB.COM. THE PARAMETER LIST BLOCK IS FILLED IN ACCORDINGLY.
;
; AT ENTRY: AS ABOVE.
;
; AT EXIT:
;    AS ABOVE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSE_PARAMETERS       PROC	NEAR

	XOR	AX,AX				; setup default parameters.
	MOV	[BP].RET_CODE_1,NO_IDLANG
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE
	MOV	[BP].RET_CODE_3,VALID_SYNTAX
	MOV	[BP].RET_CODE_4,NO_ID
	MOV	[BP].PATH_LENGTH,AX
	LEA	DI,PARMS			; setup parse blocks
	MOV	SI,COMMAND_LINE_START

	call	save_curptr

	XOR	CX,CX
	XOR	DX,DX
	CALL	SYSPARSE

kbs_10:
	cmp	ax,RC_EOL		; while not end of line and...
	jnz	kbs_11
	jmp	kbs_12
kbs_11:
	cmp	LOOP_COUNT,ERROR_COND	; parameters valid, do...
	jnz	kbs_13
	jmp	kbs_12

kbs_13:
	cmp	ax,RC_NOT_IN_SW		; invalid switch?
	jz	kbs_08
	cmp	ax,RC_SW_FIRST
	jnz	kbs_09

kbs_08:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; set invalid syntax flag.
	MOV	LOOP_COUNT,ERROR_COND		; set error flag to exit parse.

;***CNS
	MOV	ERR_PART,INVALID_SWITCH
	call	save_curptr
;***CNS

	jmp	kbs_10

kbs_09:

	cmp	RESULT_SYN_PTR,offset id_name	; was /id:xxx switch found?
	jnz	not_id_switch


	MOV	AX,WORD PTR RESULT_VAL+2 ; is it valid?
	OR	AX,AX
	jnz	kbs_01

	mov	ax,word ptr RESULT_VAL
	cmp	ax,MAX_ID
	jna	kbs_02

kbs_01:

	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	MOV	[ERR_PART],VALUE_DISALLOW	; SET ERROR TYPE FOR DISPLAY
	call	save_curptr

	jmp	short kbs_03

kbs_02:
	MOV	[BP].RET_CODE_4,ID_VALID ; yes...set return code 4.
	MOV	[BP].ID_PARM,AX
	mov	fourth_parm,1
	mov	fth_parmid,1

	jmp	short kbs_03


not_id_switch:
	cmp	RESULT_SYN_PTR,offset help_name	; was /? switch found?
	jnz	not_help_switch

	or	pswitches,1			; set flag for /?
	jmp	short kbs_03

not_help_switch:
	cmp	RESULT_SYN_PTR,offset ext_name
	jnz	kbs_07

	or	pswitches,2			; set flag for /e
	jmp	short kbs_03


kbs_07:
	INC	LOOP_COUNT		; positional encountered...
	cmp	LOOP_COUNT,1		; check for language
	jnz	kbs_04

	CALL	PROCESS_1ST_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_04:
	cmp	LOOP_COUNT,2		; check for code page
	jnz	kbs_05

	CALL	 PROCESS_2ND_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_05:
	cmp	LOOP_COUNT,3		; check for file name
	jnz	kbs_06

	CALL	PROCESS_3RD_PARM

	call	save_curptr

	jmp	short kbs_03

;	all other cases

kbs_06:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; too many parms

	call	save_curptr

	MOV	ERR_PART,TOO_MANY
	MOV	LOOP_COUNT,ERROR_COND	; set error flag to exit parse.
kbs_03:
	MOV	RESULT_TYPE,0		; reset result block.
	CALL	SYSPARSE		; parse next parameter.

	jmp	kbs_10

kbs_12:
	cmp	[bp].RET_CODE_4,ID_VALID
	jnz	kbs_14				; ensure that if switch was
	cmp	[bp].RET_CODE_1,LANGUAGE_VALID	; used, it was valid keyword
	jz	kbs_14

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; code was used..

;***CNS
	call	save_curptr
	MOV	ERR_PART,VALUE_DISALLOW
;***CNS

kbs_14:
	RET

PARSE_PARAMETERS       ENDP

save_curptr	proc	near

	PUSH	AX			;Save environment
	MOV	AX,CUR_PTR		;Set advancing ptr to end of argument
	MOV	OLD_PTR,AX		;after saving the beginning the string
	MOV	CUR_PTR,SI
	POP	AX			;Restore the environment
	ret

save_curptr	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_1ST_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE FIRST POSITIONAL PARAMETER. THIS SHOULD
; BE THE LANGUAGE ID OR THE KEYBOARD ID.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR LANGUAGE ID.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_1ST_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; error on parse?
	jng	kbs_23

	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; yes...set invalid language
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; and syntax error..
	MOV	LOOP_COUNT,ERROR_COND		 ; set flag to exit parse.
	MOV	ERR_PART,AX

	jmp	kbs_18

kbs_23:
	cmp	RESULT_TYPE,NUMBER	; was this a number (id?)
	jnz	kbs_24

	MOV	AX,WORD PTR RESULT_VAL+2 ; yes...check to see if
	OR	AX,AX			; within range.
	jnz	kbs_19

	MOV	AX,WORD PTR RESULT_VAL
	cmp	ax,max_id
	jna	kbs_17

kbs_19:
	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	jmp	short kbs_18

kbs_17:
	MOV	[BP].RET_CODE_1,ID_VALID	; valid id...set
	MOV	[BP].RET_CODE_4,ID_VALID	; valid id...set
	MOV	[BP].ID_PARM,AX			; and value moved into block
	MOV	LOOP_COUNT,4			; there should be no more parms
	mov	one_parmid,1

	jmp	short kbs_18

kbs_24:
	cmp	RESULT_TYPE,STRING	; must be a string then???
	jnz	kbs_26

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	DS
	LDS	SI,RESULT_VAL		; get ptr to string
	MOV	DI,BP
	ADD	DI,LANGUAGE_PARM	; point to block for copy.
	MOV	CX,LANG_LENGTH		; maximum length = 2
	LODSB				; load AL with 1st char..

kbs_16:
	jcxz	kbs_15			; do twice, unless only 1 char
	or	al,al
	jz	kbs_15

	STOSB				; store
	DEC	CX			; dec count
	LODSB				; load

	jmp	kbs_16

kbs_15:

	or	cx,cx			; if there was less than 2 or..
	jnz	kbs_20
	or	al,al			;  greater than 2 chars, then..
	jz	kbs_21

kbs_20:
	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; invalid.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	ERR_PART,INVALID_PARAM
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse.

	jmp	short kbs_22

kbs_21:
	MOV	[BP].RET_CODE_1,LANGUAGE_VALID	; valid language has been copied
	MOV	ALPHA,1				; language found

kbs_22:
	POP	DS
	POP	CX
	POP	DI
	POP	SI
	jmp	short kbs_18

;	omitted parameter...

kbs_26:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; invalid since further parameters.
kbs_18:
	RET

PROCESS_1ST_PARM       ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_2ND_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 2ND POSITIONAL PARAMETER. THIS SHOULD
; BE THE CODE PAGE, IF REQUESTED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR CODE PAGE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_2ND_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR			; if parse error
	jle	kbs_32

	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_31

kbs_32:

	cmp	RESULT_TYPE,NUMBER		; was parameter specified?
	jnz	kbs_30

	MOV	AX,WORD PTR RESULT_VAL+2	; yes..if code page not..
	OR	AX,AX

	jnz	kbs_27

	MOV	AX,WORD PTR RESULT_VAL		; valid..then

	cmp	ax,MAX_ID
	jna	kbs_28

kbs_27:
	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse

	jmp	short kbs_31

kbs_28:
	MOV	[BP].RET_CODE_2,CODE_PAGE_VALID	; else...valid code page
	MOV	[BP].CODE_PAGE_PARM,AX		; move into parm

	jmp	short kbs_31

kbs_30:
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE	; mark as not specified.
kbs_31:
	RET

PROCESS_2ND_PARM      ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_3RD_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 3RD POSITIONAL PARAMETER. THIS SHOULD
; BE THE KEYBOARD DEFINITION FILE PATH, IF SPECIFIED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR FILE NAME.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_3RD_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; if parse error, then...
	jle	kbs_33

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX ; syntax error.
	MOV	LOOP_COUNT,ERROR_COND	; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_34

kbs_33:

	cmp	RESULT_TYPE,FILE_SPEC
	jnz	kbs_34

	PUSH	DS
	PUSH	SI
	PUSH	DI
	PUSH	CX
	LDS	SI,RESULT_VAL		; load offset of file name
	LEA	DI,TEMP_FILE_NAME
	MOV	[BP].PATH_OFFSET,DI	; copy to parameter block
	XOR	CX,CX
	LODSB				; count the length of the path.

kbs_35:
	or	al,al
	jz	kbs_36

	STOSB
	LODSB
	INC	CX
	jmp	short kbs_35

kbs_36:
	MOV	[BP].PATH_LENGTH,CX	; copy to parameter block
	POP	CX
	POP	DI
	POP	SI
	POP	DS
kbs_34:
	RET

PROCESS_3RD_PARM ENDP

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybtbbl.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */



.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                              
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;;
;; File Name:  KEYBTBBL.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					       ;;
	EXTRN	 TABLE_BUILD   :NEAR	       ;;
	EXTRN	 FIND_CP_TABLE :NEAR	       ;;
					       ;;
	EXTRN	 CPN_INVALID   :WORD	       ;;
	EXTRN	 SD_LENGTH     :WORD	       ;;
					       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybi9.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                             
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;       External declarations and equates for procedures in file
;;       KEYBI9.ASM
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        EXTRN    KEYB_STATE_PROCESSOR:NEAR

        EXTRN    FLAGS_TO_TEST:BYTE    ;;  (YST)
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybi9c.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                        
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBI9C.INC
;; ----------
;;
;; Root File Name:  KEYB.ASM
;; ---------------
;;
;; Description:
;; ------------
;;	 External declarations and equates for procedures in file
;;	 KEYBI9C.ASM
;;
;; Change History:
;; ---------------
;; Delete unused externs
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
	EXTRN	KEYB_INT_9:NEAR 	;;
	EXTRN	K8:BYTE 		;;
	EXTRN	BUFFER_FILL:NEAR	;;
	EXTRN	COUNTRY_FLAG:BYTE	;;
        EXTRN   COPY_NLS1_FLAG:BYTE     ;; (YST)
	EXTRN	BEEP_PENDING:BYTE	;;
	EXTRN	SCAN_CODE:BYTE		;;
	EXTRN	CHK_IBF:NEAR		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LIST


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybi9.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
        PAGE    ,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                              
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBI9.ASM
; ----------
;
; Description:
; ------------
;       Converts scan codes to ASCII for non-US keyboards.
;       This orutine uses the tables loaded into the SHARED_DATA_AREA
;       from KEYBOARD.SYS by the KEYB_COMMAND module.
;
;
; Procedures Contained in This File:
; ----------------------------------
;       KEYB_STATE_PROCESSOR - Scan to ASCII translator.
;
; External Procedure References:
; ------------------------------
;       None.
;
; Linkage Information:  Refer to file KEYB.ASM
; --------------------
;
; Change History:
; ---------------
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE KEYBEQU.INC
        INCLUDE DSEG.INC               ; System data segments
        INCLUDE POSTEQU.INC            ; System equates
        INCLUDE KEYBSHAR.INC
        INCLUDE KEYBI2F.INC
        INCLUDE KEYBI9C.INC
        INCLUDE KEYBCPSD.INC
        INCLUDE KEYBCMD.INC

        PUBLIC KEYB_STATE_PROCESSOR


        PUBLIC FLAGS_TO_TEST           ;; FRN-CAN
        PUBLIC NLS_FLAG_1              ;; FRN-CAN


CODE    SEGMENT PUBLIC 'CODE'

        ASSUME  CS:CODE,DS:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: KEYB_STATE_PROCESSOR
;
; Description:
;     Convert scan to ASCII using the tables loaded into the
;     SHARED_DATA_AREA.  Conversion is directed by the STATE LOGIC
;     commands contained in the SHARED_DATA_AREA.  This routine
;     interprets those commands.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Enable interrupts
;     Save registers
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BREAK_CODE    EQU  80H

HOT_KEY_ACTIVE  DB   0                 ; 1 if hot key is active


                                       ; These are copies of the BIOS FLAGS
FLAGS_TO_TEST    LABEL BYTE            ;  KB_FLAG, KB_FLAG_1,2,3
KB_SHADOW_FLAGS  DB   NUM_BIOS_FLAGS DUP(0)
EXT_KB_FLAG      DB   0                ; Extended KB Flag for shift states
NLS_FLAG_1       DB   0                ; NLS Flags for dead key etc
NLS_FLAG_2       DB   0                ;  .

SAVED_NLS_FLAGS  DB   0,0              ; Saved copy of the NLS flags

OPTION_BYTE     DB    0                ; Set by OPTION command

KB_FLAG_PTRS    DW   OFFSET KB_FLAG    ; These are pointers to the BIOS flags
                DW   OFFSET KB_FLAG_1  ;  we must test
                DW   OFFSET KB_FLAG_2
                DW   OFFSET KB_FLAG_3

XLAT_TAB_PTR    DW   0                 ; pointer to xlat tables for cur state

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


NEST_LEVEL      DB   0
PROCESS_LEVEL   DB   0
TAKE_ELSE       DB   0
BUSY_FLAG       DB   0                 ; Flag to prevent re-entry

CMD_JUMP_TABLE  LABEL  WORD
        DW   OFFSET  IFF_PROC          ; CODE  0
        DW   OFFSET  ANDF_PROC         ;       1
        DW   OFFSET  ELSEF_PROC        ;       2
        DW   OFFSET  ENDIFF_PROC       ;       3
        DW   OFFSET  XLATT_PROC        ;       4
        DW   OFFSET  OPTION_PROC       ;       5
        DW   OFFSET  SET_FLAG_PROC     ;       6
        DW   OFFSET  PUT_ERROR_PROC    ;       7
        DW   OFFSET  IFKBD_PROC        ;       8
        DW   OFFSET  GOTO_PROC         ;       9
        DW   OFFSET  BEEP_PROC         ;       A
        DW   OFFSET  RESET_NLS_PROC    ;       B
        DW   OFFSET  RESET_NLS1_PROC   ;       C
        DW   OFFSET  UNKNOWN_COMMAND   ;       D
        DW   OFFSET  UNKNOWN_COMMAND   ;       E
        DW   OFFSET  UNKNOWN_COMMAND   ;       F


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEYB_STATE_PROCESSOR   PROC   NEAR

        TEST   byte ptr CS:SD.TABLE_OK,1
        JNZ    WE_HAVE_A_TABLE
        CLC                            ; BACK TO US INT 9
        RET
WE_HAVE_A_TABLE:

        PUSH   DS                      ; save DS
        PUSH   ES                      ; save ES
        PUSH   AX                      ; save scan code for caller
        PUSH   BX                      ; save shift states for caller

        PUSH   CS
        POP    DS                      ; DS = our seg
        MOV    BX,DATA
        MOV    ES,BX                   ; addressability to BIOS data


        CMP     COUNTRY_FLAG,0FFH      ; Q..country mode?
        JE      INIT_STATE_PROCESSING  ; Y..continue
        JMP     GOTO_BIOS              ; N..exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; -------STATE SECTION PROCESSING-------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

INIT_STATE_PROCESSING:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set NLS shift flags EITHER_SHIFT, EITHER_ALT, EITHER_CTRL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                                       ; Q..in shift state?
        TEST   ES:KB_FLAG,RIGHT_SHIFT+LEFT_SHIFT
        JNZ    IN_SHIFT_STATE          ; Y..go set bit
        AND    EXT_KB_FLAG,NOT EITHER_SHIFT ; N..clear bit
        JMP    SHORT TEST_CTL
IN_SHIFT_STATE:
        OR     EXT_KB_FLAG,EITHER_SHIFT
TEST_CTL:
        TEST   ES:KB_FLAG,CTL_SHIFT    ; Q..in control state?
        JNZ    IN_CTL_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_CTL_SHIFT ; Q..how bout the right ctl?
        JNZ    IN_CTL_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_CTL ; N..clear the bit
        JMP    SHORT TEST_ALT
IN_CTL_STATE:
        OR     EXT_KB_FLAG,EITHER_CTL
TEST_ALT:
        TEST   ES:KB_FLAG,ALT_SHIFT    ; Q..in alt state?
        JNZ    IN_ALT_STATE            ; Y..go set bit
        TEST   ES:KB_FLAG_3,R_ALT_SHIFT ; Q..how bout the right alt?
        JNZ    IN_ALT_STATE            ; Y..go set the bit
        AND    EXT_KB_FLAG,NOT EITHER_ALT ; N..clear the bit
        JMP    SHORT COPY_FLAGS
IN_ALT_STATE:
        OR     EXT_KB_FLAG,EITHER_ALT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Copy BIOS KB flags from BIOS data seg into the
; FLAGS_TO_TEST structure.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_FLAGS:
        MOV    CX,NUM_BIOS_FLAGS
        xor    si,si                    ; pointers to the BIOS flags
        xor    di,di                    ; create shadow copies
MOVE_NEXT_FLAG:
        MOV    BX,KB_FLAG_PTRS[SI]     ; pointer to next flag
        MOV    AL,ES:[BX]              ; flag in AL
        MOV    KB_SHADOW_FLAGS[DI],AL  ; save it in the shadow table
        INC    DI
        INC    SI
        INC    SI
        LOOP   MOVE_NEXT_FLAG

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Interpret State Logic Commands
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_STATES:
        MOV    OPTION_BYTE,0           ; clear options
        MOV    SI,SD.LOGIC_PTR
        LEA    SI,[SI].SL_LOGIC_CMDS
NEXT_COMMAND:
        MOV    BL,[SI]                 ; command byte in BL
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1
        SHR    BL,1                    ; ISOLATE COMMAND CODE
        SHL    BL,1                    ; command code * 2
        JMP    CMD_JUMP_TABLE[BX]      ; go process command
UNKNOWN_COMMAND:
        JMP    FATAL_ERROR             ; bad news


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFKBD_DONE              ; N..don't process

        MOV    AX,[SI+1]               ; Keyboard Type Flag

        TEST   SD.KEYB_TYPE,AX         ; Q..are we the right system?
        JNZ    IFKBD_TEST_OK           ; Y..
IFKBD_TEST_FAILED:
        MOV    TAKE_ELSE,YES           ; test failed - take ELSE
        JMP    SHORT IFKBD_DONE
IFKBD_TEST_OK:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO
IFKBD_DONE:
        INC    NEST_LEVEL              ; IFKBD increments nest level
        INC    SI                      ; bump past IFKBD
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PUT_ERROR_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    PUT_ERROR_DONE          ; N..don't process
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        CALL   PUT_ERROR               ; check active section
        JC     PUT_ERROR_DONE          ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   PUT_ERROR

PUT_ERROR_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

PUT_ERROR      PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the PUT_ERROR command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
PE_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     PE_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     PE_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT PE_NEXT_STATE

PE_STATE_MATCH:
        MOV    AX,[DI].XS_ERROR_CHAR   ; get error char in AX
        CALL   BUFFER_FILL
        STC                            ; indicate that we found the state
PE_EXIT:
        RET

PUT_ERROR   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GOTO_BIOS:
        CLC                            ; clear carry flag indicating
        POP   BX                       ;  we should continue INT 9
        POP   AX                       ;   processing
        POP   ES
        POP   DS
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

IFF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    IFF_DONE                ; N..don't process IFF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ITS_A_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    IFF_MATCH
        JZ     IFF_NO_MATCH
ITS_A_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     IFF_MATCH
IFF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        JMP    SHORT IFF_DONE
IFF_MATCH:
        INC    PROCESS_LEVEL           ; process commands within IF
        MOV    TAKE_ELSE,NO

IFF_DONE:
        INC    NEST_LEVEL              ; IFF increments nest level
        INC    SI                      ; bump past IFF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ELSEF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    CHECK_TAKE_ELSEF        ; N..check for take_else
        DEC    PROCESS_LEVEL           ; Y..we just finished the "IF" block
        JMP    short ELSEF_DONE        ;    so we are finished with IFF/ELSEF
CHECK_TAKE_ELSEF:
        CMP    TAKE_ELSE,YES           ; Q..are we scanning for ELSE?
        JNE    ELSEF_DONE              ; N..done
        DEC    NEST_LEVEL              ; ELSEF itself is back a level
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    NOT_THIS_ELSEF          ; N..this else is not the one
        INC    PROCESS_LEVEL           ; Y..process ELSEF block
        MOV    TAKE_ELSE,NO            ; reset
NOT_THIS_ELSEF:
        INC    NEST_LEVEL              ; stuff within the ELSEF is up a level

ELSEF_DONE:
        INC    SI                      ; bump past ELSEF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    ENDIFF_DONE             ; N..don't adjust process level
        DEC    PROCESS_LEVEL           ; Y..we just finished the IF/ELSE
ENDIFF_DONE:
        DEC    NEST_LEVEL              ; ENDIF decrements nest level
        INC    SI                      ; bump past ENDIF
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Translations may be in the Common or Specific
; Sections.  Search the Specific section first
; then the common section.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    XLATT_DONE              ; N..next command
        MOV    DI,SD.ACTIVE_XLAT_PTR   ; pointer to active Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE               ; check active section
        JC     XLATT_FOUND             ; carry set if translation found
        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id for XLATT in AL
        CALL   TRANSLATE
        JNC    XLATT_DONE
XLATT_FOUND:
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched
        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     XLATT_DONE
        JMP    EXIT                    ; Y..BYE

XLATT_DONE:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND

TRANSLATE PROC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Search for a state whose ID matches the ID
; on the XLATT command
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        CLC
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
TP_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     TP_EXIT                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     TP_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT TP_NEXT_STATE

TP_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to first xlat table
        MOV    XLAT_TAB_PTR,SI         ; start of XLAT tables
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        JMP    SHORT NEXT_XLAT_TAB
TP_DONE:                               ; return here from XLAT
        POP    SI
TP_EXIT:
        RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check xlate tables for matching scan code
; The xlate table can be in one of two forms:
;    Type 1 = Table contains buffer entries only.
;             Scan code is used as an index into xlat table
;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;             Table must be searched for matching scan.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NEXT_XLAT_TAB:
        MOV    SI,XLAT_TAB_PTR         ; pointer to xlat tables
        CMP    [SI].XLAT_TAB_SIZE,0    ; Q..any more xlat tables?
        JNE    PROCESS_XLAT_TAB        ; Y..check um
        JMP    TP_DONE                 ; N..done
PROCESS_XLAT_TAB:
        MOV    DL,[SI].XLAT_OPTIONS    ; save translate options IN DL
        MOV    BX,[SI].XLAT_TAB_SIZE   ; Y..calc pointer to next xlat tab
        ADD    BX,SI
        MOV    XLAT_TAB_PTR,BX         ; pointer to next xlat tab
        TEST   DL,TYPE_2_TAB           ; Q..is this a type 2 table?
        JZ     TYPE_1_LOOKUP           ; N..go do table lookup
TYPE_2_SEARCH:                         ; Y..search table
        XOR    CH,CH
        MOV    CL,[SI].XLAT_NUM        ; number of xlat entries
        MOV    BX,DEFAULT_TAB_2_ENT_SZ ; default entry size
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JZ     NEXT_TAB_2_ENTRY        ; N..continue
        MOV    BX,ASC_ONLY_TAB_2_ENT_SZ ; Y..set size in BX
NEXT_TAB_2_ENTRY:                      ; entry size is in BX
	jcxz	next_xlat_tab		;   brif last entry
        CMP    AL,[SI].XLAT_SCAN       ; Q..scan match?
        JE     FOUND_TAB_2_ENTRY       ; Y..go create buffer entry
        ADD    SI,BX                   ; point to next entry
        LOOP   NEXT_TAB_2_ENTRY
        JMP    SHORT NEXT_XLAT_TAB
FOUND_TAB_2_ENTRY:                     ; Q..set scan code to 0?
        MOV    AH,AL                   ; default scan code in AH
        MOV    AL,[SI].XLAT_2_BUF_ENTRY ; ASCII code from table in AL
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..are buffer entries ASCII only?
        JNZ    BUFFER_ENTRY_READY      ; Y..buffer entry is ready
        MOV    AH,[SI].XLAT_2_BUF_ENTRY+1 ; N..scan code from table as well
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer

TYPE_1_LOOKUP:
        CMP    AL,[SI].XLAT_SCAN_LO    ; Q..is scan in range of this table?
        JB     NEXT_XLAT_TAB           ; N..next table
        CMP    AL,[SI].XLAT_SCAN_HI    ; Q..is scan in range of this table?
        JA     NEXT_XLAT_TAB           ; N..next table
        SUB    AL,[SI].XLAT_SCAN_LO    ; convert scan code to xlat index
        TEST   DL,ASCII_ONLY+ZERO_SCAN ; Q..ASCII only in xlat ?
        JZ     TWO_BYTE_LOOKUP         ; N..go do 2-byte lookup
        LEA    BX,[SI].XLAT_1_BUF_ENTRY ; Y..do 1-byte lookup
        XLAT   [SI].XLAT_1_BUF_ENTRY   ; ASCII code in AL
        MOV    AH,SCAN_CODE            ; SCAN in AH
        JMP    SHORT BUFFER_ENTRY_READY ; go put entry in buffer
TWO_BYTE_LOOKUP:
        MOV    BL,2                    ; multiply scan index
        MUL    BL                      ;  by two
        MOV    BX,AX                   ; real index in BX
        MOV    AX,WORD PTR [SI].XLAT_1_BUF_ENTRY[BX] ; get 2-byte buffer entry
                                       ;  AL=ASCII  AH=SCAN
BUFFER_ENTRY_READY:
        TEST   DL,ZERO_SCAN            ; Q..set scan part to zero?
        JZ     NO_ZERO_SCAN            ; N..
        XOR    AH,AH                   ; scan = 0
NO_ZERO_SCAN:
        CALL   BUFFER_FILL             ; go put entry in buffer
        STC                            ; indicate translation found
        JMP    TP_DONE

TRANSLATE ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION_PROC:
        MOV    AL,PROCESS_LEVEL
        CMP    AL,NEST_LEVEL           ; Q..nest level = process level?
        JNE    DONE_OPTION             ; N..done
        MOV    AL,[SI]+1               ; mask in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT?
        JNZ    AND_MASK
        OR     OPTION_BYTE,AL          ; N..OR in the mask bits
        JMP    short DONE_OPTION
AND_MASK:
        NOT    AL
        AND    OPTION_BYTE,AL          ; Y..AND out the mask bits
DONE_OPTION:
        INC    SI
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    RN_DONE                 ; N..don't process
        MOV    NLS_FLAG_1,0
        MOV    NLS_FLAG_2,0


        MOV    COPY_NLS1_FLAG,0        ;; FR-CAN


RN_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This PROC only for FR-CAN (YST)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RESET_NLS1_PROC:                       ;;
        MOV    AL,NEST_LEVEL           ;;
        CMP    AL,PROCESS_LEVEL        ;; Q..nest level = process level?
        JNE    RN1_DONE                 ;; N..don't process
        MOV    NLS_FLAG_1, 1            ;;
        MOV    NLS_FLAG_2,0            ;;
        MOV    COPY_NLS1_FLAG, 1        ;; (FRN-CAN)
RN1_DONE:                               ;;
        INC    SI                      ;;
        JMP    NEXT_COMMAND            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    BP_DONE                 ; N..don't process
        MOV    BEEP_PENDING,YES        ; set beep pending flag. the beep
                                       ;  will be done just before iret
BP_DONE:
        INC    SI
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    GOTO_DONE               ; N..don't process
        MOV    BL,[SI]                 ; command byte in BL
        AND    BL,NOT COMMAND_BITS     ; remove command code
        OR     BL,BL                   ; Q..goto label?
        JZ     GOTO_LABEL              ; Y..go jump
        CMP    BL,EXIT_INT_9_FLAG      ; Q..SPECIAL - Exit Int 9?
        JNE    NOT_EXIT_INT_9          ; N..
        JMP    EXIT                    ; Y..bye bye
NOT_EXIT_INT_9:
        CMP    BL,EXIT_STATE_LOGIC_FLAG ; Q..SPECIAL - Exit State Logic?
        JNE    NOT_EXIT_S_L            ; N..
        JMP    GOTO_BIOS               ; Y..goto bios
NOT_EXIT_S_L:
        JMP    FATAL_ERROR             ; garbage in that command
GOTO_LABEL:
        ADD    SI,[SI]+1               ; bump by relative offset
        MOV    PROCESS_LEVEL,0         ; reset process and nest level
        MOV    NEST_LEVEL,0
GOTO_DONE:
        ADD    SI,3                    ; bump to next command
        JMP    NEXT_COMMAND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ANDF_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    ANDF_DONE               ; N..don't process ANDF
        MOV    BL,[SI]                 ; command byte
        AND    BL,FLAG_ID_BITS         ; isolate flag id
        XOR    BH,BH
        MOV    AL,FLAGS_TO_TEST[BX]    ; flag in AL
        TEST   BYTE PTR[SI],NOT_TEST   ; Q..is this a NOT test?
        JNZ    ANDF_NOT
        TEST   AL,[SI]+1               ; Y..check for bit set
        JNZ    ANDF_DONE               ; if set then remain in IFF
        JZ     ANDF_NO_MATCH
ANDF_NOT:
        TEST   AL,[SI]+1               ; Y..check for bit clear
        JZ     ANDF_DONE               ; if clear then remain in IFF
ANDF_NO_MATCH:
        MOV    TAKE_ELSE,YES           ; flag test failed - take ELSE
        DEC    PROCESS_LEVEL           ; IFF would have inc'd - so dec
ANDF_DONE:
        INC    SI                      ; bump past ANDF
        INC    SI
        JMP    NEXT_COMMAND

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SET_FLAG Command.
; Flag Table must be in the Common Section
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SET_FLAG_PROC:
        MOV    AL,NEST_LEVEL
        CMP    AL,PROCESS_LEVEL        ; Q..nest level = process level?
        JNE    SF_DONE                 ; N..don't process

        MOV    DI,SD.COMMON_XLAT_PTR   ; check common Xlat Section
        MOV    AL,[SI+1]               ; state id in AL
        LEA    DI,[DI].XS_FIRST_STATE  ; point to first state in section
SF_NEXT_STATE:
        CMP    [DI].XS_STATE_LEN,0     ; Q..out of states?
        JE     SF_DONE                 ; Y..exit
        CMP    AL,[DI].XS_STATE_ID     ; Q..is this the requested state?
        JE     SF_STATE_MATCH
        ADD    DI,[DI].XS_STATE_LEN    ; N..check next state
        JMP    SHORT SF_NEXT_STATE

SF_STATE_MATCH:
        AND    EXT_KB_FLAG,NOT SCAN_MATCH  ; reset flag before search
        PUSH   SI                      ; save pointer to next command
        LEA    SI,[DI].XS_FIRST_TAB    ; point to table
        MOV    AL,SCAN_CODE            ; restore incoming scan code
        MOV    CX,[SI]                 ; number of entries
	jcxz	sf_restore		; done if no entries
        INC    SI                      ; Y..Bump to first entry
        INC    SI
NEXT_SF_ENTRY:
        CMP    AL,[SI]                 ; Q..scan match?
        JE     FOUND_SF_ENTRY          ; Y..go set flag
        ADD    SI,3                    ; point to next entry
        LOOP   NEXT_SF_ENTRY
        JMP    SHORT SF_RESTORE        ; no match found
FOUND_SF_ENTRY:
        MOV    NLS_FLAG_1,0            ; clear all NLS bits
        MOV    NLS_FLAG_2,0
        MOV    BL,[SI]+1               ; flag id in BX
        XOR    BH,BH
        MOV    AL,[SI]+2               ; mask in AL
        OR     FLAGS_TO_TEST[BX],AL    ; set the bit
        OR     EXT_KB_FLAG,SCAN_MATCH  ; set flag indicating scan matched


        MOV    AL,NLS_FLAG_1           ;; copy NLS_FLAG_1 to the (YST)
        MOV    COPY_NLS1_FLAG,AL       ;; public place (YST)


        TEST   OPTION_BYTE,EXIT_IF_FOUND ; Q..exit
        JZ     SF_RESTORE
        POP    SI
        JMP    short EXIT
SF_RESTORE:
        POP    SI
SF_DONE:
        INC    SI                      ; bump past command
        INC    SI
        JMP    NEXT_COMMAND


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Fatal Error routine.  Come here when
; we have a critical error such as an
; invalid State Logic Command.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FATAL_ERROR:
        JMP   SHORT EXIT               ; end the int 9 processing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Exit point.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

EXIT:
        MOV   BUSY_FLAG,NO
        STC                            ; indicate we should end INT 9
        POP   BX                       ;  processing
        POP   AX
        POP   ES
        POP   DS
        RET

KEYB_STATE_PROCESSOR   ENDP



CODE   ENDS
       END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybcmd.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
;
;                                             
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
; File Name:  KEYBCMD.ASM
; ----------
;
;
; Description:
; ------------
;	 Contains transient command processing modules for KEYB command.
;
; Procedures contained in this file:
; ----------------------------------
;	KEYB_COMMAND:	 Main routine for command processing.
;	PARSE_PARAMETERS:  Validate syntax of parameters included
;	    on command line.
;	BUILD_PATH: Find KEYBOARD.SYS file and validate language and/or
;	    code page.
;	INSTALL_INT_VECTORS:  Install our INT 9, INT 2F Drivers
;	NUMLK_ON:  Turn on the NUM LOCK LED
;	FIND_FIRST_CP: Determine first code page for given language in the
;	    Keyboard Definition file.
;
; Include Files Required:
; -----------------------
;	KEYBMSG.INC
;	KEYBEQU.INC
;	KEYBSYS.INC
;	KEYBI9C.INC
;	KEYBI9.INC
;	KEYBI2F.INC
;	KEYBSHAR.INC
;	KEYBDCL.INC
;	KEYBTBBL.INC
;	COMMSUBS.INC
;	KEYBCPSD.INC
;	POSTEQU.SRC
;	DSEG.SRC
;
; External Procedure References:
; ------------------------------
;	FROM FILE  KEYBTBBL.ASM:
;	      TABLE_BUILD - Create the shared area containing all keyboard tables.
;	      STATE_BUILD - Build all states within the table area
;	 FROM FILE  KEYBMSG.ASM:
;	      KEYB_MESSAGES - All messages
;
; Change History:
;
;  Modified for DOS 3.40 -	Nick Savage , IBM Corporation
;				Wilf Russell, IBM Canada Laboratory
;				DCR ???? -KEYBAORD SECURITY LOCK - CNS
;
;
;			        PTM 3906 - KEYB messages do not conform
;					   to spec. Error message does
;				3/24/88	   not pass back the bogus command
;					   line argument.	      - CNS
;
; PTMP3955 ;KEYB component to free environment and close handles 0 - 4
;
; 3/24/88
;
; 9/26/89 jwg Moved code from resident module and reduce code size.
;
;;;;;;;;;;;;;

	PUBLIC	KEYB_COMMAND

;*****************CNS********************
	PUBLIC	ID_TAB_OFFSET
;*****************CNS********************

	PUBLIC	CP_TAB_OFFSET
	PUBLIC	STATE_LOGIC_OFFSET
	PUBLIC	SYS_CODE_PAGE
	PUBLIC	KEYBCMD_LANG_ENTRY_PTR
	PUBLIC	DESIG_CP_BUFFER
	PUBLIC	DESIG_CP_OFFSET
	PUBLIC	KEYBSYS_FILE_HANDLE
	PUBLIC	NUM_DESIG_CP
	PUBLIC	TB_RETURN_CODE
	PUBLIC	FILE_BUFFER
	PUBLIC	FB

;*****************CNS********************
	PUBLIC	ID_PTR_SIZE
	PUBLIC	LANG_PTR_SIZE
	PUBLIC	CP_PTR_SIZE
	PUBLIC	NUM_ID
	PUBLIC	NUM_LANG
	PUBLIC	NUM_CP
	PUBLIC	SHARED_AREA_PTR
;*****************CNS********************

	PUBLIC	SD_SOURCE_PTR
	PUBLIC	TEMP_SHARED_DATA

	PUBLIC	FOURTH_PARM
	PUBLIC	ONE_PARMID
	PUBLIC	FTH_PARMID
	PUBLIC	ID_FOUND
	PUBLIC	BAD_ID
	PUBLIC	ALPHA
	EXTRN	PARSE_PARAMETERS:NEAR
	extrn	pswitches:byte

;***CNS
	EXTRN	SECURE_FL:BYTE
	EXTRN	CUR_PTR:WORD
	EXTRN	OLD_PTR:WORD
	EXTRN	ERR_PART:WORD
;***CNS

	.xlist
	INCLUDE SYSMSG.INC	       ;  message retriever
	.list

MSG_UTILNAME <KEYB>		       ;  identify to message retriever

CODE	SEGMENT PUBLIC 'CODE'

	.xlist
	INCLUDE KEYBEQU.INC
	INCLUDE KEYBSYS.INC
	INCLUDE KEYBI9.INC
	INCLUDE KEYBI9C.INC
	INCLUDE KEYBI2F.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBDCL.INC
	INCLUDE KEYBTBBL.INC
	INCLUDE COMMSUBS.INC
	INCLUDE KEYBCPSD.INC
	.xlist
	INCLUDE POSTEQU.INC
	INCLUDE DSEG.INC

	.list
	ASSUME	CS:CODE,DS:CODE

;;;;;;;;;;;;;
;
; Module: KEYB_COMMAND
;
; Description:
;     Main routine for transient command processing.
;
; Input Registers:
;     DS - points to our data segment
;
; Output Registers:
;     Upon termination, if an error has occurred in which a keyboard table
;     was not loaded, the AL register will contain the a error flag. This
;     flag is defined as follows:
;	      AL:= 1 - Invalid language, code page, or syntax
;		   2 - Bad or missing Keyboard Definition File
;		   3 - KEYB could not create a table in resident memory
;		   4 - An error condition was received when communicating
;		       with the CON device
;		   5 - Code page requested has not been designated
;		   6 - The keyboard table for the requested code page cannot
;		       be found in resident keyboard table.
;
; Logic:
;     IF KEYB has NOT been previously loaded THEN
;	  Set SHARED_AREA_PTR to TEMP_SHARED_AREA
;	  INSTALLED_KEYB := 0
;	  Get HW_TYPE (set local variable)
;     ELSE
;	  Set SHARED_AREA_PTR to ES:SHARED_AREA
;	  Get HW_TYPE (set local variable)
;	  Set TABLE_OK := 0
;	  INSTALLED_KEYB := 1
;
;     IF CPS-CON has been loaded THEN
;	  INSTALLED_CON := 1
;
;*********************************** CNS *************************************
;     Call PARSE_PARAMETERS := Edit ID or language, code page,
;					    and path parameters,ID on command line
;*********************************** CNS *************************************
;     Check all return codes:
;     IF any parameters are invalid THEN
;	  Display ERROR message
;     ELSE
;	  IF no language parm specified
;				 AND code page is not invalid
;						     AND syntax is valid THEN
;	     Process QUERY:
;	     IF KEYB is installed THEN
;		 Get and display active language from SHARED_DATA_AREA
;		 Get invoked code page from SHARED_DATA_AREA
;		 Convert to ASCII
;		 Display ASCII representation of code page, CR/LF
;*********************************** CNS *************************************
;	     IF ALTERNATE FLAG SET
;		 Get and display active ID from SHARED_DATA_AREA
;		 Convert to ASCII
;		 Display ASCII representation of ID, CR/LF
;*********************************** CNS *************************************
;	     IF CPS-CON is installed THEN
;		 Get selected code page info from CON
;		 Convert to ASCII
;		 Display ASCII representation of code page, CR/LF
;	     EXIT without staying resident
;
;	  ELSE
;	     Call BUILD_PATH := Determine location of Keyboard definition file
;	     Open the file
;	     IF error in opening file THEN
;		Display ERROR message and EXIT
;	     ELSE
;		Save handle
;		Set address of buffer
;		READ header of Keyboard definition file
;		IF error in reading file THEN
;		   Display ERROR message and EXIT
;		ELSE
;		   Check signature for correct file
;		   IF file signature is correct THEN
;		      READ language table
;		      IF error in reading file THEN
;			  Display ERROR message and EXIT
;		      ELSE
;			  Use table to verify language parm
;			  Set pointer values
;			  IF code page was specified
;			      READ language entry
;			      IF error in reading file THEN
;				   Display ERROR message and EXIT
;			      ELSE
;				   READ Code page table
;				   IF error in reading file THEN
;				       Display ERROR message and EXIT
;				   ELSE
;				       Use table to verify code page parm
;				       Set pointer values
;     IF CPS-CON is not installed THEN
;	    Set number of code pages = 1
;	    IF CODE_PAGE_PARM was specified THEN
;	       Copy CODE_PAGE_PARM into table of code pages to build
;	    ELSE
;	       Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;	       Copy SYSTEM_CP into table of code pages to build
;     ELSE
;	    Issue INT 2F ; 0AD03H  to get table of Designated code pages
;	    Set number of designated code pages (HWCP + Desig CP)
;	    Issue INT 2F ; 0AD02H  to get invoked code page
;	    IF CODE_PAGE_PARM was specified THEN
;	       Check that CODE_PAGE_PARM is in the list of designated code pages
;	       IF CODE_PAGE_PARM is in the list of designated code pages THEN
;		    Copy specified CP into table of code pages to build
;		    IF a CP has been selected AND is inconsistent with specified CP
;			Issue WARNING message
;	       ELSE
;		    Display ERROR message
;	    ELSE
;	       IF a code page has been invoked THEN
;		    Copy invoked code page into table of code pages to build
;	       ELSE
;		    Call FIND_FIRST_CP := Define the system code page (1st in Keyb Def file)
;		    Copy SYSTEM_CP into table of code pages to build
;
;     IF KEYB has not been previously installed THEN
;	  Call FIND_SYS_TYPE := Determine system type
;	  Call INSTALL_INT_9 := Install INT 9 handler
;	  Call FIND_KEYB_TYPE := Determine the keyboard type
;
;     Call TABLE_BUILD := Build the TEMP_SHARED_DATA_AREA
;
;     IF return codes from TABLE_BUILD are INVALID THEN
;	  IF KEYB_INSTALLED := 0 THEN
;	      Call REMOVE_INT_9
;	  Display corresponding ERROR message
;	  EXIT without staying resident
;     ELSE
;	  IF any of the designated CPs were invalid in the build THEN
;	      Issue WARNING message
;	  Close the Keyboard definition file
;	  IF KEYB had NOT already been installed THEN
;	      IF keyboard is a Ferrari_G AND system is not an XT THEN
;	      Call NUMLK_ON := Turn the NUM LOCK LED on
;	      IF extended INT 16 support required THEN
;		 Install extended INT 16 support
;	      Call INSTALL_INT_9_NET := Let network know about INT 9
;	      Call INSTALL_INT_2F := Install the INT 2F driver
;	      Activate language
;	      Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;	      EXIT but stay resident
;	  ELSE
;	      IF this was not a query call AND exit code was valid THEN
;		 Activate language
;		 Get resident end and copy TEMP_SHARED_DATA_AREA into SHARED_DATA_AREA
;	      EXIT without staying resident
;     END
;
;;;;;;;;;;;;;

INVALID_PARMS	     EQU  1	      ;  EXIT return codes
BAD_KEYB_DEF_FILE    EQU  2
MEMORY_OVERFLOW      EQU  3
CONSOLE_ERROR	     EQU  4
CP_NOT_DESIGNATED    EQU  5
KEYB_TABLE_NOT_LOAD  EQU  6
BAD_DOS_VER	     EQU  7	
EXIT_RET_CODE	     DB   0

;******************** CNS ***********
ID_VALID	     EQU  0
ID_INVALID	     EQU  1
NO_ID		     EQU  2
LANGUAGE_VALID	     EQU  0
LANGUAGE_INVALID     EQU  1		;  Return Codes
NO_LANGUAGE	     EQU  2		;    from
NO_IDLANG	     EQU  3
;******************** CNS ***********

CODE_PAGE_VALID      EQU  0		;     EDIT_LANGUAGE_CODE
CODE_PAGE_INVALID    EQU  1
NO_CODE_PAGE	     EQU  2
VALID_SYNTAX	     EQU  0
INVALID_SYNTAX	     EQU  1	

ACT_KEYB	     EQU  2
ACT_ID		     EQU  3
ACT_KEYB_CP	     EQU  4
ACT_CON_CP	     EQU  5
INV_L		     EQU  6		;  message numbers...
INV_I		     EQU  7
INV_CP		     EQU  8
INV_S		     EQU  18
INV_FN		     EQU  9
INV_KEYB_Q	     EQU  10
INV_CON_Q	     EQU  11
NOT_DESIG	     EQU  12
NOT_SUPP	     EQU  13
NOT_VALID	     EQU  14
WARNING_1	     EQU  15
INV_COMBO	     EQU  16
MEMORY_OVERF	     EQU  17
help_1st	     equ  300
help_last	     equ  306
CR_LF		     DB   10,13,'$'

FOURTH_PARM	DB	0		;  switch was specified
ONE_PARMID	DB	0		;  id given as positional
FTH_PARMID	DB	0		;  id given as switch
ID_FOUND	DB	0		;  id was good (in k.d. file)
BAD_ID		DB	0		;  id was bad (from parse)
ALPHA		DB	0		;  first parm a language id

ID_DISPLAYED	DB	0		;  Indicating ID already displayed

SUBLIST_NUMBER LABEL BYTE		;  sublist for numbers
	       DB	11		;  size
	       DB	0
PTR_TO_NUMBER  DW	?		;  offset ptr
SEG_OF_NUMBER  DW	?		;  segment
	       DB	1
	       DB	10100001B	;  flag
	       DB	4       	;  max width (FR-CAN)
	       DB	1		;  min width
	       DB	" "		;  filler


SUBLIST_ASCIIZ LABEL BYTE		;  sublist for asciiz
	       DB	11		;  size
	       DB	0
PTR_TO_ASCIIZ  DW	?		;  offset ptr
SEG_OF_ASCIIZ  DW	?		;  segment
	       DB	1
	       DB	00010000B	;  flag
	       DB	2		;  max width
	       DB	2		;  min width
	       DB	" "		;  filler

NUMBER_HOLDER  DW	?		;  used for message retriever

;***CNS
SUBLIST_COMLIN LABEL BYTE		;  sublist for asciiz
	       DB	11		;  size
	       DB	0
PTR_TO_COMLIN  DW	?		;  offset ptr
SEG_OF_COMLIN  DW	?
	       DB	0
	       DB	LEFT_ALIGN+CHAR_FIELD_ASCIIZ  ;  flag

	       DB	0		;  max width
	       DB	1		;  min width
	       DB	" "		;  filler


STRING_HOLDER  DB	64 DUP(0)
;***CNS

FILE_BUFFER	     DB   FILE_BUFFER_SIZE dup (0); Buffer for Keyboard Def file
FB		     EQU  FILE_BUFFER	;m for 32 language entries)
DESIG_CP_BUFFER      DW   28 DUP(?)	; (Room for 25 code pages)
DESIG_CP_BUF_LEN     DW   $-DESIG_CP_BUFFER ; Length of code page buffer
NUM_DESIG_CP	     DW   0
CP_TAB_OFFSET	     DD   ?

;******************  CNS  ******************
TOTAL_SIZE	     DW   0
PASS_LANG	     DW   0
ID_TAB_OFFSET	     DD   ?
;******************  CNS  ******************

STATE_LOGIC_OFFSET   DD   -1
KEYBSYS_FILE_HANDLE  DW   ?
TB_RETURN_CODE	     DW   1
DESIG_CP_OFFSET      DW   OFFSET DESIG_CP_BUFFER
SYS_CODE_PAGE	     DW   0
DESIG_LIST	     DW   0
QUERY_CALL	     DB   0

KB_MASK 	     EQU  02h

SIGNATURE	     DB   0FFh,'KEYB   '
SIGNATURE_LENGTH     DW   8

;******************  CNS  ***************************
NUM_ID		     DW   0
ERR4ID		     DB   0
NUM_LANG	     DW   0
NUM_CP		     DW   0
ID_PTR_SIZE	     DW   SIZE KEYBSYS_ID_PTRS
;******************  CNS  ***************************

LANG_PTR_SIZE	     DW   SIZE KEYBSYS_LANG_PTRS
CP_PTR_SIZE	     DW   SIZE KEYBSYS_CP_PTRS
KEYBCMD_LANG_ENTRY_PTR DD ?

KEYB_INSTALLED	     DW   0
CON_INSTALLED	     DW   0
SHARED_AREA_PTR      DD   0
GOOD_MATCH	     DW   0

;******************  CNS  ***************************;
LANGUAGE_ASCII	     DB   '??',0

CMD_PARM_LIST	     PARM_LIST <>

;----------  TABLES FOR EXTENDED KEYBOARD SUPPORT CTRL CASE  ---------


RPL_K8	LABEL	BYTE			;-------- CHARACTERS ---------
	DB	27,-1,00,-1,-1,-1	; Esc, 1, 2, 3, 4, 5
	DB	30,-1,-1,-1,-1,31	; 6, 7, 8, 9, 0, -
	DB	-1,127,148,17,23,5	; =, Bksp, Tab, Q, W, E
	DB	18,20,25,21,09,15	; R, T, Y, U, I, O
	DB	16,27,29,10,-1,01	; P, [, ], Enter, Ctrl, A
	DB	19,04,06,07,08,10	; S, D, F, G, H, J
	DB	11,12,-1,-1,-1,-1	; K, L, ;, ', `, LShift
	DB	28,26,24,03,22,02	; \, Z, X, C, V, B
	DB	14,13,-1,-1,-1,-1	; N, M, ,, ., /, RShift
	DB	150,-1,' ',-1           ; *, Alt, Space, CL
					;--------- FUNCTIONS ---------
	DB	94,95,96,97,98,99	; F1 - F6
	DB	100,101,102,103,-1,-1	; F7 - F10, NL, SL
	DB	119,141,132,142,115,143 ; Home, Up, PgUp, -, Left, Pad5
	DB	116,144,117,145,118,146 ; Right, +, End, Down, PgDn, Ins
	DB	147,-1,-1,-1,137,138	; Del, SysReq, Undef, WT, F11, F12
L_CTRL_TAB	EQU	$-RPL_K8

;;;;;;;;;;;;;;;;
;    Program Code
;;;;;;;;;;;;;;;;

KEYB_COMMAND  PROC NEAR

	CALL	SYSLOADMSG		;load messages
	JNC	VERSION_OK		;if no carry then version ok

	CALL	SYSDISPMSG		;error..display version error
	MOV	AL,BAD_DOS_VER		;bad DOS version
	MOV	EXIT_RET_CODE,AL
	JMP	KEYB_EXIT_NOT_RESIDENT	;exit..non resident

VERSION_OK:
	MOV	SEG_OF_NUMBER,CS	;initialize..
	MOV	SEG_OF_ASCIIZ,CS	;  ..sublists
	MOV	BP,OFFSET CMD_PARM_LIST	;pointer for parm list
	MOV	WORD PTR SHARED_AREA_PTR,ES ; ES segment

KEYB_INSTALL_CHECK:
	MOV	AX,0AD80H		; KEYB install check
	INT	2FH
	CMP	AL,-1			; If flag is not 0FFh THEN
	JE	INSTALLED_KEYB

	MOV	WORD PTR SHARED_AREA_PTR+2,OFFSET TSD
	JMP	short CON_INSTALL_CHECK

INSTALLED_KEYB:
	MOV	KEYB_INSTALLED,1	; Set KEYB_INSTALLED flag = YES
	MOV	WORD PTR SHARED_AREA_PTR,ES ; Save segment of SHARED_DATA_AREA
	MOV	WORD PTR SHARED_AREA_PTR+2,DI ;Save offset of SHARED_DATA_AREA

	MOV	AX,ES:[DI].KEYB_TYPE
	MOV	HW_TYPE,AX
	MOV	ES:[DI].TABLE_OK,0	; Do not allow processing
	PUSH	CS			;	  while building table
	POP	ES			; Reset ES until required

CON_INSTALL_CHECK:		
	MOV	AX,0AD00H		; CONSOLE install check
	INT	2FH
	CMP	AL,-1			; If flag is not 0FFh THEN
	jnz	call_first_stage

	MOV	CON_INSTALLED,1		; Set CON_INSTALLED flag = YES

CALL_FIRST_STAGE:
	PUSH	CS
	POP	ES
	CALL	PARSE_PARAMETERS	; Validate parameter list

	test	pswitches,1		; /? option?
	jz	no_help			; brif not

	mov	ax,help_1st		; first help msg
help_loop:
	push	ax
	MOV	BX,STDOUT		; to standard out
	xor	cx,cx			; no replacements
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_ASCIIZ	; ptr to sublist
	CALL	SYSDISPMSG
	pop	ax
	inc	ax
	cmp	ax,help_last
	jbe	help_loop

	mov	exit_ret_code,invalid_parms ; return "invalid parms"
	jmp	KEYB_EXIT_NOT_RESIDENT



no_help:

BEGIN_PARM_CHECK:			; CHECK ALL RETURN CODES
	MOV	DL,[BP].RET_CODE_3
	CMP	DL,1			; Check for invalid syntax
	JNE	VALID1
	JMP	ERROR3

VALID1:
	MOV	DL,[BP].RET_CODE_1	; Check for invalid language parm
	CMP	DL,1
	JNE	VALID2
	JMP	ERROR1

VALID2:
	MOV	DL,[BP].RET_CODE_2	; Check for invalid code page parm
	CMP	DL,1
	JNE	VALID3
	JMP	ERROR2

VALID3:
	MOV	DL,[BP].RET_CODE_1	; Check for query command
	CMP	DL,2
	JE	QUERY


;******************************* CNS **
	CMP	DL,3			; Get a status of the codepage
	JE	QUERY			; language, and possible ID code
;******************************* CNS **

	JMP	NOT_QUERY
					; IF QUERY is requested THEN
QUERY:
	MOV	QUERY_CALL,DL
	MOV	AX,KEYB_INSTALLED	;     If KEYB is installed THEN
	or	ax,ax
	JE	QUERY_CONTINUE1

	MOV	DI,WORD PTR SHARED_AREA_PTR+2	; Get offset of
	MOV	ES,WORD PTR SHARED_AREA_PTR	;	 shared area
	MOV	BX,WORD PTR ES:[DI].ACTIVE_LANGUAGE ; Get active language
	or	bx,bx				; if no language...
	JE	I_MESSAGE			;  then id was specified


L_MESSAGE:
	MOV	WORD PTR LANGUAGE_ASCII,BX ; Display Language
	LEA	SI,LANGUAGE_ASCII	; sublist points to...
	MOV	PTR_TO_ASCIIZ,SI	; language code asciiz string
	MOV	AX,ACT_KEYB		; display 'Current keyboard code'
	MOV	BX,STDOUT		; to standard out
	MOV	CX,1			; one replacement
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_ASCIIZ	; ptr to sublist
	CALL	SYSDISPMSG
	JMP	short KEYB_L_FINISHED
					
I_MESSAGE:
	MOV	BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
	MOV	NUMBER_HOLDER,BX	;  transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	;  sublist points to...
	MOV	PTR_TO_NUMBER,SI	;  code page word
	MOV	AX,ACT_ID		;  display 'Current ID:  '
	MOV	BX,STDOUT		;  to standard out
	MOV	CX,1			;  one replacement
	MOV	DH,UTILITY_MSG_CLASS	;  utility message
	XOR	DL,DL			;  no input
	LEA	SI,SUBLIST_NUMBER	;  ptr to sublist
	CALL	SYSDISPMSG
	MOV	ID_DISPLAYED,1		;  ID was displayed.
	JMP	short KEYB_L_FINISHED

QUERY_CONTINUE1:
	MOV	AX,INV_KEYB_Q
	MOV	BX,STDOUT		;  Else
	XOR	CX,CX			;   Display message that KEYB
	MOV	DH,UTILITY_MSG_CLASS	;   has not been installed
	XOR	DL,DL
	CALL	SYSDISPMSG
	JMP	short KEYB_CP_FINISHED

KEYB_L_FINISHED:
	MOV	BX,ES:[DI].INVOKED_CP_TABLE ; Get invoked code page

	MOV	NUMBER_HOLDER,BX	;  transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	;  sublist points to...
	MOV	PTR_TO_NUMBER,SI	;  code page word
	MOV	AX,ACT_KEYB_CP		;  display '  code page: '
	MOV	BX,STDOUT		;  to standard out
	MOV	CX,1			;  one replacement
	MOV	DH,UTILITY_MSG_CLASS	;  utility message
	XOR	DL,DL			;  no input
	LEA	SI,SUBLIST_NUMBER	;  ptr to sublist
	CALL	SYSDISPMSG
	CMP	ID_DISPLAYED,1		;  was id displayed?
	JE	KEYB_CP_FINISHED	;  yes..continue.

	MOV	BX,WORD PTR ES:[DI].INVOKED_KBD_ID ;  get id code.
	or	bx,bx			;  no id given
	JE	KEYB_CP_FINISHED

	MOV	NUMBER_HOLDER,BX	;  transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	;  sublist points to...
	MOV	PTR_TO_NUMBER,SI	;  code page word
	MOV	AX,ACT_ID		;  display 'Current ID:  '
	MOV	BX,STDOUT		;  to standard out
	MOV	CX,1			;  one replacement
	MOV	DH,UTILITY_MSG_CLASS	;  utility message
	XOR	DL,DL			;  no input
	LEA	SI,SUBLIST_NUMBER	;  ptr to sublist
	CALL	SYSDISPMSG

	MOV	AH,09H			;  need a CR_LF here.
	MOV	DX,OFFSET CR_LF
	INT	21H

KEYB_CP_FINISHED:
	MOV	AX,CON_INSTALLED	;  If CON has been installed THEN
	or	ax,ax
	JNE	GET_ACTIVE_CP
	JMP	short CON_NOT_INSTALLED

GET_ACTIVE_CP:
	MOV	AX,0AD02H		;  Get active code page
	INT	2FH			;   information from the console
	JNC	DISPLAY_ACTIVE_CP
	JMP	ERROR5

DISPLAY_ACTIVE_CP:
	MOV	NUMBER_HOLDER,BX	; transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	; sublist points to...
	MOV	PTR_TO_NUMBER,SI	; code page word
	MOV	AX,ACT_CON_CP		; display 'Current CON code page: '
	MOV	BX,STDOUT		; to standard out
	MOV	CX,1			; one replacement
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_NUMBER	; ptr to sublist
	CALL	SYSDISPMSG

	JMP	KEYB_EXIT_NOT_RESIDENT	;  Exit from Proc

CON_NOT_INSTALLED:			; ELSE
	MOV	AX,INV_CON_Q
	MOV	BX,STDOUT		; Else
	XOR	CX,CX			;	Display message that CON does
	MOV	DH,UTILITY_MSG_CLASS	;	  not have active code page
	XOR	DL,DL
	CALL	SYSDISPMSG
	JMP	KEYB_EXIT_NOT_RESIDENT	; Exit from Proc

NOT_QUERY:				; IF not a query function requested
	CALL	BUILD_PATH		; Determine location of KEYBOARD.SYS
					;  ...and open file.

	JNC	VALID4			; If no error in opening file then
	JMP	ERROR4

VALID4:
	MOV	KEYBSYS_FILE_HANDLE,AX	; Save handle
	MOV	BP,OFFSET CMD_PARM_LIST ; Set base pointer for structures
	MOV	BX,KEYBSYS_FILE_HANDLE	; Retrieve the file handle
	MOV	DX,OFFSET FILE_BUFFER	; Set address of buffer

;************************* CNS ********;
	cmp	[BP].RET_CODE_4,ID_VALID ; CNS is there an ID available
	je	ID_TYPED		; if so go find out if it is
	jmp	short GET_LANG		; a 1st or 4th parm, if not must
					; must be a language
ID_TYPED:

	call	SCAN_ID			; scan the table for the ID
	cmp	ID_FOUND,1		; if a legal ID check and see if
	jne	LOST_ID			; it is a first or fourth parm

	cmp	FTH_PARMID,1		; if it is a fourth parm go
	je	GET_ID			; check for language compatibility
	jmp	short Language_found	; otherwise it must be a first
					; parm id value

LOST_ID:				; otherwise must be a bogus match
					; between language and ID codes
					;  or the ID code does not exist
	jmp	ERR1ID			; in the table
;************************* CNS ***********;

GET_LANG:				 ; Must be a language/or a 1st parm ID
				

	XOR	DI,DI			; Set number
	LEA	CX,[DI].KH_NUM_LANG+2	;	 bytes to read header

	MOV	AH,3FH			; Read header of the Keyb Def file
	INT	21H
	JNC	VALID5			; If no error in opening file then
	JMP	ERROR4

VALID5:
	CLD				;  all moves/scans forward
	MOV	CX,SIGNATURE_LENGTH
	MOV	DI,OFFSET SIGNATURE	; Verify matching
	MOV	SI,OFFSET FB.KH_SIGNATURE ;	     signatures
	REPE	CMPSB
	JE	LANGUAGE_SPECIFIED
	JMP	ERROR4
					; READ the language table
LANGUAGE_SPECIFIED:
	MOV	AX,FB.KH_NUM_LANG
	MOV	NUM_LANG,AX		; Save the number of languages
	MUL	LANG_PTR_SIZE		; Determine # of bytes to read
	MOV	DX,OFFSET FILE_BUFFER	; Establish beginning of buffer
	MOV	CX,AX
	CMP	CX,SIZE FILE_BUFFER	; Make sure buffer is not to small
	JBE	READ_LANG_TAB
	JMP	ERROR4

READ_LANG_TAB:
	MOV	AH,3FH			; Read language table from
	INT	21H			;	       Keyb Def file
	JNC	READ_VALID		; If no error in opening file then
	JMP	ERROR4			; Else display ERROR message

READ_VALID:
	MOV	CX,NUM_LANG		;    Number of valid codes
	MOV	DI,OFFSET FILE_BUFFER	;    Point to correct word in table

SCAN_LANG_TABLE:			; FOR language parm
	MOV	AX,[BP].LANGUAGE_PARM	;    Get parameter
	CMP	[DI].KP_LANG_CODE,AX	;    Valid Code ??
	JE	LANGUAGE_FOUND		; If not found AND more entries THEN

	ADD	DI,LANG_PTR_SIZE	;	  Check next entry
	DEC	CX			;    Decrement count of entries
	JNE	SCAN_LANG_TABLE		; Else
	JMP	ERROR1			;    Display error message

;**************************** CNS ****
GET_ID: 				; CNS - Must be an ID value
	mov	cx,1			; initialize ctr value for # of ids

SEARCH_ID:				; minimum per country
;					; There is atleast 1 ID for each country
	or	cx,cx			; check for any more IDs left to check
	jne	FINDID			; Country has more than one ID check
	jmp	END_IDCHK		; Country & ID has been found or value
					; is zero
FINDID:

	push	di			; save the current language entry ptr
	push	cx			; save the minimum # of ids before
					; reading the table data from the disk
;**************************** CNS ***********

LANGUAGE_FOUND:
	MOV	CX,WORD PTR [DI].KP_ENTRY_PTR+2	; Get offset of lang entry
	MOV	DX,WORD PTR [DI].KP_ENTRY_PTR	;	in the Keyb Def file
	MOV	WORD PTR KEYBCMD_LANG_ENTRY_PTR,DX ; Save
	MOV	WORD PTR KEYBCMD_LANG_ENTRY_PTR+2,CX ;	offset
	MOV	AH,42H				; Move file pointer to
	MOV	AL,0				;  location of language
	INT	21H				;  entry
	JNC	LSEEK_VALID
	JMP	ERROR4

LSEEK_VALID:
	MOV	DI,AX
	MOV	CX,SIZE KEYBSYS_LANG_ENTRY-1	; Set number
						;  bytes to read header
	MOV	DX,OFFSET FILE_BUFFER
	MOV	AH,3FH			; Read language entry in
	INT	21H			;  Keyb Def file
	JNC	VALID6a			; If no error in file then
	JMP	ERROR4

;**************************** CNS **********************************************


valid6a:
	cmp	FOURTH_PARM,1		; Is the ID a 4th Parm
	jne	VALID6			; if not get out of routine, otherwise
	pop	cx			; restore # of ids for the country
					; Check to see if this is the first
					; time checking the primary ID
	cmp	cx,1			; if there is just one ID check to make
	jne	CHK4PARM		; sure both flags are not set
					; this should not be necessary w/ new parser

	cmp	FTH_PARMID,1		; is the ID flag for switch set
	jne	CHK1N4			; is the flag set only for the 4th
	cmp	FOURTH_PARM,1		; if set only for the switch proceed
	jne	CHK1N4			; if not must be a positional
	mov	cl,fb.kl_num_id		; get the number of IDs available from the table
	mov	FTH_PARMID,0		; turn switch flag off so the table
					; counter will not be reset

					;ids available for the
CHK1N4: 				;country
	cmp	ONE_PARMID,1		; this was to be done if
	jne	CHK4PARM		; two the positional
	cmp	FOURTH_PARM,0		; and switch was specified
	jne	CHK4PARM		; this should never happen

	pop	di			; if the parser is intact
	jmp	error3			; report error & exit

CHK4PARM:				; check on the first ID
	cmp	FOURTH_PARM,1		; ID was a switch
	jne	ABORT_LOOP		; otherwise get out of routine
	call	IDLANG_CHK		; check the ID
	jmp	short ADVANCE_PTR	; advance to the next position

ABORT_LOOP:
	xor	cx,cx			; end loop

ADVANCE_PTR:
	pop	di			;restore entry value

	dec	cx			; # of ids left to check
	je	NO_ADVANCE		; if 0, don't advance table position
	cmp	GOOD_MATCH,1		; check to see if ID matched language
	je	NO_ADVANCE		; if equal do not advance

	add	di,LANG_PTR_SIZE	; step to the next entry
					; in the table

NO_ADVANCE:

	jmp	SEARCH_ID		; for the country

;					; end of ID check for country

END_IDCHK:

	cmp	FOURTH_PARM,1		; see if id was found
	jne	VALID6
	cmp	GOOD_MATCH,0		; none found
	jne	VALID6			; report error

	mov	[bp].ret_code_4,1	; incompatible lang code
	mov	al,[bp].ret_code_4	; id combo
	jmp	err2id

					; otherwise found it
					; continue to build tbl
;**************************** CNS **********************************************

VALID6:
	MOV	AX,WORD PTR FB.KL_LOGIC_PTR	; Save the offset of the state
	MOV	WORD PTR STATE_LOGIC_OFFSET,AX	;    logic section
	MOV	AX,WORD PTR FB.KL_LOGIC_PTR+2	; Save the offset of the state
	MOV	WORD PTR STATE_LOGIC_OFFSET+2,AX ;   logic section

	MOV	DL,[BP].RET_CODE_2	; IF code page was specified
	CMP	DL,2
	JNE	CODE_PAGE_SPECIFIED
	JMP	short DONE

CODE_PAGE_SPECIFIED:		      ;  Then

;************************** CNS ***************************************
	xor	ah,ah
	MOV	Al,FB.KL_NUM_CP
;************************** CNS ***************************************

	MOV	NUM_CP,AX		; Save the number of code pages
	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	MOV	DX,OFFSET FILE_BUFFER	; Establish beginning of buffer
	MOV	CX,AX
	CMP	CX,SIZE FILE_BUFFER	; Make sure buffer is not to small
	JBE	VALID7
	JMP	ERROR4

VALID7:
	MOV	AH,3FH			; Read code page table from
	INT	21H			;	Keyb Def file
	JNC	VALID8			; If no error in opening file then
	JMP	ERROR4

VALID8:
	MOV	CX,NUM_CP		;    Number of valid codes
	MOV	DI,OFFSET FILE_BUFFER	;    Point to correct word in table

SCAN_CP_TABLE:				; FOR code page parm
	MOV	AX,[BP].CODE_PAGE_PARM	;    Get parameter
	CMP	[DI].KC_CODE_PAGE,AX	;    Valid Code ??
	JE	CODE_PAGE_FOUND		; If not found AND more entries THEN

	ADD	DI,CP_PTR_SIZE		;    Check next entry
	DEC	CX			;    Decrement count of entries
	JNE	SCAN_CP_TABLE		; Else
	JMP	ERROR2			;    Display error message
				
CODE_PAGE_FOUND:
	MOV	AX,WORD PTR [DI].KC_ENTRY_PTR
	MOV	WORD PTR CP_TAB_OFFSET,AX
	MOV	AX,WORD PTR [DI].KC_ENTRY_PTR+2
	MOV	WORD PTR CP_TAB_OFFSET+2,AX

DONE:
	MOV	SI,OFFSET DESIG_CP_BUFFER

	MOV	AX,CON_INSTALLED	;  If CON is NOT installed THEN
	or	ax,ax
	JE	SYSTEM_CP
	JMP	short GET_DESIG_CPS

SYSTEM_CP:
	MOV	CX,1
	MOV	NUM_DESIG_CP,CX		; Set number of CPs = 1
	MOV	[SI].NUM_DESIGNATES,CX

	MOV	DL,[BP].RET_CODE_2	; Check if code page parm
	or	dl,dl			;    was specified
	JNE	SET_TO_SYSTEM_CP

	MOV	DX,[BP].CODE_PAGE_PARM
	MOV	[SI].DESIG_CP_ENTRY,DX	; Load specified code page into
	JMP	READY_TO_BUILD_TABLE	;      designated code page list

SET_TO_SYSTEM_CP:
	CALL	FIND_FIRST_CP		; Call routine that sets the first
	or	ax,ax			;   table found in the Keyb Def file
	JE	SET_TO_SYSTEM_CP2	;	to the system code page
	JMP	ERROR4

SET_TO_SYSTEM_CP2:
	MOV	SYS_CODE_PAGE,BX
	MOV	[BP].CODE_PAGE_PARM,BX
	MOV	[SI].DESIG_CP_ENTRY,BX	;    Move sys CP into desig list
	JMP	READY_TO_BUILD_TABLE

GET_DESIG_CPS:				;  ELSE
	MOV	AX,0AD03H
	PUSH	CS			; Make sure ES is set
	POP	ES
	LEA	DI,DESIG_CP_BUFFER
	MOV	CX,DESIG_CP_BUF_LEN
	INT	2FH			; Get all designated code pages
	JNC	SET_DESIG_VARIABLES	;  from console
	JMP	ERROR5

SET_DESIG_VARIABLES:
	MOV	CX,[SI].NUM_DESIGNATES
	ADD	CX,[SI].NUM_HW_CPS
	MOV	NUM_DESIG_CP,CX		; Set number of Designated CPs

BUFFER_CREATED:
	MOV	AX,0AD02H
	INT	2FH			; Get invoked code page

SET_TO_CP_INVOKED:
	MOV	DL,[BP].RET_CODE_2	; IF code page parm was specified
	or	dl,dl
	JNE	SET_TO_INVOKED_CP

	MOV	CX,NUM_DESIG_CP
	MOV	DESIG_LIST,SI
	JMP	short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP:
	CMP	AX,1			; IF a code page has been invoked
	JNE	SET_TO_INVOKED_CP3

	CALL	FIND_FIRST_CP		; Call the routine that sets the
	or	ax,ax			; first code page in the Keyb Def
	JE	SET_TO_INVOKED_CP2	;  file to the system code page
	JMP	ERROR4

SET_TO_INVOKED_CP2:
	MOV	[BP].CODE_PAGE_PARM,BX
	MOV	SYS_CODE_PAGE,BX

	JMP	short TEST_IF_DESIGNATED

SET_TO_INVOKED_CP3:
	MOV	[BP].CODE_PAGE_PARM,BX

TEST_IF_DESIGNATED:
	MOV	DX,[BP].CODE_PAGE_PARM
	CMP	[SI].DESIG_CP_ENTRY,DX	; Is Code page specified in the list
	JE	CODE_PAGE_DESIGNATED	;   of designated code pages ?

NEXT_DESIG_CP:
	ADD	SI,2			; Check next code page
	DEC	CX			; If all designated code pages have
	JNZ	TEST_IF_DESIGNATED	;   been checked Then ERROR
	JMP	ERROR6

CODE_PAGE_DESIGNATED:
	CMP	SYS_CODE_PAGE,0
	JNE	READY_TO_BUILD_TABLE
	CMP	AX,1			; IF a code page has been invoked
	JE	READY_TO_BUILD_TABLE
	CMP	[BP].CODE_PAGE_PARM,BX	; IF Invoked CP <> Specified CP
	JE	READY_TO_BUILD_TABLE	;	 Issue warning

;***************************************************************************
	PUSH	BX
	PUSH	CX
	MOV	AX,WARNING_1
	MOV	BX,STDOUT
	XOR	CX,CX
	MOV	DH,UTILITY_MSG_CLASS
	XOR	DL,DL
	CALL	SYSDISPMSG
	POP	CX
	POP	BX
;***************************************************************************


READY_TO_BUILD_TABLE:

	MOV	AX,KEYB_INSTALLED
	or	ax,ax			; Else if KEYB has not been installed
	JNE	BUILD_THE_TABLE

	CALL	FIND_SYS_TYPE		; Determine system type for INT 9 use

;------ LOAD IN SPECIAL INT 9 HANDLER AND SPECIAL TABLES

	CALL	INSTALL_INT_9		; Install INT 9

	CALL	FIND_KEYB_TYPE		; Determine keyboard type table use

BUILD_THE_TABLE:
	CALL	TABLE_BUILD		; Build the TEMP_SHARED_DATA_AREA

CHECK_ERRORS:
					; Take appropriate action considering
	MOV	CX,TB_RETURN_CODE	;  return codes from TABLE_BUILD
	jcxz	CHECK_FOR_INV_CP	; If return code is not 0

	MOV	AX,KEYB_INSTALLED	; If KEYB has not been installed,
	or	ax,ax
	JNE	CHECK_ERROR_CONTINUE

	CALL	REMOVE_INT_9		;     remove installed vector

CHECK_ERROR_CONTINUE:
	CMP	CX,1			; If return code = 1
	JNE	CHECK_ERROR2
	JMP	ERROR1			;     display error message

CHECK_ERROR2:
	CMP	CX,2			; If return code = 2
	JNE	CHECK_ERROR3
	JMP	ERROR2

CHECK_ERROR3:
	CMP	CX,3			; If return code = 3
	JNE	CHECK_ERROR4
	JMP	ERROR3			;     display error message

CHECK_ERROR4:
	CMP	CX,4			; If return code = 4
	JNE	CHECK_ERROR5A
	JMP	ERROR4			;     display error message

CHECK_ERROR5A:
	CMP	CX,5			; If return code = 5
	JNE	CHECK_ERROR6A
	JMP	ERROR5A			;     display error message

CHECK_ERROR6A:
	JMP	ERROR6A			; If return code not 0,1,2,3,4 then
					;      display error message
CHECK_FOR_INV_CP:
	MOV	CX,CPN_INVALID		; Check if any CPs were not loaded
	jcxz	TERMINATE		;   If some were invalid, issue
					;	warning message

;***************************************************************************
	PUSH	BX
	PUSH	CX
	MOV	AX,NOT_SUPP
	MOV	BX,STDOUT		;  WARNING
	XOR	CX,CX			;   MESSAGE
	MOV	DH,UTILITY_MSG_CLASS
	XOR	DL,DL
	CALL	SYSDISPMSG
	POP	CX
	POP	BX
;***************************************************************************

TERMINATE:
	MOV	AH,3EH			;  Close the KEYBOARD.SYS file
	MOV	BX,KEYBSYS_FILE_HANDLE	;  if open
	or	bx,bx
	JE	KEYB_EXIT
	INT	21H

	MOV	AX,KEYB_INSTALLED
	or	ax,ax
	JE	KEYB_EXIT
	JMP	KEYB_EXIT_NOT_RESIDENT

KEYB_EXIT:
	TEST	SD.KEYB_TYPE,G_KB	; Q..FERRARI G??
	JZ	NO_FERRARI_G		; N..LEAVE NUMLK ALONE
	TEST	SD.SYSTEM_FLAG,PC_XT	;   Q..PC/XT?
	JNZ	NO_FERRARI_G		;   Y..LEAVE NUMLK ALONE
	TEST	SD.KEYB_TYPE,P_KB	;      Q..FERRARI P??
	JNZ	NO_FERRARI_G		;      Y..LEAVE NUMLK ALONE

;***CNS
	CMP	SECURE_FL,1		; IF SECURITY FLAG SET
	JNE	NO_FERRARI_G		; DON'T TURN ON NUM_LK

;***CNS
	CALL	NUMLK_ON		;    N..TURN NUMLK ON

NO_FERRARI_G:
	TEST	SD.SYSTEM_FLAG,EXT_16	; extended INT 16 support?
	JZ	SKIP_CTRL_COPY
				       ; Yes, load extened CTRL case table

	MOV	CX,L_CTRL_TAB	       ; CX = LENGTH OF EXTENDED TABLE
	MOV	SI,OFFSET CS:RPL_K8    ; POINT TO EXT. CTRL TABLES
	MOV	DI,OFFSET CS:K8        ; POINT TO REGULAR CTRL TABLE
	CLD			
	REP	MOVSB		       ; OVERLAY WITH EXT. CTRL TABLE
				
SKIP_CTRL_COPY: 		
	CALL	INSTALL_INT_9_NET	; Let the network know about INT 9
					;     (if the network is installed)
	CALL	INSTALL_INT_2F		; Install INT 2F
				
	MOV	AX,0AD82H		; Activate language
	MOV	BL,-1
	INT	2FH
				
	MOV	AH,31H			; Function call to terminate but stay
	XOR	AL,AL			;   resident
	MOV	DI,OFFSET SD_DEST_PTR	; Initialize destination ptr
				
	MOV	DX,ES:TSD.RESIDENT_END	; Get resident end
				
	CALL	COPY_SDA_SETUP		; Set up move common code
				
	JMP	COPY_SD_AREA		; Jump to proc that copies area in new
					;	part of memory

;***************************** CNS **************************************
ERR1ID:
;************************************************************************

	MOV	AX,INV_I		; invalid ID message
	MOV	BX,STDOUT		;  to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	KEYB_EXIT_NOT_RESIDENT
ERR2ID:
;***************************************************************************

	MOV	AX,INV_COMBO		; invalid combination message
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;**************************************************************************
	JMP	KEYB_EXIT_NOT_RESIDENT
;***************************** CNS ****************************************

ERROR1:
;***************************************************************************
	MOV	AX,INV_L		; invalid language code
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message

	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL
;***************************************************************************

	JMP	KEYB_EXIT_NOT_RESIDENT
ERROR2:
;***************************************************************************
	MOV	AX,INV_CP		; invalid code page message
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message

	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	KEYB_EXIT_NOT_RESIDENT
ERROR3:
;***************************************************************************

	MOV	AX,INV_S		; invalid syntax message
	MOV	BX,STDOUT		; to standard out
;***CNS

	LEA	DI,STRING_HOLDER	;Set PTR to look at the STRING
	PUSH	SI			;Save current SI index
	PUSH	AX
	MOV	AX,OLD_PTR		;Last locale of the end of a PARAM
	SUB	CUR_PTR,AX		;Get the length via the PSP
	MOV	SI,CUR_PTR
	MOV	CX,SI			;Save it in CX to move in the chars
	POP	AX			;Restore the PTR to the command line position

	MOV	SI,OLD_PTR		;Last locale of the end of a PARAM
	REP	MOVSB			;Move in the chars until no more

	LEA	DI,STRING_HOLDER	;Set PTR to look at the STRING


	POP	SI			;Restore the PTR to the command line position

	MOV	CX,1			;One replacement
	MOV	PTR_TO_COMLIN,DI	; language code asciiz string


	PUSH	AX
	MOV	AX,DS			; language code asciiz string
	MOV	SEG_OF_COMLIN,AX
	POP	AX

	MOV	AX,ERR_PART
	LEA	SI,SUBLIST_COMLIN
	MOV	DH,PARSE_ERR_CLASS	; parse error message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,INVALID_PARMS
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR4:
;***************************************************************************

	MOV	AX,INV_FN		; bad or missing file message
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,BAD_KEYB_DEF_FILE
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR5:
;***************************************************************************

	MOV	AX,INV_CON_Q		; CON code page not available.
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,CONSOLE_ERROR
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR5A:
;***************************************************************************

	MOV	AX,MEMORY_OVERF		; not enough resident memory.
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,MEMORY_OVERFLOW
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR6:
;***************************************************************************

	MOV	AX,NOT_DESIG		; code page not prepared.
	MOV	BX,STDOUT		; to standard out
	XOR	CX,CX			; no substitutions
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	CALL	SYSDISPMSG		; display message
	MOV	AL,CP_NOT_DESIGNATED
	MOV	EXIT_RET_CODE,AL

;***************************************************************************
	JMP	short KEYB_EXIT_NOT_RESIDENT
ERROR6A:
;***************************************************************************

	MOV	NUMBER_HOLDER,BX	; transfer number to temp loc.
	LEA	SI,NUMBER_HOLDER	; sublist points to...
	MOV	PTR_TO_NUMBER,SI	; code page word
	MOV	AX,NOT_VALID		; display 'Code page requested....'
	MOV	BX,STDOUT		; to standard out
	MOV	CX,1			; one replacement
	MOV	DH,UTILITY_MSG_CLASS	; utility message
	XOR	DL,DL			; no input
	LEA	SI,SUBLIST_NUMBER	; ptr to sublist
	CALL	SYSDISPMSG

	MOV	AL,KEYB_TABLE_NOT_LOAD
	MOV	EXIT_RET_CODE,AL

;***************************************************************************

KEYB_EXIT_NOT_RESIDENT:
	MOV	AH,04CH
	MOV	AL,QUERY_CALL		; Check if this was a query call
	or	al,al
	JNE	KEYB_EXIT3		;  IF yes then EXIT

	MOV	AL,EXIT_RET_CODE	; Check if return code was valid
	or	al,al
	JNE	KEYB_EXIT3		;  IF not then EXIT

COPY_INTO_SDA:
	MOV	AX,0AD82H		; Activate language
	MOV	BL,-1
	INT	2FH

	MOV	AH,04CH
	MOV	AL,EXIT_RET_CODE
	MOV	DI,WORD PTR SHARED_AREA_PTR+2	; Initialize destination ptr
	MOV	ES,WORD PTR SHARED_AREA_PTR
	MOV	DX,[BP].RESIDENT_END

	CALL	COPY_SDA_SETUP	       ; Set up move common code

	JMP	COPY_SD_AREA	       ; Jump to proc that copies area in new

KEYB_EXIT3:
	MOV	AL,EXIT_RET_CODE
	MOV	DI,WORD PTR SHARED_AREA_PTR+2	; Initialize destination ptr
	MOV	ES,WORD PTR SHARED_AREA_PTR
	MOV	ES:[DI].TABLE_OK,1
	INT	21H

KEYB_COMMAND  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: COPY_SDA_SETUP
;
; Description:
;     Common setup logic for exit
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COPY_SDA_SETUP	PROC	NEAR

	push	ax			;save existing values
	push	es
	mov	ax,cs:[2ch]		;check offset for address containin environ.
	or	ax,ax
	je	NO_FREEDOM

	mov	es,ax
	mov	ax,4900H		;make the free allocate mem func
	int	21h

NO_FREEDOM:
	pop	es			;restore existing values
	push	bx
					;Terminate and stay resident
	mov	bx,4			;1st close file handles
					;STDIN,STDOUT,STDERR
closeall:
	mov	ah,3eh
	int	21h
	dec	bx
	jnz	closeall

	pop	bx
	pop	ax

	MOV	CL,4			; Convert into paragrahs
	SHR	DX,CL
	INC	DX

	MOV	SI,OFFSET SD_SOURCE_PTR	; Initialize source ptr
	XOR	BP,BP
	LEA	BX,[BP].ACTIVE_LANGUAGE
	ADD	DI,BX			; Adjust for portion not copied
	ADD	SI,BX			; Adjust for portion not copied

	MOV	CX,SD_LENGTH		; Set length of SHARED_DATA_AREA
	SUB	CX,BX			; Adjust for portion not copied

	RET

COPY_SDA_SETUP	ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Procedure: NUMLK_ON
;
; Description:
;     Turn  Num Lock On.
;
; Input Registers:
;     N/A
;
; Output Registers:
;     N/A
;
; Logic:
;     Set Num Lock bit in BIOS KB_FLAG
;     Issue Int 16 to update lights
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

NUMLK_ON     PROC

	PUSH	ES
	PUSH	AX

	MOV	AX,DATA
	MOV	ES,AX

	OR	ES:KB_FLAG,NUM_STATE	; Num Lock state active
	MOV	AH,1			; Issue keyboard query call to
	INT	16H			;  have BIOS update the lights

	POP	AX
	POP	ES
	RET

NUMLK_ON   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9
;
; Description:
;     Install our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	Get existing vector
;	Install our vector
;	Return
;

INSTALL_INT_9	     PROC

	PUSH	ES

	MOV	AH,35H			; Get int 9 vector
	MOV	AL,9
	INT	21H			; Vector in ES:BX

	PUSH	ES			; Save segment ES:
	PUSH	CS
	POP	ES
	MOV	WORD PTR ES:SD.OLD_INT_9,BX ; Offset
	POP	AX			; Recover ES: segment
	MOV	WORD PTR ES:SD.OLD_INT_9+2,AX ; Segment

	MOV	AH,25H
	MOV	AL,9
	MOV	DX,OFFSET KEYB_INT_9	; Let DOS know about our handler
	INT	21H

	POP	ES
	RET

INSTALL_INT_9	     ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_9_NET
;
; Description:
;
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	IF network is installed THEN
;	  Let it know about our INT 9
;	Return
;

INSTALL_INT_9_NET    PROC

	PUSH	ES

	TEST	SD.SYSTEM_FLAG,PC_NET	; TEST FOR PC_NETWORK
					; IF NOT THE NETWORK INSTALLED
	JZ	INSTALL_9_DONE_NET	; SKIP THE PC NETWORK HANDSHAKE

					; ES:BX TO CONTAIN INT 9 ADDR
	MOV	BX,OFFSET KEYB_INT_9
	MOV	AX,0B808H		; FUNCTION FOR PC NETWORK TO INSTALL
					; THIS ADDRESS FOR THEIR JUMP TABLE
	INT	2FH			; TELL PC_NET TO USE MY ADDR TO CHAIN TO

INSTALL_9_DONE_NET:
	POP	ES
	RET

INSTALL_INT_9_NET    ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: INSTALL_INT_2F
;
; Description:
;     Install our INT 2F drivers.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	Get existing vectors
;	Install our vectors
;	Return
;
;
INSTALL_INT_2F    PROC

	MOV	AH,35H			; Get int 2f vector
	MOV	AL,2FH
	INT	21H			; Vector in ES:BX

	PUSH	ES			; Save segment ES:
	PUSH	CS
	POP	ES
	MOV	WORD PTR ES:SD.OLD_INT_2F,BX ; Offset
	POP	AX			; Recover ES: segment
	MOV	WORD PTR ES:SD.OLD_INT_2F+2,AX ; Segment

	MOV	AH,25H			; Set int 9 vector
	MOV	AL,2FH
	MOV	DX,OFFSET KEYB_INT_2F	; Vector in DS:DX
	INT	21H


	RET

INSTALL_INT_2F    ENDP

;
;
; Module: REMOVE_INT_9
;
; Description:
;     Remove our INT 9 driver.
;
; Input Registers:
;     DS - points to our data segment
;     BP - points to ES to find SHARED_DATA_AREA
;
; Output Registers:
;     DS - points to our data segment
;     AX, BX, DX, ES  Trashed
;
; Logic:
;	Get old vector
;	Install old vector
;	Return
;

REMOVE_INT_9	    PROC

	PUSH	DS
	PUSH	ES
	MOV	ES,WORD PTR SHARED_AREA_PTR
	MOV	AX,WORD PTR ES:SD.OLD_INT_9+2	; int 9 vector - segment
	MOV	DS,AX
	MOV	DX,WORD PTR ES:SD.OLD_INT_9	; int 9 vector - offset

	MOV	AH,25H			; Set int 9 vector
	MOV	AL,9
	INT	21H

REMOVE_9_DONE:
	POP	ES
	POP	DS
	RET

REMOVE_INT_9		 ENDP



IDLANG_CHK	PROC	NEAR

	mov	ax,fb.kl_id_code	;get the id code from the table
	cmp	ax,[bp].id_parm 	;compare it to value taken
	jne	end_match		;from the switch-- if found
	cmp	ALPHA,0 		;a keyboard code was specified
	je	a_match 		;no lang & a match

	mov	ax,fb.kl_lang_code	;compare lang codes
	cmp	ax,[BP].LANGUAGE_PARM	;they are equal
	je	a_match

	jmp	short end_match		;if not found go check next
					;id for the same country

a_match:
	mov	good_match,1		;report the ids match

end_match:
	ret

    IDLANG_CHK	ENDP
;*********************** CNS *******************;

;**********************************SCAN_ID***********************;
; New variables defined - NUM_ID,ADRSS_LANG,ID_PTR_SIZE,ID_FOUND
;****************************************************************;


SCAN_ID PROC	NEAR

	xor	di,di			;clear di to set at the
					;beginning of KEYBSYS STRUCTURE


	lea	cx,[di].kh_num_ID+4	; set number of bytes to read header

	mov	ah,3fh
	int	21h
	jnc	VAL5ID
	jmp	short BAD_TAB 		 ;bad table message

 VAL5ID:

	mov	cx,SIGNATURE_LENGTH
	mov	di,offset SIGNATURE
	mov	si,offset FB.KH_SIGNATURE
	repe	CMPSB
	je	ID_SPECIFIED
	jmp	short BAD_TAB



 ID_SPECIFIED:

	mov	ax,FB.KH_NUM_ID
	mov	NUM_ID,ax		; save # of IDs
	mul	ID_PTR_SIZE		; determine # of bytes to read
	push	ax			; save current # of bytes to read for
					; ID values only
	mov	ax,FB.KH_NUM_LANG	; add on lang data in table
	mul	LANG_PTR_SIZE		; data that comes before the ID data
	mov	cx,ax			; save that value for the size compare
	mov	PASS_LANG,cx
	pop	ax			; restore the info for # of ID bytes to read

	add	cx,ax			; add that value to get total in CX
	mov	TOTAL_SIZE,cx		; save the total size
	cmp	cx,size FILE_BUFFER
	jbe	READ_ID_TAB
	jmp	short BAD_TAB


READ_ID_TAB:
	mov	dx,offset FILE_BUFFER
	mov	ah,3fh			;read language table from
	int	21h			;keyb defn file
	jnc	READ_IDVAL
	jmp	short BAD_TAB

READ_IDVAL:

	mov	cx,NUM_ID
	mov	di,offset FILE_BUFFER
	add	di,PASS_LANG

SCAN_ID_TAB:

	mov	ax,[bp].ID_PARM
	cmp	[di].KP_ID_CODE,ax
	je	ID_HERE

	add	di,ID_PTR_SIZE
	dec	cx
	jne	SCAN_ID_TAB

	jmp	short FINALE

BAD_TAB:
	mov	ERR4ID,1
	jmp	short FINALE

ID_HERE:
	mov	ID_FOUND,1		;reset ptr for
					;current country
FINALE:
	ret

SCAN_ID	ENDP

;*******************************SCAN_ID END******;
;
; Module: BUILD_PATH
;
; Description:
;     Build the complete filename of the Keyboard Definition File
;*************************************WGR*********************
;     and open the file.
;+++++++++++++++++++++++++++++++++++++WGR+++++++++++++++++++++
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;************************************WGR**********************
;     CARRY CLEAR
;	    AX = HANDLE
;     CARRY SET (ERROR)
;	    NONE
;++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++++++
;    The complete filename will be available in FILE_NAME
;
; Logic:
;
;    Determine whether path parameter was specified
;    IF length is zero THEN
;****************************************WGR******************
;	Try to open file in ACTIVE directory
;	IF failed THEN
;	  Try to open file in ARGV(0) directory
;	  IF failed THEN
;	    Try to open file in ROOT directory (for DOS 3.3 compatibility)
;	    ENDIF
;	  ENDIF
;	ENDIF
;    ELSE
;	Copy path from PSP to FILE_NAME memory area
;	Try to open USER SPECIFIED file
;++++++++++++++++++++++++++++++++++++++++WGR++++++++++++++++++
;
;

KEYBOARD_SYS	DB   '\KEYBOARD.SYS',00
KEYB_SYS_ACTIVE DB   'KEYBOARD.SYS',00
KEYB_SYS_LENG	EQU  14
KEYB_SYS_A_LENG EQU  13

FILE_NAME	DB   128 DUP(0)

FILE_NOT_FOUND	EQU  2
PATH_NOT_FOUND	EQU  3
;
;  Program Code
;

BUILD_PATH    PROC  NEAR

	CLD
	MOV	DI,OFFSET FILE_NAME	; Get the offset of the filename
	MOV	CX,[BP].PATH_LENGTH	; If path is specified then
	jcxz	APPEND_KEYB_SYS

	MOV	SI,[BP].PATH_OFFSET	;   Get the offset of the path

	REPE	MOVSB			;   Copy each char of the specified

	MOV	AX,3D00H		; Open the KEYBOARD.SYS file
	MOV	DX,OFFSET FILE_NAME
	INT	21H
	RET				;   path into the filename location

APPEND_KEYB_SYS:
	MOV	SI,OFFSET KEYB_SYS_ACTIVE ;  copy name for active directory
	MOV	CX,KEYB_SYS_A_LENG	;  to file name variable.
	REPE	MOVSB

	MOV	AX,3D00H		; try to open it.
	MOV	DX,OFFSET FILE_NAME
	INT	21H

	jnc	opened_ok		; brif no error opening

	cmp	ax,PATH_NOT_FOUND	; was it path?
	jz	open_err_1
	cmp	ax,FILE_NOT_FOUND	; or file not found?
	jnz	open_err_2

open_err_1:
	CALL	COPY_ARGV0		; yes....try ARGV(0) directory.
	MOV	AX,3D00H
	MOV	DX,OFFSET FILE_NAME
	INT	21H

	jnc	opened_ok		; done if open ok

	cmp	ax,PATH_NOT_FOUND	; if path or file not found, try root
	jz	open_err_3
	cmp	ax,FILE_NOT_FOUND
	jnz	open_err_2

open_err_3:
	MOV	SI,OFFSET KEYBOARD_SYS	; try ROOT directory.
	MOV	DI,OFFSET FILE_NAME
	MOV	CX,KEYB_SYS_LENG
	REPE	MOVSB

	MOV	AX,3D00H
	MOV	DX,OFFSET FILE_NAME
	INT	21H

	jmp	short opened_ok

open_err_2:
	stc				; some other error, set error flag

opened_ok:

	RET

BUILD_PATH	ENDP


COPY_ARGV0  PROC

	PUSH	ES
	PUSH	DI
	PUSH	SI
	PUSH	CX

	MOV	DI,2CH		       ; Locate environment string
	MOV	ES,[DI]
	XOR	SI,SI

carv0_loop:
	cmp	word ptr es:[si],0	; find ARGV(0) string
	jz	carv0_loop_exit
	inc	si
	jmp	carv0_loop

carv0_loop_exit:
	ADD	SI,4
	LEA	DI,FILE_NAME		; move string to work area

carv0_loop1:
	MOV	AL,ES:[SI]
	MOV	[DI],AL
	INC	SI
	INC	DI
	cmp	byte ptr es:[si],0
	jnz	carv0_loop1

carv0_loop2:
	dec	di
	cmp	byte ptr [di],'\'	; scan back to first character after "\"
	jz	carv0_loop2_exit
	cmp	byte ptr [di],0
	jnz	carv0_loop2

carv0_loop2_exit:
	INC	DI
	PUSH	CS
	POP	ES
	LEA	SI,KEYB_SYS_ACTIVE	; copy in "KEYBOARD.SYS"
	MOV	CX,KEYB_SYS_A_LENG
	REPE	MOVSB

	POP	CX
	POP	SI
	POP	DI
	POP	ES
	RET

COPY_ARGV0  ENDP

;
;
; Module: FIND_FIRST_CP
;
; Description:
;     Check the keyboard definition file for the first code page
;
; Input Registers:
;     DS - points to our data segment
;     ES - points to our data segment
;     BP - offset of parmeter list
;
; Output Registers:
;	    NONE
;
; Logic:
;   Open the file
;   IF error in opening file THEN
;	Display ERROR message and EXIT
;   ELSE
;	Save handle
;	Set address of buffer
;	READ header of Keyboard definition file
;	IF error in reading file THEN
;	   Display ERROR message and EXIT
;	ELSE
;	   Check signature for correct file
;	   IF file signature is correct THEN
;	      READ language table
;	      IF error in reading file THEN
;		  Display ERROR message and EXIT
;	      ELSE
;		  Use table to verify language parm
;		  Set pointer values
;		  IF code page was specified
;		      READ language entry
;		      IF error in reading file THEN
;			   Display ERROR message and EXIT
;		      ELSE
;			   READ first code page
;			   IF error in reading file THEN
;			       Display ERROR message and EXIT
;   RET
;
;

FIND_FIRST_CP PROC  NEAR

	PUSH	CX			; Save everything that
	PUSH	DX			;  that will be changed
	PUSH	SI
	PUSH	DI

	MOV	BX,KEYBSYS_FILE_HANDLE	; Get handle
	MOV	DX,WORD PTR KEYBCMD_LANG_ENTRY_PTR   ; LSEEK file pointer
	MOV	CX,WORD PTR KEYBCMD_LANG_ENTRY_PTR+2 ;	to top of language entry
	MOV	AH,42H
	MOV	AL,0			; If no problem with
	INT	21H			;     Keyb Def file Then
	JNC	FIND_FIRST_BEGIN
	JMP	short FIND_FIRST_CP_ERROR4

FIND_FIRST_BEGIN:
	MOV	DI,AX
	MOV	CX,SIZE KEYBSYS_LANG_ENTRY-1 ; Set number
					;	bytes to read header
	MOV	DX,OFFSET FILE_BUFFER
	MOV	AH,3FH			; Read language entry in
	INT	21H			;	 keyboard definition file
	JNC	FIND_FIRST_VALID4	; If no error in opening file then
	JMP	short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID4:

;************************** CNS *******;
	xor	ah,ah
	MOV	Al,FB.KL_NUM_CP
;************************** CNS *******;

	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	MOV	DX,OFFSET FILE_BUFFER	; Establish beginning of buffer
	MOV	CX,AX
	CMP	CX,SIZE FILE_BUFFER	; Make sure buffer is not to small
	JBE	FIND_FIRST_VALID5

	JMP   short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID5:
	MOV	AH,3FH			; Read code page table from
	INT	21H			;	     keyboard definition file
	JNC	FIND_FIRST_VALID6	; If no error in opening file then
	JMP	short FIND_FIRST_CP_ERROR4

FIND_FIRST_VALID6:
	MOV	CX,NUM_CP		; Number of valid codes
	MOV	DI,OFFSET FILE_BUFFER	; Point to correct word in table

	MOV	BX,[DI].KC_CODE_PAGE	; Get parameter
	XOR	AX,AX
	JMP	short FIND_FIRST_RETURN

FIND_FIRST_CP_ERROR4:
	MOV	AX,4

FIND_FIRST_RETURN:
	POP	DI
	POP	SI
	POP	DX
	POP	CX

	RET

FIND_FIRST_CP  ENDP

	.xlist
MSG_SERVICES <MSGDATA>
MSG_SERVICES <LOADmsg,DISPLAYmsg,CHARmsg,NUMmsg>
MSG_SERVICES <KEYB.CL1>
MSG_SERVICES <KEYB.CL2>
MSG_SERVICES <KEYB.CLA>
	.list
;
; Temp Shared Data Area
; Contains data which is required by
; both the resident and transient KEYB code.
; All keyboard tables are stored in this area
; Structures for this area are in file KEYBSHAR.INC
;
	db	'TEMP SHARED DATA'
SD_SOURCE_PTR	LABEL	   BYTE
TEMP_SHARED_DATA SHARED_DATA_STR <>

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybi9c.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
PAGE	,132

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                                              
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;  File Name:  KEYBI9C.ASM
;  ----------
;
;
;  Description:
;  ------------
;	 Interrupt 9 mainline.
;	 This routine handles all US keyboard support for the following
;	 system units:	PC, PC-XT, PC-AT, PC Convertible, PC-XT/286
;			Models 25 and 30 (PALACE),
;			PS/2's - all 8042 based 80286, 80386 and 80486.
;			       - all PATRIOT and SEBRING based systems.
;	 KEYB_STATE_PROCESSOR is called for non-US keyboard support.
;
;
;
;  Procedures Contained in This File:
;  ----------------------------------
;	 KEYB_INT_9 - Interrupt 9
;
;  External Procedure References:
;  ------------------------------
;	 FROM FILE  KEYBI9.ASM:
;	      KEYB_STATE_PROCESSOR - Non US keyboard support.
;
;  Linkage Information:  Refer to file KEYB.ASM
;  --------------------
;
;  Change History:
;  ---------------
;  ; - DCR 478 -	KEYBOARD INT SPLICING Nick Savage  ;deleted by AN005
;  ; - PTM 3090	ENABLING RIGHT CTL FOR RE-BOOTING
;  ; - PTM 60XX	PICK UP ALL KEYBOARD BIOS PTR's AND DCR's TO BRING
;			INT 9h	UP TO THE TOPHAT (80486) SUPPORT LEVEL. '89  jwg
;	   PTR 6600736	Keep INT's disabled till after PORT 60h read.
;	   PTR 6600756	EXTRA EOI ISSUED IF INTERRUPTS SATURATED **********
;			   NOTE: This is a fix for a BIOS bug that goes all
;			    the way back to the first AT.  The rationale for
;			    the fix is as follows:
;	    (deleted AN005)	A stack frame is created upon entry (BP) and
;				CHK_EOI is called to check the frame. If no
;				EOI has been issued, CHK_EOI does it and
;				resets the frame, preventing any additinal
;				EOI's from being issued on subsequent calls
;				to CHK_EOI.  All direct EOI's in the code
;				have been replaced with calls to CHK_EOI.
;
;  ;Ax004; - PTM 2555	KEYB command locks keyboard. 10/5/89;cja
;			; jwg 11/09/98 Updates - Wild Mouse, etc workaround.....
;  ; - PTM 5802	Restructure Interrupt Splicing to correct lost Mouse
;			interrupt when LED's are updated.  Make it apply to
;			all systems. Essentially remove all code added by AN001.
;			Remove stack frame logic of AN003 and PTR 6600756 and do
;			an early EOI.  Requires a CLI at K38B and other places.
;			Remove Chk_ibf before 60h.
;			Re-write ERROR_BEEP to make processor speed independent
;			for AT and PS/2 systems and right tone if interrupts.
;			Make SHIP_IT handle call on PC machines.
;			Use BP to hold system flags during interrupt processing.
;	   PTR 6602049	Fix problem with Pause Key hanging system if Mouse
;			driver is using polled mode.  (Port 60h hangs.)
;	   PTR 6602247	Change JMP at K40 to stop extra Enable Keyboard cmd.
;	   PTR 6602319	Fix interrupt window on System Request key allowing
;			following scan code(s) to be processed out of sequence.
;	   PTR 6602355	Fix Print Screen clearing E0 state flags too late.
;  ; - ;deleted	Add code the clear "Wild Mouse" condition at PAUSE wait.
;  ; -  PTM 6660	Move determination code for original PC1 to COMMSUBS.ASM
;	   - ;jwg 2/90	Add Patriot/Sebring HOT REPLUG code so keyboard can be
;			switched back to Scan Code Set 1 if repluged.  LIB LITE
;  ; -  PTM 6680	Remove code attempting to re-sync BIOS flags with reset
;			Keyboard.  Test case simulators can/are sending invalid
;			sequence of AA,AA.  Must leave BIOS flags alone on POR.
;  ; -  PTM 6716	MicroSoft WORKS (German version) reentrancy problem with
;	   - ;jwg 3/90	NLS state processor and save scan code.  LED update ACK
;			overlays memory before NLS processing of scan code.
;			Remove AN006 "Wild Mouse" reset code, field tests done.
;  ; -  PTM ????	Fix read ID logic to recognize 122 keyboards and set the
;	     ;jwg 8/90	KBX flag on any enhansed keyboard.
;  ; -  PTM ????	Add 122 Keyboard key support tables.

;	M005 -- Begin Kermit revision merge

;  ;JP9009 - Sep. 1990  DBCS keyboard support
;  ;JP9010 - Oct. 1990  Server password mode support
;  ;JP901024 - Oct. 24th 1990
;                       During setting keyboard scan code table, if mouse is
;                       enabled, the setting command failed. This problem was
;                       produced as follows. Sets server password mode, and
;                       starts the DOS 4.0 with mouse(DOSSHELL starts). And
;                       presses password. At this moment, setting scan code
;                       table and enabling mouse proceed concurrently, and
;                       setting scan code table fails.
;  ;JP901025 - Oct. 25th 1990
;                       Read keyboard ID sometimes failed on 486 machine. Puts
;                       some wait(CPU independent) before reading from port 60h
;                       for 386 or over machines.
;
;	M005 -- end revision merge
;       M007 -- change jump condition so ROM BIOS variables used correctly
;       M008 -- require Ctrl+Alt+F1/2 to toggle keyboard mapping
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	INCLUDE KEYBEQU.INC
	INCLUDE DSEG.INC		; System data segments
	INCLUDE POSTEQU.INC		; System equates
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBI2F.INC
	INCLUDE KEYBI9.INC
	INCLUDE KEYBCPSD.INC
	INCLUDE KEYBCMD.INC

	PUBLIC	KEYB_INT_9
	PUBLIC	K8			; CTRL case tables
	PUBLIC	SCAN_CODE
	PUBLIC	BUFFER_FILL
	PUBLIC	COUNTRY_FLAG


        PUBLIC COPY_NLS1_FLAG          ;; FRN-CAN


	PUBLIC	BEEP_PENDING
	PUBLIC	ERROR_BEEP
	PUBLIC	CHK_IBF


ID_1		EQU	0ABH		; 1ST ID CHARACTER FOR KBX
TID_2		EQU	041H		; US G-LAYOUT
TID_2A		EQU	054H		; US P-LAYOUT

;UNTRANSLATED 2ND ID CHAR FOR KBDX
ID_2U		EQU	083H		; US G-LAYOUT (PATRIOT)
ID_2AU		EQU	084H		; US P-LAYOUT (PATRIOT)
ID_122		EQU	086H		; 2ND ID CHARACTER FOR 122-KEYBOARD
ID_2JG		EQU	090H		; JPN G-LAYOUT
ID_2JP		EQU	091H		; JPN P-LAYOUT
ID_2JA		EQU	092H		; JPN A-LAYOUT


DIAGS	SEGMENT AT 0FFFFH
	ORG	0
RESET	LABEL	FAR
DIAGS	ENDS


CODE	SEGMENT PUBLIC 'CODE'
	ASSUME	CS:CODE,DS:DATA


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   TABLE OF SHIFT KEYS AND MASK VALUES
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;------ KEY_TABLE
K6	LABEL	BYTE
	DB	INS_KEY 		; INSERT KEY
	DB	CAPS_KEY,NUM_KEY,SCROLL_KEY,ALT_KEY,CTL_KEY
	DB	LEFT_KEY,RIGHT_KEY
K6L	EQU	$-K6

;------ MASK_TABLE
K7	LABEL	BYTE
	DB	INS_SHIFT		; INSERT MODE SHIFT
	DB	CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT,ALT_SHIFT,CTL_SHIFT
	DB	LEFT_SHIFT,RIGHT_SHIFT

;----------  TABLES FOR ALT CASE  -----
;------ ALT-INPUT-TABLE
K30	LABEL	BYTE
	DB	82,79,80,81,75
	DB	76,77,71,72,73		; 10 NUMBERS ON KEYPAD
;------ SUPER-SHIFT-TABLE
	DB	16,17,18,19,20,21	; A-Z TYPEWRITER CHARS
	DB	22,23,24,25,30,31
	DB	32,33,34,35,36,37
	DB	38,44,45,46,47,48
	DB	49,50
K30_LEN 	EQU	$-K30-10

;------ ALT-INPUT-FUNCTION-TABLE   53H - 7EH
K30A	LABEL	BYTE
	DB	-1,-1,-1,-1,139,140	; Del, SysReq, Undef, WT, F11, F12
	DB	-1,235,218,219,220	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	221,222,223,226,227	; F16, F17, F18, F19, F20,
	DB	228,229,230,231 	; F21, F22, F23, F24,
	DB	-1,243,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,253			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef

H_LAST_SCAN	EQU	$-K30A+52h	; Largest valid scan code in table
					;  K30A K8 K15 K14 must have same ends

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  K8 is overlaid by K8_RPL (from module KEYB_COMMAND)
;  if extended INT 16 support is available
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

K8	LABEL	BYTE			;-------- CHARACTERS ---------
	DB	27,-1,00,-1,-1,-1	; Esc, 1, 2, 3, 4, 5
	DB	30,-1,-1,-1,-1,31	; 6, 7, 8, 9, 0, -
	DB	-1,127,-1,17,23,5	; =, Bksp, Tab, Q, W, E
	DB	18,20,25,21,09,15	; R, T, Y, U, I, O
	DB	16,27,29,10,-1,01	; P, [, ], Enter, Ctrl, A
	DB	19,04,06,07,08,10	; S, D, F, G, H, J
	DB	11,12,-1,-1,-1,-1	; K, L, ;, ', `, LShift
	DB	28,26,24,03,22,02	; \, Z, X, C, V, B
	DB	14,13,-1,-1,-1,-1	; N, M, ,, ., /, RShift
	DB	'*',-1,' ',-1           ; *, Alt, Space, CL
					;--------- FUNCTIONS ---------
	DB	94,95,96,97,98,99	; F1 - F6
	DB	100,101,102,103,-1,-1	; F7 - F10, NL, SL
	DB	119,-1,132,-1,115,-1	; Home, Up, PgUp, -, Left, Pad5
	DB	116,-1,117,-1,118,-1	; Right, +, End, Down, PgDn, Ins
	DB	-1,-1,-1,-1,137,138	; Del, SysReq, Undef, WT, F11, F12
					;---------- 122 KEYBOARD not overlaid
	DB	-1,234,206,207,208	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	209,210,211,212,213	; F16, F17, F18, F19, F20,
	DB	214,215,216,217 	; F21, F22, F23, F24,
	DB	-1,242,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,252			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef

;-----	TABLES FOR LOWER CASE (USA)  --

K10	LABEL	BYTE
	DB	27,'12345'
	DB	'67890-'
	DB	'=',08,09,'qwe'
	DB	'rtyuio'
	DB	'p[]',0DH,-1,'a'        ; LETTERS, Return, Ctrl
	DB	'sdfghj'
	DB	"kl;'`",-1              ; LETTERS, L Shift
	DB	'\zxcvb'
	DB	'nm,./'
	DB	-1,'*',-1,' \'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ LC TABLE SCAN
	DB	59,60,61,62,63		; BASE STATE OF F1 - F10
	DB	64,65,66,67,68
	DB	-1,-1			; NL, SL

;------ KEYPAD TABLE
K15	LABEL	BYTE
	DB	71,72,73,-1,75,-1	; Home, Up, PgUp, -1, Left, -1
	DB	77,-1,79,80,81,82	; Right, -1, End, Down, PgDn, Ins
	DB	83			; Del
	DB	-1,-1,'\',133,134       ; SysRq, Undef, WT, F11, F12
	DB	-1,232,182,183,184	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	185,186,187,188,189	; F16, F17, F18, F19, F20,
	DB	190,191,192,193 	; F21, F22, F23, F24,
	DB	-1,240,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef

;-------  TABLES FOR UPPER CASE (USA)

K11	LABEL	BYTE
	DB	27,'!@#$%'
	DB	'^&*()_'
	DB	'+',08,00,'QWE'
	DB	'RTYUIO'
	DB	'P{}',0DH,-1,'A'        ; LETTERS, Return, Ctrl
	DB	'SDFGHJ'
	DB	'KL:"~',-1              ; LETTERS, L Shift
	DB	'|ZXCVB'
	DB	'NM<>?'
	DB	-1,'*',-1,' |'          ; R Shift, *, Alt, Sp, CL (REALLY WT KEY)

;------ UC TABLE SCAN
K12	LABEL	BYTE
	DB	84,85,86,87,88		; SHIFTED STATE OF F1 - F10
	DB	89,90,91,92,93
	DB	-1,-1			; NL, SL

;------ NUM STATE TABLE
K14	LABEL	BYTE
	DB	'789-456+1230.'         ; NUMLOCK STATE OF KEYPAD KEYS
	DB	-1,-1,'|',135,136       ; SysRq, Undef, WT, F11, F12
	DB	-1,233,194,195,196	; Undef, PA1, F13, F14, F15
	DB	-1,-1,-1,-1,-1		; Pause, Undef 5F-62
	DB	197,198,199,200,201	; F16, F17, F18, F19, F20,
	DB	202,203,204,205 	; F21, F22, F23, F24,
	DB	-1,241,-1,-1		; K#69, ErEOF, Break, Play,
	DB	-1,-1,-1,-1,-1		; Undef, Attn, CrSel, K#56, ExSel
	DB	-1,251			; K#74, Clear,
;;*	DB	       -1,-1,-1 	;	       Undef, K#109, Undef
;;*	DB	-1,-1,-1,-1,-1		; Undef, Undef, K#94, K#14, Undef
PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: KEYB_INT_9
;
;  Description:
;      Entry point for interrupt 9 processing.
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

		EVEN			; Keep KEYB_INT_9 entry on even boundry
BEEP_PENDING	DB	NO		; YES if a beep is needed
SCAN_CODE	DB	0		; Last SCAN code read

KEYB_INT_9	PROC   NEAR
					;
	JMP	short KB_INT_1		;
COPY_NLS1_FLAG  DB       0              ;; FRN-CAN
COUNTRY_FLAG	DB	-1		; WHERE THE INT9 VECTOR POINTS

KB_INT_1:				; Do NOT enable interrupts untill after
					;  PORT 60h has been read.  INT 15h has
					;  interrupt window, do EOI, fast pass.
	PUSH	BP			; Reserved in KEYBi9c for SD.SYSTEM_FLAG
	PUSH	AX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	PUSH	SI
	PUSH	DI
	PUSH	DS
	PUSH	ES
	CLD				; FORWARD DIRECTION
	MOV	BX,DATA 		; SET UP ADDRESSING
	MOV	DS,BX			; DS POINTS AT THE ROM BIOS DATA AREA
	MOV	BP,CS:SD.SYSTEM_FLAG	; GET CS:SD.SYSTEM_FLAG, AND USE BP



;/* --	WAIT TILL KEYBOARD DISABLE COMMAND CAN BE ACCEPTED
	MOV	AL,DIS_KBD		; DISABLE THE KEYBOARD COMMAND
	CALL	SHIP_IT 		; EXECUTE DISABLE

;	M005 -- Begin additions

        TEST    BP, PC_386              ; 386 OR OVER?                 ;JP901025
        JZ      KB_INT_00_2             ; IF NOT, CONTINUE             ;JP901025
        CALL    CHK_IBF                 ; PUT SOME WAIT FOR HIGH SPEED ;JP901025
KB_INT_00_2:                            ; MACHINES                     ;JP901025

;	M005 -- End additions


	IN	AL,PORT_A		; READ IN THE CHARACTER
					; ENABLE INTERRUPTS moved from top P768

;/* --	SYSTEM HOOK  INT 15H - FUNCTION 4FH  (ON HARDWARE INTERRUPT LEVEL 9H)

	MOV	AH,04FH 		; SYSTEM INTERCEPT - KEY CODE FUNCTION
	STC				; SET CY= 1 (IN CASE OF IRET)
	INT	15H			; CASSETTE CALL   (AL)= KEY SCAN CODE
					;  RETURNS CY= 1 FOR INVALID FUNCTION
					; EARLY  EOI for all interrupts done
					;  after INT 15h to prevent re-entrancy
	XCHG	BX,AX			; SAVE SCAN CODE
	MOV	AL,EOI			; END OF INTERRUPT COMMAND (EARLY EOI)
	OUT	INTA00,AL		; SEND EOI TO INTERRUPT CONTROL PORT
	XCHG	BX,AX			; RECOVER SCAN CODE

	JC	KB_INT_02		; CONTINUE IF CARRY FLAG SET ((AL)=CODE)
	JMP	K26			; EXIT IF SYSTEM HANDLED SCAN CODE
					;  EXIT HANDLES ENABLE

;/* --- CHECK FOR A POSSIBLE HOT REPLUG AND A POR COMPLETE CODE

KB_INT_02:				;	(AL)= SCAN CODE
					;	CHECK FOR POR

;	M005 -- Begin additions

        TEST    BP, SECURITY_ACTIVE     ; SERVER PASSWORD MODE JUST EXITED?    ;JP9010
        JZ      KB_INT_02_00            ; GO IF NOT                            ;JP9010
         AND     BP, NOT SECURITY_ACTIVE; NEVER COMES HERE!                    ;JP9010
         MOV     CS:SD.SYSTEM_FLAG, BP  ; REFLECT IT TO SYSTEM_FLAG            ;JP9010
         JMP     SHORT KB_INT_02_01     ;                                      ;JP9010
KB_INT_02_00:                           ;                                      ;JP9010

;	M005 -- End additions

	CMP	AL,KB_OK		; CHECK FOR POSSIBLE KEYBOARD POR CHAR
	JNE	KB_INT_03		; CONTINUE NOT A POR OF AA
					;	CHECK FOR ENHANSED KEYB
	TEST	KB_FLAG_3,LC_E0		; WAS E0h LAST SCAN CODE?    DCR467
	JNZ	KB_INT_03		; SKIP KB POR IF IT WAS
					;	CHECK FOR LEFT SHIFT BREAK
	TEST	KB_FLAG,LEFT_SHIFT	; IS LEFT SHIFT ACTIVE?
	JNZ	KB_INT_03		; SKIP KB POR IF IT WAS
					;	KEYBOARD POWER ON DETECTED
	MOV	CS:BEEP_PENDING,YES	; INDICATE WE NEED A BEEP
KB_INT_02_01:			; M005 ;JP9010
	MOV	KB_FLAG_2,0		; CLEAR ALL LED FLAGS TO FORCE UPDATE
					; LEAVE OTHERS SO KB SIMULATORS WORK

;	M005 -- Begin additions

        TEST    CS:SD.KEYB_TYPE, DBCS_OLD_KB                                   ;JP9009
        JZ      KB_INT_02_1             ; If, DBCS old keyboard is attached,   ;JP9009
          JMP     SHORT KB_INT_02_2     ;   always set scan code table.        ;JP9009
                                        ;                                      ;JP9009
        PUBLIC  SCAN_CODE_SET           ; This is the default scan code set.   ;JP9009
SCAN_CODE_SET   DB      01              ; In case of old DBCS keyboards, this  ;JP9009
                                        ;  may be 81h or 82h.                  ;JP9009
KB_INT_02_1:                            ;                                      ;JP9009

;	M005 -- End additions

	TEST	BP,PS_8042		; SYSTEM USING 8042 & SCAN CODE SET 01?
	JZ	KB_INT_03		; SKIP IF SYSTEM USES DEFAULT SCS 02
					;	PATRIOT/SEBRING 8042 GATE ARRAY

;	M005 -- Begin additions

KB_INT_02_2:                            ;                                      ;JP9009
        PUSH    AX                      ; SAVE SCAN CODE                       ;JP9010
        MOV     AL, DISABLE_AUX         ; DISABLE AUX DEVICE WHILE CHANGING    ;JP901024
        CALL    SHIP_IT                 ; SCAN CODE TABLE                      ;JP901024

;	M005 -- End additions

	MOV	AL,SCAN_CODE_CMD	; SELECT SCAN CODE SET COMMAND
	CALL	SND_DATA		; SEND IT DIRECTLY TO THE KEYBOARD

;	M005 -- Begin changes

;JP9009 MOV     AL,01h                  ; SELECT SCAN CODE SET 01
        MOV     AL, CS:SCAN_CODE_SET    ; GET SCAN CODE SET                    ;JP9009
        CALL    SND_DATA                ; SEND IT TO THE KEYBOARD
        MOV     AL, ENABLE_AUX          ; DISABLE AUX DEVICE WHILE CHANGING    ;JP901024
        CALL    SHIP_IT                 ; SCAN CODE TABLE                      ;JP901024
;JP9010 MOV     AL,KB_OK                ; RESTORE POR SCAN CODE IN (AL)
        POP     AX                      ; RESTORE SCAN CODE                    ;JP9010


;	M005 -- End changes

KB_INT_03:

;/* --- CHECK FOR A RESEND COMMAND TO KEYBOARD

	STI				; ENABLE INTERRUPTS AGAIN
	CMP	AL,KB_RESEND		; IS THE INPUT A RESEND
	JE	KB_INT_4		; GO IF RESEND

;/* --- CHECK FOR RESPONSE TO A COMMAND TO KEYBOARD

	CMP	AL,KB_ACK		; IS THE INPUT AN ACKNOWLEDGE
	JNZ	KB_INT_2		; GO IF NOT

;/* --- A COMMAND TO THE KEYBOARD WAS ISSUED

	CLI				; DISABLE INTERRUPTS
	OR	KB_FLAG_2,KB_FA	; INDICATE ACK RECEIVED
	JMP	K26			; RETURN IF NOT (ACK RETURNED FOR DATA)

;/* --- RESEND THE LAST BYTE

KB_INT_4:
	CLI				; DISABLE INTERRUPTS
	OR	KB_FLAG_2,KB_FE	; INDICATE RESEND RECEIVED
	JMP	K26			; RETURN IF NOT (ACK RETURNED FOR DATA)


;/* --- UPDATE MODE INDICATORS IF CHANGE IN STATE

KB_INT_2:
	PUSH	AX			; SAVE DATA IN
	CALL	MAKE_LED		; GO GET MODE INDICATOR DATA BYTE
	MOV	BL, KB_FLAG_2		; GET PREVIOUS BITS
	XOR	BL,AL			; SEE IF ANY DIFFERENT
	AND	BL,KB_LEDS		; ISOLATE INDICATOR BITS
	JZ	UP0			; IF NO CHANGE BYPASS UPDATE
	CALL	SND_LED 		; GO TURN ON MODE INDICATORS
UP0:	POP	AX			; RESTORE DATA IN

;---------------------------------------------------------------------
;	      START OF KEY PROCESSING				     -
;---------------------------------------------------------------------

	MOV	AH,AL			; SAVE SCAN CODE IN AH ALSO
					; END OF RE-ENTRANT CODE PATHS
	MOV	CS:SCAN_CODE,AL 	; SAVE SCAN CODE TO BE PROCESSED BY KEYB

;------ TEST FOR OVERRUN SCAN CODE FROM KEYBOARD

	CMP	AL,KB_OVER_RUN		; IS THIS AN OVERRUN CHAR?
	JNZ	K16			; NO, TEST FOR SHIFT KEY

	MOV	CS:BEEP_PENDING,YES
	JMP	K26			; BUFFER_FULL_BEEP, EXIT

K16:

	PUSH	CS
	POP	ES			; ESTABLISH ADDRESS OF TABLES
	MOV	BH, KB_FLAG_3		; LOAD FLAGS FOR TESTING

;------ TEST TO SEE IF A READ_ID IS IN PROGRESS

	TEST	BH,RD_ID+LC_AB		; ARE WE DOING A READ ID?
	JZ	NOT_ID			; CONTINUE IF NOT
	JNS	TST_ID_2		; IS THE RD_ID FLAG ON?
	CMP	AL,ID_1 		; IS THIS THE 1ST ID CHARACTER?
	JNE	RST_RD_ID
	OR	KB_FLAG_3,LC_AB	; INDICATE 1ST ID WAS OK
RST_RD_ID:
	AND	KB_FLAG_3,NOT RD_ID	; RESET THE READ ID FLAG
	JMP	SHORT ID_EX		; AND EXIT


;------ CHECK 2ND US KBD ID - FOR SETTING NUM LOCK ON
TST_ID_2:
	AND	KB_FLAG_3,NOT LC_AB	; RESET FLAG

;	M005 -- Kermit merge changes
;
;		Note:  IBM's code diverged rather significantly from
;			Microsoft's here.  Mostly, theirs was adopted.
;			The primary differences are:
;
;			IBM recognized the ID_2JP keyboard type
;			MS  recognized the ID_122 type
;			IBM explicitly checked for all of the known
;			    extended keyboards and did NOT set the
;			    extended bit if it didn't recognize the code.
;			IBM hooks into the DBCS support routines

;M005		OR	KB_FLAG_3,KBX		; INDICATE ENHANCED KEYBOARD WAS FOUND
;M005		CMP	AL,TID_2		; IS THIS US G-LAYOUT KBD  w 8042
;M005		JE	NUM_LOCK_000		;  JUMP IF SO
;M005		CMP	AL,ID_2U		; IS THIS US G-LAYOUT KBD  w/o 8042
;M005		JE	NUM_LOCK_000		;  JUMP IF SO
;M005		CMP	AL,ID_122		; IS THIS THE 122 KEY ENHANCED KEYBOARD
;M005		JE	NUM_LOCK_000		;  JUMP IF SO
;M005	
;M005	;------ CHECK 2ND JAPANESE KBD ID	;DCR355
;M005	
;M005		CMP	AL,ID_2JG		; IS THIS JPN KBD - G ?
;M005		JE	NUM_LOCK_000		; JUMP IF SO
;M005		CMP	AL,ID_2JA		; IS THIS JPN KBD - A ?
;M005		JNE	ID_EX			; EXIT IF NUM LOCK NOT REQUIRED
;M005						;  These ID's do not set NUM LOCK ON
;M005						;  ID_2AU = US P-LAYOUT KBD  w/o 8042
;M005						;  TID_2A = US P-LAYOUT KBD  w 8042
;M005						;  ID_2JP = JPN KBD - P
;M005	
;M005	;------ A READ ID SAID THAT IT WAS ENHANCED KEYBOARD
;M005	
;M005	NUM_LOCK_000:
;M005		TEST	BH,SET_NUM_LK		; SHOULD WE SET NUM LOCK?
;M005		JZ	ID_EX			; EXIT IF NOT
;M005		OR	KB_FLAG,NUM_STATE	; FORCE NUM LOCK ON
;M005		CALL	SND_LED 		; GO SET THE NUM LOCK INDICATOR
;M005	ID_EX:
;M005		JMP	K26			; EXIT
;M005	PAGE
;M005	NOT_ID:

;	Begin IBM's slightly modified code

        CMP     AL,TID_2A               ; IS THIS US P-LAYOUT KBD  w 8042
        JE      KX_BIT                  ;  JUMP IF SO
        CMP     AL,TID_2                ; IS THIS US G-LAYOUT KBD  w 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_2AU               ; IS THIS US P-LAYOUT KBD  w/o 8042
        JE      KX_BIT                  ;  JUMP IF SO
        CMP     AL,ID_2U                ; IS THIS US G-LAYOUT KBD  w/o 8042
        JE      NUM_LOCK_000            ;  JUMP IF SO
	CMP	AL,ID_122	; M005	; 122 keyboard from MS merge
	JE	NUM_LOCK_000

;------ CHECK 2ND JAPANESE KBD ID       ;DCR355
        CMP     AL,ID_2JP               ;  IS THIS JPN KBD - P ?
        JE      KX_BIT                  ;  JUMP IF SO
        CMP     AL,ID_2JG               ;  IS THIS JPN KBD - G ?
        JE      NUM_LOCK_000            ;  JUMP IF SO
        CMP     AL,ID_2JA               ;  IS THIS JPN KBD - A ?
        JNE     ID_EX                   ;  LEAVE IF NOT

;------ A READ ID SAID THAT IT WAS ENHANCED KEYBOARD

NUM_LOCK_000:                           ; 4/7/87 A.OSADA
        TEST    BH,SET_NUM_LK           ; SHOULD WE SET NUM LOCK?
        JZ      KX_BIT                  ; EXIT IF NOT
        OR       KB_FLAG,NUM_STATE      ; FORCE NUM LOCK ON
        CALL    SND_LED                 ; GO SET THE NUM LOCK INDICATOR
KX_BIT: OR       KB_FLAG_3,KBX          ; INDICATE ENHANCED KEYBOARD WAS FOUND
ID_EX:  JMP     K26                     ; EXIT
PAGE
NOT_ID:
        mov     bl, KB_FLAG                                             ;JP9009
        call    DBCS_keyboard_support                                   ;JP9009

;	M005 -- End changes

	CMP	AL,MC_E0		; IS THIS THE GENERAL MARKER CODE?
	JNE	TEST_E1
	OR	KB_FLAG_3,LC_E0+KBX	; SET FLAG BIT, SET KBX, AND
	JMP	SHORT EXIT		; THROW AWAY THIS CODE

TEST_E1:
	CMP	AL,MC_E1		; IS THIS THE PAUSE KEY?
	JNE	NOT_HC
	OR	KB_FLAG_3,LC_E1+KBX	; SET FLAG, PAUSE KEY MARKER CODE
EXIT:	JMP	K26A			; THROW AWAY THIS CODE

NOT_HC:
	AND	AL,07FH 		; TURN OFF THE BREAK BIT
	TEST	BH,LC_E0		; LAST CODE THE E0 MARKER CODE?
	JZ	NOT_LC_E0		; JUMP IF NOT

	MOV	CX,2			; LENGTH OF SEARCH
	MOV	DI,OFFSET K6+6		; IS THIS A SHIFT KEY?
	REPNE	SCASB			; CHECK IT
	JNE	K16A			; NO, CONTINUE KEY PROCESSING
	JMP	SHORT K16B		; YES, THROW AWAY & RESET FLAG

NOT_LC_E0:
	TEST	BH,LC_E1		; LAST CODE THE E1 MARKER CODE?
	JZ	T_SYS_KEY		; JUMP IF NOT

	MOV	CX,4			; LENGTH OF SEARCH
	MOV	DI,OFFSET K6+4		; IS THIS AN ALT, CTL, OR SHIFT?
	REPNE	SCASB			; CHECK IT
	JE	EXIT			; THROW AWAY IF SO

	CMP	AL,NUM_KEY		; IS IT THE PAUSE KEY?
	JNE	K16B			; NO, THROW AWAY & RESET FLAG
	TEST	AH,80H			; YES, IS IT THE BREAK OF THE KEY?
	JNZ	K16B			;  YES, THROW THIS AWAY, TOO
	TEST	KB_FLAG_1,HOLD_STATE	;  NO, ARE WE PAUSED ALREADY?
	JNZ	K16B			;      YES, THROW AWAY
	JMP	K39P			;  NO, THIS IS THE REAL PAUSE STATE
PAGE
;------ TEST FOR SYSTEM KEY

T_SYS_KEY:
	CMP	AL,SYS_KEY		; IS IT THE SYSTEM KEY?
	JNE	K16A			; CONTINUE IF NOT

	TEST	AH,080H 		; CHECK IF THIS A BREAK CODE
	CLI				; DISABLE INTERRUPTS	 PTR 6602319
	JNZ	K16C			; DON'T TOUCH SYSTEM INDICATOR IF TRUE

	TEST	KB_FLAG_1,SYS_SHIFT	; SEE IF IN SYSTEM KEY HELD DOWN
	JNZ	K16B			; IF YES, DON'T PROCESS SYSTEM INDICATOR

	OR	KB_FLAG_1,SYS_SHIFT	; INDICATE SYSTEM KEY DEPRESSED

	MOV	AL,ENA_KBD		; INSURE KEYBOARD IS ENABLED
	CALL	SHIP_IT 		; EXECUTE ENABLE
	MOV	AX,08500H		; FUNCTION VALUE FOR MAKE OF SYSTEM KEY
	INT	15H			; USER INTERRUPT
	JMP	K27A			; END PROCESSING

K16B:	JMP	K26			; IGNORE SYSTEM KEY

K16C:	AND	KB_FLAG_1,NOT SYS_SHIFT; TURN OFF SHIFT KEY HELD DOWN

	MOV	AL,ENA_KBD		; INSURE KEYBOARD IS ENABLED
	CALL	SHIP_IT 		; EXECUTE ENABLE
	MOV	AX,08501H		; FUNCTION VALUE FOR BREAK OF SYSTEM KEY
	INT	15H			; USER INTERRUPT
	JMP	K27A			; IGNORE SYSTEM KEY
PAGE
;------ TEST FOR SHIFT KEYS
;
; HERE IS WHERE KB_FLAGS ARE SET.  WHAT HAPPENS IS, THE SYSTEM SEARCHES TABLE
; 'K6' FOR THE KEY.  IF FOUND, IT GETS THE APPROPRIATE BIT FROM TABLE 'K7'
; AND SETS IT ON. (TABLES ARE ALL AT THE TOP OF THIS ROUTINE)  FLAGS FOR THE
; SECOND ALT AND CTRL ARE SET IN KB_FLAG_3 AND HAVE THE SAME BIT POSITIONS AS
; THEIR ORIGINAL COUNTERPARTS IN KB_FLAG

K16A:	MOV	BL, KB_FLAG		; PUT STATE FLAGS IN BL
	MOV	DI,OFFSET K6		; SHIFT KEY TABLE
	MOV	CX,K6L  		; LENGTH
	REPNE	SCASB			; LOOK THROUGH THE TABLE FOR A MATCH
	MOV	AL,AH			; RECOVER SCAN CODE
	JE	K17			; JUMP IF MATCH FOUND
	JMP	K25			; IF NO MATCH, THEN SHIFT NOT FOUND

;------ SHIFT KEY FOUND

K17:	SUB	DI,OFFSET K6+1		; ADJUST PTR TO SCAN CODE MTCH
	MOV	AH,CS:K7[DI]		; GET MASK INTO AH
	MOV	CL,2			; SET UP COUNT FOR FLAG SHIFTS
	TEST	AL,80H			; TEST FOR BREAK KEY
	JZ	K17C
	JMP	K23			; JUMP IF BREAK

;------ SHIFT MAKE FOUND, DETERMINE SET OR TOGGLE

K17C:	CMP	AH,SCROLL_SHIFT
	JAE	K18			; IF SCROLL SHIFT OR ABOVE, TOGGLE KEY

;------ PLAIN SHIFT KEY, SET SHIFT ON

	CMP	COUNTRY_FLAG,0FFh	; ARE WE IN FOREIGN LANG MODE?
	JNE	K17C1			;  NO, US MODE, JUMP
	CMP	AL,ALT_KEY		; IS THIS THE ALT KEY?
	JNE	K17C1			;  NO, NORMAL KEY
					;**CNS

K17C1:	OR	KB_FLAG,AH		; TURN ON SHIFT BIT
K17C2:	TEST	AH,CTL_SHIFT+ALT_SHIFT	; IS IT ALT OR CTRL?
	JZ	K17F			;  NO, JUMP
K17D:	TEST	BH,LC_E0		; IS THIS ONE OF THE NEW KEYS?
	JZ	K17E			;  NO, JUMP
	OR	KB_FLAG_3,AH		; SET BITS FOR RIGHT CTRL, ALT
;        JMP	 K26			 ; INTERRUPT_RETURN
        jmp     short K17G              ; FRN-CAN

K17E:	SHR	AH,CL			; MOVE FLAG BITS TWO POSITIONS
	OR	KB_FLAG_1,AH		; SET BITS FOR LEFT CTRL, ALT
; 	 JMP	 K26			; INTERRUPT RETURN
        jmp     short K17G              ; FRN-CAN

K17F:
	TEST	CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
	JZ	K17G			; N..all done
	CMP	COUNTRY_FLAG,0FFh	; ARE WE IN LANG MODE?
	JNE	K17G			;  NO, ALL DONE WITH SHIFT KEY

;------ If keyboard is P12 then we still need to release caps_lk

	TEST	BP,PC_LAP		;  IS THIS A P12 KEYBOARD?
	JNZ	REMOVE_CAPS_SHIFT

	TEST	BH,KBX			; THIS THE ENHANCED KEYBOARD?
	JZ	K17G			;  NO, ALL DONE WITH SHIFT KEY
REMOVE_CAPS_SHIFT:
	AND	KB_FLAG,NOT CAPS_SHIFT ;  YES, TAKE KB OUT OF C_L STATE
	CALL	SND_LED 		;   AND UPDATE THE LED INDICATORS
K17G:


; ===========================================
;    FRN-CAN
; ===========================================
        CMP     COUNTRY_FLAG,0FFh       ; ARE WE IN FOREIGN LANG MODE?
        JNE     K17H                    ; NO, US MODE, RETURN
        TEST    CS:SD.SPECIAL_FEATURES,SHIFTS_TO_LOGIC; CAN OUR STATE
                                        ; LOGIC SUPPORT THIS CALL?
        JZ      K17H                    ; NO, RETURN
        OR      CS:FLAGS_TO_TEST[EXT_KB_FLAG_ID],SHIFTS_PRESSED;
                                        ; SET FLAG FOR STATE LOGIC
        CALL    KEYB_STATE_PROCESSOR    ; ********
        AND     CS:FLAGS_TO_TEST[EXT_KB_FLAG_ID],NOT SHIFTS_PRESSED;                                             ; CLEAR FLAG AFTER USE           (YST)
; ===========================================
;    FRN-CAN
; ===========================================


K17H:   JMP     K26                     ;  RETURN

;------ TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT

K18:					; SHIFT-TOGGLE
	TEST	BL,CTL_SHIFT		; CHECK CTL SHIFT STATE
	JZ	K18A			; JUMP IF NOT CTL STATE
	JMP	K25			; JUMP IF CTL STATE
K18A:	CMP	AL,INS_KEY		; CHECK FOR INSERT KEY
	JNE	K22			; JUMP IF NOT INSERT KEY
	TEST	BL,ALT_SHIFT		; CHECK FOR ALTERNATE SHIFT
	JZ	K18B			; JUMP IF NOT ALTERNATE SHIFT
	JMP	K25			; JUMP IF ALTERNATE SHIFT
K18B:	TEST	BH,LC_E0		; IS THIS THE NEW INSERT KEY?
	JNZ	K22			; YES, THIS ONE'S NEVER A "0"
K19:	TEST	BL,NUM_STATE		; CHECK FOR BASE STATE
	JNZ	K21			; JUMP IF NUM LOCK IS ON
	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ; TEST FOR SHIFT STATE
	JZ	K22			   ; JUMP IF BASE STATE
K20:	MOV	AH,AL			; PUT SCAN CODE BACK IN AH
	JMP	K25			; NUMERAL "0", STNDRD. PROCESSING

K21:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ; MIGHT BE NUMERIC
	JZ	K20			   ; IS NUMERIC, STD. PROC.

K22:					; SHIFT TOGGLE KEY HIT; PROCESS IT
	TEST	AH, KB_FLAG_1		; IS KEY ALREADY DEPRESSED?
	JZ	K22A
	JMP	K26			; JUMP IF KEY ALREADY DEPRESSED
K22A:	OR	KB_FLAG_1,AH		; INDICATE THAT THE KEY IS DEPRESSED
	XOR	KB_FLAG,AH		; TOGGLE THE SHIFT STATE

	TEST	CS:SD.SPECIAL_FEATURES,TYPEWRITER_CAPS_LK
	JZ	K22C			; N..all done

;------ If keyboard is P12 then we do not toggle

	TEST	BP,PC_LAP		;  IS THIS A P12 KEYBOARD?
	JNZ	LAP_SO_DONT_TOGGLE

	TEST	BH,KBX			; THIS THE ENHANCED KEYBOARD?
	JZ	K22C			;  NO, ALL DONE WITH TOGGLE KEYS

LAP_SO_DONT_TOGGLE:
	CMP	CS:COUNTRY_FLAG,0FFh	; ARE WE IN FOREIGN LANG MODE?
	JNE	K22C			;  NO, NO SPECIAL STUFF FOR U.S.
	TEST	AH,CAPS_SHIFT		; IS IT THE CAPS_LOCK KEY?
	JZ	K22C			;  NO, NOTHING ELSE TO DO
	OR	KB_FLAG,AH		;  YES, SET CAPS_LOCK (NOT TOGGLE)

K22C:

;------ TOGGLE LED IF CAPS, NUM, OR SCROLL KEY DEPRESSED

	TEST	AH,CAPS_SHIFT+NUM_SHIFT+SCROLL_SHIFT ; SHIFT TOGGLE?
	JZ	K22B			; GO IF NOT
	PUSH	AX			; SAVE SCAN CODE AND SHIFT MASK
	CALL	SND_LED 		; GO TURN MODE INDICATORS ON
	POP	AX			; RESTORE SCAN CODE

K22B:	CMP	AL,INS_KEY		; TEST FOR 1ST MAKE OF INSERT KEY
	JNE	K26			; JUMP IF NOT INSERT KEY
	MOV	AH,AL			; SCAN CODE IN BOTH HALVES OF AX
	JMP	K28			; FLAGS UPDATED, PROC. FOR BUFFER

;------ BREAK SHIFT FOUND

K23:					; BREAK-SHIFT-FOUND
	CMP	AH,SCROLL_SHIFT 	; IS THIS A TOGGLE KEY?
	NOT	AH			; INVERT MASK
	JAE	K24			; YES, HANDLE BREAK TOGGLE
	AND	KB_FLAG,AH		; TURN OFF SHIFT BIT
	CMP	AH,NOT CTL_SHIFT	; IS THIS ALT OR CTL?
	JA	K23D			;  NO, ALL DONE

	TEST	BH,LC_E0		; 2ND ALT OR CTL?
	JZ	K23A			; NO, HANDLE NORMALLY
	AND	KB_FLAG_3,AH		; RESET BIT FOR RIGHT ALT OR CTL
	JMP	SHORT K23B		; CONTINUE
K23A:	SAR	AH,CL			; MOVE THE MASK BIT TWO POSITIONS
	AND	KB_FLAG_1,AH		; RESET BIT FOR LEFT ALT OR CTL
K23B:	MOV	AH,AL			; SAVE SCAN CODE
	MOV	AL, KB_FLAG_3		; GET RIGHT ALT & CTRL FLAGS
	CMP	COUNTRY_FLAG,0FFH	; ARE WE IN LANGUAGE MODE?
	JNE	K23C			;  NO, LEAVE RIGHT FLAGS AS IS
;**CNS
	AND	AL,NOT GRAPH_ON 	;  YES, FILTER OUT THE ALT_GR KEY
;**CNS
K23C:	SHR	AL,CL			; MOVE TO BITS 1 & 0
	OR	AL, KB_FLAG_1		; PUT IN LEFT ALT & CTL FLAGS
	SHL	AL,CL			; MOVE BACK TO BITS 3 & 2
	AND	AL,ALT_SHIFT+CTL_SHIFT	; FILTER OUT OTHER GARBAGE
	OR	KB_FLAG,AL		; PUT RESULT IN THE REAL FLAGS
	MOV	AL,AH			; RECOVER SAVED SCAN CODE

K23D:	CMP	AL,ALT_KEY+80H		; IS THIS ALTERNATE SHIFT RELEASE
	JNE	K26			; INTERRUPT_RETURN

;------ ALTERNATE SHIFT KEY RELEASED, GET THE VALUE INTO BUFFER

	MOV	AL, ALT_INPUT
	xor	ah,ah			; scan code of 0
	MOV	ALT_INPUT,AH		; ZERO OUT THE FIELD
	or	al,al			; was the input = 0?
	JE	K26			; INTERRUPT_RETURN
	CALL	BUFFER_FILL_ANY_CHAR	; Put in buffer, but use this
					;  entry point to avoid trashing
					;   an ASCII code of 255
	JMP	SHORT K26		; INTERRUPT_RETURN

K24:					; BREAK-TOGGLE
	AND	KB_FLAG_1,AH		; INDICATE NO LONGER DEPRESSED
	JMP	SHORT K26		; INTERRUPT_RETURN

;------ TEST FOR HOLD STATE
					; AL, AH = SCAN CODE
K25:					; NO-SHIFT-FOUND
	CMP	AL,80H			; TEST FOR BREAK KEY
	JAE	K26			; NOTHING FOR BREAK CHARS FROM HERE ON
	TEST	KB_FLAG_1,HOLD_STATE	; ARE WE IN HOLD STATE
	JZ	K28			; BRANCH AROUND TEST IF NOT
	CMP	AL,NUM_KEY
	JE	K26			; CAN'T END HOLD ON NUM_LOCK
	AND	KB_FLAG_1,NOT HOLD_STATE  ; TURN OFF THE HOLD STATE BIT

K26:
	AND	KB_FLAG_3,NOT LC_E0+LC_E1 ; RESET LAST CHAR H.C. FLAG

K26A:					; INTERRUPT-RETURN
	CLI				; TURN OFF INTERRUPTS
	CALL	ERROR_BEEP		; CHECK FOR ERROR BEEP PENDING

	CMP	CS:BUFFER_ENTRY_OK,YES	; HAS A CHARACTER BEEN PLACED IN BUFFER
	JNE	K27			;  NO, SKIP POST

	MOV	byte ptr CS:BUFFER_ENTRY_OK,NO	; CLEAR POST CHARACTER IN BUFFER FLAG
	MOV	AX,09102H		; MOVE IN POST CODE & TYPE
	INT	15H			; PERFORM OTHER FUNCTION
K27:
	MOV	AL,ENA_KBD		; ENSURE KEYBOARD IS ENABLED (AT PS/2)
	CALL	SHIP_IT 		; EXECUTE ENABLE

K27A:	CLI				; DISABLE INTERRUPTS
	POP	ES			; RESTORE REGISTERS
	POP	DS			; *
	POP	DI			; *
	POP	SI			; *
	POP	DX			; *
	POP	CX			; *
	POP	BX			; *
	POP	AX			; *
	POP	BP			; *

	IRET				; RETURN
PAGE
;------ NOT IN HOLD STATE
					; AL, AH = SCAN CODE (ALL MAKES)
K28:					; NO-HOLD-STATE
;	 CMP	 AL,H_LAST_SCAN		 ; TEST FOR OUT-OF-RANGE SCAN CODES
	CMP	AL,7fH			; VERAV - FEB 92 - permit other scan codes
	JA	SHORT K26		; IGNORE IF OUT-OF-RANGE

	TEST	BP,EXT_122		; IS EXTENDED 122 KEYBOARD SUPPORT OK
	JNZ	K28_122 		; SKIP NON-122 OUT-OF-RANGE CHECK

;	 CMP	 AL,88			 ; TEST FOR OUT-OF-RANGE SCAN CODES
	CMP	AL,7fH			; VERAV - FEB 92 - permit other scan codes
	JA	K26			; IGNORE IF OUT-OF-RANGE
K28_122:
K28_1:			; M005 ;JP9009
	TEST	BL,ALT_SHIFT		; ARE WE IN ALTERNATE SHIFT?
	JZ	K28A			; JUMP IF NOT ALTERNATE

	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K29			; NO, ALT STATE IS REAL

	TEST	KB_FLAG_1,SYS_SHIFT	; YES, IS SYSREQ KEY DOWN?
	JZ	K29			;  NO, ALT STATE IS REAL
;**CNS
	 TEST	 AH,LC_E0		; IS IT THE ALT_GR KEY?
	 JZ	 K28A			; YES,	 DON'T SET KB_FLAG

	 TEST	 AL,R_ALT_SHIFT 	; TURN ON SHIFT BIT
	 JNZ	 K29			; TURN ON SHIFT BIT
;**CNS

K28A:	JMP	K38			;  YES, THIS IS PHONY ALT STATE
					;	DUE TO PRESSING SYSREQ

;------ TEST FOR RESET KEY SEQUENCE (CTL ALT DEL) OR HOT KEY DEPRESSED

K29:					; TEST-RESET
	TEST	BL,CTL_SHIFT		; ARE WE IN CONTROL SHIFT ALSO?
	JZ	K31			; NO_RESET
	CMP	AL,DEL_KEY		; SHIFT STATE IS THERE, TEST KEY
;
;	M000 -- begin changes
;
;	note:  The special mapping of keypad-, keypad+, sp, and tab
;	  must take place in the case of alt-ctrl as well, so the following
;	  branch is moved appropriately.
;	Old instruction commented out
;
;	JNE	K31A			; NO_RESET,  TRANSLATE TABLE SWAP

	jnz	k31			; no_reset,  translate table swap

;	M000 -- end changes

;------ CTL-ALT-DEL HAS BEEN FOUND, DO I/O CLEANUP

	MOV	RESET_FLAG,1234H	; SET FLAG FOR RESET FUNCTION
	AND	WORD PTR  KB_FLAG_3,KBX ; CLEAR ALL FLAG BITS EXCEPT KBX   PED 6-25-86
	JMP	RESET			; JUMP TO POWER ON DIAGNOSTICS

;------ IN ALTERNATE SHIFT, RESET NOT FOUND

K31:					; NO-RESET
	CALL	KEYB_STATE_PROCESSOR
	JC	K26			;    TRANSLATIONS FOUND - EXIT

	CMP	AL,57			; TEST FOR SPACE KEY
	JNE	K311			; NOT THERE
	MOV	AL,' '                  ; SET SPACE CHAR
	JMP	K57			; BUFFER_FILL
K311:
	TEST	BP,EXT_16		; IS EXTENDED INT 16 LOADED?
;M001	JZ	K32			;  NO, SKIP THIS EXTENDED STUFF
	jz	k31a			;  no, skip extended stuff M001
	CMP	AL,15			; TEST FOR TAB KEY
	JNE	K312			; NOT THERE
	MOV	AX,0A500h		; SET SPECIAL CODE FOR ALT-TAB
	JMP	K57			; BUFFER_FILL
K312:
	CMP	AL,74			; TEST FOR KEYPAD -
	JE	K312A			; GO PROCESS
	CMP	AL,78			; TEST FOR KEYPAD +
;M001	JNE	K32			; SKIP TEST FOR LANG SWAP & CONT.
	jnz	k31a			; skip test for lang swap & cont. M001
K312A:	JMP	K37B			; GO PROCESS

;------ SET COUNTRY FLAG TO INDICATE WHICH TABLE WE'RE USING, FOREIGN OR DOMESTIC

K31A:	TEST    BL,CTL_SHIFT            ; Must have Ctrl+Alt to work  M008
        JZ      K31C                    ;                             M008
        CMP	AL,CS:SD.HOT_KEY_ON_SCAN ; TEST FOR HOT KEY TO US
	JNE	K31B
	MOV	CS:COUNTRY_FLAG,00	; SET FLAG FOR DOMESTIC KEY'S
	JMP	K26			; INTERRUPT RETURN

K31B:	CMP	AL,CS:SD.HOT_KEY_OFF_SCAN ; TEST FOR HOT KEY TO FOREIGN
	JNE	K31C			; IF NOT TEST FOR FRONT ENGRAV
	MOV	CS:COUNTRY_FLAG,0FFH	; SET FLAGS FOR FOREIGN KEY'S
	JMP	K26			; INTERRUPT RETURN


;------ ALT, CTRL DOWN ; NO HOT KEY

K31C:	CMP	CS:COUNTRY_FLAG,0FFH
	JNE	K32			; TRY ALT_KEY_PAD
	CALL	KEYB_STATE_PROCESSOR
	JC	K32A	;K26		;    TRANSLATIONS FOUND - EXIT


;------ LOOK FOR KEY PAD ENTRY

K32:					; ALT-KEY-PAD
	MOV	DI,OFFSET K30		; ALT-INPUT-TABLE
	MOV	CX,10			; LOOK FOR ENTRY USING KEYPAD
	REPNE	SCASB			; LOOK FOR MATCH
	JNE	K33			; NO_ALT_KEYPAD
	TEST	BH,LC_E0		; IS THIS ONE OF THE NEW KEYS?
	JNZ	K37C			;  YES, JUMP, NOT NUMPAD KEY
	SUB	DI,OFFSET K30+1 	; DI NOW HAS ENTRY VALUE
	MOV	AL, ALT_INPUT		; GET THE CURRENT BYTE
	MOV	AH,10			; MULTIPLY BY 10
	MUL	AH
	ADD	AX,DI			; ADD IN THE LATEST ENTRY
	MOV	 ALT_INPUT,AL		; STORE IT AWAY
K32A:	JMP	K26			; THROW AWAY THAT KEYSTROKE

;------ LOOK FOR SUPERSHIFT ENTRY

K33:					; NO-ALT-KEYPAD
	MOV	 ALT_INPUT,0		; ZERO ANY PREVIOUS ENTRY INTO INPUT
					; DI,ES ALREADY POINTING
	MOV	CX,K30_LEN      	; NORMALLY 26, BUT 27 FOR FR, DUE
					;  TO THE ";" KEY BEING "M"
	REPNE	SCASB			; LOOK FOR MATCH IN ALPHABET
	JE	K37A			; MATCH FOUND, GO FILL THE BUFFER

;------ LOOK FOR TOP ROW OF ALTERNATE SHIFT

K34:					; ALT-TOP-ROW
	CMP	AL,2			; KEY WITH '1' ON IT
	JB	K37B			; MUST BE ESCAPE
	CMP	AL,13			; IS IT IN THE REGION
	JA	K35			;  NO, ALT-SOMETHING ELSE
	ADD	AH,118			; CONVERT PSEUDO SCAN CODE TO RANGE
	JMP	SHORT K37A		; GO FILL THE BUFFER

;------ TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES

K35:					; ALT-FUNCTION
	CMP	AL,F11_M		; IS IT F11 or GREATER ?
	JB	K35A			;  NO, BRANCH
	SUB	AL,52h			; SET UP TO SEARCH ALT-FUNCTION-TABLE
	MOV	BX,OFFSET K30A		; BASE CASE TABLE
	JMP	K64			; CONVERT TO PSEUDO SCAN

K35A:	TEST	BH,LC_E0		; DO WE HAVE ONE OF THE NEW KEYS?
	JZ	K37			;  NO, JUMP
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K37			;  NO, DO COMPATIBLE OUTPUT
	CMP	AL,28			; TEST FOR KEYPAD ENTER
	JNE	K35B			; NOT THERE
	MOV	AX,0A600h		; SPECIAL CODE
	JMP	K57			; BUFFER FILL
K35B:	CMP	AL,83			; TEST FOR DELETE KEY
	JE	K37C			; HANDLE WITH OTHER EDIT KEYS
	CMP	AL,53			; TEST FOR KEYPAD /
	JNE	K32A			; NOT THERE, NO OTHER E0 SPECIALS
	MOV	AX,0A400h		; SPECIAL CODE
	JMP	K57			; BUFFER FILL

K37:	CMP	AL,59			; TEST FOR FUNCTION KEYS (F1)
	JB	K37B			;  NO FN, HANDLE W/OTHER EXTENDED
	CMP	AL,68			; IN KEYPAD REGION?
					; OR NUMLOCK, SCROLLOCK?
	JA	K32A			; IF SO, IGNORE
	ADD	AH,45			; CONVERT TO PSEUDO SCAN CODE

K37A:	xor	al,al			; ASCII CODE OF ZERO
	JMP	K57			; PUT IT IN THE BUFFER

K37B:
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K32A	;K26		   ;  NO, IGNORE THIS ONE
	MOV	AL,0F0h 		; USE SPECIAL ASCII CODE
	JMP	K57			; PUT IT IN THE BUFFER

K37C:
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K37A			;  NO, DO COMPATIBLE OUTPUT
	ADD	AL,80			; CONVERT SCAN CODE (EDIT KEYS)
	MOV	AH,AL			; (SCAN CODE NOT IN AH FOR INSERT)
	JMP	K37A			; PUT IT IN THE BUFFER
PAGE
;------ NOT IN ALTERNATE SHIFT

K38:					; NOT-ALT-SHIFT
					; BL STILL HAS SHIFT FLAGS
	TEST	BL,CTL_SHIFT		; ARE WE IN CONTROL SHIFT?
	JNZ	K38A			;  YES, START PROCESSING
	JMP	K44			; NOT-CTL-SHIFT

;------ CONTROL SHIFT, TEST SPECIAL CHARACTERS

;------ TEST FOR BREAK

K38A:	CMP	AL,SCROLL_KEY		; TEST FOR BREAK
	JNE	K39			; JUMP, NO-BREAK
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JNZ	K38B			;  YES, THIS IS CTRL-BREAK
	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K38B			;  NO, BREAK IS VALID
	TEST	BH,LC_E0		;  YES, WAS LAST CODE AN E0?
	JZ	K39			;   NO-BREAK, TEST FOR PAUSE

K38B:
	CLI				; Disable interrupts because EOI issued
	MOV	BX, BUFFER_HEAD 	; RESET BUFFER TAIL TO BUFFER HEAD
	MOV	 BUFFER_TAIL,BX
	MOV	 BIOS_BREAK,80H 	; TURN ON BIOS_BREAK BIT

;-------- ENABLE KEYBOARD

	MOV	AL,ENA_KBD		; ENABLE KEYBOARD
	CALL	SHIP_IT 		; EXECUTE ENABLE
	INT	1BH			; BREAK INTERRUPT VECTOR
	SUB	AX,AX			; PUT OUT DUMMY CHARACTER
	JMP	K57			; BUFFER_FILL

;-------- TEST FOR PAUSE

K39:					; NO-BREAK
	CMP	AL,NUM_KEY		; LOOK FOR PAUSE KEY
	JNE	K41			; NO-PAUSE
	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K39P			;  NO, THIS IS A VALID PAUSE
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K41			;  NO, IT'S NOT PAUSE THIS TIME
K39P:	OR	KB_FLAG_1,HOLD_STATE	; TURN ON THE HOLD FLAG

;-------- ENABLE KEYBOARD

	MOV	AL,ENA_KBD		; ENABLE KEYBOARD
	CALL	SHIP_IT 		; EXECUTE ENABLE

;------ DURING PAUSE INTERVAL, TURN CRT BACK ON

	CMP	CRT_MODE,7		; IS THIS BLACK AND WHITE CARD
	JAE	K40			; YES, NOT CGA MODES NOTHING TO DO
	MOV	DX,03D8H		; PORT FOR COLOR CARD
	MOV	AL,CRT_MODE_SET 	; GET THE VALUE OF THE CURRENT MODE
	OUT	DX,AL			; SET THE CRT MODE, SO THAT CRT IS ON
K40:					; PAUSE-LOOP
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K40A			;  NO, SKIP THE BATTERY LIFE STUFF
	MOV	AX,4104H		; FUNCTION 41, AL=04=RETURN IF 0
	MOV	BX,HOLD_STATE*100H	; BH=HOLD_STATE, BL=0=NO TIME OUT
	PUSH	DS			; MAKE ES:DI POINT TO KB_FLAG_1
	POP	ES
	MOV	DI,OFFSET  KB_FLAG_1
	INT	15H			; SLEEP UNTIL OUT OF HOLD

;------ CHECK FOR AUX ADAPTER INPUT PENDING
K40A:
	MOV CX,100			; COUNT FOR WAIT LOOP
K40B:
	TEST	KB_FLAG_1,HOLD_STATE	; ARE WE IN HOLD STATE
	JZ K40E 			; EXIT IF NOT

	TEST	BP,PC_XT+PC_LAP		; Check for systems without AUX BIOS
	JNZ	K40B			; For them, just loop on hold flag

	IN	AL,STATUS_PORT		; READ CURRENT STATUS
	AND	AL,MOUSE_OBF+OUT_BUF_FULL ; MASK OFF ALL BUT MOUSE DATA BITS
	CMP	AL,MOUSE_OBF+OUT_BUF_FULL ; IS THERE STILL MOUSE DATA PENDING?
	LOOPE	K40B			; WAIT FOR MOUSE DATA TO GO
	JNE	K40A			; CONTINUE IF PAUSE STATE	       ;an005
K40E:
	AND	KB_FLAG_1,NOT HOLD_STATE ; CLEAR HOLD STATE FLAG
	JMP	K27A			; INTERRUPT_RETURN_NO_EOI      PTR 2247

;------ TEST SPECIAL CASE KEY 55

K41:					; NO-PAUSE
	CMP	AL,55			; TEST FOR */PRTSC KEY
	JNE	K42			; NOT-KEY-55
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K41B			;  NO, JUMP
	TEST	BH,LC_E0		;  YES, WAS LAST CODE AN E0?
	JZ	K41A			;    NO, THIS IS THE PRTSC KEY
	JMP	SHORT K42B		;    YES, E0 MEANS THE "*" KEY

K41B:	TEST	BH,KBX			; IS THIS THE ENHANCED KEYBOARD?
	JZ	K41A			;  NO, CTL-PRTSC IS VALID
	TEST	BH,LC_E0		;  YES, WAS LAST CODE AN E0?
	JZ	K42B			;   NO, TRANSLATE TO A FUNCTION
K41A:	MOV	AX,114*256		; START/STOP PRINTING SWITCH
	JMP	K57			; BUFFER_FILL

;------ SET UP TO TRANSLATE CONTROL SHIFT

K42:					; NOT-KEY-55
	CALL	KEYB_STATE_PROCESSOR
	JC	K449	;K26		; TRANSLATIONS FOUND - EXIT

	CMP	AL,15			; IS IT THE TAB KEY?
	JE	K42B			;  YES, XLATE TO FUNCTION CODE
	CMP	AL,53			; IS IT THE / KEY?
	JNE	K42A			;  NO, NO MORE SPECIAL CASES
	TEST	BH,LC_E0		;  YES, IS IT FROM THE KEYPAD?
	JZ	K42A			;   NO, JUST TRANSLATE
	MOV	AX,9500h		;   YES, SPECIAL CODE FOR THIS ONE
	JMP	K57			;   BUFFER FILL

K42A:	MOV	BX,OFFSET K8		; SET UP TO TRANSLATE CTL
	CMP	AL,59			; IS IT IN CHARACTER TABLE?
	JB	K45F			;  YES, GO TRANSLATE CHAR
K42B:	MOV	BX,OFFSET K8		; SET UP TO TRANSLATE CTL
	JMP	K64			;  NO, GO TRANSLATE_SCAN
PAGE
;------ NOT IN CONTROL SHIFT

K44:
	CALL	KEYB_STATE_PROCESSOR
	JC	K449	;K26		; TRANSLATIONS FOUND - EXIT

	CMP	AL,55			; PRINT SCREEN KEY?
	JNE	K45			; NOT-PRINT-SCREEN
	TEST	BP,PC_LAP		; IS THIS THE LAP COMPUTER?
	JZ	K441			;  NO, JUMP
	TEST	BH,LC_E0		;  YES, WAS LAST CODE THE MARKER?
	JZ	K44A			;	NO, TEST THE SHIFT STATE
	JMP	SHORT K45C		;	YES, XLATE TO "*" CHAR
K441:	TEST	BH,KBX			; IS THIS ENHANCED KEYBOARD?
	JZ	K44A			; NO, TEST FOR SHIFT STATE
	TEST	BH,LC_E0		; YES, LAST CODE A MARKER?
	JNZ	K44B			;  YES, IS PRINT SCREEN
	JMP	SHORT K45C		;  NO, XLATE TO "*" CHARACTER
K44A:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ;NOT 101 KBD, SHIFT KEY DOWN?
	JZ	K45C			   ; NO, XLATE TO "*" CHARACTER

;------ ISSUE INTERRUPT TO PERFORM PRINT SCREEN FUNCTION
K44B:
	CLI				; DISABLE INTERRUPTS	       PTR 2355
	AND	KB_FLAG_3,NOT LC_E0+LC_E1 ;ZERO OUT THESE FLAGS
	MOV	AL,ENA_KBD		; INSURE KEYBOARD IS ENABLED
	CALL	SHIP_IT 		; EXECUTE ENABLE
	PUSH	BP			; SAVE POINTER (compatibility)
	INT	5H			; ISSUE PRINT SCREEN INTERRUPT
	POP	BP			; RESTORE POINTER
	JMP	K27A			; EXIT WITHOUT EXTRA EOI OR ENABLE

K449:
	JMP	K26			; EXIT

;------ HANDLE THE IN-CORE KEYS
K45:					; NOT-PRINT-SCREEN
	CMP	AL,58			; TEST FOR IN-CORE AREA
	JA	K46			; JUMP IF NOT

	TEST	BH,GRAPH_ON		; IS ALT GRAPHICS ON?		   AEV
	JNZ	K449	;K26		; YES, TRASH KEYSTROKE

	CMP	AL,53			; IS THIS THE "/" KEY?
	JNE	K45A			;  NO, JUMP
	TEST	BH,LC_E0		; WAS LAST CODE THE MARKER?
	JNZ	K45C			;  YES, TRANSLATE TO CHARACTER

K45A:	MOV	CX,K30_LEN	        ; LENGTH OF SEARCH
	MOV	DI,OFFSET K30+10	; POINT TO TABLE OF A-Z CHARS
	REPNE	SCASB			; IS THIS A LETTER KEY?
	JNE	K45B			;  NO, SYMBOL KEY

	TEST	BL,CAPS_STATE		; ARE WE IN CAPS_LOCK?
	JNZ	K45D			; TEST FOR SURE
K45B:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT ; ARE WE IN SHIFT STATE?
	JNZ	K45E			  ; YES, UPPERCASE
					  ; NO, LOWERCASE
K45C:	MOV	BX,OFFSET K10		; TRANSLATE TO LOWERCASE LETTERS
	JMP	SHORT K56
K45D:					; ALMOST-CAPS-STATE
	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT ; CL ON. IS SHIFT ON, TOO?
	JNZ	K45C			; SHIFTED TEMP OUT OF CAPS STATE
K45E:	MOV	BX,OFFSET K11		; TRANSLATE TO UPPERCASE LETTERS
K45F:	JMP	SHORT K56


;------ TEST FOR KEYS F1 - F10
K46:					; NOT IN-CORE AREA
	CMP	AL,68			; TEST FOR F1 - F10
	JA	K47			; JUMP IF NOT
	JMP	SHORT K53A		; YES, GO DO FN KEY PROCESS


;------ HANDLE THE NUMERIC PAD KEYS

K47:					; NOT F1 - F10
	CMP	AL,83			; TEST FOR NUMPAD KEYS
	JA	K52			; JUMP IF NOT

;------ KEYPAD KEYS, MUST TEST NUM LOCK FOR DETERMINATION
K48:	CMP	AL,74			; SPECIAL CASE FOR MINUS
	JE	K45E			; GO TRANSLATE (US & WT ARE SAME)
	CMP	AL,78			; SPECIAL CASE FOR PLUS
	JE	K45E			; GO TRANSLATE (US & WT ARE SAME)
	TEST	BH,LC_E0		; IS THIS ONE OF THE NEW KEYS?
	JNZ	K49			;  YES, TRANSLATE TO BASE STATE

	TEST	BL,NUM_STATE		; ARE WE IN NUM_LOCK?
	JNZ	K50			; TEST FOR SURE
	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT  ; ARE WE IN SHIFT STATE?
	JNZ	K51			   ; IF SHIFTED, REALLY NUM STATE

;------ BASE CASE FOR KEYPAD
K49:	CMP	AL,76			; SPECIAL CASE FOR BASE STATE 5
	JNE	K49A			; CONTINUE IF NOT KEYPAD 5
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 LOADED?
	JZ	K59	;K26		;  NO, INGORE

	MOV	AL,0F0h 		; SPECIAL ASCII CODE
	JMP	SHORT K57		; BUFFER FILL
K49A:	MOV	BX,OFFSET K10		; BASE CASE TABLE
	JMP	SHORT K64		; CONVERT TO PSEUDO SCAN

;------ MIGHT BE NUM LOCK, TEST SHIFT STATUS
K50:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT	;ALMOST-NUM-STATE
	JNZ	K49			; SHIFTED TEMP OUT OF NUM STATE
K51:	JMP	SHORT K45E		; REALLY_NUM_STATE
					; (US & WT ARE SAME)

;------ TEST FOR THE NEW KEY ON WT KEYBOARDS

K52:					; NOT A NUMPAD KEY
	CMP	AL,86			; IS IT THE NEW WT KEY?
	JNE	K53			; JUMP IF NOT
	MOV	AL,58			; WE'RE GOING TO PULL A SNEAKY
	JMP	K45			; TRICK HERE. WT TABLES ARE TOO SHORT TO
					; XLATE 86, SO WE'LL CHANGE IT TO CAPS_LOCK
					; AND PUT THE CHAR IN THE TABLES IN THE C_L
					; POSITION, SINCE C_L SCAN CODES NEVER GET
					; HERE ANYWAY.

;------ MUST BE F11 OR F12

K53:	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 THERE?
	JZ	K59			;  NO, INGORE F11 & F12 (NEAR RET)
					; F1 - F10 COME HERE, TOO
K53A:	TEST	BL,LEFT_SHIFT+RIGHT_SHIFT ;TEST SHIFT STATE
	JZ	K49			;   JUMP, LOWERCASE PSEUDO SC'S

	MOV	BX,OFFSET K11		; UPPER CASE PSEUDO SCAN CODES
	JMP	SHORT K64		; TRANSLATE_SCAN
PAGE
;------ TRANSLATE THE CHARACTER

K56:					; TRANSLATE-CHAR
	DEC	AL			; CONVERT ORIGIN
	XLAT	CS:K11			; CONVERT THE SCAN CODE TO ASCII
	TEST	KB_FLAG_3,LC_E0	; IS THIS A NEW KEY?
	JZ	K57			;  NO, GO FILL BUFFER
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 THERE?
	JZ	K57			;  NO, DO COMPATIBLE OUTPUT
	MOV	AH,MC_E0		;  YES, PUT SPECIAL MARKER IN AH
	JMP	SHORT K57		; PUT IT INTO THE BUFFER

;------ TRANSLATE SCAN FOR PSEUDO SCAN CODES

K64:					; TRANSLATE-SCAN-ORGD
	DEC	AL			; CONVERT ORIGIN
	XLAT	CS:K8			; CTL TABLE SCAN
	MOV	AH,AL			; PUT VALUE INTO AH
	xor	al,al			; ZERO ASCII CODE
	TEST	KB_FLAG_3,LC_E0		; IS THIS A NEW KEY?
	JZ	K57			;  NO, GO FILL BUFFER
	TEST	BP,EXT_16		; IS THE EXTENDED INT 16 THERE?
	JZ	K57			;  NO, DO COMPATIBLE OUTPUT
	MOV	AL,MC_E0		;  YES, PUT SPECIAL MARKER IN AL

;------ PUT CHARACTER INTO BUFFER

K57:					; BUFFER-FILL
	CALL	BUFFER_FILL
K59:
	JMP	K26			;-- THAT'S ALL FOLKS --

KEYB_INT_9   ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: BUFFER_FILL
;
;  Description:
;      Generate keyboard buffer entry
;
;  Input Registers:
;      AX - the buffer entry
;      DS - BIOS data segment
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

BUFFER_ENTRY_OK DB	NO		; YES if character put into buffer

BUFFER_FILL	PROC   NEAR

	CMP	AL,-1			; IS THIS AN IGNORE CHAR
	JE	K61B			; YES, EXIT
	CMP	AH,-1			; LOOK FOR -1 PSEUDO SCAN
	JE	K61B			; EXIT
;
;  BUFFER_FILL_ANY_CHAR is an alternate entry point to this PROC.
;  Entry at this point will avoid trashing ASCII values of 255.
;
BUFFER_FILL_ANY_CHAR  LABEL  NEAR

	PUSH	SI
	PUSH	BX
	PUSH	DS			; This routine may be called
					;  externally so make sure DS points
	MOV	BX,DATA 		;   to BIOS data
	MOV	DS,BX

	cli				; disable interrupts  P724
	MOV	BX, BUFFER_TAIL 	; GET THE END POINTER TO THE BUFFER
	MOV	SI,BX			; SAVE THE VALUE
	INC	BX			; MOVE TO NEXT WORD IN LIST
	INC	BX

;; VERIFY IF THE CURRENT ROM LEVEL IN THE SYSTEM IS FOR THE ORIGINAL PC1

	TEST	BP,PC_81		; CHECK FOR '81 DATE FLAG SET
        JZ      NOT_PC1                 ; IF IT'S A LATER ROM RELEASE, BRANCH -- M007

	CMP	BX,OFFSET KB_BUFFER_END ; AT END OF BUFFER?
	JNE	K5			; NO, CONTINUE
	MOV	BX,OFFSET  KB_BUFFER	; YES, RESET TO BUFFER BEGINNING
	JMP	SHORT K5
NOT_PC1:
	CMP	BX, BUFFER_END		; AT END OF BUFFER?
	JNE	K5			; NO, CONTINUE
	MOV	BX, BUFFER_START	; YES, RESET TO BUFFER BEGINNING
K5:
	CMP	 BX,BUFFER_HEAD 	; HAS THE BUFFER WRAPPED AROUND
	JE	K62			; BUFFER_FULL_BEEP
	MOV	[SI],AX 		; STORE THE VALUE
	MOV	 BUFFER_TAIL,BX 	; MOVE THE POINTER UP
	MOV	CS:BUFFER_ENTRY_OK,YES	; INDICATE WE PUT SOMETHING IN BUFFER
	JMP	SHORT K61A
K62:
	MOV	CS:BEEP_PENDING,YES	; INDICATE WE NEED A BEEP
K61A:
	POP	DS
	POP	BX
	POP	SI
	sti				; enable interrupts  P724
K61B:
	RET
BUFFER_FILL	ENDP

PAGE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  Procedure: ERROR_BEEP
;
;  Description:
;      General routine to generate beep tones
;
;  Input Registers:
;      None
;
;  Output Registers:
;      None
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


ERROR_BEEP	PROC	NEAR

	CMP	CS:BEEP_PENDING,YES	; Q..SHOULD WE BEEP?
	JNE	NO_BEEP

	MOV	CS:BEEP_PENDING,NO	; Reset BEEP required
	MOV	CX,216-32		; NUMBER OF CYCLES FOR 1/8 SECOND TONE
	IN	AL,PORT_B		; Get control info
	PUSH	AX
LOOP01:
	AND	AL,0FCH 		; Turn off timer gate and speaker
	OUT	PORT_B,AL		; output to control - speaker off
	CALL	WAITFB			; half cycle time for tone
	OR	AL,2			; turn on speaker
	CLI				; Disable interrupts for 1/2 cycle, 300u
	OUT	PORT_B,AL		; output to control
	CALL	WAITFB			; another half cycle
	STI				; Enable interrupts between 1/2 cycle
	LOOP	LOOP01

	POP	AX
	OUT	PORT_B,AL		; Restore control
	MOV	CX,32*2 		; Short delay count of 32 cycles
LOOP02:
	CALL	WAITFB			; Add a short delay to complete 1/8 sec
	LOOP	LOOP02			; Repeat
	CLI				; Disable interrupts
NO_BEEP:
	RET				; RETURN
ERROR_BEEP	ENDP

WAITFB	PROC	NEAR			;	DELAY FOR  (CX)*15.085737 US
	PUSH	AX			; SAVE WORK REGISTER (AH)
	PUSH	CX			; SAVE COUNT
	MOV	CX,19			; The half cycle time for 1745 hz
	TEST	BP,PC_AT+PC_386 	; IF THE SYSTEM IS AN 80x86
	JNZ	WAITF1			; SKIP TO REFRESH BIT DELAY

WAITF0:
	NOP				; Force two fetch cycles on Model 30
	LOOP	WAITF0			; SOFTWARE DELAY LOOP ON 808x MACHINES
	JMP	SHORT WAITFE		; EXIT

WAITF1: 				;	USE TIMER 1 OUTPUT BITS
	IN	AL,PORT_B		; READ CURRENT COUNTER OUTPUT STATUS
	AND	AL,REFRESH_BIT		; MASK FOR REFRESH DETERMINE BIT
	CMP	AL,AH			; DID IT JUST CHANGE
	JE	WAITF1			; WAIT FOR A CHANGE IN OUTPUT LINE

	MOV	AH,AL			; SAVE NEW FLAG STATE
	LOOP	WAITF1			; DECREMENT HALF CYCLES TILL COUNT END
WAITFE:
	POP	CX			; RESTORE COUNT
	POP	AX			; RESTORE (AH)
	RET				; RETURN  (CX)= 0

WAITFB	ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	SHIP_IT
;
;	THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;	TO THE KEYBOARD CONTROLLER.
;
;	On entry the AL contains the command byte.
;	On Enable keyboard commands, the reset keyboard input latch is done
;	if the system is the old PC type.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SHIP_IT PROC	NEAR

;------- TEST SYSTEM TYPE

	PUSHF				; SAVE FLAGS	P725
	CLI				; DISABLE INTERRUPTS TILL DATA SENT

	TEST	BP,PC_XT+PC_LAP
	JZ	SI5			; USE AT 8042 COMMAND IF NOT PC TYPE

	CMP	AL,ENA_KBD		; CHECK FOR ENABLE KEYBOARD COMMAND
	JNE	SI9			; SKIP ENABLE RESET
					;   FOR PC, XT, P12: RESET THE KEYBOARD
	PUSH	AX			; SAVE AX
	IN	AL,KB_CTL		; GET THE CONTROL PORT
	MOV	AH,AL			; SAVE VALUE
	OR	AL,80H			; RESET BIT FOR KEYBOARD ON PC/PC-XT
	OUT	KB_CTL,AL
	XCHG	AH,AL			; GET BACK ORIGINAL CONTROL
	OUT	KB_CTL,AL		; KB HAS BEEN RESET
	POP	AX			; RESTORE AX
					; EXIT as NOT next system
SI5:
	TEST	BP,PC_AT+PC_386 	; IF THE SYSTEM IS NOT AN 80x86
	JZ	SI9			; MACHINE, EXIT THIS PROC.

;------- WAIT FOR COMMAND TO BE ACCEPTED;

	CALL	chk_ibf 		; GO READ KEYBOARD CONTROLLER STATUS
	OUT	STATUS_PORT,AL		; SEND TO KEYBOARD CONTROLLER
SI9:					; ENABLE INTERRUPTS AGAIN
	POPF				; RESTORE FLAGS P725
	RET				; RETURN TO CALLER
SHIP_IT ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	SND_DATA
;
;	THIS ROUTINE HANDLES TRANSMISSION OF COMMAND AND DATA BYTES
;	TO THE KEYBOARD AND RECEIPT OF ACKNOWLEDGEMENTS.  IT ALSO
;	HANDLES ANY RETRIES IF REQUIRED
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_DATA PROC	NEAR
	PUSH	AX			; SAVE REGISTERS
	PUSH	BX			; *
	PUSH	CX
	MOV	BH,AL			; SAVE TRANSMITTED BYTE FOR RETRIES

	MOV	BL,3			; LOAD RETRY COUNT
SD0:
	CLI				; DISABLE INTERRUPTS
	AND	KB_FLAG_2,NOT (KB_FE+KB_FA+kb_err) ; CLEAR ACK, RESEND and
						    ; error flags

	CALL	CHK_IBF 		; Wait for command accepted

	MOV	AL,BH			; REESTABLISH BYTE TO TRANSMIT
	OUT	PORT_A,AL		; SEND BYTE
	STI				; ENABLE INTERRUPTS
	MOV	CX,DLY_15MS		; DELAY FOR 15 ms TIMEOUT
SD1:	TEST	KB_FLAG_2,KB_FE+KB_FA	; SEE IF EITHER BIT SET
	JNZ	SD3			; IF SET, SOMETHING RECEIVED GO PROCESS
	IN	AL,PORT_B		; WAIT LOOP USING REFRESH BIT
	AND	AL,REFRESH_BIT
	CMP	AL,AH
	JE	SD1			; KEEP TESTING
	MOV	AH,AL			; DEC CX ON REFRESH TIC
	LOOP	SD1			; KEEP TESTING
					; !! TIMEOUT !!

SD2:	DEC	BL			; DECREMENT RETRY COUNT
	JNZ	SD0			; RETRY TRANSMISSION
	OR	KB_FLAG_2,KB_ERR	; TURN ON TRANSMIT ERROR FLAG
	JMP	SHORT SD4		; RETRIES EXHAUSTED FORGET TRANSMISSION

SD3:	TEST	KB_FLAG_2,KB_FA	; SEE IF THIS IS AN ACKNOWLEDGE
	JZ	SD2			; IF NOT, GO RESEND

SD4:	POP	CX			; RESTORE REGISTERS
	POP	BX
	POP	AX			; *
	RET				; RETURN, GOOD TRANSMISSION
SND_DATA ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	SND_LED
;
;	THIS ROUTINE TURNS ON THE MODE INDICATORS.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SND_LED PROC	NEAR
	CLI				; TURN OFF INTERRUPTS

	TEST	BP,PC_AT+PC_386 	; IF THE SYSTEM IS NOT A 80x86
	JZ	SL1			; MACHINE, EXIT THIS PROC

	TEST	KB_FLAG_2,KB_PR_LED	; CHECK FOR MODE INDICATOR UPDATE
	JNZ	SL1			; DONT UPDATE AGAIN IF UPDATE UNDERWAY
	OR	KB_FLAG_2,KB_PR_LED	; TURN ON UPDATE IN PROCESS
	MOV	AL,LED_CMD		; LED CMD BYTE
	CALL	SND_DATA		; SEND DATA TO KEYBOARD
	CLI
	CALL	MAKE_LED		; GO FORM INDICATOR DATA BYTE
	AND	KB_FLAG_2,0F8H 		; CLEAR MODE INDICATOR BITS
	OR	KB_FLAG_2,AL		; SAVE PRESENT INDICATORS FOR NEXT TIME
	TEST	KB_FLAG_2,KB_ERR	; TRANSMIT ERROR DETECTED
	JNZ	SL2			;  YES, BYPASS SECOND BYTE TRANSMISSION
	CALL	SND_DATA		; SEND DATA TO KEYBOARD
	CLI				; TURN OFF INTERRUPTS
	TEST	KB_FLAG_2,KB_ERR	; TRANSMIT ERROR DETECTED
	JZ	SL3			; IF NOT, DONT SEND AN ENABLE COMMAND
SL2:	MOV	AL,KB_ENABLE		; GET KEYBOARD CSA ENABLE COMMAND
	CALL	SND_DATA		; SEND DATA TO KEYBOARD
	CLI				; TURN OFF INTERRUPTS
SL3:	AND	KB_FLAG_2,NOT(KB_PR_LED+KB_ERR) ; TURN OFF MODE INDICATOR
					; UPDATE AND TRANSMIT ERROR FLAG
SL1:	STI				; ENABLE INTERRUPTS
	RET				; RETURN TO CALLER
SND_LED ENDP
PAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	MAKE_LED
;
;	THIS ROUTINE FORMS THE DATA BYTE NECESSARY TO TURN ON/OFF
;	THE MODE INDICATORS
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MAKE_LED PROC	NEAR
	PUSH	CX			; SAVE CX
	MOV	AL, KB_FLAG		; GET CAPS & NUM LOCK INDICATORS
	AND	AL,CAPS_STATE+NUM_STATE+SCROLL_STATE ; ISOLATE INDICATORS
	MOV	CL,4			; SHIFT COUNT
	ROL	AL,CL			; SHIFT BITS OVER TO TURN ON INDICATORS
	AND	AL,07H			; MAKE SURE ONLY MODE BITS ON
	POP	CX
	RET				; RETURN TO CALLER
MAKE_LED ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	CHK_IBF
;
;  Description:
;      Waits for a keyboard command to be accepted
;	wait until ibf = 0   (empty)
;
;  Input Registers:
;      None
;
;  Output Registers:
;	ZF=0	time out & IBF still full
;	ZF=1	IBF is empty
;
;	---------------------------------------------------------------
;	This procedure replaces the previous one which used a software
;	timing loop.   (For 80286, 80386 and 80486 based machines.)
;	---------------------------------------------------------------
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

chk_ibf proc	near

	push	ax			; Save register used
	push	cx
	mov	cx,DLY_15MS		; Timeout 15 milleseconds (15000/15.086;
chk_ibfl:
	in	al,PORT_B		; Read current refresh output bit
	and	al,refresh_bit		; Mask all but refresh bit
	cmp	al,ah			; Did it change? (or first pass thru)
	jz	short chk_ibfl		; No, wait for change, else continue

	mov	ah,al			; Save new refresh bit state
	in	al,status_port		; Read status port
	test	al,inpt_buf_full	; Check for input buffer empty
	loopnz	chk_ibfl		; Loop until input buf empty or timeout;

	pop	cx
	pop	ax			; Restore register used
	ret				; Return to caller

chk_ibf endp

;	M005 -- begin added section

;***********************************************************************;JP9009
;*                                                                     *;JP9009
;*                    DBCS Common Keyboard Support                     *;JP9009
;*                                                                     *;JP9009
;*      The DBCS common keyboard unique scan code is mapped to the     *;JP9009
;*      temporary scan code. It is again mapped to the corresponding   *;JP9009
;*      scan code/character code according the current shift staes.    *;JP9009
;*                                                                     *;JP9009
;***********************************************************************;JP9009
                                                                        ;JP9009
DBCS_keyboard_support   proc    near                                    ;JP9009
        cmp     al, 80h                         ; Ignore break keys     ;JP9009
        jae     leave_it_to_common_method                               ;JP9009
        test    cs:SD.KEYB_TYPE, DBCS_KB        ; DBCS keyboard?        ;JP9009
        jz      leave_it_to_common_method                               ;JP9009
        cmp     cs:SD.INVOKED_CP_TABLE, 932     ; DBCS code page?       ;JP9009
        jb      leave_it_to_common_method                               ;JP9009
                call    DBCS_keyboard_common_support                    ;JP9009
                test    cs:SD.KEYB_TYPE, DBCS_OLD_KB                    ;JP9009
                jz      leave_it_to_common_method_1                     ;JP9009
                        call    DBCS_old_keyboard_support               ;JP9009
    leave_it_to_common_method_1:                                        ;JP9009
                mov     ah, al          ; ah = al = 'make' scan code    ;JP9009
                mov     cs:scan_code, al; Set this because we don't know;JP9009
                                        ; who will use it later.        ;JP9009
    leave_it_to_common_method:                                          ;JP9009
        ret                                                             ;JP9009
DBCS_keyboard_support   endp                                            ;JP9009
                                                                        ;JP9009
PSEUDO_SC_ALPHANUMERIC  equ     7eh                                     ;JP9009
PSEUDO_SC_HIRAGANA      equ     7fh                                     ;JP9009
                                                                        ;JP9009
DBCS_keyboard_common_support    proc    near                            ;JP9009
        ; Check if it is the Alphanumeric key or Kanji NO key           ;JP9009
        ; of the DBCS new keyboard.                                     ;JP9009
        cmp     al, 3ah                         ; CAPS key ?            ;JP9009
        jne     leave_it_to_common_method_2     ; if not                ;JP9009
        test    bl, ALT_SHIFT                                           ;JP9009
        jnz     convert_to_alphanumeric                                 ;JP9009
        test    bl, (LEFT_SHIFT or RIGHT_SHIFT)                         ;JP9009
        jnz     leave_it_to_common_method_2                             ;JP9009
        jmp     short convert_to_alphanumeric_2                         ;JP9009
    convert_to_alphanumeric:                                            ;JP9009
            test    cs:SD.KEYB_TYPE, DBCS_OLD_A_KB                      ;JP9009
            jnz     leave_it_to_common_method_2                         ;JP9009
    convert_to_alphanumeric_2:                                          ;JP9009
                mov     al, PSEUDO_SC_ALPHANUMERIC                      ;JP9009
    leave_it_to_common_method_2:                                        ;JP9009
        ret                                                             ;JP9009
DBCS_keyboard_common_support    endp                                    ;JP9009
                                                                        ;JP9009

;***********************************************************************;JP9009
;*                                                                     *;JP9009
;*                    DBCS Old Keyboard Support                        *;JP9009
;*                                                                     *;JP9009
;*      The old DBCS keyboard unique scan codes is mapped to the       *;JP9009
;*      temporary scan code. It is again mapped to the corresponding   *;JP9009
;*      scan code/character code according the current shift staes.    *;JP9009
;*                                                                     *;JP9009
;***********************************************************************;JP9009
                                                                        ;JP9009
DBCS_old_keyboard_support       proc    near                            ;JP9009
        cmp     al, 38h                                                 ;JP9009
        jne     not_right_ALT_nor_hiragana                              ;JP9009
        test    ds:KB_FLAG_3, LC_E0                                     ;JP9009
        jz      not_right_ALT_nor_hiragana                              ;JP9009
                mov     al, PSEUDO_SC_HIRAGANA                          ;JP9009
                and     ds:KB_FLAG_3, not LC_E0                         ;JP9009
    not_right_ALT_nor_hiragana:                                         ;JP9009
        ret                                                             ;JP9009
DBCS_old_keyboard_support       endp                                    ;JP9009

;	M005 -- end added section

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybshar.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1991
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSHAR.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;; ;jwg  ; - Feb 1990 For 4.03.
;; ;AN007; -	       Add Patriot/Sebring determination code for HOT Replug
;;			so that INT 9 handler can alter keyboard Scan Code set.
;; ;M030		Merged IBM (Kermit - JP), KEYBOARD.SYS and KEYB.COM
;;			  versions of this file into one.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHARED_DATA_STR defines the initial fixed length portion of the
;; Shared Data Area.
;; Tables are loaded beginning at TABLE_AREA in the following order:
;;  State Logic
;;  Common Translate Section
;;  Specific Translate Sections for
;;   each code page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; SPECIAL_FEATURES equates:
TYPEWRITER_CAPS_LK  EQU    8000H	;; typewriter style caps lock
					;;
JR_HOT_KEY_1_2	equ	4000h		;; M030 Merged back for kdfcf.asm
;;========================================
;; Added for French Canadian Dual Mode
;; 3/16/93
;;========================================
SHIFTS_TO_LOGIC     EQU    2000H       ;; - transfer CTRL, SHIFT, ALT keys
                                       ;;   to LOGIC section
                                       ;;
SWITCHABLE          EQU    1000H       ;; - Driver can use NLS/Def mode
                                       ;;   switching (like Rus/Lat mode)
                                       ;;   Used for Int 2Fh, function 0AD83h answer
;;========================================
;; End of modifications for Fr-Can
;;========================================
JR_KB		equ	8000h		;; M030 Merged back for kdfcf.asm
					;; Some useful scan codes:
F1_SCAN     EQU   59			;; F1
F2_SCAN     EQU   60			;; F2
					;;
					;;	SYSTEM_FLAG / Hardware equates:
					;;   INT 16h and remote support
EXT_16		EQU	8000H		;; extended INT 16h support is there
EXT_122 	EQU	4000H		;; extended INT 16h for 122 is there
;		EQU	2000H		;;  unused
PC_NET		EQU	1000H		;; flag PC Net is installed
					;;   System type/hardware support flags
PC_81		EQU	0800H		;; flag for Original PC
PC_XT		EQU	0400H		;; code for PC, PC/XT, PORTABLE
PC_LAP		EQU	0200H		;; code for Convertiable (p-12)
PC_PAL		EQU	0080H		;; code for Model 30 (PALACE)
PC_AT		EQU	0040H		;; code for PC-AT  with 8042
PC_386		EQU	0020H		;; code for PS/2's with 8042 (WRANGLER)
PS_8042 	EQU	0010H		;; 8042 is a Patriot/Sebring type array;AN007;jwg
					;;  or system set translate OFF (SCS=01)
SECURITY_ACTIVE	EQU	0008h	; M030	;; Server password mode is active
;				; M030	;;  This bit becomes off from on when
;				; M030	;;  correct password is entered JP9010
					;;
					;; HOT_KEY_FLAG EQUATES:
US_MODE     EQU   0			;;  hot key is active => US
LANG_MODE   EQU   0FFH			;;  hot key is inactive
					;;
					;; -----------------------------------
SHARED_DATA_STR     STRUC		;; SHARED DATA AREA
					;;
OLD_INT_9	    DD	  0		;; saved int 9 vector
OLD_INT_2F	    DD	  0		;; saved int 2F vector
		    dd    0		;; reserved
KEYB_TYPE	    DW	  0		;; type of keyboard
SYSTEM_FLAG	    DW	  0		;; system configuration flags
TABLE_OK	    DB	  0		;; flag to INT 9 that table is built
		    db    5 dup (0)	;; reserved
					;;
					;; Table copy begins here:
ACTIVE_LANGUAGE     DB	  'US'          ;; language code
INVOKED_CP_TABLE    DW	  437		;; ptr to table for invoked code page
INVOKED_KBD_ID	    DW	  0		;; WGR invoked keyboard id.	       ;AN000
ACTIVE_XLAT_PTR     DW	  -1		;; ptr to active Specific Translate Sect
FIRST_XLAT_PTR	    DW	  -1		;; ptr to first Specific Translate Sect
RESIDENT_END	    DW	  0ffffh	;; offset of last byte in resident mem
LOGIC_PTR	    DW	  -1		;; ptr to State Logic
COMMON_XLAT_PTR     DW	  -1		;; ptr to Common Translate Section
SPECIAL_FEATURES    DW	  ?		;; special Features
TABLE_OVERFLOW	    DB	  0		;; overflow flag for table rebuild
HOT_KEY_ON_SCAN     DB	  ?		;; scan codes to use with ALT+CTRL
HOT_KEY_OFF_SCAN    DB	  ?		;;  to turn hot key on and off
		    DB	  4 DUP(0)	;; reserved
TABLE_AREA	    DB	  ?		;; tables loaded here:
					;;  State Logic
					;;  Common Translate Section
					;;  Specific Translate Sections for
					;;   each code page
SHARED_DATA_STR     ENDS		;;
					;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic equates.
;; Contains equates for our NLS Flags and for the State Logic
;; commands.
;; State Logic command macros are defined in KEYBMAC.INC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_LOGIC_STR STRUC			;;
					;;
SL_LOGIC_LEN	DW   ?			;; length of state logic
SL_SPECIAL_FEATURES   DW   ?		;;
SL_LOGIC_CMDS	DB   0			;; state logic commands begin here
					;;
STATE_LOGIC_STR ENDS			;;
					;;
					;;
NUM_BIOS_FLAGS	    EQU   4		;;
NUM_NLS_FLAGS	    EQU   2		;; '+1' below is the EXT_KB_FLAG
NUM_FLAGS	    EQU   NUM_BIOS_FLAGS+NUM_NLS_FLAGS+1
					;;
					;;
EITHER_SHIFT	    EQU   80H		;; EXT_KB_FLAG : our own shift state
EITHER_CTL	    EQU   40H		;;  flags
EITHER_ALT	    EQU   20H		;;
SCAN_MATCH	    EQU   08H		;; set if scan code found in XLATT
					;; or SET_FLAG searches
                                        ;;
SHIFTS_PRESSED      EQU   04H           ;; set if any SHIFT, ALT, CTRL key
                                        ;; pressed (used in Frn-Can kdf)
					;;					;;
KB_FLAG_ID	    EQU   0		;; Flag ID's as coded in IFF and ANDF
KB_FLAG_1_ID	    EQU   1		;;  commands
KB_FLAG_2_ID	    EQU   2		;;
KB_FLAG_3_ID	    EQU   3		;;
EXT_KB_FLAG_ID	    EQU   4		;;
NLS_FLAG_1_ID	    EQU   5		;;
NLS_FLAG_2_ID	    EQU   6		;;
					;;
COMMAND_BITS	    EQU   0F0H		;; Mask to isolate command code
SUB_CMD_BITS	    EQU   0FH		;; mask to isolate sub command code
NOT_TEST	    EQU   08H		;; NOT bit in IFF, ANDF
COMMAND_SHIFT	    EQU   4		;; shift amount for command code
FLAG_ID_BITS	    EQU   07H		;; mask to isolate flag id in IFF, ANDF
NUM_COMMANDS	    EQU   0CH		;; number of commands
					;;
IFF_COMMAND	    EQU   00H		;;
ANDF_COMMAND	    EQU   10H		;;
ELSEF_COMMAND	    EQU   20H		;;
ENDIFF_COMMAND	    EQU   30H		;;
XLATT_COMMAND	    EQU   40H		;;
OPTION_COMMAND	    EQU   50H		;;
SET_FLAG_COMMAND    EQU   60H		;;
PUT_ERROR_COMMAND   EQU   70H		;;
IFKBD_COMMAND	    EQU   80H		;;
GOTO_COMMAND	    EQU   90H		;;
BEEP_COMMAND	    EQU   0A0H		;;
RESET_NLS_COMMAND   EQU   0B0H		;;
RESET_NLS1_COMMAND  EQU   0C0H          ;; FRN-CAN to toggle keyb state for dead keys
CHECK_CORE_COMMAND  EQU   0C0H		;;
					;;
					;;
EXIT_INT_9_FLAG 	EQU  01H	;; Special forms of GOTO.  These
EXIT_STATE_LOGIC_FLAG	EQU  02H	;;  values are in the right nibble
					;;   of the GOTO command.
					;;
					;; PROCESSING OPTIONS:
EXIT_IF_FOUND	    EQU   80H		;; exit INT 9 if a translation
					;;  match is found
					;;
ANY_KB		     EQU   0FFFFH	;;
XT_KB		     EQU   4000H	;;
AT_KB		     EQU   2000H	;;
G_KB		     EQU   1000H	;;
P_KB		     EQU   0800H	;;
P12_KB		     EQU   0400H	;;
DBCS_OLD_A_KB	     EQU   0080H ; M030	;; JP9009
DBCS_OLD_P_KB	     EQU   0040H ; M030	;; JP9009
DBCS_OLD_G_KB	     EQU   0020H ; M030	;; JP9009
DBCS_OLD_KB	     EQU   00C0H ; M030	;; JP9009
DBCS_KB		     EQU   0020H ; M030	;; JP9009
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table Sections.  Both the Specific and Common
;; Translate Sections are formatted as follows.
;;
;; The Specific Translate Sections are chained together using the
;; XS_NEXT_SECT_PTR field (-1 if last section).
;; Translate Sections contains multiple States.
;; A State contains the translate tables for a single
;; shift state (IE lower case, upper case ....)
;; Each State may contain multiple translate tables.
;;
;; The Translate Section layout is defined using several STRUCs.
;; These STRUCs are allocated in the Shared Data Area as follows:
;;
;;	 XLAT_SECT_STR		  ; header info for the section
;;	    STATE_STR		  ; header for state #1
;;	      XLAT_STR		  ;   first translate tab for state #1
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      XLAT_STR		  ;   second translate tab
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	    STATE_STR		  ; header for state #2
;;	      XLAT_STR
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	   ...
;;
;; A State may contain a "Set_Flag" table instead of translate tables.
;; These tables are used to set the NLS flags instead of generating
;; ASCII codes (for example: to remember dead key states).
;; There can be only on Set_Flag table per state.
;; The Set_Flag table layout is defined in the SET_FLAG_STR STRUC.
;;
;; So some states will contain translate tables (to generate ASCII codes)
;; and some states will contain a Set_Flag table (to record dead key
;; status).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
XLAT_SECT_STR	    STRUC		;;
					;;
XS_NEXT_SECT_PTR       DW    ?		;; Pointer to next Specific Translate
					;;  Section
XS_CP_ID	       DW    ?		;; code page id
XS_FIRST_STATE	       DB    ?		;;
					;;
XLAT_SECT_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State structure.
;; The last State is a null State containing only the
;; XS_STATE_LEN field with a value of 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_STR	    STRUC		;;
					;;
XS_STATE_LEN	 DW    ?		;; length of state section
XS_STATE_ID	 DB    ?		;; State ID
XS_KBD_TYPE	 DW    ?		;; Keyboard Type
XS_ERROR_CHAR	 DW    ?		;; Buffer entry for error character
XS_FIRST_TAB	 DB    ?		;;
					;;
STATE_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table structures.
;; There may be many translate tables in a State.  The last
;; table is a null table containing only the XLAT_TAB_SIZE field with
;; a value of 0.
;; The xlate table can be in one of two forms:
;;    Type 1 = Table contains buffer entries only.
;;	       Scan code is used as an index into xlat table
;;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;;	       Table must be searched for matching scan.
;; Type 1 is the default.  Type 2 tables should be identified by setting
;; the TYPE_2_TAB bit in XLAT_OPTIONS.
;; Buffer entries default to 2-bytes per entry.
;; Optionally the table may contain ASCII codes only
;; (1-byte entries).  This is specified by setting the ASCII_ONLY bit
;; in XLAT_OPTIONS.  2-byte buffer entries are coded ASCII,SCAN.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; Translate options:
ASCII_ONLY	    EQU   80H		;; Only ASCII codes listed - use
					;;  incoming scan for buffer entry
TYPE_2_TAB	    EQU   40H		;; search xlat table for matching scan
ZERO_SCAN	    EQU   20H		;; set the scan half of the buffer
					;;  entry to 0
					;;
NULL_ASCII_CODE     EQU   -1		;;
					;;
DEFAULT_TAB_2_ENT_SZ   EQU   3		;;
ASC_ONLY_TAB_2_ENT_SZ  EQU   2		;;
					;;
					;;
XLAT_STR	    STRUC		;;
					;;
XLAT_TAB_SIZE	    DW	  ?		;; Size in bytes of this table -
					;;  includes this field, options etc.
XLAT_OPTIONS	    DB	  ?		;; xlat options
					;; XLAT TABLE IS HERE
XLAT_STR	    ENDS		;;
					;;
XLAT_TYPE_1_STR     STRUC		;; use scan code as index into table
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_SCAN_LO	    DB	  ?		;; Scan code
XLAT_SCAN_HI	    DB	  ?		;;  range
XLAT_1_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_1_STR     ENDS		;;
					;;
XLAT_TYPE_2_STR     STRUC		;; search table for scan
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_NUM	    DB	  ?		;; number of scans
XLAT_SCAN	    DB	  ?		;; Scan code
XLAT_2_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_2_STR     ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set_Flag Tables.
;; State Sections immediately following the LAST_ENTRYs.
;; Dead key definitions.  If the scan matches then
;; set the bit in NLS_FLAGs indicated in DK_MASK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
SF_ENT_SZ     EQU   3			;; size of entry
					;;
SET_FLAG_STR	    STRUC		;;
					;;
SF_NUM		    DB	  0		;; Number of entries
SF_SCAN_CODE	    DB	  0		;; scan code
SF_FLAG_ID	    DB	  0		;; flag id
SF_FLAG_MASK	    DB	  0		;; flag mask
					;;
SET_FLAG_STR	    ENDS		;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\keybtbbl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
	PAGE	,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                                           
; MS-DOS 5.00 - NLS Support - KEYB Command
;
; File Name:  KEYBTBBL.ASM
; ----------
;
; Description:
; ------------
;	Build SHARED_DATA_AREA with parameters specified
;	in KEYBCMD.ASM
;
; Documentation Reference:
; ------------------------
;	None
;
; Procedures Contained in This File:
; ----------------------------------
;	TABLE_BUILD: Build the header sections of the SHARED_DATA_AREA
;	STATE_BUILD: Build the state sections in the table area
;	FIND_CP_TABLE: Given the language and code page parm, determine the
;		offset of the code page table in KEYBOARD.SYS
;
; Include Files Required:
; -----------------------
;	KEYBSHAR.INC
;	KEYBSYS.INC
;	KEYBDCL.INC
;	KEYBI2F.INC
;
; External Procedure References:
; ------------------------------
;	None
;
; Change History:
; ---------------
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	PUBLIC TABLE_BUILD
	PUBLIC FIND_CP_TABLE
	PUBLIC CPN_INVALID
	PUBLIC SD_LENGTH

CODE	SEGMENT PUBLIC 'CODE'

	INCLUDE KEYBEQU.INC
	INCLUDE KEYBSHAR.INC
	INCLUDE KEYBSYS.INC
	INCLUDE KEYBCMD.INC
	INCLUDE KEYBDCL.INC
	INCLUDE COMMSUBS.INC
	INCLUDE KEYBCPSD.INC

	ASSUME  cs:CODE,ds:CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: TABLE_BUILD
;
; Description:
;	Create the table area within the shared data structure. Each
;	table is made up of a descriptor plus the state sections.
;	Translate tables are found in the Keyboard definition file and are
;	copied into the shared data area by means of the STATE_BUILD
;	routine.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	bp - points at beginning of CMD_PARM_LIST
;
;	SHARED_DATA_STR must be allocated in memory
;
;	The following variables must also be passed from KEYB_COMMAND
;	 KEYBSYS_FILE_HANDLE is set to file handle after opening file
;	 CP_TAB_OFFSET is the offset of the CP table in the SHARED_DATA_AREA
;	 STATE_LOGIC_OFFSET is the offset of the state section in the SHARED_DATA_AREA
;	 SYS_CODE_PAGE is the binary representation of the system CP
;	 KEYBCMD_LANG_ENTRY_PTR is a pointer to the lang entry in KEY DEF file
;	 DESIG_CP_BUFFER is the buffer which holds a list of designated CPs
;	 DESIG_CP_OFFSET:WORD is the offset of that list
;	 NUM_DESIG_CP is the number of CPs designated
;	 FILE_BUFFER is the buffer to read in the KEY DEF file
;**********CNS ***************************************
;	 ID_PTR_SIZE is the size of the ID ptr structure
;**********CNS ***************************************
;	 LANG_PTR_SIZE is the size of the lang ptr structure
;	 CP_PTR_SIZE is the size of the CP ptr structure
;	 NUM_CP is the number of CPs in the KEYB DEF file for that lang
;	 SHARED_AREA_PTR segment and offset of the SHARED_DATA_AREA
;
;
; Output Registers:
;	cx - RETURN_CODE :=  0  - Table build successful
;			  1  - Table build unsuccessful - ERROR 1
;					(Invalid language parm)
;			  2  - Table build unsuccessful - ERROR 2
;					(Invalid Code Page parm)
;			  3  - Table build unsuccessful - ERROR 3
;					(Machine type unavaliable)
;			  4  - Table build unsuccessful - ERROR 4
;					(Bad or missing keyboard def file)
;			  5  - Table build unsuccessful - ERROR 5
;					(Memory overflow occurred)
; Logic:
;	Calculate Offset difference between TEMP and SHARED_DATA_AREAs
;	Get LANGUAGE_PARM and CODE_PAGE_PARM from parm list
;	Call FIND_CP_TABLE := Determine whether CP is valid for given language
;	IF CP is valid THEN
;	Store them in the SHARED_DATA_AREA
;	Prepare to read Keyboard definition file by LSEEKing to the top
;	READ the header
;	Store maximum table values for calculation of RES_END
;	Set di to point at TABLE_AREA within SHARED_DATA_AREA
;	FOR the state logic section of the specified language:
;		IF STATE_LOGIC_PTR is not -1 THEN
;		LSEEK to state logic section in keyboard definition file
;		READ the state logic section into the TABLE_AREA
;		Set the hot keyb scan codes
;		Set the LOGIC_PTR in the header
;	FOR the common translate section:
;		IF Length parameter is not 0 THEN
;		Build state
;		Set the COMMON_XLAT_PTR in the header
;	FOR the specific translate sections:
;	Establish addressibility to list of designated code pages
;	FOR each code page
;		IF CP_ENTRY_PTR is not -1 THEN
;		Determine offset of CP table in Keyb Def file
;		IF CP table not avaliable THEN
;			Set CPN_INVALID flag
;		ELSE
;			LSEEK to CPn state section in keyboard definition file
;			IF this is the invoked code page THEN
;			Set ACTIVE_XLAT_PTR in SHARED_DATA_AREA
;			Update RESIDENT_END ptr
;			Build state
;	Update RESIDENT_END ptr
;	End
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FB		EQU	FILE_BUFFER
KB_MASK		EQU	02H

FIRST_XLAT_TAB	DW	0
NEXT_SECT_PTR	DW	-1

MAX_COM_SIZE	DW	?
MAX_SPEC_SIZE	DW	?
MAX_LOGIC_SIZE	DW	?

RESIDENT_END_ACC DW	0
SA_HEADER_SIZE	DW	SIZE SHARED_DATA_STR;
PARM_LIST_OFFSET DW	?
;********************CNS*************************
TB_ID_PARM	DW	0
;********************CNS*************************
TB_LANGUAGE_PARM DW	0
TB_CODE_PAGE_PARM DW	0

CPN_INVALID	DW	0

KEYB_INSTALLED	DW	0
SD_AREA_DIFFERENCE DW	0
SD_LENGTH	DW	2000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TABLE_BUILD	  PROC NEAR

	mov	ax,OFFSET SD_SOURCE_PTR	; Setup the difference
	sub	ax,OFFSET SD_DesT_PTR	; value used to calculate
	mov	SD_AREA_DIFFERENCE,ax	; new ptr values for
					;  SHARED_DATA_AREA
	mov	ax,[bp].ID_PARM		; Get id parameter
	mov	TB_ID_PARM,ax
	mov	ax,[bp].LANGUAGE_PARM	; Get language parameter
	mov	TB_LANGUAGE_PARM,ax
	mov	bx,[bp].CODE_PAGE_PARM	; Get code page parameter
	mov	TB_CODE_PAGE_PARM,bx
					; Make sure code page is
	call	FIND_CP_TABLE		;   valid for the language
	jcxz	TB_CHECK_CONTINUE1	; IF code page is found
	jmp	TB_ERROR6		;  for language THEN

TB_CHECK_CONTINUE1:
	mov	bp,OFFSET SD_SOURCE_PTR	; Put language parm and
	mov	ax,TB_ID_PARM		;  id parm and..
	mov	es:[bp].INVOKED_KBD_ID,ax
	mov	bx,TB_CODE_PAGE_PARM
	mov	es:[bp].INVOKED_CP_TABLE,bx	; code page parm into the
	mov	ax,TB_LANGUAGE_PARM		;  SHARED_DATA_AREA
	mov	word ptr es:[bp].ACTIVE_LANGUAGE,ax

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	xor	dx,dx			; LSEEK file pointer
	xor	cx,cx			;  back to top of file
	mov	ax,4200h		; If no problem with
	int	21H			;  Keyboard Def file THEN
	jnc	TB_START
	jmp	TB_ERROR4

TB_START:				; Else
	xor	di,di			; Set number
;M006	LEA	cx,[di].KH_MAX_LOGIC_SZ+2 ;	bytes to read header
	lea	cx,[di].KH_NUM_ID+2	; M006 -- read a few extra entries
	mov	dx,OFFSET FILE_BUFFER	; Move contents into file buffer
	mov	ah,3FH			;  READ
	push	cs
	pop	ds
	int	21H			;  File
	jnc	TB_CONTINUE1
	jmp	TB_ERROR4

TB_CONTINUE1:
	cmp	cx,ax
	je	TB_ERROR_CHECK1
;M002	mov	cx,4
;M002	jmp	TB_CPN_INVALID
tb_err4_j:				; M006
	jmp	TB_ERROR4		; M002

TB_ERROR_CHECK1:
	cmp	FB.KH_NUM_ID,0		; M006 -- is it an old KEYBOARD.SYS?
	jz	tb_err4_j		; M006 --  bomb out if so

	mov	cx,FB.KH_MAX_COM_SZ	; Save values for RESIDENT_END
	mov	MAX_COM_SIZE,cx		;  calculation
	mov	cx,FB.KH_MAX_SPEC_SZ
	mov	MAX_SPEC_SIZE,cx
	mov	cx,FB.KH_MAX_LOGIC_SZ
	mov	MAX_LOGIC_SIZE,cx


	LEA	di,[bp].TABLE_AREA	; Point at beginning of table area
					;		di ---> TABLE_AREA

;	M002 -- begin added section
;
;	Before we go ANY further, let's see if we actually have room
;	   for our worst case memory allocation needs.  Notice that
;	   we're actually trusting the MAX fields from the KEYBOARD
;	   definition file.  If it lies to us and has fields bigger
;	   than these MAX values, we may crash over memory we don't
;	   own during initialization.

	mov	ax,NUM_DESIG_CP
	mul	MAX_SPEC_SIZE
	or	dx,dx			; error if overflowed 16 bits
	jnz	mem_alloc_err

	add	ax,SA_HEADER_SIZE
	jc	mem_alloc_err
	add	ax,MAX_LOGIC_SIZE
	jc	mem_alloc_err
	add	ax,MAX_COM_SIZE
	jc	mem_alloc_err

;	Note that ax could be used for the RESIDENT_END_ACC value,
;	  but since this check is being added late in the testing
;	  cycle, we'll leave that calculation alone.

	add	ax,di			; get the ending offset of temp buffer
	jc	mem_alloc_err

	add	ax,15
	jc	mem_alloc_err
	mov	cl,4			; convert to paragraph
	shr	ax,cl
	mov	cx,ax
	mov	ax,cs			; get our code segment
	add	ax,cx			; this is our ending segment
	cmp	ax,cs:[2]		; compare against psp:2
	jb	mem_alloc_ok
mem_alloc_err:
	jmp	TB_ERROR5
mem_alloc_ok:

;	M002 -- end added section

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR STATE LOGIC SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_STATE_BEGIN:
	mov	bx,KEYBSYS_FILE_HANDLE		; Get handle
	mov	cx,word ptr STATE_LOGIC_OFFSET+2
	mov	dx,word ptr STATE_LOGIC_OFFSET	; Get LSEEK file pointer

	cmp	dx,-1			; If no language table then
	jnz	TB_STATE_CONTINUE1	;  jump to code page begin
	jmp	TB_CP_BEGIN

TB_STATE_CONTINUE1:			; Else
	mov	ax,4200h		; LSEEK to begin of state logic sect
	int	21H			;	Keyboard Def file THEN
	jnc	TB_STATE_CONTINUE2
	jmp	TB_ERROR4

TB_STATE_CONTINUE2:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	sub	di,SD_AREA_DIFFERENCE	; Adjust for relocation
	mov	es:[bp].LOGIC_PTR,di	; Set because this is state
	add	di,SD_AREA_DIFFERENCE	; Adjust for relocation

	mov	cx,4			; Set number bytes to read length and
					;	special features
	mov	dx,OFFSET FILE_BUFFER	; Set the buffer address
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	jnc	TB_STATE_CONTINUE3
	jmp	TB_ERROR4

TB_STATE_CONTINUE3:
	cmp	cx,ax
	je	TB_ERROR_CHECK2
;M002	mov	cx,4
;M002	jmp	TB_CPN_INVALID
	jmp	TB_ERROR4

TB_ERROR_CHECK2:
	mov	ax,FB.KT_SPECIAL_FEATURES	; Save the special features in the
	mov	es:[bp].SPECIAL_FEATURES,ax	;	SHARED_DATA_AREA


	mov	es:[bp].HOT_KEY_ON_SCAN,F1_SCAN
	mov	es:[bp].HOT_KEY_OFF_SCAN,F2_SCAN

HOT_KEY_SET:
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	or	cx,cx
	jnz	TB_STATE_CONTINUE4

	dec	cx			; cx = -1
	mov	es:[bp].LOGIC_PTR,cx
	jmp	short SB_COMM_BEGIN

TB_STATE_CONTINUE4:
	mov	es:[di],cx		; Store length parameter in
	add	di,2			;	  SHARED_DATA_AREA
	mov	cx,FB.KT_SPECIAL_FEATURES ; Save the special features
	mov	es:[di],cx
	add	di,2
	mov	cx,FB.KT_LOGIC_LEN	; Set length of section to read
	sub	cx,4			; Adjust for what we have already read
	mov	dx,di			; Set the address of SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH			; Read logic section from the
	int	21H			;	Keyb Def file
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE5
	jmp	TB_ERROR4

TB_STATE_CONTINUE5:
	cmp	cx,ax
	je	TB_ERROR_CHECK3
;M002	mov	cx,4
;M002	jmp	TB_CPN_INVALID
	jmp	TB_ERROR4

TB_ERROR_CHECK3:
	add	di,cx			; Set di at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
	mov	cx,RESIDENT_END_ACC	;	di --->
	add	cx,SA_HEADER_SIZE
	add	cx,MAX_LOGIC_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh Resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	** FOR COMMON TRANSLATE SECTION FOR LANG **
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SB_COMM_BEGIN:
	mov	cx,SIZE KEYBSYS_XLAT_SECT-1 ; Set number bytes to read header
	mov	dx,di			; Set the SHARED_DATA_AREA address
	push	es
	pop	ds
	mov	ah,3FH			; Read from the Keyb Def file
	int	21H
	push	cs
	pop	ds
	jnc	TB_STATE_CONTINUE6
	jmp	TB_ERROR4

TB_STATE_CONTINUE6:
	mov	cx,es:[di].KX_SECTION_LEN; Set length of section to read
	jcxz	TB_CP_BEGIN

	mov	cx,word ptr SB_STATE_OFFSET	;  Save the offset of the
	add	cx,FB.KT_LOGIC_LEN
	mov	word ptr SB_STATE_OFFSET,cx	;  Save the offset of the
	sub	di,SD_AREA_DIFFERENCE		;   Adjust for relocation
	mov	es:[bp].COMMON_XLAT_PTR,di
	add	di,SD_AREA_DIFFERENCE		;   Adjust for relocation

	call	STATE_BUILD
					; di set at new beginning of area
					;		TABLE_AREA
					;		STATE_LOGIC
					;		COMMON_XLAT_SECTION
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_COM_SIZE
	mov	RESIDENT_END_ACC,cx	;  Refresh resident end size

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	FOR alL DESIGNATED OR INVOKED CODE PAGES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_CP_BEGIN:						; Get the offset to
	mov	cx,OFFSET DESIG_CP_BUFFER.DESIG_CP_ENTRY ; the beginning of the
	mov	DESIG_CP_OFFSET,cx			; table of designated
							; code pages
TB_CPN_BEGIN:
	mov	ax,word ptr es:[bp].ACTIVE_LANGUAGE  ; Get the active language
	mov	cx,NUM_DESIG_CP		; Get the number of CPs
	or	cx,cx			; IF we have done all requested CPs
	jnz	TB_CPN_VALID1
	jmp	TB_DONE			;	Then done

TB_CPN_VALID1:
	mov	si,[DESIG_CP_OFFSET]
	mov	bx,[si]			; Get the CP
	cmp	bx,-1
	jnz	TB_CPN_CONTINUE1
	jmp	short TB_CPN_REPEAT

TB_CPN_CONTINUE1:			; ELSE
	push	di
	call	FIND_CP_TABLE		;	Find offset of code page table
	pop	di

	jcxz	TB_CPN_VALID		;  brif valid code page for language
	mov	CPN_INVALID,cx		;	Set flag and go to next CP
	jmp	short TB_CPN_REPEAT	; Else

TB_CPN_VALID:
	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	cx,word ptr CP_TAB_OFFSET+2  ; Get offset of the code page
	mov	dx,word ptr CP_TAB_OFFSET ;	in the Keyb Def file

	cmp	dx,-1			; Test if code page is blank
	jnz	TB_CPN_CONTINUE2
	jmp	short TB_CPN_REPEAT	; If it is then go get next CP

TB_CPN_CONTINUE2:
	mov	ax,4200h		; LSEEK to table in Keyb Def file
	int	21H			;	Keyb Def file Then
	jnc	TB_CPN_CONTINUE3
	jmp	TB_ERROR4

TB_CPN_CONTINUE3:
	mov	dx,ax
	mov	word ptr SB_STATE_OFFSET+2,cx	;  Save the offset of the
	mov	word ptr SB_STATE_OFFSET,dx	;	states in Keyb Def file

	mov	cx,TB_CODE_PAGE_PARM	;  If this code page is the
	mov	si,[DESIG_CP_OFFSET]	;	invoked code page
	cmp	cx,[si]
	jnz	TB_CPN_CONTINUE4	;  Then

	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].ACTIVE_XLAT_PTR,di ;  Set active xlat section
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE4:
	sub	di,SD_AREA_DIFFERENCE	;  Adjust for relocation
	mov	es:[bp].FIRST_XLAT_PTR,di ;	  Set flag
	add	di,SD_AREA_DIFFERENCE	;  Adjust for relocation

TB_CPN_CONTINUE5:
	CALL	STATE_BUILD		;  Build state
					;		TABLE_AREA
	jcxz	TB_CPN_REPEAT		;    COMMON_XLAT_SECTION,SPECIFIC...
	jmp	short TB_ERROR4	;M006	;	di --->
;M006	jmp	TB_ERROR4		;	di --->

TB_CPN_REPEAT:
	mov	cx,RESIDENT_END_ACC
	add	cx,MAX_SPEC_SIZE	;  Refresh resident end size
	mov	RESIDENT_END_ACC,cx

	mov	cx,DESIG_CP_OFFSET
	add	cx,2			; Adjust offset to find next code page
	mov	DESIG_CP_OFFSET,cx

	mov	cx,NUM_DESIG_CP		; Adjust the number of code pages left
	dec	cx
	mov	NUM_DESIG_CP,cx

	jmp	TB_CPN_BEGIN
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TB_DONE:
	mov	cx,RESIDENT_END_ACC	;  Set final calculated value
	add	cx,bp
	sub	cx,SD_AREA_DIFFERENCE		;  Adjust for relocation
	mov	es,word ptr SHARED_AREA_PTR	;	Set segment
	mov	bp,word ptr SHARED_AREA_PTR+2
	cmp	cx,es:[bp].RESIDENT_END
	JNA	TB_DONE_CONTINUE1
	jmp	short TB_ERROR5

TB_DONE_CONTINUE1:
	cmp	es:[bp].RESIDENT_END,-1
	jnz	DONT_REPLACE
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR
	mov	es:[bp].RESIDENT_END,cx ;  Save resident end
	jmp	short CONTINUE_2_END

DONT_REPLACE:
	push	cs
	pop	es
	mov	bp,OFFSET SD_SOURCE_PTR

CONTINUE_2_END:
	sub	cx,OFFSET SD_DesT_PTR	;  Calculate # of bytes to copy
	mov	SD_LENGTH,cx

	xor	cx,cx			;  Set valid completion return code
	mov	TB_RETURN_CODE,cx
	ret

;	M002 -- dead code deleted.  The following label was only
;		branched to with cx==4.  Those calls were all
;		replaced with direct JMPs to TB_ERROR4, which was
;		assumed to set cx=4 in other places anyway.

;M002	TB_CPN_INVALID:
;M002		cmp	cx,1			;  Set error 1 return code
;M002		jnz	TB_ERROR2
;M002		mov	TB_RETURN_CODE,cx
;M002		ret
;M002	
;M002	TB_ERROR2:
;M002		cmp	cx,2			;  Set error 2 return code
;M002		jnz	TB_ERROR3
;M002		mov	TB_RETURN_CODE,cx
;M002		ret
;M002	
;M002	TB_ERROR3:
;M002		cmp	cx,3			;  Set error 3 return code
;M002		jnz	TB_ERROR4
;M002		mov	TB_RETURN_CODE,cx
;M002		ret
;M002	

TB_ERROR4:
;M002	cmp	cx,4			;  Set error 4 return code
;M002	jnz	TB_ERROR5
	mov	cx,4		; M002	; set error 4 return code
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR5:
	mov	cx,5			;  Set error 5 return code
	mov	TB_RETURN_CODE,cx
	ret

TB_ERROR6:
	mov	bx,TB_CODE_PAGE_PARM
	mov	cx,6
	mov	TB_RETURN_CODE,cx	;  Set error 6 return code
	ret

TABLE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: STATE_BUILD
;
; Description:
;	Create the state/xlat section within the specific translate section.
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	SB_STATE_OFFSET - offset to the beginning of the info in Keyb Def SYS
;	di - offset of the beginning of the area used to build states
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	di  - offset of the end of the area used by STATE_BUILD
;
;	cx - Return Code := 0  -  State build successful
;			    4  -  State build unsuccessful
;				    (Bad or missing Keyboard Def file)
;
; Logic:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

END_OF_AREA_PTR	DW	0
SB_FIRST_STATE	DW	0
SB_STATE_LENGTH	DW	0
SB_STATE_OFFSET	DD	0
STATE_LENGTH	DW	0
RESTORE_BP	DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

STATE_BUILD	  PROC NEAR

	mov	si,di			;  Get the tally pointer
	mov	END_OF_AREA_PTR,di	;  Save pointer

	mov	RESTORE_bp,bp		;  Save the base pointer

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr SB_STATE_OFFSET	; LSEEK file pointer
	mov	cx,word ptr SB_STATE_OFFSET+2	;	back to top of XLAT table
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyboard Def file THEN
	jnc	SB_FIRST_HEADER
	jmp	SB_ERROR4

SB_FIRST_HEADER:
	xor	bp,bp
	LEA	cx,[bp].KX_FIRST_STATE	; Set number of bytes to read header
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; read in the header
	int	21H
	push	cs
	pop	ds
	jnc	SB_HEAD_CONTINUE1
	jmp	SB_ERROR4

SB_HEAD_CONTINUE1:
	mov	dx,NEXT_SECT_PTR
	cmp	dx,-1
	je	SB_HEAD_CONTINUE2
	sub	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE2:
	mov	es:[di].XS_NEXT_SECT_PTR,dx
	cmp	dx,-1
	je	SB_HEAD_CONTINUE3
	add	dx,SD_AREA_DIFFERENCE	;  Adjust for relocation

SB_HEAD_CONTINUE3:
	add	di,cx			; Update the di pointer

SB_NEXT_STATE:
	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_STATE_ID	;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1:
	push	cs			; Reset the data segment
	pop	ds
	mov	cx,es:[di].KX_STATE_LEN ; If the length of the state section
	mov	STATE_LENGTH,cx
	add	di,2			;  is zero then done
	jcxz	SB_DONE

	xor	bp,bp			;  Set number
	LEA	cx,[bp].KX_FIRST_XLAT-2 ;	bytes to read state length
	mov	dx,di			;  Read the header into the
	mov	bx,KEYBSYS_FILE_HANDLE	;	SHARED_DATA_AREA
	push	es
	pop	ds
	mov	ah,3FH
	int	21H

SB_CONTINUE1A:
	push	cs			; Reset the data segment
	pop	ds
	sub	di,2
	mov	ax,es:[di].XS_KBD_TYPE	; Get the keyboard type def
	test	ax,HW_TYPE		; Does it match our hardware?
	JNZ	SB_CONTINUE2
	mov	dx,es:[di].XS_STATE_LEN ; No, then
	LEA	cx,[bp].KX_FIRST_XLAT
	sub	dx,cx
	xor	cx,cx
	mov	ah,42H			;  LSEEK past this state
	mov	al,01H
	int	21H
	jmp	SB_NEXT_STATE

SB_CONTINUE2:				; Yes, then
	mov	ax,SIZE STATE_STR-1
	add	di,ax			; Set PTR and end of header

SB_XLAT_TAB_BEGIN:			; Begin getting xlat tables
	mov	bx,KEYBSYS_FILE_HANDLE
	LEA	dx,[bp].KX_FIRST_XLAT	; Adjust for what we have already read
	mov	cx,STATE_LENGTH
	sub	cx,dx
	mov	dx,di
	push	es
	pop	ds
	mov	ah,3FH			; Read in the xlat tables
	int	21H
	push	cs
	pop	ds
	jnc	SB_CONTINUE4
	jmp	short SB_ERROR4

SB_CONTINUE4:
	cmp	cx,ax
	je	SB_ERROR_CHECK1
	jmp	short SB_ERROR4

SB_ERROR_CHECK1:
	add	di,cx			; Update the end of area ptr

	mov	si,di
	jmp	SB_NEXT_STATE

SB_DONE:
	mov	ax,-1
	mov	si,END_OF_AREA_PTR
	mov	NEXT_SECT_PTR,si

	mov	bp,RESTORE_bp
	ret

SB_ERROR1:
	mov	cx,1
	ret

SB_ERROR2:
	mov	cx,2
	ret

SB_ERROR3:
	mov	cx,3
	ret

SB_ERROR4:
	mov	cx,4
	ret


STATE_BUILD	  ENDP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Module: FIND_CP_TABLE
;
; Description:
;	Determine the offset of the specified code page table in KEYBOARD.SYS
;
; Input Registers:
;	ds - points to our data segment
;	es - points to our data segment
;	ax - ASCII representation of the language parm
;	bx - binary representation of the code page
;
;	KEYBSYS_FILE_HANDLE - handle of the KEYBOARD.SYS file
;
; Output Registers:
;	CP_TAB_OFFSET - offset of the CP table in KEYBOARD.SYS
;
;	cx - Return Code := 0  -  State build successful
;			    2  -  Invalid Code page for language
;			    4  -  Bad or missing Keyboard Def file
; Logic:
;
;	READ language table
;	IF error in reading file THEN
;	 Display ERROR message and EXIT
;	ELSE
;	 Use table to verify language parm
;	 Set pointer values
;	 IF code page was specified
;		READ language entry
;		IF error in reading file THEN
;		  Display ERROR message and EXIT
;		ELSE
;		  READ Code page table
;		  IF error in reading file THEN
;			Display ERROR message and EXIT
;		  ELSE
;			Use table to get the offset of the code page parm
;	ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_PARM	  DW	?

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Program Code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FIND_CP_TABLE	  PROC  NEAR


	mov	FIND_CP_PARM,bx	  ; Save Code page

	mov	bx,KEYBSYS_FILE_HANDLE	; Get handle
	mov	dx,word ptr KEYBCMD_LANG_ENTRY_PTR ; LSEEK file pointer
	mov	cx,word ptr KEYBCMD_LANG_ENTRY_PTR+2 ;  to top of language entry
	mov	ax,4200h		; If no problem with
	int	21H			;   Keyb Def file Then
	jnc	FIND_BEGIN
	jmp	short FIND_CP_ERROR4

FIND_BEGIN:
	mov	di,ax
	mov	cx,SIZE KEYBSYS_LANG_ENTRY-1	; Set number
						;	bytes to read header
	mov	dx,OFFSET FILE_BUFFER
	mov	ah,3FH			; Read language entry in
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID4		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID4:

;****************************** CNS ****************************************
	xor	ah,ah
	mov	al,FB.KL_NUM_CP
;****************************** CNS ****************************************

	mov	NUM_CP,ax		; Save the number of code pages
	MUL	CP_PTR_SIZE		; Determine # of bytes to read
	mov	dx,OFFSET FILE_BUFFER	; Establish beginning of buffer
	mov	cx,ax
	cmp	cx,FILE_BUFFER_SIZE	; Make sure buffer is not to small
	jbe	FIND_VALID5
	jmp	short FIND_CP_ERROR4

FIND_VALID5:
	mov	ah,3FH			; Read code page table from
	int	21H			;	KEYBOARD.SYS file
	jnc	FIND_VALID6		; If no error in opening file then
	jmp	short FIND_CP_ERROR4

FIND_VALID6:
	mov	cx,NUM_CP		;  Number of valid codes
	mov	di,OFFSET FILE_BUFFER	;  Point to correct word in table

F_SCAN_CP_TABLE:			; FOR code page parm
	mov	ax,FIND_CP_PARM		;	Get parameter
	cmp	[di].KC_CODE_PAGE,ax	;	Valid Code ??
	je	F_CODE_PAGE_FOUND	; If not found AND more entries THEN
	add	di,LANG_PTR_SIZE	;	Check next entry
	loop	F_SCAN_CP_TABLE		;    Decrement count & loop


	jmp	short FIND_CP_ERROR2	;  Display error message

F_CODE_PAGE_FOUND:
	mov	ax,word ptr [di].KC_ENTRY_PTR
	mov	word ptr CP_TAB_OFFSET,ax
	mov	ax,word ptr [di].KC_ENTRY_PTR+2
	mov	word ptr CP_TAB_OFFSET+2,ax

	xor	cx,cx
	ret

FIND_CP_ERROR1:
	mov	cx,1
	ret

FIND_CP_ERROR2:
	mov	cx,2
	ret

FIND_CP_ERROR3:
	mov	cx,3
	ret

FIND_CP_ERROR4:
	mov	cx,4
	ret

FIND_CP_TABLE	 ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE	ENDS
	END	TABLE_BUILD

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\loadfix\loadfix.asm ===
FindStruc	struc

	db	21 dup (?)		;reserved area
Attr	db	?			;attribute of file
Time	dw	?			;time of last write
Date	dw	?			;date of last write
Fsize	dd	?			;filesize
Fname	db	13 dup (?)		;filename

FindStruc	ends

CMDSIZE		equ	94h		;current resident size of
					;command.com is 94h paras

code	segment byte public 'CODE'
	assume	cs:code, ds:code, es:code

	org	100h
public	start
start:
	mov	sp,offset MyStack		;set ss:sp to our stack

	mov	ax,offset EndProg
	add	ax,15
	mov	cl,4
	shr	ax,cl			;para size of this program
	mov	bx,ax			;bx = this program's size
	mov	cx,es
	add	ax,cx			;ax = top of this program
	sub	ax,1000h - CMDSIZE		;are we below the first 64K?
	jae	no_mem			;no, dont reserve memory
	neg	ax			;additional memory to be reserved
	add	bx,ax
no_mem:					;bx = #paras needed
	mov	ah,4ah
	int	21h			;resize to desired size
;
;Prepare to execute the desired program
;
	call	Exec_prepare
	jnc	do_exec

	mov	al,1	   		;return error
	jmp	short exit
do_exec:
	cmp	helpflg,1
	je 	do_help
	mov	ah,4bh
	mov	dx,offset ExecPath
	mov	bx,offset ExecBlk
	int	21h			;do the Exec
	jc	exec_err		;error while executing
;
;No error on execution. Get the return code of the program we executed and
;return that as our return code.
;
	mov	ah,4dh
	int	21h			;al = return code now
exit:
	mov	ah,4ch
	int	21h			;terminate ourselves
exec_err:
	mov	dx,offset ErrMsg		;Error executing command.com
	mov	al,1
	call	dispmsg
	jmp	short	exit
do_help:
	mov	dx,offset HelpMsg		;Display help for loadfix
	call	dispmsg
	xor	al,al
	jmp	short exit

;***
;Dispmsg -- Displays messages that are terminated by '$'
;
;Input:	ds:dx = pointer to message
;
;Output: None
;
;Registers: ax
;***

dispmsg	proc	near

	mov	ah,9
	int	21h
	ret

dispmsg	endp

;***
;Exec_prepare -- Searches the environment for the COMSPEC and sets up the
;command line and FCBs for the Exec call
;
;Input:	None
;
;Output: Carry set => error. Error message is displayed here
;	Carry clear => all parameters set successfully
;
;Registers: ax, cx, dx, si, di
;***

Exec_prepare	proc	near

	push	ds
	push	es

	mov	si,81h			;ds:si points at our command line
	call	skip_white		;skip all leading whitespace

	cmp	byte ptr [si],0dh		;Did we hit a CR?
	je	no_parms		;yes, no parameters given
;
;Check if we have a /? here
;
	cmp	byte ptr [si],'/'
	jne	no_help
	cmp	byte ptr [si+1],'?'
	jne	no_help

	inc	helpflg   		;/? given -- print help
	jmp	short exefnd

no_help:
	mov	dx,si			;ds:dx now points at the program

	mov	si,offset CmdOpt
	mov	di,offset CmdParms
	inc	di
	mov	cl,CmdOptLen
	xor	ch,ch
	rep	movsb

	mov	si,dx
	xor	cx,cx
st_lp:
	lodsb
	stosb
	inc	cx
	cmp	al,0dh
	jne	st_lp

	dec	cx
	add	cl,CmdOptLen		;command line cannot be >128
	mov	CmdParms,cl

	mov	si,offset CmdParms

	mov	word ptr CmdPtr,si
	mov	word ptr CmdPtr+2,cs		;store command line pointer

	mov	word ptr Fcb1+2,cs
	mov	word ptr Fcb2+2,cs

	call	find_comspec
	jc	no_comspec

	mov	si,offset ExecPath
	xchg 	si,di
	push	ds
	push	es
	pop	ds
	pop	es
comspec_lp:
	lodsb
	stosb
	or	al,al
	jnz	comspec_lp

exefnd:
	clc
execp_ret:
	pop	es
	pop	ds
	ret
no_parms:
	mov	dx,offset NoParms
	call	dispmsg
	stc
	jmp	short execp_ret
no_comspec:
	mov	dx,offset NoComspec
	call	dispmsg
	stc
	jmp	short execp_ret

Exec_prepare	endp

;***
;skip_white -- Skips all whitespace characters until it hits a non-whitespace
;
;Input: ds:si = string to be looked at
;
;Output: ds:si points at the first non-whitespace char in the string
;
;Registers: ax, si
;***

skip_white	proc	near
	
	lodsb
	cmp	al,20h			;Blank?
	je	skip_white		;yes, skip
	cmp	al,9			;Tab?
	je	skip_white		;yes, skip

	dec	si			;point at the first non-white

	ret

skip_white	endp

;***
;find_comspec -- searches in the environment for the COMSPEC variable
;
;Input: None
;
;Output: es:di points at the arguments of the COMSPEC= variable
;
;Registers: si
;***

find_comspec	proc	near

	mov	si,offset Comspec_Text

;
; input: ds:si points to a "=" terminated string
; output: es:di points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format
;
	call	find				; find the name
	jc	done_findp			; carry means not found
	call	scasb1				; scan for = sign
done_findp:
	ret

find_comspec	endp

;***
;find -- scans the environment for the variable whose name is passed in
;
;Input: ds:si points at the environment variable to be scanned for
;
;Output: es:di points at the environment variable
;
;Registers: ax, di
;***

find	proc	near

	cld
	call	count0				; cx = length of name
	mov	es,es:[2ch]			; get environment segment
;
;Bugbug: What if the environment segment here is 0?
;
	xor	di,di

find1:
	push	cx
	push	si
	push	di

find11:
	lodsb
	inc	di
	cmp	al,es:[di-1]
	jnz	find12
	loop	find11

find12:
	pop	di
	pop	si
	pop	cx
	jz	end_find
	push	cx
	call	scasb2				; scan for a nul
	pop	cx
	cmp	byte ptr es:[di],0
	jnz	find1
	stc					; indicate not found
end_find:
	ret

find	endp

;***
;count0 -- returns length of string until the first '=' char
;
;Input: ds:si points at the string
;
;Output: cx = length until '='
;
;Registers: di
;***

count0	proc	near

	mov	di,si				;ds = es = cs

	push	di				; count number of chars until "="
	call	scasb1
	pop	cx
	sub	di,cx
	xchg	di,cx
	ret

count0	endp

;***
;scasb1 -- scans string for the first '='
;scasb2 -- scans string for the first null
;
;Input: es:di = string
;
;Output: es:di points after the desired char
;
;Registers: ax, cx
;***

scasb1	proc	near

	mov	al,'='                          ; scan for an =
	jmp	short scasbx
scasb2:
	xor	al,al				; scan for a nul
scasbx:
	mov	cx,100h
	repnz	scasb
	ret

scasb1	endp

;**************************
;Data
;**************************

ExecBlk	label	word
	dw	0
CmdPtr	dd	?
Fcb1	dw	offset MyFcb1
	dw	?
Fcb2	dw	offset MyFcb2
	dw	?

	dw	128 dup (1)
MyStack	label	word

CmdOpt	db	'/C '
CmdOptLen 	db	$ - CmdOpt

CmdParms	db	128 dup (?)		;buffer to hold prog to be Exec'ed

ExecPath	db	67 dup (?)		;holds path to COMMAND.COM

ComSpec_Text	db	'COMSPEC=',0

MyFcb1	db	0
	db	11 dup (' ')

MyFcb2	db	0
	db	11 dup (' ')

Helpflg	db	0			;default is no help

include	loadmsg.msg

EndProg	label	byte

code	ends
	end	start
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\label\label.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*
 *  This file contains the constants, globals, structure definitions,
 *  and extern declarations for the label utility.
 */

/*
 *  Constant Declarations
 */ 
#define  MAX_LABEL_LENGTH  11
#define  OK  0
#define  EOL  '\0'
#define  EOFCHAR 0x1a
#define  TRUE  1
#define  FALSE 0
#define  DRIVE_BYTE  7
#define  NAME  8
#define  ENDNAME  19
#define	 LEN_UNKNOWN  0
#define  STDOUT	1
#define  STDERR 2

#define SPACEBAR ' '                             /* M002 */
#define CARRIAGE_RETURN '\r'                     /* M002 */
#define DBL_QUOTE '"'                            /* M002 */
#define CMDLINE_OFFSET 0x81                      /* M002 */

/*  DOS version numbers */
#define  MAJOR_VERSION  5                        /* M001 */
#define  MINOR_VERSION  0

/* Definitions for determining if network drive */
#define  BIT_12_MASK  0x1000
#define  IOCTL	0x44
#define  REMOTE 0x9



/*
 *  Typedef Declarations
 */
typedef  int  LoopIndex;
typedef  int  Boolean;
typedef  int  ErrorCode;



/*
 *  Global Variables
 */
#define BAD_CHARS 21                                       /* M002 */
char BadChars[BAD_CHARS] = "*?/\\|.,;:+=<>[]()&^\"";       /* M002 */

char Drive[3] = "?:";
char TempDrive[3] = "?:";
char Label[13] = "";
char OldLabel[13] = "";
char fcb[128] = {0xff, 0, 0, 0, 0, 0, 0x8, 0, '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', '?'};
char con_fcb[44] = {0xff, 0, 0, 0, 0, 0, 0, 0, 'C', 'O', 'N',' ',' ',' ',' ',' ',' ',' ',' '};
char creat_fcb[44] = {0xff, 0, 0, 0, 0, 0, 0x8, 0, ' ', ' ', ' ',' ',' ',' ',' ',' ',' ',' ',' '};
Boolean Nolabel = TRUE;
Boolean firsttime = TRUE;
Boolean DriveNotFirst = FALSE;
char newline[2] = {0xd, 0xa};
#define	NEW_LEN  2

/* buffers for changing directories */
#define PATHLEN 64                               /* M003 */
char curdir[PATHLEN] = {0};                      /* M003 */
char rootdir[4] = "?:\\";                        /* M003 */

/* buffer for mygets */
char getsbuf[MAX_LABEL_LENGTH+3];	/* 2 extra for header */
char input_redir = -1;			/* TRUE if input redirected */



/*
 *  Function Prototypes
 */
int	main(int, char * []);
void	DumbPrint(int,char *,int);
int	CheckOptionsHelp(int, char **);
void	process_commandline(int, char **);
void	GetDrive(void);
void	DisplayLabel(void);
void	GetLabel(void);
char    *gets(char *);
void	puts(char *);
void	DeleteLabel(void);
int	CreateLabel(void);
Boolean LegitDrive(char *);
Boolean IllegitLabelWithDrive(char *);
void    SaveLabel(char *);
Boolean IllegitimateLabel(char *);
void	PrintHex(char);
void	mygets(char *,unsigned);
Boolean CheckCmdLineQuotes(void);                /* M002 */
void	ExitLabel(void);                         /* M003 */
void far _interrupt ctrlc_hdlr(void);            /* M003 */


#ifdef DBCS
unsigned char *DBCSstrupr(unsigned char *str);
int	IsDBCSLeadByte(unsigned char);
int	CheckDBCSTailByte(unsigned char *,unsigned char *);
#endif



/*
 *   Macro Definitions
 */

/***************************************************************************/
/* Routine:  GetCurDir                                                     */
/*                                                                         */
/* Function: Gets the current directory.  It gets the ASCIIZ string that   */
/*           that describes the path from the root to the current          */
/*           directory, and the name of that directory.                    */
/*           The name returned does NOT contain the drive letter or the    */
/*           leading backslash.                                            */
/* M003                                                                    */
/***************************************************************************/

#define GetCurDir(reg, dir)                                                 \
{                                                                           \
  reg.x.ax = 0x4700;                        /* get current directory */     \
  reg.h.dl = 0;                                                             \
  reg.x.si = (unsigned)dir;                                                 \
  intdos(&reg, &reg);                                                       \
}


/***************************************************************************/
/* Routine:  SetCurDir                                                     */
/*                                                                         */
/* Function: Sets the current directory using the specified drive and      */
/*           path.                                                         */
/* M003                                                                    */
/***************************************************************************/

#define SetCurDir(reg, dir)                                                 \
{                                                                           \
  reg.x.ax = 0x3B00;                        /* set current directory */     \
  reg.x.dx = (unsigned)dir;                                                 \
  intdos(&reg, &reg);                                                       \
}


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\chkvdisk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
; Check for existence of a VDisk header.  Check the beginning of the segment
; addressed by the INT 19 vector, and, if XMS is available to give us
; A20 toggling, check at the 1Mb boundary.  We don't do the latter check
; if we can't do the A20 switch.
;
; Return the size of the VDisk if found.
;

; Checking for a VDISK header at 1Mb is currently disabled.  This is because
; the XMS calls used to access the HMA will cause INT 15 memory to
; be claimed if there are currently no Himem or XMS users, and the MEM
; command shouldn't disturb the memory environment in that way.
; We rely on VDisk allocators to use the INT 19 approach to signal
; their memory usage.  According to Ray Duncan, this may not be
; entirely reliable, but this is probably better than adding the
; code necessary to do lots of INT 15 block moves to interrogate
; the extended memory arena.

CHECKXMS	equ	0		; set to non-zero to enable checking
					; of the HMA for VDisk headers.

.MODEL	SMALL
.CODE

	extrn	_XMM_Installed	:Near
	extrn	_XMM_QueryA20	:Near
	extrn	_XMM_EnableA20	:Near
	extrn	_XMM_DisableA20 :Near

;----------------------------------------------------------------------------
;
; following piece of code will be moved into a para boundary. And the para
; address posted in seg of int 19h vector. Offset of int 19h will point to
; VDint19. This is to protect HMA from apps which use VDISK header method
; to determine free extended memory.
;
; For more details read "power programming" column by Ray Duncan in the
; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
;
;----------------------------------------------------------------------------
;
StartVDHead	label	byte
;
;-------------- what follows is a dummy device driver header (not used by DOS)
;
		dd	0		; link to next device driver
		dw	8000h		; device attribute
		dw	0		; strategy routine offset
		dw	0		; interrupt routine offset
		db	1		; number of units
		db	7 dup(0)	; reserved area
VDiskSig1	db	'VDISK'

VLEN1		equ	($-offset VDiskSig1)

		db	'  V3.3'	; vdisk label
		db	15 dup (0)	; pad
VDiskEnd1	dw	0		; bits 0-15 of free HMA
		db	11h		; bits 16-23 of free HMA (1M + 64K)

VDInt19:
		db	0eah		; jmp to old vector
OldVDInt19	dd	?		; Saved int 19 vector

EndVDHead	label	byte
;
;
VDiskHMAHead	db	0,0,0		; non-bootable disk
VDiskSig2	db	'VDISK'

VLEN2		equ	($-offset VDiskSig2)

		db	'3.3'		; OEM - signature
		dw	128		; number of bytes/sector
		db	1		; sectors/cluster
		dw	1		; reserved sectors
		db	1		; number of FAT copies
		dw	64		; number of root dir entries
		dw	512		; number of sectors
		db	0feh		; media descriptor
		dw	6		; number of sectors/FAT
		dw	8		; sectors per track
		dw	1		; number of heads
		dw	0		; number of hodden sectors
VDiskEnd2	dw	440h		; Start of free HMA in K (1M+64K)
EndVDiskHMAHead	label	byte
;
;
;----------------------------------------------------------------------------
;
; procedure : IsVDiskInstalled
;
;		Checks for the presence of VDISK header at 1MB boundary
;		& INT 19 vector.  Returns number of Kb used as Vdisk
;
; Inputs  : none
; Outputs : AX = size of VDisk in Kb, 0 if none found
; Uses	  : AX, CX
;
;----------------------------------------------------------------------------
;
		public _CheckVDisk

_CheckVDisk	proc   near
		push	bp
		push	si		; Save regs
		push	di
		push	es
		push	ds

		mov	ax,3519h	; Get Int Vector 19h
		int	21h
					; set registers for CMPS
		mov	di, offset VDiskSig1 - offset StartVDHead
		mov	cx, VLEN1
		push	cs
		pop	ds
		mov	si, offset VDiskSig1
		rep	cmpsb
IF NOT CHECKXMS
		jnz	cvd_NoDisk
ELSE
		jnz	cvd_checkXMS	; jump if we didn't find it
ENDIF

;
; Get the first free address in Kb, and determine the number of Kb used
; above 1Mb.  First free address in a 24-bit address, so divide by 1024
; to get number of Kb
;
		mov	di,offset VDiskEnd1 - offset StartVDHead
		mov	ax,es:[di]+1	; load top 16 bits of end address
		shr	ax,1
		shr	ax,1		; fast divide of 24 bits by 1024
		test	es:[di],03FFh	; check for rounding
		jz	@F
		inc	ax		; round up if needed
@@:
IF NOT CHECKXMS
		jmp	short cvd_End

ELSE
		pop	ds		; clear top of stack
		jmp	short cvd_End	; AX now has size in Kb


;
; Ensure that A20 is on before we check above 1Mb.  If XMS is not
; installed, we punt, and assume no VDisk
;

cvd_checkXMS:
		pop	ds		; get DS again
		call	_XMM_Installed
		or	ax,ax
		jz	cvd_NoDisk	; No XMS, assume no VDisk

;
; Get and save current A20 state, get A20 on
;
		call	_XMM_QueryA20
		push	ax		; save current state
		or	ax,ax		; already on?
		jnz	cvd_A20On	; yes, don't turn it on
		call	_XMM_EnableA20	; turn it on

cvd_A20On:
		push	ds		; save DS again
		mov	ax, 0ffffh
		mov	ds, ax
		mov	si, 10h+(offset VDiskSig2 - offset VDiskHMAHead)
		mov	ax,cs
		mov	es,ax
		mov	di, offset VDiskSig2
		mov	cx, VLEN2
		rep	cmpsb
		jne	@F		; if no header, turn off A20 now
					; get first free address in Kb
		mov	si,offset VDiskEnd2 - offset VDiskHMAHead
		mov	ax,[si]
@@:
		pop	ds		; get original DS again
		pop	ax		; get original A20 state
		pushf			; save result of header check
		or	ax,ax		; was A20 already on?
		jnz	@F		; jump if yes
		call	_XMM_DisableA20 ; else turn it off again

@@:
		popf			; get result of header check
		je	cvd_End 	; jump if present

ENDIF		; CHECKXMS

cvd_NoDisk:
		mov	ax,1024 	; set up to return 0

cvd_End:
		sub	ax,1024 	; discount first 1Mb from first
					; free address to get size in Kb
IF NOT CHECKXMS
		pop	ds
ENDIF
		pop	es
		pop	di
		pop	si
		pop	bp
		ret
_CheckVDisk endp

		end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\keyb\keyb2\parser.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1987 - 1991
; *                      All Rights Reserved.
; */
PAGE	,132
TITLE	PARSE CODE AND CONTROL BLOCKS FOR KEYB.COM

;****************** START OF SPECIFICATIONS **************************
;
;  MODULE NAME: PARSER.ASM
;
;  DESCRIPTIVE NAME: PARSES THE COMMAND LINE PARAMETERS FOR KEYB.COM
;
;  FUNCTION: THE COMMAND LINE IN THE PSP IS PARSED FOR PARAMETERS.
;
;  ENTRY POINT: PARSE_PARAMETERS
;
;  INPUT: BP POINTS TO PARAMETER LIST
;	  DS & ES POINT TO PSP
;
;  AT EXIT:
;     PARAMETER LIST FILLED IN AS REQUIRED.
;
;  INTERNAL REFERENCES:
;
;     ROUTINES: SYSPARSE - PARSING CODE
;
;     DATA AREAS: PARMS - PARSE CONTROL BLOCK FOR SYSPARSE
;
;  EXTERNAL REFERENCES:
;
;     ROUTINES: N/A
;
;     DATA AREAS: PARAMETER LIST BLOCK TO BE FILLED.
;
;  NOTES:
;
;  REVISION HISTORY:
;	 A000 - DOS Version 3.40
;  3/24/88 AN003 - P3906 PARSER changes to return "bogus" parameter on the
;	       "Parameter value not allowed " message - CNS
;  5/12/88 AN004 - P4867 /ID:NON-Numeric hangs the sytem as a 1st positional
;
;
;                                                  
; MS-DOS 5.00 - NLS Support - KEYB Command
;
;
;****************** END OF SPECIFICATIONS ****************************

INCLUDE KEYBDCL.INC

ID_VALID	EQU	0
ID_INVALID	EQU	1
NO_ID		EQU	2

LANGUAGE_VALID	EQU	0
LANGUAGE_INVALID EQU	1
NO_LANGUAGE	EQU	2

NO_IDLANG	EQU	3

CODE_PAGE_VALID EQU	0
CODE_PAGE_INVALID EQU	1
NO_CODE_PAGE	EQU	2
VALID_SYNTAX	EQU	0
INVALID_SYNTAX	EQU	1

COMMAND_LINE_START EQU	81H
RC_EOL		EQU	-1
RC_NO_ERROR	EQU	0
RC_OP_MISSING	EQU	2
RC_NOT_IN_SW	EQU	3

;***CNS P4867 1st CHECK for /ID:ALPHA

RC_SW_FIRST	EQU	9

;***CNS P4867 1st CHECK for /ID:ALPHA

ERROR_COND	EQU	-1
NUMBER		EQU	1
STRING		EQU	3
FILE_SPEC	EQU	5
MAX_ID		EQU	999
LANG_LENGTH	EQU	2

INVALID_SWITCH	EQU	3
TOO_MANY	EQU	1
INVALID_PARAM	EQU	10
VALUE_DISALLOW	EQU	8


	PUBLIC	PARSE_PARAMETERS ; near procedure for parsing command line
	PUBLIC	CUR_PTR 	; near procedure for parsing command line
	PUBLIC	OLD_PTR 	; near procedure for parsing command line
	PUBLIC	ERR_PART	; near procedure for parsing command line

	EXTRN	BAD_ID:BYTE	; WGR to match old code
	EXTRN	FOURTH_PARM:BYTE ; WGR to match old code
	EXTRN	ONE_PARMID:BYTE	; WGR to match old code
	EXTRN	FTH_PARMID:BYTE	; WGR to match old code
	EXTRN	ALPHA:BYTE	; WGR to match old code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Set assemble switches for parse code that is not required!!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DateSW		EQU	0
TimeSW		EQU	0
CmpxSW		EQU	0
DrvSW		EQU	0
QusSW		EQU	0
KeySW		EQU	0
Val1SW		EQU	0
Val2SW		EQU	0
Val3SW		EQU	0


CODE	SEGMENT PUBLIC 'CODE' BYTE
	ASSUME	CS:CODE,DS:CODE

	.XLIST
	INCLUDE	PARSE.ASM	; Parsing code
	.LIST


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; PARM control blocks for KEYB
; Parsing command line as follows:
;
; KEYB [lang],[cp],[[d:][path]KEYBOARD.SYS][/ID:id][/e][/?]
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARMS	LABEL	WORD
	DW	PARMSX
	DB	0		; no extra delimeters or EOLs.

PARMSX	LABEL	BYTE
	DB	0,3		; min,max positional operands
	DW	LANG		; pointer to control block
	DW	CP		; pointer to control block
	DW	FILE_NAME	; pointer to control block
	DB	3		; 3 switches
	DW	ID_VALUE	; pointer to control block
	dw	help_value	; pointer to control block
	dw	ext_value	; pointer to control block
	DB	0		; no keywords

LANG	LABEL	WORD
	DW	0A001H		; sstring or numeric value (optional)
	DW	0002H		; cap result by char table (sstring)
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

CP	LABEL	WORD
	DW	8001H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

FILE_NAME LABEL WORD
	DW	0201H		; file spec
	DW	0001H		; cap by file table
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	0		; no keyword/switch synonyms

ID_VALUE LABEL	WORD
	DW	8010H		; numeric
	DW	0		; no functions
	DW	RESULT_BUF	; result
	DW	NOVALS		; no value checking done
	DB	1		; 1 switch synonym
id_name:
	DB	"/ID",0 	; ID switch

help_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	RESULT_BUF	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
help_name:
	db	"/?",0		; /? switch

ext_value label	word
	dw	0		; no values
	dw	0		; no functions
	dw	result_buf	; result
	dw	novals		; no value checking done
	db	1		; 1 switch synonym
ext_name:
	db	"/E",0		; /e switch


NOVALS	LABEL	BYTE
	DB	0		; no value checking done

RESULT_BUF	LABEL BYTE
RESULT_TYPE	DB	0	; type returned (number, string, etc.)
		DB	?	; matched item tag (if applicable)
RESULT_SYN_PTR	DW	?	; synonym ptr (if applicable)
RESULT_VAL	DD	?	; value

LOOP_COUNT	DB	0	; keeps track of parameter position

;***CNS
CUR_PTR        DW	0	; keeps track of parameter position
OLD_PTR        DW	0	; keeps track of parameter position
ERR_PART       DW	0	; keeps track of parameter position
;***CNS
				;..and reports an error condition

	public	pswitches
pswitches	db	0	; bit 0, /?, bit 1 /e

TEMP_FILE_NAME DB	128 DUP(0) ; place for file name

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PARSE_PARAMETERS
;
; FUNCTION:
; THIS PROCEDURE PARSES THE COMMAND LINE PARAMETERS IN THE PSP FOR
; KEYB.COM. THE PARAMETER LIST BLOCK IS FILLED IN ACCORDINGLY.
;
; AT ENTRY: AS ABOVE.
;
; AT EXIT:
;    AS ABOVE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PARSE_PARAMETERS       PROC	NEAR

	XOR	AX,AX				; setup default parameters.
	MOV	[BP].RET_CODE_1,NO_IDLANG
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE
	MOV	[BP].RET_CODE_3,VALID_SYNTAX
	MOV	[BP].RET_CODE_4,NO_ID
	MOV	[BP].PATH_LENGTH,AX
	LEA	DI,PARMS			; setup parse blocks
	MOV	SI,COMMAND_LINE_START

	call	save_curptr

	XOR	CX,CX
	XOR	DX,DX
	CALL	SYSPARSE

kbs_10:
	cmp	ax,RC_EOL		; while not end of line and...
	jnz	kbs_11
	jmp	kbs_12
kbs_11:
	cmp	LOOP_COUNT,ERROR_COND	; parameters valid, do...
	jnz	kbs_13
	jmp	kbs_12

kbs_13:
	cmp	ax,RC_NOT_IN_SW		; invalid switch?
	jz	kbs_08
	cmp	ax,RC_SW_FIRST
	jnz	kbs_09

kbs_08:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; set invalid syntax flag.
	MOV	LOOP_COUNT,ERROR_COND		; set error flag to exit parse.

;***CNS
	MOV	ERR_PART,INVALID_SWITCH
	call	save_curptr
;***CNS

	jmp	kbs_10

kbs_09:

	cmp	RESULT_SYN_PTR,offset id_name	; was /id:xxx switch found?
	jnz	not_id_switch


	MOV	AX,WORD PTR RESULT_VAL+2 ; is it valid?
	OR	AX,AX
	jnz	kbs_01

	mov	ax,word ptr RESULT_VAL
	cmp	ax,MAX_ID
	jna	kbs_02

kbs_01:

	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	MOV	[ERR_PART],VALUE_DISALLOW	; SET ERROR TYPE FOR DISPLAY
	call	save_curptr

	jmp	short kbs_03

kbs_02:
	MOV	[BP].RET_CODE_4,ID_VALID ; yes...set return code 4.
	MOV	[BP].ID_PARM,AX
	mov	fourth_parm,1
	mov	fth_parmid,1

	jmp	short kbs_03


not_id_switch:
	cmp	RESULT_SYN_PTR,offset help_name	; was /? switch found?
	jnz	not_help_switch

	or	pswitches,1			; set flag for /?
	jmp	short kbs_03

not_help_switch:
	cmp	RESULT_SYN_PTR,offset ext_name
	jnz	kbs_07

	or	pswitches,2			; set flag for /e
	jmp	short kbs_03


kbs_07:
	INC	LOOP_COUNT		; positional encountered...
	cmp	LOOP_COUNT,1		; check for language
	jnz	kbs_04

	CALL	PROCESS_1ST_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_04:
	cmp	LOOP_COUNT,2		; check for code page
	jnz	kbs_05

	CALL	 PROCESS_2ND_PARM

	call	save_curptr

	jmp	short kbs_03

kbs_05:
	cmp	LOOP_COUNT,3		; check for file name
	jnz	kbs_06

	CALL	PROCESS_3RD_PARM

	call	save_curptr

	jmp	short kbs_03

;	all other cases

kbs_06:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; too many parms

	call	save_curptr

	MOV	ERR_PART,TOO_MANY
	MOV	LOOP_COUNT,ERROR_COND	; set error flag to exit parse.
kbs_03:
	MOV	RESULT_TYPE,0		; reset result block.
	CALL	SYSPARSE		; parse next parameter.

	jmp	kbs_10

kbs_12:
	cmp	[bp].RET_CODE_4,ID_VALID
	jnz	kbs_14				; ensure that if switch was
	cmp	[bp].RET_CODE_1,LANGUAGE_VALID	; used, it was valid keyword
	jz	kbs_14

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; code was used..

;***CNS
	call	save_curptr
	MOV	ERR_PART,VALUE_DISALLOW
;***CNS

kbs_14:
	RET

PARSE_PARAMETERS       ENDP

save_curptr	proc	near

	PUSH	AX			;Save environment
	MOV	AX,CUR_PTR		;Set advancing ptr to end of argument
	MOV	OLD_PTR,AX		;after saving the beginning the string
	MOV	CUR_PTR,SI
	POP	AX			;Restore the environment
	ret

save_curptr	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_1ST_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE FIRST POSITIONAL PARAMETER. THIS SHOULD
; BE THE LANGUAGE ID OR THE KEYBOARD ID.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR LANGUAGE ID.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_1ST_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; error on parse?
	jng	kbs_23

	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; yes...set invalid language
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	 ; and syntax error..
	MOV	LOOP_COUNT,ERROR_COND		 ; set flag to exit parse.
	MOV	ERR_PART,AX

	jmp	kbs_18

kbs_23:
	cmp	RESULT_TYPE,NUMBER	; was this a number (id?)
	jnz	kbs_24

	MOV	AX,WORD PTR RESULT_VAL+2 ; yes...check to see if
	OR	AX,AX			; within range.
	jnz	kbs_19

	MOV	AX,WORD PTR RESULT_VAL
	cmp	ax,max_id
	jna	kbs_17

kbs_19:
	MOV	[BP].RET_CODE_1,ID_INVALID	; no...invalid id.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error.
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	mov	bad_id,1

	jmp	short kbs_18

kbs_17:
	MOV	[BP].RET_CODE_1,ID_VALID	; valid id...set
	MOV	[BP].RET_CODE_4,ID_VALID	; valid id...set
	MOV	[BP].ID_PARM,AX			; and value moved into block
	MOV	LOOP_COUNT,4			; there should be no more parms
	mov	one_parmid,1

	jmp	short kbs_18

kbs_24:
	cmp	RESULT_TYPE,STRING	; must be a string then???
	jnz	kbs_26

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	DS
	LDS	SI,RESULT_VAL		; get ptr to string
	MOV	DI,BP
	ADD	DI,LANGUAGE_PARM	; point to block for copy.
	MOV	CX,LANG_LENGTH		; maximum length = 2
	LODSB				; load AL with 1st char..

kbs_16:
	jcxz	kbs_15			; do twice, unless only 1 char
	or	al,al
	jz	kbs_15

	STOSB				; store
	DEC	CX			; dec count
	LODSB				; load

	jmp	kbs_16

kbs_15:

	or	cx,cx			; if there was less than 2 or..
	jnz	kbs_20
	or	al,al			;  greater than 2 chars, then..
	jz	kbs_21

kbs_20:
	MOV	[BP].RET_CODE_1,LANGUAGE_INVALID ; invalid.
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	ERR_PART,INVALID_PARAM
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse.

	jmp	short kbs_22

kbs_21:
	MOV	[BP].RET_CODE_1,LANGUAGE_VALID	; valid language has been copied
	MOV	ALPHA,1				; language found

kbs_22:
	POP	DS
	POP	CX
	POP	DI
	POP	SI
	jmp	short kbs_18

;	omitted parameter...

kbs_26:
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; invalid since further parameters.
kbs_18:
	RET

PROCESS_1ST_PARM       ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_2ND_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 2ND POSITIONAL PARAMETER. THIS SHOULD
; BE THE CODE PAGE, IF REQUESTED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR CODE PAGE.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_2ND_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR			; if parse error
	jle	kbs_32

	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_31

kbs_32:

	cmp	RESULT_TYPE,NUMBER		; was parameter specified?
	jnz	kbs_30

	MOV	AX,WORD PTR RESULT_VAL+2	; yes..if code page not..
	OR	AX,AX

	jnz	kbs_27

	MOV	AX,WORD PTR RESULT_VAL		; valid..then

	cmp	ax,MAX_ID
	jna	kbs_28

kbs_27:
	MOV	[BP].RET_CODE_2,CODE_PAGE_INVALID ; mark invalid..
	MOV	[BP].RET_CODE_3,INVALID_SYNTAX	; syntax error
	MOV	LOOP_COUNT,ERROR_COND		; set flag to exit parse

	jmp	short kbs_31

kbs_28:
	MOV	[BP].RET_CODE_2,CODE_PAGE_VALID	; else...valid code page
	MOV	[BP].CODE_PAGE_PARM,AX		; move into parm

	jmp	short kbs_31

kbs_30:
	MOV	[BP].RET_CODE_2,NO_CODE_PAGE	; mark as not specified.
kbs_31:
	RET

PROCESS_2ND_PARM      ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; PROCEDURE_NAME: PROCESS_3RD_PARM
;
; FUNCTION:
; THIS PROCEDURE PROCESSES THE 3RD POSITIONAL PARAMETER. THIS SHOULD
; BE THE KEYBOARD DEFINITION FILE PATH, IF SPECIFIED.
;
; AT ENTRY: PARSE RESULT BLOCK CONTAINS VALUES IF AX HAS NO ERROR.
;
; AT EXIT:
;    PARAMETER CONTROL BLOCK UPDATED FOR FILE NAME.
;
; AUTHOR: WGR
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PROCESS_3RD_PARM       PROC    NEAR

	cmp	ax,RC_NO_ERROR		; if parse error, then...
	jle	kbs_33

	MOV	[BP].RET_CODE_3,INVALID_SYNTAX ; syntax error.
	MOV	LOOP_COUNT,ERROR_COND	; set flag to exit parse
	MOV	ERR_PART,AX

	jmp	short kbs_34

kbs_33:

	cmp	RESULT_TYPE,FILE_SPEC
	jnz	kbs_34

	PUSH	DS
	PUSH	SI
	PUSH	DI
	PUSH	CX
	LDS	SI,RESULT_VAL		; load offset of file name
	LEA	DI,TEMP_FILE_NAME
	MOV	[BP].PATH_OFFSET,DI	; copy to parameter block
	XOR	CX,CX
	LODSB				; count the length of the path.

kbs_35:
	or	al,al
	jz	kbs_36

	STOSB
	LODSB
	INC	CX
	jmp	short kbs_35

kbs_36:
	MOV	[BP].PATH_LENGTH,CX	; copy to parameter block
	POP	CX
	POP	DI
	POP	SI
	POP	DS
kbs_34:
	RET

PROCESS_3RD_PARM ENDP

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\label\label.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/**************************************************************************/
/*                                                                        */
/*  UTILITY NAME:      Label                                              */
/*                                                                        */
/*  SOURCE FILE NAME:  Label.C                                            */
/*                                                                        */
/*  STATUS:            Label Utility, DOS Version 5.00                    */
/*                                                                        */
/**************************************************************************/

#include <io.h>
#include <dos.h>
#include <stdlib.h>
#include <string.h>
#include "label.h"
#include "messages.h"


/*********************************************************************/
/* Routine: Main                                                     */
/*                                                                   */
/* Function:  First make sure we are running over the correct DOS    */
/*            version.  Then see if user wanted help text.  If so,   */
/*            display and exit.  Process the command line to see if  */
/*            the drive and label were given.  If drive was not      */
/*            given, get the current drive.  If no label was given,  */
/*            display the current label and then get new one from    */
/*            the user.  Then delete the old one and create the new. */
/*********************************************************************/

main(int argc, char *argv[])
{
  char ans[2];
  union REGS reg;                                /* M003 */

  _dos_setvect(0x23, ctrlc_hdlr);
  atexit(ExitLabel);

  /* First make sure we are running on a correct DOS version */
  if ((_osmajor < MAJOR_VERSION) || ((_osmajor == MAJOR_VERSION) && 
      (_osminor < MINOR_VERSION)))
  {
    DumbPrint(STDERR, msg_tbl[BAD_DOS_VERSION], LEN_UNKNOWN);
    DumbPrint(STDERR, newline, NEW_LEN);
    return (BAD_DOS_VERSION);
  }
  
  /* Check for "/?" on the command line. If found, output the options  */
  /* help message, and then exit. */
  if (CheckOptionsHelp(argc, argv))
    exit(OK);

  /* Process the command line, see what we've got & haven't got */
  process_commandline(argc, argv);
  
  /* If no drive was specified, get default drive */
  if (*Drive == '?')
    GetDrive();

  /* Save current directory and move to root directory - M003 */
  GetCurDir(reg, curdir);                        /* get current directory */
  if (curdir[0] != 0)                            /* root dir? */
  {
    *rootdir = *Drive;
    SetCurDir(reg, rootdir);                     /* change to root dir */
  }
   
  /* If no label was specified, show current one first and then */
  /* get new one interactively */
  if (*Label == EOL)
  {
    DisplayLabel();
    GetLabel();
  }
    
  /* If they entered an empty label (Carriage Return) then ask them if */
  /* they want to delete the existing volume label */
  if ((*Label == EOL) && (!Nolabel))
  {
    DumbPrint(STDOUT, newline, NEW_LEN);
    do
    {
      DumbPrint(STDOUT, msg_tbl[DEL_CUR_VOL], LEN_UNKNOWN);
      mygets(ans,2);
    } while ( ((*ans = (char)toupper(*ans)) != YES) && (*ans != NO) );
    
    if (toupper(*ans) == NO)
      exit(OK);                                  /* M003 */
  }

  /* Delete the old volume label */
  DeleteLabel();
  
  /* Create the new one, if there is one to create */
  if (*Label != '\0')
  {
    if (CreateLabel())
    {
      DumbPrint(STDOUT, newline, NEW_LEN);
      DumbPrint(STDOUT, msg_tbl[TOO_MANY_FILES], LEN_UNKNOWN);
      DumbPrint(STDOUT, newline, NEW_LEN);
      exit(TOO_MANY_FILES);                      /* M003 */
    }
  }
  exit(OK);                                      /* M003 */
}

  
/*********************************************************************/
/* Routine:   CheckOptionsHelp                                       */
/*                                                                   */
/* Function:  Checks for "/?" on the command line (any of the argv   */
/*            except argv[0]).  If found, display the options help   */
/*            message, and returns TRUE, so main() will know it      */
/*            should exit.                                           */
/*                                                                   */
/* Arguments: Receives argc and argv from main().                    */
/*            put the answer.                                        */
/*                                                                   */
/* Returns:   TRUE if /? found, FALSE otherwise.                     */
/*********************************************************************/

int CheckOptionsHelp(int c, char *v[])
{ 
  for (c--, v++; c; c--, v++)
  {
    if (v[0][0] == '/' && v[0][1] == '?')
    {
      DumbPrint(STDOUT, msg_tbl[HELP_MSG_1], LEN_UNKNOWN);
      DumbPrint(STDOUT, newline, NEW_LEN);
      DumbPrint(STDOUT, msg_tbl[HELP_MSG_2], LEN_UNKNOWN);
      return (TRUE);
    }
  }
  return (FALSE);		/* /? not found, no message */
}


/********************************************************************/
/* Routine:  Process_commandline                                    */
/*                                                                  */
/* Function: Go through the command line and pick off the drive and */
/*           label if these were given.  Note that because volume   */
/*           labels can have spaces, if the label was given on the  */
/*           command line, it would be spread out over argv[i] for  */
/*           more than one i.                                       */
/********************************************************************/

void process_commandline(int ac, char *av[])
{
  LoopIndex i;

  for (i = 1; i < ac; i++)
  {

#ifdef DBCS
    if (LegitDrive((av[i]) = DBCSstrupr(av[i])))
#else
    if (LegitDrive((av[i]) = strupr(av[i])))
#endif

    {
      if (*Drive == '?')
      {
        /* Save the drive letter */
        *Drive = *av[i];
      }
      else
      {    
        DumbPrint(STDERR, msg_tbl[MULTIPLE_DRIVE], LEN_UNKNOWN);
        DumbPrint(STDERR, newline, NEW_LEN);
        exit(MULTIPLE_DRIVE);
      }
      
      /* See if the drive letter is the first parameter */
      if (i != 1)
        DriveNotFirst = TRUE;

      /* See if the label is tacked right onto the drive letter. */
      /* Verify label if it is. */
      if (IllegitLabelWithDrive(av[i]))
        return;
    }
    else
    {
      if (IllegitimateLabel(av[i])) 
        return;
      else
        SaveLabel(av[i]);
    }
  }
  /*  M002
   *  Check for a double quote on the original command line.  The C
   *  initialization code will delete the quotes, so we must check the
   *  psp for them.  If any quotes are found, then an error should be
   *  returned.
   */
  if (CheckCmdLineQuotes())
  {
    strcpy(Label,"");
    DumbPrint(STDERR, msg_tbl[LABEL_SYNTAX_ERR], LEN_UNKNOWN);
    DumbPrint(STDERR, newline, NEW_LEN);
    return;
  }
}


/********************************************************************/
/* Routine:  DisplayLabel                                           */
/*                                                                  */
/* Function: Display the volume label and serial number (if any).   */
/*           First set the DTA to be global variable FCB, then do   */
/*           findfirst to find a file in the root with volume       */
/*           attribute.  We need the FCB-findfirst because the      */
/*           handle-based one returns the filename (i.e. vol label) */
/*           as eight characters - dot - three characters.          */
/********************************************************************/

void DisplayLabel()
{
  unsigned char serialbuf[26];
  union REGS reg;
  struct SREGS sreg;

  /* first set the dta to be fcb so information returned is put there */
  reg.x.ax = 0x1a00;
  reg.x.dx = (unsigned)fcb;
  intdos(&reg, &reg);

  /* now try to find the volume label */
  fcb[DRIVE_BYTE] = *Drive - 'A' + 1;
  reg.x.ax = 0x1100;
  reg.x.dx = (unsigned)fcb;
  intdos(&reg, &reg);
  if (reg.h.al)
  {
    DumbPrint(STDOUT, msg_tbl[VOL_IN_DRIVE], LEN_UNKNOWN);
    DumbPrint(STDOUT, Drive, 1);
    DumbPrint(STDOUT, msg_tbl[HAS_NO_LABEL], LEN_UNKNOWN);
    DumbPrint(STDOUT, newline, NEW_LEN);
  }
  else
  {
    Nolabel = FALSE;
    fcb[ENDNAME] = '\0';
    DumbPrint(STDOUT, msg_tbl[VOL_IN_DRIVE], LEN_UNKNOWN);
    DumbPrint(STDOUT, Drive, 1);
    DumbPrint(STDOUT, msg_tbl[IS], LEN_UNKNOWN);
    DumbPrint(STDOUT, &fcb[NAME], LEN_UNKNOWN);
    DumbPrint(STDOUT, newline, NEW_LEN);
  }

  /* Now print out the volume serial number, if it exists */
  segread(&sreg);
  reg.x.ax = 0x6900;
  reg.h.bl = *Drive - 'A' + 1;
  reg.x.dx = (unsigned)serialbuf;
  intdosx(&reg, &reg, &sreg);
  if (!reg.x.cflag)
  {
    DumbPrint(STDOUT, msg_tbl[VOL_SER], LEN_UNKNOWN);
    PrintHex(serialbuf[5]);
    PrintHex(serialbuf[4]);
    DumbPrint(STDOUT, msg_tbl[DASH], LEN_UNKNOWN);
    PrintHex(serialbuf[3]);
    PrintHex(serialbuf[2]);
    DumbPrint(STDOUT, newline, NEW_LEN);
  }
}


/********************************************************************/
/* Routine:  GetDrive                                               */
/*                                                                  */
/* Function: Get the current drive, and write the drive character   */
/*           into the global variable Drive                         */
/********************************************************************/

void GetDrive()
{
  unsigned driveno;

  _dos_getdrive(&driveno);
  Drive[0] = (char) driveno + 'A'- 1;
  LegitDrive(Drive);		     /* check for validity of drive */
}


/********************************************************************/
/* Routine:  GetLabel                                               */
/*                                                                  */
/* Function: Get the label from the user.  Spin in a loop until     */
/*           user enters a label with valid characters.  Then make  */
/*           sure it's not too long, & copy it into global variable */
/*           Label.                                                 */
/********************************************************************/

void GetLabel()
{ 
  char temp[MAX_LABEL_LENGTH+1]; 

  do
  {
    DumbPrint(STDERR, msg_tbl[ENTER_LABEL], LEN_UNKNOWN);
    mygets(temp,MAX_LABEL_LENGTH+1);
  } while (IllegitimateLabel(temp));

  strcpy(Label, temp);
}


/********************************************************************/
/* Routine: LegitDrive                                              */
/*                                                                  */
/* Function:  Make sure the drive in question is valid for labeling */
/*            purposes.  Therefore it has to be a valid drive (if   */
/*            you can open CON on a given drive, it is valid), but  */
/*            it cannot be a network drive, and it cannot be a      */
/*            drive which has been JOINed, SUBSTed, or ASSIGNed     */
/********************************************************************/

Boolean LegitDrive(char *s)
{
  char buf1[128], buf2[128];
  struct SREGS sreg;
  union REGS reg;

  /* Is this argument supposed to be a drive ? */
  if (s[1] != ':')
    return (FALSE);

  /* Save drive letter in temporary storage */
  *TempDrive = *s;

  /* Make sure this is a valid drive */
  con_fcb[DRIVE_BYTE] = *TempDrive - 'A' + 1;
  reg.x.ax = 0x0f00;
  reg.x.dx = (unsigned)con_fcb;
  intdos(&reg, &reg);
  if (reg.h.al)
  {
    DumbPrint(STDERR, msg_tbl[INVALID_DRIVE], LEN_UNKNOWN);
    DumbPrint(STDERR, newline, NEW_LEN);
    exit(INVALID_DRIVE);
  }
  reg.x.ax = 0x1000;
  reg.x.dx = (unsigned)con_fcb;
  intdos(&reg, &reg);			/* now close the file */

  /* Make sure user is not trying to label a network drive */
  reg.h.ah = IOCTL;
  reg.h.al = REMOTE;
  reg.h.bl = (char)(*TempDrive - 'A' + 1);
  intdos(&reg, &reg);
  if (reg.x.dx & BIT_12_MASK)
  {
    DumbPrint(STDERR, msg_tbl[REM_MEDIA], LEN_UNKNOWN);
    DumbPrint(STDERR, newline, NEW_LEN);
    exit(REM_MEDIA);                          
  }

  /* Make sure the user is not trying to label a drive which has */
  /* been ASSIGNed, JOINed, or SUBSTed                           */
  strcpy(buf1, TempDrive);
  strcat(buf1, "\\");
  segread(&sreg);
  reg.x.si = (unsigned)buf1;
  reg.x.di = (unsigned)buf2;
  reg.x.ax = 0x6000;
  intdosx(&reg, &reg, &sreg);
  if (*buf1 != *buf2)
  {
    DumbPrint(STDERR, msg_tbl[TRANSLATED_DRIVE], LEN_UNKNOWN);
    DumbPrint(STDERR, newline, NEW_LEN);
    exit(TRANSLATED_DRIVE);
  }

  return (TRUE);
}


/********************************************************************/
/* Routine: IllegitLabelWithDrive                                   */
/*                                                                  */
/* Function: See if the label given by the user is connected to the */
/*           drive letter (no space in between drive and label).    */
/*           If so, then check to see that the label given is       */
/*           legitimate.                                            */
/********************************************************************/

Boolean IllegitLabelWithDrive(char *s)
{
  if (s[2] != EOL)
  {
    if (IllegitimateLabel(&s[2]))
      return (TRUE);

    SaveLabel(&s[2]);
    return (FALSE);
  }
}


/********************************************************************/
/* Routine: SaveLabel                                               */
/*                                                                  */
/* Function: Saves the label in the global variable.  If it isn't   */
/*           the first entry, then it adds a space and then copies  */
/*           the label.                                             */
/*           Also, if the drive letter was NOT the first parameter  */
/*           and the label is not empty, then an error is returned. */
/*              e.g  label foo a: bar  => yields an error.          */
/********************************************************************/

void SaveLabel(char *string)
{
  if (firsttime)
    firsttime = FALSE;
  else
  {
    if (DriveNotFirst)
    {
      DumbPrint(STDERR, msg_tbl[INVALID_DRIVE_SYNTAX], LEN_UNKNOWN);
      DumbPrint(STDERR, newline, NEW_LEN);
      exit(INVALID_DRIVE_SYNTAX);
    }
    else
      strcat(Label, " ");
  }
  strcat(Label, string);
}


/********************************************************************/
/* Routine: IllegitimateLabel                                       */
/*                                                                  */
/* Function: Make sure the volume label given by the user is of the */
/*           appropriate format.  This means it must be less than   */
/*           twelve characters long, and none of the characters can */
/*           be any of those listed in the BadChars array (see file */
/*           defs.h)                                                */
/********************************************************************/

Boolean IllegitimateLabel(char *s)
{
  int length, LabelLen;
  LoopIndex i, j;

#ifdef DBCS
  s = DBCSstrupr(s);
#else
  s = strupr(s);
#endif

  /* Make sure label is not too long */
  length = strlen(s);
  LabelLen = strlen(Label);
  if ((length > MAX_LABEL_LENGTH) ||
      ((LabelLen > 0) && ((length + LabelLen + 1) > MAX_LABEL_LENGTH)))
  {
    strcpy(Label,"");
    DumbPrint(STDERR, msg_tbl[LABEL_TOO_LONG], LEN_UNKNOWN);
    DumbPrint(STDERR, newline, NEW_LEN);
    return (LABEL_TOO_LONG);
  }

#ifdef DBCS
  if (!CheckDBCSTailByte(s,s + length - 1) && IsDBCSLeadByte(s[length - 1]))
  {
    s[length - 1] = '\0';
    length--;
  }
#endif


  /* Make sure all characters are legitimate */
  for (i = 0; i < length; i++)
  {

#ifdef DBCS
    if (IsDBCSLeadByte(s[i]))
      i++;
    else
    {
#endif

      for (j = 0; j < BAD_CHARS; j++)
      {
        if (s[i] == BadChars[j])
        {
          strcpy(Label,"");
          DumbPrint(STDERR, msg_tbl[LABEL_SYNTAX_ERR], LEN_UNKNOWN);
          DumbPrint(STDERR, newline, NEW_LEN);
          return (LABEL_SYNTAX_ERR);
        }
      }

      if ((unsigned char)s[i] < (unsigned char)SPACEBAR)   /* M002 */
      {
        strcpy(Label,"");
        DumbPrint(STDERR, msg_tbl[LABEL_SYNTAX_ERR], LEN_UNKNOWN);
        DumbPrint(STDERR, newline, NEW_LEN);
        return (LABEL_SYNTAX_ERR);
      }

#ifdef DBCS
    }
#endif

  }
  return (FALSE);
}


/********************************************************************/
/* Routine:  DeleteLabel                                            */
/*                                                                  */
/* Function: Get rid of current volume label.  I had to go through  */
/*           intdos because remove/unlink didn't seem to work       */
/********************************************************************/

void DeleteLabel()
{
  char findstring[7];
  struct find_t  findstr;
  union REGS reg;

  strcpy(findstring, "?:\\*.*");
  *findstring = *Drive;
  if (!_dos_findfirst(findstring, _A_VOLID, &findstr))
  {
    strcpy(OldLabel, findstr.name);
    fcb[DRIVE_BYTE] = *Drive - 'A' + 1;
    reg.x.ax = 0x1300;
    reg.x.dx = (unsigned)fcb;
    intdos(&reg, &reg);
  }
}


/********************************************************************/
/* Routine:  CreateLabel                                            */
/*                                                                  */
/* Function: Create the new volume label file.  We need an FCB-type */
/*           create because the C runtime library function create   */
/*           truncates the name to eight characters.                */
/********************************************************************/

int CreateLabel()
{
  union REGS reg;
  LoopIndex i;
  int length;

  creat_fcb[DRIVE_BYTE] = *Drive - 'A' + 1;
  length = strlen(Label);
  for (i = 0; i < length; i++)
    creat_fcb[NAME + i] = Label[i];

  reg.x.ax = 0x1600;                             /* create the file */
  reg.x.dx = (unsigned)creat_fcb;
  intdos(&reg, &reg);

  if (!reg.h.al)
  {
    reg.x.ax = 0x1000;                           /* close the file */
    reg.x.dx = (unsigned)creat_fcb;
    intdos(&reg, &reg);
    return (OK);
  }
  else
    return (TOO_MANY_FILES);
}


/********************************************************************/
/* Routine: DumbPrint                                               */
/*                                                                  */
/* Function: Write text to STDOUT and STDERR.  The reason for not   */
/*           using fprintf is because it costs ~3k in executable    */
/*           (disk space is currently a priority.)   The handle and */
/*           string must be specified, but a length argument of     */
/*           zero means call strlen to find out the arg.  Requiring */
/*           a length arg means we can print out single chars and   */
/*           non-ASCIIZ strings as well as ASCIIZ strings.          */
/********************************************************************/

void DumbPrint(int hndle, char strng[], int len)
{
  union REGS reg;

  if (!len)
    len = strlen(strng);

  reg.h.ah = 0x40;
  reg.x.bx = hndle;
  reg.x.cx = len;
  reg.x.dx = (unsigned)strng;
  intdos(&reg, &reg);
}


/********************************************************************/
/* Routine: PrintHex                                                */
/*                                                                  */
/* Function: Print out a character (a byte) as two 4 bit hex values.*/
/*           Do this by converting each 4 bit number into its       */
/*           corresponding character, and using DumbPrint to print  */
/*           the value.                                             */
/********************************************************************/

void PrintHex(char c)
{
  unsigned char temp;

  /* First print high nibble */
  temp = c;
  temp = temp >> 4;
  if (temp < 10)
    temp += '0';
  else
    temp += ('A' - 10);
  DumbPrint(STDOUT, &temp, 1);

  /* Then print low nibble */
  temp = c & 0xf;
  if (temp < 10)
    temp += '0';
  else
    temp += ('A' - 10);
  DumbPrint(STDOUT, &temp, 1);
}


/********************************************************************/
/* Routine: mygets                                                  */
/*                                                                  */
/* Function: Simulates GETS taking care of EOF.                     */
/********************************************************************/

void mygets(char *buff, unsigned int length)
{
  char *sptr;
  int i;
  union REGS reg;                      /* structure for doing int21's with */

  if (input_redir == -1)
  {
    reg.h.ah = 0x44;
    reg.h.al = 0x0;                    /* get device info */
    reg.x.bx = 0x0;                    /* for STDIN */
    intdos(&reg, &reg);
    if (reg.x.dx & 0x80)
      input_redir = 0;
    else
      input_redir = 1;
  }

  if (input_redir)
  {
    reg.h.ah = 0xb;                    /* check input status */
    intdos(&reg,&reg);
    if (reg.h.al == 0)                 /* EOF ? */
    {
      puts(msg_tbl[UNEXP_EOF]);
      exit(UNEXP_EOF);                           /* M003 */
    }
  }

  /* else  - NOT EOF; go get input */

  getsbuf[0] = (char) length;          /* add 1 for CR */
  getsbuf[2] = 0;
  reg.x.dx = (unsigned) getsbuf;
  reg.h.ah = 0xa;                      /* buffered input from STDIN */
  intdos(&reg,&reg);

  puts("\r");

  sptr = &getsbuf[2];
  if (*sptr == EOFCHAR)
  {
    puts(msg_tbl[UNEXP_EOF]);
    exit(UNEXP_EOF);                             /* M003 */
  }
  for (i = 0; i < getsbuf[1]; i++)
    *buff++ = *sptr++;
  *buff = '\0';                        /* null terminate the string */
}


/********************************************************************/
/* Routine: CheckCmdLineQuotes                                      */
/*                                                                  */
/* Function: Check the original command line for any double quotes. */
/*           The C initialization code removes the double quotes.   */
/*           If any double quotes are entered on the original       */
/*           command line, then an error is returned.               */
/* M002                                                             */
/********************************************************************/

Boolean CheckCmdLineQuotes()
{
  union REGS reg;
  static unsigned char far *psp;

  /* first get the segment address of PSP */
  reg.x.ax = 0x6200;
  intdos(&reg, &reg);

  /* get address of original command line */
  FP_OFF(psp) = CMDLINE_OFFSET;
  FP_SEG(psp) = reg.x.bx;

  /* check for double quotes */
  for (; *psp != CARRIAGE_RETURN; psp++)
  {
    if (*psp == DBL_QUOTE)
      return (TRUE);              /* found a double quote */
  }
  return (FALSE);                 /* double quote NOT found */
}


/***************************************************************************/
/* Routine:  ExitLabel                                                     */
/*                                                                         */
/* Function: Exits the label utility by returning the user to the original */
/*           directory and returning the appropriate error code.           */
/* M003                                                                    */
/***************************************************************************/

void ExitLabel()
{
  union REGS reg;
  
  if (curdir[0] != 0)                        /* originally at root? */
    SetCurDir(reg, curdir);                  /* change to original dir */
}


/***************************************************************************/
/* Routine:  ctrlc_hdlr                                                    */
/*                                                                         */
/* Function: This is the ctrlc_handler routine.  It simply does an exit    */
/*           so that the "atexit" routine will be executed.                */
/* M003                                                                    */
/***************************************************************************/

void far _interrupt ctrlc_hdlr()
{
  exit(OK);
}


#ifdef DBCS

/********************************************************************/
/* Routine: DBCSstrupr                                              */
/*                                                                  */
/* Function: DBCS enabled strupr.                                   */
/********************************************************************/

unsigned char *DBCSstrupr(unsigned char *str)
{
  unsigned char *s;

  s = str;
  while (*s)
  {
    if (IsDBCSLeadByte(*s))
      s++;
    else
      *s = toupper(*s);
    s++;
  }
  return (str);
}


/********************************************************************/
/* Routine: IsDBCSLeadByte                                          */
/*                                                                  */
/* Function: Test if the character is DBCS lead byte.               */
/*                                                                  */
/*     input:  c = character to test                                */
/*     output: TRUE if leadbyte                                     */
/********************************************************************/

int IsDBCSLeadByte(unsigned char c)
{
  static unsigned char far *DBCSLeadByteTable = 0;

  union REGS inregs,outregs;
  struct SREGS segregs;
  unsigned char far *p;

  if (DBCSLeadByteTable == 0)
  {
    inregs.x.ax = 0x6300;              /* get DBCS lead byte table */
    intdosx(&inregs, &outregs, &segregs);
    FP_OFF(DBCSLeadByteTable) = outregs.x.si;
    FP_SEG(DBCSLeadByteTable) = segregs.ds;
  }

  p = DBCSLeadByteTable;
  while (p[0] || p[1])
  {
    if (c >= p[0] && c <= p[1])
      return (TRUE);
    p += 2;
  }
  return (FALSE);
}


/********************************************************************/
/* Routine: CheckDBCSTailByte                                       */
/*                                                                  */
/* Function: Check if the character point is at the tail byte.      */
/*                                                                  */
/*     input:  *str = strart pointer of the string                  */
/*             *point = character pointer to check                  */
/*     output: TRUE if at the tail byte                             */
/********************************************************************/

int CheckDBCSTailByte(unsigned char *str, unsigned char *point)
{
  unsigned char *p;

  p = point;
  while (p != str)
  {
    p--;
    if (!IsDBCSLeadByte(*p))
    {
      p++;
      break;
    }
  }
  return ((point - p) & 1 ? TRUE : FALSE);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\memctrlc.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*******************************************************************/
/*	MEMCTRLC.C																		*/
/*																						*/
/*		This module contains the Ctrl-C handler put in by Mem when 	*/
/*	it links in UMBs. On a Ctrl-C, UMBs are delinked if they were	*/
/* 	explicitly enabled by Mem. The old Ctrl-C handler is restored 	*/
/* 	and Mem then exits. If we dont do this, UMBs remain linked in	*/
/*	after a Ctrl-C and as a result lot of old programs dont run.	*/
/*																						*/
/*******************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <dos.h>

extern char LinkedIn;
extern void (interrupt far *OldCtrlc)();

void interrupt cdecl far MemCtrlc (unsigned es, unsigned ds,
			unsigned di, unsigned si, unsigned bp, unsigned sp,
			unsigned bx, unsigned dx, unsigned cx, unsigned ax )
{
	union REGS inregs;

	((void)es), ((void)ds),	((void)si),	((void)bp), ((void)sp);
	((void)bx), ((void)dx), ((void)bx), ((void)dx), ((void)cx);
	((void)di), ((void)ax);

	if ( LinkedIn )	/* Did we link in UMBs */
	{
		inregs.x.ax = 0x5803;
		inregs.x.bx = 0;
		intdos( &inregs, &inregs );	/* Delink UMBs */
	}

	_dos_setvect( 0x23, OldCtrlc ); /* Restore previous ctrlc handler */

	exit(0);	/* Exit Mem */

}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\mem.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */

/*----------------------------------------------------------------------+
|                                                                       |
|                                                                       |
|       Title:          MEM                                             |
|                                                                       |
|       Syntax:                                                         |
|                                                                       |
|               From the DOS command line:                              |
|                                                                       |
|               MEM                                                     |
|                       - Used to display DOS memory map summary.       |
|                                                                       |
|               MEM /CLASSIFY                                           |
|                       - Lists modules' memory use.                    |
|                                                                       |
|               MEM /DEBUG                                              |
|                       - Used to display a detailed DOS memory map.    |
|                                                                       |
|               MEM /FREE                                               |
|                       - Lists free memory, in various forms.          |
|                                                                       |
|               MEM /MODULE                                             |
|                       - Details a single module's memory use.         |
|                           						|
|=======================================================================|
|   				Revision History                  	|   
|=======================================================================|
|                                                                       |
|       AN001 - PTM P2914 -> This PTM relates to MEM's ability to report|
|                            the accurate total byte count for EM       |
|                            memory.                                    |
|                                                                       |
|       AN002 - PTM P3477 -> MEM was displaying erroneous base memory   |
|                            information for "Total" and "Available"    |
|                            memory.  This was due to incorrect logic   |
|                            for RAM carving.                           |
|                                                                       |
|       AN003 - PTM P3912 -> MEM messages do not conform to spec.       |
|               PTM P3989                                               |
|                                                                       |
|               Date: 1/28/88                                           |
|                                                                       |
|       AN004 - PTM P4510 -> MEM does not give correct DOS size.        |
|                                                                       |
|               Date: 4/27/88                                           |
|                                                                       |
|       AN005 - PTM P4957 -> MEM does not give correct DOS size for     |
|                            programs loaded into high memory.          |
|                                                                       |
|               Date: 6/07/88                                           |
|									|
|   M000   SR   8/27/90   Added new Ctrl-C handler to delink UMBs	|
|									|
|   M003  NSM  12/28/90   Added a New switch /Classify which groups	|
|         			groups programs in conv and UMB and 	|
|				gives sizes in decimal and hex.         |
|                                                                       |
|   T-RICHJ     5/27/92   Rewrote 70% or so; different options, added   |
|                         mprintf(), reworked internal memory           |
|                         structure, replaced old command-line parser   |
|                                                                       |
+----------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/

#include "ctype.h"
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"         /* MSKK02 07/18/89 */
#include "mem.h"

/*---------------------------------------------------------------------------*/

/* All global declarations go here */

   char   *SingleDrive = "%c:";
   char   *MultipleDrives = "%c: - %c:";
   char   *UnOwned = "----------";

#if IBMCOPYRIGHT                                                        /*EGH*/
        char    *Ibmbio = "IBMBIO";                                     /*EGH*/
        char    *Ibmdos = "IBMDOS";                                     /*EGH*/
#else                                                                   /*EGH*/
        char    *Ibmbio = "IO    "; 
        char    *Ibmdos = "MSDOS "; 
#endif                                                                  /*EGH*/

   char  LinkedIn = 0;   /* Flag set when mem links in UMBs :M000 */
   void (interrupt far *OldCtrlc)(); /* Old Ctrlc handler save vector :M000*/

/*---------------------------------------------------------------------------*/

   struct sublistx sublist[10];

   struct SYSIVAR far *SysVarsPtr;

   char ddrivername[MAX_DDRIVER_REP][9];
   int  ddriveridx = 0;

   unsigned far *ArenaHeadPtr;

   char      OwnerName[128];
   char      TypeText[128];
   char      cmd_line[128];

   unsigned  long UMB_Head;
   unsigned  LastPSP=0;

   char      UseArgvZero = TRUE;
   char      EMSInstalledFlag = (char) 2;

   union  REGS  InRegs;
   union  REGS  OutRegs;
   struct SREGS SegRegs;

   int    BlockDeviceNumber;

   int       NoCR = 0;

   int       DataLevel;
   int       PageBreak;
   int       num_lines;        /* number of lines we've printed on the page */

   char      ModName[40];      /* MEM/M option name */

   struct mem_classif mem_table;

/*---------------------------------------------------------------------------*/

char *ArgPos;  /* Used to report which argument caused an error */

void interrupt cdecl far MemCtrlc (unsigned es, unsigned ds,
         unsigned di, unsigned si, unsigned bp, unsigned sp,
         unsigned bx, unsigned dx, unsigned cx, unsigned ax );

void
main (argc, argv)
int   argc;
char      **argv;
{
   unsigned char   UMB_Linkage;
   unsigned int    rc=0;      /* init to NO ERROR */

   if (argc)  (void)*argv;

   sysloadmsg(&InRegs,&OutRegs);
   if ((OutRegs.x.cflag & CarryFlag) == CarryFlag)
      {
      sysdispmsg(&OutRegs,&OutRegs);
      exit(1);
      }

   init_data();  /* Initialize memory totals */
   DataLevel = PageBreak = 0;
   num_lines = 0;

   if ((rc = parse_cmd (argc, argv)) != 0)
      {
      Parse_Message (rc, (char far *)ArgPos);
      exit (1);
      }

   if (PageBreak)
      {                          /* Find the # of lines on the console      */
      PageBreak = get_lines();   /* (error sets PageBreak to 0, which turns */
      }                          /* it off nicely)                          */

   /*
    * Store the current Ctrl-C handler and replace with our
    * Ctrl-C handler :M000
    */

   OldCtrlc = _dos_getvect( 0x23 ); /* M000 */
   _dos_setvect( 0x23, MemCtrlc );   /* M000 */

   /*
    * Check the UMB link state and do that nasty...
    *
    */

   InRegs.x.ax = GET_UMB_LINK_STATE; /* save current linkstate of UMBs */
   intdos(&InRegs, &OutRegs);

   LinkedIn = 0;

   if (! (UMB_Linkage = OutRegs.h.al))
      {                /* UMBs not presently linked, so do it now */
      InRegs.x.ax = SET_UMB_LINK_STATE;
      InRegs.x.bx = LINK_UMBS;
      intdos(&InRegs, &OutRegs);
      LinkedIn++;   /* Indicate that we have linked in UMBs :M000 */
      }

   rc = DisplayBaseDetail();      /* go show the memory state, and    */
				  /* restore original UMB link state: */
   if (!UMB_Linkage)      /* weren't linked originally */
      {
      InRegs.x.ax = SET_UMB_LINK_STATE;
      InRegs.x.bx = UNLINK_UMBS;
      intdos(&InRegs, &OutRegs);  /* take 'em out again */
      LinkedIn--;
      }

   _dos_setvect (0x23, OldCtrlc);   /* M000 */

		/* if no error in DisplayBaseDetail,    */
		/* go display other things as necessary */

   if (!rc)
      {
      GetSummary();  /* Fills in a few other things */

      switch (DataLevel)
         {
	 case  0:  DispMEMSummary();
	          break;
	          break;
         case  1:  DisplayClassification();
         case  2:  DisplaySummary();
	          break;
         }
      }

   /* If user did not issue Ctrl-C till here, we just remove the handler */

   exit (rc);
}

/*---------------------------------------------------------------------------*/

unsigned long AddressOf(Pointer)
char far *Pointer;
{
   unsigned long SegmentAddress,OffsetAddress;

   SegmentAddress = (unsigned long) (FP_SEG(Pointer)) * 16l;
   OffsetAddress  = (unsigned long) (FP_OFF(Pointer));

   return ((SegmentAddress + OffsetAddress)/16L);

}

/******************************************************************************
 *
 * init_data() resets various totals in <mem_table>, to prepare for later
 * counts.  It also zeroes the two arrays of data.
 *
 */

void
init_data ()
{
   int   i;

   mem_table.conv_ttl = mem_table.conv_free  = (unsigned long)0;
   mem_table.umb_ttl  = mem_table.umb_free   = (unsigned long)0;
   mem_table.xms_ttl  = mem_table.xms_free   = (unsigned long)0;
   mem_table.ems_ttl  = mem_table.ems_free   = (unsigned long)0;
   mem_table.int_15h  = mem_table.conv_large = (unsigned long)0;

   mem_table.hma        = (unsigned int)0;
   mem_table.noof_progs = mem_table.noof_umbs = 0;

   mem_table.xmsMvers = mem_table.xmsmvers = 0;
   mem_table.xmsMdrvr = mem_table.xmsmdrvr = 0;
   mem_table.emsMvers = mem_table.emsmvers = 0;

   for (i = 0; i < MAX_DDRIVER_REP; i++)
      {
      ddrivername[i][0] = 0;
      }
   ddriveridx = 0;

   for (i = 0; i < MAX_CLDATA_INDEX; i++)
      {
      mem_table.files[i].psp_addr = -1;  /* A 0 would mean free space */
      mem_table.files[i].conv_ttl = mem_table.files[i].umb_ttl = 0L;

      mem_table.umbs[i].umb_free = mem_table.umbs[i].umb_ttl   = 0L;
      mem_table.umbs[i].umb_addr = mem_table.umbs[i].umb_large = 0L;
      }
}

/******************************************************************************
 *
 * parse_cmd() interepetes the following options from the command-line:
 *
 *      /C        or /CLASSIFY      - DataLevel = 1
 *      /D        or /DEBUG         - DataLevel = 2
 *      /F        or /FREE          - DataLevel = 3
 *      /M module or /MODULE module - DataLevel = 4
 *      none of /C,/D,/F,/M         - DataLevel = 0
 *
 *      /P        or /PAGE          - PageBreak = 1
 *
 *      /H or /?  or /HELP          - Helptext displayed; immediate exit
 *
 * It accepts arguments as "MEM/C/P" or "MEM/P/M:module" or
 * "MEM /Mmodule" or "MEM/M = module /P" or "MEM/Mmodule/P" or
 * "MEM /debug/page" or... well, just about anything.
 *
 * If it returns 0, everything's fine... otherwise, it returns the error
 * message that should be printed before exiting.
 *
 */

#define SWITCHCHAR '/'

int
parse_cmd (agc, agv)
int        agc;
char          **agv;
{
   char  cmdline[256], *ptr;
   int   i;
   char far *fptr;

/*
 * First we reconstruct the command-line... argv[][] is a little too
 * clumsy for what we're gonna do in a sec.
 *
 */

   cmdline[0] = 0;
   for (i = 1; i < agc; i++)
      {
      strcat (cmdline, agv[i]);
      strcat (cmdline, " ");
      }
   strupr (cmdline);               /* Make it case-insensitive */

/*
 * That done, let's go...
 *
 */

   ArgPos = cmdline;
   for ( ; *ArgPos; )
      {
      while (*ArgPos && strchr (" \t", *ArgPos))  /* Skip whitespace */
         ArgPos++;

      if (! *ArgPos)  break;   /* In the event that it ended in whitespace */

      if (*ArgPos != SWITCHCHAR)
         {
	 for (i = ArgPos - cmdline; i >= 0; i--)
	    if (cmdline[i] == SWITCHCHAR)  break;
	 i = max (i, 0);
	 for ( ; *ArgPos; ArgPos++)
	    if (strchr (" /\t", *ArgPos))  break;
	 *ArgPos = 0;          /* Null-terminate after this option...      */
	 ArgPos = &cmdline[i]; /* ...and point to the start of the option. */
	 return p_not_in_key;  /* They've given "MEM garbage" or something */
	 }
      switch (*(ArgPos+1))
         {
	 case 'C':  if (DataLevel != 0)
	               {
		       *(ArgPos+2) = 0;
		       return p_too_many;
	               }
		    DataLevel = 1;
		    ArgPos += (! strncmp (ArgPos+1, "CLASSIFY", 8)) ? 9 : 2;
		   break;
	 case 'D':  if (DataLevel != 0)
	               {
		       *(ArgPos+2) = 0;
		       return p_too_many;
	               }
		    DataLevel = 2;
		    ArgPos += (! strncmp (ArgPos+1, "DEBUG", 5)) ? 6 : 2;
		   break;
	 case 'F':  if (DataLevel != 0)
	               {
		       *(ArgPos+2) = 0;
		       return p_too_many;
	               }
		    DataLevel = 3;
		    ArgPos += (! strncmp (ArgPos+1, "FREE", 4)) ? 5 : 2;
		   break;

	 case 'P':  if (PageBreak != 0)
	               {
		       *(ArgPos+2) = 0;
		       return p_too_many;
	               }
		    PageBreak = 3;
		    ArgPos += (! strncmp (ArgPos+1, "PAGE", 4)) ? 5 : 2;
		   break;

	 case 'M':  if (DataLevel != 0)
	               {
		       *(ArgPos+2) = 0;
		       return p_too_many;
	               }
		    ptr = ArgPos;   /* Remember where we are, in case of err */
		    DataLevel = 4;
		    ArgPos += (! strncmp (ArgPos+1, "MODULE", 6)) ? 7 : 2;

		    while (*ArgPos && strchr (" :\t", *ArgPos))
		       ArgPos++;                       /* Skip delimiters  */

		    i = 0;
		    while (*ArgPos && !strchr (" /\t", *ArgPos))
		       {
		       ModName[i] = *ArgPos;
		       ArgPos++;  i++;
		       }
		    ModName[i] = 0;         /* Terminate the name */
		    if (i == 0)  /* They didn't give a module name */
		       {
		       InRegs.x.ax = ModuleName;
		       InRegs.h.dh = Utility_Msg_Class;
		       sysgetmsg(&InRegs,&SegRegs,&OutRegs);
		       FP_OFF(fptr) = OutRegs.x.si;
		       FP_SEG(fptr) = SegRegs.ds;

		       for (ptr = cmdline; *fptr; ptr++, fptr++)
		          *ptr = *fptr;
		       *ptr = 0;

		       ArgPos = cmdline;    /* So complain, and list the */
		                            /* paramter as missing from  */
		       return p_op_missing; /* the option "/MODULE".     */
		       }
		   break;

	 case 'H':
	 case '?':  if (DataLevel != 0 || PageBreak != 0)
	               {
		       *(ArgPos+2) = 0;
		       return p_too_many;
	               }
		     for (i = MSG_OPTIONS_FIRST; i <= MSG_OPTIONS_LAST; i++)
			mprintf (i, "");
		     exit (0);
		   break;

	 default:   *(ArgPos+2) = 0;
	            return p_not_in_sw;
         }
      }

   return 0;
}

/************************************************************************/
/* Parse_Message                - This routine will print only those    */
/*                                messages that require 1 replaceable   */
/*                                parm.                                 */
/*                                                                      */
/*      Inputs  : Msg_Num       - number of applicable message          */
/*                Handle        - display type                          */
/*                Message_Type  - type of message to display            */
/*                Replace_Parm  - pointer to parm to replace            */
/*                                                                      */
/*      Outputs : message                                               */
/*                                                                      */
/************************************************************************/

void
Parse_Message (Msg_Num, parse_ptr)
int            Msg_Num;  
char               far *parse_ptr;
{                          
   if (! parse_ptr)
      InRegs.x.cx = 0;    
   else
      {
      sublist[1].value     = (unsigned far *)parse_ptr;
      sublist[1].size      = Sublist_Length; 
      sublist[1].reserved  = Reserved;      
      sublist[1].id        = 0;            
      sublist[1].flags     = Char_Field_ASCIIZ+Left_Align;
      sublist[1].max_width = 40;
      sublist[1].min_width = 01;
      sublist[1].pad_char  = Blank; 

      InRegs.x.cx = 1;
      }

   InRegs.x.ax = Msg_Num;      
   InRegs.x.bx = STDERR;      
   InRegs.h.dl = No_Input;  
   InRegs.h.dh = Parse_Err_Class; 
   InRegs.x.si = (unsigned int)&sublist[1]; 
   sysdispmsg(&InRegs,&OutRegs); 
}                                  

/* M003 END */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\msgdef.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/************************************************************************/
/* MSGDEF.H		- This include file defines each message type	*/
/*			  that can occur in MEM.  These defines will	*/
/*			  be used by MEM to build the proper message.	*/
/*									*/
/*	Date	: 10/29/87						*/
/************************************************************************/
#include "version.h"                                                    /*EGH*/

#define NewLineMsg			10
#define Title1Msg			11
#define Title2Msg			12
#define Title3Msg			13
#define Title4Msg			14
#define MainLineMsg			15
#define DriverLineMsg			16
#define DeviceLineMsg			17
#define Int15MemoryMsg			18
#define SpaceOverMsg			19
#define XMSVersionMsg			20
#define EMSVersionMsg			21
#define LoadHighMsg			22
#define HiddenMsg			23
#define InterruptVectorMsg		24
#define ROMCommunicationAreaMsg 	25
#define DOSCommunicationAreaMsg 	26
#if IBMCOPYRIGHT                                                        /*EGH*/
#define IbmbioMsg                       56                              /*EGH*/
#define IbmdosMsg                       57                              /*EGH*/
#else                                                                   /*EGH*/
#define IbmbioMsg                       27
#define IbmdosMsg			28
#endif                                                                  /*EGH*/
#define SystemDataMsg			29
#define SystemProgramMsg		30
#define SystemDeviceDriverMsg		31
#define InstalledDeviceDriverMsg	32
#define SingleDriveMsg			33
#define MultipleDrivesMsg		34
#define ConfigBuffersMsg		35
#define ConfigFilesMsg			36
#define ConfigFcbsMsg			37
#define ConfigStacksMsg 		38
#define ConfigDeviceMsg 		39
#define ConfigIFSMsg			40
#define ConfigLastDriveMsg		41
#define ConfigInstallMsg		45	/* gga */
#define UnownedMsg			42
#define BlankMsg			43
#define HandleMsg			44
#define EXTMemAvlMsg			46	/* ;an001; dms;*/
#define StackMsg			47
#define FreeMsg 			48
#define ProgramMsg			49
#define EnvironMsg			50
#define DataMsg 			51
#define XMSMemAvlMsg			52
#define HMAAvlMsg			53
#define HMANotAvlMsg			54
#define HMADOSMsg			55
#define ROMDOSMsg			58
#define CTtlTitleMsg			59
#define ModUseMsg			60
#define FreeConvMsg			61
#define	CFreeMsg			62
#define CTtlNameMsg			63
#define CTtlUScoreMsg			64
#define FreeTitleMsg			65
#define FreeUScoreMsg			66
#define MainFLineMsg			67
#define CMemFragMsg			68
#define SystemMsg			69
#define FreeSumMsg			70

#define ModNoneMsg			71
#define MainMLineMsg			72
#define ModBarMsg			73
#define ModSumMsg			74
#define ModTitleMsg	75
#define ModUScoreMsg	76
#define MainMXLineMsg	77
#define MainCLineMsg	78
#define MainXLineMsg	79
#define KeyPressMsg	80
#define NoUMBAvailMsg	81

#define Title1AMsg	82
#define Title2AMsg	83
#define ConvMemDet	84
#define UpperMemDet	85

#define MemSumm1Msg	86
#define MemSumm2Msg	87
#define MemLineMsg	88
#define LargeExMsg	89
#define LargeUMBMsg	90
#define ConvMsg		91
#define UpperMsg	92
#define XMSMsg		93
#define EMSMsg		94
#define TotalMsg	95
#define TtlConvMsg	96

#define FreeUpperMsg	97
#define FreeUTitleMsg	98
#define FreeUUScoreMsg	99
#define MainFULineMsg	100

#define MemSumMsg	101
#define SumTitleMsg	102
#define SumUScoreMsg	103
#define SumLineMsg	104

#define AdaptMsg  	105

#define MainMDLineMsg	106  // See 72
#define MainMDXLineMsg	107  // See 77

#define TtlEms		108
#define ModuleName      109

#define Bites           110
#define FreeEms 	111

#define XMSMsgPool	112
#define FreeEMSPool	113
#define PoolMsg1	114
#define PoolMsg2	115

#define	MSG_OPTIONS_FIRST	300
#define	MSG_OPTIONS_LAST	306

#ifdef JAPAN
#define	AdddrvMsg			400
#endif

#define ParseError1Msg			01
#define ParseError10Msg 		10

/************************************************************************/
/*		Message Retriever Standard Equates			*/
/************************************************************************/

#define Ext_Err_Class			0x0001
#define Parse_Err_Class 		0x0002
#define Utility_Msg_Class		0x00ff
#define No_Handle			0xffff
#define No_Replace			0x0000
#define Sublist_Length			0x000b
#define Reserved			0x0000
#define Left_Align			0x0000
#define Right_Align			0x0080
#define Char_Field_Char 		0x0000
#define Char_Field_ASCIIZ		0x0010
#define Unsgn_Bin_Byte			0x0011
#define Unsgn_Bin_Word			0x0021
#define Unsgn_Bin_DWord 		0x0031
#define Sgn_Bin_Byte			0x0012
#define Sgn_Bin_Word			0x0022
#define Sgn_Bin_DWord			0x0032
#define Bin_Hex_Byte			0x0013
#define Bin_Hex_Word			0x0023
#define Bin_Hex_DWord			0x0033
#define No_Input			0x0000
#define STDIN				0x0000
#define STDOUT				0x0001
#define STDERR				0x0002
#define Blank				0x0020

#define CarryFlag			0x0001
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\memex.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */

/*
 * MEMEX.C - expanded and extended memory handling functions for MEM.C.
 *
 */

#include "bios.h"
#include "ctype.h"
#include "conio.h"			/* need for kbhit prototype */
#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"			/* MSKK02 07/18/89 */
#include "mem.h"
#include "xmm.h"
#include "versionc.h"

int IsWindowsRunning (void);

void
GetExtraMemory()
{
   GetEMS();
   GetXMS();
}

void
GetXMS()
{
   int far *ptr;
   long a, b;

   mem_table.hma = -2;	/* Does not exist by default */

   if (IsPre286())
      {
      mem_table.xms_ttl = 0L;
      mem_table.xms_free = 0L;
      return;
      }

   InRegs.x.ax = 0x4300;
   int86x (0x2F, &InRegs, &OutRegs, &SegRegs);

   if (OutRegs.h.al == 0x80)
      {
      InRegs.x.ax = 0x4310;
      int86x (0x2F, &InRegs, &OutRegs, &SegRegs);
      FP_SEG(ptr) = SegRegs.es;
      FP_OFF(ptr) = OutRegs.x.bx;

      a = XMSVersion (ptr);
      b = XMSDriver  (ptr);

      mem_table.xmsMvers = (int)(a / (long)0x100);  // Get version number
      mem_table.xmsmvers = (int)(a % (long)0x100);

      mem_table.xmsMdrvr = (int)(b / (long)0x100);  // Get driver version
      mem_table.xmsmdrvr = (int)(b % (long)0x100);
      }

/*
 * BUGBUG t-richj 11/23/92:  Function 0x52 doesn't return valid XMS # if > 16MB
 *    Previously, MEM was using int 0x21, function 0x52 to obtain the amount
 *    of XMS on the system--this fails on machines with more than 16MB, as does
 *    the semi-documented int 0x15, function 0x88 call.  The only reliable
 *    method to determine the total amount of XMS is to sum each used block
 *    with the amount free (the call for which works properly).  We use the
 *    DOS call here to determine the amount of XMS tenatively; if an XMM
 *    is installed, we will correct the total size of XMS by working with it.
 *
 */

   InRegs.h.ah = (unsigned char) 0x52;
   intdosx(&InRegs,&OutRegs,&SegRegs);

   FP_SEG(SysVarsPtr) = SegRegs.es;
   FP_OFF(SysVarsPtr) = OutRegs.x.bx;
   if (SysVarsPtr->ExtendedMemory != 0)
      {
      mem_table.xms_ttl = (long)SysVarsPtr->ExtendedMemory * 1024L;

      OutRegs.x.cflag = 0;
      InRegs.x.ax = GetExtended;

      int86(CASSETTE, &InRegs, &OutRegs);

      mem_table.int_15h = (long)OutRegs.x.ax * 1024L;

/*
 * subtract out VDisk usage from int15h memory.  Note assumption that
 * VDisk usage doesn't exceed 64Mb.  Don't bother if there is no extended
 * memory.
 *
 */

      if (mem_table.int_15h != 0L)
         mem_table.int_15h -= (long)CheckVDisk() * 1024L;

      // BUGBUG jimmat 1-14-93
      // This has already been done above.  Doing it again voids the
      // vdisk check just before this.

      InRegs.x.ax = 0x8800;
      int86 (0x15, &InRegs, &OutRegs);
      mem_table.int_15h = (long)OutRegs.x.ax *1024L;

/*
 * if an XMS driver is present, INT 15 may return 0 as the amount
 * of extended memory available.  In that case, call the XMS
 * driver to find out the amount of XMS free.  Don't call XMS
 * unconditionally, because that will cause it to claim memory
 * if it has not already done so.
 *
 * However, it is possible, with the newer versions of Himem,
 * for XMS memory and INT 15 memory to coexist.  There is no
 * completely reliable way to detect this situation, but we
 * do know that if Himem is installed, DOS is high, and INT 15
 * memory exists, then we are configured that way.  In that case,
 * we can make calls to Himem without disrupting the memory environment.
 * Otherwise we can't.
 *
 */

      if (XMM_Installed())
         {
	 mem_table.xms_free = XMM_QueryTotalFree() * 1024L;

	 if (!IsWindowsRunning())
	    Correct_Total_XMS ();

	 mem_table.xms_ttl -= mem_table.umb_ttl;

         InRegs.x.ax = 0x3306;		/* get DOS version info */
         intdos(&InRegs, &OutRegs);	/* call DOS */

         mem_table.hma = (OutRegs.h.dh == DOSHMA) + 2*(OutRegs.h.dh == DOSROM);

         if (! mem_table.hma)
	    {
	    mem_table.hma = XMM_RequestHMA(0xffff) ? -1 : 0;
	    if (! mem_table.hma)
	       {
	       XMM_ReleaseHMA();
	       }
	    }
	 }
      }
}

void
GetEMS ()
{
   if (! EMSInstalled())  return;

   InRegs.x.ax = EMSGetFreePgs;
   int86x (EMS, &InRegs, &OutRegs, &SegRegs);

   mem_table.ems_ttl  = (16L*1024L) * OutRegs.x.dx;
   mem_table.ems_free = (16L*1024L) * OutRegs.x.bx;

   InRegs.x.ax = EMSGetVer;
   int86x(EMS, &InRegs, &OutRegs, &SegRegs);
   mem_table.emsMvers = (OutRegs.h.al & 0xF0) >> 4;
   mem_table.emsmvers = (OutRegs.h.al & 0x0F);
}

char EMSInstalled()
{
   unsigned int	EMSStatus;
   unsigned int	EMSVersion;

   char		EmsName[8];
   void far	*EmsNameP;

   InRegs.h.ah = GET_VECT;
   InRegs.h.al = EMS;
   intdosx(&InRegs,&OutRegs,&SegRegs);

   if ((SegRegs.es != 0) && (OutRegs.x.bx != 0))
      {
      EmsNameP = EmsName;
      movedata(SegRegs.es, 0x000a, FP_SEG(EmsNameP), FP_OFF(EmsNameP), 8);
      if (strncmp(EmsName, "EMMXXXX0", 8))
	 return FALSE;

      InRegs.x.ax = EMSGetStat;	 	  		/* get EMS status    */
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      EMSStatus = OutRegs.h.ah; 		  	/* EMS status in AH  */

      InRegs.x.ax = EMSGetVer;		  		/* get EMS version   */
      int86x(EMS, &InRegs, &OutRegs, &SegRegs);
      EMSVersion = OutRegs.h.al;		  	/* EMS version in AL */

      if ((EMSStatus == 0) && (EMSVersion >= DOSEMSVER))
	 return TRUE;
      }

   return FALSE;
}

/*
 * The code below is snitched from xmsinfo.c (thanks, jimmat)
 *
 */

void Correct_Total_XMS()
{
   struct _handle far *lpHandle, far *lpHandleTable;
   unsigned int HandleCount, HandleSize;

/*
 * If we can talk to the XMS driver, we can obtain an accurate amount of
 * total XMS by adding the amount free to the amount used--the amount used
 * being obtained by checking each handle, and summing the size of those
 * marked 'used' (0x02 == hType).
 *
 */

   if (lpHandleTable = HimemHandleTable (&HandleCount,&HandleSize))
      {
      mem_table.xms_ttl  = mem_table.xms_free;
      mem_table.xms_ttl += 0x40 * 1024L;  /* Account for HMA */

      for (lpHandle = lpHandleTable; HandleCount; HandleCount--, lpHandle++)
         {
         if (lpHandle->hType == 0x02)     /* Is this handle used? */
            {
            mem_table.xms_ttl += (long)lpHandle->hLen * 1024L;
            }
         }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\lines.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;
; Check the mode of the console, and return the number of lines available.
; This function is used in MEM's /P command, to determine the number of lines
; to be printed before a keypress is requested.
;
; On error, return 0.

.MODEL	SMALL

include rombios.inc

.CODE

public _get_lines

_get_lines	proc	near
	push	ds
	mov	ax, ROMBIOS_DATA

	mov	ds, ax
	assume	ds:ROMBIOS_DATA

	mov	ah, 0
	mov	al, CRT_ROWS

	pop	ds
	assume	ds:DGROUP

ifndef JAPAN
	inc	al
endif

	cmp	al, 1
	ja	@f
	mov	al, 0	; Indicate an error (like what?)
@@:	ret

_get_lines	endp

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\membase.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */

/*
 * MEMBASE.C - MEM routines for determining and displaying memory usage
 *             for conventional memory.
 */

#include "stdio.h"
#include "dos.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"
#include "mem.h"

#define EMSGetHandleName 0x5300 	/* get handle name function */
#define EMSGetHandlePages 0x4c00	/* get handle name function */
#define EMSCODE_83	0x83		/* handle not found error */
#define EMSMaxHandles	256		/* max number handles */

/*---------------------------------------------------------------------------*/

	    /*
	     * DataLevel:  0 -     Print nothing here
	     *             1 - /C: Print nothing here
	     *             2 - /D: Print everything available
	     *             3 - /F: Print any line with Owner == 0
	     *             4 - /M: Print any line with OwnerName == ModName
	     *
	     * modulesize, below, is only used with options /F and /M.
	     *
	     */

long   modulesize = 0L;            /* Increases... 0== haven't started. */
char  *gpszDevDriver = NULL;
char   Out_Str1[64];
char   Out_Str2[64];
extern unsigned int MaxMin[2];
int   HandleIndex;		      /* used to step through emm386 handles */
char  HandleName[9];		      /* save area for emm386 handle name */

#define K384   (long)(393216)  // 384k, the size of the upper-memory segment
#define ONEMEG (long)(1048576) // 1MB

unsigned int DisplayBaseDetail()
{
   char   temp[128], t2[128];
   struct ARENA far *ThisArenaPtr;
   struct ARENA far *NextArenaPtr;
   struct ARENA far *ThisConfigArenaPtr;
   struct ARENA far *NextConfigArenaPtr;

   struct DEVICEHEADER far *ThisDeviceDriver;

   int   SystemDataType;
   char	 SystemDataOwner[64];

   unsigned long far *UMB_Head_ptr;
   unsigned far *EnvironmentSegmentPtr;

   unsigned int long    Out_Var1;
   unsigned int long    Out_Var2;
   unsigned int long    Org_IOsize;
   unsigned int long    Org_IOaddr;
   unsigned int long    umb_numb = 0L;

   InRegs.h.ah = (unsigned char) 0x52;
   intdosx(&InRegs,&OutRegs,&SegRegs);

   FP_SEG(SysVarsPtr)   = FP_SEG(UMB_Head_ptr) = SegRegs.es;
   FP_OFF(SysVarsPtr)   = OutRegs.x.bx;

   FP_OFF(UMB_Head_ptr) = 0x8c;          /* ptr to UMB_HEAD in DOS Data */ 
   UMB_Head = (*UMB_Head_ptr) & 0xFFFF;

   if (DataLevel == 2)
      {
      mprintf (NewLineMsg, "");
      mprintf (ConvMemDet, "");
      mprintf (NewLineMsg, "");
      mprintf (Title1Msg,  "");
      mprintf (Title2Msg,  "");
      }

   if (DataLevel == 3)
      {
      mprintf (NewLineMsg,    "");
      mprintf (FreeConvMsg,   "");
      mprintf (NewLineMsg,    "");
      mprintf (FreeTitleMsg,  "");
      mprintf (FreeUScoreMsg, "");
      }

   InRegs.h.ah = (unsigned char) 0x30;
   intdos(&InRegs, &OutRegs);

   if ( (OutRegs.h.al != (unsigned char) 3) ||
        (OutRegs.h.ah < (unsigned char) 40) )
      {
      UseArgvZero = TRUE;
      }
   else
      {
      UseArgvZero = FALSE;
      }

		       /* Display stuff below DOS  */

   Out_Var1 = 0l;
   Out_Var2 = 0x3FFl;
   if (AddMem_to_Table (8, Out_Var1, umb_numb, Out_Var2-16))  return 1;
   DoMainLine (8,&Out_Var1,BlankMsg,&Out_Var2,InterruptVectorMsg,&umb_numb);

   Out_Var1 = 0x40l;
   Out_Var2 = 0xFFl;
   if (AddMem_to_Table (8, Out_Var1, umb_numb, Out_Var2-16))  return 1;
   DoMainLine(8,&Out_Var1,BlankMsg,&Out_Var2,ROMCommunicationAreaMsg,&umb_numb);

   Out_Var1 = 0x50l;
   Out_Var2 = 0x1FFl;
   if (AddMem_to_Table (8, Out_Var1, umb_numb, Out_Var2-16))  return 1;
   DoMainLine(8,&Out_Var1,BlankMsg,&Out_Var2,DOSCommunicationAreaMsg,&umb_numb);

	      /* Display the BIO data location and size */

   Out_Var1 = 0x70l;
   Out_Var2 = (long) (FP_SEG(SysVarsPtr) - 0x70)*16L - 16L;
   if (AddMem_to_Table (8, Out_Var1, umb_numb, Out_Var2))  return 1;
   DoMainLine (8, &Out_Var1, IbmbioMsg, &Out_Var2, SystemDataMsg, &umb_numb);

	  /* Display the Base Device Driver Locations and Sizes */

     /*********************************************************************/
     /* to do this get the starting address of the internal driver header */
     /* chain. Start from the first header and get the address of the     */
     /* first header.  Display the driver name and address by calling     */
     /* "DISPLAYDEVICEDRIVER".  Repeat this for next driver on the chain  */
     /* until the last driver.  Note that driver name is in the header.   */
     /* The driver header addrs is in the system variable table from      */
     /* INT 21H fun 52H call.                                             */
     /*********************************************************************/

   BlockDeviceNumber = 0;

   if (DataLevel == 2)
      {
      for (ThisDeviceDriver = SysVarsPtr->DeviceDriverChain;
	   (FP_OFF(ThisDeviceDriver) != 0xFFFF);
	   ThisDeviceDriver = ThisDeviceDriver->NextDeviceHeader)
	 {
	 if ( FP_SEG(ThisDeviceDriver) < FP_SEG(SysVarsPtr) )
	    {
	    strcpy (temp, GetDeviceDriver (ThisDeviceDriver));
	    mprintf (DeviceLineMsg, "%-8c%-m", temp, SystemDeviceDriverMsg);
	    }
	 }
      }

	      /* Display the DOS data location and size */

   FP_SEG(ArenaHeadPtr) = FP_SEG(SysVarsPtr);         /* ;an004; */
   FP_OFF(ArenaHeadPtr) = FP_OFF(SysVarsPtr) - 2;     /* ;an004; */
   FP_SEG(ThisArenaPtr) = *ArenaHeadPtr;              /* ;an004; */
   FP_OFF(ThisArenaPtr) = 0;                          /* ;an004; */

   Out_Var1 = (long) FP_SEG(SysVarsPtr);
   Out_Var2 = (long) (AddressOf((char far *)ThisArenaPtr) - Out_Var1)*16L -16L;
   if (AddMem_to_Table (8, Out_Var1, umb_numb, Out_Var2))  return (1);
   DoMainLine (8, &Out_Var1, IbmdosMsg, &Out_Var2, SystemDataMsg, &umb_numb);

		    /* Display the memory data */

/******************************************************************************
/*
/* IO.SYS data area contains BUFFERS, FCBs, LAST DRIVE etc.  They are contained
/* in a one huge memory block.  This block has a seg iD 0008.  This seg ID can
/* be found from the block header owner area.  This seg id 0008:0000
/* points to the buffer table as shown below.  If seg id is 0008:000, then
/* using the seg id find the table.  Each entry is contained in a sub block
/* within the main block.  Each sub block has header and this header contains
/* id such as B for BUFFER,  X for FCBs,  I for IFS,  D for external device
/* drivers.  Go through the sub blocks and display the name ans size. that's it.
/*
/* If the block contains D, then it contains external drivers.  The driver name
/* is not in the sub block.  So we have to find the driver name from the driver
/* header chain.  To do this get the address of the driver chain from system
/* variable table from INT 21H FN 52H call.  Go through the chain and find out
/* the name.  Display name from the header and the size we got from the sub
/* block.
/*
/*
/* After this main block, comes other buffer blocks which contains programs
/* such as command.com, doscolor, even MEM.  From these blocks, get the program
/* name and the size and display them too.
/*
/* 0008:000->------------------          -------------------
/*           | BUFFERS        | -------->|B (signature)    | Block header
/*           ------------------          -------------------
/*           | FCBs           | --       |                 |
/*           ------------------   |      | Buffers data    |
/*           | IFSs           |   |      |                 |
/*           ------------------   |      |                 |
/*           | LAST DRIVE     |   |      |                 |
/*           ------------------   |      -------------------
/*           | EXTERN DRIVER 1|   |
/*           ------------------   |          -------------------
/*           | EXTERN DRIVER 2|   | -------->|X (signature)    | Block header
/*           ------------------              -------------------
/*           | EXTERN DRIVER 3|              |                 |
/*           ------------------              | Buffers data    |
/*                                           |                 |
/*                                           |                 |
/*                                           |                 |
/*                                           -------------------
/*
/* For DOS 5.0, there are some additions to the above.	Basically, we have
/* three possible memory maps, to wit:
/*
/*    DOS Loads Low			     DOS loads high
/*    70:0 - BIOS data			     70:0 - BIOS data
/*	     DOS data				    DOS data
/*	     BIOS + DOS code			    Sysinit data (arena name SD)
/*	       (arena owner 8, name "SC")	    VDisk header (arena name SC)
/*	     Sysinit data (arean owner 8, name SD)
/*
/*    DOS tries to load high but fails
/*    70:0 - BIOS data
/*	     DOS data
/*	     Sysinit data (arena name SD)
/*	     DOS + BIOS code (arena name SC)
/*
/*    We have to detect the special arena ownership marks and display them
/*    correctly.  Everything after DOS and BIOS data should have an arena header
/******************************************************************************/

   for (;;)
      {

#ifdef JAPAN
      if (ThisArenaPtr->Owner == 8 || ThisArenaPtr->Owner == 9)
#else
      if (ThisArenaPtr->Owner == 8)
#endif
	 {

	 FP_SEG(NextArenaPtr)=FP_SEG(ThisArenaPtr) +ThisArenaPtr->Paragraphs +1;
	 FP_OFF(NextArenaPtr)=0;

	 Out_Var1 = AddressOf((char far *)ThisArenaPtr);
	 Out_Var2 = (long) (ThisArenaPtr -> Paragraphs) * 16l;
	 if (ThisArenaPtr->OwnerName[0] == 'S' &&
	     ThisArenaPtr->OwnerName[1] == 'C')
	    {
	            /* display message for BIOS and DOS code */

	    if ((long)FP_SEG (ThisArenaPtr) >= (long)UMB_Head)
	       {
	       umb_numb++;

	       if (DataLevel == 2)
		  {
		  mprintf (NewLineMsg, "");

	          if (umb_numb == 1)
		     {
		     mprintf(UpperMemDet, "");
		     mprintf(NewLineMsg,  "");
		     mprintf(Title1AMsg,  "");
		     mprintf(Title2AMsg,  "");
		     }
                  }
	       }
	    else
	       {
	       if (AddMem_to_Table (8,Out_Var1,umb_numb,Out_Var2))
	          return(1);

	       DoMainLine (8, &Out_Var1, IbmdosMsg, &Out_Var2,
		              SystemProgramMsg, &umb_numb);
	       }
	    }
	 else if (ThisArenaPtr->OwnerName[0] == 'H')
	    {

	    if (AddMem_to_Table (0, Out_Var1, umb_numb, Out_Var2))
	       return(1);

/*
 * this block has been hidden via loadhigh for loading mem ... display it as
 * LOADHIGH / Temporarily Restricted
 *
 *          DoMainLine(0,&Out_Var1,LoadHighMsg,&Out_Var2,HiddenMsg,&umb_numb);
 *
 * That line removed in favor of making it all look more like free memory:
 *
 */

            DoMainLine (0,&Out_Var1,LoadHighMsg,&Out_Var2,FreeMsg,&umb_numb); 

	    }
	 else
	    {

/*
 * display message for data (8+SD)
 *
 */

            Org_IOaddr = Out_Var1;
            Org_IOsize = Out_Var2;

	    DoMainLine(8,&Out_Var1,IbmbioMsg,&Out_Var2,SystemDataMsg,&umb_numb);

	    FP_SEG(ThisConfigArenaPtr) = FP_SEG(ThisArenaPtr) +1;
	    FP_OFF(ThisConfigArenaPtr) = 0;

	    while ( (FP_SEG(ThisConfigArenaPtr) > FP_SEG(ThisArenaPtr)) &&
		    (FP_SEG(ThisConfigArenaPtr) < FP_SEG(NextArenaPtr)))
	       {

	       if (ThisConfigArenaPtr->Signature=='D' ||
	           ThisConfigArenaPtr->Signature=='I')
		  {
		  strcpy (SystemDataOwner, OwnerOf (ThisConfigArenaPtr));
		  }
	       else
		  {
		  strcpy (SystemDataOwner, " ");
		  }

	       switch (ThisConfigArenaPtr->Signature)
		  {
		  case 'B':  SystemDataType = ConfigBuffersMsg;          break;
		  case 'D':  SystemDataType = InstalledDeviceDriverMsg;  break;
		  case 'F':  SystemDataType = ConfigFilesMsg;            break;
		  case 'I':  SystemDataType = ConfigIFSMsg;              break;
		  case 'L':  SystemDataType = ConfigLastDriveMsg;        break;
		  case 'S':  SystemDataType = ConfigStacksMsg;           break;
		  case 'T':  SystemDataType = ConfigInstallMsg;          break;
		  case 'X':  SystemDataType = ConfigFcbsMsg;             break;
		  default:   SystemDataType = BlankMsg;                  break;
		  }

/*
 *  Found one, now display the owner name and size
 *
 */

	       if (SystemDataType != BlankMsg)
		  {
		  Out_Var1 = ((long) ThisConfigArenaPtr -> Paragraphs) * 16l;
		  sprintf (temp, "(%ldK)", toK(Out_Var1));
		  NextConfigArenaPtr = ThisConfigArenaPtr;
		  FP_SEG(NextConfigArenaPtr)+=NextConfigArenaPtr->Paragraphs+1;
		  if (ThisConfigArenaPtr->Signature == (char)'D')
		     {
		     FP_SEG(ThisDeviceDriver) = FP_SEG(ThisConfigArenaPtr) + 1;
		     FP_OFF(ThisDeviceDriver) = 0;

		     strcpy (t2, GetDeviceDriver (ThisDeviceDriver));

		     ThisDeviceDriver = ThisDeviceDriver->NextDeviceHeader;
		     }
		  else
		     {
		     strcpy (SystemDataOwner, DriverData (ThisConfigArenaPtr));
                     strcpy (t2,              " ");
		     }

		 if (ThisConfigArenaPtr->Signature=='D' ||
		     ThisConfigArenaPtr->Signature=='I')
		     {
		     Org_IOsize -= Out_Var1;
		     gpszDevDriver = SystemDataOwner;
		     AddMem_to_Table (7, Org_IOaddr, umb_numb, Out_Var1);
		     DoMainLine (7, &Org_IOaddr, 0, &Out_Var1,
		                 SystemDataType, &umb_numb);
		     }

		  if (DataLevel == 2)
		     {
		     mprintf (DriverLineMsg, "%8ld%7c%-8c%-m%-c",
			&Out_Var1, temp, t2, SystemDataType, SystemDataOwner);
		     }
		  }

	       FP_SEG(ThisConfigArenaPtr) += ThisConfigArenaPtr->Paragraphs +1;
	       }

/*
 * Now that we've added memory for each device driver, add whatever's left.
 *
 */

	    AddMem_to_Table (8, Org_IOaddr, umb_numb, Org_IOsize);
	    }
	 }
      else
         {

 /****************************************************************************/
 /* If not BIOS table, it is a program like MEM, etc.			    */
 /* calculate the size of the block occupied by the program and display prog */
 /* name and size                                                            */
 /****************************************************************************/

	 Out_Var1 = AddressOf((char far *)ThisArenaPtr);
	 Out_Var2 = ((long) (ThisArenaPtr -> Paragraphs)) * 16l;
	 strcpy(Out_Str1,OwnerOf(ThisArenaPtr));
	 strcpy(Out_Str2,TypeOf(ThisArenaPtr));
	 gpszDevDriver = Out_Str1;

	 /* We don't want to include mem's environment space into the
	  * computations. Since this environment space is allocated to
	  * running other programs, it really isn't part of free memory.
	  */

	  FP_SEG(EnvironmentSegmentPtr) = ThisArenaPtr->Owner;
	  FP_OFF(EnvironmentSegmentPtr) = 44;

	  if (!((_psp == ThisArenaPtr->Owner) &&
		(*EnvironmentSegmentPtr == FP_SEG(ThisArenaPtr)+1) ))
	     if (AddMem_to_Table (ThisArenaPtr->Owner,Out_Var1,umb_numb,Out_Var2))
		return(1);

	 DoMainLine_a (ThisArenaPtr->Owner, &Out_Var1, Out_Str1,
	               &Out_Var2, Out_Str2, &umb_numb); 
	 }

      if (ThisArenaPtr->Signature == (char)'Z')
         break;

      FP_SEG(ThisArenaPtr) += ThisArenaPtr->Paragraphs + 1;
      }

   if (DataLevel == 4)
      {
      if (! modulesize)
         {
         mprintf (ModNoneMsg, "%-c", ModName);
	 }
      else
         {
	 mprintf (ModBarMsg, "");
	 sprintf (temp, "(%ldK)", toK(modulesize));
	 mprintf (ModSumMsg, "%8ld%7c", &modulesize, temp);
	 }
      }

   if (DataLevel == 3)
      {
      mprintf (NewLineMsg, "");
      sprintf (temp, "(%ldK)", toK(modulesize));
      mprintf (FreeSumMsg, "%7ld%7c", &modulesize, temp);

      DisplayFree();
      }

   return(0);
}

void
DisplayFree ()
{
   char  temp1[30], temp2[30], temp3[30];
   long  i;

   mprintf (NewLineMsg, "");
   if (mem_table.umbs[0].umb_ttl == 0L)
      {
      mprintf (NoUMBAvailMsg, "");
      return;
      }

   mprintf (FreeUpperMsg,   "");
   mprintf (NewLineMsg,     "");
   mprintf (FreeUTitleMsg,  "");
   mprintf (FreeUUScoreMsg, "");

   for (i = 1; i < MAX_CLDATA_INDEX; i++)
      {
      if (mem_table.umbs[i-1].umb_ttl == 0L)  break;

      sprintf (temp1, "(%ldK)", toK (mem_table.umbs[i-1].umb_large));
      sprintf (temp2, "(%ldK)", toK (mem_table.umbs[i-1].umb_free));
      sprintf (temp3, "(%ldK)", toK (mem_table.umbs[i-1].umb_ttl));

      mprintf (MainFULineMsg, "%3ld%7ld%6c%7ld%6c%7ld%6c", &i,
               &mem_table.umbs[i-1].umb_large, temp1,
               &mem_table.umbs[i-1].umb_free,  temp2,
               &mem_table.umbs[i-1].umb_ttl,   temp3);
      }
}

/*---------------------------------------------------------------------------*/

char *GetDeviceDriver    (ThisDeviceDriver)
struct DEVICEHEADER far  *ThisDeviceDriver;
{
   static char  LocalDeviceName[16];
   int          i;

   if (((ThisDeviceDriver->Attributes) & 0x8000 ) != 0)
      {
      for (i = 0; i < 8; i++)  LocalDeviceName[i] = ThisDeviceDriver->Name[i];
      LocalDeviceName[8] = NUL;
      }
   else
      {
      if ((int)ThisDeviceDriver->Name[0] == 1)
         {
	 sprintf (&LocalDeviceName[0], SingleDrive, 'A'+BlockDeviceNumber);
         }
      else
         {
         sprintf (&LocalDeviceName[0], MultipleDrives, 'A'+BlockDeviceNumber,
	       'A'+BlockDeviceNumber + ((int)ThisDeviceDriver->Name[0]) -1);
         }

      BlockDeviceNumber += (int)(ThisDeviceDriver->Name[0]);
      }

   return LocalDeviceName;
}

/*---------------------------------------------------------------------------*/

void GetSummary()
{
   long    extra;
   long    total_mem;

   char	far *CarvedPtr;
   struct PSP_STRUC
      {
      unsigned int	int_20;
      unsigned int	top_of_memory;
      };
   struct PSP_STRUC far *PSPptr;

   /* Adjust for XBDA size */
   /* XBDA size should be added to total mem size reported by INT 12 */
   /* IFF XBDA is placed just at the end of conv.mem */
   /* IF EMM386 or QEMM is loaded, XBDA gets relocated to EMM driver mem */
   /* and int 12 reports correct size of memory in this case */
   InRegs.x.bx = 0;
   InRegs.x.ax = 0xc100;
   int86x(0x15, &InRegs, &OutRegs, &SegRegs);
   if (OutRegs.x.cflag == 0)
      {
      if (mem_table.conv_ttl == (unsigned long)((long)SegRegs.es) * 16l)
         {
	 FP_SEG(CarvedPtr) = SegRegs.es;
	 FP_OFF(CarvedPtr) = 0;
	 mem_table.conv_ttl += ((unsigned long int)(*CarvedPtr) * 1024l);
	 }
      }

   InRegs.h.ah = GET_PSP;
   intdos(&InRegs,&OutRegs);

   FP_SEG(PSPptr) = OutRegs.x.bx;
   FP_OFF(PSPptr) = 0;

	       /* Get total memory in system */

   int86 (MEMORY_DET,&InRegs,&OutRegs);

   mem_table.conv_ttl = (unsigned long int) OutRegs.x.ax * 1024l;
   mem_table.rom_ttl  = 0L;

   GetExtraMemory();  /* Get XMS/EMS information */

   if (mem_table.umb_ttl || mem_table.xms_ttl)
      {
      total_mem = mem_table.conv_ttl + mem_table.umb_ttl + mem_table.xms_ttl;

      if ((extra = ONEMEG - (total_mem % ONEMEG)) <= K384)
	 {
	 mem_table.rom_ttl = extra;
	 }
      }
}

void DispMEMSummary()
{
   char      temp1[40], temp2[40], temp3[40];
   char      far *fpBytes;
   long      used, t_used, t_ttl, t_free, c_used;
   int	     fPooled;

   // EMS is 'pooled' with XMS if this is a recent enough version of
   // EMM386 (fIsPooled) and the min and max EMS pool sizes are different.

   fPooled = fIsPooled() && (MaxMin[0] != MaxMin[1]) && EMSInstalled();

   mprintf (NewLineMsg,  "");
   mprintf (MemSumm1Msg, "");
   mprintf (MemSumm2Msg, "");

   t_used = c_used = 0L;

   used = mem_table.conv_ttl - mem_table.conv_free;
   t_used += used;
   sprintf (temp1, "%ldK", toK (mem_table.conv_ttl));
   sprintf (temp2, "%ldK", toK (used));
   sprintf (temp3, "%ldK", toK (mem_table.conv_free));
   mprintf (MemLineMsg, MemFormat, ConvMsg, temp1, temp2, temp3);

   used = mem_table.umb_ttl - mem_table.umb_free;
   t_used += used;
   sprintf (temp1, "%ldK", toK (mem_table.umb_ttl));
   sprintf (temp2, "%ldK", toK (used));
   sprintf (temp3, "%ldK", toK (mem_table.umb_free));
   mprintf (MemLineMsg, MemFormat, UpperMsg, temp1, temp2, temp3);

   c_used = t_used;
   used = mem_table.rom_ttl;
   t_used += used;
   sprintf (temp1, "%ldK", toK (mem_table.rom_ttl));
   sprintf (temp2, "%ldK", toK (mem_table.rom_ttl));
   sprintf (temp3, "%ldK", toK (0L));
   mprintf (MemLineMsg, MemFormat, AdaptMsg, temp1, temp2, temp3);

   used = mem_table.xms_ttl - mem_table.xms_free;
   t_used += used;
   sprintf (temp1, "%ldK", toK (mem_table.xms_ttl));
   sprintf (temp2, "%ldK", toK (used));
   sprintf (temp3, "%ldK", toK (mem_table.xms_free));
   if (fPooled)
      mprintf (MemLineMsg, MemFormat, XMSMsgPool, temp1, temp2, temp3);
   else
      mprintf (MemLineMsg, MemFormat, XMSMsg, temp1, temp2, temp3);

   mprintf (MemSumm2Msg, "");

   t_ttl  = mem_table.conv_ttl  + mem_table.umb_ttl  + mem_table.rom_ttl +
	    + mem_table.xms_ttl;
   t_free = mem_table.conv_free + mem_table.umb_free +
	    + mem_table.xms_free ;
   sprintf (temp1, "%ldK", toK (t_ttl));
   sprintf (temp2, "%ldK", toK (t_used));
   sprintf (temp3, "%ldK", toK (t_free));
   mprintf (MemLineMsg, MemFormat, TotalMsg, temp1, temp2, temp3);

   mprintf (NewLineMsg, "");
   t_ttl  = mem_table.conv_ttl  + mem_table.umb_ttl;
   t_free = mem_table.conv_free + mem_table.umb_free;
   sprintf (temp1, "%ldK", toK (t_ttl));
   sprintf (temp2, "%ldK", toK (c_used));
   sprintf (temp3, "%ldK", toK (t_free));
   mprintf (MemLineMsg, MemFormat, TtlConvMsg, temp1, temp2, temp3);

   mem_table.conv_large -= 16;  /* They can't use the header area */

   mprintf (NewLineMsg, "");

   /* Always print the ems total and free values from int 67/42 */
   if (mem_table.ems_ttl != 0) {
       sprintf (temp1, "%ldK", toK (mem_table.ems_ttl));
       sprintf (temp2, "(%ld bytes)  ", mem_table.ems_ttl);
       mprintf (TtlEms, "%6c%17c", temp1, temp2);

       sprintf (temp1, "%ldK", toK (mem_table.ems_free));
       sprintf (temp2, "(%ld bytes)  ", mem_table.ems_free);
       mprintf (fPooled ? FreeEMSPool : FreeEms, "%6c%17c", temp1, temp2);
       mprintf (NewLineMsg, "");
   }

   /* If EMS and XMS are shared, display the available EMS may vary disclaimer.
    */

   if (fPooled) {
      mprintf (PoolMsg1, "");
      mprintf (PoolMsg2, "");
      mprintf (NewLineMsg, "");
   }

   InRegs.x.ax = Bites;
   InRegs.h.dh = Utility_Msg_Class;
   sysgetmsg(&InRegs,&SegRegs,&OutRegs);
   FP_OFF(fpBytes) = OutRegs.x.si;
   FP_SEG(fpBytes) = SegRegs.ds;

   sprintf (temp1, "%ldK", toK (mem_table.conv_large));
   sprintf (temp2, "(%ld %s)  ", mem_table.conv_large, fpBytes);
   mprintf (LargeExMsg,  "%6c%17c", temp1, temp2);
   sprintf (temp1, "%ldK", toK (mem_table.umb_large));
   sprintf (temp2, "(%ld %s)  ", mem_table.umb_large, fpBytes);
   mprintf (LargeUMBMsg, "%6c%17c", temp1, temp2);

   switch (mem_table.hma)
      {
      case -2:	break;		 /* HMA doesn't exist, don't print anything */
      case -1:	mprintf (HMANotAvlMsg, "");  break; /* exists, but used */
      case  0:	mprintf (HMAAvlMsg,    "");  break; /* exists and free */
      case  1:	mprintf (HMADOSMsg,    "");  break; /* in use by MSDOS */
      default:	mprintf (ROMDOSMsg,    "");  break; /* in use by ROM DOS */
      }

   return;
}

void DisplaySummary()
{
   unsigned long int HandleMem; 	 /* memory associated w/handle */
   char  TitlesPrinted = FALSE; 	 /* flag for printing titles */

   char  temp1[40], temp2[40], temp3[40];
   long  used, t_used, t_ttl, t_free, c_used;
   int   fPooled;

   // EMS is 'pooled' with XMS if this is a recent enough version of
   // EMM386 (fIsPooled) and the min and max EMS pool sizes are different.

   fPooled = fIsPooled() && (MaxMin[0] != MaxMin[1]) && EMSInstalled();

   mprintf (NewLineMsg,   "");
   mprintf (MemSumMsg,    "");
   mprintf (NewLineMsg,   "");
   mprintf (SumTitleMsg,  "");
   mprintf (SumUScoreMsg, "");

   t_used = c_used = 0L;

   used = mem_table.conv_ttl - mem_table.conv_free;
   t_used += used;
   sprintf (temp1, "(%ldK)", toK (mem_table.conv_ttl));
   sprintf (temp2, "(%ldK)", toK (used));
   sprintf (temp3, "(%ldK)", toK (mem_table.conv_free));
   mprintf (SumLineMsg, SumFormat, ConvMsg,
            &mem_table.conv_ttl, temp1, &used, temp2,
            &mem_table.conv_free, temp3);

   used = mem_table.umb_ttl - mem_table.umb_free;
   t_used += used;
   sprintf (temp1, "(%ldK)", toK (mem_table.umb_ttl));
   sprintf (temp2, "(%ldK)", toK (used));
   sprintf (temp3, "(%ldK)", toK (mem_table.umb_free));
   mprintf (SumLineMsg, SumFormat, UpperMsg,
            &mem_table.umb_ttl, temp1, &used, temp2,
            &mem_table.umb_free, temp3);

   c_used = t_used;

   t_used += mem_table.rom_ttl;
   used = 0L;
   sprintf (temp1, "(%ldK)", toK (mem_table.rom_ttl));
   sprintf (temp2, "(%ldK)", toK (mem_table.rom_ttl));
   sprintf (temp3, "(%ldK)", toK (0L));
   mprintf (SumLineMsg, SumFormat, AdaptMsg,
            &mem_table.rom_ttl, temp1, &mem_table.rom_ttl, temp2,
            &used, temp3);

   used = mem_table.xms_ttl - mem_table.xms_free;
   t_used += used;
   sprintf (temp1, "(%ldK)", toK (mem_table.xms_ttl));
   sprintf (temp2, "(%ldK)", toK (used));
   sprintf (temp3, "(%ldK)", toK (mem_table.xms_free));
   if (fPooled)
      mprintf (SumLineMsg, SumFormat, XMSMsgPool,
	       &mem_table.xms_ttl, temp1, &used, temp2,
	       &mem_table.xms_free, temp3);
   else
      mprintf (SumLineMsg, SumFormat, XMSMsg,
	       &mem_table.xms_ttl, temp1, &used, temp2,
	       &mem_table.xms_free, temp3);

   mprintf (SumUScoreMsg, "");

   t_ttl  = mem_table.conv_ttl  + mem_table.umb_ttl  + mem_table.rom_ttl +
	    + mem_table.xms_ttl;
   t_free = mem_table.conv_free + mem_table.umb_free +
	    + mem_table.xms_free ;
   sprintf (temp1, "(%ldK)", toK (t_ttl));
   sprintf (temp2, "(%ldK)", toK (t_used));
   sprintf (temp3, "(%ldK)", toK (t_free));
   mprintf (SumLineMsg, SumFormat, TotalMsg,
                 &t_ttl, temp1, &t_used, temp2, &t_free, temp3);

   mprintf (NewLineMsg, "");
   t_ttl  = mem_table.conv_ttl  + mem_table.umb_ttl;
   t_free = mem_table.conv_free + mem_table.umb_free;
   sprintf (temp1, "(%ldK)", toK (t_ttl));
   sprintf (temp2, "(%ldK)", toK (c_used));
   sprintf (temp3, "(%ldK)", toK (t_free));
   mprintf (SumLineMsg, SumFormat, TtlConvMsg,
                 &t_ttl, temp1, &c_used, temp2, &t_free, temp3);
   mprintf (NewLineMsg, "");

   /* if ems is install or no NOEMS, then display the handles */
   if (EMSInstalled() && (DataLevel == 2)) {
       HandleName[0] = NUL;	      /* initialize the array	      */

       mprintf (NewLineMsg,   "");

       segread(&SegRegs);

       SegRegs.es = SegRegs.ds;

       for (HandleIndex = 0; HandleIndex < EMSMaxHandles; HandleIndex++)
       {

	   InRegs.x.ax = EMSGetHandleName;     /* get handle name */
	   InRegs.x.dx = HandleIndex;	       /* handle in question */
	   InRegs.x.di = (unsigned int) HandleName;    /* point to handle name */
	   int86x(EMS, &InRegs, &OutRegs, &SegRegs);

	   HandleName[8] = NUL; 	       /* make sure terminated w/nul */

	   if (OutRegs.h.ah != EMSCODE_83)
	   {
	       InRegs.x.ax = EMSGetHandlePages;  /* get pages assoc w/this handle */
	       InRegs.x.dx = HandleIndex;
	       int86x(EMS, &InRegs, &OutRegs, &SegRegs);
	       HandleMem = OutRegs.x.bx;
	       HandleMem *= (long) (16l*1024l);

	       if (!TitlesPrinted)
	       {
		   mprintf (Title3Msg,	 "");
		   mprintf (Title4Msg,	 "");
		   TitlesPrinted = TRUE;
	       }

	       if (HandleName[0] == NUL)
		   strcpy(HandleName,"        ");

	       mprintf (HandleMsg, "%4d%8c%6lx", &HandleIndex, HandleName, &HandleMem);
	   }
       }  /* end   for (HandleIndex = 0; HandleIndex < EMSMaxHandles;HandleIndex++) */

       mprintf (NewLineMsg,   "");
   }

   /* Always print the ems total and free values from int 67/42 */
   if (mem_table.ems_ttl != 0) {
       /* print the total and free ems lines */
       sprintf (temp1, "(%ldK)", toK (mem_table.ems_ttl));
       sprintf (temp2, "%8.8s", temp1);
       NoCR = 1;
       mprintf (SpaceOverMsg, "");
       mprintf (TtlEms,  "%10ld%8c", &mem_table.ems_ttl, temp2);

       sprintf (temp1, "(%ldK)", toK (mem_table.ems_free));
       sprintf (temp2, "%8.8s", temp1);
       NoCR = 1;
       mprintf (SpaceOverMsg, "");
       mprintf (fPooled ? FreeEMSPool : FreeEms,  "%10ld%8c", &mem_table.ems_free, temp2);
   }


   /* If EMS and XMS are shared, display the available EMS may vary disclaimer.
    */

   if (fPooled) {

       mprintf (NewLineMsg,   "");

       NoCR = 1;
       mprintf (SpaceOverMsg, "");
       mprintf (PoolMsg1, "");

       NoCR = 1;
       mprintf (SpaceOverMsg, "");
       mprintf (PoolMsg2, "");

       mprintf (NewLineMsg, "");
   }


   if (DataLevel == 2)
      {
      sprintf (temp1, "(%ldK)", toK (mem_table.int_15h));
      sprintf (temp2, "%8.8s", temp1);
      NoCR = 1;  mprintf (SpaceOverMsg, "");
      mprintf (Int15MemoryMsg, "%10ld%8c", &mem_table.int_15h, temp2);
      }

   mem_table.conv_large -= 16;  /* They can't use the header area */
   sprintf (temp1, "(%ldK)", toK (mem_table.conv_large));
   sprintf (temp2, "%8.8s", temp1);
   NoCR = 1;  mprintf (SpaceOverMsg, "");
   mprintf (LargeExMsg,  "%10ld%8c", &mem_table.conv_large, temp2);

   sprintf (temp1, "(%ldK)", toK (mem_table.umb_large));
   sprintf (temp2, "%8.8s", temp1);
   NoCR = 1;  mprintf (SpaceOverMsg, "");
   mprintf (LargeUMBMsg, "%10ld%8c", &mem_table.umb_large, temp2);

   NoCR = 1;  mprintf (SpaceOverMsg, "");
   switch (mem_table.hma)
      {
      case -2:	break;
      case -1:  mprintf (HMANotAvlMsg, "");  break;
      case  0:  mprintf (HMAAvlMsg,    "");  break;
      case  1:  mprintf (HMADOSMsg,    "");  break;
      default:  mprintf (ROMDOSMsg,    "");  break;
      }

   if (DataLevel == 2)
      {
      used = 0;  /* Okay, a second use for this thing... */
      if (mem_table.xmsMvers != 0)
         {
	 mprintf (NewLineMsg, "");
	 sprintf (temp1, "%d.%02d", mem_table.xmsMvers, mem_table.xmsmvers);
	 sprintf (temp2, "%d.%02d", mem_table.xmsMdrvr, mem_table.xmsmdrvr);
	 mprintf (XMSVersionMsg, "%5c%5c", temp1, temp2);
	 used = 1;
	 }
      if (mem_table.emsMvers != 0)
         {
	 if (! used)  mprintf (NewLineMsg, "");
	 sprintf (temp1, "%d.%02d", mem_table.emsMvers, mem_table.emsmvers);
	 mprintf (EMSVersionMsg, "%5c", temp1);
	 }
      }

   return;
}

/*---------------------------------------------------------------------------*/

char *OwnerOf    (ArenaPtr)
struct ARENA far *ArenaPtr;
{
   char        far *StringPtr;
   char	           *o;
   unsigned    far *EnvironmentSegmentPtr;
   unsigned         PspSegment;
   int	            i, fPrintable;

    o = &OwnerName[0];
   *o = NUL;
   strcpy (o, UnOwned);

   PspSegment = ArenaPtr->Owner;

   if (PspSegment == 0)
      sprintf(o,Ibmdos);
   else
      if (PspSegment == 8)
	 sprintf (o, Ibmbio);
      else
	 {
	 FP_SEG(ArenaPtr) = PspSegment-1;   /* Arena is 16 bytes before PSP */
	 StringPtr = (char far *) &(ArenaPtr -> OwnerName[0]);

	 /* M002 BEGIN
	  * Chars below 0x20 (Space) and char 0x7f are not printable in US
	  * and European Code pages.  The following code checks for them and
	  * does not print such names.  - Nagara 11/20/90
	  */

	 fPrintable = TRUE;

#ifndef DBCS
	 for (i = 0; i < 8;i++,StringPtr++)
	    {
	    if ((*StringPtr < 0x20) | (*StringPtr == 0x7f))
	       {  
		      /* unprintable char ? */	
	       if (*StringPtr)  fPrintable = FALSE;	
	       break;
	       }
	    }
#endif

	 if (fPrintable)
	    {
	    StringPtr = (char far *) &(ArenaPtr->OwnerName[0]);
	    for (i = 0; i < 8;i++)
	       *o++ = *StringPtr++;
	    *o = NUL;
	    }
	 /* M002 END */

	 }

   if (UseArgvZero)  GetFromArgvZero (PspSegment, EnvironmentSegmentPtr);

   return (&OwnerName[0]);
}

/*---------------------------------------------------------------------------*/

void GetFromArgvZero (PspSegment, EnvironmentSegmentPtr)
unsigned              PspSegment;
unsigned                     far *EnvironmentSegmentPtr;
{
   char	    far *StringPtr;
   char	        *OutputPtr;
   unsigned far *WordPtr;

   OutputPtr = &OwnerName[0];

   if (UseArgvZero)
      {
      if (PspSegment < FP_SEG(ArenaHeadPtr))
	 {
	 if (*OutputPtr == NUL)  sprintf (OutputPtr,Ibmdos);
	 }
      else
	 {
	 FP_SEG(EnvironmentSegmentPtr) = PspSegment;
	 FP_OFF(EnvironmentSegmentPtr) = 44;

	      /*  FP_SEG(StringPtr) = *EnvironmentSegmentPtr; */

	 FP_SEG(StringPtr) = FP_SEG(EnvironmentSegmentPtr);
	 FP_OFF(StringPtr) = 0;

	 while ((*StringPtr != NUL) || (*(StringPtr+1) != NUL))  StringPtr++;

	 StringPtr += 2;
	 WordPtr    = (unsigned far *)StringPtr;

	 if (*WordPtr == 1)
	    {
	    StringPtr += 2;
	    while (*StringPtr != NUL)
	       *OutputPtr++ = *StringPtr++;
	    *OutputPtr++ = NUL;

	    while (OutputPtr > &OwnerName[0])
	       {
	       if (*OutputPtr == (char) '.')
	          *OutputPtr = NUL;
	       if ((*OutputPtr == (char) '\\') || (*OutputPtr == (char) ':'))
		  {
		  OutputPtr++;
		  break;
		  }
	       OutputPtr--;
	       }
	    }
	 }
      }

   strcpy (&OwnerName[0], OutputPtr);

   return;
}

/*---------------------------------------------------------------------------*/

char *TypeOf     (Header)
struct ARENA far *Header;
{
   char	        *t;
   unsigned      PspSegment;
   unsigned far *EnvironmentSegmentPtr;
   unsigned int  Message_Number;
   char far     *Message_Buf;
   unsigned int  i;

   t = &TypeText[0];
   *t = NUL;

   Message_Number = 0xff;
   if (Header->Owner == 8)  Message_Number = StackMsg;
   if (Header->Owner == 0)  Message_Number = FreeMsg;

   PspSegment = Header -> Owner;
   if (PspSegment < FP_SEG(ArenaHeadPtr))
      {
      if (Message_Number == 0xff)  Message_Number = BlankMsg;
      }
   else
      {
      FP_SEG(EnvironmentSegmentPtr) = PspSegment;
      FP_OFF(EnvironmentSegmentPtr) = 44;

      if (PspSegment == FP_SEG(Header)+1)
	 Message_Number = ProgramMsg;
      else
         if (*EnvironmentSegmentPtr == FP_SEG(Header)+1)
	    Message_Number = EnvironMsg;
	 else
	    Message_Number = DataMsg;
      }

   InRegs.x.ax = Message_Number;
   InRegs.h.dh = Utility_Msg_Class;
   sysgetmsg(&InRegs,&SegRegs,&OutRegs);

   FP_OFF(Message_Buf)    = OutRegs.x.si;
   FP_SEG(Message_Buf)    = SegRegs.ds;

   i = 0;
   while (*Message_Buf != NUL)
      TypeText[i++] = *Message_Buf++;
   TypeText[i++] = NUL;

   return(t);
}

/************************************************************************/
/* DisplayClassification						*/
/*	Main display proc for /C switch 				*/
/*									*/	
/* ENTRY:	none							*/
/*									*/	
/* EXIT:	none 							*/
/*									*/
/*									*/
/* CAVEATS:								*/
/*	Arenas owned by MEM are marked as FREE				*/	
/*									*/	
/*	display memory break up for conventional and upper memory	*/
/*									*/	
/************************************************************************/

void DisplayClassification()
{

   int               i, msgtype, dd;
   unsigned long     memsize;
   char             *nameptr;
   char              temp1[12], temp2[12], temp3[12];
   struct ARENA far *ArenaPtr;

   mprintf (NewLineMsg,    "");
   mprintf (CTtlTitleMsg,  "");
   mprintf (NewLineMsg,    "");
   mprintf (CTtlNameMsg,   "");
   mprintf (CTtlUScoreMsg, "");

   for (i = 0; i < mem_table.noof_progs; i++)
      {
      if (mem_table.files[i].psp_addr  < 1)  continue; /* Display FREE last */
      if (mem_table.files[i].psp_addr == 7)
         {
         if ((dd = mem_table.files[i].driveridx) == MAX_DDRIVER_REP)
            {
	    continue;
	    }
	 }

      msgtype = 0;
      if (mem_table.files[i].psp_addr == 8)
	 {
	 msgtype = (mem_table.files[i].umb_ttl) ? SystemMsg : IbmdosMsg;
	 }

      memsize = mem_table.files[i].conv_ttl + mem_table.files[i].umb_ttl;
      sprintf (temp1, "(%ldK)", toK (mem_table.files[i].conv_ttl));
      sprintf (temp2, "(%ldK)", toK (mem_table.files[i].umb_ttl));
      sprintf (temp3, "(%ldK)", toK (memsize));

      if (msgtype)
         {
	 mprintf (MainCLineMsg, "%-8m%8ld%7c%8ld%7c%8ld%7c", msgtype,
	      &memsize, temp3, &mem_table.files[i].conv_ttl, temp1,
	                        &mem_table.files[i].umb_ttl, temp2);
	 }
      else
	 {
	 if (mem_table.files[i].psp_addr == 7)
	    {
	    nameptr = ddrivername[dd];
	    }
	 else
	    {
	    FP_SEG(ArenaPtr) = mem_table.files[i].psp_addr -1;
	    FP_OFF(ArenaPtr) = 0;
	    nameptr = OwnerOf(ArenaPtr);
            }

	 mprintf (MainCLineMsg, "%-8c%8ld%7c%8ld%7c%8ld%7c", nameptr,
	      &memsize, temp3, &mem_table.files[i].conv_ttl, temp1,
	                        &mem_table.files[i].umb_ttl, temp2);
	 }
      }

   for (i = 0; i < mem_table.noof_progs; i++)  /* There should be only 1 */
      {
      if (mem_table.files[i].psp_addr)  continue;

      memsize = mem_table.files[i].conv_ttl + mem_table.files[i].umb_ttl;
      sprintf (temp1, "(%ldK)", toK (mem_table.files[i].conv_ttl));
      sprintf (temp2, "(%ldK)", toK (mem_table.files[i].umb_ttl));
      sprintf (temp3, "(%ldK)", toK (memsize));

      mprintf (MainCLineMsg, "%-8m%8ld%7c%8ld%7c%8ld%7c", CFreeMsg,
	   &memsize, temp3, &mem_table.files[i].conv_ttl, temp1,
	                    &mem_table.files[i].umb_ttl,  temp2);
      }
}

/*----------------------------------------------------------------------*/
/*  AddMem_to_Table						        */
/*	Entry:	PSP_ADDR	(to which this mem. should be added)	*/
/*		ARENA_START_ADDR					*/
/*		Region of arena (0 == conv, 1 == UMB#1, 2 == UMB#2...)	*/
/*		Length_of_Arena						*/
/*	Exit:	mem_table updated.			      		*/
/*		returns 1 if more than MAX_CL_ENTRIES in mem_table	*/
/*		   else 0						*/
/*									*/
/* CAVEATS:						  		*/
/* --------								*/
/* 1. any system area (BIOS,SYSINIT,DOS ) code/data is listed as	*/
/*    to PSP 8.							        */
/*									*/
/* 2. We look at the UMB_HEAD in DOS DATA to determine whether an arena */
/*    is in UMB or not; For the Arena at the UMB boundary, we add one   */
/*    para to conv. and remaining to UMB portion of that PSP	        */
/*									*/
/* 3. Any free memory is always added as a new entry in the mem_table   */
/*    instead of just adding the sizes to an existing FREE entry        */
/*    Free memory gets added to the previous free memory if they are    */
/*    contiguous							*/
/*									*/
/* 4. The no of programs/free arenas cannot exceed a max of (100)	*/
/*    (defined by MAX_CLDATA_INDEX )       				*/
/*    If the memory is fragmented and a lot of small TSRs loaded such   */
/*    that we exceed this limit, we TERMINATE				*/
/*									*/
/* 5. Mem occupied by this MEM are also reported as FREE mem		*/
/*									*/
/*----------------------------------------------------------------------*/

/*
 * AddMem_to_Table() should be called for each given primary segment in the
 * detailed display.  By the time the detail is over, all conventional and
 * upper memory summaries of any sort will be finished (neato eh?), save the
 * sorting of programs (if you wanna do that).
 *
 */

unsigned int AddMem_to_Table (psp, addr, region, size)
unsigned int                  psp;
unsigned long                      addr, region, size;
{
   int               dd,            i;
   static long       memsize = 0L,  wasfree = 0L;
   static int        ismem   = 0;
   struct ARENA far *ArenaPtr;

   if (psp == 7)
      {
      dd = (unsigned int)GetDDriverPSP ();
      }
   else
      {
      FP_SEG(ArenaPtr) = (unsigned)addr-1; // Find the arena so we can get name
      FP_OFF(ArenaPtr) = 0;                // to compare with device drivers.

      if ((dd = IsDDriverAround (gpszDevDriver)) < 0) // If there's no DD
         dd = MAX_DDRIVER_REP;                        // with the same
      else                                            // name, it's nrml
         psp = 7;     // Otherwise, pretend we're filling in the DD list.
      }

   size += 16;  /* Header */

   if (ismem && psp == 0)
      {
      wasfree = memsize;
      memsize = 0;
      }

   ismem = 0;
   if (psp == _psp)
      {
      if (wasfree && region == 0L)
         {
	 memsize += wasfree;
	 }

      psp = 0;  /* treat MEM's arenas as FREE */
      ismem = 1;
      wasfree = 0L;
      }
   else
      wasfree = (psp == 0 && region == 0L) ? wasfree+size : 0L;

   for (i = 0; i < mem_table.noof_progs; i++)
      if (mem_table.files[i].psp_addr == psp)
         {
	 if ((psp != 7) || mem_table.files[i].driveridx == dd)
	    break;
	 }

	   /* if psp is not already listed in the table, add it */

   if (i == mem_table.noof_progs)
      {
      if (mem_table.noof_progs == MAX_CLDATA_INDEX)
	 {
	 mprintf(CMemFragMsg, "");
	 return(1);
	 }
      mem_table.files[i].psp_addr  = psp;
      mem_table.files[i].driveridx = dd;
      mem_table.noof_progs ++;
      }

		 /* add the memory to the table entry */

   if (ismem && region==0L)
      memsize += size;

   if (addr < UMB_Head)
      {
      mem_table.files[i].conv_ttl += size;
      if (psp == 0)
         mem_table.conv_free += size;
      if (psp == 0 && size > mem_table.conv_large)
         mem_table.conv_large = size;
      if (ismem && memsize > (long)mem_table.conv_large)
         mem_table.conv_large = size;
      if (wasfree > (long)mem_table.conv_large)
         mem_table.conv_large = wasfree;
      }
   else
      {
      mem_table.umb_ttl += size;
      if (psp == 0)
         mem_table.umb_free += size;

      mem_table.files[i].umb_ttl += size;
      if (psp == 0 && size > mem_table.umb_large)
	mem_table.umb_large = size;
      }

   if (region == 0L)  return 0;

   mem_table.umbs[(int)region-1].umb_ttl += size;
   if (psp == 0)
      {
      mem_table.umbs[(int)region-1].umb_free += size;
      if (size > mem_table.umbs[(int)region-1].umb_large)
	 mem_table.umbs[(int)region-1].umb_large = size;
      }
   if (mem_table.umbs[(int)region-1].umb_addr == 0L ||
       addr < mem_table.umbs[(int)region-1].umb_addr)
      {
      mem_table.umbs[(int)region-1].umb_addr = addr;
      }

  return 0;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/* A quick bit about headers:  MEM now reports all headers, or MCBs, as      */
/* space allocated by modules; ie, a module consisting of 2 MCBs, one which  */
/* points to a 50-paragraph block, and one which points to a 25-paragraph    */
/* block, will be listed in MEM/C as using 77 paragraphs... 1 for each MCB   */
/* as well.  MEM/D will list the individual sizes as 51 and 26 paragraphs,   */
/* so that size + address gives the next address.  This is mentioned here    */
/* because things... well... have not always been this way.                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
DoMainLine        (Owner, Address, Name, Size, Type, Region)
int                Owner,          Name,       Type;
unsigned long int        *Address,      *Size,      *Region;
{
   char  temp[40], far *ptr, temp2[9];

   if (Owner != 7)  *Size += 16;  // For display ONLY--see end of this routine

   if (DataLevel == 2 && Owner != 7)
      {
      mainline (Address, Name, Size, Type, Region);
      }

   if (DataLevel == 3 && *Region == 0L && (Owner == 0 || Owner == _psp))
      {
      sprintf (temp, "(%ldK)", toK (*Size));
      mprintf (MainFLineMsg, "%5lx%8ld%7c", Address, Size, temp);
      modulesize += *Size;
      }
   if (DataLevel == 4)
      {
      if (Owner == 7)
         {
	 strcpy (temp2, gpszDevDriver);
	 ptr = temp2;
	 }
      else
	 {
	 InRegs.x.ax = Name;
	 InRegs.h.dh = Utility_Msg_Class;
	 sysgetmsg(&InRegs,&SegRegs,&OutRegs);
	 FP_OFF(ptr) = OutRegs.x.si;
	 FP_SEG(ptr) = SegRegs.ds;
         }

      estrip (ptr);
      if (stricmp (ModName, (char *)ptr))  return;

      if (! modulesize)
         {
	 mprintf (NewLineMsg,   "");
	 mprintf (ModUseMsg,    "%-c", ModName);
	 mprintf (NewLineMsg,   "");
	 mprintf (ModTitleMsg,  "");
	 mprintf (ModUScoreMsg, "");
	 }
      sprintf (temp, "(%ldK)", toK (*Size));
      if (*Region == 0L)
         {
	 if (Owner != 7)
	    {
	    mprintf (MainMLineMsg, "%5lx%8ld%7c%-m", Address,Size,temp,Type);
	    }
	 else
	    {
	    mprintf (MainMDLineMsg, "%5lx%8ld%7c%-m%-c", Address, Size,
	                            temp, Type, ptr);
	    }
         }
      else
         {
	 if (Owner != 7)
	    {
	    mprintf (MainMXLineMsg, "%5lx%3ld%8ld%7c%-m", Address, Region,
		     Size, temp, Type);
	    }
	 else
	    {
	    mprintf (MainMDXLineMsg, "%5lx%3ld%8ld%7c%-m%-c", Address, Region,
		     Size, temp, Type, ptr);
	    }
         }
      modulesize += *Size;
      }

   if (Owner != 7)  *Size -= 16;  // For display ONLY--see top of this routine
}

void
DoMainLine_a      (Owner, Address, Name, Size, Type, Region)
int                Owner;
char                              *Name,      *Type;
unsigned long int        *Address,      *Size,      *Region;
{
   char  temp[40];
   *Size += 16;
   if (DataLevel == 2)  mainline_a (Address, Name, Size, Type, Region);
   if (DataLevel == 3 && *Region == 0L && (Owner == 0 || Owner == _psp))
      {
      sprintf (temp, "(%ldK)", toK (*Size));
      mprintf (MainFLineMsg, "%5lx%8ld%7c", Address, Size, temp);
      modulesize += *Size;
      }
   if (DataLevel == 4)
      {
      estrip ((char far *)Name);
      if (stricmp (Name, ModName))
      if (stricmp (Name, ModName))  return;

      if (! modulesize)
         {
	 mprintf (NewLineMsg,   "");
	 mprintf (ModUseMsg,    "%-c", ModName);
	 mprintf (NewLineMsg,   "");
	 mprintf (ModTitleMsg,  "");
	 mprintf (ModUScoreMsg, "");
	 }
      sprintf (temp, "(%ldK)", toK (*Size));
      if (*Region == 0L)
         mprintf (MainMLineMsg, "%5lx%8ld%7c%-c", Address,
		  Size, temp, Type);
      else
         mprintf (MainMXLineMsg, "%5lx%3ld%8ld%7c%-c", Address, Region,
		  Size, temp, Type);
      modulesize += *Size;
      }
   *Size -= 16;
}

void
estrip   (str)
char far *str;
{
   char far *p;
   if ((p = strchr ((char *)str, ' ')) != NULL)  *p = 0;
}

/*
 * DriverData() returns a character string containing:
 *
 *    Driver == 'F' : Number of files from "FILES=XXX" statement
 *    Driver == 'X' : Number of FCBS from "FCBS=XXX" statement
 *    Driver == 'B' : Number of buffers from "BUFFERS=XXX" statment
 *    Driver == 'L' : Letter of last drive from "LASTDRIVE=?" statement
 *    Driver == 'S' : Proper format from "STACKS=XXX,XXX" statement
 *
 * Thanks go to EricAr for his work here.
 *
 */

char *
DriverData       (ptr)
struct ARENA far *ptr;
{

#define buffer_m (int) (SysVarsPtr->BufferValues & 0x00FF)
#define buffer_n (int)((SysVarsPtr->BufferValues & 0xFF00) >> 8)

   void    far *tmp, far *tmp2;
   static char  buf[40];

   strcpy (buf, "?");

   tmp  = ptr;  FP_SEG(tmp)++;
   tmp2 = ptr;  FP_SEG(tmp2)++;
   FP_OFF(tmp)  = 4L;
   FP_OFF(tmp2) = 6L;
   switch (ptr->Signature)
      {
      case 'F':  sprintf (buf, "%d", *(short far *)tmp +5);
		break;
      case 'X':  sprintf (buf, "%d", *(short far *)tmp);
		break;
      case 'B':  if (! buffer_n)  sprintf (buf, "%d", buffer_m);
                 else             sprintf (buf, "%d,%d", buffer_m, buffer_n);
		break;
      case 'L':  sprintf (buf, "%c", ('A'-1) +SysVarsPtr->CdsCount);
		break;
      case 'S':  FP_OFF(tmp) = 2L;
                 sprintf (buf, "%d,%d", *(short far *)tmp, *(short far *)tmp2);
		break;
      }
   return buf;
}

unsigned int GetDDriverPSP ()
{
   register int  i;

   for (i = 0; i < ddriveridx; i++)
      {
      if (! strcmp (ddrivername[i], gpszDevDriver))
	 break;
      }
   if (i >= MAX_DDRIVER_REP)
      {
      return MAX_DDRIVER_REP;  // Too many?
      }
   if (i == ddriveridx)
      {
      strcpy (ddrivername[i], gpszDevDriver);
      ddriveridx++;
      }
   return i;
}

unsigned int IsDDriverAround (char *name) // Returns -1 if not, else its #.
{
   register int  i;

   for (i = 0; i < ddriveridx; i++)
     {
     if (! strcmp (ddrivername[i], name))
        break;
     }
   return (i < ddriveridx) ? i : -1;
}

/* M003 END */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\emm386.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
;
;  EMM386.ASM
;
;     fIsPooled() - Returns version if pooling is in effect, else 0
;

.MODEL	SMALL

include rombios.inc

;
;emm defines
;
EMM_INT_VECT		EQU 	67h
DEVICE_OFFSET		EQU	10

EMM_POOLED_VER		EQU	42Dh   ; emm386 pooled version is 4.45

EMM_READ_FUNC		EQU	1
EMM_GET_VER		EQU	2
EMM_DEV_NAME    	EQU     "EMMXXXX0",0 ; Name for EMM driver IOCTL open.
EMM_DEV_NOEMS           EQU     '$'          ; M000: Replacement for first
                                             ;   char. of EMM_DEV_NAME when
                                             ;   "device=EMM386 NOEMS".

EMM_DEV_VCPI            EQU     "EMMQXXX0",0 ; M002: Name for EMM driver when
                                             ;   VCPI but not EMS support.

EMM386_SIG           	EQU     "MICROSOFT"  ; M001: EMM386 Signature.
                                             ; M001: Offset from device base.
EMM386_SIG_OFFSET       EQU     (0ah + EMM_DEV_NAME_LEN - 1 + 2)


; Structure of the data returned on the IOCTL call to the EMM driver

EMM_STRUC	struc

    EMM_Version_Maj	db	?   ; Internal revision number
    EMM_Version_Min	db	?

EMM_STRUC	ends

Version		EQU (-((SIZE EMM_STRUC) - EMM_Version_Maj))
Function	EQU (-(SIZE EMM_STRUC))

.DATA

DevName db 'EMMXXXX0'

DeviceName	db	EMM_DEV_NAME	; Name for EMM IOCTL opens.
EMM_DEV_NAME_LEN EQU    ($-DeviceName)  ; M001: Length of DeviceName string.

EMM386Sig    	db      EMM386_SIG	; M001: Signature for EMM386 device.
EMM386_SIG_LEN  EQU     ($-EMM386Sig) 	; M001: Signature length.

;M002
VCPIDevName	db	EMM_DEV_VCPI	; Name for EMM VCPI IOCTL opens.

_MaxMin  dw 2 dup (0)
public _MaxMin

.CODE

public _fIsPooled

_fIsPooled	proc	near
	push	ES
	push	SI
	push	DI
	pushf				; M001: Save flags due to CLD below.
	push	BP
	mov	BP,SP
	sub	SP,SIZE EMM_STRUC

;M000
        xor     ax, ax
	mov	[_MaxMin],   ax
	mov	[_MaxMin+2], ax      ; First, we initialize the buffer.

	mov	DX,OFFSET DeviceName	; DS:DX pointer to emm name
	mov	AX,3d02h		; Try to open the device
	int	21h
        jnc     GEV40                   ; Jump if device opens.

	mov	DeviceName,EMM_DEV_NOEMS ; DS:DX -> NOEMS emm name
	mov	AX,3d02h		; Try to open the device
	int	21h
        jnc     GEV40                   ; Jump if device opens.

;M002
	mov	DX,OFFSET VCPIDevName	; DS:DX pointer to VCPI emm name
	mov	AX,3d02h		; Try to open the device
	int	21h
        jc      GEV60                   ; Jump if device not found.

; M001: Validate "MICROSOFT" signature.

GEV40:  push    AX                      ; Save EMM device handle.
        mov     AX,(35h SHL 8) OR EMM_INT_VECT
        int     21h                     ; ES:BX -> EMM device handler.
                                        ; ES:0000 -> EMM device base.
        mov     DI,EMM386_SIG_OFFSET    ; ES:DI -> EMM Signature.
        mov     SI,OFFSET EMM386Sig	; DS:SI -> EMM386 Signature.
        mov     CX,EMM386_SIG_LEN       ; CX = Signature length.
        cld
        repz    cmpsb                   ; Signature match?
        jz      GEV80                  	;   Yes, jump.
                                        ;   No, fall thru and exit.

GEV60:	xor	AX,AX			; return code = 0.
	jmp	SHORT FunctExit         ; Go fix stack and exit.

GEV80:	pop	BX			; BX = device handle.
;M000

	mov	AX,4400h		; IOCTL get device information.
	int	21h
	jc	SHORT ErrorClose	; Carry indicates call unsuccesful

	test	DX,0080h		; Test if clock device.
	jz	SHORT ErrorClose	; if not, we can't steal memory.

	test	DX,4000h		; Are IOCTL's 02h and 03h supported
	jz	SHORT ErrorClose	; if not we cannot steal memory.

	push	DS
	mov	AX,SS
	mov	DS,AX
	mov	DX,BP			; DS:DX == SS:BP
	mov	CX,SIZE EMM_STRUC	; CX == size of the ctrl string
	sub	DX,CX			; DS:DX --> Start of data struct

	mov	BYTE PTR [BP].Function,EMM_GET_VER

	mov	AX,4402h		; Read control device string function
	int	21h
	pop	DS
	jc	SHORT ErrorClose	; Carry indicates call unsuccesful

	cmp	AX,CX			; If ax != cx we did not get the
	jne	SHORT ErrorClose	; number of bytes we requested !
	mov	AX,WORD PTR [BP].Version ; Have good version #
	xchg	AH,AL			; Put major ver. in AH & minor in AL

	cmp	AX,EMM_POOLED_VER	; if emm386 ver 4.45 continue
	jl	SHORT ErrorClose	; else return 0

        mov     cx, 4
	mov	dx, offset _MaxMin     ; offset of emm386 max allocated and min allocated buffer
	mov	byte ptr [_MaxMin], 3  ; set function code for IOCTL
        mov     ax, 4402h              ; read control data from char device
	int	21h		       ; get max-min allocated for emm386

	jmp	SHORT CloseHandle

ErrorClose:
	xor	AX,AX			; Invalid EMM386 version #

CloseHandle:
	push	AX
	mov	AX,3E00h		; Close device, handle in BX.
	int	21h			; Call DOS
	pop	AX

FunctExit:
	mov	SP,BP
	pop	BP
        popf                            ; M001
	pop	DI
	pop	SI
	pop	ES
	ret				; return to caller.

_fIsPooled	endp

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\submsg.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */

 /*
  * SUBMSG.C - Message retriever interface functions for MEM command.
  *
  *
  */

#include "conio.h"			/* need for getchar prototype */
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
#include "msgdef.h"
#include "version.h"
#include "mem.h"
#include "ctype.h"
#include "dos.h"

/*---------------------------------------------------------------------------*/

/*
 * mprintf () requires a message number for a stencil, and a message type
 *   from which to retrieve it.  The third argument, "fmt", is interpereted
 *   as being similar to printf... the following is its syntax:
 *      "[%[-][width]{[l]{x/d}/m/c}]*"
 * That is, the following string:
 *   %-ld%15m%d%lx%-20c
 * Tells mprintf to expect 5 replacable parameters:
 *   1: A left-justified integer double-word (long), 8 characters, decimal
 *   2: A right-justified message (which will be retreived), 15 characters
 *   3: A right-justified integer word (short), 8 characters, decimal
 *   4: A right-justified integer double-word (long), 8 characters, hex
 *   5: A left-justified character string, 20 characters
 *
 */

void
mprintf (int msgnum, char *fmt, ... )
{
   char    *ptr;
   int      count = 0, wid;
   long     argt;
   va_list  arg;

   va_start (arg, fmt);

   for (ptr = fmt; ; )
      {
      argt = 0;
      wid  = 0;
      if (*ptr != '%')  break;
      ptr++;
      if (*ptr == '-')                 { argt |= 1; ptr++; }  /* Left-just   */
      for ( ; isdigit (*ptr); ptr++)
         {
	 wid *= 10;  wid += (*ptr - '0');
	 }
      if (*ptr == 'l' || *ptr == 'L')  { argt |=  2; ptr++; } /* Dword       */
      if (*ptr == 'x' || *ptr == 'X')  { argt |=  4; ptr++; } /* Hexadecimal */
      if (*ptr == 'd' || *ptr == 'D')  {             ptr++; } /* Decimal #   */
      if (*ptr == 'c' || *ptr == 'C')  { argt |=  8; ptr++; } /* Character   */
      if (*ptr == 's' || *ptr == 'S')  { argt |=  8; ptr++; } /* (same ^^^)  */
      if (*ptr == 'm' || *ptr == 'M')  { argt |= 16; ptr++; } /* Message     */

      count++;

      sublist[count].size      = Sublist_Length;
      sublist[count].reserved  = Reserved;
      sublist[count].id        = (char)count;
      sublist[count].max_width = (char)wid;
      sublist[count].min_width = (char)wid;

      if (argt & 16)
         {
	 argt |= 8;
	 InRegs.x.ax = va_arg (arg, int);
	 InRegs.h.dh = Utility_Msg_Class;
	 sysgetmsg(&InRegs,&SegRegs,&OutRegs);
	 FP_OFF(sublist[count].value) = OutRegs.x.si;
	 FP_SEG(sublist[count].value) = SegRegs.ds;
	 sublist[count].pad_char = Blank;
         }
      else if (argt & 8)
	 {
	 sublist[count].value    = (unsigned far *)va_arg (arg, char *);
	 sublist[count].pad_char = Blank;
	 }
      else if (argt & 2)
	 {
	 sublist[count].value    = (unsigned far *)va_arg (arg, long *);
	 }
      else
	 {
	 sublist[count].value    = (unsigned far *)va_arg (arg, short *);
	 }

      if (argt & 8)
	 {
	 sublist[count].flags = Char_Field_ASCIIZ;
	 }
      else if (argt & 4)
	 {
	 sublist[count].pad_char = '0';
	 if (argt & 2)  sublist[count].flags = Bin_Hex_DWord;
	 else           sublist[count].flags = Bin_Hex_Word;
	 }
      else
	 {
	 sublist[count].pad_char = Blank;
	 if (argt & 2)  sublist[count].flags = Unsgn_Bin_DWord;
	 else           sublist[count].flags = Unsgn_Bin_Word;
	 }

      sublist[count].flags += (char)((argt & 1) ? Left_Align : Right_Align);
      }

   InRegs.x.ax = msgnum;
   InRegs.x.bx = STDOUT;
   InRegs.x.cx = count;
   InRegs.h.dl = No_Input;
   InRegs.h.dh = Utility_Msg_Class;
   if (count)  InRegs.x.si = (unsigned int)&sublist[1];

   sysdispmsg (&InRegs, &OutRegs);

   if (! NoCR)
      check_screen();
   NoCR = 0;
}

void
mainline          (Address, Name, Size, Type, Region)
int                         Name,       Type;
unsigned long int *Address,      *Size,      *Region;
{
   char Desc[20];
   sprintf (Desc, "(%ldK)", toK(*Size));
   if (*Region == 0L)
      mprintf (MainLineMsg, "%5lx%8ld%7c%-8m%-m", Address, 
               Size, Desc, Name, Type);
   else
      mprintf (MainXLineMsg, "%5lx%3ld%8ld%7c%-8m%-m", Address, Region,
               Size, Desc, Name, Type);
}

void
mainline_a          (Address, Name, Size, Type, Region)
char                         *Name,      *Type;
unsigned long int   *Address,      *Size,      *Region;
{
   char Desc[20];
   sprintf (Desc, "(%ldK)", toK(*Size));
   if (*Region == 0L)
      mprintf (MainLineMsg, "%5lx%8ld%7c%-8c%-c", Address, 
               Size, Desc, Name, Type);
   else
      mprintf (MainXLineMsg, "%5lx%3ld%8ld%7c%-8c%-c", Address, Region,
               Size, Desc, Name, Type);
}

/*---------------------------------------------------------------------------*/

/*
 * check_screen() is called after every message is displayed; if /P was
 * specified, it causes the user to hit a key after every screenful.
 *
 */

void
check_screen ()
{
   if (! PageBreak)  return;
   if (++num_lines >= (PageBreak-1))
      {
      num_lines = 0;
      mprintf (KeyPressMsg, "");
      getch();
      mprintf (NewLineMsg, "");
      num_lines = 0;
      }
}

/* M003 END */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\_msgret.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
page	       60,132
name	       _msgret
title	       C to Message Retriever
;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			msgret(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;

	MSG_UTILNAME <MEM>		;IDENTIFY THE COMPONENT 		;AN000;

;-------------------------------------------------------------------
;-------------------------------------------------------------------


_TEXT	SEGMENT BYTE PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT WORD PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME	CS: DGROUP, DS: DGROUP, SS: DGROUP, ES: NOTHING

	public	data_sysloadmsg
	public	data_sysdispmsg
	public	data_sysgetmsg

_DATA	SEGMENT

	MSG_SERVICES <MSGDATA>
	MSG_SERVICES <LOADmsg,FARmsg>
	MSG_SERVICES <DISPLAYmsg,GETmsg,CHARmsg,NUMmsg>
	MSG_SERVICES <MEM.CLA,MEM.CLB,MEM.CL1,MEM.CL2,MEM.CTL>			     ;AN000;


data_sysloadmsg proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysloadmsg		; call the message retriever

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysloadmsg endp


data_sysdispmsg proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysdispmsg

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysdispmsg endp


data_sysgetmsg	proc far

	push	bp			; save user's base pointer
	mov	bp,sp			; set bp to current sp
	push	di			; save some registers
	push	si

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di
	push	ax			; the di value from inregs is now on stack

	mov	ax,[di+00]		; get inregs.x.ax
	mov	bx,[di+02]		; get inregs.x.bx
	mov	cx,[di+04]		; get inregs.x.cx
	mov	dx,[di+06]		; get inregs.x.dx
	mov	si,[di+08]		; get inregs.x.si
	pop	di			; get inregs.x.di from stack

	push	bp			; save base pointer

;-------------------------------------------------------------------

	call	sysgetmsg		; call the message retriever

;-------------------------------------------------------------------

	pop	bp			; restore base pointer
	push	di			; the di value from call is now on stack
	mov	di,[bp+6+4]		  ; fix di (arg 1)

	push	ax			; save ax
	mov	[di+00],es		; load segregs.es
	mov	[di+06],ds		; load outregs.ds
	pop	ax			; restore ax

	pop	di			; restore di
	push	di			; save it
	mov	di,[bp+8+4]		  ; fix di (arg 2)
	mov	[di+00],ax		; load outregs.x.ax
	mov	[di+02],bx		; load outregs.x.bx
	mov	[di+04],cx		; load outregs.x.cx
	mov	[di+06],dx		; load outregs.x.dx
	mov	[di+08],si		; load outregs.x.si

	lahf				; get flags into ax
	mov	al,ah			; move into low byte
	mov	[di+0ch],ax		; load outregs.x.cflag

	pop	ax			; get di from stack
	mov	[di+0ah],ax		; load outregs.x.di

;-------------------------------------------------------------------

	pop	si			; restore registers
	pop	di
	mov	sp,bp			; restore sp
	pop	bp			; restore user's bp
	ret

data_sysgetmsg	endp

include msgdcl.inc

_DATA	ends			; end code segment

_TEXT	SEGMENT

	assume cs:_TEXT

	public	_sysdispmsg
	public	_sysloadmsg
	public	_sysgetmsg

_sysdispmsg	proc	near
		call	data_sysdispmsg
		ret
_sysdispmsg	endp

_sysloadmsg	proc	near
		call	data_sysloadmsg
		ret
_sysloadmsg	endp

_sysgetmsg	proc	near
		call	data_sysgetmsg
		ret
_sysgetmsg	endp

_TEXT	ENDS
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\xms.asm ===
;            name    XMSDriver
.model  small,c
.code
            public  XMSDriver
XMSDriver   proc    XMSPtr: far ptr
            mov     ah,00h
            call    [XMSPtr]
            mov     ax,bx
            ret
XMSDriver   endp
;            end
;
;            name    XMSVersion
.model  small,c
.code
            public  XMSVersion
XMSVersion  proc    XMSPtr: far ptr
            mov     ah,00h
            call    [XMSPtr]
            ret
XMSVersion  endp


;
; This code snitched from xmsinfo.exe
;

HimemHandleTable proc uses es si, pHandleCount:NEAR PTR, pHandleSize:NEAR PTR

	mov	ax, 4309h	; 'secret' handle table info call
	int	2fh
	cmp	al, 43h
	jne	not_himem

	cmp	word ptr es:[bx], 0A01h ; info version 1 & Handle size 10?
	jne	not_himem

	mov	al, es:[bx+1]		; handle size
	cbw
	mov	si, [pHandleSize]
	mov	[si], ax

	mov	ax, es:[bx+2]		; # handles
	mov	si, [pHandleCount]
	mov	[si], ax

	mov	ax, es:[bx+4]		; offset to handle table
	mov	dx, es:[bx+6]		; segment of handle table
	jmp	short hht_ret

not_himem:

	xor	ax,ax			; doesn't look like himem,
	mov	dx,ax			; return NULL ptr

hht_ret:

	ret

HimemHandleTable endp


;
; Machines before the 80286 will set high the top four bits in the flags
; register as soon as you try to clear them.  So put zero in AX, move that
; to the flags register and back into AX ... if AX has the top four bits
; set, it's a pre-286.
;

IsPre286 proc			; Returns 0 if 286 or higher, !0 if <= 286

        xor    AX,AX
        push   AX
        popf
        pushf
        pop    AX

        and    AX, 0F000h	; Returns F000 if <= 286
	cmp    AX, 0F000h
	jz     ip286_ret

	xor    AX, AX

ip286_ret:

        ret

IsPre286 endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\invoke.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  MKS  C00  General cleanup.  Making short jumps out of long
;                      jumps, ridding of nops.
;  05/01/90  MKS  C04  Bug#1017. Mode was setting up NOERROR to be false if
;                      DISPLAY.SYS was not loaded when doing a status check.
;
;******************************************************************************                                            ;AN000;
;m                                                                                                                        ;AN000;
        PAGE    ,132                    ;                                                                                 ;AN000;
        TITLE   ANALYZE_AND_INVOKE - call appropriate routine based on request                                             ;AN000;
.XLIST                                                                                                                     ;AN000;
   INCLUDE STRUC.INC                                                                                                       ;AN000;
.LIST                                                                                                                      ;AN000;
;.SALL                                                                                                                     ;AN000;

;
;----------------------------------------------------------------------------
;
;M005 :	device_type was not being set to COMx when get_device_retry_type was
;	called from status_for_everything
;
;----------------------------------------------------------------------------

;  P R O L O G  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
;  AC000 - P2944: Was displaying the lines and column settings for CON even
;                 though couldn't get them when ANSI.SYS isn't loaded.  Now
;                 check if ANSI loaded before trying to display the settings.

;  AC002 - P3331: ES was getting zeroed, which caused problems later in MODECP.

;  AC003 - P3541: The retry status routine was assuming different format than
;                 the retry type byte was in.  I fixed the status checking
;                 routine.

;  AX004 - P3982: The screen was being cleared after the "Unable to shift
;                 screen ..." message.

;  AC005 - P4934: The multiplex number for ANSI.SYS was changed due to a
;     5/20/88     conflict with a Microsoft product that has already been
;                 shipped.

;                                                                                                                        ;AN000;
;  P R O L O G  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  M A C R O S  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
GET_EXTENDED_ERROR   MACRO                                                                                                 ;AN000;
                                                                                                                           ;AN000;
MOV   BX,0              ;level for 3.00 to 4.00                                                                            ;AN000;
MOV   AH,59H            ;function number for get extended error                                                            ;AN000;
INT   21H                                                                                                                  ;AN000;
                                                                                                                           ;AN000;
ENDM                                                                                                                       ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
BREAK   MACRO   X                                                                                                          ;AN000;
   JMP     endcase_&X                                                                                                      ;AN000;
ENDM                                                                                                                       ;AN000;
                                                                                                                           ;AN000;
SHORTBREAK   MACRO   X                                                  ;C00                                               ;AN000;
   JMP   SHORT  endcase_&X                                              ;C00                                               ;AN000;
ENDM                                                                    ;C00                                               ;AN000;
                                                                        ;C00                                               ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
DISPLAY MACRO   MESSAGE                                                                                                    ;AN000;
        MOV     DX,OFFSET MESSAGE                                                                                          ;AN000;
        CALL    PRINTF                                                                                                     ;AN000;
ENDM                                                                                                                       ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  M A C R O S  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  E Q U A T E S  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
INCLUDE modequat.inc                                                                                                       ;AN000;
                                                                                                                           ;AN000;
ANSIINT2F   EQU   1AH      ;INT 2F multiplex number for ANSI.SYS                                                           ;AC005;
ASCII_0  EQU   "0"         ;change one based binary printer number into ASCII printer number                               ;AN000;
ASCII_1  EQU   "1"                                                                                                         ;AN000;
B        EQU   2           ;retry setting                                                                                  ;AN000;
blink    EQU   0000H      ;value for flags field of IOCTL data block                                                       ;AN000;
busy_retry_active       EQU   2     ;indicates bust retry is active                                                        ;AN000;
check_installed   EQU   0  ;request installed state for INT2F (ANSI)                                                       ;AN000;
;COLUMNS           EQU   00000010B   ;                                                                                      ;AN000;
com1_retry_type_status  EQU   0     ;request for retry status on com1                                                      ;AN000;
com2_retry_type_status  EQU   2     ;request for retry status on com2                                                      ;AN000;
com3_retry_type_status  EQU   4     ;request for retry status on com3                                                      ;AN000;
com4_retry_type_status  EQU   6     ;request for retry status on com4                                                      ;AN000;
display_device EQU   3     ;type of device, used for calls to IOCTL 0C function                                            ;AN000;
E        EQU   1           ;retry setting                                                                                  ;AN000;
error_retry_active      EQU   1     ;indicates error retry is active                                                       ;AN000;
false    EQU   00H                                                                                                         ;AN000;
font_not_loaded      EQU   31       ;return from IOCTL 0C (via ext err) indicating DISPLAY.SYS don't have necessary font loaded
get_current_settings EQU   07FH     ;request for IOCTL 0C call                                                             ;AN000;
installed            EQU   0FFH     ;return from get_installed_state function                                              ;AN000;
intense  EQU   0001H      ;value for flags field of IOCTL data block                                                       ;AN000;
IOCTL0C  EQU   [SI]                                                                                                        ;AN000;
;LINES             EQU   00000001B   ;flag for IOCTL0C_functions_requested                                                  ;AN000;
lowercase            EQU   020H     ;when ORed with char value it changes it to lowercase                                 ;AN000;
LPT1                 EQU   1        ;mask for input to display_device_reroute_status, see modeecho                         ;AN000;
LPT2                 EQU   2        ;mask for input to display_device_reroute_status, see modeecho                         ;AN000;
LPT3                 EQU   4        ;mask for input to display_device_reroute_status, see modeecho                         ;AN000;
lpt1_retry_type_status  EQU   0     ;request for retry status on lpt1                                                      ;AN000;
lpt2_retry_type_status  EQU   1     ;request for retry status on lpt2                                                      ;AN000;
lpt3_retry_type_status  EQU   2     ;request for retry status on lpt3                                                      ;AN000;
MODE_INT2F_MULTIPLEX_NUMBER   EQU   0                                                                                      ;AN000;
no_retry       EQU   3     ;retry setting                                                                                  ;AN000;
no_retry_active         EQU   0     ;indicates no retry active on device                                                   ;AN000;
not_supported_on_machine   EQU   29 ;return from IOCTL 0C (via ext err) indicating hardware don't support the function     ;AN000;
parm_list_BX   EQU   [BX]                                                                                                  ;AN000;
prn_ports_attached      EQU   CL    ;used in printer_reroute_case and check_prn_ports_attached
R        EQU   3           ;retry setting for com ports                                                                    ;AN000;
ready_retry_active      EQU   3     ;indicates ready retry is active                                                       ;AN000;
redirected              EQU   2     ;network puts a 2 in printer address word for printers redirected
rerouted_printer_mask   EQU   BL    ;holds the mask to check ptsflag1 with, see modeecho.asm
returned_retry_type     EQU   AL    ;holds the returned status value                                                       ;AN000;
set_display_characteristics   EQU   05FH  ;request for IOCTL 0C call                                                       ;AN000;
status   EQU   0                    ;request for modecp                                                                    ;AN000;
StdOut                  equ     1                                                                                          ;AN000;
text     EQU   01          ;mode field of IOCTL 0C call indicating screen mode type (vs APA mode)                          ;AN000;
true     EQU   0FFH                                                                                                        ;AN000;
unspecified             EQU   0FFH  ;state of item_tags in parm_list if the positonal parm was not specified               ;AN664;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  E Q U A T E S  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  S T R U C T U R E S  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
des_strt_packet   STRUC                                                                                                    ;AN000;
   des_strt_pkfl  DW    0000           ;assume a filename specified                                                        ;AN000;
   des_strt_pklen DW    02             ;start with size of 'des_strt_pknum'                                                ;AN000;
   des_strt_pknum DW    0              ;number of cp numbers in the packet                                                 ;AN000;
   des_strt_pkcp1 DW    -1             ;code page number for 1st slot                                                      ;AN000;
   des_strt_pkcp2 DW    -1                                                                                                 ;AN000;
   des_strt_pkcp3 DW    -1                                                                                                 ;AN000;
   des_strt_pkcp4 DW    -1                                                                                                 ;AN000;
   des_strt_pkcp5 DW    -1                                                                                                 ;AN000;
   des_strt_pkcp6 DW    -1                                                                                                 ;AN000;
   des_strt_pkcp7 DW    -1                                                                                                 ;AN000;
   des_strt_pkcp8 DW    -1                                                                                                 ;AN000;
   des_strt_pkcp9 DW    -1                                                                                                 ;AN000;
   des_strt_pkcpA DW    -1                                                                                                 ;AN000;
   des_strt_pkcpB DW    -1                                                                                                 ;AN000;
   des_strt_pkcpC DW    -1             ;code page number for 12th slot                                                     ;AN000;
des_strt_packet   ENDS                                                                                                     ;AN000;
                                                                                                                           ;AN000;
;The info_level is 0 on input, and contains a return code on exit. If carry set                                            ;AN000;
;and 2 then the requested function is not supported on this machine.  If carry                                             ;AN000;
;set and 3 then DISPLAY.SYS does not have the appropriate RAM font loaded to                                               ;AN000;
;support the requested function.                                                                                           ;AN000;
                                                                                                                           ;AN000;
IOCTL0C_def STRUC                                                                                                          ;AN000;
                                                                                                                           ;AN000;
info_level  DB    0     ;return code: 0 on input, 1 ?, 2 or 3 as returns                                                   ;AN000;
            DB    0     ;reserved                                                                                          ;AN000;
data_length DW    14    ;length of the data block not including this field                                                 ;AN000;
flags       DW    0     ;filled with intense or blink                                                                      ;AN000;
mode        DB    text  ;filled with text, may be returned as 2 which means APA                                            ;AN000;
            DB    0     ;reserved                                                                                          ;AN000;
colors      DW    16    ;0 means monochrome                                                                                ;AN000;
            DW    bogus ;width in pixels for APA modes                                                                     ;AN000;
            DW    bogus ;length in pixels for APA modes                                                                    ;AN000;
cols        DW    bogus ;nubmer of text columns                                                                            ;AN000;
rows        DW    bogus ;number of text rows                                                                               ;AN000;
                                                                                                                           ;AN000;
IOCTL0C_def ENDS                                                                                                           ;AN000;
                                                                                                                           ;AN000;
INCLUDE COMMON.STC      ;includes the following strucs                                                                     ;AN000;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  S T R U C T U R E S  ͼ                                ;AN000;
                                                                                                                           ;AN000;
ROM    SEGMENT AT 0                                                                                                        ;AN000;
        ORG     530H                                                                                                       ;AN000;
resseg  LABEL   DWORD            ;location of resident mode code vector                                                     ;AN000;
ROM    ENDS                                                                                                                ;AN000;
                                                                                                                           ;AN000;
BIOS  SEGMENT AT 40H             ;
   ORG   10H                     ;location of equipment determination word
equipment_word    LABEL    WORD  ;will be changing the video mode type bits
BIOS  ENDS                       ;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
        PAGE                                                                                                               ;AN000;
PRINTF_CODE SEGMENT PUBLIC                                                                                                 ;AN000;
        ASSUME  CS:PRINTF_CODE,DS:PRINTF_CODE,SS:PRINTF_CODE                                                               ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  P U B L I C S  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
PUBLIC   analyze_and_invoke      ;make available to "MAIN"                                                                 ;AN000;
PUBLIC   busy_retry_active            ;used by modecom                                                                     ;AN000;
PUBLIC   cp_cb                      ;modepars needs to set the font file name                                              ;AN000;
PUBLIC   error_retry_active            ;used by modecom                                                                    ;AN000;
PUBLIC   initialize_printer_port_case                                                                                      ;AN000;
PUBLIC   no_retry_active            ;used by modecom                                                                       ;AN000;
PUBLIC   parm_list_holder           ;used by modeprin                                                                      ;AN664;
PUBLIC   ready_retry_active            ;used by modecom                                                                    ;AN000;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  P U B L I C S  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  E X T R N S  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
EXTRN    ANSI_not_loaded:BYTE      ;see modedefs.inc                                                                       ;AN000;
EXTRN    BAUD_equal:BYTE                        ;the string "BAUD=", see modepars                                          ;AN000;
EXTRN    BAUD_index:WORD                        ;see modecom.asm                                                           ;AN000;
EXTRN    B_str:BYTE                          ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    BITBW40:ABS                ;EQU 10H, 40X25 BW USING COLOR CARD
EXTRN    BITBW80:ABS                ;EQU 20H, 80X25 BW USING COLOR CARD
EXTRN    BW40:NEAR            ;see modedefs.inc                                                                            ;AN000;
EXTRN    BW40_item_tag:ABS               ;see MODEPARS.ASM                                                                 ;AN000;
EXTRN    BW80:NEAR            ;see modedefs.inc                                                                            ;AN000;
EXTRN    BW80_item_tag:ABS               ;see MODEPARS.ASM                                                                 ;AN000;
EXTRN    busy_status:ABS
EXTRN    close:ABS            ;EQU  3EH   ;CLOSE A FILE HANDLE,see modecpeq.inc                                            ;AN000;
EXTRN    columns_ptr:WORD                 ;see modesubs.inc                                                                ;AN000;
EXTRN    CO40:NEAR            ;see modedefs.inc                                                                            ;AN000;
EXTRN    CO40_item_tag:ABS               ;see MODEPARS.ASM                                                                 ;AN000;
EXTRN    CO80:NEAR            ;see modedefs.inc                                                                            ;AN000;
EXTRN    CO80_item_tag:ABS               ;see MODEPARS.ASM                                                                 ;AN000;
EXTRN    codepage_index_holder:WORD          ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    codepage_item_tag:ABS               ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    columns_equal:BYTE              ;see MODEPARS.ASM                                                                 ;AN000;
EXTRN    columns_equal_msg:BYTE              ;see MODEdefS.inc                                                             ;AN000;
EXTRN    columns_holder:BYTE              ;holder for printer chars per line (binary) value, see modeprin                  ;AN000;
EXTRN    COLS_equal:BYTE                 ;see MODEPARS.ASM                                                                 ;AN000;
EXTRN    columns_item_tag:ABS               ;see MODEPARS.ASM                                                              ;AN000;
EXTRN    COM1_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    COM2_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    COM3_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    COM4_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    COMX:ABS                            ;one of two possible values for "device_type"
EXTRN    CON_str:BYTE                        ;"CON"see MODEPARS.ASM                                                        ;AN000;
EXTRN    CRLF:BYTE                       ;see MODEDEFS.ASM, used before "Invalid parameter - " for consistent spacing      ;AN000;
EXTRN    data_bits_index:WORD                ;see modecom.asm                                                              ;AN000;
EXTRN    DATA_equal:BYTE                       ;see MODEPARS.ASM                                                           ;AN000;
EXTRN    DELAY_equal:BYTE                    ;see MODEPars.asm                                                             ;AN000;
EXTRN    DEL_equal:BYTE                      ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    des_start_packet:WORD         ;AX000; des_strt_packet <>, see modepars                                            ;AN000;
EXTRN    device:BYTE                   ;holder of com number for invoke and modeecho                                       ;AN000;
EXTRN    device_name:WORD                                                                                                  ;AN000;
EXTRN    device_type:BYTE                    ;see MODEPARS.ASM                                                          ;AN000;
EXTRN    dev_name_size:WORD                  ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    dev_open_mode:ABS             ;read write access                                                                  ;AN000;
EXTRN    display_printer_reroute_status:NEAR ;see modeecho.asm
EXTRN    eighty_item_tag:ABS                 ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    eighty_str:BYTE                     ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    error_status:ABS                    ;see MODEPRIN
EXTRN    five_char_underline:BYTE            ;see modedefs.inc                                                             ;AN000;
EXTRN    four_char_underline:BYTE            ;see modedefs.inc                                                             ;AN000;
EXTRN    function_not_supported:BYTE            ;see modedefs.inc                                                          ;AN000;
EXTRN    err1:BYTE                           ;see modedefs.inc
EXTRN    E_str:BYTE                          ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    fourty_item_tag:ABS                 ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    fourty_str:BYTE                     ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    handle_40_or_80:NEAR                   ;see modescrn                                                              ;AN000;
EXTRN    illegal_device_ptr:WORD             ;see modesubs.inc
EXTRN    keyword:ABS                         ;see MODEPARS                                                                 ;AN000;
EXTRN    invalid_number_of_parameters:WORD                                                                                 ;AN000;
;EXTRN    invalid_parameter:WORD      ;<CR><LF>"Invalid parameter '????'",beep                                              ;AN000;
EXTRN    len_COMX_str:ABS                    ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    len_CON_str:ABS                     ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    len_LPTX_str:ABS                    ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    L_item_tag:ABS                      ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    LINES_equal:BYTE                   ;see MODEPARS.ASM                                                              ;AN000;
EXTRN    LINES_equal_msg:BYTE                   ;see MODEDEFS.INC                                                          ;AN000;
EXTRN    lines_item_tag:ABS               ;see MODEPARS.ASM                                                                ;AN000;
EXTRN    long_underline:BYTE                 ;see modedefs.inc                                                             ;AN000;
EXTRN    lptno:BYTE                       ;holder of printer number for invoke and modeecho                                ;AN000;
EXTRN    lpt1_retry_type:BYTE                ;see RESCODE
EXTRN    LPT1_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    LPT2_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    LPT3_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    notredpt:BYTE                    ;printer number in "LPTn not rerouted"
EXTRN    max_request_type:ABS                ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    modecom:NEAR                                                                                                      ;AN000;
EXTRN    modecp:NEAR                                                                                                       ;AN000;
EXTRN    modeecho:NEAR                                                                                                     ;AN000;
EXTRN    modeecno:NEAR                                                                                                     ;AN000;
EXTRN    modeprin:NEAR                                                                                                     ;AN000;
EXTRN    modify_resident_code:NEAR                 ;see modeprin                                                           ;AN000;
EXTRN    MONO:NEAR            ;see modedefs.inc                                                                            ;AN000;
EXTRN    MONO_item_tag:ABS               ;see MODEPARS.ASM                                                                 ;AN000;
EXTRN    no_retry_flag:ABS                ;see MODEPRIN
EXTRN    noerror:BYTE                                                                                                      ;AN000;
EXTRN    none_item_tag:ABS                   ;see modepars.asm                                                             ;AN000;
EXTRN    none_str:BYTE                       ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    offending_parameter:BYTE       ;see MODEMES                                                                       ;AN000;
EXTRN    OFF_item_tag:ABS                     ;see pares.asm                                                               ;AN000;
EXTRN    off_str:BYTE                       ;see MODEPARS.ASM                                                              ;AN000;
EXTRN    onethirtytwo_item_tag:ABS        ;see modepars.asm                                                                ;AN000;
EXTRN    ON_item_tag:ABS                     ;see pares.asm                                                                ;AN000;
EXTRN    on_str:BYTE                       ;see MODEPARS.ASM                                                               ;AN000;
EXTRN    open:ABS                   ;open a device handle, see modecpeq.inc                                                ;AN000;
EXTRN    parity_equal:BYTE          ;see modepars.asm                                                                      ;AN000;
EXTRN    parity_index:WORD          ;see modecom                                                                           ;AN000;
EXTRN    parm2:BYTE                 ;see MODEPRIN.ASM                                                                      ;AN000;
EXTRN    parm3:BYTE                 ;see MODEPARS.ASM                                                                      ;AN000;
;EXTRN    parm_lst:BYTE              ;parm_list_entry  max_pos_parms DUP (<>), see MODEPARS.ASM                            ;AN000;
EXTRN    parms_form:byte            ;indicator of whether the parameters were entered as positionals or as keywords        ;AN000;
EXTRN    pbaud_ptr:WORD         ;AN000;;pointer to the baud rate string in the initialization message for COM, see modesubs.inc
EXTRN    pdata:BYTE                    ;see modesubs.inc                                                                   ;AN000;
EXTRN    pparity_ptr:WORD              ;see modesubs.inc                                                                   ;AN000;
EXTRN    pparm:BYTE                    ;used by modecom and for message, see modesubs.inc                                  ;AN000;
EXTRN    prepare:ABS                                                                                                       ;AN000;
EXTRN    prepare_item_tag:ABS               ;see MODEPARS.ASM                                                              ;AN000;
EXTRN    PRINTR:WORD             ;PRINTER BASE (40:8), HOLDS PORT ADDRESSES OF PRINTER CARDS
EXTRN    pstop_ptr:WORD                ;see modesubs.inc                                                                   ;AN000;
EXTRN    PRINTF:NEAR                                                                                                       ;AN000;
EXTRN    rate_equal:BYTE              ;see MODEPARS.ASM                                                                    ;AN000;
EXTRN    ready_status:ABS              ;see modeprin
EXTRN    redpt:BYTE                    ;printer number (n) in message "LPTn rerouted to COMm"
EXTRN    refresh:ABS                                                                                                       ;AN000;
EXTRN    retry_item_tag:ABS               ;see MODEPARS.ASM                                                                ;AN000;
EXTRN    request_type:BYTE             ;see "MODEPARS.ASM"                                                                 ;AN000;
EXTRN    retry_equal:BYTE              ;see MODEDEFS.INC                                                                   ;AN000;
EXTRN    retry_equal_str:BYTE                                                                                              ;AN000;
EXTRN    retry_index:WORD              ;see MODECOM.ASM                                                                    ;AN000;
EXTRN    retry_type_ptr:WORD           ;see MODESUBS.INC                                                                   ;AN000;
EXTRN    row_ptr:WORD                          ;see modesubs.inc                                                           ;AN000;
EXTRN    row_type:WORD                          ;see modesubs.inc                                                          ;AN000;
EXTRN    R_item_tag:ABS                      ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    R_str:BYTE                          ;see MODEPARS.ASM                                                             ;AN000;
EXTRN    Required_font_not_loaded:BYTE    ;see modedefs.asm                                                                ;AN000;
EXTRN    res_com_retry_type:ABS              ;see RESCODE.SAL                                                              ;AN000;
;EXTRN    res_lpt_retry_type:ABS              ;see RESCODE.SAL                                                              ;AN000;
EXTRN    select:ABS                           ;request type for 'modecp'                                                   ;AN000;
EXTRN    select_item_tag:ABS               ;see MODEPARS.ASM                                                               ;AN000;
EXTRN    serial_base:WORD                    ;see modecom                                                                  ;AN000;
EXTRN    set_con_features:ABS                                                                                              ;AN000;
EXTRN    set_retry_type:NEAR                 ;see modeprin                                                                 ;AN000;
EXTRN    shift_screen:NEAR                   ;see modescrn                                                                 ;AN000;
EXTRN    stat_dev_ptr:WORD                   ;see modedefs.inc                                                             ;AN000;
EXTRN    status_for_device:BYTE              ;"Status for device %1:" see modedefs.inc                                     ;AN000;
EXTRN    status_for_everything:ABS                                                                                         ;AN000;
EXTRN    stop_bits_index:WORD                ;see modecom.asm                                                              ;AN000;
EXTRN    stop_equal:BYTE                     ;"STOP=", see modepars                                                        ;AN000;
EXTRN    typamat:NEAR                  ;see "typamat.asm"                                                                  ;AN000;
                                                                                                                           ;AN000;
;possible values of "request_type"                                                                                         ;AN000;
                                                                                                                           ;AN000;
EXTRN    all_con_status:ABS                                                                                                ;AN000;
EXTRN    codepage_prepare:ABS                                                                                              ;AN000;
EXTRN    codepage_refresh:ABS                                                                                              ;AN000;
EXTRN    codepage_select:ABS                                                                                               ;AN000;
EXTRN    codepage_status:ABS                                                                                               ;AN000;
EXTRN    codepage_prepared_status:ABS                                                                                      ;AN000;
EXTRN    codepage_selected_status:ABS                                                                                      ;AN000;
EXTRN    com_status:ABS                                                                                                    ;AN000;
;EXTRN    con_status:ABS                                                                                                   ;AN000;
EXTRN    initialize_com_port:ABS                                                                                           ;AN000;
EXTRN    initialize_printer_port:ABS                                                                                       ;AN000;
EXTRN    old_initialize_printer_port:ABS                                                                                   ;AN000;
EXTRN    old_video_mode_set:ABS                                                                                            ;AN000;
EXTRN    printer_reroute:ABS                                                                                               ;AN000;
EXTRN    printer_status:ABS                                                                                                ;AN000;
EXTRN    turn_off_reroute:ABS                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  E X T R N S  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  D A T A  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
ANSI_installed          DB    false       ;boolean indicator of whether ANSI.SYS is installed                              ;AN000;
columns_specified       DB    false       ;indicates if columns= was on the command line, see set_con_features_case;AN000;
code_page_numbers_encountered    DB    0                                                                                   ;AN000;
cp_cb                   codepage_parms <> ;codepage subroutine parameter block                                             ;AN000;
com_ports_attached      DB    0           ;number of com ports in the machine
current_packet_cp_number   DW    -2       ;adjustment for accessing current 'des_strt_pkcp?' in 'des_start_packet'         ;AN000;
delay_holder            DB    1           ;holder for binary form of delay requested                                       ;AN000;
device_request          DB    ?           ;holds device request value                                                      ;AN000;
max_pknum               EQU      ($ - OFFSET des_start_packet.des_strt_pkcp1)/2        ;most cp numbers can send at once   ;AN000;
;IOCTL0C_functions_requested   DB 0        ;for displaying messages, flag byte indicating IOCTL functions requested         ;AN000;
need_typamat_call       DB       false    ;boolean for saving up delay and rate settings                                   ;AN000;
need_IOCTL0C            DB       false    ;boolean for saving up parts of an IOCTL 0CH call                                ;AN000;
parm_list_holder        DW    bogus       ;holder for address of parsed parameter list for when BX is needed elsewhere     ;AN000;
parm_list_index_holder  DW    bogus       ;holder for index of parsed parameter list for when DI is needed elsewhere       ;AN000;
i                       DB    0           ;index for status loop                                                           ;AN000;
rate_holder             DB    32          ;holder for binary form of rate value                                            ;AN000;
row_value               DB       ?        ;holder for binary form of row value during status display                       ;AN000;
                                                                                                                           ;AN000;
IOCTL0C_data_block   IOCTL0C_def<>                                                                                         ;AN000;

PUBLIC IOCTL0C_data_block
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  D A T A  ͼ                                ;AN000;
                                                                                                                           ;AN000;
check_ANSI_installed PROC  NEAR           ;See if ANSI.SYS is installed                                                 ;AC001;

   MOV   AH,ANSIINT2F                                                                                                   ;AC001;
   MOV   AL,check_installed                                                                                             ;AC001;
   INT   2FH                                                                                                            ;AC001;
   .IF <AL EQ installed> THEN                                                                                           ;AC001;
      MOV   ANSI_installed,true           ;initialized to false, so no ELSE needed                                      ;AC001;
   .ENDIF

check_ANSI_installed ENDP                                                                                               ;AC001;

;------------------------------------------------------------------------------



setup_device_name PROC  NEAR                                                                                               ;AN000;
                                                                                                                           ;AN000;
MOV   DX,device_name          ;DX=pointer to ASCIIZ device name                                                            ;AN000;
MOV   cp_cb.cp_device,DX         ;Set the pointer to the device name ASCIIZ in the parameter block for 'modecp'.           ;AN000;
                                                                                                                           ;AN000;
RET                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
setup_device_name ENDP                                                                                                     ;AN000;
                                                                                                                           ;AN000;
;------------------------------------------------------------------------------
;                                           ;AN000;
;
; SET_EQUIPMENT_WORD
; ------------------
;
;  Change the equipment word to reflect the new number of columns.  If the
;  current mode is MONO then no change will be done because the number of
;  columns cannot be changed on a monochrome display.
;
;  INPUT: DX=setting for the video bits
;
;
;  RETURN: equipment word changed if not in MONO mode
;
;
;  MESSAGES: none
;
;  REGISTER  AX - used for masking and testing bits
;  USAGE:    ES - holds segment of ROM data area
;
;
;  ASSUMPTIONS: The user requested only a cloumns change, i.e. did not want to
;               change the active display.
;
;               DX will be either 0010 or 0020.
;
;               ES was assumed to nothing.
;
;
;  SIDE EFFECT: AX destroyed
;
;                                                                                                                         ;AN000;
;                                           ;AN000;

set_equipment_word   PROC  NEAR

PUSH  ES                           ;need to get to 40:10 to change the
MOV   AX,BIOS                      ;equipment word
MOV   ES,AX                        ;ES=40
ASSUME   ES:BIOS                   ;tell linker/mother assembler what we did
XOR   AX,AX                        ;clear reg for checking current setting
OR    AX,MASK VIDEO                ;turn on both video bits
AND   AX,ES:equipment_word         ;if the video bits are 11B (MONO) then
XOR   AX,MASK VIDEO                ;AX won't change
.IF NZ THEN                        ;IF AX didn't change then don't change the equipment word
   MOV     AX,ES:equipment_word    ;GET CURRENT STATUS FLAG BYTE
   AND     AX,0FFFFH-MASK VIDEO    ;CLEAR VIDEO DEFINITION BITS
   OR      AX,DX                   ;TURN ON REQUESTED VIDEO BITS
   MOV     ES:equipment_word,AX    ;RESTORE UPDATED FLAG BYTE
.ENDIF                             ;ENDIF not in MONO mode
ASSUME   ES:NOTHING                ;tell linker/mother assembler what we did
POP   ES                           ;

RET                                ;

set_equipment_word   ENDP          ;
;------------------------------------------------------------------------------
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
do_IOCTL0C  PROC  NEAR                                                                                                     ;AN000;
PUBLIC   DO_IOCTL0C                                                                                                        ;AN000;
      MOV   AH,open              ;open device                                                                              ;AN000;
      MOV   AL,dev_open_mode     ;AL=open mode for devices, see modecpeq.inc                                               ;AN000;
      MOV   DX,OFFSET CON_str    ;know that CON is being opened, avoid using user input and having to remove colon         ;AN000;
      INT   21H                                                                                                            ;AN000;
                                                                                                                           ;AN000;
      MOV   BX,AX                ;BX=handle of CON                                                                         ;AN000;
      MOV   AX,440CH                                                                                                       ;AN000;
      MOV   CH,display_device    ;type of device                                                                           ;AN000;
      MOV   DX,OFFSET IOCTL0C_data_block                                                                                   ;AN000;
      INT   21H                           ;the IOCTL data block is filled with the current settings                        ;AN000;
      PUSHF                               ;save result of the IOCTL                                                        ;AN000;
                                                                                                                           ;AN000;
      MOV   AH,3EH               ;assume that BX still has the handle                                                      ;AN000;
      INT   21H                  ;close CON, open and close each time because if error may not be back to close            ;AN000;
                                                                                                                           ;AN000;
      POPF                       ;restore result of the IOCTL                                                              ;AN000;
                                                                                                                           ;AN000;
      RET                                                                                                                  ;AN000;
                                                                                                                           ;AN000;
do_IOCTL0C  ENDP                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;-------------------------------------------------------------------------------                                           ;AN000;
                                                                                                                           ;AN000;
display_columns_status  PROC  NEAR                                                                                         ;AN000;
                                                                                                                           ;AN000;
MOV   CL,get_current_settings                                                                                              ;AN000;
CALL  do_IOCTL0C                    ;get current settings of CON                                                           ;AN000;
.IF <IOCTL0C_data_block.mode EQ text> THEN                                                                                 ;AN000;
   .IF <IOCTL0C_data_block.cols EQ 80> THEN                                                                                ;AN000;
      MOV columns_ptr,OFFSET eighty_str      ;set up message block with pointer to "80"                                    ;AN000;
   .ELSE                                                                                                                   ;AN000;
      MOV columns_ptr,OFFSET fourty_str                                                                                    ;AN000;
   .ENDIF                                                                                                                  ;AN000;
.ELSE                                                                                                                      ;AN000;
   MOV columns_ptr,OFFSET NONE_str                                                                                         ;AN000;
.ENDIF                                                                                                                     ;AN000;
display  COLUMNS_equal_msg                                                                                                 ;AN000;
                                                                                                                           ;AN000;
RET                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
display_columns_status  ENDP                                                                                               ;AN000;
                                                                                                                           ;AN000;
;-------------------------------------------------------------------------------                                           ;AN000;
                                                                                                                           ;AN000;
display_lines_status PROC  NEAR                                                                                            ;AN000;
                                                                                                                           ;AN000;
MOV   CL,get_current_settings                                                                                              ;AN000;
CALL  do_IOCTL0C                    ;get current settings of CON                                                           ;AN000;
.IF <IOCTL0C_data_block.mode EQ text> THEN                                                                                 ;AN000;
   MOV   AX,IOCTL0C_data_block.rows                                                                                        ;AN000;
   MOV   row_value,AL                    ;row_value=binary row value                                                       ;AN000;
   MOV   row_type,right_align+unsgn_bin_byte  ;set up sublist so msg ret knows it is a binary byte                         ;AN000;
   MOV   row_ptr,OFFSET row_value        ;set up LINES_equal sublist                                                       ;AN000;
.ELSE                                                                                                                      ;AN000;
   MOV   row_ptr,OFFSET  NONE_str                                                                                          ;AN000;
.ENDIF                                                                                                                     ;AN000;
display  LINES_equal_msg                                                                                                   ;AN000;
                                                                                                                           ;AN000;
RET                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
display_lines_status ENDP                                                                                                  ;AN000;

;-------------------------------------------------------------------------------

old_video_mode_set_IOCTL   PROC  NEAR                           ;AN004;

MOV   CL,set_display_characteristics                                                                        ;AN000;
CALL do_IOCTL0C                                                                                             ;AN000;
.IF C THEN                                                                                                  ;AN000;
   get_extended_error                                                                                       ;AN000;
   .IF <AX EQ not_supported_on_machine> THEN                                                                ;AN000;
      DISPLAY Function_not_supported                                                                        ;AN000;
   .ELSEIF <AX EQ font_not_loaded> THEN                                                                     ;AN000;
      DISPLAY Required_font_not_loaded                                                                      ;AN000;
   .ENDIF                                                                                                   ;AN000;
   MOV   noerror,false                                                                                      ;AN000;
.ENDIF                     ;AN000;carry                                                                     ;AN000;

RET
                                                                ;AN004;
old_video_mode_set_IOCTL   ENDP                                 ;AN004;

                                                                                                                           ;AN000;
;-------------------------------------------------------------------------------                                           ;AN000;
;                                           ;AN000;
;
; CHECK_COM_PORTS_ATTACHED
; ------------------------
;
;  Return the number of com ports in the machine.
;
;  INPUT: none
;
;
;  RETURN: com_ports_attached - number of com ports
;
;
;  MESSAGES: none
;
;  REGISTER
;  USAGE:      SI - index of the FOR loop and displacement from serial_base
;              ES - holds segment of ROM data area
;
;
;  ASSUMPTIONS: The user has initialized com_ports_attached to zero.
;
;
;  SIDE EFFECT: ES is lost
;               SI is lost
;                                                                                                                         ;AN000;
;                                           ;AN000;

check_com_ports_attached   PROC  NEAR

MOV   SI,0
MOV   ES,SI       ;now ES:SERIAL_BASE addresses 40:0=0:400

.FOR SI = 0 TO 6 STEP 2

   .IF <<WORD PTR ES:SERIAL_BASE[SI]> NE 0> THEN       ;SEE IF THE COM PORT EXISTS
      INC   com_ports_attached
   .ENDIF

.NEXT SI

RET

check_com_ports_attached   ENDP


;-------------------------------------------------------------------------------                                           ;AN000;
;                                           ;AN000;
;
; CHECK_PRN_PORTS_ATTACHED
; ------------------------
;
;  Return the number of printer ports in the machine. The network will put a 2
;  in th address word if the printer is redirected, so for the printer to
;  actually exist the address must be greater than 2 ("redirected").  Since
;  can't have infinite retry on redirected printers only want to count ports
;  with >2 for addresses.
;
;  INPUT: none
;
;
;  RETURN: prn_ports_attached - number of printer ports
;
;
;  MESSAGES: none
;
;  REGISTER
;  USAGE:      SI - index of the FOR loop and displacement from printr
;              ES - holds segment of ROM data area (0 in this case)
;
;
;  ASSUMPTIONS: All valid printer port addresses are >2.
;
;
;  SIDE EFFECT: ES is lost
;               SI is lost
;                                                                                                                         ;AN000;
;                                           ;AN000;

check_prn_ports_attached   PROC  NEAR


MOV   SI,0
MOV   ES,SI       ;now ES:printr addresses 40:8=0:408

.FOR SI = 0 TO 4 STEP 2       ;for each of 3 printer port address holder words

   .IF <<WORD PTR ES:printr[SI]> GT redirected> THEN       ;SEE IF THE PORT EXISTS
      INC   prn_ports_attached
   .ENDIF

.NEXT SI

RET

check_prn_ports_attached   ENDP


;-------------------------------------------------------------------------------                                           ;AN000;
;                                           ;AN000;
;                                                                                                                         ;AN000;
; GET_DEVICE_RETRY_TYPE                                                                                                   ;AN000;
; ---------------------                                                                                                   ;AN000;
;                                                                                                                         ;AN000;
;  Return the type of retry active for comX or lptX.                                                                      ;AN000;
;                                                                                                                         ;AN000;
;  INPUT: device_request - scalar indicating what status the user requested.                                              ;AN000;
;              use the following equates:                                                                                 ;AN000;
;                                                                                                                         ;AN000;
;                  com1_retry_type_status   EQU  0                                                                        ;AN000;
;                  com2_retry_type_status   EQU  2                                                                        ;AN000;
;                  com3_retry_type_status   EQU  4                                                                        ;AN000;
;                  com4_retry_type_status   EQU  6                                                                        ;AN000;
;                  lpt1_retry_type_status                                                                                 ;AN000;
;                  lpt2_retry_type_status                                                                                 ;AN000;
;                  lpt3_retry_type_status                                                                                 ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  RETURN: returned_retry_type - scalar indicating type of retry active for                                               ;AN000;
;               the requested device. compare with the following equates:                                                 ;AN000;
;                                                                                                                         ;AN000;
;                  no_retry_flag                                                                                          ;AN000;
;                  error_status                                                                                    ;AN000;
;                  busy_status                                                                                      ;AN000;
;                  ready_status                                                                                    ;AN000;
;                                                                                                                         ;AN000;
;           retry_type_ptr - set to proper string                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  MESSAGES: none                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  REGISTER                                                                                                               ;AN000;
;  USAGE:      CL - For com ports it serves as bit shift count for the retry type byte.
;                                                                                                                         ;AN000;
;              AL - On exit holds retry type scalar on exit (returned_retry_type)                                        ;AN000;
;                                                                                                                         ;AN000;
;              ES - holds segment of resident mode code                                                                   ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  CONVENTIONS: The value in device_request is used as an index into the LPTX                                             ;AN000;
;                array of retry type flags, or as a bit shift count for the                                               ;AN000;
;                COM retry type byte.                                                                                  ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  ASSUMPTIONS: The user has initialized device_request on entry with                                                ;AN000;
;               the equates provided.                                                                                     ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  SIDE EFFECT: none.                                                                                                     ;AN000;
;                                                                                                                         ;AN000;
;                                           ;AN000;
                                                                                                                           ;AN000;
get_device_retry_type PROC NEAR                                         ;AN665;

PUBLIC get_device_retry_type

PUSH BX                                                                 ;AN665;
PUSH ES                                                                 ;AN665;

XOR  BX,BX                                                              ;AN665;
MOV  ES,BX                             ;set segment to zero             ;AN665;
ASSUME   ES:ROM                        ;tell linker/mother assembler what we did

.IF <<ES:WORD PTR resseg> NE 0000H> THEN    ;IF code resident THEN      ;AN665;
   MOV  ES,ES:WORD PTR resseg[2]            ;ES=seg of resident code    ;AN665;
   ASSUME   ES:NOTHING                      ;tell linker/mother assembler what we did
   .IF <device_type EQ COMx> THEN
      MOV   CL,device_request                ;CL has 0, 2, 4 or 6 for COM 1, 2, 3 or 4 respectively                   ;AC003;
      MOV   returned_retry_type,BYTE PTR ES:res_com_retry_type           ;AL=the status byte for all 4 com ports            ;AN665;
      SHR   returned_retry_type,CL       ;AL=XXXXXX??, where ?? is the retry bits for port in question               ;AC003;
      AND   returned_retry_type,00000011B ;AL=000000??, where ?? is the retry bits for port in question               ;AC003;
   .ELSE                                                                ;AN665;
      MOV  BL,device_request                   ;BX=index into retry bytes in resident code  ;AN665;
      MOV  returned_retry_type,BYTE PTR ES:lpt1_retry_type[BX]          ;AN665;
   .ENDIF                                                               ;AN665;
.ELSE                                                                   ;AN665;
   MOV  returned_retry_type,no_retry_flag                               ;AN665;
.ENDIF                                                                  ;AN665;

.IF <returned_retry_type EQ B> OR               ;COM form of busy flag  ;AN665;
.IF <returned_retry_type EQ busy_status> THEN                           ;AN665;
   MOV   retry_type_ptr,OFFSET B_str                                    ;AN665;
.ELSEIF <returned_retry_type EQ E> OR           ;COM form of error flag     ;AN665;
.IF <returned_retry_type EQ error_status> THEN                      ;AN665;
   MOV   retry_type_ptr,OFFSET E_str                                    ;AN665;
.ELSEIF <returned_retry_type EQ R> OR           ;COM form of ready flag     ;AN665;
.IF <returned_retry_type EQ ready_status> THEN                      ;AN665;
   MOV   retry_type_ptr,OFFSET R_str                                    ;AN665;
.ELSE                                                                   ;AN665;
   MOV   retry_type_ptr,OFFSET NONE_str    ;not E, B or R.              ;AN665;
.ENDIF                                                                  ;AN665;

POP  ES                                                                 ;AN665;
POP  BX                                                                 ;AN665;
RET                                                                     ;AN665;

get_device_retry_type ENDP                                              ;AN665;
                                                                                                                           ;AN000;
;                                           ;AN000;
;                                                                                                                         ;AN000;
; ANALYZE_AND_INVOKE                                                                                                      ;AN000;
; ------------------                                                                                                      ;AN000;
;                                                                                                                         ;AN000;
; The command line is boken down into pieces by "parse_parameters".  Each piece                                           ;AN000;
; is analyzed here, and the appropriate routine called to setup and/or execute                                            ;AN000;
; the requested function.                                                                                                 ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  INPUT: request_type - scalar indicating what operation the user requested.                                             ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  RETURN: none                                                                                                           ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  MESSAGES: none                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  REGISTER                                                                                                               ;AN000;
;  USAGE:       DI - index into the list of parsed parms, the array parm_list.                                            ;AN000;
;                                                                                                                         ;AN000;
;               CX - temporary holder for memory to memory MOVs                                                           ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  CONVENTIONS:                                                                                                           ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  ASSUMPTIONS: All the input are valid. The parm_list entry past the last one                                            ;AN000;
;               has a parm_type of bogus.                                                                                 ;AN000;
;                                                                                                                         ;AN000;
;               The lines and columns values are in binary for request_type=                                              ;AN000;
;               set_con_features                                                                                          ;AN000;
;                                                                                                                         ;AN000;
;               The codepage numbers were put into des_start_packet.                                                      ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;  SIDE EFFECT:                                                                                                           ;AN000;
;                                                                                                                         ;AN000;
;                                                                                                                         ;AN000;
;                                           ;AN000;
                                                                                                                           ;AN000;
analyze_and_invoke  PROC  NEAR      ;AX000;                                                                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;CASE request_type=                                                                                                        ;AN000;
                                                                                                                           ;AN000;
   MOV   cp_cb.des_pack_ptr,OFFSET des_start_packet     ;AX000;In case a codepage request                                  ;AN000;
                                                                                                                           ;AN000;
   MOV   DI,0      ;initialize index into the list of parsed parameters                                                    ;AN000;
                                                                                                                           ;AN000;
   ;calculate the displacement for the jump to the jump                                                                    ;AN000;
   MOV   parm_list_holder,BX           ;save parm_list_BX                                                                  ;AN000;
   XOR   BX,BX                      ;AX000;                                                                                ;AN000;
   MOV   BL,max_request_type        ;AX000;                                                                                ;AN000;
   SUB   BL,request_type            ;AX000;see the list of equates for request_type                                        ;AN000;
   SHL   BX,1                       ;AX000;BX=word displacement into jump table                                            ;AN000;
   JMP   jump_table1[BX]            ;AX000;jump to appropriate jump                                                        ;AN000;
                                                                                                                           ;AN000;
   jump_table1    LABEL    WORD        ;the order of the following entries is critical                                     ;AN000;
                                                                                                                           ;AN000;
   DW   OFFSET all_con_status_case                                                                                         ;AN000;
   DW   OFFSET codepage_prepare_case                                                                                       ;AN000;
   DW   OFFSET codepage_refresh_case                                                                                       ;AN000;
   DW   OFFSET codepage_select_case                                                                                        ;AN000;
   DW   OFFSET codepage_status_case                                                                                        ;AN000;
   DW   OFFSET codepage_prepared_status_case                                                                               ;AN000;
   DW   OFFSET codepage_selected_status_case                                                                               ;AN000;
   DW   OFFSET com_status_case                                                                                             ;AN000;
   DW   OFFSET initialize_com_port_case                                                                                    ;AN000;
   DW   OFFSET initialize_printer_port_case                                                                                ;AN000;
   DW   OFFSET old_initialize_printer_port_case                                                                            ;AN000;
   DW   OFFSET old_video_mode_set_case                                                                                     ;AN000;
   DW   OFFSET printer_reroute_case                                                                                        ;AN000;
   DW   OFFSET printer_status_case                                                                                         ;AN000;
   DW   OFFSET set_con_features_case                                                                                       ;AN000;
   DW   OFFSET status_for_everything_case                                                                                  ;AN000;
   DW   OFFSET turn_off_reroute_case                                                                                       ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   all_con_status_case:                ;know that all con status is requested                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
      MOV      stat_dev_ptr,OFFSET CON_str      ;set up msg ser input                                                      ;AN000;
      MOV      dev_name_size,len_CON_str        ;set up for msg service, see MODEPARS.ASM                                  ;AN000;
      display  status_for_device                                                                                           ;AN000;
      display  long_underline          ;Status for device CON:                                                             ;AN000;
      display  four_char_underline     ;----------------------                                                             ;AN000;
                                                                                                                           ;AN000;
      CAll  check_ANSI_installed       ;see if ANSI.SYS is installed                                                       ;AC001;
      .IF   <ANSI_installed EQ true> THEN    ;IF can get info on settings THEN display them ELSE don't display them
         CALL  display_columns_status                                                                                  ;AN000;
         CALL  display_lines_status                                                                                  ;AN000;
      .ENDIF                                                                                                               ;AC001;
      MOV   cp_cb.request_typ,status         ;set up variables for modecp                                                  ;AN000;
      MOV   cp_cb.cp_device,OFFSET CON_str                                                                                 ;AN000;
                                                                                                                           ;AN000;
      CALL  modecp                        ;display codepage status                                                         ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   codepage_prepare_case:                                                                                                  ;AN000;
                                                                                                                           ;AN000;
      MOV   cp_cb.request_typ,prepare                                                                                      ;AN000;
      CALL  setup_device_name        ;Set the pointer to the device name ASCIIZ in the parameter block for 'modecp'.       ;AN000;
                                                                                                                           ;AN000;
      call  modecp                                                                                                         ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   codepage_refresh_case:                                                                                                  ;AN000;
                                                                                                                           ;AN000;
      MOV   cp_cb.request_typ,refresh                                                                                      ;AN000;
      CALL  setup_device_name        ;Set the pointer to the device name ASCIIZ in the parameter block for 'modecp'.       ;AN000;
                                                                                                                           ;AN000;
      call  modecp                                                                                                         ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   codepage_select_case:                                                                                                   ;AN000;
                                                                                                                           ;AN000;
      MOV   cp_cb.request_typ,select                                                                                       ;AN000;
      CALL  setup_device_name        ;Set the pointer to the device name ASCIIZ in the parameter block for 'modecp'.       ;AN000;
      MOV   des_start_packet.des_strt_pknum,1      ;one cp number                                                          ;AN000;
      MOV   des_start_packet.des_strt_pklen,4      ;bytes for count (word) and one number (word)                           ;AN000;
      MOV   BX,parm_list_holder                         ;restore parm_list_BX                                              ;AN000;
      MOV   DI,codepage_index_holder                    ;DI=index in parm list of the entry for the codepage to be selected;AN000;
      MOV   AX,parm_list_BX[DI].value1                ;AX=codepage number in binary form                                   ;AN000;
      MOV   des_start_packet.des_strt_pkcp1,AX     ;setup parm block with the (single) cp number                           ;AN000;
                                                                                                                           ;AN000;
      CALL  modecp                                                                                                         ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   codepage_status_case:                                                                                                   ;AN000;
   codepage_prepared_status_case:                                                                                          ;AN000;
   codepage_selected_status_case:                                                                                          ;AN000;
                                                                                                                           ;AN000;
      MOV   cp_cb.request_typ,status                                                                                       ;AN000;
      CALL  setup_device_name        ;Set the pointer to the device name ASCIIZ in the parameter block for 'modecp'.       ;AN000;
                                                                                                                           ;AN000;
      CALL  modecp                                                                                                         ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   com_status_case:                                                                                                        ;AN000;
                                                                                                                           ;AN000;
             ; INPUT: device_type = COMx
             ;        device      = ASCII COM number

      MOV   com_ports_attached,0        ;C04 ;check_com_ports assumes this is
                                        ;C04 ;zero.  It has already been called
                                        ;C04 ;so will be wrong if we don't
                                        ;C04 ;reset this here
      CALL  check_com_ports_attached         ;return number of com ports in com_ports_attached                             ;AN000;
                                                                                                                           ;AN000;
      .IF <device_name EQ <OFFSET COM1_str>> AND                                                                           ;AN000;
      .IF <com_ports_attached GE 1> THEN                ;COM1 exists
         MOV   BL,COM1                                                                                                     ;AN000;
         MOV   stat_dev_ptr,OFFSET COM1_str      ;set up msg ser input                                                  ;AN000;
         MOV   device_request,com1_retry_type_status                                                                       ;AN000;
      .ELSEIF <device_name EQ <OFFSET COM2_str>> AND                                                                       ;AN000;
      .IF <com_ports_attached GE 2> THEN                ;COM2 exists
         MOV   BL,COM2                                                                                                     ;AN000;
         MOV   stat_dev_ptr,OFFSET COM2_str      ;set up msg ser input                                                  ;AN000;
         MOV   device_request,com2_retry_type_status                                                                       ;AN000;
      .ELSEIF <device_name EQ <OFFSET COM3_str>> AND                                                                       ;AN000;
      .IF <com_ports_attached GE 3> THEN                ;COM3 exists
         MOV   BL,COM3                                                                                                     ;AN000;
         MOV   stat_dev_ptr,OFFSET COM3_str      ;set up msg ser input                                                  ;AN000;
         MOV   device_request,com3_retry_type_status                                                                       ;AN000;
      .ELSEIF <device_name EQ <OFFSET COM4_str>> AND                                                                       ;AN000;
      .IF <com_ports_attached EQ 4> THEN                ;COM4 exists
         MOV   BL,COM4                                                                                                     ;AN000;
         MOV   stat_dev_ptr,OFFSET COM4_str      ;set up msg ser input                                                  ;AN000;
         MOV   device_request,com4_retry_type_status                                                                       ;AN000;
      .ELSE                                             ;device does not exist                                             ;AN000;
          MOV  CX,device_name                                                              ;AN000;                        ;AN000;
          MOV  illegal_device_ptr,CX      ;put pointer to com port string in message                                       ;AN000;
          DISPLAY err1                   ;AN000;"Illegal device name - COMX"                                               ;AN000;
          MOV  noerror,false                    ;set flag for displaying status to be skipped
      .ENDIF                                                                                                               ;AN000;
      .IF <noerror EQ true> THEN
         MOV      dev_name_size,len_COMX_str       ;set up for msg service, see MODEPARS.ASM                                  ;AN000;
         display  status_for_device                ;"Status for device COM?:"                                                 ;AN000;
         display  long_underline                   ;"------------------"                                                      ;AN000;
         display  five_char_underline           ;has CRLF on it       "-----"                                                 ;AN000;
         call  get_device_retry_type                                                                                          ;AN000;
         display  retry_equal                                                                                                 ;AN000;
      .ENDIF
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  con_status_case:     ;don't know which con status is requested                                                          ;AN000;
                                                                                                                           ;AN000;
;     MOV   request_type,all_con_status   ;AC000;DCR76                                                                     ;AN000;
;     CALL  analyze_and_invoke            ;AC000;DCR76                                                                     ;AN000;
                                                                                                                           ;AN000;
;     MOV      dev_name_size,len_CON_str       ;set up for msg service, see MODEPARS.ASM                                   ;AN000;
;     MOV      stat_dev_ptr,OFFSET CON_str      ;set up msg ser input                                                      ;AN000;
;     display  status_for_device                                                                                           ;AN000;
;     display  long_underline          ;Status for device CON:                                                             ;AN000;
;     display  four_char_underline     ;----------------------                                                             ;AN000;
;                                                                                                                          ;AN000;
;     MOV   DI,0                                                                                                           ;AN000;
;                                                                                                                          ;AN000;
;     .WHILE <parm_list_BX[DI].parm_type NE bogus> DO      ;the entry after the last has parm_type of bogus                ;AN000;
;                                                                                                                          ;AN000;
;        ;CASE parm_list_BX[DI].item_tag=                                                                                  ;AN000;
;                                                                                                                          ;AN000;
;           ;CODEPAGE,                                                                                                     ;AN000;
;           ;PREPARE,                                                                                                      ;AN000;
;           ;SELECT:                                                                                                       ;AN000;
;                                                                                                                          ;AN000;
;                 .IF <parm_list_BX[DI].item_tag EQ CODEPAGE_item_tag> OR                                                  ;AN000;
;                 .IF <parm_list_BX[DI].item_tag EQ SELECT_item_tag> OR                                                    ;AN000;
;                 .IF <parm_list_BX[DI].item_tag EQ PREPARE_item_tag> THEN                                                 ;AN000;
;                                                                                                                          ;AN000;
;              MOV   cp_cb.request_typ,status                                                                              ;AN000;
;              MOV   cp_cb.cp_device,OFFSET CON_str                                                                        ;AN000;
;              CALL  modecp                        ;display codepage status                                                ;AN000;
;                                                                                                                          ;AN000;
;              BREAK 2                                                                                                     ;AN000;
;                                                                                                                          ;AN000;
;                 .ENDIF                                                                                                   ;AN000;
;                                                                                                                          ;AN000;
;           ;BLINK:                                                                                                        ;AN000;
;                                                                                                                          ;AN000;
;                 .IF <parm_list_BX[DI].item_tag EQ BLINK_item_tag> THEN                                                   ;AN000;
;                                                                                                                          ;AN000;
;              CALL  display_blink_status                                                                                  ;AN000;
;                                                                                                                          ;AN000;
;              BREAK 2                                                                                                     ;AN000;
;                                                                                                                          ;AN000;
;                 .ENDIF                                                                                                   ;AN000;
;                                                                                                                          ;AN000;
;                                                                                                                          ;AN000;
;           ;COLUMNS:                                                                                                      ;AN000;
;                                                                                                                          ;AN000;
;                 .IF <parm_list_BX[DI].item_tag EQ COLUMNS_item_tag> THEN                                                 ;AN000;
;                                                                                                                          ;AN000;
;              CALL  display_COLUMNS_status                                                                                ;AN000;
;                                                                                                                          ;AN000;
;              BREAK 2                                                                                                     ;AN000;
;                                                                                                                          ;AN000;
;                 .ENDIF                                                                                                   ;AN000;
;                                                                                                                          ;AN000;
;                                                                                                                          ;AN000;
;           ;LINES:                                                                                                        ;AN000;
;                                                                                                                          ;AN000;
;                 .IF <parm_list_BX[DI].item_tag EQ LINES_item_tag> THEN                                                   ;AN000;
;                                                                                                                          ;AN000;
;              CALL  display_lines_status                                                                                  ;AN000;
;                                                                                                                          ;AN000;
;              BREAK 2                                                                                                     ;AN000;
;                                                                                                                          ;AN000;
;                 .ENDIF                                                                                                   ;AN000;
;                                                                                                                          ;AN000;
;        ENDCASE_2:                                                                                                        ;AN000;
;                                                                                                                          ;AN000;
;        ADD   DI,TYPE parm_list_entry                                                                                     ;AN000;
;                                                                                                                          ;AN000;
;     .ENDWHILE                                                                                                            ;AN000;
                                                                                                                           ;AN000;
;     BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   initialize_com_port_case:                                                                                               ;AN000;
                                                                                                                           ;AN000;

      MOV   BX,parm_list_holder                 ;restore parm_list_BX                                                   ;AN000;

      .IF <parms_form EQ keyword> THEN        ;IF the parms were input as keywords THEN                                    ;AN000;
                                                                                                                           ;AN000;
         MOV   DI,TYPE parm_list_entry          ;skip COMN parm                                                            ;AN000;
                                                                                                                           ;AN000;
         .WHILE <parm_list_BX[DI].parm_type NE bogus> DO NEAR ;the entry after the last has parm_type of bogus             ;AN000;
                                                                                                                           ;AN000;
            ;CASE parm_list_BX[DI].keyword_switch_ptr=                                                                     ;AN000;
                                                                                                                           ;AN000;
               ;BAUD_equal:                                                                                                ;AN000;
                                                                                                                           ;AN000;
                     .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET BAUD_equal>> THEN                                 ;AN000;
                                                                                                                           ;AN000;
                  MOV   AX,parm_list_BX[DI].value1  ;AX= pointer to the baud rate string                                   ;AN000;
                  MOV   pbaud_ptr,AX                ;set pointer to the baud rate string in the messge                     ;AN000;
                  MOV   baud_index,DI                      ;set index into parm list for setcom                            ;AN000;
;C00              BREAK 3                                                                                                  ;AN000;
                  SHORTBREAK 3                                          ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                     .ENDIF                                                                                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
               ;PARITY_equal:                                                                                              ;AN000;
                                                                                                                           ;AN000;
                     .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET PARITY_equal>> THEN                               ;AN000;
                                                                                                                           ;AN000;
                  MOV   SI,parm_list_BX[DI].value1    ;AX= pointer to the parity string                                    ;AN000;
                  MOV   pparity_ptr,SI                ;set pointer to the parity string in the messge                      ;AN000;
                  OR    BYTE PTR [SI],lowercase         ;convert to lowercase for compatibility with previous versions
                  MOV   parity_index,DI               ;set index into parm list for setcom                                 ;AN000;
;C00              BREAK 3                                                                                                  ;AN000;
                  SHORTBREAK 3                                          ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                     .ENDIF                                                                                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
               ;DATA_equal:                                                                                                ;AN000;
                                                                                                                           ;AN000;
                     .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET DATA_equal>> THEN                                 ;AN000;
                                                                                                                           ;AN000;
                  MOV   BP,parm_list_BX[DI].value1    ;BP= pointer to the data bits string                                 ;AN000;
                  MOV   AL,[BP]                       ;AL= data bits character                                             ;AN000;
                  MOV   pdata,AL                      ;set the data bits string in the messge                              ;AN000;
                  MOV   data_bits_index,DI               ;set index into parm list for setcom                              ;AN000;
;C00              BREAK 3                                                                                                  ;AN000;
                  SHORTBREAK 3                                          ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                     .ENDIF                                                                                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
               ;STOP_equal:                                                                                                ;AN000;
                                                                                                                           ;AN000;
                     .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET STOP_equal>> THEN                                 ;AN000;
                                                                                                                           ;AN000;
                  MOV   AX,parm_list_BX[DI].value1    ;AX= pointer to the stop bit string                                  ;AN000;
                  MOV   pstop_ptr,AX                  ;set pointer to the parity string in the messge                      ;AN000;
                  MOV   stop_bits_index,DI               ;set index into parm list for setcom                              ;AN000;
;C00              BREAK 3                                                                                                  ;AN000;
                  SHORTBREAK 3                                          ;C00                                               ;AN000;
                                                                                                                           ;AN000;
                     .ENDIF                                                                                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
               ;RETRY_equal:                                                                                               ;AN000;
                                                                                                                           ;AN000;
                     .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET RETRY_equal_str>> THEN                            ;AN000;
                                                                                                                           ;AN000;
                  MOV   retry_index,DI       ;indicate to modecom which parm is retry                                      ;AN000;
;                 BREAK 3                                                                                                  ;AN000;
                                                                                                                           ;AN000;
                     .ENDIF                                                                                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ENDCASE_3:                                                                                                     ;AN000;
                                                                                                                           ;AN000;
            ADD   DI,TYPE parm_list_entry                                                                                  ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
         .ENDWHILE                                                                                                         ;AN000;
                                                                                                                           ;AN000;
      .ELSE                         ;the parms were entered as positionals (the old form)                                  ;AN000;
                                                                                                                           ;AN000;
         MOV   baud_index,TYPE parm_list_entry                                                                             ;AN000;
         MOV   DI,2 * (TYPE parm_list_entry)                                                                     ;AN000;
         .IF <parm_list_BX[DI].item_tag NE unspecified> THEN                               ;AN000;IF stopbits requested THEN
            MOV   parity_index,DI                                                                     ;AN000;
         .ENDIF
         MOV   DI,3 * (TYPE parm_list_entry)                                                                  ;AN000;
         .IF <parm_list_BX[DI].item_tag NE unspecified> THEN                               ;AN000;IF stopbits requested THEN
            MOV   data_bits_index,DI                                                                                    ;AN000;
         .ENDIF
         MOV   DI,4 * (TYPE parm_list_entry)                                               ;DI=stopbits index  ;AN000;
         .IF <parm_list_BX[DI].item_tag NE unspecified> THEN                               ;AN000;IF stopbits requested THEN
            MOV   stop_bits_index,DI                                                                ;AN000;
         .ENDIF
         MOV   DI,5 * (TYPE parm_list_entry)                  ;AN000;DI=index of retry parm
         .IF <parm_list_BX[DI].item_tag NE unspecified> THEN                               ;AN000;IF retry requested THEN
            MOV   retry_index,DI                                                           ;AN000;set up index for modecom
         .ENDIF                                                                                                            ;AN000;
                                                                                                                           ;AN000;
      .ENDIF                                                                                                               ;AN000;
                                                                                                                           ;AN000;
      CALL  modecom                                                                                                        ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;

                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   old_initialize_printer_port_case:   ;Assume that parms not specified have an entry in parm_list that is in initial state;AN000;

                                       ;printer_no has ASCII form of printer number                                        ;AN000;
                                       ;need to put binary form of columns in columns_holder (80 or 132)                   ;AN000;
                                       ;need to put "6" or "8" in parm2                                                    ;AN000;
                                       ;need to set retry_index                                                            ;AN000;


PUBLIC   old_initialize_printer_port_case

      MOV   BX,parm_list_holder              ;restore parm_list_BX                                                      ;AN000;
      MOV   DI,TYPE parm_list_entry          ;skip LPTN parm, point at chars per line                             ;AN000;

      .IF <parm_list_BX[DI].item_tag EQ onethirtytwo_item_tag> THEN                                               ;AN000;
         MOV   columns_holder,132                                                                                 ;AN000;
      .ELSEIF <parm_list_BX[DI].item_tag EQ eighty_item_tag> THEN                                               ;AN000;
         MOV   columns_holder,80                                                                                  ;AN000;
      .ENDIF                                 ;if not 80 or 132 modeprin assumes not specified, and makes no change;AN000;
      ADD   DI,TYPE parm_list_entry          ;look at lines per inch                                                       ;AN000;

      .IF <parm_list_BX[DI].item_tag NE unspecified> THEN       ;IF chars per line specified THEN             ;AN000;
         MOV   SI,parm_list_BX[DI].value1         ;SI=>"6" or "8"                                         ;AN000;
         MOV   AL,BYTE PTR DS:[SI]                                                                                   ;AN000;
         MOV   parm2,AL                       ;parm2="6" or "8"                                                 ;AN000;
      .ENDIF   ;otherwise leave parm2=0FFH (unspecified)  ;AN000;

      ADD   DI,TYPE parm_list_entry          ;look at retry request                                                       ;AN000;
      .IF <parm_list_BX[DI].item_tag NE unspecified> THEN                                                         ;AN000;
         MOV   retry_index,DI                ;AN000;let modeprin know retry was requested and the index of it.
      .ENDIF                                 ;AN000;

      CALL  modeecno                                                                                                       ;AN000;
      CALL  modeprin                                                                                                       ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;



   initialize_printer_port_case:    ;printer_no has ASCII form of printer number                                           ;AN000;
                                    ;need to put binary form of columns in columns_holder (80 or 132)                      ;AN000;
                                    ;need to put "6" or "8" in parm2                                                       ;AN000;
                                    ;need to set retry_index                                                               ;AN000;
                                                                                                                           ;AN000;
      MOV   BX,parm_list_holder                 ;restore parm_list_BX                                                      ;AN000;
      MOV   DI,TYPE parm_list_entry          ;skip LPTN parm                                                               ;AN000;

      .WHILE <parm_list_BX[DI].parm_type NE bogus> DO      ;the entry after the last has parm_type of bogus                ;AN000;
                                                                                                                           ;AN000;
         ;CASE parm_list_BX[DI].keyword_switch_ptr=                                                                        ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ;LINES_equal:                                                                                                  ;AN000;
                                                                                                                           ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET LINES_equal>> THEN                                   ;AN000;
                                                                                                                           ;AN000;
               MOV   SI,parm_list_BX[DI].value1         ;SI=>"6" or "8"                                                    ;AN000;
               MOV   AL,BYTE PTR DS:[SI]                                                                                   ;AN000;
               MOV   parm2,AL                           ;parm2="6" or "8"                                                  ;AN000;
;C00           BREAK 4                                                                                                     ;AN000;
               SHORTBREAK 4                                             ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                  .ENDIF                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ;COLUMNS_equal:                                                                                                ;AN000;
                                                                                                                           ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET COLUMNS_equal>> OR                                   ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET COLS_equal>> THEN                                    ;AN000;
                                                                                                                           ;AN000;
               .IF <parm_list_BX[DI].item_tag EQ onethirtytwo_item_tag> THEN                                               ;AN000;
                  MOV   columns_holder,132                                                                                 ;AN000;
               .ELSE                                                                                                       ;AN000;
                  MOV   columns_holder,80                                                                                  ;AN000;
               .ENDIF                                                                                                      ;AN000;
;C00           BREAK 4                                                                                                     ;AN000;
               SHORTBREAK 4                                             ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                  .ENDIF                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ;RETRY_equal:                                                                                                  ;AN000;
                                                                                                                           ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET RETRY_equal_str>> THEN                               ;AN000;

               MOV   retry_index,DI                                                                                        ;AN664;
;C00           BREAK 4                                                                                                     ;AN000;
               SHORTBREAK 4                                             ;C00                                                  ;AN000;
                                                                                                                           ;AN000;
                  .ENDIF                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
         ENDCASE_4:                                                                                                        ;AN000;
                                                                                                                           ;AN000;
         ADD   DI,TYPE parm_list_entry                                                                                     ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
      .ENDWHILE                                                                                                            ;AN000;

      CALL  modeecno       ;turn of rerouting                                                                              ;AN000;
      CALL  modeprin                                                                                                       ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   old_video_mode_set_case:                                                                                                ;AN000;
                                                                                                                           ;AN000;
   PUBLIC   old_video_mode_set_case                                                                                        ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
      ;first see if ANSI.SYS is loaded                                                                               ;AN000;
      CALL  check_ANSI_installed                                                                                     ;AC001;
      .IF <ANSI_installed EQ true> THEN                                                                                   ;AC001;
         MOV   CL,get_current_settings                                                                               ;AN000;
         PUSH  BX                         ;save parm_list                                                            ;AN000;
         CALL  do_IOCTL0C                    ;get current settings of CON                                            ;AN000;
         POP   BX                                 ;restore parm_list                                                 ;AN000;
         MOV   IOCTL0C_data_block.mode,text                                                                          ;AN000;
      .ENDIF                        ;AN000;ANSI installed                                                            ;AN000;
      MOV   BX,parm_list_holder                 ;restore parm_list_BX                                                      ;AN000;
      PUSH  DI                                  ;save parm list index                                                      ;AN000;
      cmp parm_list_BX[DI].item_tag,unspecified                         ;*A
      jnz       specified_line                                          ;*A
      jmp       not_specified_line                                      ;*A
specified_line:                                                         ;*A
         .IF <parm_list_BX[DI].item_tag EQ BW40_item_tag> THEN ;IF BW40 REQUESTED                              ;AN000;
            MOV   IOCTL0C_data_block.cols,40      ;setup IOCTL input block ;*A
            MOV   IOCTL0C_data_block.colors,16; colors 16 for all but mono  ;*A
            CALL BW40                                                                                                         ;AN000;
         .ELSEIF <parm_list_BX[DI].item_tag EQ BW80_item_tag> THEN ;IF BW80 REQUESTED                                         ;AN000;
            MOV   IOCTL0C_data_block.cols,80  ;assume 80 lines,change on 43 ;*A
            MOV   IOCTL0C_data_block.colors,16; colors 16 for all but mono  ;*A
            CALL  BW80                                                                                                        ;AN000;
         .ELSEIF <parm_list_BX[DI].item_tag EQ CO40_item_tag> THEN ;IF CO40 REQUESTED                                         ;AN000;
            MOV   IOCTL0C_data_block.cols,40      ;setup IOCTL input block ;*A
            MOV   IOCTL0C_data_block.colors,16; colors 16 for all but mono  ;*A
            CALL  CO40                                                                                                        ;AN000;
         .ELSEIF <parm_list_BX[DI].item_tag EQ CO80_item_tag> THEN ;IF CO80 REQUESTED                                         ;AN000;
            MOV   IOCTL0C_data_block.cols,80  ;assume 80 lines,change on 43 ;*A
            MOV   IOCTL0C_data_block.colors,16; colors 16 for all but mono  ;*A
            CALL  CO80                                                                                                        ;AN000;
         .ELSEIF <parm_list_BX[DI].item_tag EQ MONO_item_tag> THEN ;IF MONO REQUESTED                                         ;AN000;
            MOV   IOCTL0C_data_block.cols,80  ;assume 80 lines,change on 43 ;*A
            MOV   IOCTL0C_data_block.colors,0 ; colors 16 for all but mono  ;*A
            CALL  MONO                                                                                                        ;AN000;
         .ELSE                                                                                                                ;AN000;
            .IF <ANSI_installed EQ true> THEN                              ;AN000;
               .IF <parm_list_BX[DI].value1 EQ <OFFSET fourty_str>> THEN                                       ;AN000;
                  MOV   IOCTL0C_data_block.cols,40      ;setup IOCTL input block with the columns requested        ;AN000;
                  MOV   DX,bitBW40                      ;AC006;set up for OR in set_equipment_word
               .ELSE
                  MOV   IOCTL0C_data_block.cols,80      ;setup IOCTL input block with the columns requested           ;AN000;
                  MOV   DX,bitBW80                      ;AC006;set up for OR in set_equipment_word
               .ENDIF                                                                                                      ;AN000;
               PUSH  DX                                 ;AN006;save mask
               CALL  old_video_mode_set_IOCTL                   ;AN004;use IOCTL if possible to retain lines setting  ;AN000;
               POP   DX                                 ;AN006;
            .ELSE
               .IF <parm_list_BX[DI].item_tag EQ fourty_item_tag> THEN ;IF 40 REQUESTED                                    ;AN000;
                  MOV  BL,40                        ;set up for handle_40_or_80                            ;AN000;
                  MOV  DX,bitBW40                   ;set up for OR in set_equipment_word
               .ELSE                                                                                                       ;AN000;
                  MOV  BL,80                        ;set up for handle_40_or_80                            ;AN000;
                  MOV  DX,bitBW80                   ;set up for OR in set_equipment_word
               .ENDIF                                                                                                      ;AN000;
               CALL HANDLE_40_OR_80                                                                                     ;AN000;
            .ENDIF
            CALL set_equipment_word                     ;AN006;change video bits
         .ENDIF                                                                                                               ;AN000;

not_specified_line:                                                     ;*A
      POP   DI                                  ;restore parm list index                                                   ;AN000;

      .IF <NOERROR EQ TRUE> AND              ;process ,r  l,[T]                                                         ;AN000;
      MOV   BX,parm_list_holder                 ;restore parm_list_BX                                                      ;AN000;
      ADD   DI,SIZE parm_list_entry       ;process second parm, shift direction                                            ;AN000;
      .IF <parm_list_BX[DI].item_tag NE unspecified> THEN                                                                  ;AN000;
         .IF <parm_list_BX[DI].item_tag EQ R_item_tag> OR                                                                  ;AN000;
         .IF <parm_list_BX[DI].item_tag EQ L_item_tag> THEN                                                                ;AN000;
            MOV   CL,parm_list_BX[DI].item_tag                                                                             ;AN000;
            MOV   PARM2,CL          ;set up for SHIFT_SCREEN                                                               ;AN000;
            ADD   DI,TYPE parm_list_entry       ;look at third parm                                                        ;AN000;
            MOV   CL,parm_list_BX[DI].item_tag  ;CL=T_item_tag or bogus                                                 ;AN000;
            MOV   PARM3,CL          ;may be bogus, but shift_screen will handle it correctly                               ;AN000;
            CALL  SHIFT_SCREEN                                                                                             ;AN000;
         .ELSE                      ;AN000;must be a rows value
            .IF <ANSI_installed EQ true> THEN                              ;AN000;
;AC004;        MOV   need_IOCTL0C,true                       ;use IOCTL if possible to retain lines setting  ;AN000;
               MOV   DX,parm_list_BX[DI].value1                                                                            ;AN000;
               MOV   IOCTL0C_data_block.rows,DX         ;the IOCTL input block has the columns requested                   ;AN000;
               CALL  old_video_mode_set_IOCTL                ;AN004;use IOCTL if possible to retain lines setting  ;AN000;
            .ELSE                         ;AN000;ANSI not installed                                                        ;AN000;
               DISPLAY ANSI_not_loaded                                                                                     ;AN000;
               MOV   noerror,false                                                                                         ;AN000;
            .ENDIF                        ;AN000;ANSI installed                                                            ;AN000;
         .ENDIF                                                                                                            ;AN000;
      .ENDIF                                                                                                               ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;


                                                                                                                           ;AN000;
PUBLIC   printer_reroute_case
                                                                                                                           ;AN000;
   printer_reroute_case:
                        ;INPUT:lptno=zero based printer number OUTPUT:;AH=printer number mask: lpt1=1, lpt2=2, lpt3=4      ;AN000;
                              ;device=COM number in ASCII form        ;SI=printer number value (one based)                ;AN000;
                                                                      ;AL=com number character                             ;AN000;
      XOR   CX,CX
      MOV   CL,lptno          ;lptno always <= 255
      MOV   SI,CX             ;SI=zero based printer number (0, 1, or 2)                                                 ;AN000;
      INC   SI                ;SI=one based printer number (1, 2, or 3)                                                 ;AN000;
      MOV   AH,1                                                                                                           ;AN000;
      SAL   AH,CL             ;AH=2**SI,AH=printer number mask for MODEECHO                                                ;AN000;
      MOV   DH,CL
      ADD   DH,ASCII_1        ;DH=ASCII printer number                                                                     ;AN000;
      MOV   AL,device         ;AL=ASCII form of com device number       ;AN000;
      MOV   REDPT,DH          ;PUT n OF LPTn IN REDIRECT MESSAGE
      MOV   NOTREDPT,DH       ;AND INTO NOT REDIRECTED MSG
      CALL  modeecho                                                                                     ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   printer_status_case:                                                                                                    ;AN000;

PUBLIC   printer_status_case

             ; INPUT: device_type = LPTx
             ;        device      = ASCII printer number
             ;        lptno       = ASCII printer number
             ;        device_name = offset of printer string
                                                                                                                           ;AN000;

      MOV   cp_cb.request_typ,status                                                                                       ;AN000;
      MOV   AX,device_name                                                                                                 ;AN000;
      MOV   stat_dev_ptr,AX             ;AC665;set up msg ser input                                                        ;AN000;
      MOV   dev_name_size,len_LPTX_str  ;AN000;set up for msg service, see MODEPARS.ASM                                    ;AN000;
      MOV   cp_cb.cp_device,AX         ;AN665;set up for call to modecp                                                    ;AN000;
                                                                                                                           ;AN000;
      .IF <device_name EQ <OFFSET LPT1_str>> THEN                                                                          ;AN000;
         MOV   device_request,lpt1_retry_type_status                                                                       ;AN000;
         MOV   rerouted_printer_mask,LPT1
         MOV   redpt,"1"                                ;set up for reroute message
         MOV   notredpt,"1"                             ;set up for not rerouted message
      .ELSEIF <device_name EQ <OFFSET LPT2_str>> THEN                                                                      ;AN000;
         MOV   device_request,lpt2_retry_type_status                                                                       ;AN000;
         MOV   rerouted_printer_mask,LPT2
         MOV   redpt,"2"                                ;set up for reroute message
         MOV   notredpt,"2"                             ;set up for not rerouted message
      .ELSEIF <device_name EQ <OFFSET LPT3_str>> THEN                                                                      ;AN000;
         MOV   device_request,lpt3_retry_type_status                                                                       ;AN000;
         MOV   rerouted_printer_mask,LPT3
         MOV   redpt,"3"                                ;set up for reroute message
         MOV   notredpt,"3"                             ;set up for not rerouted message
      .ENDIF                                                                                                               ;AN000;
                                                                                                                           ;AN000;
      PUSH  ES                               ;save ES, used in MODECP                                                      ;AC002;
;AC002;PUSH  AX          ;AN000;save
                                                                                                                           ;AN000;
      display  status_for_device                                                                                           ;AN000;
      display  long_underline                                 "Status for device LPTX?"                                    ;AN000;
      display  five_char_underline           ;has CRLF on it   -----------------------                                     ;AN000;
      call  display_printer_reroute_status               ;see modeecho.asm                                             ;AN000;
;AC002;POP   AX                                          ;restore "device_request"                                          ;AN000;
      XOR   CX,CX             ;initialize prn_ports_attached                                                               ;AN000;
      CALL  check_prn_ports_attached   ;return number of printer cards in prn_ports_attached                               ;AN000;
      POP   ES                               ;restore ES                                                                   ;AC002;
      ADD   prn_ports_attached,ASCII_0        ;CX=ASCII form of last printer number                                        ;AN000;
      .IF <prn_ports_attached GE redpt> THEN    ;IF the printer exists THEN                                                ;AN000;
         call  get_device_retry_type                                                                                       ;AN000;
         display  retry_equal                                                                                              ;AN000;
         CALL  modecp                        ;display codepage status                                                      ;AN000;
      .ENDIF                                                                                                              ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
;m                                                                                                                       ;AN000;
   set_con_features_case:        ;the command line was nothing but con keywords                                            ;AN000;
                                                                                                                           ;AN000;
      ;first see if ANSI.SYS is loaded                                                                                     ;AN000;
      CALL  check_ANSI_installed                                                                                           ;AC001;
      .IF <ANSI_installed EQ true> THEN                                                                                    ;AC001;
         MOV   CL,get_current_settings                                                                                     ;AN000;
         CALL  do_IOCTL0C                    ;get current settings of CON                                                  ;AN000;
         ;MOV   SI,OFFSET IOCTL0C_data_block  ;set up IOCTL0C, addressablitiy to the IOCTL data block                      ;AN000;
                                                                                                                           ;AN000;
         MOV   IOCTL0C_data_block.mode,text                                                                                ;AN000;
                                                                                                                           ;AN000;
      .ENDIF   ;ANSI.SYS installed                                                                                         ;AN000;
                                                                                                                           ;AN000;
      MOV   BX,parm_list_holder                 ;restore parm_list_BX                                                      ;AN000;
      ADD   DI,TYPE parm_list_entry             ;skip CON parm                                                             ;AN000;
      .WHILE <parm_list_BX[DI].parm_type NE bogus> DO NEAR ;the entry after the last has parm_type of bogus                ;AN000;
                                                                                                                           ;AN000;
         ;CASE parm_list_BX[DI].keyword_switch_ptr=                                                                        ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ;LINES_equal:                                                                                                  ;AN000;
                                                                                                                           ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET LINES_equal>> THEN                                   ;AN000;
                                                                                                                           ;AN000;
               MOV   DX,parm_list_BX[DI].value1                                                                            ;AN000;
               MOV   IOCTL0C_data_block.rows,DX         ;the IOCTL input block has the columns requested                   ;AN000;
               MOV   need_IOCTL0C,true                                                                                     ;AN000;
;C00           BREAK 1                                                                                                     ;AN000;
               SHORTBREAK 1                                             ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                  .ENDIF                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ;COLUMNS_equal:       ;the value is binary                                                                     ;AN000;
                                                                                                                           ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET COLUMNS_equal>> OR                                   ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET COLS_equal>> THEN                                    ;AN000;
                                                                                                                           ;AN000;
               .IF <ANSI_installed EQ true> THEN                              ;AN000;
                  MOV   need_IOCTL0C,true                       ;use IOCTL if possible to retain lines setting  ;AN000;
                  MOV   DX,parm_list_BX[DI].value1                                                                            ;AN000;
                  MOV   IOCTL0C_data_block.cols,DX         ;the IOCTL input block has the columns requested                   ;AN000;
               .ENDIF
               .IF <parm_list_BX[DI].item_tag EQ fourty_item_tag> THEN ;IF 40 REQUESTED                                    ;AN000;
                  MOV  columns_specified,40             ;set up for handle_40_or_80 if needed            ;AN000;
                  MOV   DX,bitBW40                      ;AC006;set up for OR in set_equipment_word
               .ELSE                                                                                                       ;AN000;
                  MOV  columns_specified,80             ;set up for handle_40_or_80 if needed  ;AN000;
                  MOV   DX,bitBW80                      ;AC006;set up for OR in set_equipment_word
               .ENDIF                                                                                           ;AN000;
               CALL  set_equipment_word      ;AN006;change video bits in equipment word
;C00           BREAK 1                                                                                          ;AN000;
               SHORTBREAK 1                                             ;C00                                         ;AN000;
                                                                                                                           ;AN000;
                  .ENDIF                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ;RATE_equal:                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET RATE_equal>> THEN                                    ;AN000;
                                                                                                                           ;AN000;
               MOV   AL,BYTE PTR parm_list_BX[DI].value1       ;save the rate requested in binary form, always <255        ;AN000;
               MOV   rate_holder,AL                                                                                        ;AN000;
               MOV   need_typamat_call,true                                                                                ;AN000;
;C00           BREAK 1                                                                                                     ;AN000;
               SHORTBREAK 1                                             ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                  .ENDIF                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
            ;DELAY_equal:                                                                                                  ;AN000;
                                                                                                                           ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET DELAY_equal>> OR                                     ;AN000;
                  .IF <parm_list_BX[DI].keyword_switch_ptr EQ <OFFSET DEL_equal>> THEN                                     ;AN000;
                                                                                                                           ;AN000;
               MOV   AL,BYTE PTR parm_list_BX[DI].value1      ;save delay requested (binary), always <255                  ;AN000;
               MOV   delay_holder,AL                                                                                       ;AN000;
               MOV   need_typamat_call,true                                                                                ;AN000;
;C00           BREAK 1                                                                                                     ;AN000;
               SHORTBREAK 1                                             ;C00                                                    ;AN000;
                                                                                                                           ;AN000;
                  .ENDIF                                                                                                   ;AN000;
                                                                                                                           ;AN000;
         ENDCASE_1:                                                                                                        ;AN000;
                                                                                                                           ;AN000;
         ADD   DI,TYPE parm_list_entry       ;address next parm                                                            ;AN000;
                                                                                                                           ;AN000;
      .ENDWHILE                                                                                                            ;AN000;
                                                                                                                           ;AN000;
DUMMY3:                                                                                                                    ;AN000;
PUBLIC DUMMY3                                                                                                              ;AN000;
                                                                                                                           ;AN000;
      .IF <need_IOCTL0C EQ true> THEN                                                                                      ;AN000;
         .IF <ANSI_installed EQ true> THEN                                                                                 ;AN000;
            MOV   CL,set_display_characteristics                                                                           ;AN000;
            CALL do_IOCTL0C                                                                                                ;AN000;
            .IF C THEN                                                                                                     ;AN000;
               get_extended_error                                                                                          ;AN000;
               .IF <AX EQ not_supported_on_machine> THEN                                                                   ;AN000;
                  DISPLAY Function_not_supported                                                                           ;AN000;
               .ELSEIF <AX EQ font_not_loaded> THEN                                                                        ;AN000;
                  DISPLAY Required_font_not_loaded                                                                         ;AN000;
               .ENDIF                                                                                                      ;AN000;
               MOV   noerror,false                                                                                         ;AN000;
            .ENDIF                                                                                                         ;AN000;
         .ELSE                                                                                                             ;AN000;
            DISPLAY ANSI_not_loaded                                                                                        ;AN000;
            MOV   noerror,false                                                                                            ;AN000;
         .ENDIF                                                                                                            ;AN000;
      .ELSEIF <columns_specified NE false> THEN                                                                            ;AN000;
         MOV   BL,columns_specified                     ;set up for call to handle_40_or_80                                ;AN000;
         CALL  HANDLE_40_OR_80                                                                                             ;AN000;
      .ENDIF                                                                                                               ;AN000;

      .IF <need_typamat_call EQ true> THEN                                                                                 ;AN000;
         MOV   BL,rate_holder                                                                                              ;AN000;
         MOV   BH,delay_holder                                                                                             ;AN000;
         CALL  typamat                                                                                                     ;AN000;
      .ENDIF                                                                                                               ;AN000;
                                                                                                                           ;AN000;
      BREAK 0                                                                                                              ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
   status_for_everything_case:                                                                                             ;AN000;
                                                                                                                           ;AN000;
      MOV   request_type,printer_status         ;status routine for printers                                               ;AN000;
      MOV   device_name,OFFSET LPT1_str         ;will display the reroute                                                  ;AN000;
      CALL  analyze_and_invoke                  ;status for the printer whether                                            ;AN000;
      MOV   device_name,OFFSET LPT2_str         ;it exists or not, so call for                                             ;AN000;
      CALL  analyze_and_invoke                  ;all of them                                                               ;AN000;
      MOV   device_name,OFFSET LPT3_str                                                                                    ;AN000;
      CALL  analyze_and_invoke                                                                                             ;AN000;
                                                                                                                           ;AN000;
      MOV   request_type,all_con_status                                                                                    ;AN000;
      CALL  analyze_and_invoke                                                                                             ;AN000;
      MOV   NOERROR,true                        ;Errors to this point are  ;C04
                                                ;because DISPLAY.SYS or    ;C04
                                                ;PRINTER.SYS is not loaded,;C04
                                                ;and if not reset here not ;C04
                                                ;all statuses will show up.;C04

      CALL  check_com_ports_attached         ;return number of com ports in com_ports_attached                             ;AN000;

      MOV   request_type,com_status                                                                                        ;AN000;
      MOV   device_type, COMx			; M005
      MOV   CL,com_ports_attached                                                                                          ;AN000;
      .FOR  i = 1 TO CL                                                                                                    ;AN000;

         .SELECT                                                                                                           ;AN000;

            .WHEN <i EQ 1>                                                                                                 ;AN000;
               MOV   device_name,OFFSET COM1_str                                                              ;AN000;      ;AN000;

            .WHEN <i EQ 2>                                                                                                 ;AN000;
               MOV   device_name,OFFSET COM2_str                                                                           ;AN000;

            .WHEN <i EQ 3>                                                                                                 ;AN000;
               MOV   device_name,OFFSET COM3_str                                                                           ;AN000;

            .WHEN <i EQ 4>                                                                                                 ;AN000;
               MOV   device_name,OFFSET COM4_str                                                                       ;AN0;AN000;

         .ENDSELECT                                                                                                        ;AN000;

         CALL  analyze_and_invoke                                                                                ;AN000;   ;AN000;
      .NEXT i                                                                                                              ;AN000;

;C00  BREAK 0                                                                                                 ;AN000;
      SHORTBREAK 0                                                      ;C00                                       ;AN000;



   turn_off_reroute_case:               ;user specified only LPTx[:]                                        ;AN000;
                        ;INPUT:lptno=ASCII printer number



      CALL  modeecno    ;turn off rerouting                                                                                ;AN000;
      XOR   CX,CX             ;initialize prn_ports_attached
      CALL  check_prn_ports_attached   ;return number of printer cards in prn_ports_attached
      ADD   prn_ports_attached,ASCII_0        ;CX=ASCII form of last printer number
      .IF <prn_ports_attached GE LPTNO> THEN    ;IF the printer exists THEN
         CALL  set_retry_type                   ;turn off infinit retry                                                    ;AN000;
         CALL  modify_resident_code             ;modify resident code to reflect retry turned off                          ;AN000;
      .ENDIF

;C00  BREAK 0                                                                                                              ;AN000;
      SHORTBREAK 0                                                      ;C00                                                    ;AN000;

                                                                                                                           ;AN000;
ENDCASE_0:                                                                                                                 ;AN000;
                                                                                                                           ;AN000;
RET                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
analyze_and_invoke  ENDP                                                                                                   ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
PRINTF_CODE ENDS                                                                                                           ;AN000;
        END                                                                                                                ;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\display.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;m
PRINTF_CODE SEGMENT PUBLIC

ASSUME CS:PRINTF_CODE, DS:PRINTF_CODE, ES:PRINTF_CODE, SS:PRINTF_CODE


;  P U B L I C S  ͻ
;											  

PUBLIC	 initialize_sublists

;											  
;  P U B L I C S  ͼ

;*****************************************************************************
; External Declarations
;*****************************************************************************
;

EXTRN	 first_sublist:BYTE
EXTRN	 number_of_sublists:ABS
EXTRN	 SysDispMsg:Near






;
;***************************************************************************
; Message Structures
;***************************************************************************
;


Message_Table struc				;				;AN000;
						;
Entry1	dw	0				;				;AN000;
Entry2	dw	0				;				;AN000;
Entry3	dw	0				;				;AN000;
Entry4	dw	0				;				;AN000;
Entry5	db	0				;				;AN000;
Entry6	db	0				;				;AN000;
Entry7	dw	0				;				;AN000;
						;
Message_Table ends				;				;AN000;

include common.stc	      ;contains the following structure

;sublist_def  STRUC

;	      db  ?  ;Sublist Length, fixed
;	      db  ?  ;Reserved, not used yet		       ;AN000;
;	      dw  ?  ;offset
;sublist_seg  dw  ?  ;segment part of pointer to piece of message
;	      db  ?  ;ID, special end of message format ;AN000;
;	      db  ?  ;flags
;	      db  ?
;	      db  ?
;	      db  ?

;sublist_def  ENDS

;
;
; INITIALIZE_SUBLISTS
; -------------------
; A .COM file cannot have references to segments in it at EXE2BIN time so
; the segment part of pointers to pieces of messages in sublist blocks must
; be done at execution time.  This routine does that for all sublists.
;
;
; INPUT:
;
;
;
;
;
;
;
; RETURN:
;
;
;  MESSAGES:	 none
;
;
;
;  REGISTER
;  USAGE AND
;  COMVENTIONS:
;
;
;
;  ASSUMPTIONS:
;
;
;  SIDE EFFECT:
;
;
;   
;
; BEGIN
;										
; END										
;
;

initialize_sublists  PROC  NEAR 										 ;AN000;

MOV   CX,number_of_sublists											 ;AN000;
MOV   SI,OFFSET first_sublist	       ;address first sublist							 ;AN000;
REPEAT: 													 ;AN000;
   MOV	 [SI].sublist_seg,DS	       ;set up the segment part of the pointer field in the sublist block	 ;AN000;
   ADD	 SI,TYPE sublist_def	       ;point to next sublist block						 ;AN000;
LOOPNZ	repeat													 ;AN000;
														 ;AN000;
RET
														 ;AN000;
initialize_sublists  ENDP

;*****************************************************************************
;PRINTF
;*****************************************************************************
;
;Description: Save all registers, set up registers required for SysDispMsg
;	      routine. This information is contained in a message description
;	      table pointed to by the DX register. Call SysDispMsg, then
;	      restore registers. This routine assumes that the only time an
;	      error will be returned is if an extended error message was
;	      requested, so it will ignore error returns
;
;Called Procedures: sysdispmsg
;
;Change History:    Created	   4/22/87	   MT
;
;Input:    ES:DX = pointer to message description
;
;Output:   None
;
;Psuedocode
;----------
;
;	Save all registers
;	Setup registers for SysDispMsg from Message Description Tables
;	CALL SysDispMsg
;	Restore registers
;	ret
;*****************************************************************************

Public	PRINTF
PRINTF	 PROC  NEAR		     ;				     ;AN000;

;	push	ax
						;Save registers 		;AN000;
	push	bx				; "  "    "  "                  ;AN000;
	push	cx				; "  "    "  "                  ;AN000;
	push	dx				; "  "    "  "                  ;AN000;
	push	si				; "  "    "  "                  ;AN000;
	push	di				; "  "    "  "                  ;AN000;
	mov	di,dx				;Change pointer to table	;AN000;
	mov	ax,[di].Entry1			  ;Message number		  ;AN000;
	mov	bx,[di].Entry2			  ;Handle			  ;AN000;
	mov	si,[di].Entry3			  ;Sublist			  ;AN000;
	mov	cx,[di].Entry4			  ;Count			  ;AN000;
	mov	dh,[di].Entry5			  ;Class			  ;AN000;
	mov	dl,[di].Entry6			  ;Function			  ;AN000;
	mov	di,[di].Entry7			  ;Input			  ;AN000;
	call	SysDispMsg			;Display the message		;AN000;
	pop	di				;Restore registers		;AN000;
	pop	si				; "  "    "  "                  ;AN000;
	pop	dx				; "  "    "  "                  ;AN000;
	pop	cx				; "  "    "  "                  ;AN000;
	pop	bx				; "  "    "  "                  ;AN000;
;	pop	ax				; "  "    "  "                  ;AN000;
	ret					;All done			;AN000;

PRINTF	ENDP			 ;				 ;AN000;

PRINTF_CODE ENDS

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\xmm.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1991
; *                      All Rights Reserved.
; */
/*
 *	XMS Driver C Interface Routine Definitions
 *
 */

unsigned	XMM_Installed(void);

long	XMM_Version(void);
long	XMM_RequestHMA(unsigned);
long	XMM_ReleaseHMA(void);
long	XMM_GlobalEnableA20(void);
long	XMM_GlobalDisableA20(void);
long	XMM_EnableA20(void);
long	XMM_DisableA20(void);
long	XMM_QueryA20(void);
long	XMM_QueryLargestFree(void);
long	XMM_QueryTotalFree(void);
long	XMM_AllocateExtended(unsigned);
long	XMM_FreeExtended(unsigned);
long	XMM_MoveExtended(struct XMM_Move *);
long	XMM_LockExtended(unsigned);
long	XMM_UnLockExtended(unsigned);
long	XMM_GetHandleLength(unsigned);
long	XMM_GetHandleInfo(unsigned);
long	XMM_ReallocateExtended(unsigned, unsigned);
long	XMM_RequestUMB(unsigned);
long	XMM_ReleaseUMB(unsigned);

struct	XMM_Move {
	unsigned long	Length;
	unsigned short	SourceHandle;
	unsigned long	SourceOffset;
	unsigned short	DestHandle;
	unsigned long	DestOffset;
};

#define	XMSERROR(x)	(char)((x)>>24)


struct _handle {
    unsigned char hType;
    unsigned char hLocks;
    unsigned long hBase;
    unsigned long hLen;
};

struct _handle far *HimemHandleTable(unsigned int *, unsigned int *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mem\wintest.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1988 - 1993
; *                      All Rights Reserved.
; */
;
; Checks to see if Windows is running.  Returns 1 if Windows 3.0 or
;   above is running, 0 otherwise.


.MODEL SMALL


TRUE                EQU   1

NO_WINDOWS          EQU   0
WIN_286             EQU   1
WIN_386             EQU   2
WIN_REAL_MODE       EQU   3
WIN_STANDARD_MODE   EQU   4
WIN_ENHANCED_MODE   EQU   5
WIN_UNKNOWN_MODE    EQU   6

wWindowsType        EQU   Word Ptr [bp-02]
wWindowsMajor       EQU   Word Ptr [bp-04]
wWindowsMinor       EQU   Word Ptr [bp-06]
fDosShell           EQU   Word Ptr [bp-08]

.CODE

public _IsWindowsRunning


_IsWindowsRunning proc

; Make room for local variables

  push    bp
  mov     bp,sp
  sub     sp,8

; Set fDosShell to FALSE

  xor     ax,ax                   ; Zero out fDosShell
  mov     fDosShell,ax


;*************************************************************************
;* The following code was taken from MSD 2.01's OSINFO.C, WinVerDetect() *
;*************************************************************************

; Check for Windows 3.1

  mov     ax,160Ah                ; WIN31CHECK
  int     2Fh                     ; check if running under win 3.1
  or      ax,ax
  jnz     Win30EnhModeCheck

; Windows 3.1 detected

  mov     wWindowsMajor,3         ; Set the version number
  mov     wWindowsMinor,10

;   CX = 3 - Enhanced, CX = 2 - Standard, CX = 1 - Real.

  cmp     cx,1
  jne     Win31StdChk
  mov     wWindowsType, WIN_REAL_MODE
  jmp     WinDetectComplete

Win31StdChk:

  cmp     cx,2
  jne     Win31EnhChk
  mov     wWindowsType, WIN_STANDARD_MODE
  jmp     WinDetectComplete

Win31EnhChk:

  cmp     cx,3
  jne     Win31UnknownMode
  mov     wWindowsType, WIN_ENHANCED_MODE
  jmp     WinDetectComplete

Win31UnknownMode:

  mov     wWindowsType, WIN_UNKNOWN_MODE
  jmp     WinDetectComplete


; Check for 3.0 Enhanced mode

Win30EnhModeCheck:
  mov     ax,1600h                ; WIN386CHECK
  int     2Fh
  test    al,7Fh
  jz      Win286Check

; Windows 3.0 Enhanced Mode detected

  mov     wWindowsMajor,3         ; Set the version number
  mov     wWindowsMinor,0
                                  ; Set the mode
  mov     wWindowsType, WIN_ENHANCED_MODE
  jmp     WinDetectComplete


; Check for Windows/286

Win286Check:
  mov     ax,1700h                ; WIN286CHECK
  int     2Fh
  cmp     al,2h                   ; If /286 installed, ver = AL.AH
  jnz     WinOldApCheck           ; /286 is always 2.x

; Windows/286 detected

  xor     bh,bh
  mov     bl,al
  mov     wWindowsMajor,bx
  mov     bl,ah
  mov     wWindowsMinor,bx
  mov     wWindowsType, WIN_286
  jmp     WinDetectComplete


; Check for Windows 3.0 WINOLDAP

WinOldApCheck:
  mov     ax,4680h                ; IS_WINOLDAP_ACTIVE
  int     2Fh
  or      ax,ax                   ; running under 3.0 derivative ?
  jz      DosShellCheck

; Windows is not running on this computer

  jmp     NotRunningUnderWin


; Check for DOS 5.0 DOSSHELL Task Switcher

DosShellCheck:
  mov     ax,4b02h                ; detect switcher
  push    bx
  push    es
  push    di
  xor     bx,bx
  mov     di,bx
  mov     es,bx
  int     2Fh
  pop     di
  pop     es
  pop     bx
  or      ax,ax
  jnz     RunningUnderWinStdReal30

; Running under DOS 5.0 task switcher

  mov     wWindowsMajor,0         ; Windows is not running
  mov     wWindowsMinor,0
  mov     wWindowsType, NO_WINDOWS
  mov     fDosShell, TRUE         ; Set the flag for the DOSSHELL
  jmp     WinDetectComplete


RunningUnderWinStdReal30:

  mov     ax,1605h                ; PMODE_START
  int     2Fh
  cmp     cx,-1
  jnz     Running30RealOr386

; Windows 3.0 Standard Mode detected

  mov     ax,1606h                ; PMODE_STOP
  int     2Fh                     ; in case someone is accounting.

  mov     wWindowsMajor,3         ; Set the version number
  mov     wWindowsMinor,0
                                  ; Set the Windows mode
  mov     wWindowsType, WIN_STANDARD_MODE
  jmp     WinDetectComplete

Running30RealOr386:

  mov     ax,1606h                ; PMODE_STOP
  int     2Fh                     ; in case someone is accounting.

  cmp     al,1                    ; WIN386CHECK again
  jnz     RunningUnderRealMode
  cmp     al,0FFh
  jz      RunningUnderWin386

RunningUnderRealMode:

  mov     wWindowsMajor,3         ; Set the version number
  mov     wWindowsMinor,0
                                  ; Set the Windows mode
  mov     wWindowsType, WIN_REAL_MODE
  jmp     WinDetectComplete


RunningUnderWin386:

  mov     wWindowsMajor,2
  mov     wWindowsMinor,0FFh
  mov     wWindowsType, WIN_386
  jmp     WinDetectComplete

NotRunningUnderWin:

  mov     wWindowsMajor,0         ; Windows is not running
  mov     wWindowsMinor,0
  mov     wWindowsType, NO_WINDOWS

WinDetectComplete:

;************************************************************************
;* The previous code was taken from MSD 2.01's OSINFO.C, WinVerDetect() *
;************************************************************************


; Return 1 if wWindowsType != NO_WINDOWS

  mov     ax,wWindowsType       ; AX == Windows type
  or      ax,ax                 ; Is it zero
  jz      ReturnToCaller        ; True: Return

  mov     ax,1                  ; If Windows is active, return 1

ReturnToCaller:

  mov     sp,bp
  pop     bp
  ret

_IsWindowsRunning endp

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\main.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;m
	PAGE	,132			;
	TITLE	MODE COMMAND - MAIN PROCEDURE AND COMMAND PARSING
.XLIST
   INCLUDE STRUC.INC
.LIST
;.SALL


;  P R O L O G  ͻ
;											  

;  AC001 - P3976: Need to have all pieces of messages in MODE.SKL so have to
;		  implement the SYSGETMSG method of getting addressability to
;		  the pieces.  This means that the code does a SYSGETMSG call
;		  which returns a pointer (DS:SI) to the message piece.  The
;		  address is then put in the sublist block for the message
;		  being issued.

;  AN002 - P4011: Need to close all open handles before terminating and staying
;		  resident so don't eat into the total available handles for the
;		  system.
;											  
;  P R O L O G  ͼ

INCLUDE  SYSMSG.INC

MSG_UTILNAME <MODE>


;  E Q U A T E S  ͻ
;											  

false	EQU	00H
STDIN	    EQU   0		       ;AN002;handle for standard input device
STDPRN	    EQU   4		       ;AN002;handle for standard printer device
TERMINATE EQU	4CH			;INT 21 "TERMINATE RETURNING CODE" FUNCTION
terminate_and_stay_resident    EQU   31H   ;INT 21 "terminate and remain resident"
truu	 EQU   0FFH

;											  
;  E Q U A T E S  ͼ


;  S T R U C T U R E S  ͻ
;											  


;											  
;  S T R U C T U R E S  ͼ


	PAGE
PRINTF_CODE SEGMENT PUBLIC
	ASSUME	CS:PRINTF_CODE,DS:PRINTF_CODE,SS:PRINTF_CODE


;  P U B L I C S  ͻ
;											  

PUBLIC	 main
PUBLIC	 SYSDISPMSG
PUBLIC	 SYSGETMSG


;											  
;  P U B L I C S  ͼ


;  E X T R N S	ͻ
;											  

EXTRN	analyze_and_invoke:NEAR
EXTRN	get_machine_type:NEAR		      ;get model and sub-model bytes
EXTRN	initialize_sublists:NEAR	  ;see display.asm
EXTRN	move_destination:ABS		  ;location of res code after it has been moved
EXTRN	noerror:BYTE
EXTRN	parse_parameters:NEAR
EXTRN	PRINTF:NEAR
EXTRN	rescode_length:ABS	       ;length in paragraphs of the resident code
EXTRN	stay_resident:BYTE	       ;boolean indicating just loaded resident code see 'rescode'

;											  
;  E X T R N S	ͼ


;  D A T A	ͻ
;											  


	DB	"The MODE command "
	DB	"--------------------------------------------------------------"

;											  
;  D A T A	ͼ

;	P R O C E D U R E S  ͻ
;											  

close_handles  PROC  NEAR		  ;AN002;close all standard device handles
					  ;AN002;
MOV   AH,3EH				  ;AN002;
					  ;AN002;
.FOR BX = STDIN TO STDPRN		  ;AN002;
   INT	 21H				  ;AN002;
.NEXT BX				  ;AN002;
					  ;AN002;
RET					  ;AN002;
					  ;AN002;
close_handles  ENDP			  ;AN002;

;											  
;	P R O C E D U R E S  ͼ


;
;-------------------------------------------------------------------------------

MSG_SERVICES <MSGDATA>		    ;define message service data area

MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg>	;AC001;
MSG_SERVICES <mode.cla,mode.clb,mode.cl1,mode.cl2>    ;class B is for messages > 30
;;RPS  MSG_SERVICES <mode.cl1,mode.cl2>


main  PROC  NEAR

CALL  SYSLOADMSG		    ;load the message text
.IF NC THEN			    ;IF messages loaded successfully THEN
   CALL  get_machine_type
   CALL  initialize_sublists
   CALL  parse_parameters
   .IF <noerror EQ truu> THEN	       ;no problems parsing so continue
      CALL  analyze_and_invoke		  ;semantically analyze the parms and invoke appropriate routine
   .ENDIF

   MOV	AH,TERMINATE		       ;assume won't stay resident
   .IF <noerror EQ false> THEN
      MOV  AL,1 		       ;had a problem somewhere
   .ELSE
      .IF   <stay_resident EQ truu> THEN
	 CALL  close_handles		  ;close all standard devices;AN002;
	 MOV  DX,move_destination
	 MOV  CL,4			  ;4 right shifts = divide by 16
	 SAR  DX,CL			  ;DX=offset of start of resident code in paragraphs
					  ;SET END OF RESIDENT CODE FOR "terminate and remain resident"
					  ;TO first usable
	 ADD   DX,rescode_length	  ;BYTE OF PROGRAM segment PREFIX
	 MOV  AH,terminate_and_stay_resident
      .ENDIF
      MOV  AL,0 		       ;all went well
   .ENDIF
.ELSE				       ;ABORT

   CALL  SYSDISPMSG			  ;display some "I'm crashing" message

.ENDIF


INT	21H			 ;TERMINATE RETURNING ERRORLEVEL INDICATING success
RET

include msgdcl.inc

main  ENDP

PRINTF_CODE ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modecpms.inc ===
;MODECPMS.INC - INCLUDED IN MODECP.SAL 

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

 IF1
 %OUT INCLUDE MODECPMS.INC ;DESCRIPTIONS OF MESSAGES
 ENDIF

;$SALUT CP(0,2,9,32)	       ;(set preprocessor columns for indenting)

 EXTRN	CPMSG1:WORD	   ;"Failure to access Codepage Font File",BEEP,CR,LF,EOM

 EXTRN	CPMSG2:WORD	   ;"Failure to OPEN device: %S",CR,LF,EOM
 EXTRN	CPMSGLST2DEV:WORD      ;FILLED IN WITH PTR TO DEVICE NAME

 EXTRN	CPMSG3:WORD	   ;"Missing from font file is either device or codepage",BEEP,CR,LF,EOM

 EXTRN	CPMSG4:WORD	   ;"Font file contents invalid",CR,LF,EOM

 EXTRN	CPMSG5:WORD	   ;"Previously prepared codepage deleted",BEEP,CR,LF,EOM

 EXTRN	CPMSG6:WORD	   ;"Active codepage for %S is %D",CR,LF,EOM
 EXTRN	CPMSGLST6DEV:WORD      ;FILLED IN BY "QUERY" ROUTINE WITH PTR TO DEVICE NAME
 EXTRN	CPMSGLST6CP:WORD       ;FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID

 EXTRN	CPMSG7:WORD	   ;"Device %S not prepared",CR,LF,EOM
 EXTRN	CPMSGLST7DEV:WORD      ;FILLED IN BY "QUERY" ROUTINE WITH PTR TO DEVICE NAME

 EXTRN	CPMSG8:WORD	   ;"%s codepages:",CR,LF,EOM
;AC001; EXTRN  CPMSGLST8HD:WORD       ;OFFSET TO "HARDWARE" OR "PREPARED"
 EXTRN	CPMSG8_HW:WORD	       ;message number for "hardware ",EOM
 EXTRN	CPMSG8_PR:WORD	       ;message number for "prepared ",EOM

 EXTRN	CPMSG9:WORD	   ;"  Codepage %d",CR,LF,EOM
 EXTRN	CPMSGLST9CP:WORD       ;FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID

 EXTRN	CPMSG10:WORD	   ;"MODE %S Codepage function completed",CR,LF,EOM
;AC001; EXTRN  CPMSGLST10FUN:WORD     ;FILLED IN TO POINT TO:
 EXTRN	CPMSGxx_QUERY:WORD     ;message number for "Query",EOM
 EXTRN	CPMSGxx_PREP:WORD      ;message number for "Prepare",EOM
 EXTRN	CPMSGxx_REFRESH:WORD   ;message number for "Refresh",EOM
 EXTRN	CPMSGxx_SELECT:WORD    ;message number for "Select",EOM

 EXTRN	CPMSG12:WORD	   ;"Current Codepage settings:",CR,LF,EOM

 EXTRN	CPMSG13:WORD	   ;"   %D - %S Codepage",CR,LF,EOM
 EXTRN	CPMSGLST13CP:WORD      ;FILLED IN WITH CODEPAGE ID
;AC001; EXTRN  CPMSGLST13TYP:WORD     ;FILLED IN TO POINT TO:
 EXTRN	CPMSG13_ACT:WORD       ;message number for "Active"
 EXTRN	CPMSG13_SYS:WORD       ;message number for "System"

 EXTRN	CPMSG14:WORD	   ;"  Codepage unprepared",CR,LF,EOM

 EXTRN	CPMSG15:WORD	   ;"Device not supported for Codepage",BEEP,CR,LF,EOM

 EXTRN	CPMSG16:WORD	   ;"No codepage has been selected",BEEP,CR,LF,EOM

 EXTRN	CPMSG17:WORD	   ;"Device error during %S",BEEP,CR,LF,EOM
 EXTRN	CPMSG17_WRIT:WORD      ;message number for "write of font file to device",EOM

 EXTRN	CPMSG18:WORD	   ;"Specified Codepage not prepared",BEEP,CR,LF,EOM

 EXTRN	CPMSG19:WORD	   ;"Current keyboard does not support this Codepage",BEEP,CR,LF,EOM

 EXTRN	CPMSG20:WORD	   ;"Error during read of font file",BEEP,CR,LF,EOM

 EXTRN	CPMSG21:WORD	   ;CR,LF,"Unable to perform REFRESH",BEEP,EOM

 EXTRN  msgOutOfMemory:WORD

;THE FOLLOWING DATA AREAS DEFINING MESSAGES CAN BE FOUND IN "MODEMES.ASM"

;CPMSG1 	DB    "Failure to access Codepage Font File",BEEP,CR,LF,EOM
;CPMSG1     DW	  CPMSG1

;CPMSG2 	DB    "Failure to access device: %S",BEEP,CR,LF,EOM
;CPMSG2     DW	  CPMSG2
;CPMSGLST2DEV	DW    ? 	;FILLED IN WITH PTR TO DEVICE NAME

;CPMSG3 	DB	;"Missing from font file is either device or codepage",BEEP,CR,LF,EOM
;CPMSG3     DW	  CPMSG3

;CPMSG4 	DB    "Font file contents invalid",BEEP,CR,LF,EOM
;CPMSG4     DW	  CPMSG4

;CPMSG5 	DB    "Previous prepared codepage deleted",BEEP,CR,LF,EOM
;CPMSG5     DW	  CPMSG5

;CPMSG6 	DB    "Active codepage for device %S is %D",CR,LF,EOM
;CPMSG6     DW	  CPMSG6
;CPMSGLST6DEV	DW    ? 	;FILLED IN BY "QUERY" ROUTINE WITH PTR TO DEVICE NAME
;CPMSGLST6CP	DW    ? 	;FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID

;CPMSG7 	DB    "Device %S not prepared",CR,LF,EOM
;CPMSG7     DW	  CPMSG7
;CPMSGLST7DEV	DW    ? 	;FILLED IN BY "QUERY" ROUTINE WITH PTR TO DEVICE NAME

;CPMSG8 	DB    "%S codepages:",CR,LF,EOM
;CPMSG8     DW	  CPMSG8
;CPMSGLST8HD	DW    ? 	;OFFSET TO "HARDWARE" OR "PREPARED"
;CPMSG8_HW	DB    "hardware",EOM
;CPMSG8_PR	DB    "prepared",EOM

;CPMSG9 	DB    "  Codepage %d",CR,LF,EOM
;CPMSG9     DW	  CPMSG9
;CPMSGLST9CP	DW    ? 	;FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID

;CPMSG10	 DB    "MODE %S Codepage function completed",CR,LF,EOM
;CPMSG10     DW    CPMSG10
;CPMSGLST10FUN	 DW    ?	 ;FILLED IN TO POINT TO:
;CPMSG10_QUERY	 DB    "Querry",EOM
;CPMSG10_DES	 DB    "Prepare",EOM
;CPMSG10_SELECT  DB    "Activate",EOM
;CPMSG10_REFRESH DB    "Refresh",EOM
;CPMSG10_GLOBAL  DB    "Global",EOM

;CPMSG11	 DB    "Error %S Global Codepage",CR,LF,EOM
;CPMSG11     DW    CPMSG11
;CPMSGLST11FUN	 DW    ?	;FILLED IN TO POINT TO:
;CPMSG11_SET	 DB    "setting",EOM
;CPMSG11_GET	 DB    "getting",EOM

;CPMSG12	 DB    "Current Codepage settings:",CR,LF,EOM
;CPMSG12     DW    CPMSG12

;CPMSG13	 DB    "   %D - %S Codepage",CR,LF,EOM
;CPMSG13     DW    CPMSG13
;CPMSGLST13CP	 DW    ?	;FILLED IN WITH CODEPAGE ID
;CPMSGLST13TYP	 DW    ?	;FILLED IN TO POINT TO:
;CPMSG13_ACT	 DB    "Active",EOM
;CPMSG13_SYS	 DB    "System",EOM

;CPMSG14	 DB    "  Codepage unprepared",CR,LF,EOM
;CPMSG14     DW    CPMSG14

;CPMSG15	 DB    "Device not supported for Codepage",BEEP,CR,LF,EOM
;CPMSG15     DW    CPMSG15

;CPMSG16	 DB    "No codepage has been selected",BEEP,CR,LF,EOM
;CPMSG16     DW    CPMSG16

;CPMSG17	 DB	"Device error during %S",BEEP,CR,LF,EOM
;CPMSG17     DW     CPMSG17
;CPMSGLST17FUN	 DW	?	;FILLED IN TO POINT TO:
;CPMSG17_QUERY	 DB	"Query",EOM
;CPMSG17_PREP	 DB	"Prepare",EOM
;CPMSG17_REFRESH DB	"Refresh",EOM
;CPMSG17_ACT	 DB	"Activate",EOM

;CPMSG17_WRIT	 DB	"write of font file to device",EOM

;CPMSG18	 DB	"Specified Codepage not prepared",BEEP,CR,LF,EOM
;CPMSG18     DW     CPMSG18

;CPMSG19	 DB	"Current keyboard does not support this Codepage",BEEP,CR,LF,EOM
;CPMSG19     DW     CPMSG19

;CPMSG20	 DB	"Error during read of font file",BEEP,CR,LF,EOM
;CPMSG20     DW     CPMSG20

;CPMSG21	 DB	"Unable to perform REFRESH operation",BEEP,CR,LF,EOM
;CPMSG21     DW     CPMSG21
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modeecho.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

PAGE ,132 ;
TITLE MODEECHO - REDIRECT PRINTER OUTPUT FROM PARALLEL TO SERIAL

.XLIST
INCLUDE STRUC.INC
.LIST

INCLUDE common.stc	;definition of parm_list_entry struc

DISPLAY 	MACRO	MSG
	MOV	DX,OFFSET MSG
	CALL	PRINTF
ENDM

SET	MACRO	REG,VALUE		;SET REG TO VALUE. DON'T SPECIFY AX FOR REG
	PUSH	AX
	MOV	AX,VALUE
	MOV	REG,AX
	POP	AX
ENDM


;*****************************************************************
VECT	SEGMENT AT 0
		ORG	50H
VECT14H 	LABEL	DWORD	;RS232 CALL, WILL POINT TO MODETO AFTER
				; RESIDENT CODE IS LOADED.
		ORG	400H
RS232_BASE	DW	?	;ADDR OF RS232 ADAPTER FOR COM1
		DW	?	;ADDR OF RS232 ADAPTER FOR COM2
		DW	?	;ADDR OF RS232 ADAPTER FOR COM3
		DW	?	;ADDR OF RS232 ADAPTER FOR COM4
;
		ORG	408H
PRINTR		DW	?	;LPT1
		DW	?	;LPT2
		DW	?	;LPT3
;
		ORG	530H
RESSEG		DD	?	;VECTOR OF MODETO, IF RESIDENT,OR 0
VECT	ENDS
;*****************************************************************
ascii_to_int	EQU   0FH     ;ANDed with an ascii 0-9 value yeilds binary 0-9
CR		EQU	13	;CARRIAGE RETURN
LF		EQU	10	;LINE FEED
parm_list	EQU	[BP]	;AN000; 					 ;AN000;
TO_SCREEN	EQU	9	;REQUEST OUTPUT TO SCREEN

PUBLIC	       LPTNO	      ;used by modeprin and modepars
PUBLIC		PRINTR
PUBLIC	       display_printer_reroute_status

PAGE
;***************************************************************
PRINTF_CODE	SEGMENT PUBLIC
	ASSUME CS:PRINTF_CODE,DS:PRINTF_CODE,ES:NOTHING

;  D A T A	ͻ
;											  

two	       DB    2	      ;used to change byte displacement to word disp. See 'modeecho'
LPTNO	       DB    0	      ;holder of ASCII form of the LPT number (1 thru 3)

;											  
;  D A T A	ͼ

EXTRN PARM1:BYTE,PARM2:BYTE,PARM3:BYTE,MODE:BYTE
;PARM1	DB	10 DUP(0)
;PARM2	DB	0
;PARM3	DB	0
;MODE	DB	0
;FLAG	DB	0
ENDPARM EQU	MODE
EXTRN CRLF:BYTE 		    ;AN000;carriage return linefeed
EXTRN	 parm_lst:BYTE		    ;AN000;
EXTRN	illegal_device_ptr:WORD     ;AN000;pointer to bad com device name string
EXTRN MODELOAD:NEAR
EXTRN PRINTF:NEAR		;FORMATTED "C" LIKE SCREEN OUTPUT ROUTINE
EXTRN REDIRMSG:WORD	     ;CR,LF,"LPT"
EXTRN REDPT:BYTE		;" "
;				": rerouted to COM"
EXTRN REDCOM:BYTE		;" "
;				":",CR,LF,"$"
;
EXTRN NOTREMSG:WORD	     ;CR,LF,"LPT"
EXTRN NOTREDPT:BYTE		 ;" "
;				": not redirected.",CR,LF,"$"
;EXTRN printer_reroute_mask:BYTE    ;mask for testing ptsflag1 to see if a printer is rerouted
EXTRN ptsflag1:BYTE		    ;see rescode.sal
EXTRN  ERR1:WORD	    ;"ILLEGAL DEVICE NAME"
EXTRN resflag2:ABS	    ;see rescode
EXTRN FIXUP:ABS 		;IN MODEPTS, OFFSET USED BY COND. JMP
EXTRN OFFPTS:ABS		;WHERE MODEPTS IS RELATIVE TO BEGINNING
				; OF MODETO
EXTRN NEW_PTSFLAG:ABS		;WHERE PTSFLAG1 IS IN THE RESIDENT CODE
				; RELATIVE TO BEGINING OF MODETO
;
;***************************************************************
VERIFY	PROC NEAR
	PUBLIC	VERIFY
;
	SUB	AX,AX		;CLEAR A REG
	MOV	ES,AX		;SET ES TO LOW MEMORY
;DETERMINE WHAT PRINTER IS INVOLVED (LOOK AT n OF LPTn:)
	MOV	AL,BYTE PTR DS:LPTNO
	MOV	REDPT,AL		;PUT n OF LPTn IN REDIRECT MESSAGE
	MOV	NOTREDPT,AL	 ;AND INTO NOT REDIRECTED MSG
;	IF PRINTER DEVICE IS LPT1
	CMP	AL,"1"
	JNE	ELSEIF01A
;
	  MOV	AH,01H	 ;SET FLAG FOR LPT1
	  MOV	SI,1	;SAVE LPT NUMBER AS OFFSET TO FLAG BYTE ARRAY
;	ELSEIF PRINTER DEVICE IS LPT2
	JMP SHORT ENDIF01
ELSEIF01A:
	CMP	AL,"2"
	JNE	ELSEIF01B
;
	  MOV	AH,02H	 ;SET FLAG FOR LPT2
	  MOV	SI,2	;SAVE LPT NUMBER AS OFFSET TO FLAG BYTE ARRAY
;	ELSEIF PRINTER DEVICE IS LPT3
	JMP SHORT ENDIF01
ELSEIF01B:
;	CMP	AL,"3"
;	JNE	ELSE01
;
	  MOV	AH,04H	 ;SET FLAG FOR LPT3
	  MOV	SI,03	;SAVE LPT NUMBER AS OFFSET TO FLAG BYTE ARRAY
;	ELSE ,SINCE NONE OF THE ABOVE, MUST BE INVALID
;	JMP	SHORT ENDIF01
;ELSE01:
;	  DISPLAY ERR1		 ;FUSS ABOUT INVALID n OF LPTn
;	  MOV	AH,0		;SET FLAG TO INVALID
;	ENDIF ,END OF CHECK FOR DEVICE NO. IN LPTn
ENDIF01:
;AT EXIT: AH=MASK FOR NEW_PTSFLAG REPRESENTING WHICH LPTn, (OR 0 IF n INVALID)
;	AH HAS 0000 0XXX , WHERE BIT ON REPRESENTS:
;		|| --LPT1
;		| ---LPT2
;		----LPT3
;	SI=SET TO HEX 1,2, OR 3 TO BE USED AS OFFSET BEYOND NEW_PTSFLAG
;	TO ADDRESS THE BYTES PTSFLAG2, PTSFLAG3, AND PTSFLAG4
;	(SEE MODECODE FOR BYTE DEFINITIONS)
	RET
VERIFY	ENDP
;***************************************************************


MODEECHO PROC NEAR
	PUBLIC MODEECHO


;INPUT:

;	SI=printer number value (one based)
;	AH=printer number mask: lpt1=1, lpt2=2, lpt3=4
;	AL=com number character
;	all values are known to be valid, but the existence of the com port has
;	  not been checked.


;REGISTER
;  USAGE :  DL - hold the binary COM number
;	    BX - general use




MOV   REDCOM,AL 	;PUT m OF COMm TO REDIRECT MESSAGE
PUSH  ES		;SAVE SEG REG
SET   ES,0

MOV   BH,AH			    ;save the lpt number
AND   AL,ascii_to_int		    ;convert to 1 based integer
MOV   DL,AL			    ;FLAG FOR COM1, see 'ptsflag2' in 'rescode'
;see if the COM# ACTUALLY EXISTS
DEC   AL			    ;AL= 0 based com number
MUL   TWO			    ;AL=disp from 40:0 of com port address word
MOV   AH,BH			    ;restore the lpt number
XOR   BX,BX			    ;prepare for byte move
MOV   BL,AL			    ;BX=disp from 40:0 of com port address word
.IF <ES:RS232_BASE[BX] NE 0> THEN   ;IF the com adapter does exist THEN

   ;AT THIS POINT WE KNOW THAT LPTn AND COMm ARE BOTH LEGAL

   ;THE FOLLOWING IS WHERE THE APPROPRIATE ADDRESS WORD FOR THE PRINTER
   ;INVOLVED IS SET TO 0001H TO INDICATE TO BASIC THAT IT CAN OPEN THE
   ;DEVICE BECAUSE IT HAS BEEN REDIRECTED.  SEE TECH REF PAGE A-2
   ;RS232 AND PRINTER BASE.

	       SAL SI,1 	   ;2*SI TO GET TO THE APPROPRIATE WORD
   ;	   : : IF THE PRINTER ACTUALLY EXISTS
	       CMP ES:PRINTR-2+[SI],0000H  ;IF THE WORD IS NONZERO THE
	       JNE ENDIF10	   ;DEVICE EXISTS SO DON'T PUT A 1 THERE.
		 MOV	   ES:PRINTR-2+[SI],0001H  ;PUT 0001H IN PRINTER WORD n
   ;	   : : ENDIF PRINTER EXISTS
   ENDIF10:
	       SAR SI,1 	   ;RESTORE SI TO n OF LPTn
   ;
	       CALL	   MODELOAD	   ;WITHIN 'MODECODE' MODULE
   ;
   ;AH HAS A MASK SET BY THE 'VERIFY' PROC TO CORRESPOND TO THE LPTn
	       PUSH	   ES	   ;I'M ABOUT TO USE ES, SO I'LL SAVE IT
	       PUSH	   DI
	       LES	   DI,ES:RESSEG    ;FETCH POINTER TO MODETO IN RESIDENT CODE
	       MOV	   BX,NEW_PTSFLAG  ; FROM MODETO INTO BX
	       ADD	   BX,DI   ;ES:BX IS ADDRESS OF PTSFLAG1 IN RESIDENT
				   ; CODE (PROC MODEPTS)
	       OR	   AH,BYTE PTR ES:[BX]	   ;TURN ON THIS PRINTER'S BIT
	       MOV	   BYTE PTR ES:[BX],AH	   ;RECORD WHICH LPT IS TO BE
						   ; REDIRECTED
   ;				   SI=LPTn, DL=COMm
	       DEC	   DL	   ;NOW DL=0 FOR COM1, DL=1 FOR COM2
   ;				   SINCE SI=1, 2, OR 3, THIS PUTS A 0 OR 1 INTO
   ;				    PTSFLAG2, PTSFLAG3, OR PTSFLAG4
	       MOV	   BYTE PTR ES:[BX][SI],DL ;RECORD FOR THIS LPTn
   ;				    WHICH COMm THE LPTn IS REDIRECTED TO
	       POP	   DI
	       POP	   ES	   ;RESTORE SEG REG USED FOR CHECKING/SETTING ADDRESS
			   ; WORDS AND NEW_PTSFLAG
	       CALL	   ECHO     ;CHANGE JMP IN MODEPTS COPY IN LOW MEMORY
   ;				    SO PROPER LPTn GETS REDIRECTED
	       DISPLAY	   CRLF 					;AN000;
	       DISPLAY	   REDIRMSG

.ELSE				    ;valid com name, adapter not there
   MOV	 DI,0			    ;COM device name is always the first parm, the value of "LPTX[:]=value"    ;AN000;
   MOV	 BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]
   MOV	 CX,parm_list[DI].value1    ;AN000;					     ;AN000;
   MOV	illegal_device_ptr,CX	    ;AN000;set up message with bad com device name string
   DISPLAY ERR1 		       ;"Illegal device name - COMX"
.ENDIF


	POP	ES			;RESTORE SEG REG
	RET
MODEECHO ENDP
;***************************************************************
MODEECNO PROC NEAR
	PUBLIC MODEECNO
;INPUT: PARM1 AREA HAS:
;	LPTN:
;	OF WHICH VERIFICATION HAS BEEN MADE OF ONLY:
;	L???:
	PUSH	ES		 ;SAVE SEG REG
	CALL	VERIFY		 ;VERIFY THE n OF LPTn
;		SET AH ACCORDINGLY
;		ON EXIT FROM VERIFY, ES=0
;
;	IF n OF LPTn IS OK
	CMP	AH,0
	JE	ENDIF06
;	: IF IT IS POSSIBLE THAT REDIRECTION IS IN EFFECT
	  CMP	WORD PTR ES:530H,0000H	;HAS THE POINTER BEEN SET?
	  JE	ENDIF05 	;SINCE THE POINTER HASN'T BEEN SET, THE
				; CODE HASN'T BEEN LOADED, THEREFORE
				; THE LPT CAN'T BE REDIRECTED, SO THERE
				; IS NO NEED TO UNREDIRECT IT
;		SINCE n OF LPTn IS OK,
;		AND SI HAS 1,2,OR 3 TO CORRESPOND TO n
;		AND AH HAS:
;		0000 0001 - LPT1
;		0000 0010 - LPT2
;		0000 0100 - LPT3
	    XOR 	AH,0FFH 	;NOW AL HAS
;				1111 1110 - LPT1
;				1111 1101 - LPT2
;				1111 1011 - LPT3
	    PUSH	ES	;SAVE ES=0, SET BY VERIFY
	    PUSH	DI		;WILL BE USED AS OFFSET IN SEGMENT 0
				;ES:=O
	    LES 	DI,ES:RESSEG	;FETCH POINTER TO MODETO IN RESIDENT CODE
	    PUSH	BX	;TO AVOID 'TYPE MISMATCH' I PUT OFFSET
	    MOV 	BX,NEW_PTSFLAG	;FROM MODETO INTO BX
	    AND 	AH,BYTE PTR ES:[DI]+[BX] ;CLEAR THIS PRINTER'S BIT
	    MOV 	BYTE PTR ES:[DI]+[BX],AH ;RESTORE Revised FLAG BYTE
	    POP 	BX
	    POP 	DI
	    POP 	ES		;RESTORE ES=0
;
;LPTn IS BEING UNREDIRECTED.  IF THE PRINTER EXISTS, THE ADDRESS WORD FOR
;THAT DEVICE WILL NOT CONTAIN 0001H.  IF IT DOES CONTAIN 0001H, IT MUST BE SET
;TO 0000H SO BASIC WILL NOT ALLOW IT TO BE OPENED.  SEE PROCEDURE MODEECHO
;IN THIS MODULE, AND TECH REF PAGE A-2 (RS232 AND PRINTER BASE).
;
	    SAL 	SI,1	;SI=WORD n FOR LPTn
;	: : IF THE DUMMY PRINTER EXISTS
	    CMP 	ES:PRINTR-2+[SI],0001H	;DOES THE PRINTER EXIST?
	    JNE 	ENDIF07 ;  IF SO, DON'T MESS WITH THE ADDRESS WORD
	      MOV	ES:PRINTR-2+[SI],0000H	;IF NOT, ZERO THE ADDRESS WORD
;	: : ENDIF PRINTER EXISTS
ENDIF07:
	    SAR 	SI,1	;RESTORE SI TO n OF LPTn
;				 SO PROPER LPTn GETS REDIRECTED
;
;IF THE PRINTER EXISTS THE ADDRESS WORD IS NOW WHAT IT STARTED OUT AS
;AT POWER UP INITIALIZATION TIME. IF THE PRINTER DOESN'T EXIST, THE ADDRESS
;WORD IS NOW EQUAL TO 0000H.
;
	    CALL	ECHO		;GO INFORM THE RESIDENT CODE
;
ENDIF05:
	    DISPLAY	CRLF	       ;AN000;carriage return linefeed
	    DISPLAY	NOTREMSG
;	: ENDIF IS REDIRECTION IN EFFECT
;	ENDIF IS n OF LPTn OK?
ENDIF06:
	POP	ES		;RESTORE SEG REG
;
;A RETURN CODE IS PASSED BACK TO THE CALLER, MODEPRIN.
;AH=0 MEANS INVALID LPTn
;AH not= 0 MEANS LPTn IS OK
;
	RET			;RETURN TO CALLER
MODEECNO ENDP
;***************************************************************
ECHO	PROC	NEAR
;'MODEPTS' STARTS WITH THREE INSTRUCTIONS:
;	F6 C2 01	TEST  DL,1
;	75 05		JNZ   CK
;	EA ---- ----	JMP   PRINTER_IO
;		CK: (REDIRECT TO COMm)
;'PTSFLAG' HAS A FLAG BYTE SHOWING WHICH LPTn GETS REDIRECTED.
;THIS CODE HERE IS TO MODIFY THE FIRST TWO INSTRUCTIONS AT 'MODEPTS'
;SO REDIRECTED LPTn GOES TO 'CK:' AND OTHER LPTn GOES TO PRINTER_IO.
;
	PUSH   DI
	;ES:=0
	LES	DI,ES:RESSEG	;FETCH POINTER TO MODETO IN RESIDENT CODE
	PUSH   BX		;TO AVOID 'TYPE MISMATCH' I PUT THE OFFSET
	PUSH	CX		;NEED A HOLDER FOR FIXUP
	MOV	BX,NEW_PTSFLAG	; FROM MODETO INTO BX
	MOV	AL,BYTE PTR ES:[DI]+[BX] ;FIND WHICH LPTn GET REDIRECTED
	MOV	BX,DI		;PUT OFFSET OF MODETO INTO BX
	POP	DI
	ADD	BX,OFFPTS	;ADD OFFSET OF MODEPTS FROM MODETO, NOW
				; ES:BX POINTS TO MODEPTS
	MOV	CX,FIXUP	;HOLD FIXUP IN WORD FORM SO LINKER CAN FILL IN
	CLI			;IF AN INTERRUPT OCCURS HERE THE JUMP WOULD
				; BE INCORRECT
	MOV	BYTE PTR ES:[BX]+4,CL		;SET JUMP TARGET (CK) TO +3BH
	POP	CX		;RETURN FIXUP'S WORD FORM HOLDER
	MOV	AH,0		;CLEAR HIGH BYTE
	SHL	AL,1		;COUNT WAS 0,1,2,3,...7
;				COUNT IS NOW 0,2,4,6...14
	MOV	SI,AX		;GET INDEX OF BR TABLE ENTRY
	JMP	CASE[SI]
;
CASE	EQU THIS WORD
	DW	P0
	DW	P1
	DW	P2
	DW	P3
	DW	P4
	DW	P5
	DW	P6
	DW	P7
;
P0:
;		SINCE NO PRINTER IS TO BE REDIRECTED
	MOV	WORD PTR ES:[BX]+3,00EBH	;MAKE JUMP INTO NO-OP
;		TO CAUSE 'FALL THRU' TO JMP PRINTER_IO INSTR
	JMP	SHORT ENDC
P1:
;	REDIRECT LPT1 ONLY
	MOV	WORD PTR ES:[BX]+2,7403H	;TEST 3 : JZ CK
	JMP	SHORT ENDC
;
P2:
;	REDIRECT LPT2 ONLY
	MOV	WORD PTR ES:[BX]+2,7501H	;TEST 1 : JNZ CK
	JMP	SHORT ENDC
;
P3:
;	REDIRECT LPT1 AND LPT2 ONLY
	MOV	WORD PTR ES:[BX]+2,7402H	; TEST 2 : JZ CK
	JMP	SHORT ENDC
;
P4:
;	REDIRECT LPT3 ONLY
	MOV	WORD PTR ES:[BX]+2,7502H	;TEST 2 :JNZ CK
	JMP	SHORT ENDC
;
P5:
;	REDIRECT LPT1 AND LPT3 ONLY
	MOV	WORD PTR ES:[BX]+2,7401H	;TEST 1 : JZ CK
	JMP	SHORT ENDC
;
P6:
;	REDIRECT LPT2 AND LPT3 ONLY
	MOV	WORD PTR ES:[BX]+2,7503H	;TEST 3 : JNZ CK
	JMP	SHORT ENDC
;
P7:
;	REDIRECT ALL THREE: LPT1, LPT2, AND LPT3
	MOV	WORD PTR ES:[BX]+2,0EB00H	;TEST 0 : JMP CK
ENDC:
	STI			;REENABLE INTERRUPTS
	POP	BX
	RET
ECHO	ENDP


;					   ;AN000;
;
; DISPLAY_PRINTER_REROUTE_STATUS
; ------------------------------
;
;  Setup message for the reroute status of the specified printer.
;
;  INPUT: BL - mask for ptsflag1 (1, 2 or 4)
;	   REDPT - contains ASCII form of n OF LPTn in redirmsg "LPTn rerouted to COMm"
;	   NOTREDPT - contains ASCII form of n of LPTn in message "LPTn not rerouted"
;
;
;
;  RETURN: REDCOM - filled with ASCII form of m OF COMm in MESSAGE "LPTn rerouted to COMn"none
;
;
;
;  MESSAGES:  REDIRMSG if the printer is rerouted
;	       NOTREMSG if the printer is not rerouted
;
;
;  REGISTER
;  USAGE:
;
;
;
;  ASSUMPTIONS: input is valid
;
;
;  SIDE EFFECT: ES - lost
;		 SI - lost
;															   ;AN000;
;					   ;AN000;

display_printer_reroute_status	PROC  NEAR

XOR  CX,CX								;AN665;
MOV  ES,CX			       ;set segment to zero		;AN665;

.IF <<ES:WORD PTR resseg> NE 0000H> AND      ;IF the resident code is loaded AND
MOV  ES,ES:WORD PTR resseg[2]					     ;AN665;
;;XOR	BX,BX
;;MOV	BL,printer_reroute_mask
TEST  BL,ES:PTSFLAG1	   ;see if the printer is rerouted
.IF NZ THEN				     ;the printer is rerouted
   SHR	 BL,1	  ;was 1, 2, or 4, now is 0, 1, or 2
;;;INC	 BL	  ;now is 1, 2, or 3
;;;ADD	 BL,resflag2		    ;ES:BX=>the com byte for the desired printer
   ADD	 BX,resflag2		    ;ES:BX=>the com byte for the desired printer
   .SELECT

      .WHEN <<BYTE PTR ES:[BX]> EQ 0>
	 MOV   redcom,"1"           ;printer rerouted to COM1

      .WHEN <<BYTE PTR ES:[BX]> EQ 1>
	 MOV   redcom,"2"           ;printer rerouted to COM2

      .WHEN <<BYTE PTR ES:[BX]> EQ 2>
	 MOV   redcom,"3"           ;printer rerouted to COM3

      .WHEN <<BYTE PTR ES:[BX]> EQ 3>
	 MOV   redcom,"4"           ;printer rerouted to COM4

   .ENDSELECT
   display  redirmsg	   ;"LPTn rerouted to COMm"
.ELSE
   display  notremsg	   ;"LPTn not rerouted"
.ENDIF




RET

display_printer_reroute_status	ENDP

PRINTF_CODE	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modecom.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  MKS  C00  General cleanup.  Making short jumps out of long
;                      jumps, ridding of nops.
;  06/14/90  MKS  C07  Bug#646.  1.5 stop bits is only valid when there are
;                      5 data bits.  This fix will change the message to be 2
;                      stop bits if 1.5 stop bits are specified, as long as 5
;                      data bits were not specified.  Also, if 1.5 stop bits is
;                      specified, the default for data bits will become 5.
;
;******************************************************************************
PAGE ,132 ;                                                                                                               ;AN000;
TITLE MODECOM.ASM - RS232 SUPPORT FOR THE MODE COMMAND                                                                     ;AN000;
                                                                                                                           ;AN000;
.XLIST                                                                                                                     ;AN000;
INCLUDE STRUC.INC                                                                                                          ;AN000;
.LIST                                                                                                                      ;AN000;

;  P R O L O G  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
;  AC000 - P2852: Loading resident code trashed CX which was used as a shift
;                 count.

;  AC001 - P3540: PS/2 only parms other than baud not being treated properly.

;                                                                                                                        ;AN000;
;  P R O L O G  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
DISPLAY MACRO   MESSAGE                                                                                                    ;AN000;
        MOV     DX,OFFSET MESSAGE                                                                                          ;AN000;
        CALL    PRINTF                                                                                                     ;AN000;
ENDM                                                                                                                       ;AN000;
                                                                                                                           ;AN000;
;------------------------------------------------------------------------                                                  ;AN000;
                                                                                                                           ;AN000;
ABORT   MACRO                                                                                                              ;AN000;
;       JMP     ENDIF01                                                                                                    ;AN000;
        JMP     SHORT ENDIF01                                           ;C00                                               ;AN000;
ENDM                                                                                                                       ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;------------------------------------------------------------------------                                                  ;AN000;
                                                                                                                           ;AN000;
INCLUDE  common.stc        ;contains the following structure                                                               ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;parm_list_entry   STRUC                   ;used by parse_parameters and invoke                                            ;AN000;
;                                                                                                                          ;AN000;
;parm_type            DB       bogus                                                                                       ;AN000;
;item_tag             DB       0FFH                                                                                        ;AN000;
;value1               DW       bogus       ;used only for filespecs and code page numbers                                  ;AN000;
;value2               DW       bogus       ;used only for filespecs and code page numbers                                  ;AN000;
;keyword_switch_ptr   DW       0                                                                                           ;AN000;
;                                                                                                                          ;AN000;
;parm_list_entry   ENDS                                                                                                    ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
; E Q U A T E S ͻ                                  ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;

INCLUDE modequat.inc             ;AN000;include definition of false, machine types

                                                                                                                           ;AN000;
AT_family   EQU 0FCH             ;model byte for 286 boxes                                                                 ;AN000;
DEV1        EQU "1"              ;CHAR IN "COM1:"                                                                          ;AN000;
DEV2        EQU "2"              ;CHAR IN "COM2:"                                                                          ;AN000;
DEV3        EQU "3"              ;CHAR IN "COM3:"                                                                          ;AN000;
DEV4        EQU "4"              ;CHAR IN "COM4:"                                                                          ;AN000;
OFFTO       EQU modeto           ;OFFSET OF MODETO IN RESIDENT CODE FROM SEGMENT                                           ;AN000;
                                 ; STORED AT 530H BY MODELOAD                                                              ;AN000;
not_specified        EQU   0                                                                                               ;AN000;
parm_list            EQU   [BP]                                                                                            ;AN000;
;Roughrider  EQU 05               ;sub model byte                                                                           ;AN000;
SPACE       EQU " "              ;BLANK CHARACTER                                                                          ;AN000;
;Trailboss   EQU 04               ;sub model byte for 'Trailboss'                                                           ;AN000;
true        EQU 0FFH                                                                                                       ;AN000;
;Wrangler    EQU 0F8H             ;primary model byte                                                                       ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  E Q U A T E S  ͼ                                ;AN000;

                                ; BEGINNING OF PROC MODETO)                                                                ;AN000;
ROM    SEGMENT AT 0                                                                                                        ;AN000;
    ORG    50H                                                                                                             ;AN000;
VECT14H    LABEL  DWORD         ;RS232 CALL, POINTS TO PROC MODETO WHEN                                                    ;AN000;
                                ; WHEN CODE IS RESIDENT                                                                    ;AN000;
    ORG    400H                                                                                                            ;AN000;
SERIAL_BASE     LABEL   WORD    ;SERIAL PORT ADDRESSES                                                                     ;AN000;
        ORG     530H                                                                                                       ;AN000;
RESSEG  LABEL   DWORD           ;VECTOR OF MODETO, WHEN RESIDENT                                                           ;AN000;
ROM        ENDS                                                                                                            ;AN000;
PAGE                                                                                                                       ;AN000;
PRINTF_CODE        SEGMENT  PUBLIC                                                                                         ;AN000;
           ASSUME CS:PRINTF_CODE,DS:PRINTF_CODE                                                                            ;AN000;
                                                                                                                           ;AN000;
;  E X T R N S  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
EXTRN  B_item_tag:ABS            ;see modepars                                                                             ;AN000;
EXTRN  baud_19200:BYTE                                                                                                     ;AN000;
EXTRN  busy_retry_active:ABS     ;see invoke.asm                                                                           ;AN000;
EXTRN  E_item_tag:ABS            ;see modepars                                                                             ;AN000;
EXTRN  eight_item_tag:ABS        ;see modepars                                                                             ;AN000;
EXTRN  ERR1:WORD                                                                                                           ;AN000;
EXTRN  even_item_tag:ABS         ;see modepars                                                                             ;AN000;
EXTRN  error_retry_active:ABS    ;see invoke.asm                                                                           ;AN000;
EXTRN  five_item_tag:ABS         ;see modepars                                                                             ;AN000;
EXTRN  fourtyeighthundred_item_tag:ABS     ;see modepars.asm                                                               ;AN000;
EXTRN  fourtyeighthundred_str:BYTE                                                                                         ;AN000;
EXTRN  illegal_device_ptr:WORD    ;see modesubs.inc                                                                        ;AN000;
EXTRN  INITMSG:BYTE,DEVICE:BYTE,PPARITY:BYTE,PDATA:BYTE,PSTOP:BYTE,PPARM:BYTE                                              ;AN000;
EXTRN  keyword:ABS                                                                                                         ;AN000;
EXTRN  machine_type:BYTE         ;see 'rescode'                                                                            ;AN000;
EXTRN  mark_item_tag:ABS         ;see modepars                                                                             ;AN000;
EXTRN  MODELOAD:NEAR                                                                                                       ;AN000;
EXTRN  MODETO:WORD                                                                                                         ;AN000;
EXTRN  new_com_initialize:BYTE               ;flag indicating that a PS/2 only parm was specified                          ;AC001;
EXTRN  nineteentwohundred_item_tag:ABS       ;see modepars.asm                                                             ;AN000;
EXTRN  nineteentwohundred_str:BYTE      ;see modepars.asm                                                                  ;AN000;
EXTRN  ninetysixhundred_item_tag:ABS                                                                                       ;AC001;
EXTRN  ninetysixhundred_str:BYTE                                                                                           ;AN000;
EXTRN  no_retry_active:ABS       ;see invoke.asm                                                                           ;AN000;
EXTRN  noerror:byte              ;boolean indicating success of previous actions                                           ;AN000;
EXTRN  none_item_tag:ABS         ;see modepars                                                                             ;AN000;
EXTRN  onefifty_str:BYTE                                                                                                   ;AN000;
EXTRN  oneten_item_tag:ABS       ;see modepars.asm                                                                         ;AN000;
EXTRN  oneten_str:BYTE                                                                                                     ;AN000;
EXTRN  onefifty_item_tag:ABS     ;see modepars.asm                                                                         ;AN000;
EXTRN  one_point_five_item_tag:ABS     ;see modepars.asm                                                                   ;AN000;
EXTRN  one_point_five_str:BYTE    ;see modesubs.inc                                                                        ;AN000;
EXTRN  p_item_tag:ABS            ;see modepars.asm                                                                         ;AN000;
EXTRN  parm_lst:BYTE             ;parm_list_entry  max_pos_parms DUP (<>)                                                  ;AN000;
EXTRN  parms_form:BYTE                                                                                                     ;AN000;
EXTRN  pstop_ptr:WORD           ;see modedefs.inc                                                                         ;AN000;
EXTRN  odd_item_tag:ABS          ;see modepars                                                                             ;AN000;
EXTRN  one_item_tag:ABS          ;see modepars                                                                             ;AN000;
EXTRN  PBAUD_ptr:WORD            ;see 'modemes'                                                                            ;AN000;
EXTRN  PRINTF:NEAR                                                                                                         ;AN000;
EXTRN  PARM1:BYTE,PARM2:BYTE,PARM3:BYTE,MODE:BYTE
EXTRN  R_item_tag:ABS                                                                                                      ;AN000;
EXTRN  RATEMSG:WORD       ;CR,LF,"Invalid baud rate specified",BEEP,CR,LF,"$"                                              ;AN000;
EXTRN  ready_retry_active:ABS    ;see invoke.asm                                                                           ;AN000;
EXTRN  res_com_retry_type:ABS    ;retry type flag, displacement from address pointed to by 50:30 when code is resident, see rescode
EXTRN  seven_item_tag:ABS         ;see modepars                                                                            ;AN000;
EXTRN  sixhundred_item_tag:ABS     ;see modepars.asm                                                                       ;AN000;
EXTRN  sixhundred_str:BYTE                                                                                                 ;AN000;
EXTRN  six_item_tag:ABS       ;see modepars                                                                                ;AN000;
EXTRN  space_item_tag:ABS     ;see modepars                                                                                ;AN000;
EXTRN  submodel_byte:BYTE     ;see 'rescode'                                                                               ;AN000;
EXTRN  threehundred_item_tag:ABS     ;see modepars.asm                                                                     ;AN000;
EXTRN  threehundred_str:BYTE                                                                                               ;AN000;
EXTRN  twelvehundred_item_tag:ABS     ;see modepars.asm                                                                    ;AN000;
EXTRN  twelvehundred_str:BYTE                                                                                              ;AN000;
EXTRN  twentyfourhundred_str:BYTE                                                                                          ;AN000;
EXTRN  twentyfourhundred_item_tag:ABS     ;see modepars.asm                                                                ;AN000;
EXTRN  two_item_tag:ABS         ;see modepars                                                                              ;AN000;
EXTRN  function_not_supported:BYTE            ;see modedefs.inc; M002; COM Init failure                                    ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  E X T R N S  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  P U B L I C S  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
PUBLIC  baud_index              ;holder of the index in the parm list of the baud rate requested                           ;AN000;
PUBLIC  data_bits_index         ;set by invoke                                                                             ;AN000;
PUBLIC  MODECOM                                                                                                            ;AN000;
PUBLIC  parity_index            ;set by invoke                                                                             ;AN000;
PUBLIC  SERIAL_BASE             ;Make available to RESCODE and MAIN                                                        ;AN000;
PUBLIC  retry_index             ;make available to analyze_and_invoke                                                      ;AN000;
PUBLIC  setcom                  ;get it listed in the link map                                                             ;AN000;
PUBLIC  setto                   ;get it listed in link map for debugging                                                   ;AN000;
PUBLIC  stop_bits_index         ;set by invoke                                                                             ;AN000;
public  databit_default         ;only used here.                           ;C07
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  P U B L I C S  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;  D A T A  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;THESE FOLLOWING BAUD RATES REPRESENT THE 1ST 2 CHAR                                                                       ;AN000;
baud_index  DW       TYPE parm_list_entry ;holder of the index into the parm list of the baud rate                         ;AN000;
data_bits_index DW   0     ;holder of the index into the parm list of the data bits                                        ;AN000;
parity_index    DW   0     ;holder of the index into the parm list of the parity                                           ;AN000;
stop_bits_index DW   0     ;holder of the index into the parm list of the stop bits                                        ;AN000;
retry_index     DW   0                                                                                                     ;AN000;
                                                                                                                           ;AN000;
databit_default DB   FALSE      ;Flag showing if default databits used     ;C07
;INITMSG    DB    CR,LF                                                                                                    ;AN000;
;           DB    "COM"                                                                                                    ;AN000;
;DEVICE     DB    " "                                                                                                      ;AN000;
;           DB    ": "             ;SEPARATOR BLANK                                                                        ;AN000;
;PBAUD      DB    4 DUP(" ")                                                                                               ;AN000;
;           DB    ","    ;SEPARATOR                                                                                        ;AN000;
;PPARITY    DB    "e"    ;DEFAULT IS EVEN PARITY                                                                           ;AN000;
;           DB    ","    ;SEPARATOR                                                                                        ;AN000;
;PDATA      DB    "7"    ;DEFAULT IS 7 DATA BITS PER BYTE                                                                  ;AN000;
;           DB    ","    ;SEPARATOR                                                                                        ;AN000;
;PSTOP      DB    "1"    ;DEFAULT FOR BAUD > 110, CHANGED TO 2 FOR 110                                                     ;AN000;
;           DB    ","    ;SEPARATOR                                                                                        ;AN000;
;PPARM      DB    " "                                                                                                      ;AN000;
;           DB    CR,LF,"$"    ;END OF 'INITMSG'                                                                           ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
;                                                                                                                        ;AN000;
;  D A T A  ͼ                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
SUBTTL SET UP FOR SERIAL RETRY                                                                                             ;AN000;
PAGE                                                                                                                       ;AN000;
;
;
;-------------------------------------------------------------------------------
;Ŀ
;                                                                             
; SETTO                                                                       
; -----                                                                       
;                                                                             
;  Set the resident retry flag to type of retry active for comx.              
;                                                                             
;  INPUT:  device - holds '1', '2', '3' or '4' (ascii) for x of lptx.         
;          retry_index - holds index value for the parsed retry parameter.    
;          resseg - holds offset of resident code in memory                   
;          res_com_retry_type - holds offset of com retry flag in resident    
;            code.                                                            
;                                                                             
;                                                                             
;  RETURN: pparm - set to 'P', 'B', 'R', 'E', or '-' for type of retry active.
;          flag in resident code set                                          
;                                                                             
;                                                                             
;  MESSAGES: none.                                                            
;                                                                             
;                                                                             
;  REGISTER                                                                   
;  USAGE:      AL - new setting for resident flag. (see RESCODE.SAL for       
;                   format)                                                   
;              CL - shift bit count                                           
;              ES - holds segment of resident code                            
;              BP - offset of parameter list                                  
;              DI - offset of retry index within parameter list               
;              DL - current resident flag setting                             
;                                                                             
;                                                                             
;  PSUEDO CODE:                                                               
;                                                                             
;      SAVE REGISTERS                                                         
;      SET UP SEGMENT REGISTER AND BIT MASKS                                  
;      IF <RETRY REQUESTED>                                                   
;         SET UP PARAMETER LIST STRUCTURE                                     
;         SET BIT MASK FOR TYPE OF RETRY AND SET pparm TO PROPER LETTER       
;         IF <RESIDENT CODE IS NOT LOADED>                                    
;            LOAD RESIDENT CODE                                               
;         ENDIF                                                               
;         GET CURRENT com_lpt_retry_type                                      
;         SET AND STORE NEW com_lpt_retry_type                                
;      ELSEIF <RESIDENT CODE ALREADY LOADED>                                  
;         GET CURRENT com_lpt_retry_type                                      
;         IF <POSITIONAL PARAMETER SPECIFIED>                                 
;            SET FLAG TO ZERO, SET pparm TO PROPER LETTER                     
;         ELSE                                                                
;            SET pparm TO PROPER LETTER FOR CURRENT SETTING                   
;         ENDIF                                                               
;      ELSE                                                                   
;         SET pparm TO '-'                                                    
;      ENDIF                                                                  
;      RESTORE REGISTERS                                                      
;      RETURN                                                                 
;                                                                             
;                                                                             
;                                                                             
;  SIDE EFFECT: Loads resident code if it is needed and has not been loaded.  
;                                                                             
;
;
SETTO    PROC    NEAR                                                                                                      ;AN663;
                                                                                                                           ;AN663;
      PUSH ES                   ;save registers                                                                            ;AN663;
      PUSH DI                                                                                                              ;AN663;
      PUSH AX                                                                                                              ;AN663;
      PUSH DX                                                                                                              ;AN663;
                                                                                                                           ;AN663;
      XOR  AX,AX                ;clear a reg                                                                               ;AN663;
      MOV  ES,AX                ;set to segment at 0                                                                       ;AN663;
      MOV  CL,device                                                                                                       ;AN663;
      AND  CL,07H                                                                                                          ;AN663;
      DEC  CL                                                                                                              ;AN663;
      SHL  CL,1                                                                                                            ;AN663;
      MOV  DH,11111100B         ;set bit mask to clear old flag setting                                                    ;AN663;
      ROL  DH,CL                                                                                                           ;AN663;
                                                                                                                           ;AN663;
      .IF <retry_index NE 0> THEN                       ;retry specified, set                                              ;AN663;
                                                        ;  byte in resident code                                           ;AN663;
         MOV  DI,retry_index                            ;  to proper setting.                                              ;AN663;
                                                        ;  if code is not loaded,                                          ;AN663;
         .SELECT                                        ;  loaded it.                                                      ;AN663;
         .WHEN <parm_list[DI].item_tag EQ P_item_tag>                                                                      ;AN663;
            MOV  AL,busy_retry_active                                                                                     ;AN663;
            MOV  pparm,'p'                                                                                                 ;AN663;
         .WHEN <parm_list[DI].item_tag EQ E_item_tag>                                                                      ;AN663;
            MOV  AL,error_retry_active                                                                                     ;AN663;
            MOV  pparm,'e'                                                                                                 ;AN663;
         .WHEN <parm_list[DI].item_tag EQ B_item_tag>                                                                      ;AN663;
            MOV  AL,busy_retry_active                                                                                      ;AN663;
            MOV  pparm,'b'                                                                                                 ;AN663;
         .WHEN <parm_list[DI].item_tag EQ R_item_tag>                                                                      ;AN663;
            MOV  AL,ready_retry_active                                                                                     ;AN663;
            MOV  pparm,'r'                                                                                                 ;AN663;
         .ENDSELECT                                                                                                        ;AN663;
                                                                                                                           ;AN663;
         .IF <<WORD PTR ES:resseg> EQ 0000H> THEN                                                                          ;AN663;
            PUSH  CX                                    ;save shift count
            CALL modeload                               ;load the resident code                                            ;AN663;
            POP   CX                                    ;restore shift count
         .ENDIF                                                                                                            ;AN663;
                                                                                                                           ;AN663;
         MOV  ES,ES:WORD PTR resseg[2]                                                                                     ;AN663;
         MOV  DL,BYTE PTR ES:res_com_retry_type                                                                            ;AN663;
                                                        ;get the old setting                                               ;AN663;
         ROL  AL,CL                                                                                                        ;AN663;
         AND  DL,DH                                                                                                        ;AN663;
         OR   DL,AL                                                                                                        ;AN663;
         MOV  BYTE PTR ES:res_com_retry_type,DL         ;store the new setting                                             ;AN663;
                                                                                                                           ;AN663;
      .ELSEIF <<WORD PTR ES:resseg> NE 0000H> THEN      ;if code is loaded but no                                          ;AN663;
                                                        ;  retry is specified then                                         ;AN663;
         MOV  ES,ES:WORD PTR resseg[2]                                                                                     ;AN663;
         MOV  DL,BYTE PTR ES:res_com_retry_type                                                                            ;AN663;
                                                                                                                           ;AN663;
         .IF <parms_form NE keyword>                    ;if 'NONE' was specified                                           ;AN663;
                                                        ;  with positional parameter                                       ;AN663;
            AND  DL,DH                                  ;  set bits to zero                                                ;AN663;
            MOV  BYTE PTR ES:res_com_retry_type,DL                                                                         ;AN663;
                                                                                                                           ;AN663;
         .ELSE                                          ;else update pparm with                                            ;AN663;
                                                        ;  current retry type                                              ;AN663;
            NOT  DH                                                                                                        ;AN663;
            AND  DL,DH                                                                                                     ;AN663;
            SHR  DL,CL                                                                                                     ;AN663;
                                                                                                                           ;AN663;
            .SELECT                                     ;set pparm to proper letter                                        ;AN663;
            .WHEN <DL EQ no_retry_active>                                                                                  ;AN663;
               MOV  pparm,'-'                                                                                              ;AN663;
            .WHEN <DL EQ error_retry_active>                                                                               ;AN663;
               MOV  pparm,'e'                                                                                              ;AN663;
            .WHEN <DL EQ busy_retry_active>                                                                                ;AN663;
               MOV  pparm,'b'                                                                                              ;AN663;
            .WHEN <DL EQ ready_retry_active>                                                                               ;AN663;
               MOV  pparm,'r'                                                                                              ;AN663;
            .ENDSELECT                                                                                                     ;AN663;
                                                                                                                           ;AN663;
         .ENDIF                                                                                                            ;AN663;
                                                                                                                           ;AN663;
      .ELSE                                             ;no retry, no code resident                                        ;AN663;
                                                                                                                           ;AN663;
         MOV  pparm,'-'                                                                                                    ;AN663;
                                                                                                                           ;AN663;
      .ENDIF                                                                                                               ;AN663;
                                                                                                                           ;AN663;
      POP  DX                                                                                                              ;AN663;
      POP  AX                   ;restore registers                                                                         ;AN663;
      POP  DI                                                                                                              ;AN663;
      POP  ES                                                                                                              ;AN663;
      RET                                                                                                                  ;AN663;
                                                                                                                           ;AN663;
SETTO ENDP                                                                                                                 ;AN663;



SUBTTL SET SERIAL PROTOCOL
PAGE

;------------------------------------------------------------------------------

;Ŀ
;                                                                             
; SETCOM                                                                      
; ------                                                                      
;                                                                             
;                                                                             
;                                                                             
;  INPUT:                                                                     
;                                                                             
;                                                                             
;                                                                             
;                                                                             
;                                                                             
;                                                                             
;  RETURN:                                                                    
;                                                                             
;                                                                             
;                                                                             
;  MESSAGES: none.                                                            
;                                                                             
;                                                                             
;  REGISTER                                                                   
;  USAGE:                                                                     
;                                                                             
;                                                                             
;  ASSUMPTIONS: All parms have been checked for validity as being possible and
;               supported on the machine.                                     
;                                                                             
;                                                                             
;                                                                             
;  SIDE EFFECT:                                                               
;                                                                             
;

SETCOM PROC    NEAR                                                                                                        ;AN000;
                                                                                                                           ;AN000;
                                                                                                                         ;AN000;
MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]                                           ;AN000;
MOV    DI,baud_index        ;DI=index into parm list of the baud rate entry                                             ;AN000;

.SELECT                    ;prepare AL for old init and CL for new init                                                 ;AC001;

   .WHEN <parm_list[DI].item_tag EQ oneten_item_tag>                                                                    ;AC001;
      MOV   AL,0                                                                                                        ;AN000;
      MOV   CL,0
      MOV   pbaud_ptr,OFFSET oneten_str                                                                                 ;AN000;
   .WHEN <parm_list[DI].item_tag EQ onefifty_item_tag> THEN                                                           ;AN000;
      MOV   AL,00100000B                                                                                                ;AN000;
      MOV   CL,1
      MOV   pbaud_ptr,OFFSET onefifty_str                                                                               ;AN000;
   .WHEN <parm_list[DI].item_tag EQ threehundred_item_tag> THEN                                                       ;AN000;
      MOV   AL,01000000B                                                                                                ;AN000;
      MOV   CL,2
      MOV   pbaud_ptr,OFFSET threehundred_str                                                                           ;AN000;
   .WHEN <parm_list[DI].item_tag EQ sixhundred_item_tag> THEN                                                         ;AN000;
      MOV   AL,01100000B                                                                                                ;AN000;
      MOV   CL,3
      MOV   pbaud_ptr,OFFSET sixhundred_str                                                                             ;AN000;
   .WHEN <parm_list[DI].item_tag EQ twelvehundred_item_tag> THEN                                                      ;AN000;
      MOV   AL,10000000B                                                                                                ;AN000;
      MOV   CL,4
      MOV   pbaud_ptr,OFFSET twelvehundred_str                                                                          ;AN000;
   .WHEN <parm_list[DI].item_tag EQ twentyfourhundred_item_tag> THEN                                                  ;AN000;
      MOV   AL,10100000B                                                                                                ;AN000;
      MOV   CL,5
      MOV   pbaud_ptr,OFFSET twentyfourhundred_str                                                                      ;AN000;
   .WHEN <parm_list[DI].item_tag EQ fourtyeighthundred_item_tag> THEN                                                 ;AN000;
      MOV   AL,11000000B                                                                                                ;AN000;
      MOV   CL,6
      MOV   pbaud_ptr,OFFSET fourtyeighthundred_str                                                                     ;AN000;
   .WHEN <parm_list[DI].item_tag EQ ninetysixhundred_item_tag> THEN                                                     ;AN000;
      MOV   AL,11100000B                                                                                                ;AN000;
      MOV   CL,7
      MOV   pbaud_ptr,OFFSET ninetysixhundred_str                                                                       ;AN000;
   .WHEN <parm_list[DI].item_tag EQ nineteentwohundred_item_tag> NEAR THEN   ;handle 19200 case if 19, 19200, 19.2 or 19.2K specified
      MOV   CL,8              ;value for 19200 baud, no old equivalent                                                  ;AC001;
      MOV   pbaud_ptr,OFFSET nineteentwohundred_str                                                                     ;AC001;

.ENDSELECT                                                                                                           ;AC001;
;          AL IS:  XXX00000 for the baud rate, CL has appropriate value for baud

MOV   DI,parity_index                                                                                             ;AN000;
.IF <parm_list[DI].item_tag EQ none_item_tag> THEN                                                                ;AN000;
   MOV PPARITY,"n"          ;set up message for no PARITY                                                       ;AN000;
   MOV   BH,0               ;AL already set properly for old init                                                 ;AN000;
.ELSEIF <parm_list[DI].item_tag EQ odd_item_tag> THEN                                                             ;AN000;
   MOV PPARITY,"o"          ;set up message for odd PARITY                                                       ;AN000;
   OR    AL,08H             ;PUT THE 000XX000 BITS TO AL PARM WHERE XX=01 FOR PARITY=ODD                         ;AN000
   MOV   BH,1               ;new initialize                                                                      ;AN000;
.ELSEIF <parm_list[DI].item_tag EQ space_item_tag> THEN                                                            ;AN000;
   MOV PPARITY,"s"          ;set up message for space PARITY                                                       ;AN000;
   MOV   BH,4               ;SPACE not supported in old init                                                      ;AN000;
.ELSEIF <parm_list[DI].item_tag EQ mark_item_tag> THEN                                                            ;AN000;
   MOV PPARITY,"m"          ;set up message for mark PARITY                                                       ;AN000;
   MOV   BH,3               ;MARK parity not supported in old init                                                ;AN000;
.ELSE                      ;not specified or asked for even                                                       ;AN000;
   MOV PPARITY,"e"          ;set up message for even PARITY, the default if not specified                        ;AN000;
   OR    AL,18H             ;PUT THE 000XX000 BITS TO AL PARM WHERE XX=11 FOR PARITY=EVEN                        ;AN000
   MOV   BH,2                    ;even parity for new initialize                                                 ;AN000;
.ENDIF                                                                                                            ;AN000;

MOV   DI,data_bits_index                                                                                          ;AN000;
.IF <parm_list[DI].item_tag EQ five_item_tag> THEN                                                                ;AN000;
   MOV   pdata,"5"            ;set up message for 5 bits                                                         ;AN000;
   MOV   CH,0                 ;not old init for 5 data bits                                                       ;AN000;
.ELSEIF <parm_list[DI].item_tag EQ six_item_tag> THEN                                                             ;AN000;
   MOV   pdata,"6"            ;set up message for 6 bits                                                         ;AN000;
   MOV   CH,1                 ;no old init for 6 data bits                                                        ;AN000;
.ELSEIF <parm_list[DI].item_tag EQ eight_item_tag> THEN                                                           ;AN000;
   MOV   pdata,"8"            ;set up message for 8 bits                                                         ;AN000;
   OR    AL,03H             ;IN THE 000000XX POSITION, SET XX=11 TO MEAN 8 DATA BITS                                 ;AN000;
   MOV   CH,3                                                                                                     ;AN000;
.ELSEIF <parm_list[DI].item_tag EQ seven_item_tag> THEN                    ;C07
   OR    AL,02H             ;IN THE 000000XX POSITION, SET XX=10 TO MEAN 7 ;C07
   MOV   CH,2                 ;message already set up for 7 bits           ;C07
.ELSE                         ;asked for 7 or skipped the parm and will get 7 as default                          ;AN000;
   OR    AL,02H             ;IN THE 000000XX POSITION, SET XX=10 TO MEAN 7 DATA BITS                                 ;AN000;
   MOV   CH,2                 ;message already set up for 7 bits                                                  ;AN000;
   mov   databit_default,true ;Set up flag showing we used default databits;C07
.ENDIF                                                                                                            ;AN000;

;PUT THE NO. STOP BITS TO AL PARM IN THE 00000X00 POSITION and BL for new init                                               ;AN000
MOV   DI,stop_bits_index
;AN000;
MOV   BL,0                    ;assume stop bits was 1, message already set up                                 ;AN000;
.SELECT
                                                                                                                  ;AN000;
   .WHEN <parm_list[DI].item_tag EQ two_item_tag>                                                       ;AN000;
      MOV   pstop,"2"         ;set up message for 2 stop bits                                         ;AN000;
      or    al,4              ;turn on proper bit for 2 stop bits
      MOV   BL,1              ;value for two or 1.5                                                                 ;AN000;
      .IF <pdata EQ "5"> THEN ;if user request 5 data bits and 2 stop bits ;C07
          MOV   pstop_ptr,OFFSET one_point_five_str  ;He really gets 1.5   ;C07
      .ENDIF                                         ;stopbits             ;C07

   .WHEN <parm_list[DI].item_tag EQ one_point_five_item_tag>                 ;AN000;                              ;AN000;
      MOV   pstop_ptr,OFFSET one_point_five_str                ;set up message for 1.5 stop bits                  ;AN000;
      or    al,4              ;turn on proper bit for 1.5 stop bits
      MOV   BL,1              ;new init for 1.5                                                                 ;AN000;
      .IF <databit_default EQ true> THEN                                   ;C07
          MOV   pdata,"5"            ;set up message for 5 databits        ;C07
          MOV   CH,0                 ;not old init for 5 data bits         ;C07
      .ENDIF                                                               ;C07
      .IF <pdata GE "6"> AND                                               ;C07
      .IF <pdata LE "8"> THEN                                              ;C07
          MOV   pstop_ptr,OFFSET pstop    ;Set up message for 2 databits   ;C07
          mov   pstop,"2"                 ;Can't get 1.5 stopbits w/>5 data;C07
      .ENDIF                                                               ;C07

   .WHEN <stop_bits_index EQ not_specified>              ;if stop bits not specified                       ;AN000;
      MOV   DI,baud_index                                                                                               ;AC000;
      .IF <parm_list[DI].item_tag EQ oneten_item_tag>     ;BAUD=110 SPECIFIED THEN SET DEFAULT STOP BITS TO TWO         ;AC000;
         OR    AL,04H             ;TURN ON BIT IN 00000X00 POSITION TO REQUEST 2 STOP BITS               ;AN000;
         MOV   pstop,"2"         ;set up message for 2 stop bits                                         ;AN000;
         mov   bl,1              ;set up for extended init
      .ENDIF                     ;FOR STOPBITS=1, LEAVE THAT BIT OFF, message already set by modecom    ;AN000;

;  .OTHERWISE specified 1, everything set up

.ENDSELECT                 ;IF not 1.5 or two, already set up for 1                                             ;AN000;

 .IF <noerror EQ true> THEN                                                                                           ;AN000;
  ;SET DX PARM TO REQUEST WHICH COM DEVICE                                                                           ;AN000;
   XOR   DX,DX                                                                                                       ;AN000;
   MOV   DL,DEVICE               ;device set by modepars in first_parm_case:                                         ;AN000;
   AND   DL,07                   ;convert to binary 1 thru 4                                                         ;AN000;
   DEC   DL                      ;put in BIOS digestable 0 thru 3                                                    ;AN000;

;--------------------------------------------------------------------------
;M004;
;
; The init logic was redone because correction of bug M002 created M004
; The logic is now:
; 
;   If ExtendedInitRequired
;      Then
;        DoExtendedInit
;        CheckIfExtendedFunctionAreThere
;        If not
;           then
;             Display Function not supported
;             Goto End
;      Else
;        DoNormalInit
;   Display InitMessage
;   End:
;--------------------------------------------------------------------------
                                                                                                                  ;AN000;
   .IF <new_com_initialize EQ true> THEN                                                                                ;AC001;
      XOR   AL,AL             ;ask for no break                                                                         ;AN000;
      MOV   AH,4              ;new set baud BIOS call                                                                   ;AN001;
      INT   14H               ;INIT THE RS232
      MOV   AX,500H           ;get MCR to check if extended service supported
      MOV   BL,0FFh           ;If extended available, BL will not be xFF
      INT   14H
      INC   BL                ;If zero, BL stayed to xFF
      .IF Z
        DISPLAY Function_not_supported
	JMP SHORT DID_NOT_INIT
      .ENDIF
   .ELSE                      ;old style com initialization                                                    ;AN000;      ;AC001;
      XOR   AH,AH             ;AH=0 requests initialization                                                                 ;AC001;
      INT   14H               ;INIT THE RS232                                                                        ;AN000;
   .ENDIF                                                                                                                   ;AC001;

;           NOW THAT THE RS232 IS INITIALIZED,                                                                        ;AN000;

   CALL    SETTO        ;LOOK AT P PARM, MAYBE TIMEOUT TO BE RETRIED                                                 ;AN000;
   DISPLAY INITMSG            ;TELL USER RS232 IS INITIALIZED                                                        ;AN000;

DID_NOT_INIT:

 .ENDIF                                                                                                               ;AN000;

 RET                                                                                                                   ;AN000;
SETCOM ENDP                                                                                                                ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;
SUBTTL                                                                                                                     ;AN000;
PAGE                                                                                                                       ;AN000;
                                                                                                                           ;AN000;
                                                                                                                           ;AN000;

MODECOM PROC    NEAR


       MOV    AL,DEVICE           ;AL= DEVICE ID OF "1", "2", "3" or "4"
       AND    AL,07               ;TRANSLATE TO BINARY
       DEC    AL                  ;PUT IN ZERO BASE
       SAL    AL,1                ;POSITION OF PORT ADDRESS WORD (2*AL)
       XOR    AH,AH               ;CLEAR AH
       MOV    SI,AX
       XOR    AL,AL               ;CLEAR AX
       PUSH   DS
       MOV    DS,AX
       CMP    WORD PTR DS:SERIAL_BASE[SI],0       ;SEE IF THE COM PORT EXISTS
       POP    DS
       JNE    THEN01A
          MOV   DI,0                      ;the device name is always the first parm                                         ;AN000;
          MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]                                  ;AN000;
          MOV   CX,parm_list[DI].value1                                                     ;AN000;
          MOV  illegal_device_ptr,CX
          DISPLAY err1                   ;AN000;"Illegal device name - COMX"
          MOV  noerror,false              ;AN000;
         ABORT
;
THEN01A:

;                    DEFINE DEFAULTS:
         MOV PSTOP,"1"            ;ONE STOP BIT, OK FOR BAUD>110
         MOV PDATA,"7"            ;7 DATA BITS
         MOV PPARM,"-"            ;NO SERIAL TIMEOUT RETRY
;

;WE HAVE THE INFORMATION NEEDED TO INITIALIZE THE RS232 DEVICE
;
         CALL SETCOM              ;SET THE RS232 DEVICE
;
;    : ELSE ,SINCE COUNT WAS NOT BIG ENUF
ENDIF01:                         ;jump to here if the port does not exist
     RET                          ;RETURN TO MODE MAIN ROUTINE
MODECOM ENDP
PRINTF_CODE     ENDS
    END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modecpeq.inc ===
; MODECPEQ.INC - INCLUDED IN MODECP.SAL 

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	IF1
	    %OUT    INCLUDE MODECPEQ.INC ;MACROS,DOS EQUATES,STRUCS,OTHER EQUATES
	ENDIF

;	$SALUT	CP(4,9,17,32)
HEADER	MACRO	TEXT,EJECT
;;example:  header <new subtitle goes here>
;;the angle brackets are required
.XLIST
	SUBTTL	TEXT
IFB	<EJECT>
.LIST
ENDIF
	PAGE
	ENDM

; - - - - - - - - - - - - - - - - - - - -
;			   $SALUT      CP(2,28,40,47)

DOSCALL 		   MACRO       FUNC,SUBFUNC
;;IF SUBFUNC IS USED, THEN FUNC MUST BE USED
			   IFNB        <FUNC> ;IS THERE ANY PARMS AT ALL?
			     IFNB	 <SUBFUNC>
			       MOV	   AX,(FUNC SHL 8) + SUBFUNC
			     ELSE	      ;;SINCE THERE IS NO SUBFUNC
			       MOV	   AH,FUNC
			     ENDIF
			   ENDIF
			   INT	       21H
			   ENDM

; - - - - - - - - - - - - - - - - - - - -
;		    $SALUT CP(4,21,26,32)

;		DOS FUNCTION CALLS
PRINTSTR	    EQU  09H   ;PRINT STRING ENDING WITH "$"
			       ;DS:DX = POINTER TO STRING

SET_VECTOR	    EQU  25H   ;SET INTERRUPT VECTOR
			       ;DS:DX = VECTOR TO INT HANDLER
			       ;AL = INTERRUPT NUMBER

DOS_VERSION	    EQU  30H   ;DETERMINE VERSION OF DOS
			       ;OUTPUT: AL=MAJOR, AH=MINOR VERSION NUMBER
			       ;	BX AND CX SET TO ZERO

BREAK_CHECK	    EQU  33H   ;CNTRL-BREAK CHECK
			       ;AL=0 - REQUEST CURRENT STATE
			       ;AL=1 - SET CURRENT STATE
			       ;DL=0 - BREAK OFF
			       ;DL=1 - BREAK ON

GET_VECTOR	    EQU  35H   ;GET INTERRUPT VECTOR
			       ;AL = INTRRUPT NUMBER
			       ;OUTPUT: ES:BX = CONTENTS OF VECTOR

OPEN		    EQU  3DH   ;OPEN FILE FOR INPUT
			       ;DS:DX = POINTER TO ASCIIZ PATH NAME
			       ;AL = OPEN MODE

CLOSE		    EQU  3EH   ;CLOSE A FILE HANDLE
			       ;BX = HANDLE RETURNED BY OPEN OR CREATE

READ		    EQU  3FH   ;READ FROM A FILE OR DEVICE
			       ;BX = FILE HANDLE
			       ;DS:DX = BUFFER ADDRESS
			       ;CX NUMBER OF BYTES TO READ

WRITE		    EQU  40H   ;WRITE TO A FILE OR DEVICE
			       ;BX = FILE HANDLE
			       ;DS:DX = ADDRESS OF DATA TO WRITE
			       ;CX = NUMBER OF BYTES TO WRITE


LSEEK		    EQU  42H   ;MOVE FILE READ/WRITE POINTER
			       ;CX:DX - DISTANCE TO MOVE IN BYTES
			       ;BX = FILE HANDLE
			       ;AL = METHOD OF MOVING:
			       ;   00 - MOVE CX:DX BYTES FROM BEGINNING
			       ;   01 - MOVE TO CURRENT LOCATION + OFFSET
			       ;   02 - MOVE TO END OF FILE
			       ;OUTPUT:DX:AX NEW POINTER LOCATION

IOCTL		    EQU  44H   ;I/O CONTROL FOR DEVICES
			       ;DS:DX = DATA OR BUFFER
			       ;CX = NUMBER OF BYTES TO READ OR WRITE
			       ;BX = FILE HANDLE, OR,
			       ;BL = DRIVE NUMBER (0=DEFAULT,1=A,...)
			       ;AL = FUNCTION VALUE
			       ;OUTPUT: AX=NO. BYTES TRANSFERRED
			       ; OR ERROR CODE IS CY SET

ALLOC_MEM	    EQU  48H   ;ALLOCATE MEMORY
			       ;BX = NUMBER OF PARAGRAPHS REQUESTED
			       ;OUTPUT: IF NO CARRY, AX:0 POINTS TO
			       ; ALLOCATED MEMORY BLOCK
			       ; IF CARRY, BX IS SIZE OF LARGEST BLOCK
			       ; AVAILABLE, IN PARAGRAPHS, AX=ERR CODE

FREE_AL_MEM	    EQU  49H   ;FREE ALLOCATED MEM
			       ;ES=SEG OF BLOCK BEING RETURNED
			       ;OUTPUT: AX=ERROR CODE IF CY SET

EXTERROR	    EQU  59H   ;EXTENDED ERROR
			       ;BX = 30 VERSION NUMBER (FOR 3.30)
			       ;OUTPUT:
			       ;AX=EXTENDED ERROR
			       ;BH=ERROR CLASS
			       ;BL=SUGGESTED ACTION
			       ;CH=LOCUS

;		(THESE VALUES GO TO AX FOR INT 21H)
SET_GLOBAL_CP	    EQU  6602H ;INPUTS:
			       ; BX=CODE PAGE,

GET_GLOBAL_CP	    EQU  6601H ;RESULTS:
			       ; BX=ACTIVE CODE PAGE,
			       ; DX=SYSTEM CODE PAGE

GENERIC_IOCTL	    EQU  440CH ;INPUTS:
			       ; CH AND CL SET AS DEFINED IN NEXT 2 SECTIONS
			       ; IN GENERAL, CH=CATEGORY CODE (MAJOR CODE)
			       ; CL=FUNCTION WITHIN CATEGORY (MINOR CODE)

;			MAJOR CODES:
;		(THESE VALUES GO TO CH REG DURING GENERIC IOCTL:
UNK_DEV_TYPE	    EQU  00H   ;USED IF TYPE NOT KNOWN
COM_DEV_TYPE	    EQU  01H   ;COMx DEVICE TYPE
CON_DEV_TYPE	    EQU  03H   ;CONSOLE DEVICE TYPE
LPT_DEV_TYPE	    EQU  05H   ;LPTx DEVICE TYPE
GLOBAL_CP	    EQU  -1    ;GLOBAL CODEPAGE, INDICATED BY DEVICE="*",
			       ; NOT USED WITH GENERIC IOCTL

;			MINOR CODES:
;		SUBFUNCTIONS OF GENERIC_IOCTL:
;		(THESE VALUES GO TO CL REG)
PREPARE_STRT	    EQU  4CH   ;INPUTS:
			       ;BX=HANDLE, AX="GENERIC_IOCTL"
			       ;CX=xxx_DEV_TYPE * 256 + "PREPARE_STRT"
			       ;DS:DX=DATA BUFFER "DES_STRT_PACKET"

PREPARE_END	    EQU  4DH   ;INPUTS:
			       ;BX=HANDLE, AX="GENERIC_IOCTL"
			       ; DS:DX=DATA BUFFER "PACKET"

SELECT_CP	    EQU  4AH   ;INPUTS:
			       ;BX=HANDLE, AX="GENERIC_IOCTL"
			       ; DS:DX=DATA BUFFER "PACKET"

QUERY_SELECTED	    EQU  6AH   ;INPUTS:
			       ;BX=HANDLE, AX="GENERIC_IOCTL"
			       ; DS:DX=DATA BUFFER "PACKET"

QUERY_DES_LST	    EQU  6BH   ;INPUTS:
			       ;BX=HANDLE, AX="GENERIC_IOCTL"
			       ; DS:DX=DATA BUFFER

;		      OTHER EQUATES
IOCTL_WRITE	    EQU  3     ;VAL FOR AL, WHEN WRITING TO DEVICE VIA IOCTL
FILE_OPEN_MODE	    EQU  0     ;BIT FIELDS ARE ISSSRAAA WHERE:
			       ; I=0 FILE IS INHERITED BY CHILD PROCESS
			       ;   (OF WHICH THERE ISN'T ANY)
			       ; SSS=SHARING MODE IS "COMPATABILITY MODE"
			       ; R=0 (RESERVED)
			       ; AAA=0 (READ ACCESS)
DEV_OPEN_MODE	    EQU  2     ;SAME BITS AS ABOVE, EXCEPT AAA=010, READ/WRITE ACCESS

FALSE		    EQU  0     ;INDICATES AN ERROR TO ERRORLEVEL
TRUE		    EQU  0FFH

refresh_request     EQU  0     ;scaler to indicate that the current request is refresh for 'des_end'

STDERR		    EQU  2     ;PRE-OPENED HANDLE FOR STANDARD ERROR
STDOUT		    EQU  1     ;PRE-OPENED HANDLE FOR STANDARD OUTPUT

INT24		    EQU  24H   ;CRITICAL ERROR HANDLER VECTOR
EMPTY		    EQU  -1    ;EMPTY SLOT IN LIST OF CODEPAGES

IOCTL_FUN_GET_INFO  EQU  0     ;GET DEVICE INFORMATION (RETURNED IN DX) FROM IOCTL
IOCTL_FUN_SET_INFO  EQU  1     ;SET DEVICE INFORMATION (PASSED IN DX) TO IOCTL
ISDEVICE	    EQU  0080H ;FLAG IN DEVICE INFO WORD, RETURNED IN DX
BINARY_DEV	    EQU  0020H ;BINARY FLAG IN DEVICE INFO WORD

MAPERR		    EQU  19    ;ERRORS FROM DEVICES MAPPED TO COMMON ERRORS,
			       ; AS DEVICE ERR=0 IS REPORTED AS COM ERROR=19
FAIL24		    EQU  83    ;RET CODE, INT 24 HANDLER REQUESTED "FAIL"

;PREPARE START ERROR CODES:
DS_ERR0 	    EQU  0     ;PREVIOUS PREPARE DELETED
DS_ERR1 	    EQU  1     ;INVALID FUNCTION NUMBER
DS_ERR8 	    EQU  8     ;CODE PAGE CONFLICT (USED FOR KEYB XX MISMATCH)
DS_ERRA 	    EQU  0AH   ;DEVICE ERROR
DS_ERR16	    EQU  016H  ;UNKNOWN COMMAND (22 DECIMAL)

;PREPARE WRITE ERROR CODES:
DW_ERR8 	    EQU  8     ;DEVICE NOT FOUND IN FILE ,OR
			       ;CODE PAGE NOT FOUND IN FILE
DW_ERRA 	    EQU  0AH   ;DEVICE ERROR
DW_ERRC 	    EQU  0CH   ; FILE CONTENTS NOT A FONT FILE,
			       ; OR FILE CONTENTS STRUCTURE DAMAGED

;PREPARE END ERROR CODES:
DE_ERRC 	    EQU  0CH   ;NO PREPARE START

;SELECT ERROR CODES:
IN_ERR7 	    EQU  07H   ;CODE PAGE NOT PREPARED
IN_ERR8 	    EQU  08H   ;CURRENT KEYB DOES NOT SUPPORT THIS CP
IN_ERRA 	    EQU  0AH   ;DEVICE ERROR

;QUERY SELECTED ERROR CODES:
QS_ERR7 	    EQU  07H   ;NO CODE PAGE HAS BEEN SELECTED
QS_ERRA 	    EQU  0AH   ;DEVICE ERROR

;QUERY PREPARED LIST ERROR CODES:
QL_ERR7 	    EQU  07H   ; NO CODE PAGES HAVE BEEN SELECTED
QL_ERRA 	    EQU  0AH   ;DEVICE ERROR

;REFRESH ERROR CODES RETURNED FROM PREPARE START FOR A REFRESH REQUEST:

RS_ERR8 	    EQU  8     ;KEYBOARD/CODE PAGE CONFLICT
RS_ERRA 	    EQU  0AH   ;DEVICE ERROR
RS_ERRC 	    EQU  0CH   ;DEVICE DRIVER DOES NOT HAVE COPY OF CODE PAGE
			       ; TO DOWNLOAD TO DEVICE

;ERROR CODES PRESENTED IN THE LOWER HALF OF DI TO THE INT 24H HANDLER:
;CRERR0 	     EQU  0	;ATTEMPT TO WRITE ON WRITE_PROTECTED DISKETTE
;CRERR1 	     EQU  1	;UNKNOWN UNIT
;CRERR2 	     EQU  2	;DRIVE NOT READY
;CRERR3 	     EQU  3	;UNKNOWN COMMAND
;CRERR4 	     EQU  4	;DATA ERROR (crc)
;CRERR5 	     EQU  5	;BAD REQUEST STRUCTURE LENGTH
;CRERR6 	     EQU  6	;SEEK ERROR
;CRERR7 	     EQU  7	;UNKNOWN MEDIA TYPE
;CRERR8 	     EQU  8	;SECTOR NOT FOUND
;CRERR9 	     EQU  9	;PRINTER OUT OF PAPER
;CRERRA 	     EQU  0AH	;WRITE FAULT
;CRERRB 	     EQU  0BH	;READ FAULT
;CRERRC 	     EQU  0CH	;GENERAL FAILURE

;EXIT CODES, IN AL, WHEN IRET FROM INT 24H ERROR HANDLER.
CRERR_IGNORE	    EQU  0     ;IGNORE THE ERROR
CRERR_RETRY	    EQU  1     ;RETRY THE OPERATION
CRERR_TERM	    EQU  2     ;TERMINATE PROGRAM VIA INT 23H
CRERR_FAIL	    EQU  3     ;FAIL THE SYSTEM CALL IN PROGRESS

;		EQUATES FOR THE BREAK CHECK FUNCTION:

;IN AL:
REQUEST_BREAK_STATE EQU  0
SET_BREAK_STATE     EQU  1

;IN DL:
BREAK_OFF	    EQU  0
BREAK_ON	    EQU  1

DBCS_header	    EQU  ES:[DI]    ;used to address DBCS_head
DBCS_table	    EQU  DS:[SI]    ;used to address the DBCS vector table

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;	       DEFINITIONS OF CONTROL BLOCKS

FON		    STRUC      ;CODEPAGE FONT FILE CONTENTS
FONTAG		    DB	 0FFH,"FONT   " ;FILE TAG
		    DB	 8 DUP(?) ;RESERVED
FONPTCT 	    DW	 ?     ;COUNT OF POINTERS IN HEADER
FONPT		    DB	 ?     ;START OF ARRAY OF POINTERS
FON		    ENDS

;		THIS STRUC MAPS AN AREA POINTED TO BY "CP_CB", AN EXTRN
;AC001;CODEPAGE_PARMS	   STRUC
;AC001;DEVICE		   DW	?     ;POINTER TO ASCIIZ STRING OF DEVICE NAME
;AC001;DES_PACK_PTR	   DW	?     ;OFFSET TO "DES_STRT_PACKET"
;AC001;FONT_FILESPEC	   DW	?     ;PATH AND FILESPEC OF FONT FILE
;AC001;REQUEST_TYPE	   DW	?     ;TYPE OF FUNCTION TO BE PERFORMED
;AC001;CODEPAGE_PARMS	   ENDS
;		DEFINITIONS OF VALUES FOUND IN "REQUEST_TYPE" ABOVE:
		    EXTRN SELECT:ABS
		    EXTRN PREPARE:ABS
		    EXTRN REFRESH:ABS

;		"PACKET" POINTED TO BY DS:DX
PACKET		    STRUC      ;USED BY MINOR CODES: 6AH,4AH,4DH (SELECT, QUERY SELECTED, PREPARE END)
PACKLEN 	    DW	 2     ;LENGTH OF PACKET IN BYTES, FOR DBCS COUNTRIES, LENGTH OF DBCS TABLE (IF NON-ZERO) WILL be added
PACKCPID	    DW	 0     ;CODE PAGE ID
PACKVECTOR1	    DB	 0     ;start of vector list if included							    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0     ; holders for maximum possible number of 						    ;AN000;
		    DB	 0     ; DBCS vector pairs									    ;AN000;
		    DB	 0     ;											    ;AN000;
		    DB	 0     ;											    ;AN000;
		    DB	 0     ;											    ;AN000;
PACKVECTOR12	    DB	 0     ;											    ;AN000;
		    DB	 0     ;											    ;AN000;
PACKET		    ENDS												    ;AN000;
															    ;AN000;
DBCS_head	    STRUC      ;return from function 6507, pointed to by ES:DI, addressed via "DBCS_header"                 ;AN000;
info_id 	    DB	 7												    ;AN000;
table_ptr	    DD	 0     ;used to address DBCS_tabl								    ;AN000;
DBCS_head	    ENDS
															    ;AN000;
DBCS_tabl	    STRUC      ;map of DBCS table, addressed via DBCS_table						    ;AN000;
table_len	    DW	 6     ;length in bytes of the list of vectors							    ;AN000;
vector1 	    DB	 0     ;start of vector list									    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0     ;each vector is two bytes, a start value and an						    ;AN000;
		    DB	 0     ;end value										    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
		    DB	 0												    ;AN000;
DBCS_tabl	    ENDS


;		"DES_STRT_PACKET" POINTED TO BY DS:DX
DES_STRT_PACKET     STRUC
DES_STRT_PKFL	    DW	 ?     ;FLAGS (DEFINED BELOW STRUC DEFINITION)
DES_STRT_PKLEN	    DW	 ?     ;BYTE LENGTH OF REST OF THE PACKET,
			       ; NOT INCLUDING THIS LENGTH FIELD
DES_STRT_PKNUM	    DW	 ?     ;NUMBER OF CODEPAGES IN FOLLOWING LIST
DES_STRT_PKCP1	    DW	 ?     ;CODE PAGE ONE
DES_STRT_PKCP2	    DW	 ?     ;CODE PAGE TWO
;   :		    :	 :	  :
DES_STRT_PKCPN	    DW	 ?     ;CODE PAGE n
;NOTE: THESE n CODEPAGES MAY HAVE A -1 VALUE, WHICH IS TREATED AS A PLACEHOLDER
; TO ALLOW POSITION CONTROL FOR EACH CODEPAGE VALUE IN THE LIST.
DES_STRT_PACKET     ENDS

;			DEFINITIONS OF CONTENTS OF "DES_STRT_PKFL"
DES_STRT_FL_SINGLE  EQU  8000H ; 8000H=SINGLE CP FIFO PREPARE
;   (NOT SUPPORTED, ONLY LIST FORM IN DOS 3.30 RELEASE)
DES_STRT_FL_CART    EQU  0001H ; 0001H=CARTRIDGE PREPARE

; ED OF MODECPEQ.INC FILE
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modecp.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  05/22/90  MKS  C05  MODE was hanging when preparing code pages.  This is
;                      because someone was using PSP:6 to see how many free
;                      bytes were in the segment.  This old CALL5 from CPM is
;                      not officially supported and apparently changed in 5.0.
;                      We are now doing basically the same thing, but using a
;                      DOS call to see how much memory is left in the segment.
;
;******************************************************************************                                            ;AN000;
.XLIST
INCLUDE STRUC.INC
.LIST


;  M A C R O S  ͻ
;                                                                                        

set_submessage_ptr   MACRO submessage,message ;PUT pointer to "subMESSAGE" into submessage pointer field of "message".

MOV   AX,submessage                          ;AX=message number                 ;AN001;
MOV   DH,utility_msg_class                   ;DH=message class=utility class    ;AN001;
CALL  SYSGETMSG                              ;DS:SI=>message piece                                ;AN001;
MOV   BP,OFFSET sublist_&message             ;address the sublist control block ;AN001;
MOV   [BP].sublist_off,SI                    ;the sublist now points to the desired message piece ;AN001;
ENDM                                                                                              ;AN001;

;                                                                                        
;  M A C R O S  ͼ

      PAGE    ,132                    ;
        TITLE   MODECP.SAL - CODEPAGE SUPPORT
        INCLUDE MODECPRO.INC            ;MODULE PROLOGUE
;THE FOLLOWING "INCLUDE MODECPEQ.INC" CONTAINS THE FOLLOWING DEFINITIONS:
; MACROS: HEADER, DOSCALL
; DOS FUNCTION CALLS EQUATES
; MAJOR AND MINOR CODES FOR "GENERIC IOCTL" DOS FUNCTION CALL
; ERROR RETURN CODES FROM SEVERAL SUBFUNCTIONS OF THE GENERIC IOCTL
; OPEN MODE EQUATES
; DEFINITIONS OF STRUC:
;      "FON" - THE HEADER OF THE CODEPAGE FONT FILE
;      "CODEPAGE_PARMS" - INPUT PARM LIST FROM CALLER
;      "PACKET" AND "DES_STRT_PACKET" - BUFFERS USED
;         BY THE SEVERAL CODEPAGE DOS IOCTL CALLS
        INCLUDE MODECPEQ.INC            ;MACROS,DOS EQUATES,STRUCS,OTHER EQUATES
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        HEADER  <DESCRIPTIONS OF ALL MESSAGES USED BY MODECP.SAL>
        INCLUDE MODECPMS.INC            ;DESCRIPTIONS OF MESSAGES
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
        HEADER  <EXTRNS, LOCAL DATA AND OTHER WORKAREAS>
;              $SALUT CP(4,16,22,38) ;(set preprocessor columns for indenting)
PRINTF_CODE    SEGMENT WORD PUBLIC
               ASSUME CS:PRINTF_CODE ;"MODE" IS A ".COM" FILE;
               ASSUME DS:PRINTF_CODE ; AS SUCH, ALL FOUR SEG REGS
               ASSUME ES:PRINTF_CODE ; POINT TO THE ONE COMMON
               ASSUME SS:PRINTF_CODE ; SEGMENT, "PRINTF_CODE"

MODECP00       EQU   $               ;UNREFERENCED, LOCATES REL ZERO IN LINK MAP
               PUBLIC MODECP00


;  P U B L I C S  ͻ
;                                                                                        

PUBLIC   CLOSE                      ;EQU  3EH   ;CLOSE A FILE HANDLE,make available to analyze_and_invoke, see modecpeq.inc
PUBLIC   DES_STRT_FL_CART           ;EQU  0001H, means CARTRIDGE prepare
PUBLIC   DEV_OPEN_MODE              ;make available to analyze_and_invoke, see modecpeq.inc
PUBLIC   OPEN                       ;make available to analyze_and_invoke, see modecpeq.inc

;                                                                                        
;  P U B L I C S  ͼ

;  E X T R N S  ͻ
;                                                                                        

EXTRN    cp_cb:WORD        ;AN000;codepage_parms <>, see invoke

               EXTRN NOERROR:BYTE    ;ERRORLEVEL RETURN CODE FLAG BYTE
                                     ; NORMAL VALUE IS "TRUE" (-1)
                                     ; IF ERROR OCCURS, SET IT TO "FALSE" (0)
               EXTRN PRINTF:NEAR     ;SENDS MESSAGES TO STDOUT OR STDERR

EXTRN    SYSGETMSG:NEAR    ;AN001;message services routine to get the address of a message.  Used to get address of a submessage.
EXTRN    Utility_Msg_Class:ABS    ;AN001;
EXTRN    sublist_cpmsg8:BYTE    ;AN001;
EXTRN    sublist_cpmsg10:BYTE    ;AN001;
EXTRN    sublist_cpmsg17:BYTE    ;AN001;

;                                                                                        
;  E X T R N S  ͼ


INCLUDE  common.stc        ;AN001;includes the following structures


;bogus    EQU   88H      ;totally invalid value
;
;codepage_parms STRUC
;   cp_device      DW    ?
;   des_pack_ptr   DW    ?
;   font_filespec  DW    ?
;   request_typ    DW    ?
;codepage_parms ENDS
;
;
;parm_list_entry   STRUC                   ;used by parse_parameters and invoke
;
;parm_type            DB       bogus
;item_tag             DB       0FFH
;value1               DW       bogus       ;used only for filespecs and code page numbers
;value2               DW       bogus       ;used only for filespecs and code page numbers
;keyword_switch_ptr   DW    0
;
;parm_list_entry   ENDS
;
;
;sublist_def  STRUC         ;used by initialize_sublists
;
;             db  ?  ;Sublist Length, fixed
;             db  ?  ;Reserved, not used yet                   ;AN000;
;sublist_off  dw  ?  ;offset
;sublist_seg  dw  ?  ;segment part of pointer to piece of message
;             db  ?  ;ID, special end of message format ;AN000;
;             db  ?  ;flags
;             db  ?
;             db  ?
;             db  ?
;
;sublist_def  ENDS

;  D A T A  ͻ
;                                                                                        


                                     ;ALL MESSAGES ARE IN THE MODEMES.ASM MODULE
current_request   DB bogus             ;see 'do_refresh' and 'des_end'
dgroup         group zseg,printf_code
zseg           segment para public
;               LOCAL WORKAREA
;C05 BUF            DB    512 DUP(0)      ;DEFAULT BUFFER AREA
BUF            DB 0                  ;DEFAULT BUFFER AREA               ;C05
                                     ;Buffer allocated from here later  ;C05
               public buf            ;not referenced, just shows up on mapf buf
END_OF_BUF     EQU   $
zseg           ends

RESPONSE_LIST  LABEL WORD            ;WHERE TO PUT THE RESULTS OF QUERY prepareS
RES_NUM_ENTRIES EQU  12              ;NUMBER ENTRIES IN EACH HARDWARE AND prepare LISTS
RES_LEN        DW    RES_END - RESPONSE_LIST - 2 ;BYTE SIZE OF RESPONSE AREA
RES_HWCP       DW    RES_NUM_ENTRIES ;NUMBER OF HARDWARE CODE PAGES IN FOLLOWING LIST
               DW    RES_NUM_ENTRIES DUP(-1)
RES_DSCP       DW    RES_NUM_ENTRIES ;NUMBER OF prepare CODE PAGES IN FOLLOWING LIST
               DW    RES_NUM_ENTRIES DUP(-1)
RES_END        EQU   $               ;END OF QUERY prepare RESPONSE LIST


OLDINT24       DD    ?               ;ORIGINAL CONTENTS OF INT 24H VECTOR
CRITERROR      DW    0               ;ERROR REPORTED IN DI TO INT 24H HANDLER

DEVICE_STATUS  DW    ?               ;FLAGS SET BY IOCTL (GET DEVICE INFO)
DEV_HANDLE     DW    ?               ;VALUE OF HANDLE RETURNED BY
                                     ; OPEN TO DEVICE FOR IOCTL I/O
FILE_HANDLE    DW    ?               ;VALUE OF HANDLE RETURNED BY
                                     ; OPEN TO FILESPEC.
DEV_TYPE       DW    prepare_STRT    ;CX=xxx_DEV_TYPE * 256 + "prepare_STRT"
                                     ;THE HIGH BYTE IS JUST ZERO HERE, BUT
                                     ; THAT WILL BE OR'ED IN LATER
PK             PACKET <>             ;SELECT, QUERY SELECTED, prepare END

PUBLIC         PK

DBCS_headr     DBCS_head <>

PUBLIC         DBCS_headr

;       THESE NEXT TWO WORDS MUST BE KEPT TOGETHER
;       THEY ARE REFERENCED AS A DWORD
DBUF           LABEL DWORD
BUF_OFF        DW    0               ;OFFSET OF ALLOCATED BUFFER
BUF_SEG        DW    ?               ;SEGID OF ALLOCATED BUFFER

BUF_SIZ        DW    1000H           ;REMEMBER HOW MUCH BUF IS AVAILABLE
                                     ; (IN PARAGRAPHS, NOT BYTES)
BUF_BYTES      DW    ?               ;NUMBER OF BYTES ACTUALLY IN THE BUFFER
PREPED         DW    0               ;COUNT OF CODEPAGES KNOWN TO DEVICE
MINOR_VERSION  DB    0,0             ;MINOR VERSION OF DOS
STATUS_BREAK   DB    0               ;SAVES THE CURRENT STATUS OF "BREAK"
DEV_TABLE      LABEL BYTE            ;TABLE OF SUPPORTED DEVICE NAMES
CN             DB    "CON",0
LP             DB    "PRN",0
L1             DB    "LPT1",0
L2             DB    "LPT2",0
L3             DB    "LPT3",0
C1             DB    "COM1",0
C2             DB    "COM2",0
C3             DB    "COM3",0
C4             DB    "COM4",0
G1             DB    "*",0
END_DEV_TABLE  LABEL BYTE
DEV_TAB_PTRS   DW    CN,LP,L1,L2,L3,C1,C2,C3,C4,G1,END_DEV_TABLE
NUM_TABL_ENTRIES EQU (($-DEV_TAB_PTRS)-2)/2 ;NUMBER OF DEVICE POINTERS
;THE ENTRIES IN THE NEXT TABLE MUST BE KEPT IN THE SAME ORDER AS THE
; DEVICE NAMES IN THE ABOVE LIST.  THERE MUST BE A ONE-TO-ONE CORRESPONDENCE
; BETWEEN THE DEVICE NAMES AND THIS TABLE OF DEVICE TYPES.
DEV_TYPES      DB    CON_DEV_TYPE    ;CN
               DB    LPT_DEV_TYPE    ;LP
               DB    LPT_DEV_TYPE    ;L1
               DB    LPT_DEV_TYPE    ;L2
               DB    LPT_DEV_TYPE    ;L3
               DB    COM_DEV_TYPE    ;C1
               DB    COM_DEV_TYPE    ;C2
               DB    COM_DEV_TYPE    ;C3
               DB    COM_DEV_TYPE    ;C4
               DB    GLOBAL_CP       ;G1


;                                                                                        
;  D A T A  ͼ



MODECP PROC NEAR               ;SUBROUTINE ENTRY POINT


 PUBLIC MODECP
                               ;REMEMBER WHAT THE CURRENT SETTING IS
                               ; OF "BREAK"
 DOSCALL BREAK_CHECK,REQUEST_BREAK_STATE ;CURRENT STATE RETURNED IN DL

 MOV   STATUS_BREAK,DL         ;REMEMBER WHAT THE CURRENT BREAK STATUS IS

 MOV   DL,BREAK_OFF            ;AVOID UNWANTED CTRL-BREAK DURING OPERATION
 DOSCALL BREAK_CHECK,SET_BREAK_STATE

;DOSCALL DOS_VERSION           ;DETERMINE VERSION OF DOS
                               ;OUTPUT: AL=MAJOR, AH=MINOR VERSION NUMBER
;MOV   MINOR_VERSION,AH        ;        BX AND CX SET TO ZERO

;               REMEMBER ORIGINAL OWNER OF INT 24H
;                  THE CRITICAL ERROR HANDLER
 CALL  SAVE_VECTOR24           ;SET DWORD AT "OLDINT24" WITH ORIGINAL POINTERS

;                       SET UP THE DEVICE TYPE
;                       FOR THE prepare START FUNCTION
 MOV   BX,CP_CB.cp_device     ;SET A BASE REG TO POINT TO DEV NAME
 CALL  SET_DEV_TYPE            ;INTERROGATE THE DEVICE NAME,
                               ; SET "DEV_TYPE" ACCORDINGLY
;CMP   BYTE PTR DEV_TYPE+BYTE,GLOBAL_CP ;WAS THE DEVICE SPECIFIED AS "*"?
;$IF   E
;   CALL  SET_GLOBAL_CODEPAGE
;$ELSE                         ;SINCE DEVICE WAS NOT "*"


;                      OPEN DEVICE
    MOV   DX,BX                ;DS:DX=POINTER TO ASCIIZ DEVICE NAME
    DOSCALL OPEN,DEV_OPEN_MODE ;OPEN DEVICE WITH READ/WRITE ACCESS

;   $IF   NC                   ;IF OPEN OK,
    JC $$IF1
       MOV   DEV_HANDLE,AX     ;REMEMBER HANDLE TO DEVICE

       MOV   BX,AX             ;PASS DEVICE HANDLE TO IOCTL
       DOSCALL IOCTL,IOCTL_FUN_GET_INFO

       MOV   DEVICE_STATUS,DX  ;SAVE THE DEVICE STATUS
;      $IF   NC,AND            ;IF OK
       JC $$IF2
       TEST  DX,ISDEVICE       ;IS THIS A DEVICE OR FILE?
;      $IF   NZ                ;IF IS A DEVICE
       JZ $$IF2
          CALL  FUNCTION_SELECT ;CHECK THE "request_typ", AND
                               ; CALL THE APPROPRIATE FUNCTION HANDLER
;      $ELSE                   ;SINCE NOT A DEVICE, MUST BE A FILE
       JMP SHORT $$EN2
$$IF2:
          MOV   DX,OFFSET CPMSG15     ;PASS POINTER TO MSG PARM LIST
          CALL  SEND_MSG       ;"DEVICE NOT SUPPORTED FOR CODEPAGE"

;      $ENDIF                  ;OK FROM IOCTL, AND DEVICE OR FILE?
$$EN2:
       MOV   BX,DEV_HANDLE
       DOSCALL CLOSE           ;FINISHED WITH DEVICE

;   $ELSE                      ;SINCE DEVICE OPEN NOT OK
    JMP SHORT $$EN1
$$IF1:
       MOV   AX,CP_CB.cp_device   ;GET OFFSET TO ASCIIZ DEVICE NAME
       MOV   CPMSGLST2DEV,AX   ; TO MSG PARM LIST
       MOV   DX,OFFSET CPMSG2     ;PASS POINTER TO MSG PARM LIST
       CALL  SEND_MSG          ;"FAILURE TO OPEN DEVICE"

;   $ENDIF                     ;DEVICE OPEN OK?
$$EN1:
;$ENDIF                        ;DEVICE "*"?
 MOV   DL,STATUS_BREAK         ;GET WHAT THE BREAK STATUS USED TO BE
 DOSCALL BREAK_CHECK,SET_BREAK_STATE ;RETURN TO USER DEFINED BREAK CONDITION

 RET                           ;RETURN TO CALLER
MODECP ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


SET_DEV_TYPE PROC NEAR



;INPUT: BX = OFFSET TO ASCIIZ OF DEVICE NAME

 MOV   CX,NUM_TABL_ENTRIES     ;SET LOOP COUNTER TO NUMBER OF DEVICE NAMES IN LIST
 MOV   SI,OFFSET DEV_TAB_PTRS  ;SET INDEX TO FIRST ENTRY IN TABLE OF POINTERS
 MOV   DI,OFFSET DEV_TYPES     ;SET INDEX TO FIRST ENTRY OF DEVICE TYPES
;$SEARCH                       ;LOOK THRU TABLE FOR MATCHING ENTRY
$$DO7:
    PUSH  DS                   ;AN002;
    POP   ES                   ;need ES and DS the same for the CMPSB    ;AN002;
    PUSH  CX                   ;SAVE COUNTER OF DEVICE NAMES
    PUSH  SI                   ;SAVE POINTER TO TABLE OF POINTERS TO DEVICE NAMES
    PUSH  DI                   ;SAVE POINTER TO TABLE OF DEVICE TYPES

    MOV   CX,[SI]+WORD         ;GET OFFSET TO NEXT DEVICE NAME
    SUB   CX,[SI]              ;SET COUNT TO SIZE OF THIS DEVICE NAME
    MOV   DI,[SI]              ;POINT TO DEVICE NAME FROM ENTRY IN TABLE
    MOV   SI,BX                ;POINT TO DEVICE NAME FROM COMMAND LINE
    REP   CMPSB                ;IS THIS THE ONE?

    POP   DI                   ;RESTORE POINTER TO DEVICE TYPE LIST
    POP   SI                   ;RESTORE POINTER TO TABLE OF DEVICE NAME POINTERS
    POP   CX                   ;RESTORE COUNTER OF DEVICES
;$EXITIF E
 JNE $$IF7
    MOV   AL,BYTE PTR[DI]      ;GET TYPE OF THIS DEVICE
;$ORELSE
 JMP SHORT $$SR7
$$IF7:
    ADD   SI,WORD              ;BUMP INDEX TO NEXT ENTRY IN TABLE
    ADD   DI,BYTE              ;BUMP INDEX TO NEXT ENTRY IN TABLE
;$ENDLOOP LOOP
 LOOP $$DO7
    MOV   AL,UNK_DEV_TYPE      ;DEVICE NAME IS NOT IN THE ABOVE LIST
;$ENDSRCH
$$SR7:
 MOV   BYTE PTR DEV_TYPE+BYTE,AL ;ADD DESCRIPTOR OF DEVICE TO DEV_TYPE WORD

RET
SET_DEV_TYPE ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

;SET_GLOBAL_CODEPAGE PROC NEAR
;
;;DEVICE WAS SPECIFIED AS "*", INDICATING THE GLOBAL CODEPAGE IS THE DEVICE
;
; MOV   AX,CP_CB.request_typ
; CMP   AX,SELECT
; $IF   E
;    MOV   BX,CP_CB.DES_PACK_PTR ;SET BASE REG TO POINT TO PACKET AREA
;    MOV   BX,[BX].DES_STRT_PKCP1 ;GET CODEPAGE ID FROM PACKET
;    MOV   AX,SET_GLOBAL_CP     ;SET GLOBAL CODEPAGE
;    DOSCALL
;
;    $IF   C                    ;IF ERROR TRYING TO SET GLOBAL CODEPAGE
;       MOV   CPMSGLST11FUN,OFFSET CPMSG11_SET ;PUT "SETTING" INTO MESSAGE
;       MOV   DX,OFFSET CPMSG11     ;PASS OFFSET TO MSG PARM LIST
;       CALL  SEND_MSG
;
;    $ELSE
;       MOV   CPMSGLST10FUN,OFFSET CPMSG10_GLOBAL ;SET MSG TO SAY "GLOBAL"
;       MOV   DX,OFFSET CPMSG10     ;PASS OFFSET TO MSG PARM LIST
;       CALL  QUEUE             ;"MODE GLOBAL CODEPAGE FUNCTION COMPLETED"
;
;    $ENDIF                     ;ERROR IN SETTING GLOBAL CODEPAGE?
; $ELSE                         ;SINCE NOT "SELECT" ASSUME IT IS "STATUS"
;    MOV   AX,GET_GLOBAL_CP
;    DOSCALL
;
;    $IF   C                    ;IF ERROR
;       MOV   CPMSGLST11FUN,OFFSET CPMSG11_GET ;PUT "GETTING" INTO MESSAGE
;       MOV   DX,OFFSET CPMSG11     ;PASS OFFSET TO MSG PARM LIST
;       CALL  SEND_MSG
;
;    $ELSE                      ;SINCE NO ERROR
;       PUSH  DX                ; DX=SYSTEM CODE PAGE
;       PUSH  BX                ; BX=ACTIVE CODE PAGE
;       MOV   DX,OFFSET CPMSG12     ;PASS OFFSET TO MSG PARM LIST
;       CALL  QUEUE             ;"CURRENT CODEPAGE SETTINGS:"
;
;       MOV   CPMSGLST13TYP,OFFSET CPMSG13_ACT ;PUT "ACTIVE" INTO MESSAGE
;       POP   CPMSGLST13CP      ;PASS ACTIVE CODEPAGE ID TO MSG PARM LIST (PUSHED FROM BX)
;       MOV   DX,OFFSET CPMSG13     ;PASS OFFSET TO MSG PARM LIST
;       CALL  QUEUE             ;"   XXX - ACTIVE CODEPAGE"
;
;       POP   CPMSGLST13CP      ;PASS SYSTEM CODE PAGE (PUSHED FROM DX)
;       MOV   CPMSGLST13TYP,OFFSET CPMSG13_SYS ;PUT "SYSTEM" INTO MESSAGE
;       MOV   DX,OFFSET CPMSG13     ;PASS OFFSET TO MSG PARM LIST
;       CALL  QUEUE             ;"   XXX - SYSTEM CODEPAGE"
;
;    $ENDIF                     ;ERROR IN GETTING GLOBAL CODEPAGE STATUS?
; $ENDIF                        ;"SELECT" OR "STATUS"?
;
; RET
;SET_GLOBAL_CODEPAGE ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 HEADER <SELECT FUNCTION HANDLING ROUTINE ACCORDING TO 'request_typ'>

FUNCTION_SELECT PROC NEAR

 MOV   AX,CP_CB.request_typ
 CMP   AX,PREPARE              ;("prepare" IS INTERNAL USAGE ONLY; "PREPARE" IS WHAT CUSTOMER SEES)
;$IF   E                       ;IF "prepare" IS REQUESTED FUNCTION
 JNE $$IF12
    CALL  DO_prepare           ;DEFINE FONTS TO DEVICE

;$ELSE                         ;SINCE NOT A "prepare"
 JMP SHORT $$EN12
$$IF12:
    CMP   AX,SELECT
;   $IF   E                    ;IF "SELECT" IS REQUESTED FUNCTION
    JNE $$IF14
       CALL  DO_SELECT

;   $ELSE                      ;SINCE NOT "SELECT" EITHER
    JMP SHORT $$EN14
$$IF14:
       CMP   AX,REFRESH
;      $IF   E                 ;IF "REFRESH IS REQUSTED FUNCTION
       JNE $$IF16
          CALL  DO_REFRESH

;      $ELSE                   ;SINCE NONE OF THE ABOVE
       JMP SHORT $$EN16
$$IF16:
          CALL  DO_STATUS

;      $ENDIF                  ;REFRESH?
$$EN16:
;   $ENDIF                     ;SELECT?
$$EN14:
;$ENDIF                        ;prepare?
$$EN12:

 RET
FUNCTION_SELECT ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 HEADER <'prepare' -  CODEPAGE FUNCTION>

DO_prepare PROC NEAR

PUBLIC DO_prepare

 MOV   BX,CP_CB.DES_PACK_PTR
 TEST  [BX].DES_STRT_PKFL,DES_STRT_FL_CART ;CARTRIDGE prepare?
;$IF   Z                       ;NO, LOOK FOR FONT FILE
 JNZ $$IF21
    MOV   AX,CS                ;USE PREDEFINED AREA
    MOV   BUF_SEG,AX           ;REMEMBER WHERE BUFFER IS
    lea   dx,dgroup:BUF        ;buf is at end of allocated memory
    mov   BUF_OFF,dx
;C05mov   ax,ds:[6]            ;get number bytes in this segment
;C05sub   ax,dx                ;get size of buf to segment end
;C05mov   cl,4                 ;shift count
;C05shr   ax,cl                ;convert buf size to para size
    mov   bx,1000H              ;use BX for MODIFY ALLOCATED MEMORY     ;C05
    mov   ah,4Ah                ;int 21h function for shrinking memory  ;C05
    int   21h                   ;do it                                  ;C05
;
; BX = gives the available size 
; remember that our stack is also in the same segment and at the very end!
; THIS IS A HACK: We know that since mode < 64K in size, our SS == CS
; and also that SP = TOP of available memory; So we just leave out 
; the current stack usage + 5 paragraphs and use the remaining memory
; for reading the code page font file.
; 
    mov   cl,4                  ;shift count                            ;C05
    shr   dx,cl                 ;Convert buf size to paragraphs         ;C05
    sub   bx,dx                 ;Free bytes after BUF to end of memory  ;C05
                                ;Still accessible from CS               ;C05
    mov	dx, -1			; end of memory
    sub   dx,sp			; amout of stack already used
    add	dx,50h			; just some magic no; some extra room for
				; stack
    shr  dx,cl			; convert to paras
    sub	 bx,dx			; bx = size of buffer we can safely use
    jle	 Outofmem
	
    MOV   BUF_SIZ,bx           ;SIZE IN PARAGRAPHS
;                      OPEN FILE FOR INPUT

    MOV   DX,CP_CB.FONT_FILESPEC ;DS:DX = POINTER TO ASCIIZ PATH NAME
    DOSCALL OPEN,FILE_OPEN_MODE ;OPEN CODEPAGE FILE IN READ ONLY MODE

;   $IF   NC                   ;IF OPEN OK,
    JC $$IF22
       MOV   FILE_HANDLE,AX    ;REMEMBER THE HANDLE TO THE FILE
       CALL  DES_START         ;PERFORM THE prepare START

;      $IF   NC                ;IF prepare START WAS OK
       JC $$IF23
          CALL  DEVICE_TO_BINARY ;SET DEVICE TO "BINARY MODE"

          CALL  MOVE_FILE      ;READ IN THE CODEPAGE FILE, SEND TO DEVICE

          CALL  DES_END        ;PERFORM prepare END FUNCTION

;      $ELSE                   ;SINCE prepare START HAD A PROBLEM
       JMP SHORT $$EN23
$$IF23:
          CALL  DES_START_ERROR ;DISPLAY MSG SAYING WHY DES_START FAILED

;      $ENDIF                  ;prepare START OK?
$$EN23:

;                      CLOSE A FILE HANDLE
       MOV   BX,FILE_HANDLE    ;BX = HANDLE RETURNED BY OPEN OR CREATE
       DOSCALL CLOSE

;   $ELSE                      ;SINCE FILE OPEN NOT OK
    JMP SHORT $$EN22
$$IF22:
       MOV   DX,OFFSET CPMSG1     ;PASS OFFSET TO MSG PARM LIST
       CALL  SEND_MSG          ; "FAILURE TO OPEN CODEPAGE FONT FILE"

;   $ENDIF                     ;FILE OPEN OK?
$$EN22:
;$ELSE                         ;SINCE NO FONT FILE SPEC INDICATED FOR CARTRIDGE,
 JMP SHORT $$EN21

Outofmem:
	mov	dx,offset msgOutOfMemory
	call	SEND_MSG
	jmp	short $$EN21


$$IF21:

    CALL  DES_START            ;PERFORM THE prepare START

;   $IF   C
    JNC $$IF29
       CALL  DES_START_ERROR   ;DISPLAY MSG SAYING WHY DES_START FAILED

;   $ELSE                      ;SINCE DES_START WAS OK,
    JMP SHORT $$EN29
$$IF29:
       CALL  DES_END           ;PERFORM prepare END FUNCTION

;   $ENDIF                     ;DES_START ON CARTRIDGE OK?
$$EN29:
;$ENDIF                        ;CARTRIDGE?
$$EN21:
 RET
DO_prepare ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
DES_START PROC NEAR

PUBLIC DES_START

 MOV   CX,DEV_TYPE             ;CX=xxx_DEV_TYPE * 256 + "prepare_STRT"
 MOV   DX,CP_CB.DES_PACK_PTR   ;DS:DX=DATA BUFFER "DES_STRT_PACKET"
 CALL  DO_GENERIC_IOCTL

 RET
DES_START ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
DES_START_ERROR PROC NEAR
;AFTER DES_START, CARRY WAS SET ON, INDICATING AN ERROR
;               prepare START ERROR CODES:
                               ;DS_ERR0 EQU 0     PREVIOUS prepare DELETED
                               ;DS_ERR8 EQU 8     CODE PAGE CONFLICT (USED FOR KEYB XX MISMATCH)
                               ;DS_ERRA EQU 0AH  DEVICE ERROR
                               ;DS_ERR16 EQU 016H UNKNOWN COMMAND

 CALL  EX_ERR                  ;GET EXTENDED ERROR
                               ;AX=EXTENDED ERROR
                               ;BH=ERROR CLASS
                               ;BL=SUGGESTED ACTION
                               ;CH=LOCUS
 CMP   AX,DS_ERRA+MAPERR       ;DEVICE ERROR?
;$IF   E
 JNE $$IF33
;AC001;    MOV   CPMSGLST17FUN,OFFSET CPMSG17_PREP ;MOVE "PREPARE" INTO MESSAGE
    set_submessage_ptr CPMSGxx_PREP,cpmsg17 ;MOVE "PREPARE" INTO MESSAGE ;AN002;
    MOV   DX,OFFSET CPMSG17     ;PASS OFFSET TO MSG PARM LIST
                               ;"DEVICE ERROR DURING PREPARE"

;$ELSE                         ;SINCE NOT ERROR CODE 0AH,
 JMP SHORT $$EN33
$$IF33:
    CMP   AX,DS_ERR0+MAPERR    ;PREVIOUS prepare DELETED?
;   $IF   E
    JNE $$IF35
       MOV   DX,OFFSET CPMSG5     ;PASS OFFSET TO MSG PARM LIST
                               ;"PREVIOUSLY PREPARED CODEPAGE DELETED"
;   $ELSE
    JMP SHORT $$EN35
$$IF35:
       CMP   AX,DS_ERR16       ;DOES THE DEVICE DRIVER SUPPORT DESIGNATE START FUNCTION?
;      $IF   E,OR
       JE $$LL37
       CMP   AX,DS_ERR1        ;16=unknown command, 1=Invalid function number
;      $IF   E
       JNE $$IF37
$$LL37:
          MOV   DX,OFFSET CPMSG15     ;PASS OFFSET TO MSG PARM LIST
                               ;"Codepage operation not supported on this device",BEEP,CR,LF,EOM

;      $ELSE                   ;SINCE NOT THAT EITHER, ASSUME MUST BE CODE 8
       JMP SHORT $$EN37
$$IF37:
          MOV   DX,OFFSET CPMSG19     ;PASS OFFSET TO MSG PARM LIST
                               ;"Current keyboard does not support this Codepage",BEEP,CR,LF,EOM
;      $ENDIF
$$EN37:

;   $ENDIF                     ;PREV prepare DELETED?
$$EN35:
;$ENDIF                        ;WHICH ERROR CODE?
$$EN33:
 CALL  SEND_MSG                ;DISPLAY INDICATED MESSAGE


 RET
DES_START_ERROR ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

MOVE_FILE PROC NEAR

;CODEPAGE FILE IS OPEN, THE prepare START IS COMPLETED OK...

dummy8:
public   dummy8


;$SEARCH                       ;REPEAT READS UNTIL FILE COMPLETELY READ
$$DO42:
;                      READ FROM A FILE OR DEVICE
    MOV   AX,BUF_SIZ           ;NUMBER OF PARAS TO READ
    MOV   CL,4
    SHL   AX,CL                ;CONVERT PARA COUNT TO BYTE COUNT
    MOV   CX,AX                ;PASS BYTE COUNT TO CX
    MOV   BX,FILE_HANDLE       ;BX = FILE HANDLE
    PUSH  DS
    LDS   DX,DBUF              ;DS:DX = BUFFER ADDRESS
    DOSCALL READ

    POP   DS                   ;RESTORE DATA ADDRESSABILITY
;$LEAVE C                      ;ERROR DURING READ?
 JC $$EN42
    MOV   BUF_BYTES,AX         ;REMEMBER HOW MANY BYTES READ
    CMP   AX,0                 ;WAS ANYTHING READ?
;$LEAVE E                      ;NOTHING READ, QUIT
 JE $$EN42
                               ;SOMETHING WAS READ, PROCESS THE BUFFER
    CALL  HOOK_IN_MY_INT24     ;DO MY OWN ERROR HANDLING

;                     WRITE TO A FILE OR DEVICE
    MOV   BX,DEV_HANDLE        ;BX = FILE HANDLE
    MOV   CX,BUF_BYTES         ;CX = NUMBER OF BYTES TO WRITE
    PUSH  DS
    LDS   DX,DBUF              ;DS:DX = ADDRESS OF DATA TO WRITE
    DOSCALL IOCTL,IOCTL_WRITE  ;WRITE THE DATA TO THE DEVICE

    POP   DS
    PUSHF                      ;SAVE FLAGS
    CALL  RESTORE_OLD_INT24    ;LET SYSTEM RESUME ERROR HANDLING

    POPF                       ;RESTORE FLAGS

;$EXITIF C                     ;QUIT IF A PROBLEM
 JNC $$IF42
                               ;prepare WRITE ERROR CODES:
                               ;DW_ERR8 EQU 8   DEVICE NOT FOUND IN FILE ,OR
                               ;                 CODE PAGE NOT FOUND IN FILE
                               ;DW_ERRA EQU 0AH DEVICE ERROR
                               ;DW_ERRC EQU 0CH  FILE CONTENTS NOT A FONT FILE,
                               ;                 OR FILE CONTENTS STRUCTURE DAMAGED
    CALL  EX_ERR               ;GET EXTENDED ERROR
                               ;AX=EXTENDED ERROR
                               ;BH=ERROR CLASS
                               ;BL=SUGGESTED ACTION
                               ;CH=LOCUS
    CMP   AX,FAIL24            ;DID ERROR COME FROM THE INT 24 HANDLER?
;   $IF   E
    JNE $$IF46
       MOV   AX,CRITERROR      ;REAL ERROR CAME FROM INT24
       ADD   AX,MAPERR
;   $ENDIF
$$IF46:
    CMP   AX,DW_ERR8+MAPERR    ;DEVICE NOT FOUND IN FILE ,OR
                               ; CODE PAGE NOT FOUND IN FILE
;   $IF   E
    JNE $$IF48
       MOV   DX,OFFSET CPMSG3     ;"Missing from font file is either device or codepage"
;   $ELSE                      ;SINCE NOT ERR 8
    JMP SHORT $$EN48
$$IF48:
       CMP   AX,DW_ERRA+MAPERR ;DEVICE ERROR

;      $IF   E
       JNE $$IF50
;AC001;   MOV   CPMSGLST17FUN,OFFSET CPMSG17_WRIT ;"write of font file to device",EOM
          set_submessage_ptr  CPMSG17_WRIT,cpmsg17  ;"write of font file to device",EOM;AN001;
          MOV   DX,OFFSET CPMSG17     ;"DEVICE ERROR DURING %S"
;      $ELSE                   ;SINCE NOT ERR A NEITHER, MUST BE
       JMP SHORT $$EN50
$$IF50:
                               ; FILE CONTENTS NOT A FONT FILE,
                               ; OR FILE CONTENTS STRUCTURE DAMAGED
          MOV   DX,OFFSET CPMSG4     ;"Font file contents invalid"
;      $ENDIF                  ;ERR "A"?
$$EN50:
;   $ENDIF                     ;ERR 8?
$$EN48:
    CALL  SEND_MSG             ;DISPLAY THE ERROR MSG POINTED TO BY DX

;$ORELSE                       ;SINCE WRITE TO DEVICE WAS OK,
 JMP SHORT $$SR42
$$IF42:
;$ENDLOOP                      ;GO BACK AND READ SOME MORE
 JMP SHORT $$DO42
$$EN42:
;   $IF   C                    ;IF READ ERROR
    JNC $$IF56
       MOV   DX,OFFSET CPMSG20     ;"ERROR DURING READ OF FONT FILE"
       CALL  SEND_MSG          ;DISPLAY THE ERROR MSG POINTED TO BY DX

;   $ENDIF                     ;READ ERROR?
$$IF56:
;$ENDSRCH
$$SR42:

 RET
MOVE_FILE ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

DES_END PROC NEAR

 MOV   CX,DEV_TYPE             ;PICK UP DEVICE TYPE AS MAJOR CODE
 MOV   CL,prepare_END          ;CX=xxx_DEV_TYPE * 256 + "prepare_END"
 MOV   DX,OFFSET PK            ;DS:DX=DATA BUFFER, PROBABLY NOT USED
                               ; THIS IS JUST A DUMMY BUFFER, NO DATA FOR IT
 CALL  DO_GENERIC_IOCTL

;$IF   C                       ;IF THERE WAS AN ERROR
 JNC $$IF59
;AC001;    MOV   CPMSGLST17FUN,OFFSET CPMSG17_PREP ;MOVE "PREPARE" INTO MESSAGE
    set_submessage_ptr  CPMSGxx_PREP,cpmsg17 ;MOVE "PREPARE" INTO MESSAGE
    MOV   DX,OFFSET CPMSG17     ;PASS OFFSET TO MSG PARM LIST
    CALL  SEND_MSG             ;"DEVICE ERROR DURING PREPARE"

;$ELSE                         ;SINCE NO ERROR DURING PREPARE END,
 JMP SHORT $$EN59
$$IF59:
    CMP   NOERROR,TRUE
;   $IF   E                    ;IF no previous errors THEN
    JNE $$IF61
       CMP   current_request,refresh_request
;      $IF   E
       JNE $$IF62
;AC001;   MOV   CPMSGLST10FUN,OFFSET CPMSG10_REFRESH   ;SET MSG TO SAY "REFRESH"
          set_submessage_ptr  CPMSGxx_REFRESH,cpmsg10   ;SET MSG TO SAY "REFRESH";AN001;
;      $ELSE
       JMP SHORT $$EN62
$$IF62:
;AC001;   MOV   CPMSGLST10FUN,OFFSET CPMSG10_DES ;SET MSG TO SAY "PREPARE"
          set_submessage_ptr  CPMSGxx_prep,cpmsg10 ;SET MSG TO SAY "PREPARE";AN001;
;      $ENDIF
$$EN62:
       MOV   DX,OFFSET CPMSG10     ;PASS OFFSET TO MSG PARM LIST
       CALL  printf             ;"MODE PREPARE CODEPAGE FUNCTION COMPLETED"
;   $ENDIF
$$IF61:

;$ENDIF                        ;ERROR DURING PREPARE END?
$$EN59:
 RET
DES_END ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

;        'SELECT' - FUNCTION HANDLER



DO_SELECT PROC NEAR

 CALL  setup_packet_for_DBCS   ;see if DBCS vectors needed, if so move them into the packet
 MOV   BX,CP_CB.DES_PACK_PTR   ;GET PACKET FROM INPUT PARMLIST
 MOV   AX,[BX].DES_STRT_PKCP1  ;GET CODEPAGE FROM HIS PACKET
 MOV   PK.PACKCPID,AX          ; INTO PACKET EXPECTED BY SELECT FUNCTION
 MOV   CX,DEV_TYPE             ;CX=xxx_DEV_TYPE * 256 + "MINOR CODE"
 MOV   CL,SELECT_CP            ;SET MINOR CODE TO "SELECT"
 MOV   DX,OFFSET PK            ;DS:DX=DATA BUFFER "PACKET"
 CALL  DO_GENERIC_IOCTL

dummy10:
public dummy10

;$IF   C                       ;IF SELECT WAS NOT OK
 JNC $$IF67

    CALL  EX_ERR               ;GET EXTENDED ERROR
                               ;AX=EXTENDED ERROR
                               ;BH=ERROR CLASS
                               ;BL=SUGGESTED ACTION
                               ;CH=LOCUS
    CMP   AX,IN_ERR7+MAPERR    ;CODE PAGE NOT PREPARED?
;   $IF   E
    JNE $$IF68
       MOV   DX,OFFSET CPMSG18     ;PASS OFFSET TO MSG PARM LIST
                               ;"SPECIFIED CODEPAGE NOT PREPARED"
;   $ELSE                      ;NOT ERR7, MUST BE SOMETHING ELSE
    JMP SHORT $$EN68
$$IF68:
       CMP   AX,IN_ERR8+MAPERR ;KEYBOARD SUPPORT THIS CODEPAGE?
;      $IF   E
       JNE $$IF70
          MOV   DX,OFFSET CPMSG19     ;"CURRENT KEYBOARD DOES NOT SUPPORT THIS CP"
;      $ELSE                   ;SINCE NOT ERR8 EITHER, MUST BE DEVICE ERROR
       JMP SHORT $$EN70
$$IF70:

;AC001;   MOV   CPMSGLST17FUN,OFFSET CPMSG17_ACT
          set_submessage_ptr  CPMSGxx_select,cpmsg17                       ;AN001;
          MOV   DX,OFFSET CPMSG17     ;"DEVICE ERROR DURING SELECT"
;      $ENDIF                  ;KEYB SUPPORT THIS CODEPAGE?
$$EN70:
;   $ENDIF                     ;CP NOT PREPARED?
$$EN68:
    CALL  SEND_MSG             ;DISPLAY INDICATED ERROR MESSAGE

;$ELSE                         ;SINCE SELECT WAS OK,
 JMP SHORT $$EN67
$$IF67:
    CMP   NOERROR,TRUE
;   $IF   E                    ;IF no previous errors THEN
    JNE $$IF75
;AC001;MOV   CPMSGLST10FUN,OFFSET CPMSG10_SELECT ;SET MSG TO SAY "SELECT"
       set_submessage_ptr  CPMSGxx_SELECT,cpmsg10 ;SET MSG TO SAY "SELECT"
       MOV   DX,OFFSET CPMSG10     ;PASS OFFSET TO MSG PARM LIST
       CALL  printf             ;"MODE SELECT CODEPAGE FUNCTION COMPLETED"
;   $ENDIF
$$IF75:

;$ENDIF                        ;SELECT OK?
$$EN67:

 RET
DO_SELECT ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;
;
; DO_REFRESH
; ----------
;
;  THIS EVENT WOULD BE REQUIRED IN CASE THE EXTERNAL DEVICE LOST ITS LOADABLE
;  FONT DESCRIPTIONS, AS PERHAPS IF THE PRINTER GOT TURNED OFF, FOR EXAMPLE.
;
;  The possible return codes for a REFRESH request will be returned only on a
; designate start and are defined as follows:
;
; 8008 - For DISPLAY.SYS this means that there is a keyboard/code page conflict.
;
; 800A - Device error.
;
; 800C - The device driver does not have a copy of the code page in memory.
;        This could be due to the DEVICE= command in CONFIG.SYS not setting up
;        the buffer, so all previous prepares were handled by downloading the
;        code page directly to the printer.
;
;


 HEADER <'REFRESH' - RELOAD EXISTING FONTS>


DO_REFRESH PROC NEAR


 MOV   current_request,refresh_request

 CALL  DES_START               ;PERFORM THE prepare START

;$IF   NC                      ;IF prepare START WAS OK
 JC $$IF78
    CALL  DEVICE_TO_BINARY     ;SET DEVICE TO "BINARY MODE"

;UNLIKE THE prepare FUNCTION, THERE IS NO FONT FILE TO BE SENT TO THE
;DEVICE DRIVER, WHO SHOULD STILL HAVE THE FONT DESCRIPTOR DATA TO BE
;RETRANSMITTED TO THE EXTERNAL DEVICE ITSELF.



    CALL  DES_END              ;PERFORM prepare END FUNCTION

;$ELSE                         ;SINCE prepare START HAD A PROBLEM
 JMP SHORT $$EN78
$$IF78:

;AFTER DES_START, CARRY WAS SET ON, INDICATING AN ERROR
;               prepare START ERROR CODES for REFRESH request:
;RS_ERR8             EQU  8     ;KEYBOARD/CODE PAGE CONFLICT
;RS_ERRA             EQU  0AH   ;DEVICE ERROR
;RS_ERRC             EQU  0CH   ;DEVICE DRIVER DOES NOT HAVE COPY OF CODE PAGE

    CALL  EX_ERR                  ;GET EXTENDED ERROR
                                  ;AX=EXTENDED ERROR
                                  ;BH=ERROR CLASS
                                  ;BL=SUGGESTED ACTION
                                  ;CH=LOCUS
    CMP   AX,DS_ERRA+MAPERR       ;DEVICE ERROR?
;   $IF   E
    JNE $$IF80
;AC001;MOV   CPMSGLST17FUN,OFFSET CPMSG17_REFRESH   ;MOVE "Refresh" INTO MESSAGE
       set_submessage_ptr  CPMSGxx_REFRESH,cpmsg17   ;MOVE "Refresh" INTO MESSAGE ;AN001;
       MOV   DX,OFFSET CPMSG17     ;PASS OFFSET TO MSG PARM LIST
                                  ;"Device error during REFRESH"

;   $ELSE                         ;SINCE NOT ERROR CODE 0AH,
    JMP SHORT $$EN80
$$IF80:
       CMP   AX,RS_ERRC+MAPERR
;      $IF   E                    ;IF driver unable to download because he has no buffer THEN
       JNE $$IF82
          MOV   DX,OFFSET CPMSG21     ;PASS OFFSET TO MSG PARM LIST
                                  ;"Unable to perform REFRESH"
;      $ELSE
       JMP SHORT $$EN82
$$IF82:
          CMP   AX,DS_ERR16       ;DOES THE DEVICE DRIVER SUPPORT DESIGNATE START FUNCTION?
;         $IF   E,OR
          JE $$LL84
          CMP   AX,DS_ERR1        ;16=unknown command, 1=Invalid function number
;         $IF   E
          JNE $$IF84
$$LL84:
             MOV   DX,OFFSET CPMSG15     ;PASS OFFSET TO MSG PARM LIST
                                  ;"Codepage operation not supported on this device",BEEP,CR,LF,EOM

;         $ELSE                   ;SINCE NOT THAT EITHER, ASSUME MUST BE CODE 8
          JMP SHORT $$EN84
$$IF84:
             MOV   DX,OFFSET CPMSG19     ;PASS OFFSET TO MSG PARM LIST
                                  ;"Current keyboard does not support this Codepage",BEEP,CR,LF,EOM
;         $ENDIF
$$EN84:

;      $ENDIF                     ;PREV prepare DELETED?
$$EN82:
;   $ENDIF                        ;WHICH ERROR CODE?
$$EN80:
    CALL  SEND_MSG                ;DISPLAY INDICATED MESSAGE

;$ENDIF                        ;prepare START OK?
$$EN78:

 RET
DO_REFRESH ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
DEVICE_TO_BINARY PROC NEAR

 MOV   DX,DEVICE_STATUS        ;GET BITS DEFINING DEVICE
 OR    DX,BINARY_DEV           ;TURN ON THE "BINARY" FLAG BIT
 XOR   DH,DH                   ;BE SURE DH IS CLEAR
 MOV   BX,DEV_HANDLE           ;PASS THE DEVICE HANDLE TO IOCTL
 DOSCALL IOCTL,IOCTL_FUN_SET_INFO ;SET DEVICE TO "BINARY"

 RET
DEVICE_TO_BINARY ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 HEADER <'STATUS' - QUERY FUNCTION HANDLER>

PUBLIC   do_status

DO_STATUS PROC NEAR

 CALL  setup_packet_for_DBCS
 MOV   CX,DEV_TYPE             ;CX=xxx_DEV_TYPE * 256 + "MINOR CODE"
 MOV   CL,QUERY_SELECTED       ;SET MINOR CODE TO "QUERY SELECT"
 MOV   DX,OFFSET PK            ;DS:DX=DATA BUFFER "PACKET"
 CALL  DO_GENERIC_IOCTL

;$IF   C
 JNC $$IF90
    CALL  QUERY_ERROR          ;DISPLAY CAUSE OF PROBLEM

;$ELSE                         ;SINCE NOT ERROR ON QUERY
 JMP SHORT $$EN90
$$IF90:
    MOV   AX,PK.PACKCPID       ;GET CODEPAGE ID FROM PACKET
    MOV   CPMSGLST6CP,AX       ;PASS CODEPAGE ID TO PRINTF
    MOV   AX,CP_CB.cp_device      ;GET POINTER TO DEVICE NAME
    MOV   CPMSGLST6DEV,AX      ;OFFSET TO DEVICE NAME MOVED TO MSG PARM LST
    MOV   DX,OFFSET CPMSG6     ;PASS OFFSET TO MSG PARM LIST
    CALL  printf                ;DISPLAY THE MESSAGE:
                               ; "CURRENTLY SELECTD CODEPAGE IS %D FOR DEVICE: %S",CR,LF,0

    CALL  QUERY_LISTER         ;DISPLAY LIST OF PREPPED CODEPAGES

;$ENDIF                        ;ERR FROM QUERY ACTIVE?
$$EN90:

 RET
DO_STATUS ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
QUERY_LISTER PROC NEAR

 MOV   CX,DEV_TYPE             ;CX=xxx_DEV_TYPE * 256 + "MINOR CODE"
 MOV   CL,QUERY_DES_LST        ;SET MINOR CODE TO "QUERY prepare LIST"
 MOV   DX,OFFSET RESPONSE_LIST ;DS:DX=DATA BUFFER
 CALL  DO_GENERIC_IOCTL

;$IF   C                       ;IF PROBLEM WITH QUERY LIST
 JNC $$IF93
    CALL  QUERY_ERROR          ;DISPLAY CAUSE OF PROBLEM

;$ELSE                         ;SINCE NO PROBLEM WITH QUERY LIST
 JMP SHORT $$EN93
$$IF93:
    MOV   SI,OFFSET RES_HWCP   ;START WITH THE LIST OF HARDWARE CODEPAGES
    MOV   CX,[SI]              ;GET NUMBER OF HARDWARE CODEPAGES IN LIST IN PACKET
    ADD   SI,WORD              ;START WITH THE FIRST CODEPAGE
;   $IF   NCXZ                 ;IF ANY HARDWARE CODEPAGES ARE PRESENT
    JCXZ $$IF95
;AC001;MOV   CPMSGLST8HD,OFFSET CPMSG8_HW ;GET OFFSET OF "HARDWARE" TO MSG PARM LIST
       PUSH CX                ;protect from SYSGETMSG ;AC001;
       PUSH SI                ;protect from SYSGETMSG ;AC001;
       set_submessage_ptr  CPMSG8_HW,cpmsg8 ;GET OFFSET OF "HARDWARE" TO MSG PARM LIST;AC001;
       POP  SI
       POP  CX
       CALL  DISPLAY_CPID

;   $ENDIF                     ;HARDWARE CODEPAGES PRESENT?
$$IF95:
    MOV   CX,[SI]              ;GET NUMBER OF prepare CODEPAGES IN LIST IN PACKET
    ADD   SI,WORD              ;LOOK AT NEXT CODEPAGE ENTRY IN LIST
;   $IF   NCXZ                 ;IF ANY prepare CODEPAGES ARE PRESENT
    JCXZ $$IF97
;AC001;MOV   CPMSGLST8HD,OFFSET CPMSG8_PR ;GET OFFSET OF "PREPARED" TO MSG PARM LIST
       PUSH  CX               ;protect from SYSGETMSG ;AC001;
       PUSH  SI               ;protect from SYSGETMSG ;AC001;
       set_submessage_ptr  CPMSG8_PR,cpmsg8 ;GET OFFSET OF "PREPARED" TO MSG PARM LIST ;AC001;
       POP   SI
       POP   CX
       CALL  DISPLAY_CPID

;   $ENDIF                     ;PREPARED CODEPAGES PRESENT?
$$IF97:
    CMP   PREPED,0             ;CHECK COUNT OF PREPED CODEPAGES
;   $IF   Z                    ;IF NONE,
    JNZ $$IF99
       MOV   AX,CP_CB.cp_device   ;GET POINTER TO DEVICE NAME
       MOV   CPMSGLST7DEV,AX   ;OFFSET TO DEVICE NAME MOVED TO MSG PARM LST
       MOV   DX,OFFSET CPMSG7     ;PASS OFFSET TO MSG PARM LIST
       CALL  printf             ;DISPLAY THE MESSAGE:
                               ; "NO CODEPAGES PREPARED FOR DEVICE: %S",CR,LF,0
;   $ENDIF                     ;PREPED PAGES?
$$IF99:
;$ENDIF                        ;ERR FROM QUERY LIST?
$$EN93:
 CMP   NOERROR,TRUE
;$IF   E                       ;IF no previous errors THEN
 JNE $$IF102
;AC001;    MOV   CPMSGLST10FUN,OFFSET CPMSG10_QUERY ;SET MSG TO SAY "QUERY"
    set_submessage_ptr  cpmSGxx_QUERY,cpmsg10       ;SET MSG TO SAY "QUERY" ;AN001;
    MOV   DX,OFFSET CPMSG10     ;PASS OFFSET TO MSG PARM LIST
    CALL  printf                ;"MODE QUERRY CODEPAGE FUNCTION COMPLETED"
;$ENDIF
$$IF102:

 RET
QUERY_LISTER ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


QUERY_ERROR PROC NEAR


;CARRY WAS SET AFTER "QUERY SELECT" OR "QUERY LIST".

 CALL  EX_ERR                  ;GET EXTENDED ERROR
                               ;AX=EXTENDED ERROR
                               ;BH=ERROR CLASS
                               ;BL=SUGGESTED ACTION
                               ;CH=LOCUS
 CMP    AX,QS_ERR7+MAPERR      ;CODE PAGE NOT SELECTD?

 .IF <AX EQ <QS_ERR7+MAPERR>> THEN  ;CODE PAGE NOT SELECTD?     ;AC665;
    MOV   DX,OFFSET CPMSG16     ;PASS OFFSET TO MSG PARM LIST
                               ;"NO CODEPAGE HAS BEEN SELECTED"
    CALL  SEND_MSG             ;DISPLAY INDICATED ERROR MESSAGE

    MOV   NOERROR,TRUE         ;FORGET THE ABOVE WAS FLAGGED AS "ERROR"
    CALL  QUERY_LISTER         ;LIST PREPPED CODEPAGES ANYWAY

 .ELSEIF <AX EQ DS_ERR16> OR   ;016H UNKNOWN COMMAND, i.e. device driver not loaded ;AN665;
 .IF <AX EQ DS_ERR1> THEN      ;;AN665;16=unknown command, 1=Invalid function number
    MOV   DX,OFFSET CPMSG15    ;AN665;PASS OFFSET TO MSG PARM LIST, "Codepage operation not supported on this device"
    CALL  SEND_MSG              ;DISPLAY INDICATED ERROR MESSAGE

 .ELSE                         ;NOT ERR7 or 16, MUST BE DEVICE ERROR ;AC665;
;AC002;    MOV   CPMSGLST17FUN,OFFSET CPMSG17_QUERY
    set_submessage_ptr  CPMSGxx_QUERY,cpmsg17
    MOV   DX,OFFSET CPMSG17     ;"DEVICE ERROR DURING QUERY"

 .ENDIF                        ;CP NOT PREPARED?

 RET
QUERY_ERROR ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
DISPLAY_CPID PROC NEAR
;INPUT: SI=OFFSET TO CODEPAGE ID WORD IN LIST

 MOV   DX,OFFSET CPMSG8        ;PASS OFFSET TO MSG PARM LIST
 CALL  printf                   ;DISPLAY THE MESSAGE:
                               ; "%s CODEPAGES:"
 CLD                           ;REQUEST INCREMENT IF INDEX
;$DO
$$DO104:
    LODSW                      ;GET CODEPAGE ID FROM PACKET
                               ;SI NOW POINTS TO NEXT WORD IN CODEPAGE LIST
    CMP   AL,EMPTY
;   $IF   E
    JNE $$IF105
       MOV   DX,OFFSET CPMSG14     ;PASS OFFSET TO MSG PARM LIST
                               ; "  Codepage unprepared",CR,LF,0
;   $ELSE                      ;SINCE NOT EMPTY,
    JMP SHORT $$EN105
$$IF105:
       INC   PREPED            ;COUNT PREPED CODEPAGES
       MOV   CPMSGLST9CP,AX    ;PASS CODEPAGE ID TO PRINTF
       MOV   DX,OFFSET CPMSG9     ;PASS OFFSET TO MSG PARM LIST
                               ; "  Codepage %d",CR,LF,0
;   $ENDIF                     ;EMPTY?
$$EN105:
    CALL  printf                ;DISPLAY THE MESSAGE

;$ENDDO LOOP
 LOOP $$DO104

 RET
DISPLAY_CPID ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 HEADER <SUBROUTINES TO HANDLE MESSAGES TO STDOUT OR STDERR>
SEND_MSG PROC NEAR             ;USED TO SEND "ERROR" MESSAGES ONLY
                               ;FOR NON-ERROR MESSAGES, CALL printf DIRECTLY.
;INPUT: DX=OFFSET TO PRINTF MESSAGE PARM LIST

 MOV   NOERROR,FALSE           ;SET ERROR TO ERRORLEVEL
 CALL  printf

 RET
SEND_MSG ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
EX_ERR PROC NEAR
;THE DOSCALL RESPONDED WITH CARRY, SO GET EXTENDED ERROR
 MOV   BX,WORD PTR MINOR_VERSION ;BX = 30 VERSION NUMBER (FOR 3.30)
 DOSCALL EXTERROR              ;EXTENDED ERROR
                               ;OUTPUT:
                               ;AX=EXTENDED ERROR
                               ;BH=ERROR CLASS
                               ;BL=SUGGESTED ACTION
                               ;CH=LOCUS
 RET
EX_ERR ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
DO_GENERIC_IOCTL PROC NEAR

PUBLIC DO_GENERIC_IOCTL

;INPUT CX=xxx_DEV_TYPE * 256 + "MINOR CODE"
;      DS:DX=DATA BUFFER

 MOV   BX,DEV_HANDLE           ;BX=HANDLE
 MOV   AX,GENERIC_IOCTL        ;AX="GENERIC_IOCTL"
 DOSCALL                       ;SELECT DEVICE WITH GENERIC_IOCTL

 RET
DO_GENERIC_IOCTL ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 HEADER <INT 24H - CRITICAL ERROR HANDLER, AND SUBROUTINES>
HANDLER24 PROC NEAR            ;CRITICAL ERROR HANDLER FOR INT 24H
;WHEN THE CRITICAL ERROR OCCURS, CONTROL IS TRANSFERRED TO INTERRUPT 24H.
;BP:SI POINTS TO THE DEVICE HEADER CONTROL BLOCK.

;ERROR CODE IS IN THE LOWER HALF OF THE DI REG WITH UPPER HALF UNDEFINED.
;ERROR CODES ARE DEFINED IN THE "MODECPEQ.INC" MODULE.

 MOV   CRITERROR,DI            ;SAVE THE ABOVE ERROR CODE

;AT EXIT, WHEN THE IRET IS EXECUTED, DOS RESPONDS ACCORDING TO (AL)

 MOV   AL,CRERR_FAIL           ;REQUEST THE "FAIL" OPTION

 IRET                          ;RETURN FROM INTERRUPT
HANDLER24 ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
SAVE_VECTOR24 PROC NEAR
;GET THE ORIGINAL CONTENTS OF THE CRITICAL ERROR HANDLER VECTOR, 24H
; AND SAVE THEM IN THE DWORD AT "OLDINT24"

 PUSH  ES                      ;SAVE BASE SEGREG
 DOSCALL GET_VECTOR,INT24      ;GET ORIGINAL OWNER OF INT 24H VECTOR

 MOV   WORD PTR OLDINT24,BX    ;OUTPUT: ES:BX = CONTENTS OF VECTOR
 MOV   WORD PTR OLDINT24+WORD,ES
 POP   ES                      ;RESTORE BASE SEGREG

 RET
SAVE_VECTOR24 ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
RESTORE_OLD_INT24 PROC NEAR
;TAKE THE CONTENTS OF THE ORIGINAL INT24 VECTOR, SAVED IN "OLDINT24"
; AND RESTORE THE INT24 ENTRY IN VECTOR BACK TO ITS ORIGINAL CONTENTS.

 PUSH  DS                      ;SAVE MY DATA SEGREG
 LDS   DX,OLDINT24             ;DS:DX = VECTOR TO INT HANDLER
 DOSCALL SET_VECTOR,INT24      ;RESTORE OLD POINTER INTO INT24 VECTOR

 POP   DS                      ;RESTORE MY DATA SEGREG

 RET
RESTORE_OLD_INT24 ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
HOOK_IN_MY_INT24 PROC NEAR
;SET THE CRITICAL ERROR INTERRUPT HANDLER IN
;  VECTOR TABLE TO POINT TO "HANDLER24"

 MOV   DX,OFFSET HANDLER24     ;DS:DX = VECTOR TO INT HANDLER
 DOSCALL SET_VECTOR,INT24      ;SET INT24 VECTOR TO POINT TO NEW HANDLER

 RET
HOOK_IN_MY_INT24 ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;                                           ;AN000;
;
;
;  SETUP_PACKET_FOR_DBCS
;  ---------------------
;
;  Determine if need to include codepage information in the Invoke or Query
;  packet.
;
;
;
;  INPUT: Global access to "pk", the Invoke or Query packet.
;
;
;  RETURN: If needed, the DBCS vetcors are added to the packet and the packet
;          size is incremented.
;
;  MESSAGES: none
;
;  REGISTER
;  USAGE:
;
;
;  SIDE EFFECT:
;
;
;  PSEUDO CODE:
;
;  set up for and call INT 21 function 6507
;  IF the length field of the DBCS table is non-zero THEN
;     add the length of the table to the length field of the packet
;  ENDIF
;
;
;  DATA STRUCTURES: PK - the vectors are moved into this structure beginning
;                   at PACKVECTOR1.  The count of the vectors is added to
;                   PACKLEN.
;
;                   DBCS_header - The return from function 6507.
;
;                   DBCS_table - the table of vectors pointed to by
;                                DBCS_header.table_ptr.
;
;
;  ASSUMPTIONS: No more than 12 (0CH) are in the DBCS table.
;
;               The double word pointer returned by function 6507
;               (DBCS_header.table_ptr) always points to the DBCS table.
;
;               The first byte of the table (DBCS_table.table_len) is zero if
;               DBCS support is not necessary.
;                                                                                                                         ;AN000;
;               ES=DS.                                                                                                    ;AN000;
;                                                                                                                         ;AN000;
;                                           ;AN000;

setup_packet_for_DBCS   PROC  NEAR

PUBLIC setup_packet_for_DBCS

PUSH  DS                                  ;DS is used to address the DBCS vector table which is somewhere in IBMDOS

;set up for and call INT 21 function 6507
MOV   AX,6507H                            ;get ext country info, DBCS info
MOV   BX,-1                               ;use codepage currently active for CON
MOV   DX,-1                               ;use default contry ID
MOV   CX,TYPE DBCS_head                   ;length of data to be returned
MOV   DI,OFFSET DBCS_headr                ;DI=>buffer to fill with info ID and pointer to table
INT   21H

LDS   SI,DBCS_header.table_ptr            ;DS:SI=>DBCS table,"DBCS_table" EQU DS:[SI]
.IF <DBCS_table.table_len NE 0> THEN      ;IF there are some vectors THEN
   MOV   CX,DBCS_table.table_len          ;set length of the list of vectors
   ADD   CS:pk.packlen,CX
   ADD   SI,vector1                       ;DS:SI=>first DBCS vector
   MOV   DI,OFFSET pk                     ;ES:DI=>the query or invoke packet
   ADD   DI,packvector1                   ;ES:DI=>holder for first DBCS vector in the query/invoke packet
   REP   MOVSB                            ;mov all the vectors and the two bytes of zeros into the packet
.ENDIF

POP   DS                                  ;restore to address stuff in MODE's segment

RET

setup_packet_for_DBCS   ENDP


PRINTF_CODE ENDS               ;END OF MODECP.SAL MODULE
END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modeleng.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  MKS  C00  General cleanup.  Making short jumps out of long 
;                      jumps, ridding of nops.
;
;******************************************************************************
PAGE ,132 ;
TITLE MODELENG.ASM - VARIOUS SERVICE ROUTINES

;This module contains procedures:
;MODELENG - convert 3 digit or less ASCII string to binary number
;GET_MACHINE_TYPE - determine the machine type based on model byte and sub model byte

.XLIST
   INCLUDE STRUC.INC
.LIST
;.SALL

;  P R O L O G  ͻ
;                                                                                        

;  AX001 - P4031: Was allowing rate and delay settings on ATs that did not have
;                 the functionality in the BIOS.  Have to check specifically for
;                 a date of 11/15/85 or later.

;  AX002 - P4543: Add VAIL and SNOWMASS to legal choices for 19200 baud

;                                                                                        
;  P R O L O G  ͼ



;  P U B L I C S  ͻ
;                                                                                        

PUBLIC   get_machine_type
PUBLIC   MODELENG

;                                                                                        
;  P U B L I C S  ͼ

;  M A C R O S  ͻ
;                                                                                        

BREAK MACRO destination          ;AN001;

;C00 JMP   ENDCASE_&destination       ;AN001;
JMP  SHORT ENDCASE_&destination       ;AN001;                           ;C00

ENDM                             ;AN001;

;                                                                                        
;  M A C R O S  ͼ


; E Q U A T E S ͻ
;                                                                                        

AT_or_XT286_or_PS2_50_or_PS2_60  EQU   0FCH  ;AN000;primary model byte for all 286 based machines
BIOS_date                        EQU   ES:[DI]     ;used for accessing parts of the BIOS date ;AN001;
INTCONV                          EQU   48          ;CONVERT ASCII TO NUMERIC
model_byte_AH                    EQU   AH
return_system_configuration      EQU   0C0H        ;INT 15H subfunction
system_descriptor_table          EQU   ES:[BX]
system_services                  EQU   15H         ;ROM BIOS call
XT2                              EQU   0FBH  ;AN000;model byte for 2nd release of XT

INCLUDE  modequat.inc

;                                                                                        
;  E Q U A T E S  ͼ


;  S T R U C T U R E S  ͻ
;                                                                                        

BIOS_date_struc   STRUC                ;in form mm/dd/yy  ;AN001;
   month    DW    ?                                       ;AN001;
   slash1   DB    ?                                     ;AN001;
   day      DW    ?                                     ;AN001;
   slash2   DB    ?                                     ;AN001;
   year     DW    ?                                     ;AN001;
BIOS_date_struc   ENDS                                  ;AN001;


system_descriptor    STRUC
   length_of_descriptor    DW    bogus                  ;number of bytes in the descriptor table
   primary_model_byte      DB    bogus
   secondary_model_byte    DB    bogus
system_descriptor    ENDS

;                                                                                        
;  S T R U C T U R E S  ͼ


ROM     SEGMENT AT 0F000H

ORG   0FFF5H                                 ;location of date ROM BIOS for the release was written ;AN001;
date_location  LABEL WORD                    ;AN001;

ORG   0FFFEH
model_byte      LABEL   BYTE

ROM     ENDS



PRINTF_CODE   SEGMENT PUBLIC
         ASSUME CS:PRINTF_CODE,DS:PRINTF_CODE



;  D A T A  ͻ
;                                                                                        

HUNDRED  DB    100
TEN      DB    10


;                                                                                        
;  D A T A  ͼ


;  E X T R N S  ͻ
;                                                                                        

EXTRN    machine_type:BYTE             ;see 'rescode.sal'
EXTRN    submodel_byte:BYTE            ;see 'rescode.sal'

;                                                                                        
;  E X T R N S  ͼ


MODELENG PROC    NEAR
;
;INPUT:BP HAS ADDR OF PARM FIELD IN DATA SPACE (DS:)
;
    MOV    BL,0                   ;INIT BL TO 0
;   IF THIS PARAMETER IS A THREE DIGIT NUMBER,
    CMP    BYTE PTR DS:[BP]+2,0 ;LOOK AT THIRD DIGIT
    JE     ENDIF01
    CMP    BYTE PTR DS:[BP]+2,20H               ;see if third char is a blank
    JE     ENDIF01              ;IF there is a third digit THEN
;
      MOV    AL,DS:[BP]     ;GET FIRST DIGIT
      SUB    AL,INTCONV     ;CONVERT TO INT
      MUL    HUNDRED        ;HUNDREDTHS PLACE
      ADD    BL,AL          ;ADD TO BL
      INC    BP             ;BUMP TO NEXT DIGIT
    ENDIF01:    ;ENDIF THIS PARAMETER IS A THREE DIGIT NUMBER
    MOV    AL,DS:[BP]       ;GET NEXT DIGIT
    SUB    AL,INTCONV       ;CONVERT TO INT
       JNC    ENDIF02
       MOV     BL,0FFH    ;encountered an error so put a bogus number in the sum
    ENDIF02:
    MUL    TEN              ;TENS PLACE
    ADD    BL,AL            ;ADD TO BL
    INC    BP               ;GO TO NEXT DIGIT
    MOV    AL,DS:[BP]       ;GET NEXT DIGIT
    SUB    AL,INTCONV       ;CONVERT TO INT
    ADD    BL,AL            ;ADD TO BL
    RET
MODELENG ENDP


ascii_to_int   PROC  NEAR  ;input: AX=2 digit ascii number ;AN001;
                           ;output: BL has binary value            ;AN001;
                           ;assume: no overflow or underflow       ;AN001;

    PUSH   AX               ;the MUL destroys AH                   ;AN001;
    SUB    AL,INTCONV       ;CONVERT high order digit to binary    ;AN001;
    MUL    TEN              ;TENS PLACE                            ;AN001;
    MOV    BL,AL            ;ADD TO BL                             ;AN001;
    POP    AX                                                      ;AN001;
    MOV    AL,AH            ;AL=low order digit                    ;AN001;
    SUB    AL,INTCONV       ;CONVERT TO binary                     ;AN001;
    ADD    BL,AL            ;ADD TO BL                             ;AN001;
    RET                                                            ;AN001;

ascii_to_int   ENDP                                                ;AN001;


;------------------------------------------------------------------------------

;
;
; GET_MACHINE_TYPE
; ----------------
;
;  Get the machine type and store for future reference.
;
;
;  INPUT: none
;
;
;  RETURN: A scalar value indicating the type of machine is stored in
;          'machine_type'.
;
;
;  MESSAGES: none
;
;
;
;  REGISTER
;  USAGE AND
;  COMVENTIONS: AX - general usage
;               BX - used to address the system descriptor table
;
;
;
;
;
;  ASSUMPTIONS: DS has segment of MODE's data area
;
;
;  SIDE EFFECT: ES is changed.
;
;
;


get_machine_type  PROC    NEAR



PUSH  ES
PUSH  BX                               ;will be used to point to 'system descriptor table'
MOV   AH,return_system_configuration
INT   15H
.IF   NC             ;IF the call was handled successfully
   MOV   AH,system_descriptor_table.secondary_model_byte
   MOV   submodel_byte,AH                               ;save submodel byte
   MOV   AH,system_descriptor_table.primary_model_byte
.ELSE
   MOV   AX,ROM                 ;get addressability to the model byte
   MOV   ES,AX
   MOV   AH,ES:model_byte
.ENDIF

.IF <model_byte_AH EQ AT_or_XT286_or_PS2_50_or_PS2_60> THEN    ;AN000;may have a submodel byte, check it

   .IF <submodel_byte EQ PS2Model60> THEN       ;AN000;
      MOV   AH,PS2Model60                       ;AN000;
   .ELSEIF <submodel_byte EQ VAIL> OR           ;AN000;
   .IF <submodel_byte EQ PS2Model50> THEN       ;AN000;
      MOV   AH,PS2Model50                       ;AN000;
   .ELSEIF <submodel_byte EQ XT286> THEN        ;AN000;
      MOV   AH,XT286                            ;AN000;
   .ELSEIF <submodel_byte EQ AT3> THEN          ;AN000;
      MOV   DI,OFFSET date_location                    ;ES:DI=>BIOS date (BIOS_date EQU ES:[DI])               ;AN001;

;     CASE BIOS_date=                                                                                   ;AN001;

;        later than 1985:                                                                               ;AN001;

               MOV   AX,BIOS_date.year                   ;AX=ASCII form of BIOS date year              ;AN001;
               CALL  ascii_to_int                        ;BL=binary form of BIOS date year              ;AN001;
               .IF <BL GT 85> THEN                       ;IF AT built in 86 or later              ;AN001;

            MOV   AH,AT4                                                                                ;AN001;
            BREAK 0                                                                                     ;AN001;

               .ENDIF                                                                                   ;AN001;

;        1985, on 11/15:               ;BL already has year from above check                            ;AN001;

               .IF <BL EQ 85> AND                                                                       ;AN001;
               .IF <BIOS_date.month EQ "11"> AND                                                        ;AN001;
               .IF <BIOS_date.day EQ "51"> THEN       ;"51" is the word form of "15"                    ;AN001;

            MOV   AH,AT4                                                                                ;AN001;
            BREAK 0                                                                                     ;AN001;

               .ENDIF                                                                                   ;AN001;

;        otherwise:                    ;internal release of third version of AT                                        ;AN001;

            MOV   AH,AT3                                                                                ;AN001;


       ENDCASE_0:                                                                                       ;AN001;

   .ELSEIF <submodel_byte EQ AT2> THEN          ;AN000;
      MOV   AH,AT2                              ;AN000;
   .ENDIF                                       ;AN000;IF none of the above AH has correct value for AT1 (FC)
.ELSEIF <model_byte_AH EQ XT2> THEN             ;AN000;
   MOV   AH,PCXT                                ;AN000;no difference from XT1
.ENDIF                                          ;AN000;

MOV   DS:machine_type,AH         ;AH was set as result of getting the system configuration or during the IF.
POP   BX
POP   ES

RET                     ;RETURN TO MODE MAIN ROUTINE
get_machine_type  ENDP
PRINTF_CODE   ENDS
    END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modecpro.inc ===
; MODECPRO.INC - INCLUDED BY MODECP.SAL  

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: MODECP

; DESCRIPTIVE NAME: MODE, CODEPAGE HANDLER

;FUNCTION: Manages the codepage file, sending it to the
;	   device when a DESIGNATE is requested, telling
;	   the device which FONT to select when ACTIVATE
;	   is requested, and displaying the font status
;	   of the device when QUERY is requested.

; NOTES:
;	 This module should be processed with the SALUT pre-processor
;	 with re-allignment not requested, as:

;		SALUT MODECP,NUL,;


; ENTRY POINT: MODECP
;    LINKAGE: CALL MODECP

; INPUT: As defined by the "CODEPAGE_PARMS" STRUC.
;	All four segregs are expected to point to the one common
;	segment, called PRINTF_CODE.

; EXIT-NORMAL:	ERRORLEVEL 0 - Successful completion

; EXIT-ERROR: ERRORLEVEL 1 - An error message is also displayed

; EFFECTS:

; INTERNAL REFERENCES:
;    ROUTINES:
;	MODECP - HANDLES ALL PROCESSING FOR THE CODEPAGE SUPPORT IN MODE
;	SET_DEV_TYPE - SCANS LIST OF DEVICES FOR SPECIFIED DEVICE
;	SET_GLOBAL_CODEPAGE - DEVICE IS "*", INVOKE OR QUERY GLOBAL CODEPAGE
;	FUNCTION_SELECT - DETERMINES FUNCTION TO BE PERFORMED, DESIGNATE,QUERY,INVOKE
;	DO_DESIGNATE - PERFORMS START DESIGNATE, DOWNLOAD FONT FILE, DESIGNATE END
;	DES_START - HANDLES DETAILS OF START DESIGNATE FUNCTION
;	DES_START_ERROR - DIAGNOSES ERRORS FROM DESIGNATE START
;	MOVE_FILE - HANDLES DETAILS OF DOWNLOADING THE FONT FILE TO DEVICE
;	DES_END - HANDLES DETAILS OF DESIGNATE END FUNCTION
;	DO_INVOKE - HANDLES DETAILS OF INVOKE FUNCTION
;	DO_STATUS - INTERROGATES DEVICE FOR CODEPAGE STATUS
;	QUERY_ERROR - DISGNOSES ERRORS FROM QUERY REQUEST
;	DISPLAY_CPID - DISPLAYS THE CODEPAGE ID AS PART OF STATUS REPORT
;	SEND_MSG - SET UP ALL ERROR MESSAGES TO BE DISPLAYED
;	QUEUE - HANDLES INTERFACE TO "PRINTF" FOR ALL MESSAGES
;	EX_ERR - DOSCALL RESULTED IN CARRY, SO GO FIND OUT THE EXTENDED ERROR
;	DO_GENERIC_IOCTL - PROCESS ALL GENERIC IOCTL CALLS TO THE DEVICE
;

;    DATA AREAS:
;	WORKAREA - Temporary storage

; EXTERNAL REFERENCES:
;    ROUTINES:
;	PRINTF - Uses the MSG parm lists to construct the messages
;		 on STDOUT, on on STDERR.

;    DATA AREAS: A large buffer is allocated from free memory, if available.

; COPYRIGHT: The copyright notice is found in the OBJ code generated from
;	     the "MAIN.ASM" module of the MODE component of the DOS utility.

;****************** END OF SPECIFICATIONS *****************************
	IF1
	    %OUT INCLUDE MODECPRO.INC ;MODULE PROLOGUE
	ENDIF

;  P R O L O G  ͻ
;											  

;  AX001 - P3976: Need to have all pieces of messages in MODE.SKL so have to
;		  implement the SYSGETMSG method of getting addressability to
;		  the pieces.  This means that the code does a SYSGETMSG call
;		  which returns a pointer (DS:SI) to the message piece.  The
;		  address is then put in the sublist block for the message
;		  being issued.

;  AX002 - P4576  Segments were being trashed before calling message services
;		  because device type was wrong on IOCTL call because ES was
;		  zero when using CMPSB in SET_DEV_TYPE and no match was made.

;											  
;  P R O L O G  ͼ
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modemes.asm ===
PAGE	,132	;
	  TITLE MODEMES - MESSAGES DISPLAYED ON CONSOLE BY MODE
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;  P R O L O G  ͻ
;											  

;  AC001 - P3976: Need to have all pieces of messages in MODE.SKL so have to
;		  implement the SYSGETMSG method of getting addressability to
;		  the pieces.  This means that the code does a SYSGETMSG call
;		  which returns a pointer (DS:SI) to the message piece.  The
;		  address is then put in the sublist block for the message
;		  being issued.

;											  
;  P R O L O G  ͼ

PRINTF_CODE SEGMENT PUBLIC
	  ASSUME CS:PRINTF_CODE,DS:PRINTF_CODE
;
CR	  EQU	13	;CARRIAGE RETURN
LF	  EQU	10	;LINE FEED
BEEP	  EQU	7	;AUDIBLE TONE
EOM	  EQU	0	;NULL TERMINATOR, REQUIRED BY PRINTF

IF1
   %OUT including  MODESUBS.INC
   %OUT including  MODEDEFS.INC
ENDIF
INCLUDE  MODESUBS.INC
INCLUDE  MODEDEFS.INC

;
PUBLIC	 first_sublist
PUBLIC	 number_of_sublists

 PUBLIC    MOVED_MSG, ERR1, ERR2, PT80, PT80N, PT132, PT132N
 PUBLIC    PTLINES, RATEMSG, INITMSG, REDIRMSG, SHIFT_MSG, sublist_shift_msg
 PUBLIC    NOTREMSG, RETPARTO, sublist_retparto, CANT_SHIFT, sublist_cant_shift
 PUBLIC    NUMBERS, ;AC001;INF_OR_NO_ptr
 PUBLIC    Invalid_number_of_parameters, COM1_or_COM2, net_error
 PUBLIC    Invalid_parameter, not_supported, offending_parameter
 PUBLIC  offending_parameter_ptr
 PUBLIC    INITMSG, device,pbaud,pparity,pdata,pstop,pparm,pbaud,baud_19200
 PUBLIC  pstop_ptr
 PUBLIC  pparity_ptr
	       PUBLIC CPMSG1
		PUBLIC CPMSG2,CPMSGLST2DEV
		PUBLIC CPMSG3
		PUBLIC CPMSG4
		PUBLIC CPMSG5
		PUBLIC CPMSG6,CPMSGLST6CP,CPMSGLST6DEV
		PUBLIC CPMSG7,CPMSGLST7DEV
;AC001; 	PUBLIC CPMSGLST8HD
		PUBLIC sublist_cpmsg8
		PUBLIC CPMSG8
		PUBLIC CPMSG8_HW
;AC001; 	PUBLIC CPMSG8_PR
		PUBLIC CPMSG9,CPMSGLST9CP
		PUBLIC CPMSG10
		PUBLIC sublist_cpmsg10
;AC001; 	PUBLIC CPMSGLST10FUN
;AC001; 	PUBLIC CPMSG10_QUERY
;AC001; 	PUBLIC CPMSG10_DES
;AC001; 	PUBLIC CPMSG10_REFRESH
;AC001; 	PUBLIC CPMSG10_SELECT
;AC001; 	PUBLIC CPMSG10_GLOBAL
		PUBLIC CPMSG12
		PUBLIC CPMSG13
		PUBLIC CPMSGLST13CP
		PUBLIC CPMSGLST13TYP
;AC001; 	PUBLIC CPMSG13_ACT
;AC001; 	PUBLIC CPMSG13_SYS
		PUBLIC CPMSG14
		PUBLIC CPMSG15
		PUBLIC CPMSG16
		PUBLIC CPMSG17
		PUBLIC sublist_CPMSG17
;AC001; 	PUBLIC CPMSGLST17FUN
;AC001; 	PUBLIC CPMSG17_QUERY
;AC001; 	PUBLIC CPMSG17_PREP
;AC001; 	PUBLIC CPMSG17_REFRESH
;AC001; 	PUBLIC CPMSG17_ACT
;AC001; 	PUBLIC CPMSG17_WRIT
		PUBLIC CPMSG18
		PUBLIC CPMSG19
		PUBLIC CPMSG20
		PUBLIC CPMSG21
		PUBLIC dev_name_size	     ;used by invoke for msg srv
		PUBLIC stat_dev_ptr	     ;used by invoke for msg srv
		PUBLIC long_underline	     ;used by invoke for msg srv
		PUBLIC five_char_underline	  ;used by invoke for msg srv
		PUBLIC four_char_underline	  ;used by invoke for msg srv
		PUBLIC row_ptr
		PUBLIC status_for_device
		PUBLIC notredpt
;AC001; 	PUBLIC noretry
;AC001; 	PUBLIC LEFT
;AC001; 	PUBLIC RIGHT
		PUBLIC row_type
		PUBLIC lines_equal_msg		;used by analyze_and_invoke, "LINES=%1" definition
		PUBLIC	redcom
;AC001; 	PUBLIC	rightmost
;AC001; 	PUBLIC	leftmost
;AC001; 	PUBLIC	infinite
		PUBLIC	REDPT
		PUBLIC	PBAUD_PTR
;		PUBLIC BLINK_type
		PUBLIC COLUMNS_ptr
		PUBLIC COLUMNS_equal_msg
		PUBLIC columns_type
		PUBLIC delay_type
		PUBLIC delay_ptr
		PUBLIC rate_ptr
		PUBLIC rate_type
		PUBLIC function_not_supported
		PUBLIC Required_font_not_loaded
		PUBLIC ANSI_not_loaded
		PUBLIC Baud_rate_required
		PUBLIC RETRY_type_ptr
		PUBLIC RETRY_equal
		PUBLIC Baud_rate_required
		PUBLIC	not_supported_ptr
		PUBLIC	Illegal_device_ptr
		PUBLIC	syntax_error
		PUBLIC	syntax_error_ptr
		PUBLIC	rate_and_delay_together
		PUBLIC	CRLF
		PUBLIC	Invalid_switch
		PUBLIC	rightmost
		PUBLIC	leftmost
		PUBLIC	noretry
		PUBLIC	infinite
		PUBLIC	left
		PUBLIC	right
		PUBLIC	cpmsg8_pr
		PUBLIC	cpmsgxx_query
		PUBLIC	cpmsgxx_prep
		PUBLIC	cpmsgxx_select
		PUBLIC	cpmsgxx_refresh
		PUBLIC	cpmsg17_writ
		PUBLIC	cpmsg13_act
		PUBLIC	cpmsg13_sys
		PUBLIC	options_msg
		PUBLIC	msgOutOfMemory

PRINTF_CODE	ENDS
		END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modedefs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;  P R O L O G  ͻ				   ;AN000;
;											  				   ;AN000;
															   ;AN000;
;  AC000 - P3200: Was displaying a message that Sam Nunn had deleted from the
;		  USA.MSG file because it looked like a common message.  Now
;		  I use a different (better) message.

;  AX001 - P3976: Need to have all pieces of messages in MODE.SKL so have to
;		  implement the SYSGETMSG method of getting addressability to
;		  the pieces.  This means that the code does a SYSGETMSG call
;		  which returns a pointer (DS:SI) to the message piece.  The
;		  address is then put in the sublist block for the message
;		  being issued.


;											  				   ;AN000;
;  P R O L O G  ͼ				   ;AN000;
															   ;AN000;
Stdin			equ	0
StdOut			equ	1
StdErr			equ	2
No_Handle		equ	-1


Msg_Ser_Class		equ	0
Ext_Err_Class		equ	1
Parse_Error_Class	equ	2
Utility_Msg_Class	equ	0FFh

N_A		 	equ	0

No_Input		equ	0
DOS_keyb_input		EQU	01
clear_buffer		EQU	0C0H

	PUBLIC MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST
MSG_OPTIONS_FIRST	equ	300		; first options help msg #
MSG_OPTIONS_LAST        equ     310             ; last options help msg #

;
;*****************************************************************************
; Macro's
;*****************************************************************************
;

Define_Msg macro Message_Name			;				;AN000;
						;
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input;AN000;
						;
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8		;AN000;

Parm1	label	word				;				;AN000;
	dw	Parm2				;				;AN000;
	dw	Parm3				;				;AN000;
	dw	OFFSET Parm4			       ;			       ;AN000;
	dw	Parm5				;				;AN000;
	db	Parm6				;				;AN000;
	db	Parm7				;				;AN000;
	dw	Parm8				;				;AN000;
	endm					;				;AN000;


;
;*****************************************************************************
; Message Description Tables
;*****************************************************************************
;

;---------------------- 			;
Message_Number	= 3				;CR,LF,"Invalid switch - %1",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_invalid_switch
Count		= 1				;				;AN000;
Class		= Parse_Error_Class		;resident in COMMAND		;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	invalid_switch		;				;AN000;
;---------------------- 			;
Message_Number	= 1				;COMMON1 "Incorrect DOS Version"
Handle		= STDERR			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		;			       ;AN000;
Count		= N_A				;				;AN000;
Class		= msg_ser_Class 	    ;				    ;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	wrong_version		;				;AN000;
;---------------------- 			;
Message_Number	= 8				;				;AN000;
Handle		= STDERR			;extend1			;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= ext_err_Class 	    ;				    ;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgOutOfMemory		;				;AN000;
;---------------------- 			;
Message_Number	= 3				;CR,LF,"Must specify COM1, COM2, COM3 or COM4",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	com1_or_com2		;				;AN000;
;---------------------- 			;
Message_Number	= 4				;CR,LF,"Resident portion of MODE loaded",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	moved_msg		;				;AN000;
;---------------------- 			;
Message_Number	= 5				;CR,LF,"Illegal device name",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_err1			;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	ERR1			;				;AN000;
;---------------------- 			;
Message_Number	= 6				;CR,LF,"Printer error",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	ERR2			;				;AN000;
;---------------------- 			;
Message_Number	= 7				;CR,LF,"LPT%1: set for 80",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_PT80			;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	PT80			;				;AN000;
;---------------------- 			;
Message_Number	= 8				;CR,LF,"LPT%1: set for 132",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_PT132 		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	PT132			;				;AN000;
;---------------------- 			;
Message_Number	= 9				;CR,LF,"Printer lines per inch set",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg   PTLINES			;				;AN000;
;---------------------- 			;
Message_Number	= 10				;CR,LF,"Invalid baud rate specified",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	RATEMSG 		;				;AN000;
;---------------------- 			;
Message_Number	= 11				;CR,LF,"COM%1: %2,%3,%4,%5,%6",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_INITMSG		;				;AN000;
Count		= 6				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	INITMSG 		;				;AN000;
;---------------------- 			;
Message_Number	= 12				;"0123456789",EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	NUMBERS 		;				;AN000;
;---------------------- 			;
Message_Number	= 13				;CR,LF,"Do you see the %1? (",YES,"/",NO,")",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_SHIFT_MSG		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= clear_buffer+DOS_keyb_input	;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	SHIFT_MSG		;				;AN000;
;---------------------- 			;
;Message_Number  = 14				 ;CR,LF,"Invalid parameters",BEEP,CR,LF,EOM
;Handle 	 = STDOUT			 ;				 ;AC000;
;Sublist	 = PRINTF_CODE:No_replace			 ;				 ;AC000;
;Count		 = N_A				 ;****	Now use message 54 ***** ;AC000;
;Class		 = Utility_Msg_Class		 ;				 ;AC000;
;Function	 = No_Function			 ;				 ;AC000;
;Input		 = N_A				 ;				 ;AC000;
;	 Define_Msg	 MSGI			 ;				 ;AC000;
;---------------------- 			;
Message_Number	= 15				;CR,LF,"LPT%1: rerouted to COM%2:",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_REDIRMSG		;				;AN000;
Count		= 2				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	REDIRMSG		;				;AN000;
;---------------------- 			;
Message_Number	= 16				;CR,LF,"LPT%1: not rerouted",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_NOTREMSG		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	NOTREMSG		;			      ;AN000;
;---------------------- 			;
Message_Number	= 17				;CR,LF,"%1 retry on parallel printer time-out",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_RETPARTO		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	RETPARTO		;				;AN000;
;---------------------- 			;
Message_Number	= 18				;CR,LF,"      Unable to shift screen %1",CR,LF,BEEP,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_CANT_SHIFT		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	CANT_SHIFT		;				;AN000;
;---------------------- 			;
Message_Number	= 19				;CR,LF,"Invalid parameter - %1",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_invalid_parameter
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	invalid_parameter      ;			       ;AN000;
;---------------------- 			;
Message_Number	= 20				;CR,LF,'Invalid number of parameters',BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
     Define_Msg   invalid_number_of_parameters	;			     ;AN000;
;---------------------- 			;
Message_Number	= 21				;CR,LF,'NET 042: Unable to do requested command',BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	net_error		;				;AN000;
;---------------------- 			;
Message_Number	= 22				;CR,LF,'Infinite retry not supported on Network printer',beep,cr,lf,eom
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	not_supported		;				;AN000;
;---------------------- 			;
Message_Number	= 23				;CR,LF,"Failure to access Codepage Font File",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg1			;				;AN000;
;---------------------- 			;
Message_Number	= 24				;CR,LF,"Failure to access device: %1",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg2		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	cpmsg2			;				;AN000;
;---------------------- 			;
Message_Number	= 25				;CR,LF,"Device or codepage missing from font file",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg3			;				;AN000;
;---------------------- 			;
Message_Number	= 26				;CR,LF,"Font file contents invalid",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg4			;				;AN000;
;---------------------- 			;
Message_Number	= 27				;CR,LF,"Previously prepared codepage replaced",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg5
;---------------------- 			;
Message_Number	= 28				;CR,LF,"Active codepage for device %1 is %2",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg6		;				;AN000;
Count		= 2				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg6
;---------------------- 			;
Message_Number	= 29				;CR,LF,"Device %1 not prepared",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg7		;				;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg7
;---------------------- 			;
Message_Number	= 30				;"%1 codepages:",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg8
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg8
;---------------------- 			;
Message_Number	= 31				;"  Codepage %1",CR,LF,EOM       ;FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg9
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg9
;---------------------- 			;
Message_Number	= 32				;CR,LF,"MODE %1 Codepage function completed",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg10		;				;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg10
;---------------------- 			;
Message_Number	= 33				;CR,LF,"Current Codepage settings:",CR,LF,EOM  ;table header
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg12
;---------------------- 			;
Message_Number	= 34				;"   %1 - %2 Codepage",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg13
Count		= 2
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg13
;---------------------- 			;
Message_Number	= 35				;"  Codepage not prepared",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:no_replace
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg14
;---------------------- 			;
Message_Number	= 36				;CR,LF,"Codepage operation not supported on this device",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg15
;---------------------- 			;
Message_Number	= 37				;CR,LF,"No codepage has been SELECTED",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg16
;---------------------- 			;
Message_Number	= 38				;"Device error during %1",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_cpmsg17
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg17
;---------------------- 			;
Message_Number	= 39				;"Codepage not prepared",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg18
;---------------------- 			;
Message_Number	= 40				;CR,LF,"Current keyboard does not support this Codepage",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg19
;---------------------- 			;
Message_Number	= 41				;CR,LF,"Error during read of font file",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg20
;---------------------- 			;
Message_Number	= 42				;CR,LF,"Unable to perform REFRESH operation",BEEP,CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg21
;---------------------- 			;
Message_Number	= 43				;CR,LF
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    CRLF
;---------------------- 			;
Message_Number	= 44				;"Status for device %1:",CR,LF,EOM
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_status_for_device
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    status_for_device
;---------------------- 			;
Message_Number	= 45				;"------------------" underline for status report header
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    long_underline
;---------------------- 			;
Message_Number	= 46				;"----" underline for "CON:"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    four_char_underline
;---------------------- 			;
Message_Number	= 47				;"-----" underline for "COMX:" and "LPTX:"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    five_char_underline
;---------------------- 			;
Message_Number	= 48				;"Lines=%1"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_LINES_equal		;				;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    LINES_equal_msg
;---------------------- 			;
Message_Number	= 49				;"Columns=%1"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_COLUMNS_equal 		;				;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    COLUMNS_equal_msg
;---------------------- 			;
Message_Number	= 50				;CR,LF,"Rate and delay must be specified together",BELL,CR,LF
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace			;				;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    RATE_and_DELAY_together
;---------------------- 			;
Message_Number	= 51				;"Rate=%1"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_RATE_equal		       ;			       ;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    RATE_equal
;---------------------- 			;
Message_Number	= 52				;"Delay=%1"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:sublist_DELAY_equal			;				;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    DELAY_equal
;---------------------- 			;
Message_Number	= 53				;"Function not supported on this machine"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:Sublist_Not_supported       ; 			      ;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    Function_not_supported
;---------------------- 			;
Message_Number	= 54				;"Required font not loaded"
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    Required_font_not_loaded
;---------------------- 			;
Message_Number	= 55				;"ANSI.SYS must be installed to perform requested function",BELL,CR,LF
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    ANSI_not_loaded
;---------------------- 			;
Message_Number	= 56				;CR,LF,"Baud rate required",BELL,CR,LF
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    Baud_rate_required
;---------------------- 			;
Message_Number	= 57				;"Retry=%1",CR,LF
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:Sublist_retry_equal	      ; 			      ;AN000;
Count		= 1
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    retry_equal
;---------------------- 			;
Message_Number	= 58				;"Syntax error - ",CR,LF
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:Sublist_syntax_error	      ; 			      ;AN000;
Count		= 1
Class		= Utility_msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    syntax_error
;---------------------- 			;

Message_Number	= 59 ;"rightmost 9"                  ;AN001;
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    rightmost 		    ;AN001;
;---------------------- 			;
Message_Number	= 60 ;"leftmost 0"                   ;AN001;LEFTMOST        DB
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    leftmost
;---------------------- 			;
;RETPARTO - CR,LF,;"%s retry on parallel printer time-out",CR,LF,EOM

Message_Number	= 61 ;"No"                           ;AN001;NORETRY         DB
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    noretry
;---------------------- 			;
Message_Number	= 62 ;"Infinite"                     ;AN001;INFINITE        DB
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    infinite
;---------------------- 			;
;CANT_SHIFT - CR,LF,;"      Unable to shift screen %s",CR,LF,BEEP,EOM

Message_Number	= 63 ;"left"                                ;AN001;LEFT            DB
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    left
;---------------------- 			;
Message_Number	= 64 ;"right"                               ;AN001;RIGHT           DB
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    right
;---------------------- 			;
;CPMSG8 	DB    ;"%S codepages:",CR,LF,EOM

Message_Number	= 65 ;"Hardware"             ;AN001;CPMSG8_HW      DB
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg8_hw
;---------------------- 			;
Message_Number	= 66 ;"Prepared"             ;AN001;CPMSG8_PR      DB
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg8_pr
;---------------------- 			;
;CPMSG10	 DB    ;"MODE %S Codepage function completed",CR,LF,EOM
;CPMSG17	 DB	;"Device error during %S",BEEP,CR,LF,EOM

Message_Number	= 67 ;"status"          ;AN001;CPMSG17_QUERY   CPMSG10_QUERY
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsgxx_query
;---------------------- 			;
Message_Number	= 68 ;"prepare"         ;AN001;CPMSG17_PREP    CPMSG10_DES
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsgxx_prep
;---------------------- 			;
Message_Number	= 69 ;"select"          ;AN001;CPMSG17_ACT     CPMSG10_SELECT
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsgxx_select
;---------------------- 			;
Message_Number	= 70 ;"refresh"         ;AN001;CPMSG17_REFRESH CPMSG10_REFRESH
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsgxx_refresh
;---------------------- 			;

;CPMSG17	 DB	;"Device error during %S",BEEP,CR,LF,EOM

Message_Number	= 71 ;"write of font file to device",EOM   ;AN001;CPMSG17_WRIT
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg17_writ
;---------------------- 			;
;CPMSG13	 DB    ;"   %D - %S Codepage",CR,LF,EOM

Message_Number	= 72 ;"selected"        ;AN001;CPMSG13_ACT
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg13_act
;---------------------- 			;
Message_Number	= 73 ;"system"          ;AN001;CPMSG13_SYS
Handle		= STDOUT			;				;AN000;
Sublist 	= PRINTF_CODE:No_Replace		      ; 			      ;AN000;
Count		= N_A
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg    cpmsg13_sys
;----------------------
Message_Number	= MSG_OPTIONS_FIRST		; Options help message
Handle		= STDOUT
Sublist 	= PRINTF_CODE:No_Replace
Count		= N_A
Class		= Utility_Msg_Class
Function	= No_Function
Input		= N_A
	Define_Msg    options_msg
;----------------------

; end of modedefs.inc

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modequat.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;---------------------- POSSIBLE VALUES FOR "machine_type" -------------------

;See "get_machine_type" for details on how "machine_type" is used


PC1	       EQU   0FFH	       ;scalar value and model byte for PC1
PCXT	       EQU   0FEH	       ;scalar value for XT, only one because each release is same to MODE
PCJr	       EQU   0FDH	       ;scalar value for PCJr
AT1	       EQU   0FCH	       ;scalar value for first release of AT and VAIL
AT2	       EQU   000H	       ;scalar value and submodel byte for second release of AT
AT3	       EQU   001H	       ;scalar value and submodel byte for internal release of third version of AT
AT4	       EQU   006H	       ;scalar value and submodel byte for AT on or later than 11/15/85
XT286	       EQU   002H	       ;scalar value and submodel byte for XT 286
Convertible    EQU   0F9H	       ;scalar value and model byte for PC Convertible
PS2Model30     EQU   0FAH	       ;scalar value and model byte for Personal System/2 Model 30
PS2Model50     EQU   004H	       ;scalar value and submodel byte for Personal System/2 Model 50
PS2Model60     EQU   005H	       ;scalar value and model byte for Personal System/2 Model 60
PS2Model80     EQU   0F8H	       ;scalar value and model byte for Personal System/2 Model 80 and SNOWMASS
Vail	       EQU   009H	       ;AN001;scalar value and submodel byte for VAIL


bogus			      EQU   88H 	;completely invalid value
COM1			      EQU   0C1H	;used by invoke
COM2			      EQU   0C2H	;used by invoke
COM3			      EQU   0C3H	;used by invoke
COM4			      EQU   0C4H	;used by invoke
false	EQU	00H
true	EQU	0FFH


;FLAGS field bit(s) values

Left_Align		equ	0	;00xxxxxx
Right_Align		equ	80h	;10xxxxxx

Unsgn_Bin_Byte	  equ	  11h	  ;a0010001


PUBLIC	 bogus

;  P R O L O G  ͻ
;											  

;  AX001 - P4543: Add VAIL and SNOWMASS to legal choices for 19200 baud

;											  
;  P R O L O G  ͼ
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modeprin.asm ===
PAGE ,132 ;
TITLE MODEPRIN.SAL - PRINTER SUPPORT FOR THE MODE COMMAND

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  MKS  C00  General cleanup.  Making short jumps out of long
;                      jumps, ridding of nops.
;  05/25/90  AKM  C06  Changing printer timeout for first byte of setting up
;                      printer characteristics.  If "Printer Error" message
;                      happens, we get out of the loop.  Bug#1078.
;
;******************************************************************************
.XLIST
INCLUDE STRUC.INC
.LIST
.SALL


;  P R O L O G  ͻ                                ;AN000;
;                                                                                                                        ;AN000;
                                                                                                                           ;AN000;
;  AX001 - P3976: Need to have all pieces of messages in MODE.SKL so have to
;                 implement the SYSGETMSG method of getting addressability to
;                 the pieces.  This means that the code does a SYSGETMSG call
;                 which returns a pointer (DS:SI) to the message piece.  The
;                 address is then put in the sublist block for the message
;                 being issued.
;                                                                                                                        ;AN000;
;  P R O L O G  ͼ                                ;AN000;



DISPLAY         MACRO   MSG
        MOV     DX,OFFSET MSG
        CALL    PRINTF
ENDM

PRINT   MACRO
                                MOV DX,WORD PTR PT17    ;PASS PRINTER NUMBER
                                INT 17H               ;OUTPUT TO PRINTER
        ENDM

COMPARE MACRO   STRING, CHAR1, CHAR2, CHAR3
        LOCAL   END_COMPARE

;------------------------------------------------------------------------------------------------
;
;  Compare first 3 characters of STRING with CHAR1, CHAR2, and CHAR3
;
;------------------------------------------------------------------------------------------------

  PUSH  SI
  MOV   SI,0                            ;INITIALIZE INDEX
  CMP   STRING[SI],CHAR1                ;IF first char is a match THEN
  JNE   END_COMPARE
    INC   SI                    ;  GET TO NEXT CHAR OF STRING
    CMP   STRING[SI],CHAR2              ;  IF 2nd char is a match THEN
    JNE   END_COMPARE
      INC   SI
      CMP   STRING[SI],CHAR3            ;    IF all three match then ZR is not set
END_COMPARE:
  POP   SI
ENDM
;
IF_NO_PRINTER_ERROR_THEN        MACRO
        CMP     PRINTER_ERROR,TRUE
        JE      CHK_FOR_P
ENDM
;
JUMP_EQUAL_TO_CHK_FOR_P         MACRO
LOCAL   SKIP_JUMP
;
        JNE     SKIP_JUMP
          JMP   CHK_FOR_P
        SKIP_JUMP:
ENDM


SET     MACRO   REG,VALUE               ;SET REG TO VALUE. DON'T SPECIFY AX FOR REG

        PUSH    AX
        MOV     AX,VALUE
        MOV     REG,AX
        POP     AX

ENDM


set_submessage_ptr   MACRO submessage,message ;PUT pointer to "subMESSAGE" into submessage pointer field of "message".

MOV   AX,submessage                          ;AX=message number                 ;AN001;
MOV   DH,utility_msg_class                   ;DH=message class=utility class    ;AN001;
CALL  SYSGETMSG                              ;DS:SI=>message piece                                ;AN001;
MOV   BP,OFFSET sublist_&message             ;address the sublist control block ;AN001;
MOV   [BP].sublist_off,SI                    ;the sublist now points to the desired message piece ;AN001;
ENDM                                                                                              ;AN001;


;  S T R U C T U R E S  ͻ
;                                                                                        

INCLUDE  common.stc        ;contains the following structure

;                                                                                        
;  S T R U C T U R E S  ͼ


;
ROM     SEGMENT AT 0
        ORG     530H
RESSEG  LABEL   DWORD           ;VECTOR POINTING TO MODETO IF RESIDENT
ROM     ENDS

;**********************************************************************
PRINTF_CODE   SEGMENT  PUBLIC
        ASSUME  CS:PRINTF_CODE,DS:PRINTF_CODE
;

;  E X T R N S  ͻ
;                                                                                        

EXTRN   B_item_tag:ABS            ;see modepars
EXTRN   COM1_or_COM2:WORD   ;=>"Must specify COM1 or COM2" message
EXTRN   CTRL_ST:BYTE            ;CONTROL STRING SET UP FROM CONFIGURATION PARAMETERS INPUT
EXTRN   E_item_tag:ABS            ;see modepars
EXTRN   invalid_number_of_parameters:WORD   ;=>"Invalid number of parameters"
EXTRN   noerror:BYTE             ;AN000;
EXTRN   OFFRETRY:ABS            ;OFFSET TO TEST INSTR IN RETRY CODE
EXTRN   not_supported:WORD  ;message telling user he specified "P" on a net printer
EXTRN   PRINTR:WORD             ;PRINTER BASE (40:8), HOLDS PORT ADDRESSES OF PRINTER CARDS
EXTRN   ERR1:BYTE           ;POINTER TO "Invalid parameters"
EXTRN   Illegal_device_ptr:WORD  ;pointer to device name that does not exist
EXTRN   INDEX:WORD              ;INDEX OF REDIRECTED PRINTER IN NETWORK REDIRECTION LIST
EXTRN   IS_LOCAL:BYTE           ;BOOLEAN. INDICATES IF A PRINTER IS LOCAL. INITIALLY TRUE
EXTRN   keyword:ABS
EXTRN   LOCAL_NAME:BYTE         ;FILLED IN BY GET ASSIGN LIST ENTRY FUNCTION CALL
EXTRN   lpt1_retry_type:BYTE     ;byte in resident code for retry mask, see rescode
EXTRN   LPTNO:BYTE              ;see modeecho
EXTRN   machine_type:BYTE       ;see "rescode"
EXTRN   MODEECHO:NEAR           ;SET UP REDIRECTION OF PARALLEL TO SERIAL
EXTRN   MODELENG:NEAR
EXTRN   MODELOAD:NEAR           ;MOVES THE CODE AT MODETO TO 60 AND MAKES IT RESIDENT                                      ;AN000;
EXTRN   NET_ERROR:WORD      ;"NET 042: Unable to do requested comand"                                                      ;AN000;
EXTRN   NONE_item_tag:ABS           ;AN000;see modepars                                                                    ;AN000;
EXTRN   parm_lst:BYTE            ;see modepars.asm                                                                         ;AN000;
EXTRN   P_item_tag:ABS            ;see modepars.asm                                                                        ;AN000;
EXTRN   P14_model_byte:ABS                      ;see "rescode"                                                             ;AN000;
EXTRN   PRINTF:NEAR             ;FORMATTED "C" LIKE SCREEN OUTPUT ROUTINE                                                  ;AN000;
EXTRN   PARM1:BYTE,PARM2:BYTE,PARM3:BYTE,MODE:BYTE
EXTRN   parm_list_holder:WORD    ;address of parsed parameter list                                                         ;AN663;
EXTRN   parms_form:BYTE                                                                                                    ;AN000;
EXTRN   DEVICE:BYTE,PPARM:BYTE                                                                                             ;AN000;
EXTRN   R_item_tag:ABS                                                                                                     ;AN000;
EXTRN   retry_index:WORD          ;see modecom.asm                                                                         ;AN000;

EXTRN   ERR2:WORD       ;CR,LF,"Printer error",BEEP,CR,LF,"$"
EXTRN   PT80:WORD       ;CR,LF,"LPT"
EXTRN   PT80N:BYTE      ;DB " "
;                       ": set for 80",CR,LF,"$"
EXTRN   PT132:WORD      ;CR,LF,"LPT"
EXTRN   PT132N:BYTE     ;" "
;                       ": set for 132",CR,LF,"$"
EXTRN   PTLINES:WORD    ;CR,LF,"Printer lines per inch set",CR,LF,"$"
EXTRN   NORETRY:WORD        ;message number for CR,LF,'No','$' ;AC001;
EXTRN   INFINITE:WORD       ;message number for CR,LF,'Infinite' ;AC001;
EXTRN   REMOTE_DEV:BYTE         ;FILLED IN BY GET ASSIGN LIST ENTRY FUNCTION CALL
EXTRN   RETPARTO:WORD   ;message number for '%1 retry on parallel printer timeout',CR,LF,'$'
EXTRN   sublist_retparto:BYTE    ; control block for "%1 retry on parallel printer timeout" ;AC001;
EXTRN   SYSGETMSG:NEAR           ;AC001;
EXTRN   utility_msg_class:ABS    ;used for input to sysgetmsg
EXTRN   VERIFY:NEAR             ;FINDS IF n OF LPTn IS LEGAL

;                                                                                        
;  E X T R N S  ͼ


;  E Q U A T E S  ͻ
;                                                                                        

busy_status EQU   080H           ;flag telling resident code to not change anything
COLON   EQU     ":"             ;CHAR IN "LPT1:"
error_status   EQU   029H           ;status byte indicating the printer is on fire(busy, no paper, I/O error, timeout)
FALSE   EQU     00H
SPACE   EQU     " "             ;THE BLANK CHARACTER
TO_SCREEN EQU   9               ;REQUEST OUTPUT TO SCREEN
INTCONV EQU     48              ;CONVERTS ASCII TO NUMERIC
EIGHTY  EQU     80              ;80 COL PRINTER WIDTH
no_retry_flag  EQU   0           ;no retry active, stored in lptx_retry_type, see rescode.sal
ONE_THIRTY_TWO EQU      132     ;132 COL PRINTER WIDTH
PRTDC2  EQU     18              ;PRINTER CONTROL CHAR FOR 80 COL
PRTSI   EQU     15              ;PRINTER CONTROL CHAR FOR 132 CHAR
PRTCANCEL EQU   24              ;PRINTER CONTROL CHAR FOR CANCEL
CHAR6   EQU     "6"             ;REQUEST FOR 6 LINES PER INCH
CHAR8   EQU     "8"             ;REQUEST FOR 8 LINES PER INCH
L       EQU     "L"
P       EQU     "P"
T       EQU     "T"
R       EQU     "R"
N       EQU     "N"
NULL    EQU     0               ;NULL CHAR
ASC0    EQU     "0"             ;ASCII 0, REQUEST 8 LINES PER INCH
ASC2    EQU     "2"             ;ASCII 2, REQUEST 6 LINES PER INCH
escape  EQU     27              ;ESCAPE PRINTER CONTROL CHAR
PRINTERSETUP    EQU     5E02H   ;FUNCTION CODE FOR PRINTER SET UP DOS CALL
GET_LIST_ENTRY  EQU     5F02H   ;FUNCTION CODE FOR GET ASSIGN LIST ENTRY FROM NETWORK REDIR. LIST
CHAR_DEVICE     EQU     3       ;CHARACTER DEVICE "MACRO" TYPE (IN NETWORK LINGO).
PRN_NO          EQU     3       ;CHARACTER POSITION OF THE PRINTER NUMBER IN LPTn, (ZERO BASED)
ready_status     EQU      90H      ;flag telling resident code to set status indicating printer is ready for another character
UNCHANGED       EQU     -1      ;-1 INDICATES TO SERVER THAT PARAMTER IS UNCHANGED (NOT SPECIFIED)
unspecified    EQU      0FFH     ;AN000;value of parm2 if no lines per inch was specified
TRUE    EQU     0FFH
ENDPARM EQU     MODE
parm_list  EQU   [BP]

;                                                                                        
;  E Q U A T E S  ͼ


;  D A T A  ͻ
;                                                                                        

columns_holder  DB   bogus
i        DB    0        ;loop index for retry index calculation
PT17    DW      0       ;SAVES PRINTER NUMBER FOR DX AND INT 17H
LPTN    DB      0       ;SAVES ID OF WHICH LPTn IS REFERENCED
PRINTER_NO      DB      0       ;SAVES LPT NUMBER IN ZERO BASED NUMERICAL FORM
CTRL_ST_LEN     DW      0000    ;HOLDER FOR LENGTH OF THE CONTROL STRING
REDIRECTED      DB      00      ;FLAG TO INDICATE A PRINTER IS ON THE NETWORK
CHARS_LINE      DB      -1      ;HOLDS CHARACTERS PER LINE IN NUMERIC FORM
NO_COLON        DW      00      ;CHAR POSITIONS TO MOVE IF NO COLON INCLUDED IN DEVICE NAME
PTLINES_REQ     DB      00      ;BOOLEAN INDICATOR OF LINES PER INCH REQUESTED
PRINTER_ERROR   DB      00      ;BOOLEAN INDICATOR OF PRINTER NOT THERE OR OFF OR OFFLINE
EIGHTY_CHARS_LINE_REQ   DB      00      ;BOOLEAN, INDICATES IF 80 CHARS/LINE REQUESTED
REQ_132_CHARS_LINE      DB      00      ;BOOLEAN, INDICATES IF 132 CHARS/LINE REQUESTED
OLD_PTR_TIMEOUT DB      00      ;SAVE AREA FOR OLD PRINTER TIMEOUT VALUE   ;C06
PUBLIC  OLD_PTR_TIMEOUT                                                    ;C06

;                                                                                        
;  D A T A  ͼ


;  P U B L I C S  ͻ
;                                                                                        

PUBLIC   busy_status          ;used by rescode in parallel retry code
PUBLIC columns_holder                                                                                                       ;AN000;
PUBLIC   error_status         ;used by analyze_and_invoke and rescode
PUBLIC modify_resident_code   ;used by invoke                                                                               ;AN000;
PUBLIC MODEPRIN
PUBLIC   no_retry_flag        ;used by analyze_and_invoke
PUBLIC printer_no             ;needed by modepars
PUBLIC   ready_status         ;used by analyze_and_invoke
PUBLIC set_retry_type         ;used by invoke in turn_off_retry_case

;                                                                                        
;  P U B L I C S  ͼ


;*******************************************************************
MODEPRIN PROC NEAR


;On entry: "columns_holder" contains 132,80 or 88H.
;          "parm2" contains "[68]" (FFH if not specified).
;          "parm_list[retry_index]" contains "X_item_tag" where X is e, b, r, or p

           MOV AL,LPTNO         ;AN000;LPTNO set up by modepars in first_parm_case
           MOV PT80N,AL         ;PUT ASCII PRINTER NUMBER INTO BOTH
           MOV PT132N,AL        ; MESSAGES
           SUB AL,INTCONV+1     ;CONVERT TO INTEGER, MINUS ONE
           MOV PRINTER_NO,AL    ;SAVE ZERO BASED PRINTER NUMBER
           MOV AH,0             ;CLEAR AH
           MOV WORD PTR PT17,AX ;SET UP PRINTER NUMBER FOR INTERRUPT 17H


           MOV DI,0             ;INITIALIZE LENGTH OF CONTROL STRING
           MOV BL,columns_holder    ;BL=binary form of requested chars per line
;    : : : IF REQUEST IS FOR 80 COL
           CMP BL,EIGHTY
           JNE ELSEIF03
;
             MOV CHARS_LINE,BL  ;SAVE CHARACTERS PER LINE
             MOV EIGHTY_CHARS_LINE_REQ,TRUE
             MOV BL,PRTDC2      ;SEND A DC2 CHAR TO SELECT 80 COL
;    : : : ELSEIF SINCE NOT 80, IS REQUEST FOR 132?
           JMP SHORT ENDIF03
ELSEIF03:
           CMP BL,ONE_THIRTY_TWO        ;132?
           JNE ENDIF03                    ;AC000;
;
             MOV CHARS_LINE,BL  ;SAVE CHARACTERS PER LINE
             MOV REQ_132_CHARS_LINE,TRUE
             MOV BL,PRTSI       ;SEND 'SI', CONDENSED PRINT
;    : : : ENDIF ,END IS REQUEST FOR 80 COL
ENDIF03:

;    : : : IF ANYTHING TO PRINT,
           CMP BL,bogus                   ;AC000;
           JE ENDIF04

             MOV BYTE PTR CTRL_ST[DI],BL        ;PUT CONTROL CHAR FOR COLS/LINE IN CONTROL STRING
             INC  DI            ;GET TO NEXT CHAR POSITION IN CONTROL STRING


;    : : : ENDIF END IF ANYTHING TO PRINT? TEST
ENDIF04:

PUBLIC   ENDIF04

;*****************************************************************
;  LOOK AT THE SECOND PARM, CHECKING FOR 6 OR 8 LINES PER INCH
;*****************************************************************
           MOV BL,NULL          ;NULL CHAR, TO BE REPLACED MAYBE
;    : : : IF THERE IS A SECOND PARM,
           CMP DS:PARM2,unspecified                     ;AC000;
           JE ENDIF05
;
;    : : : : IF THE REQUEST FOR 6 LINES PER INCH?
             CMP DS:PARM2,CHAR6
             JNE ELSEIF06
;
               MOV BL,ASC2      ;REQUEST 6 LPI
;    : : : : ELSEIF REQUEST IS FOR 8 LINES PER INCH
             JMP SHORT ENDIF06
ELSEIF06:
             CMP DS:PARM2,CHAR8
             JNE ENDIF06
               MOV BL,ASC0      ;REQUEST 8 LINES PER INCH
;    : : : : ENDIF ,END IS REQUEST FOR 6 LPI? TEST
ENDIF06:
;    : : : ENDIF END IS THERE A SECOND PARM? TEST
ENDIF05:
;    : : : IF 6 OR 8 LINES PER INCH REQUESTED
           CMP BL,0
           JE ENDIF07
             MOV CTRL_ST[DI],escape        ;PUT AN ESCAPE CHAR IN THE CONTROL STRING
             INC  DI                    ;GET TO NEXT CHAR POSITION IN THE CONTROL STRING
;
             MOV BYTE PTR CTRL_ST[DI],BL        ;PUT CONTROL CHAR FOR LINES/INCH IN CONTROL STRING
             INC  DI                    ;GET TO NEXT CHAR POSITION IN THE CONTROL STRING
;
             MOV        PTLINES_REQ,TRUE        ;INDICATE LINES PER INCH SET IF NO PRINTER ERROR
;    : : : ENDIF END IS 6 OR 8 LPI REQUESTED? TEST
ENDIF07:
           CALL VERIFY          ;SEE IF n OF LPTn WAS LEGAL
           MOV  BYTE PTR LPTN,AH        ;SAVE THE n OF LPTn
;
           MOV  BX,0
           PUSH BX
           POP  ES              ;GET ADDRESSABILITY TO PRINTER BASE
           MOV  BL,PRINTER_NO   ;PUT ZERO BASED PRINTER NUMBER INTO BL
           SAL  BL,1            ;CHANGE TO WORD OFFSET FROM PRINTER BASE (40:8)
           CMP  ES:PRINTR[BX],0 ;SEE IF THERE IS NO PORT ADDRESS FOR THE SPECIFIED PRINTER THEN
           JNE  PRINTER_EXISTS
             MOV  IS_LOCAL,FALSE                ;NOT A LOCAL PRINTER
           PRINTER_EXISTS:
;
;**************************************************************************************************
;  SEARCH THE NETWORK REDIRECTION LIST
;
;  IF THE PRINTER IS FOUND IN THE LIST THEN THE CONTROL STRING HAS TO BE SENT TO THE REDIRECTOR,
;  OTHERWISE THE CONTROL STRING WILL BE SENT DIRECTLY TO THE LOCAL PRINTER.
;  AN INDEX WILL BE INITIALIZED TO ZERO.  A GET ASSIGN LIST ENTRY CALL WILL BE MADE, THE DEVICE
;  TYPE IS CHECKED FOR CHARACTER DEVICE TYPE. IF THE ENTRY IS A CHARACTER DEVICE THEN THE NAME IS
;  COMPARED WITH THE NAME OF THE PRINTER TO BE CONFIGURED.  IF THE NAMES MATCH THEN WE KNOW THAT
;  THE PRINTER HAS BEEN PUT ON THE NETWORK, ELSE WE CONTINUE DOWN THE LIST BY INCREMENTING THE
;  INDEX AND MAKING ANOTHER GET ASSIGN LIST ENTRY CALL.  THIS CONTINUES UNTIL THE END OF THE NRL
;  IS REACHED OR THE PRINTER IS FOUND.
;  GET ASSIGN LIST ENTRY CALL WORKS AS FOLLOWS: 5F02H IS PUT IN AX, THE INDEX IS PUT IN BX. ON
;  RETURN DS:SI POINTS TO THE LOCAL NAME, ES:DI POINTS TO REMOTE NAME, CX HAS THE DEVICE TYPE.  IF
;  CARRY IS SET AX HAS ERROR CODE: INVALID FUNCTION (NETWORK SUPPORT IS NOT PRESENT) OR, NO MORE
;  FILES (THE INDEX IS GREATER THAN THE NUMBER OF NETWORK ASSIGNMENTS).
;
;**************************************************************************************************
;
SEE_IF_REDIRECTED:

PUBLIC SEE_IF_REDIRECTED

        MOV     CTRL_ST_LEN,DI          ;SAVE LENGTH OF CONTROL STRING
        DEC     INDEX                   ;SET INDEX TO -1 SO IT WILL BEGIN AT ZERO
SRCH_NRL:
        MOV     AX,GET_LIST_ENTRY       ;SET UP FOR GET ASSIGN LIST ENTRY FUNCTION CALL
        INC     INDEX
        MOV     BX,INDEX                ;BX GETS THE INDEX OF THE ENTRY TO BE FECTHED
        MOV     SI,OFFSET LOCAL_NAME    ;DS:SI POINTS TO HOLDING AREA FOR LOCAL DEVICE NAME
        PUSH    DS
        POP     ES                      ;ES GETS THE SEGMENT OF REMOTE DEVICE NAME HOLDING AREA
        MOV     DI,OFFSET REMOTE_DEV    ;ES:DI POINTS TO (USELESS) REMOTE DEVICE NAME HOLDING AREA
        INT     21H
        JNC     CHK_DEV_TYPE
        JMP     NOT_RED                 ;IF CARRY IS SET THEN THE PRINTER IS NOT REDIRECTED
CHK_DEV_TYPE:
          CMP   BL,CHAR_DEVICE          ;ELSE CHECK THE DEVICE TYPE
          JE    CHECK_NAME              ;IF THE DEVICE TYPE IS CHAR DEVICE THEN COMPARE NAMES
            JMP SRCH_NRL                ;ELSE CONTINUE SEARCH
CHECK_NAME:                     ;SEE IF THE LOCAL NAME IS THE PRINTER TO BE CONFIGURED
;  Count the number of characters in the local name
  MOV   SI,00                           ;INITIALIZE THE CHARACTER COUNTER
COUNT:
  CMP   LOCAL_NAME[SI],NULL             ;WHILE (char<>null) AND (char<>space) DO
  JE    CHECK_1st_3                     ;END OF NAME
    CMP   LOCAL_NAME[SI],SPACE
    JE    CHECK_1st_3                   ;  END OF NAME
      INC   SI                          ;    INCREMENT NUMBER OF CHARS IN THE NAME
  JMP   COUNT                           ;END WHILE non-termination char
CHECK_1st_3:                            ;SEE IF 1st 3 CHARS ARE LPT OR PRN
  CMP   SI,4                            ;IF the name is 4 or less chars THEN
  JG    CONTINUE_SEARCH                 ;NAME IS TOO LONG
    COMPARE   LOCAL_NAME, L, P, T
    JNE       CHECK_FOR_PRN
      MOV       AL,PT80N                        ;PUT PRINTER NUMBER IN AL
      CMP       LOCAL_NAME[PRN_NO],AL           ;CHECK PRINTER NUMBER
      JE        END_CHECK_NAME                  ;FOUND THE PRINTER IN THE LIST
    CHECK_FOR_PRN:
      COMPARE   LOCAL_NAME, P, R, N
      JNE       CONTINUE_SEARCH                 ;NOT REDIRECTED AS PRN EITHER
        CMP       PT80N,1                         ;IF printer to be configured is lpt1 THEN
        JNE       CONTINUE_SEARCH
      JMP SHORT END_CHECK_NAME                  ;FOUND THE PRINTER IN THE LIST
  CONTINUE_SEARCH:
    JMP   SRCH_NRL
END_CHECK_NAME:

PUBLIC END_CHECK_NAME

MOV     REDIRECTED,TRUE                         ;REDIRECTED:=TRUE.  THE PRINTER WAS FOUND IN NRL
;
;**************************************************************************************************
;  INDICATE TO SERVER THAT THE CONFIGURATION OF A NETWORK PRINTER HAS CHANGED.
;
;  SET DS:SI TO POINT TO THE PRINTER NAME, CHARS_LINE HAS THE CHARACTERS PER LINE, PARM2 HAS THE
;  LINES PER INCH IN CHARACTER FORM.
;**************************************************************************************************
;
      CMP  CTRL_ST_LEN,0                ;IF printer configuration has changed THEN
      JUMP_EQUAL_TO_CHK_FOR_P
        MOV  SI,OFFSET LOCAL_NAME       ;DS:SI POINTS TO PRINTER NAME
        MOV  AH,02
        XOR  AL,AL              ;AL=0
        MOV  CL,8                       ;CL HOLDS SHIFT COUNT.  8 IS NUMBER OF BITS NEEDED FOR 132.
        MOV  DL,CHARS_LINE              ;MOV 80 or 132 or FF INTO ACCUMULATOR REGISTER
        ROR  DL,1                       ;IF (DL=50H) OR (DL=84H) THEN DL[7]=0  ELSE DL=FFH
        SAR  DL,CL                      ;IF (CHARS_LINE = 80) OR (CHARS_LINE = 132) THEN
        MOV  BH,DL                        ;BH=0  ELSE  BH=BL=FFH
        MOV  BL,CHARS_LINE              ;BX= -1 or 80 or 132
        MOV  CL,PARM2
        CMP  PARM2,bogus                ;IF THE LINES PER INCH WASN'T SPECIFIED THEN DON'T CONVERT
        JNE  CONVERT
          MOV  CH,UNCHANGED               ;CX=-1 (FFFF)
;C00      JMP  CALL_SERVER
          JMP  SHORT CALL_SERVER                                        ;C00
        CONVERT:                        ;ELSE
          XOR  CH,CH                      ;CLEAR CH
          SUB  CX,INTCONV                 ;CHANGE LINES PER INCH TO NUMERIC FORM
        CALL_SERVER:                    ;ENDIF
        INT  2AH                        ;CALL SERVER
;
;**************************************************************************************************
;  SET UP REDIRECTOR WITH CONTROL STRING BUFFER VIA A PRINTER SET UP CALL.
;
;  DI HAS LENGTH OF THE CONTROL STRING.  NEED TO SET DS:SI TO THE POINT TO THE CONTROL STRING
;  BUFFER, PUT THE LENGTH IN CX, AND THE NETWORK REDIRECTION LIST INDEX FOR THE PRINTER IN BX.
;**************************************************************************************************
;
      CMP       CTRL_ST_LEN,0         ;IF there is something to send to a printer THEN
      JUMP_EQUAL_TO_CHK_FOR_P
        MOV     AX,PRINTERSETUP         ;SET UP FOR PRINTER SET UP FUNCTION CALL.
        MOV     SI,OFFSET CTRL_ST       ;DS HAS SEG OF CONTROL ST. BUFFER, DS:SI POINTS TO BUFFER
        MOV     CX,CTRL_ST_LEN          ;CX GETS LENGTH OF CONTROL STRING BUFFER.
        MOV     BX,INDEX                ;BX GETS NRL INDEX OF REDIRECTED PRINTER.
        INT     21H                     ;PERFORM PRINTER SET UP.
;       $IF     C                               ;IF CARRY THERE IS A DESCREPENCY BETWEEN
        JNC $$IF1
           DISPLAY   NET_ERROR                  ;GET ASS LIST ENTRY AND PRINTER SET UP
;       $ELSE                                   ;REDIRECTOR IS RESIDENT AND PRINTER SETUP
        JMP SHORT $$EN1
$$IF1:
                                                ;CALL WAS SUCCESSFUL SO TELL USER WHAT
           CMP     EIGHTY_CHARS_LINE_REQ,TRUE      ;HAPPENED
;          $IF     E                               ;IF 80 chars/line requested THEN
           JNE $$IF3
             DISPLAY       PT80                    ;  WRITELN("LPT? set for 80")
;          $ELSE                                   ;ELSE
           JMP SHORT $$EN3
$$IF3:
              CMP   REQ_132_CHARS_LINE,TRUE
;             $IF   E                              ;  IF 132 chars/line requested THEN
              JNE $$IF5
                 DISPLAY     PT132                 ;    WRITELN("LPT? set for 132")
;             $ENDIF                               ;  ENDIF
$$IF5:
;          $ENDIF                                  ;ENDIF
$$EN3:
           CMP     PTLINES_REQ,TRUE                ;IF lines/inch requested THEN
;          $IF   E
           JNE $$IF8
              DISPLAY       PTLINES                ;  WRITELN("Printer lines per inch set")
;          $ENDIF                                  ;ENDIF
$$IF8:
;       $ENDIF                                  ;ENDIF
$$EN1:
        JMP     CHK_FOR_P                                                  ;C06
;C06    JMP     SHORT CHK_FOR_P                                         ;C00
;******************************************************************************************
; SEND THE CONTROL STRING TO THE LOCAL PRINTER

; EACH CHARACTER OF THE CONTROL STRING IS TAKEN OUT OF THE BUFFER "CTRL_ST" AND SENT TO THE
; PRINTER STARTING WITH THE FIRST CHARACTER.  ON ENTRY DI HAS THE NUMBER OF CHARACTERS IN
; THE CONTROL STRING.  SI IS USED TO INDEX INTO THE CONTROL STRING.
;******************************************************************************************
;
NOT_RED:
      CMP       IS_LOCAL,TRUE   ;IF the device is local THEN
      JE        ELSE02
        JMP     ELSE01    ;or on the network
ELSE02:
      CMP       CTRL_ST_LEN,0         ;IF there is something to send to a printer THEN
;C06     JE     CHK_FOR_P
        JNE     NO_P_CHK                                                   ;C06
        JMP     CHK_FOR_P                                                  ;C06
NO_P_CHK:                                                                  ;C06
        MOV     SI,0            ;INITIALIZE CHARACTER POSITION INDEX FOR CONTROL STRING
        PUSH    ES                                                         ;C06
        PUSH    BX                                                         ;C06
        MOV     AX,0040H                ;SETUP LOW MEMORY AREA SEGMENT     ;C06
        MOV     ES,AX                                                      ;C06
        MOV     BX,WORD PTR PT17                                           ;C06
        ADD     BX,0078H                ;GET CORRECT PRINTER TIME-OUT VALUE;C06
        MOV     AL,BYTE PTR ES:[BX]                                        ;C06
        MOV     OLD_PTR_TIMEOUT,0                                          ;C06
        CMP     AL,3                    ;DON'T CHANGE IF ALREADY LOW       ;C06
        JBE     NO_TIMEOUT_CHG                                             ;C06
        MOV     OLD_PTR_TIMEOUT,AL      ;SAVE PRINTER TIME-OUT VALUE       ;C06
        MOV     BYTE PTR ES:[BX],3      ;SET IT TO A LOW VALUE             ;C06
NO_TIMEOUT_CHG:                                                            ;C06
        POP     BX                                                         ;C06
        POP     ES                                                         ;C06
FOR:                            ;FOR each_char_in_control_string DO.  FOR DI=no_chars DOWN TO 0 DO
        DEC     CTRL_ST_LEN     ;DECREMENT LOOP COUNTER
        MOV     AH,NULL                         ;CLEAR ERROR CODE FROM AH
        MOV     AL,BYTE PTR CTRL_ST[SI]         ;MOVE NEXT CONTROL CHAR TO AL
        CALL    OUTCHR                          ;SEND THE CHARACTER TO THE PRINTER, HANDLING ERRORS
        CMP     PRINTER_ERROR,FALSE     ;EXIT LOOP IF PRINTER ERROR        ;C06
        JNE     END_OUTCHR                                                 ;C06
        INC     SI                      ;GET TO NEXT CHAR POSITION IN CONTROL STRING
        CMP     CTRL_ST_LEN,0           ;CHECK IF ALL CHARACTERS HAVE BEEN SENT
        JNE     FOR                     ;LOOP UNTIL ALL CONTROL CHARACTERS HAVE BEEN SENT
;
END_OUTCHR:                                                                ;C06
        CMP     OLD_PTR_TIMEOUT,0       ;IF TIME-OUT VALUE CHANGED         ;C06
        JZ      NO_TIMEOUT_REST                                            ;C06
        PUSH    ES                                                         ;C06
        PUSH    BX                                                         ;C06
        MOV     AX,0040H                                                   ;C06
        MOV     ES,AX                                                      ;C06
        MOV     BX,WORD PTR PT17                                           ;C06
        ADD     BX,0078H                                                   ;C06
        MOV     AL,OLD_PTR_TIMEOUT      ;RESTORE SAVED PRINTER TIMEOUT     ;C06
        MOV     BYTE PTR ES:[BX],AL                                        ;C06
        POP     BX                                                         ;C06
        POP     ES                                                         ;C06
NO_TIMEOUT_REST:                                                           ;C06
      IF_NO_PRINTER_ERROR_THEN
        CMP     EIGHTY_CHARS_LINE_REQ,TRUE      ;IF 80 chars/line requested THEN
        JNE     WAS_132_CHARS_LINE_REQ
          DISPLAY       PT80                    ;  WRITELN("LPT? set for 80")
          JMP SHORT     WAS_LINES_INCH_SPEC
        WAS_132_CHARS_LINE_REQ:                 ;ELSE
          CMP   REQ_132_CHARS_LINE,TRUE         ;  IF 132 chars/line requested THEN
          JNE   WAS_LINES_INCH_SPEC
            DISPLAY     PT132                   ;    WRITELN("LPT? set for 132")  ENDIF
        WAS_LINES_INCH_SPEC:                    ;ENDIF
        CMP     PTLINES_REQ,TRUE                ;IF lines/inch requested THEN
        JNE     LINES_NOT_REQ
          DISPLAY       PTLINES                 ;  WRITELN("Printer lines per inch set")
        LINES_NOT_REQ:                          ;ENDIF
;
;****************************************************************
;   CALL PROCEDURE TO SET THE RETRY FLAG
;****************************************************************
;
CHK_FOR_P:

public CHK_FOR_P

        CALL set_retry_type
        CALL modify_resident_code


     JMP    SHORT ENDIF01
ELSE01:

PUBLIC ELSE01

       MOV   DI,0                      ;the device name is always the first parm                                         ;AN000;
       MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]                                  ;AN000;
       MOV   BX,parm_list[DI].value1                                                     ;AN000;
       MOV  illegal_device_ptr,BX
       MOV  BYTE PTR [BX][4],0       ;AN000;chop off the string at 4, so "LPT1132" will be displayed as "LPT1"
       DISPLAY err1                   ;AN000;"Illegal device name - LPTX"
       MOV  noerror,false              ;AN000;
;    ENDIF COLON IS MISSING
ENDIF01:
;     $ENDIF ;there was a chance that the parameters were valid
;  $ENDIF ;there were enough paramters specified

   RET                        ;RETURN TO MODE MAIN ROUTINE

MODEPRIN ENDP

;******************************************************************************

modify_resident_code PROC  NEAR                                                                                            ;AN000;


        CALL LOADED_YET      ;on return ES:DI points to res copy of "modeto" if loaded
;    : :IF RESIDENT CODE IS ALREADY LOADED
        .IF Z THEN NEAR
;                    MODIFY LOADED CODE TO REFLECT WHO GETS RETRIED NOW
           MOV  BX,OFFSET lpt1_retry_type    ;BX=> first of 3 retry mask bytes                                             ;AC000;
           XOR  SI,SI    ;clear code modification index                                                     ;AN000;
           .FOR DI = 0 TO 2    ;FOR LPT1 TO LPT3 check the retry mask byte                                                ;AN000;
             .IF <<BYTE PTR ES:[BX][DI]> NE no_retry_flag> THEN    ;IF at least one type of retry on THEN         ;AN000;
                OR SI,8     ;OR in 00001000 which shifts into proper position                                              ;AN000;
             .ENDIF                                                                                                        ;AN000;
             SHR   SI,1                                                                                                    ;AN000;
           .NEXT DI       ;DI=1 or 2, SI=0,1 ,2 ,3 ,4 ,5 ,6 or 7                                             ;AN000;
           SHL  SI,1    ;SI=0, 2, 4, ... , 14, INDEX TO SHOW WHICH LPTns to be retried                                    ;AC000;
           MOV  BX,OFFRETRY     ;OFFSET TO TEST INSTR IN RETRY CODE
           CLI          ;DISABLE INTERRUPTS
           MOV  BYTE PTR ES:[BX]+4,5    ;SET JMP TARGET TO +5
           JMP  CASE[SI]        ;CALL BRANCH TABLE
;
CASE    DW      P0
        DW      P1
        DW      P2
        DW      P3
        DW      P4
        DW      P5
        DW      P6
        DW      P7
;
P0:
;                               SINCE NO PRINTER IS TO BE RETRIED
             MOV        WORD PTR ES:[BX]+3,00EBH        ;MAKE JUMP INTO NOP
;                               TO CAUSE FALL THRU TO JMP PRINTER_IO INSTR
             JMP        SHORT ENDC
;
P1:
;       RETRY LPT1 ONLY
             MOV        WORD PTR ES:[BX]+2,7403H        ;TEST 3 : JZ RT
             JMP        SHORT ENDC
;
P2:
;       RETRY LPT2 ONLY
             MOV        WORD PTR ES:[BX]+2,7501H        ;TEST 1 : JNZ RT
             JMP        SHORT ENDC
;
P3:
;       RETRY LPT1 AND LPT2 ONLY
             MOV        WORD PTR ES:[BX]+2,7402H        ;TEST 2 : JZ RT
             JMP        SHORT ENDC
;
P4:
;       REDIRECT LPT3 ONLY
             MOV        WORD PTR ES:[BX]+2,7502H        ;TEST 2 : JNZ RT
             JMP        SHORT ENDC
;
P5:
;       REDIRECT LPT1 AND LPT3 ONLY
             MOV        WORD PTR ES:[BX]+2,7401H        ;TEST 1 : JZ RT
             JMP        SHORT ENDC
;
P6:
;       REDIRECT LPT2 AND LPT3 ONLY
             MOV        WORD PTR ES:[BX]+2,7503H        ;TEST 3 : JNZ RT
             JMP        SHORT ENDC
;
P7:
;       REDIRECT ALL THREE: LPT1, LPT2, AND LPT3
             MOV        WORD PTR ES:[BX]+2,0EB00H       ;TEST 0 : JMP SHORT RT
;
ENDC:
             STI                ;REENABLE INTERRUPTS
;    : : : ENDIF RESIDENT CODE IS ALREADY LOADED
        .ENDIF

RET                                                                                                                         ;AN000;

modify_resident_code ENDP                                                                                                   ;AN000;


;**********************************************************
;FIRST_INSTR EQU 0C2F6H          ;THE FIRST INSTRUCTION OF THE LOADED CODE
;                       SEE THE RESIDENT CODE MODULE FOR ENTRY SYMBOL MODETO
;                       THE FIRST INSTRUCTION THERE IS:
;                               TEST DL,1
;                       WHICH ASSEMBLES AS:
;                               F6 C2 01


LOADED_YET PROC NEAR


;       ON EXIT, THE ZERO FLAG REFLECTS THE LOADED STATE
;       ES:DI=ADDR OF MODETO, OR ZERO
;       Z=ON, LOADED
;       Z=OFF,NOT LOADED YET
;
        PUSH    AX              ;SAVE REG
;
        SUB     AX,AX           ;ZERO A REG
        MOV     ES,AX           ;SET SEGREG TO VECTORS AT 0
        LES     DI,ES:RESSEG    ;GET ADDR OF RESIDENT CODE, IF THERE, ES:DI points to 'modeto' or is 0
        CMP     DI,0            ;see if something at 50:30
;       $IF     NE              ;IF code loaded THEN
        JE $$IF11
           CMP  AX,AX              ;SET THE ZERO FLAG TO RELFECT IT IS LOADED
;       $ELSE
        JMP SHORT $$EN11
$$IF11:
           CMP  AX,0FFH            ;RESET THE ZERO FLAG TO REFLECT IT IS NOT LOADED
;       $ENDIF
$$EN11:
;
        POP     AX              ;RESTORE CALLER'S REGS
        RET
LOADED_YET ENDP

;*******************************************************************
OUTCHR PROC NEAR
     PRINT                      ;OUTPUT CHARACTER TO PRINTER
     AND    AH,0A9H             ;MASK OFF ERROR BITS
;    IF WE GOT AN ERROR RETURN CODE
     CMP    AH,NULL
     JE    ENDIF02
;
       CMP      PRINTER_ERROR,TRUE
       JE       ALREADY_YELLED
         DISPLAY ERR2           ;DISPLAY ERROR MESSAGE
         MOV    PRINTER_ERROR,TRUE
       ALREADY_YELLED:
;    ENDIF    ,END GOT AN ERROR RETURN CODE? TEST
ENDIF02:
     RET                        ;RETURN TO MAIN PROC
OUTCHR    ENDP
;Ŀ
;                                                                             
; SET_retry_type                                                              
; --------------                                                              
;                                                                             
;  Set the resident retry mask to for all LPTs
;                                                                             
;  INPUT:  device - holds '1', '2', or '3' (ascii) for x of lptx.             
;          retry_index - holds index value for the parsed retry parameter.    
;          redirected - holds true/false value for redirected status of lptx. 
;          parm_list_holder - holds offset of parameter list.                 
;          resseg - holds offset of resident code in memory                   
;                                                                             
;                                                                             
;  RETURN:
;
;                                                                             
;                                                                             
;  MESSAGES: none
;                                                                             
;                                                                             
;  REGISTER                                                                   
;  USAGE:      AL -
;
;              CL -
;              ES -
;              BP -
;              DI -
;              DL -
;                                                                             
;                                                                             
;  PSUEDO CODE:                                                               
;
;                                                                             
;      SAVE REGISTERS                                                         
;      SET UP SEGMENT REGISTER
;      IF <RETRY REQUESTED>                                                   
;         IF <PRINTER IS REDIRECTED>                                          
;            PRINT ERROR MESSAGE - not supported on network printer.          
;         ELSE                                                                
;            SET UP PARAMETER LIST STRUCTURE                                  
;            SET BIT MASK FOR TYPE OF RETRY AND SET pparm TO PROPER LETTER    
;            LOAD RESIDENT CODE IF NEEDED                                     
;            SET AND STORE NEW lpt retry mask
;         ENDIF                                                               
;      ELSEIF <RESIDENT CODE ALREADY LOADED>                                  
;         IF <POSITIONAL PARAMETER SPECIFIED>                                 
;            SET FLAG TO ZERO, SET pparm TO PROPER LETTER                     
;         ELSE                                                                
;            SET pparm TO PROPER LETTER FOR CURRENT SETTING                   
;         ENDIF                                                               
;      ELSE                                                                   
;         SET pparm TO '-'                                                    
;      ENDIF                                                                  
;      RESTORE REGISTERS                                                      
;      RETURN                                                                 
;                                                                             
;                                                                             
;  SIDE EFFECT:
;                                                                             
;
;
set_retry_type PROC NEAR                                                                                                    ;AN663;
                                                                                                                            ;AN663;

PUSH ES                   ;save registers                                                                             ;AN663;
PUSH DI                                                                                                               ;AN663;
PUSH AX                                                                                                               ;AN663;
PUSH BX
PUSH DX                                                                                                               ;AN663;
                                                                                                                      ;AN663;
XOR  BX,BX                ;clear a reg                                                                                ;AN663;
MOV  ES,BX                ;set to segment at 0                                                                        ;AN663;
MOV  BL,device                                                                                                        ;AN663;
AND  BL,07H                                                                                                           ;AN663;
DEC  BL                    ;BX=zero based binary printer number                                           ;AN663;
                                                                                                                      ;AN663;
.IF <retry_index NE 0> THEN NEAR    ;IF retry requested on this invokation THEN                                     ;AN663;
                                                                                                                      ;AN663;
   .IF <redirected EQ true> THEN                                                                                      ;AN663;
                                                                                                                      ;AN663;
      display not_supported ;infinite retry not supported on network printer                                          ;AN663;
      jmp     srt_no_display              ;M003; Do not display retry if network printer
                                                                                                                      ;AN663;
   .ELSE NEAR                             ;not a network printer                                                      ;AN663;
                                                                                                                      ;AN663;
      MOV  DI,retry_index                                                                                             ;AN663;
      MOV  BP,parm_list_holder            ;set up addressability to the list of parsed parms,set "parm_list"          ;AN663;

      .SELECT                                                                                                         ;AN663;

         .WHEN <parm_list[DI].item_tag EQ E_item_tag>                                                                 ;AN663;
            MOV  AL,error_status         ;set mask byte to horrible status                           ;AN663;

         .WHEN <parm_list[DI].item_tag EQ P_item_tag> OR                                                              ;AN663;
         .WHEN <parm_list[DI].item_tag EQ B_item_tag>                                                         ;AN663;
            MOV  AL,busy_status          ;set mask byte to actual status                              ;AN663;

         .WHEN <parm_list[DI].item_tag EQ R_item_tag>                                             ;AN663;
            MOV  AL,ready_status         ;set mask byte to rosy status         ;AN663;

         .WHEN <parm_list[DI].item_tag EQ NONE_item_tag>                                             ;AN663;;AN000;
            MOV  AL,no_retry_flag      ;when there is no retry the mask will not be used, so this is just a flag

      .ENDSELECT

      PUSH  AX                                    ;save the retry setting ;AN001;
      .IF <AL EQ no_retry_flag> THEN
;AC001;  MOV      INF_OR_NO_PTR,OFFSET NORETRY    ;modify message to indicate no retry
         set_submessage_ptr   noretry,retparto    ;modify message to indicate no retry         ;AC001;
      .ELSE                                                                                    ;AN663;
;AC001;  MOV    INF_OR_NO_PTR,OFFSET INFINITE   ;modify message to indicate retry              ;AN663;
         set_submessage_ptr   infinite,retparto    ;modify message to indicate retry            ;AC001;
      .ENDIF                                                                                   ;AN663;
      POP   AX                                    ;restore the retry setting ;AN001;

      .IF <<WORD PTR ES:resseg> EQ 0000H> THEN    ;IF code not resident THEN                      ;AN663;
         .IF <AL NE no_retry_flag> THEN              ;need to turn on retry
            CALL modeload                            ;load resident code                          ;AN663;
            MOV  ES,ES:WORD PTR resseg[2]                                                            ;AN663;
            MOV  BYTE PTR ES:lpt1_retry_type[BX],AL      ;store new setting                    ;AN663;
         .ENDIF
      .ELSE                                       ;ELSE code is already resident
         MOV  ES,ES:WORD PTR resseg[2]                                                            ;AN663;
         MOV  BYTE PTR ES:lpt1_retry_type[BX],AL      ;store new setting                     ;AN663;
      .ENDIF                                                                                   ;AN663;
                                                                                               ;AN663;
   .ENDIF                                                                                      ;AN663;
                                                                                               ;AN663;
.ELSEIF <<WORD PTR ES:resseg> NE 0000H> THEN      ;if code is loaded but no                    ;AN663;
                                                  ;  retry is specified then                   ;AN663;
   MOV  ES,ES:WORD PTR resseg[2]                ;ES=segment of the resident code             ;AN663;
                                                                                               ;AN663;
   .IF <parms_form NE keyword>                    ;no retry specified with                     ;AN663;
                                                  ;positional parameters, so turn off retry            ;AN663;
      MOV  BYTE PTR ES:lpt1_retry_type[BX],no_retry_flag         ;set flag for get retry routine;AN663;
;AC001;      MOV   INF_OR_NO_PTR,OFFSET NORETRY          ;modify message to indicate no retry         ;AN663;
         set_submessage_ptr   noretry,retparto    ;modify message to indicate no retry         ;AC001;
                                                                                               ;AN663;
   .ELSE                                          ;else, no retry specified with keywords
                                                  ;  update pparm with current retry type      ;AN663;
      .IF <<BYTE PTR ES:lpt1_retry_type[BX]> EQ no_retry_flag> THEN                     ;AN663;
;AC001;  MOV      INF_OR_NO_PTR,OFFSET NORETRY       ;modify message to indicate no retry      ;AN663;
         set_submessage_ptr   noretry,retparto    ;modify message to indicate no retry         ;AC001;
      .ELSE                                                                                    ;AN663;
;AC001;  MOV    INF_OR_NO_PTR,OFFSET INFINITE   ;modify message to indicate retry              ;AN663;
         set_submessage_ptr   infinite,retparto    ;modify message to indicate retry            ;AC001;
      .ENDIF                                                                                   ;AN663;
                                                                                               ;AN663;
   .ENDIF                                                                                      ;AN663;
                                                                                               ;AN663;
.ELSE                                          ;no retry, no code resident                  ;AN663;
                                                                                               ;AN663;
;AC001;   MOV      INF_OR_NO_PTR,OFFSET NORETRY       ;modify message to indicate no retry            ;AN663;
   set_submessage_ptr   noretry,retparto    ;modify message to indicate no retry         ;AC001;
                                                                                               ;AN663;
.ENDIF                                                                                         ;AN663;
                         ;'Infinite retry on parallel printer timeout' OR                      ;AN663;
DISPLAY  RETPARTO        ;'No retry on parallel printer timeout'                               ;AN663;

srt_no_display:          ;M003; Do not display retry if network printer
                                                                                               ;AN663;
POP  DX                                           ;restore registers                           ;AN663;
POP  BX
POP  AX                                                                                        ;AN663;
POP  DI                                                                                        ;AN663;
POP  ES                                                                                        ;AN663;
                                                                                               ;AN663;
RET                                                                                            ;AN663;
                                                                                                     ;AN663;
set_retry_type ENDP                                                                                  ;AN663;

PRINTF_CODE   ENDS
     END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modepars.asm ===
PAGE    ,132                    ;
        TITLE   MODE COMMAND - COMMAND PARSING

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  MKS  C00  General cleanup.  Making short jumps out of long
;                      jumps, ridding of nops.
;  03/26/90  MKS  C01  Microsoft Bug #69.  Getting rid of PS2 requirements,
;                      try extended init anyway.
;  03/26/90  MKS  C02  Microsoft Bug #645.  Changed TYPE to SIZE because of
;                      an assembler bug.  MODE1132 etc. wasn't working.
;  04/25/90  JPB       Added /? options help.  parse_parm will check for
;                      /? option and call display_options_exit if found.
;                      display_options_exit will show all the lines from
;                      the options message and then exit.
;
;******************************************************************************
.XLIST                                                  ;AN000;
   INCLUDE STRUC.INC                                    ;AN000;
.LIST                                                   ;AN000;
;.SALL                                                  ;AN000;


;  P R O L O G  ͻ
;                                                                                        

;  AC001 - P3259: When "/STATUS" was only parameter was returning "Invalid
;                 number of parameters".  When "/STATUS" was first parameter
;                 the device name was not being recognized.

;  AC002 - P3258, PS/2 only COM parameters were being allowed on non-PS/2
;          P3540: machines.  Added checks for baud=19200, parity=mark or space,
;                 data=5 or 6, stop=1.5 for both keyword and positional forms.

;  AC003 - P3451: Wasn't treating semicolons as a valid blank-like delimeter.


;  AC004 - P3456: /STAT wasn't included in all checks for valid forms of /STATUS.
;                 "BW" and "CO" were being accepted as valid parms.

;  AC005 - P3796: PRN /STA returned "Invalid parameter -" when worked OK for
;                 LPT1.

;  AC006 - P3932: Was issuing "Invalid parameter - ???" for switches that are
;                 not valid, now issue "Invalid switch - ???".

;  AC007 - P3931: "CON SEL=850" acts like a status request, should return
;                 "Invalid number of parameters" because user forgot "CP".

;  AX008 - P5183: Was denying 19200 baud on PS/2 model 30s and 25s and VAILs.

;                                                                                        
;  P R O L O G  ͼ



;  M A C R O S  ͻ
;                                                                                        


BREAK   MACRO   X                                       ;AN000;
   JMP     endcase_&X                                   ;AN000;
ENDM                                                    ;AN000;

SHORTBREAK   MACRO   X                                                  ;C00
   JMP  SHORT   endcase_&X                                              ;C00
ENDM                                                                    ;C00
                                                                        ;C00
;-------------------------------------------------------------------------------

DISPLAY MACRO   MESSAGE                                 ;AN000;
        MOV     DX,MESSAGE                              ;AN000;
        CALL    PRINTF                                  ;AN000;
ENDM

;-------------------------------------------------------------------------------

check_for_lpt_keyword   MACRO            ;AN000;

MOV   DL,number_of_lpt_keywords     ;;AN000;Initialize
MOV   number_of_keywords,DL         ;;AN000;            for call to check_for_keyword
MOV   BP,OFFSET start_lpt_keyword_ptrs  ;;AN000;start_of_keyword_ptrs=[BP]
CALL  check_for_keyword                  ;AN000;

ENDM                                     ;AN000;

;
;
; DELETE_PARSER_VALUE_LIST_ENTRY
; -------------------------------
;
; As the logic in PARSE_PARAMETERS proceeds the posibilities for the next parm
; become apparent and the parser control blocks need to be changed to correctly
; parse the next parm.  This MACRO is the interface to the approptiate routine which
; modifies the list of strings or keywords in the VALUES block.
;
;
;
;
;
;  INPUT: item_type - scalar indicating that a string or keyword is to be deleted
;
;         item   - A scalar immediate that indicates the string or keyword to
;                   be "deleted"
;
;
;  RETURN: none
;
;
;  MESSAGES: none
;
;
;
;
;  REGISTER
;  USAGE:     "item" is put into BX.
;
;
;
;  CONVENTIONS:
;
;
;
;  ASSUMPTIONS: All the input are valid.
;
;
;
;
;
;
;
;
;
;
;  SIDE EFFECT:
;
;
;

delete_parser_value_list_entry   MACRO item_type,item           ;AN000;

;MOV   BX,item                          ;AN000;
CALL  item_type                        ;AN000;

ENDM                                                            ;AN000;


;-------------------------------------------------------------------------------

;
;
; MODIFY_PARSER_CONTROL_BLOCK
; ---------------------------
;
; As the logic in PARSE_PARAMETERS proceeds the posibilities for the next parm
; become apparent and the parser control blocks need to be changed to correctly
; parse the next parm.  This MACRO is the interface to the routines that modify
; those control blocks.
;
;
;
;
;
;  INPUT: control_structure - A scalar immediate indicating the control block
;                             to be modified, and the routine to call.
;
;         action - A scalar immediate that indicates the nature
;                    of the modification to be made.
;
;         item   - A scalar immediate that indicates the string, number,
;                    keywords, switch, or match flags mask involved.
;
;  RETURN: none
;
;
;  MESSAGES: none
;
;
;
;
;  REGISTER
;  USAGE:       The scalar value for the modifier will be put in a register
;               for passing to the routine that actually does the work.
;
;
;  CONVENTIONS:
;
;
;
;  ASSUMPTIONS: All the input are valid.
;
;
;  SIDE EFFECT:
;
;
;

modify_parser_control_block  MACRO    control_structure,action,item     ;AN000;

PUSH  BX                                                                ;AN000;

MOV   BX,action                           ;AN000;
MOV   AL,item                             ;AN000;
CALL  control_structure                   ;AN000;

POP   BX                                                                ;AN000;

ENDM                                                                    ;AN000;

;-------------------------------------------------------------------------------


;                                                                                        
;  M A C R O S  ͼ



;  E Q U A T E S  ͻ
;                                                                                        


INCLUDE modequat.inc


addd                 EQU   0  ;;AN000;used for "seperator_list"
binary_to_ASCII      EQU   30H      ;AN000;used to convert bytes from binary to ASCII
blank                EQU   " ";;AN000;used for "seperator_list"
both                 EQU   2        ;AN000;value of rate_and_delay_found when both have been found
comma                EQU   ","      ;AN000;used to tell the difference between a blank delimeter and missing parm, see LPTX,:
current_parm         EQU   0  ;;AN000;scalar for parser control block modifing routine "keywords"
current_parm_DI     EQU     DI      ;;AN000;index for parm_list array
delete               EQU   1  ;AN000;;used for "seperator_list"
deleted        EQU      0     ;AN000;;used to make keywords unmatchable and strings of length zero
end_of_line_char_0D  EQU   0DH      ;AN000;put at end of the command line by the loader
end_of_line_char_00  EQU   00H      ;AN000;put at end of the complex parm by the parser
i_CL                 EQU   CL       ;;AN000;loop index
include_string_list  EQU   3        ;;AN000;number of value definitions so strings are included
include_number_list  EQU   2        ;;AN000;See "nrng" in description of "values" block input for generalized parser
keyword              EQU   58H      ;;AN000;indicator parms are in keyword form vs positional, value for parms_form
first_com_keyword    EQU   SI       ;;AN000;holder for "first_com_keyword_ptr"
last_com_keyword     EQU   SI       ;;AN000;holder for "last_com_keyword_ptr"
first_LPT_keyword    EQU   SI       ;;AN000;holder for "first_LPT_keyword_ptr"
last_LPT_keyword     EQU   SI       ;;AN000;holder for "last_LPT_keyword_ptr"
first_CON_keyword    EQU   SI       ;;AN000;holder for "first_con_keyword_ptr"
last_CON_keyword     EQU   SI       ;;AN000;holder for "last_con_keyword_ptr"
max_parms            EQU   16       ;;AN000;con cp prep=((1,2,3,4,5,6,7,8,9,10,11,12) filespec.cpi)
min_codepage_value   EQU   0         ;AN000;
max_codepage_value   EQU   999      ;;AN000;three digits
max_number_of_codepages EQU   12     ;AN000;assure that user does not specify too many code page numbers
min_number_of_codepages EQU   1      ;AN000;
min_old_com_pos_parms  EQU      0    ;AN000;could have nothing else meaning status request
max_old_com_pos_parms  EQU      5    ;AN000; ;baud, parity, data bits, stop bits, P
max_switches         EQU   2  		; /STATUS and /?
no_message           EQU   0  ;AN000;indicate to message handler interface that no message to issue
none_found           EQU   0  ;AN000;;if keyword_switch_ptr is returned as zero then parser did not encounter a keyword or switch
not_in_switch_list   EQU   3        ;AC006;
number_of_printer_status_qualifiers    EQU   4  ;;AN000;codepage, prepare, select, RETRY
parm_list            EQU   [BX]                  ;AN000;
parms_BX             EQU   [BX]                  ;AN000;
parser_return_code_AX   EQU   AX                 ;AN000;
PS2                  EQU   44H                  ;AC002;flag for "type_of_machine"
result_BP            EQU   [BP]                  ;AN000;
range_item_tag       EQU   55H      ;AN000;;marker for checks in memory, otherwise just a holder
ranges_only          EQU   1  ;;AN000;See "nrng" in description of "values" block input for generalized parser
start_of_keyword_ptrs   EQU   [BP]        ;AN000;;used for indexing the list of offsets in check_for_keyword
tab                     EQU   09          ;AC006;
unspecified             EQU   0FFH        ;AN000;item tag of parm not specified: skipped optional positional parm


;possible values for "parm_type", the type of parm returned by parser

complx               EQU   4              ;AN000;
number               EQU   1              ;AN000;
string               EQU   3              ;AN000;

;possible values for "return_code_AX"

no_error             EQU   0              ;AN000;;not the same as "noerror"
operand_missing      EQU   2              ;AN000;
syntax_error_rc      EQU   9              ;AN000;
end_of_command_line  EQU   -1             ;AN000;
end_of_complex       EQU   -1             ;AN000;found 0 that parser wrote over closing ")" of complex



;possible values of "device_type"

COMX                             EQU   09CH     ;AN000;
;CON                              EQU   0       ;AN000;
LPTX                             EQU   09BH     ;AN000;
;LPT1                             EQU   0       ;AN000;


;possible values of "request_type"

max_request_type                 EQU   09AH     ;AN000;;must be same as following value
all_con_status                   EQU   09AH     ;AN000;
codepage_prepare                 EQU   099H     ;AN000;
codepage_refresh                 EQU   098H     ;AN000;
codepage_select                  EQU   097H     ;AN000;
codepage_status                  EQU   096H     ;AN000;
codepage_prepared_status         EQU   095H     ;AN000;
codepage_selected_status         EQU   094H     ;AN000;
com_status                       EQU   093H     ;AN000;
initialize_com_port              EQU   092H     ;AN000;
initialize_printer_port          EQU   091H     ;AN000;
old_initialize_printer_port      EQU   090H     ;AN000;;found traditional syntax
old_video_mode_set               EQU   08FH     ;AN000;;found traditional syntax
printer_reroute                  EQU   08EH     ;AN000;
printer_status                   EQU   08DH     ;AN000;
set_con_features                 EQU   08CH     ;AN000;
status_for_everything            EQU   08BH     ;AN000;
turn_off_reroute                 EQU   08AH     ;AN000;
last_request_type                EQU   08AH     ;AN000;;must be same as previous value


;possible codepage requests, used by modecp

select         EQU   086H                       ;AN000;
prepare        EQU   085H                       ;AN000;
refresh        EQU   084H                       ;AN000;
;status                 ;AN000;;see request_type possibilities



;possible values of "looking_for"


codepage                                          EQU     6FH           ;AN000;
codepage_prms                                     EQU     6EH           ;AN000;
com_keyword                                       EQU     6DH           ;AN000;
com_keyword_or_baud                               EQU     6CH           ;AN000;
CON_keyword                                       EQU     6BH           ;AN000;
con_kwrd_status_or_cp                             EQU     6AH           ;AN000;
databits_or_null                                  EQU     69H           ;AN000;
device_name_or_eol                                EQU     68H           ;AN000;
eol                                               EQU     67H   ;;AN000;end of line
first_parm                                        EQU     66H    ;AN000;
li_or_null                                        EQU     65H    ;AN000;
P                                                 EQU     64H    ;AN000;
parity_or_null                                    EQU     63H    ;AN000;
prn_kw_status_cp_cl_null                          EQU     62H    ;AN000;
sd_or_dl                                          EQU     61H    ;AN000;
sd_or_dl_or_eol                                   EQU     60H    ;AN000;
status_or_eol                                     EQU     5FH    ;AN000;
stopbits_or_null                                  EQU     5EH    ;AN000;
T_or_EOL                                          EQU     5DH    ;AN000;

max_looking_for     EQU     6FH     ;AN000;;used for calculating the displacement into jump table for "CASE looking_for="




;item tags for COM port names strings

COM1_item_tag        EQU   1           ;;AN000;these values must be 1 through 4 because
COM2_item_tag        EQU   2           ;;AN000;parsing for COM special cases depends
COM3_item_tag        EQU   3           ;;AN000;on it.
COM4_item_tag        EQU   4

;item tags for paritys

first_parity_item_tag   EQU   86H       ;AN000;
mark_item_tag           EQU   86H       ;AN000;
space_item_tag          EQU   85H       ;AN000;
none_item_tag           EQU   84H       ;AN000;
odd_item_tag            EQU   83H       ;AN000;
even_item_tag           EQU   82H       ;AN000;
last_parity_item_tag    EQU   82H       ;AN000;


;item tags for printer port names

PRN_item_tag         EQU   5            ;AN000;
LPT1_item_tag        EQU   6            ;AN000;
LPT2_item_tag        EQU   7            ;AN000;
LPT3_item_tag        EQU   8            ;AN000;

;item tags for screen modes

first_screen_mode_item_tag    EQU   9   ;AN000;
BW40_item_tag        EQU   0BH          ;AN000;
BW80_item_tag        EQU   0CH          ;AN000;
CO40_item_tag        EQU   0DH          ;AN000;
CO80_item_tag        EQU   0EH          ;AN000;
eighty_item_tag      EQU   0FH          ;AN000;
fourty_item_tag      EQU   10H          ;AN000;
MONO_item_tag        EQU   11H          ;AN000;
last_screen_mode_item_tag     EQU   11H ;AN000;

con_item_tag         EQU   12H          ;AN000;


;item tags for LPT special cases

first_lpt_special_case_item_tag  EQU   13H   ;;AN000;following value must be the same as this one
LPT1132_item_tag     EQU   13H                ;AN000;
LPT2132_item_tag     EQU   14H                ;AN000;
LPT3132_item_tag     EQU   15H                ;AN000;
LPT180_item_tag      EQU   16H                ;AN000;
LPT280_item_tag      EQU   17H                ;AN000;
LPT380_item_tag      EQU   18H                ;AN000;
last_lpt_special_case_item_tag   EQU   18H   ;;AN000;this value must be the same as the previous

P_item_tag           EQU   19H                ;AN000;
RETRY_item_tag       EQU   1AH                ;AN000;
B_item_tag           EQU   1BH                ;AN000;
E_item_tag           EQU   1CH                ;AN000;
R_item_tag           EQU   1DH                ;AN000;

codepage_item_tag    EQU   1EH            ;;AN000;for the range defining codepage possibilities
PREPARE_item_tag     EQU   1FH             ;AN000;
SELECT_item_tag      EQU   20H             ;AN000;
REFRESH_item_tag     EQU   21H             ;AN000;

COLUMNS_item_tag     EQU   23H             ;AN000;
DELAY_item_tag       EQU   24H             ;AN000;
LINES_item_tag       EQU   25H             ;AN000;
RATE_item_tag        EQU   26H             ;AN000;

COM_item_tag         EQU   27H             ;AN000;

ON_item_tag          EQU   28H             ;AN000;
OFF_item_tag         EQU   29H             ;AN000;

L_item_tag           EQU   2AH             ;AN000;
T_item_tag           EQU   2BH             ;AN000;

;item tags for numbers not in other lists

zero_item_tag                  EQU  2CH    ;AN000;
first_stopbit_item_tag         EQU  2DH    ;AN000;
one_item_tag                   EQU  2EH    ;AN000;
one_point_five_item_tag        EQU  2FH    ;AN000;
two_item_tag                   EQU  30H    ;AN000;
last_stopbit_item_tag          EQU  31H    ;AN000;
three_item_tag                 EQU  32H    ;AN000;
four_item_tag                  EQU  33H    ;AN000;
first_databit_item_tag         EQU  34H    ;AN000;
five_item_tag                  EQU  35H    ;AN000; ;data bit, typamatic rate
six_item_tag                   EQU  36H    ;AN000;
seven_item_tag                 EQU  37H    ;AN000;
eight_item_tag                 EQU  38H    ;AN000;
last_databit_item_tag          EQU  39H    ;AN000;
nine_item_tag                  EQU  3AH    ;AN000;
ten_item_tag                   EQU  3BH    ;AN000;
eleven_item_tag                EQU  3CH    ;AN000;;first two chars of 110
twelve_item_tag                EQU  3DH    ;AN000;
thirteen_item_tag              EQU  3EH    ;AN000;
fourteen_item_tag              EQU  3FH    ;AN000;
fifteen_item_tag               EQU  40H    ;AN000;;abbreviated form of 150, 15 is also a RATE= candidate
sixteen_item_tag               EQU  41H    ;AN000;
seventeen_item_tag             EQU  42H    ;AN000;
eighteen_item_tag              EQU  43H    ;AN000;
nineteen_item_tag              EQU  44H    ;AN000;;used for baud rates and RATE=
twenty_item_tag                EQU  45H    ;AN000;
twentyone_item_tag             EQU  46H    ;AN000;
twentytwo_item_tag             EQU  47H    ;AN000;
twentythree_item_tag           EQU  48H    ;AN000;
twentyfour_item_tag            EQU  49H    ;AN000;    ;24 is also a typamatic rate
twentyfive_item_tag            EQU  4AH    ;AN000;
twentysix_item_tag             EQU  4BH    ;AN000;
twentyseven_item_tag           EQU  4CH    ;AN000;
twentyeight_item_tag           EQU  4DH    ;AN000;
twentynine_item_tag            EQU  4EH    ;AN000;
thirty_item_tag                EQU  4FH    ;AN000;
thirtyone_item_tag             EQU  50H    ;AN000;
thirtytwo_item_tag             EQU  51H    ;AN000;
fourtythree_item_tag           EQU  52H    ;AN000;
fifty_item_tag                 EQU  53H    ;AN000;
sixty_item_tag                 EQU  54H    ;AN000;
oneten_item_tag                EQU  55H    ;AN000;
onethirtytwo_item_tag          EQU  56H    ;AN000;
onefifty_item_tag              EQU  57H    ;AN000;
threehundred_item_tag          EQU  58H    ;AN000;
sixhundred_item_tag            EQU  59H    ;AN000;
twelvehundred_item_tag         EQU  5AH    ;AN000;
twentyfourhundred_item_tag     EQU  5BH    ;AN000;
fourtyeighthundred_item_tag    EQU  5CH    ;AN000;
ninetysixhundred_item_tag      EQU  5DH    ;AN000;
nineteentwohundred_item_tag    EQU  5EH    ;AN000;


;mask values for function_flags

capitalize     EQU   0001H     ;AN000;capitalize by file table


;mask values for match flags

numeric        EQU   8000H                 ;AN000;
simple_string  EQU   2000H                 ;AN000;
complex        EQU   0400H                 ;AN000;
filespec       EQU   0200H                 ;AN000;
ignore_colon   EQU   0010H                 ;AN000;
optional       EQU   0001H                 ;AN000;
clear_all      EQU   0000H                 ;AN000;

;delete_simple_string    EQU   0CFFFH   ;AN000;;NOT (simple_string), to turn off simple_string bit in the match_flags




;                                                                                        
;  E Q U A T E S  ͼ



;  S T R U C T U R E S  ͻ
;                                                                                        


des_strt_packet   STRUC
   des_strt_pkfl  DW    0000           ;assume a filename specified
   des_strt_pklen DW    02             ;start with size of 'des_strt_pknum'
   des_strt_pknum DW    0              ;number of cp numbers in the packet
   des_strt_pkcp1 DW    -1             ;code page number for 1st slot
   des_strt_pkcp2 DW    -1
   des_strt_pkcp3 DW    -1
   des_strt_pkcp4 DW    -1
   des_strt_pkcp5 DW    -1
   des_strt_pkcp6 DW    -1
   des_strt_pkcp7 DW    -1
   des_strt_pkcp8 DW    -1
   des_strt_pkcp9 DW    -1
   des_strt_pkcpA DW    -1
   des_strt_pkcpB DW    -1
   des_strt_pkcpC DW    -1             ;code page number for 12th slot
des_strt_packet   ENDS


INCLUDE  COMMON.STC     ;contains the following strucs, needed in invoke also


;parm_list_entry   STRUC
;
;parm_type            DB       bogus
;item_tag             DB       0FFH
;value1               DW       bogus
;value2               DW       bogus
;keyword_switch_ptr   DW    0
;
;parm_list_entry   ENDS


;codepage_parms STRUC
;   cp_device      DW    ?
;   des_pack_ptr   DW    ?
;   font_filespec  DW    ?
;   request_typ    DW    ?
;codepage_parms ENDS


parms_def      STRUC                      ;AN000;

parmsx_ptr        DW      bogus           ;AN000;changed as the possibilities for parms following are determined
                  DB      1               ;AN000;have extra delimiter list
seperators_len    DB      1               ;AN000;length of extra delimiter list
seperators        DB      ";"             ;AC003;EXTRA DELIMITER LIST
                  DB      8 DUP (" ")     ;AC003; extra blanks for adding more delimeters (. " \ [ ] : + =)

parms_def      ENDS                       ;AN000;



result_def     STRUC                      ;AN000;

ret_type  DB       0                      ;AN000;
ret_tag   DB       0FFH                   ;AN000;
synonym   DW       0                      ;AN000;
ret_value1 DW       bogus                 ;AN000;
ret_value2 DW       bogus                 ;AN000;

result_def     ENDS                       ;AN000;







;                                                                                        
;  S T R U C T U R E S  ͼ



        PAGE                                                    ;AN000;
PRINTF_CODE SEGMENT PUBLIC                                      ;AN000;
        ASSUME  CS:PRINTF_CODE,DS:PRINTF_CODE,SS:PRINTF_CODE    ;AN000;


;  P U B L I C S  ͻ
;                                                                                        

PUBLIC   all_con_status                                         ;AN000;
PUBLIC   baud_equal                                             ;AN000;
PUBLIC   B_item_tag        ;needed by modecom                   ;AN000;
PUBLIC   B_str                                                  ;AN000;
PUBLIC   BW40_item_tag                                          ;AN000;
PUBLIC   BW80_item_tag                                          ;AN000;
PUBLIC   codepage_index_holder      ;make available to invoke   ;AN000;
PUBLIC   codepage_item_tag                                      ;AN000;
PUBLIC   codepage_prepare                                       ;AN000;
PUBLIC   codepage_prepared_status                               ;AN000;
PUBLIC   codepage_refresh                                       ;AN000;
PUBLIC   codepage_selected_status                               ;AN000;
PUBLIC   COM_status                                             ;AN000;
PUBLIC   COMX                       ;make available to rescode  ;AN000;
PUBLIC   CON_str              ;AN000;make available to invoke for messages
PUBLIC   CO40_item_tag        ;AN000;
PUBLIC   CO80_item_tag        ;AN000;
PUBLIC   codepage_item_tag    ;AN000;
PUBLIC   codepage_select      ;AN000;
PUBLIC   codepage_status      ;AN000;
PUBLIC   columns_equal        ;AN000;
PUBLIC   COLS_equal           ;AN000;
PUBLIC   columns_item_tag     ;AN000;
PUBLIC   COM1_str             ;AN000;
PUBLIC   COM2_str             ;AN000;
PUBLIC   COM3_str             ;AN000;
PUBLIC   COM4_str             ;AN000;
PUBLIC   data_equal           ;AN000;used by invoke
PUBLIC   delay_equal          ;AN000;
PUBLIC   del_equal            ;AN000;
PUBLIC   des_start_packet     ;AN000;
PUBLIC   device_name          ;AN000;
PUBLIC   device_type          ;AN000;make available to rescode
PUBLIC   E_item_tag                 ;needed by modecom          ;AN000;
PUBLIC   E_str                ;AN000;
PUBLIC   eight_item_tag       ;AN000;used by setcom
PUBLIC   eighty_item_tag      ;AN000;
PUBLIC   eighty_str           ;AN000;
PUBLIC   even_item_tag        ;AN000;used by setcom
PUBLIC   five_item_tag        ;AN000;used in setcom
PUBLIC   fourtyeighthundred_item_tag      ;used by setcom;AN000;
PUBLIC   fourtyeighthundred_str           ;used by setcom;AN000;
PUBLIC   fourty_item_tag                                 ;AN000;
PUBLIC   fourty_str                                      ;AN000;
PUBLIC   initialize_com_port                             ;AN000;
PUBLIC   initialize_printer_port                         ;AN000;
PUBLIC   keyword              ;AN000;make available to invoke.asm
PUBLIC   len_COMX_str         ;AN000;make available to invoke.asm
PUBLIC   len_CON_str          ;AN000;make available to invoke.asm for message service
PUBLIC   len_LPTX_str         ;AN000;make available to invoke.asm
PUBLIC   lines_equal          ;AN000;
PUBLIC   lines_item_tag       ;AN000;
PUBLIC   L_item_tag           ;AN000;
PUBLIC   LPTX                 ;AN000;make available to rescode
PUBLIC   LPT1_str             ;AN000;
PUBLIC   LPT2_str             ;AN000;
PUBLIC   LPT3_str             ;AN000;
PUBLIC   mark_item_tag        ;AN000;used in setcom
PUBLIC   max_request_type     ;AN000;
PUBLIC   mono_item_tag        ;AN000;
PUBLIC   new_com_initialize               ;AC002;make available for modecom
PUBLIC   nineteentwohundred_item_tag       ;AN000;used by modecom
PUBLIC   nineteentwohundred_str            ;AN000;used by modecom
PUBLIC   ninetysixhundred_item_tag         ;AN000;
PUBLIC   ninetysixhundred_str ;AN000;
PUBLIC   none_item_tag        ;AN000;used in invoke
PUBLIC   NONE_str             ;AN000;
PUBLIC   OFF_item_tag         ;AN000;
PUBLIC   OFF_str              ;AN000;
PUBLIC   odd_item_tag         ;AN000;  ;used by setcom
PUBLIC   old_initialize_printer_port   ;AN000;
PUBLIC   old_video_mode_set            ;AN000;
PUBLIC   one_item_tag               ;used in setcom     ;AN000;
PUBLIC   one_point_five_item_tag    ;used in setcom     ;AN000;
PUBLIC   one_point_five_str         ;used in setcom     ;AN000;
PUBLIC   onefifty_item_tag          ;used in setcom     ;AN000;
PUBLIC   onefifty_str               ;used in setcom     ;AN000;
PUBLIC   oneten_item_tag            ;used in modecom    ;AN000;
PUBLIC   oneten_str                 ;used in modecom    ;AN000;
PUBLIC   onethirtytwo_item_tag                          ;AN000;
PUBLIC   ON_item_tag                                    ;AN000;
PUBLIC   ON_str                                         ;AN000;
PUBLIC   P_item_tag                 ;make available to modecom  ;AN000;
PUBLIC   parity_equal               ;used in analyze_and_invoke ;AN000;
PUBLIC   parm_lst                   ;used in modecom.asm        ;AN000;
PUBLIC   parms_form                 ;make available to invoke   ;AN000;
PUBLIC   parse_parameters                                       ;AN000;
PUBLIC   prepare                                                ;AN000;
PUBLIC   prepare_item_tag                                       ;AN000;
PUBLIC   printer_reroute                                        ;AN000;
PUBLIC   printer_status                                         ;AN000;
PUBLIC   R_item_tag                                             ;AN000;
PUBLIC   R_str                                                  ;AN000;
PUBLIC   rate_equal                                             ;AN000;
PUBLIC   refresh                                                ;AN000;
PUBLIC   request_type                                           ;AN000;
PUBLIC   reroute_requested            ;make available to rescode;AN000;
PUBLIC   retry_equal_str               ;make available to invoke;AN000;
PUBLIC   retry_item_tag                                         ;AN000;
PUBLIC   retry_requested            ;make available to rescode  ;AN000;
PUBLIC   select                                                 ;AN000;
PUBLIC   select_item_tag                                        ;AN000;
PUBLIC   set_con_features                                       ;AN000;
PUBLIC   seven_item_tag             ;used by setcom             ;AN000;
PUBLIC   sixhundred_item_tag        ;used by setcom             ;AN000;
PUBLIC   sixhundred_str             ;used by setcom             ;AN000;
PUBLIC   six_item_tag               ;used by setcom             ;AN000;
PUBLIC   space_item_tag             ;used by setcom             ;AN000;
PUBLIC   status_for_everything                                  ;AN000;
PUBLIC   stop_equal                                             ;AN000;
PUBLIC   T_item_tag                                             ;AN000;
PUBLIC   threehundred_item_tag      ;used by setcom             ;AN000;
PUBLIC   threehundred_str           ;used by setcom             ;AN000;
PUBLIC   turn_off_reroute                                       ;AN000;
PUBLIC   twelvehundred_item_tag      ;used by setcom            ;AN000;
PUBLIC   twelvehundred_str           ;used by setcom            ;AN000;
PUBLIC   twentyfourhundred_item_tag      ;used by setcom        ;AN000;
PUBLIC   twentyfourhundred_str           ;used by setcom        ;AN000;
PUBLIC   two_item_tag               ;used by setcom             ;AN000;

;                                                                                        
;  P U B L I C S  ͼ


;  E X T R N S  ͻ
;                                                                                        

;EXTRN   command_line:BYTE               ;AN000;PARM AREA
;EXTRN   command_line_length:BYTE        ;AN000;NUMBER OF BYTES OF PARM AREA
EXTRN   com1_or_com2:BYTE           ;AN000;see modedefs.inc
EXTRN   cp_cb:WORD            ;AN000;codepage_parms <> ;codepage subroutine parameter block
EXTRN   CRLF:WORD                      ;displayed before "Invalid parameter - " for consistent spacing                      ;AN000;
EXTRN   DES_STRT_FL_CART:ABS                 ;AN000;;CARTRIDGE prepare
EXTRN   device:BYTE                    ;AN000;holder for com number, used in setcom
EXTRN   first_char_in_command_line:BYTE ;AN000;location of the command line parameters
EXTRN    function_not_supported:BYTE   ;AN000;see modedefs.inc
EXTRN   get_machine_type:NEAR           ;AN000;get model and sub-model bytes
EXTRN   invalid_parameter:BYTE          ;AN000;CR,LF,"Invalid parameter - '????'"CR,LF,BEEP
EXTRN   LPTNO:BYTE            ;AN000;holder of ASCII version of printer number, see first_parm_case and modeprin
EXTRN   machine_type:BYTE           ;AN000;see get_machine_type
EXTRN   modecp:NEAR                 ;AN000;
EXTRN   move_destination:ABS        ;AN000;location of res code after it has been moved
EXTRN   noerror:BYTE        ;AN000;
EXTRN    not_supported_ptr:WORD     ;AN000;holder of address of string that describes what is not supported, see modedefs.inc
EXTRN    offending_parameter:BYTE         ;AC006;the holder of the text string that was wrong.
EXTRN   offending_parameter_ptr:WORD       ;AN000;;see MODEMES
EXTRN   printer_no:BYTE                ;AN000;;see modeprin
EXTRN   PRINTF:NEAR                    ;AN000;
EXTRN   rate_and_delay_together:BYTE   ;AN000;RATE and DELAY must be specified together
EXTRN    syntax_error_ptr:WORD         ;AN000;pointer to parameter with bad format

;possible values of "message"

EXTRN   baud_rate_required:BYTE        ;AN000;
EXTRN   invalid_number_of_parameters:WORD    ;AN000;
EXTRN   Invalid_switch:BYTE
EXTRN	MSG_OPTIONS_LAST	: ABS
EXTRN	options_msg	: BYTE
EXTRN   syntax_error:BYTE

;                                                                                        
;  E X T R N S  ͼ


;  D A T A  ͻ
;                                                                                        

code_page_numbers_encountered    DB    0
current_packet_cp_number   DW    -2  ;adjustment for accessing current 'des_strt_pkcp?' in 'des_start_packet'
EOL_found               DB       false
looking_for             DB       bogus    ;semantic analysis state, can be one of:
match_not_found         DB       true     ;indication that a token was found in the list of keywords



des_start_packet        des_strt_packet <>

;----------------------------      NEW DATA  ---------------------------------



baud_specified          DB    false       ;AN000;
codepage_index_holder   DW    bogus       ;AN000;;holder for index in parm_list of the selected code page
colon                   DB    ":"         ;AN000;
command_line            DW    0081H       ;AN000;  ;holder for pointer to unparsed part of the command line, see "parse_parm"
device_name             DW    0           ;AN000;;OFFSET device name string, see "analyze_and_invoke" in invoke.asm
device_type             DB    bogus       ;AN000;
end_of_seperator_list   DW    bogus       ;AN000;;loop terminator,word because compared with DI
match_found             DB    false       ;AN000;   ;boolean loop terminator
message                 DW    no_message  ;AN000;
new_com_initialize      DB    false       ;AC002;flag for modecom to indicate PS/2 only parm specified
number_of_keywords      DB    0           ;AN000;;input for check_for_keyword
parms_form              DB    0           ;AN000;;holder for indicator of whether the parms were in keyword or positonal form
ordinal                 DW    0           ;AN000;
rate_and_delay_found    DB    false       ;AN000;need to have both, this byte keeps track of what has been found
request_type            DB    bogus       ;AN000;
reroute_requested       DB    false       ;AN000;
retry_requested         DB    false       ;AN000;
search_stop             DB    0           ;AN000;;loop stopper for search_item_tags
status_found            DB    false       ;AN000;;boolean indicator that /status has been found
status_request          DB    bogus       ;AN000;;furthur clarification. possible values are: bogus, true, and false
terminating_delimeter   DB    bogus       ;AN000;;save return from sysparse
type_of_machine         DB    bogus       ;AC000;"get_machine_type" determines "machine_type", this byte is general flag for PS/2s


;       PARSER interface data
;---------------------------------------

start_com_keyword_ptrs  LABEL WORD                      ;AN000;
first_com_keyword_ptr   DW    OFFSET   baud_equal       ;AN000;
                        DW    OFFSET   parity_equal     ;AN000;
                        DW    OFFSET   data_equal       ;AN000;
                        DW    OFFSET   stop_equal       ;AN000;
last_com_keyword_ptr    DW    OFFSET   retry_equal_str      ;AN000;
number_of_com_keywords  EQU   ($ - start_com_keyword_ptrs)/2    ;AN000;


start_LPT_keyword_ptrs  LABEL WORD                      ;AN000;
first_LPT_keyword_ptr   DW    OFFSET   retry_equal_str      ;AN000;
                        DW    OFFSET   COLUMNS_equal    ;AN000;
                        DW    OFFSET   COLS_equal       ;AN000;
last_LPT_keyword_ptr    DW    OFFSET   LINES_equal      ;AN000;
number_of_LPT_keywords  EQU   ($ - start_LPT_keyword_ptrs)/2    ;AN000;


start_CON_keyword_ptrs  LABEL WORD                      ;AN000;
first_CON_keyword_ptr   DW    OFFSET   COLUMNS_equal    ;AN000;
                        DW    OFFSET   COLS_equal       ;AN000;
                        DW    OFFSET   LINES_equal      ;AN000;
                        DW    OFFSET   RATE_equal       ;AN000;
                        DW    OFFSET   DELAY_equal      ;AN000;
last_CON_keyword_ptr    DW    OFFSET   DEL_equal        ;AN000;
number_of_CON_keywords  EQU   ($ - start_CON_keyword_ptrs)/2    ;AN000;



parms    parms_def<>             ;AN000;set up for first_parm_case, except parmsx_ptr needs to be set


parmsx   LABEL  BYTE             ;AN000;

   DB       0                  ;AN000;how many non-switch/non-keyword parms are required
   DB       3                  ;AN000;max pos parms for this parmsx, use others for further parms
   DW       first_pos_control  ;AN000;control block for every possible (non-mutatant) first positional parm
   DW       second_pos_control ;AN000;
   DW       third_pos_control  ;AN000;

   DB       max_switches                  ;AN000;
   DW       Sw_control			;AN000;
   DW       Sw_Options

   DB       max_keywords         ;AN000;number of unique keywords for all options

start_keyword_list   LABEL BYTE  ;AN000;

   DW       LPT1_colon_equal_control   ;AN000;
   DW       LPT1_equal_control         ;AN000;
   DW       LPT2_colon_equal_control   ;AN000;
   DW       LPT2_equal_control         ;AN000;
   DW       LPT3_colon_equal_control   ;AN000;
   DW       LPT3_equal_control         ;AN000;

   DW       RETRY_equal_control  ;AN000;for parallel and serial printers

   DW       COLUMNS_equal_control   ;AN000;
   DW       LINES_equal_control     ;AN000;;this and previous MUST OCCUR IN THIS ORDER
   DW       PREPARE_equal_control   ;AN000;
   DW       SELECT_equal_control    ;AN000;

max_keywords   EQU   ($ - start_keyword_list) / 2   ;AN000;two bytes per entry



con_parmsx   LABEL  BYTE             ;AN000;for keyword form of con support

   DB       0                  ;AN000;no positional parms required after CON
   DB       2                  ;AN000;CP and REFRESH allowed
   DW       first_CON_pos_control    ;AN000;control block for CP
   DW       second_CON_pos_control  ;AN000;control block for REFRESH

   DB       max_switches                  ;AN000;
   DW       Sw_control			; AN000;
   DW       Sw_Options

   DB       number_of_CON_keywords         ;AN000;number of unique keywords for CON

start_con_keyword_list   LABEL BYTE  ;AN000;

   DW       COLUMNS_equal_control   ;AN000;
   DW       LINES_equal_control     ;AN000;
   DW       PREPARE_equal_control   ;AN000;
   DW       SELECT_equal_control    ;AN000;

   DW       DELAY_equal_control     ;AN000;
   DW       RATE_equal_control      ;AN000;

number_of_con_keywords   EQU   ($ - start_con_keyword_list) / 2   ;AN000;two bytes per entry


old_con_parmsx   LABEL  BYTE             ;AN000;

   DB       0                  ;AN000;no positional parms required after 80, co40 etc.
   DB       2                  ;AN000;shift direction and "T" allowed
   DW       first_old_CON_pos_control    ;AN000;shift direction and display lines
   DW       second_old_CON_pos_control  ;AN000;control block for T

   DB       0                             ;AN000;no switches

   DB       0                             ;AN000;no keywords for old CON


lpt_parmsx   LABEL  BYTE             ;AN664;for the second thru 4th parms, [[chars/line][[,lines/inch][[,P]]]]

   DB       0                  ;AN000;how many non-switch/non-keyword parms are required
   DB       3                  ;AN000;max pos parms for this parmsx, use others for further parms
   DW       first_lpt_pos_control  ;AN000;control block for every possible chars per line value
   DW       second_lpt_pos_control ;AN000;
   DW       third_lpt_pos_control  ;AN000;

   DB       max_switches                  ;AN000;
   DW       Sw_control                    ;AN000;
   DW       Sw_Options

   DB       max_lpt_keywords         ;AN000;number of unique keywords for all options

start_lpt_keyword_list   LABEL BYTE  ;AN000;

   DW       RETRY_equal_control  ;AN000;for parallel printers

   DW       COLUMNS_equal_control   ;AN000;
   DW       LINES_equal_control     ;AN000;;this and previous MUST OCCUR IN THIS ORDER
   DW       PREPARE_equal_control   ;AN000;
   DW       SELECT_equal_control    ;AN000;

max_lpt_keywords   EQU   ($ - start_keyword_list) / 2   ;AN000;two bytes per entry


prepare_equal_parmsx LABEL BYTE                                 ;AN000;

   prepare_min_parms LABEL BYTE                                 ;AN000;changed by hardware cp code to allow no filename
   DB       min_number_of_codepages                             ;AN000;
   DB       max_number_of_codepages                             ;AN000;
   DW       max_number_of_codepages DUP (prepare_equal_control) ;AN000;
   DB       max_switches                                        ;AN000;
   DW       Sw_control                                          ;AN000;
   DW       Sw_Options
   DB       0                             ;AN000;no more keywords allowed

com_parmsx   LABEL  BYTE                                        ;AN000;

                    DB       min_old_com_pos_parms      ;AN000;nothing or /STATUS
                    DB       max_old_com_pos_parms      ;AN000;baud, parity, data, stop, p
                    DW       baud_control               ;AN000;
                    DW       old_com_parity_control     ;AN000;
                    DW       old_com_databits_control   ;AN000;control block for old com data bits
                    DW       old_com_stopbits_control   ;AN000;
retry_control_ptr   DW       old_com_retry_control      ;AN000;

                    DB       max_switches                                ;AN000;
                    DW       Sw_control                                  ;AN000;
                    DW       Sw_Options

                    DB       number_of_com_keywords                      ;AN000;

start_com_keyword_list   LABEL BYTE                     ;AN000;

                    DW       BAUD_control                                ;AN000;
                    DW       PARITY_equal_control                        ;AN000;
                    DW       DATA_equal_control                          ;AN000;
                    DW       STOP_equal_control                          ;AN000;
                    DW       RETRY_equal_control        ;AN000;same as for printers

number_of_com_keywords   EQU   ($ - start_com_keyword_list) / 2  ;AN000;two bytes per entry


com_keywords_parmsx   LABEL  BYTE                        ;AC663;

   DB       0                          ;AC663;no positional parms valid
   DB       0                          ;AC663;

   DB       0                                           ;AC663;

   DB       number_of_com_keywords                      ;AC663;

   DW       BAUD_control                                ;AC663;
   DW       PARITY_equal_control                        ;AC663;
   DW       DATA_equal_control                          ;AC663;
   DW       STOP_equal_control                          ;AC663;
   DW       RETRY_equal_control        ;AC663;same as for printers



mutant_com_parmsx   LABEL  BYTE              ;AN000;for trash like COM19600

   DB     2                         ;AN000;;must find "COM" and a baud rate
   DB     2                         ;AN000;;"COM", baud
   DW     COM_control               ;AN000;
   DW     baud_control      ;AN000;use same as other com parmsx

   DB       0                          ;AN000;no switches

   DB       0                          ;AN000;no keywords

com_control  LABEL BYTE                ;AN000;for mutant_com_parmsx

               DW       simple_string    ;AN000;"COM", not optional
               DW       0                 ;AN000;don't capitalize, leave colon
               DW       result            ;AN000;
               DW       com_value         ;AN000;
               DB       0                 ;AN000;no synonyms



old_com_parity_control  LABEL BYTE        ;AC000;

               DW       simple_string+optional  ;AC000;n, o, e are strings
               DW       0                       ;AC000;don't capitalize, leave colon
               DW       result                  ;AC000;
               DW       PARITY_values           ;AC000;
               DB       0                       ;AC000;;no synonyms


old_com_DATAbits_control   LABEL BYTE           ;AC000;

               DW       simple_string+optional  ;AC000;
               DW       0                       ;AC000;;don't capitalize, leave colon
               DW       result                  ;AC000;
               DW       DATA_values             ;AC000;
               DB       0                       ;AC000;



old_com_STOPbits_control   LABEL BYTE           ;AC000;

               DW       simple_string+optional  ;AC000;
               DW       0                       ;AC000;;don't capitalize, leave colon
               DW       result                  ;AC000;
               DW       STOP_values             ;AC000;
               DB       0                       ;AC000;



old_com_RETRY_control   LABEL BYTE              ;AC000;

               DW       simple_string+optional  ;AC000;;all that is legal for RETRY is P for old com format
               DW       0                       ;AC000;;don't capitalize, never need to display to user
               DW       result                  ;AC000;
               DW       RETRY_values            ;AC000;
               DB       0                       ;AC000;


com_value    LABEL    BYTE           ;AC000;"COM" for mutant_com_parmsx

   DB       include_string_list      ;AC000;have list of strings

   DB       0                        ;AC000;

   DB       0                        ;AC000;no number choices

   DB       1                        ;AC000;just "COM"

   DB       COM_item_tag             ;AC000;
   DW       OFFSET COM_str           ;AC000;


first_pos_control  LABEL BYTE                ;AN000;initialized for first_parm_case

match_flags    DW       simple_string+optional   ;***  +ignore_colon  *** ;AN000;2011, all that is legal for non-/status first parm
function_flags DW       0010H                   ;AN000;don't capitalize, remove colon at end
               DW       result                  ;AN000;
values_ptr     DW       first_pos_values        ;AN000;
               DB       0                    ;AN000;no keywords as positionals


second_pos_control  LABEL BYTE                ;AN000;initialized for first_parm_case

match_flags2      DW       simple_string+optional+ignore_colon  ;AN000;2011, all that is legal for non-/status first parm
function_flags2   DW       0010H                   ;AN000;don't capitalize, remove colon at end
                  DW       result               ;AN000;
values_ptr2       DW       second_pos_values    ;AN000;
                  DB       0                    ;AN000;;no keywords as positionals

third_pos_control  LABEL BYTE                ;AN000;initialized for first_parm_case

match_flags3      DW       simple_string+optional+ignore_colon  ;AN000;2011, all that is legal for non-/status first parm
function_flags3   DW       0010H                   ;AN000;don't capitalize, remove colon at end
                  DW       result               ;AN000;
values_ptr3       DW       third_pos_values     ;AN000;
                  DB       0                    ;AN000;;no keywords as positionals

first_lpt_pos_control  LABEL BYTE                ;AN000;chars per line

               DW       simple_string+optional  ;AN000;2001, all that is legal for chars per line
               DW       0000H                   ;AN000;don't capitalize
               DW       result                  ;AN000;
               DW       first_lpt_pos_values    ;AN000;
               DB       0                    ;AN000;no keywords as positionals


second_lpt_pos_control  LABEL BYTE                ;AN000;lines per inch

                  DW       simple_string+optional  ;AN000;2001, all that is legal for chars per line
                  DW       0000H                   ;AN000;don't capitalize
                  DW       result               ;AN000;
                  DW       second_lpt_pos_values    ;AN000;
                  DB       0                    ;AN000;;no keywords as positionals

third_lpt_pos_control  LABEL BYTE                ;AN000;P

                  DW       simple_string+optional  ;AN000;2001, all that is legal for retry settings
                  DW       0000H                   ;AN000;don't capitalize
                  DW       result               ;AN000;
                  DW       third_lpt_pos_values     ;AN000;
                  DB       0                    ;AN000;;no keywords as positionals



BAUD_control  LABEL BYTE                  ;AN000;used for positional and keyword form

               DW       simple_string     ;AN000;required
               DW       0                       ;AN000;don't capitalize
               DW       result              ;AN000;
               DW       BAUD_values         ;AN000;
               DB       1                   ;AN000;;only one form of the keyword

BAUD_equal     DB    "BAUD=",0                      ;AN000;


parity_equal_control  LABEL BYTE                    ;AN000;initialized for first_parm_case

               DW       simple_string           ;AN000;n, o, even, m, space etc are strings
               DW       0                       ;AN000;don't capitalize, leave colon
               DW       result                  ;AN000;
               DW       PARITY_values           ;AN000;
               DB       2                       ;two ways to specify it

parity_equal   DB    "PARITY=",0                ;AN000;
par_equal      DB    "PAR=",0                   ;AN000;



DATA_equal_control   LABEL BYTE                 ;AN000;

               DW       simple_string
               DW       0                       ;AN000;;don't capitalize, leave colon
               DW       result                  ;AN000;
               DW       DATA_values             ;AN000;
               DB       1                       ;AN000;

data_equal     DB    "DATA=",0                  ;AN000;



STOP_equal_control   LABEL BYTE                 ;AN000;

               DW       simple_string           ;AN000;
               DW       0                       ;AN000;;don't capitalize, leave colon
               DW       result                  ;AN000;
               DW       STOP_values             ;AN000;
               DB       1                       ;AN000;

stop_equal     DB    "STOP=",0                  ;AN000;



RETRY_equal_control   LABEL BYTE                ;AN000;

               DW       simple_string           ;AN000;;all that is legal for RETRY is on and off
               DW       0                       ;AN000;;don't capitalize, never need to display to user
               DW       result                  ;AN000;
               DW       RETRY_values            ;AN000;
               DB       1                       ;AN000;

retry_equal_str DB    "RETRY=",0                 ;AN000;



PREPARE_equal_control   LABEL BYTE              ;AN000;

prepare_equal_match_flags  LABEL WORD           ;AN000;
               DW       numeric+complex+filespec  ;AN000;has to be complex at first, then numbers and filespec inside the parens
               DW       capitalize        ;AN000;capitalize the filespec
               DW       result            ;AN000;
               DW       prepare_values    ;AN000;
               DB       2                 ;AN000;

prepare_equal  DB    "PREPARE=",0         ;AN000;
prep_equal     DB    "PREP=",0            ;AN000;


SELECT_equal_control   LABEL BYTE         ;AN000;

               DW       numeric           ;AN000;range of codepage numbers
               DW       0                 ;AN000;don't capitalize, leave colon
               DW       result            ;AN000;
               DW       SELECT_values     ;AN000;
               DB       2              ;AN000;no keywords as positionals

select_equal   DB    "SELECT=",0       ;AN000;
sel_equal      DB    "SEL=",0          ;AN000;


DELAY_equal_control   LABEL BYTE       ;AN000;

               DW       numeric        ;AN000;  ;takes less space than number definitions
               DW       0              ;AN000;  ;don't capitalize, leave colon
               DW       result         ;AN000;
               DW       DELAY_values   ;AN000;
               DB       2              ;AN000;

del_equal      DB    "DEL=",0          ;AN000;
delay_equal    DB    "DELAY=",0        ;AN000;


RATE_equal_control   LABEL BYTE        ;AN000;

               DW       numeric        ;AN000;
               DW       0              ;AN000;  ;don't capitalize, leave colon
               DW       result         ;AN000;
               DW       RATE_values    ;AN000;
               DB       1              ;AN000;

rate_equal     DB    "RATE=",0         ;AN000;



LINES_equal_control   LABEL BYTE       ;AN000;

LINES_match_flag  DW       numeric     ;AN000;     ;setup for CON, changed if find LPTX
                  DW       0           ;AN000;     ;don't capitalize, leave colon
                  DW       result      ;AN000;
LINES_value_ptr   DW       CON_LINES_values ;AN000;
                  DB       1                ;AN000;

lines_equal       DB    "LINES=",0          ;AN000;



COLUMNS_equal_control   LABEL BYTE          ;AN000;

COLUMNS_match_flag   DW       numeric       ;AN000;   ;setup for CON changed when find LPTX
                     DW       0             ;AN000;   ;don't capitalize, leave colon
                     DW       result        ;AN000;
COLUMNS_value_ptr    DW       CON_COLUMNS_values      ;AN000;setup for CON, changed if find LPTX
                     DB       2                       ;AN000;

COLUMNS_equal        DB    "COLUMNS=",0      ;AN000;printer keyword
COLS_equal           DB    "COLS=",0         ;AN000;


LPT1_colon_equal_control   LABEL BYTE        ;AN000;

               DW       simple_string+ignore_colon   ;AN000;COM?[:] is all that is valid
               DW       0                ;AN000;;don't capitalize, leave colon
               DW       result           ;AN000;
               DW       reroute_values   ;AN000;
               DB       1                ;AN000;

LPT1_colon_equal  DB "LPT1:=",0          ;AN000;



LPT1_equal_control   LABEL BYTE          ;AN000;

               DW       simple_string+ignore_colon   ;AN000;COM?[:] is all that is valid
               DW       0                       ;AN000;don't capitalize, leave colon
               DW       result                  ;AN000;
               DW       reroute_values          ;AN000;
               DB       1                       ;AN000;

LPT1_equal        DB "LPT1=",0                  ;AN000;



LPT2_colon_equal_control   LABEL BYTE           ;AN000;

               DW       simple_string+ignore_colon   ;AN000;COM?[:] is all that is valid
               DW       0                ;AN000;don't capitalize, leave colon
               DW       result           ;AN000;
               DW       reroute_values   ;AN000;
               DB       1                ;AN000;

LPT2_colon_equal  DB "LPT2:=",0          ;AN000;



LPT2_equal_control   LABEL BYTE          ;AN000;

               DW       simple_string+ignore_colon   ;AN000;;COM?[:] is all that is valid
               DW       0                ;AN000;don't capitalize, leave colon
               DW       result           ;AN000;
               DW       reroute_values   ;AN000;
               DB       1                ;AN000;

LPT2_equal        DB "LPT2=",0           ;AN000;



LPT3_colon_equal_control   LABEL BYTE    ;AN000;

               DW       simple_string+ignore_colon   ;AN000;COM?[:] is all that is valid
               DW       0                ;AN000;don't capitalize, leave colon
               DW       result           ;AN000;
               DW       reroute_values   ;AN000;
               DB       1                ;AN000;

LPT3_colon_equal  DB "LPT3:=",0          ;AN000;



LPT3_equal_control   LABEL BYTE          ;AN000;

               DW       simple_string+ignore_colon   ;AN000;COM?[:] is all that is valid
               DW       0                 ;AN000;don't capitalize, leave colon
               DW       result            ;AN000;
               DW       reroute_values    ;AN000;
               DB       1                 ;AN000;

LPT3_equal        DB "LPT3=",0            ;AN000;

first_con_pos_control   LABEL BYTE          ;AN000;

               DW       simple_string     ;AN000;CP, code, codepage
               DW       0                 ;AN000;don't capitalize, leave colon
               DW       result            ;AN000;
               DW       OFFSET   first_CON_pos_values    ;AN000;
               DB       0                 ;AN000;no synonyms


second_con_pos_control   LABEL BYTE          ;AN000;

               DW       simple_string     ;AN000;REFRESH
               DW       0                 ;AN000;don't capitalize, leave colon
               DW       result            ;AN000;
               DW       OFFSET   second_CON_pos_values    ;AN000;
               DB       0                 ;AN000;no synonyms

first_old_con_pos_control   LABEL BYTE          ;AN000;

               DW       simple_string+numeric  ;AN000;r, l or screen lines request
               DW       0                 ;AN000;don't capitalize
               DW       result            ;AN000;
               DW       OFFSET   first_old_CON_pos_values    ;AN000;
               DB       0                 ;AN000;no synonyms


second_old_con_pos_control   LABEL BYTE          ;AN000;

               DW       simple_string+optional     ;AN000;T
               DW       0                 ;AN000;don't capitalize
               DW       result            ;AN000;
               DW       OFFSET   second_old_CON_pos_values    ;AN000;
               DB       0                 ;AN000;no synonyms

first_old_CON_pos_values    LABEL    BYTE      ;all valid forms of shift direction, and screen line values ;AN000;

   DB       include_string_list      ;AN000;have list of strings

   DB       0                        ;no number ranges          ;AN000;

   DB       number_of_CON_lines_numbers      ;number of rows choices;AN000;

   DB       twentyfive_item_tag                                 ;AN000;
   DD       25                                                  ;AN000;
   DB       fourtythree_item_tag                                ;AN000;
   DD       43                                                  ;AN000;
   DB       fifty_item_tag                                      ;AN000;
   DD       50                                                  ;AN000;

   DB       number_of_shift_forms      ;number of shift strings AN000;

   start_shift_forms   LABEL    BYTE                      ;AN000;


   DB       R_item_tag           ;AN000;
   DW       OFFSET R_str         ;AN000;
   DB       L_item_tag           ;AN000;
   DW       OFFSET L_str         ;AN000;


   number_of_shift_forms  EQU   ($ - start_shift_forms)/3       ;3 bytes per entry;AN000;


second_old_CON_pos_values    LABEL    BYTE      ;all valid forms of T   ;AN000;

   DB       include_string_list      ;AN000;have list of strings

   DB       0                        ;no number ranges          ;AN000;

   DB       0                       ;no number list             ;AN000;

   DB       number_of_T_forms      ;number of T strings AN000;

   start_T_forms   LABEL    BYTE                      ;AN000;


   DB       T_item_tag           ;AN000;
   DW       OFFSET T_str         ;AN000;


   number_of_T_forms  EQU   ($ - start_T_forms)/3       ;3 bytes per entry;AN000;


first_CON_pos_values    LABEL    BYTE      ;all valid forms of codepage;AN000;

   DB       include_string_list      ;AN000;have list of strings

   DB       0                        ;no number ranges          ;AN000;

   DB       0                       ;no number list             ;AN000;

   DB       number_of_CP_forms      ;number of cp strings AN000;

   start_CP_forms   LABEL    BYTE                      ;AN000;


   ;codepage strings

   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CODE_str      ;AN000;
   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CODEPAGE_str  ;AN000;
   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CP_str        ;AN000;

   ;invalid choice, included for usable error reporting: if come across refresh right after CON then issue invalid number of parms

   DB       REFRESH_item_tag     ;AC007;
   DW       OFFSET REF_str       ;AC007;
   DB       REFRESH_item_tag     ;AC007;
   DW       OFFSET REFRESH_str   ;AC007;

   number_of_CP_forms  EQU   ($ - start_CP_forms)/3       ;3 bytes per entry;AN000;


second_CON_pos_values    LABEL    BYTE      ;all valid forms of REFRESH;AN000;

   DB       include_string_list      ;AN000;have list of strings

   DB       0                        ;no number ranges          ;AN000;

   DB       0                       ;no number list             ;AN000;

   DB       number_of_REFRESH_forms      ;number of REFRESH strings AN000;

   start_REFRESH_forms   LABEL    BYTE                      ;AN000;

   DB       REFRESH_item_tag     ;AN000;
   DW       OFFSET REF_str       ;AN000;
   DB       REFRESH_item_tag     ;AN000;
   DW       OFFSET REFRESH_str   ;AN000;

   number_of_REFRESH_forms  EQU   ($ - start_REFRESH_forms)/3       ;3 bytes per entry;AN000;


BAUD_values    LABEL    BYTE             ;AN000;;all valid baud rates

   DB       include_string_list      ;AN000;have list of numbers and two strings

   DB       0                        ;AN000;

   DB       0                    ;AN000;no numeric representations

   DB       number_of_baud_strings   ;AN000;number of baud rates that are being used for other parameters also

   start_baud_strings   LABEL    BYTE     ;AN000;

   DB       oneten_item_tag               ;AN000;
   DW       OFFSET oneten_str             ;AN000;
   DB       oneten_item_tag               ;AN000;
   DW       OFFSET eleven_str   ;AN000;;"11" first two chars of 110
   DB       onefifty_item_tag   ;AN000;
   DW       OFFSET fifteen_str  ;AN000;
   DB       onefifty_item_tag   ;AN000;
   DW       OFFSET onefifty_str ;AN000;
   DB       threehundred_item_tag      ;AN000;
   DW       OFFSET thirty_str          ;AN000;
   DB       threehundred_item_tag      ;AN000;
   DW       OFFSET threehundred_str    ;AN000;
   DB       sixhundred_item_tag        ;AN000;
   DW       OFFSET sixty_str           ;AN000;
   DB       sixhundred_item_tag        ;AN000;
   DW       OFFSET sixhundred_str      ;AN000;
   DB       twelvehundred_item_tag     ;AN000;
   DW       OFFSET twelve_str          ;AN000;
   DB       twelvehundred_item_tag     ;AN000;
   DW       OFFSET twelvehundred_str   ;AN000;
   DB       twentyfourhundred_item_tag ;AN000;
   DW       OFFSET twentyfour_str      ;AN000;24 is also a typamatic rate
   DB       twentyfourhundred_item_tag ;AN000;
   DW       OFFSET twentyfourhundred_str     ;AN000;
   DB       fourtyeighthundred_item_tag      ;AN000;
   DW       OFFSET fourtyeight_str           ;AN000;
   DB       fourtyeighthundred_item_tag      ;AN000;
   DW       OFFSET fourtyeighthundred_str    ;AN000;
   DB       ninetysixhundred_item_tag        ;AN000;
   DW       OFFSET ninetysix_str             ;AN000;
   DB       ninetysixhundred_item_tag        ;AN000;
   DW       OFFSET ninetysixhundred_str      ;AN000;
   DB       nineteentwohundred_item_tag      ;AN000;;item tag
   DW       OFFSET nineteentwohundred_str ;AN000;;pointer to string
   DB       nineteentwohundred_item_tag   ;AN000;;item tag
   DW       OFFSET nineteen_point_two_str ;AN000;
   DB       nineteentwohundred_item_tag   ;AN000;  ;item tag
   DW       OFFSET nineteen_str           ;AN000;   ;used for RATE= also
   DB       nineteentwohundred_item_tag   ;AN000;  ;item tag
   DW       OFFSET nineteen_point_two_K_str ;AN000;pointer to string "19.2K"

   number_of_baud_strings  EQU   ($ - start_baud_strings)/3  ;AN000;3 bytes per entry



PARITY_values    LABEL    BYTE              ;AN000;all valid paritys

   DB       include_string_list      ;AN000;have list of strings

   DB       0                        ;AN000;

   DB       0                   ;AN000;;no number choices

   DB       number_of_paritys   ;AN000;;number of valid paritys

   start_paritys   LABEL    BYTE       ;AN000;

   DB       none_item_tag              ;AN000;
   DW       OFFSET N_str               ;AN000;
   DB       none_item_tag              ;AN000;
   DW       OFFSET NONE_str            ;AN000;
   DB       even_item_tag              ;AN000;
   DW       OFFSET EVEN_str            ;AN000;
   DB       even_item_tag              ;AN000;
   DW       OFFSET E_str               ;AN000;
   DB       odd_item_tag               ;AN663;
   DW       OFFSET O_str               ;AN663;
   DB       odd_item_tag               ;AN000;
   DW       OFFSET ODD_str             ;AN000;
   DB       MARK_item_tag              ;AN663;
   DW       OFFSET m_str               ;AN663;
   DB       MARK_item_tag              ;AN000;
   DW       OFFSET mark_str            ;AN000;
   DB       SPACE_item_tag             ;AN663;
   DW       OFFSET s_str               ;AN663;
   DB       SPACE_item_tag             ;AN000;
   DW       OFFSET space_str           ;AN000;

   number_of_paritys  EQU   ($ - start_paritys)/3 ;AN000;3 bytes per entry


DATA_values    LABEL    BYTE              ;AN000;all valid DATA values

   DB       include_string_list  ;AC663;have list of numbers

   DB       0                    ;AN000;no number ranges

   DB       0                    ;AN000;no number choices

   DB       number_of_databits   ;AN000;string choices

   start_databits   LABEL    BYTE   ;AN000;

   DB       five_item_tag           ;AN000;
   DW       OFFSET five_str         ;AN000;
   DB       six_item_tag            ;AN000;
   DW       OFFSET six_str          ;AN000;
   DB       seven_item_tag          ;AN000;
   DW       OFFSET seven_str        ;AN000;
   DB       eight_item_tag          ;AN000;
   DW       OFFSET eight_str        ;AN000;

   number_of_databits  EQU   ($ - start_databits)/3 ;AN000;3 bytes per entry


STOP_values    LABEL    BYTE             ;AN000;;all valid stop bits

   DB       include_string_list      ;AN000;have list of numbers and list of strings

   DB       0                        ;AN000;

   DB       0                         ;AN000; ;no number choices

   DB       number_of_stopbit_strings  ;AN000;;choices in string form

   start_stopbit_strings   LABEL    BYTE    ;AN000;

   DB       one_item_tag                    ;AN000;
   DW       OFFSET one_str                  ;AN000;
   DB       one_point_five_item_tag         ;AN000;
   DW       OFFSET one_point_five_str       ;AN000;
   DB       two_item_tag                    ;AN000;
   DW       OFFSET two_str                  ;AN000;

   number_of_stopbit_strings  EQU   ($ - start_stopbit_strings)/3  ;AN000;3 bytes per entry



RETRY_values    LABEL    BYTE             ;AN000;;all valid RETRY settings

   DB       include_string_list      ;AN000;have list of strings

   DB       0                        ;AN000;

   DB       0                   ;AN000;;no number choices

   DB       number_of_retry_settings   ;AN000;

   start_retry_settings   LABEL    BYTE   ;AN000;

   DB       B_item_tag                    ;AN000;
   DW       OFFSET B_str                  ;AN000;
   DB       E_item_tag                    ;AN000;
   DW       OFFSET E_str                  ;AN000;
   DB       R_item_tag                    ;AN000;
   DW       OFFSET R_str                  ;AN000;
   DB       NONE_item_tag                 ;AN663;
   DW       OFFSET N_str                  ;AN663;
   DB       NONE_item_tag                 ;AN000;
   DW       OFFSET NONE_str               ;AN000;
   DB       P_item_tag                    ;AN000;
   DW       OFFSET P_str                  ;AN000;

   number_of_retry_settings  EQU   ($ - start_retry_settings)/3 ;AN000;3 bytes per entry



PREPARE_values    LABEL    BYTE        ;AN000;almost any numeric value is valid

   DB       ranges_only                ;AN000;;have range of numbers

   DB       1                          ;AN000;;one range

   DB       codepage_item_tag          ;AN000;
   DD       min_codepage_value         ;AN000;
   DD       max_codepage_value         ;AN000;




SELECT_values    LABEL    BYTE              ;AN000;all valid baud rates

   DB       ranges_only         ;AN000;;have range of numbers

   DB       1                   ;AN000;

   DB       codepage_item_tag   ;AN000;;item tag for the range
   DD       min_codepage_value  ;AN000;
   DD       max_codepage_value  ;AN000;


DELAY_values    LABEL    BYTE             ;AN000;;all valid delay rates

   DB       ranges_only         ;AN000;;have range of numbers

   DB       1                   ;AN000;;1 range
   DB       range_item_tag      ;AN000;;don't ever need this item tag
   DD       1                   ;AN000;;smallest valid delay value
   DD       4                   ;AN000;;largest valid delay value



RATE_values    LABEL    BYTE             ;AN000;;all valid typamatic rates

   DB       ranges_only         ;AN000;;have range of numbers

   DB       1                   ;AN000;;1 range
   DB       range_item_tag      ;AN000;;never used
   DD       1                   ;AN000;;smallest valid rate
   DD       32                  ;AN000;;largest valid rate




CON_COLUMNS_values    LABEL    BYTE ;AN000;all valid columns values for the screen

   DB       include_number_list     ;AN000;    ;have list of numbers

   DB       0                       ;AN000;only numeric representations

   DB       number_of_CON_columns_numbers   ;AN000;choices represented as numbers

   start_CON_columns_numbers   LABEL    BYTE   ;AN000;

   DB       fourty_item_tag                    ;AN000;
   DD       40                                 ;AN000;
   DB       eighty_item_tag         ;          ;AN000;
   DD       80                       ;AN000;numbers because used in call to IOCTL

   number_of_CON_columns_numbers  EQU   ($ - start_CON_columns_numbers)/5       ;5 bytes per entry;AN000;



CON_LINES_values    LABEL    BYTE      ;all valid LINES= values for the screen;AN000;

   DB       include_number_list            ;have list of numbers;AN000;

   DB       0                                                   ;AN000;

   DB       number_of_CON_lines_numbers              ; number ch;AN000;

   start_CON_lines_numbers   LABEL    BYTE                      ;AN000;

   DB       twentyfive_item_tag                                 ;AN000;
   DD       25                                                  ;AN000;
   DB       fourtythree_item_tag                                ;AN000;
   DD       43                                                  ;AN000;
   DB       fifty_item_tag                                      ;AN000;
   DD       50                                                  ;AN000;

   number_of_CON_lines_numbers  EQU   ($ - start_CON_lines_numbers)/5       ;5 bytes per entry;AN000;




LPT_COLUMNS_values    LABEL    BYTE ;AN000;all valid columns values for parallel printers

   DB       include_string_list     ;AN000;;have list of strings

   DB       0                       ;AN000;

   DB       0                       ;AN000;no numeric representations

   DB       number_of_lpt_columns_strings  ;AN000;;choices represented as strings

   start_LPT_columns_strings   LABEL    BYTE    ;AN000;

   DB       eighty_item_tag         ;           ;AN000;
   DW       OFFSET eighty_str       ;AN000;;strings because values also used as positional parms
   DB       onethirtytwo_item_tag   ;AN000;
   DW       OFFSET onethirtytwo_str ;AN000;

   number_of_LPT_columns_strings  EQU   ($ - start_LPT_columns_strings)/3       ;3 bytes per entry;AN000;



LPT_LINES_values    LABEL    BYTE ;AN000;all valid LINES= values for the screen

   DB       include_string_list       ;AN000;have list of strings

   DB       0                         ;AN000;

   DB       0                         ;AN000;    ;no number choices

   DB       number_of_LPT_lines_strings   ;AN000;

   start_LPT_lines_strings   LABEL    BYTE   ;AN000;

   DB       six_item_tag                 ;AN000;;for printer
   DW       OFFSET six_str               ;AN000;
   DB       eight_item_tag               ;AN000;;for printer
   DW       OFFSET eight_str             ;AN000;

   number_of_LPT_lines_strings  EQU   ($ - start_LPT_lines_strings)/3 ;AN000;3 bytes per entry


reroute_values    LABEL    BYTE    ;AN000;;all valid destination devices for parallel printer reroute

   DB       include_string_list    ;AN000; ;have list of numbers and one string

   DB       0                      ;AN000;

   DB       0                   ;AN000;;no number choices

   DB       number_of_reroute_strings     ;AN000;

   start_reroute_strings   LABEL    BYTE  ;AN000;

   DB       COM1_item_tag                 ;AN000;
   DW       OFFSET COM1_str               ;AN000;
   DB       COM2_item_tag                 ;AN000;
   DW       OFFSET COM2_str               ;AN000;
   DB       COM3_item_tag                 ;AN000;
   DW       OFFSET COM3_str               ;AN000;
   DB       COM4_item_tag                 ;AN000;
   DW       OFFSET COM4_str               ;AN000;

   number_of_reroute_strings  EQU   ($ - start_reroute_strings)/3 ;AN000;3 bytes per entry




Sw_control  LABEL BYTE                                            ;AN000;

               DW       0                 ;AN000;no values allowed on /STATUS
function_flag  DW       0                 ;AN000;no values allowed on /STATUS
               DW       result            ;AN000;same buffer as for other parms
               DW       Sw_values         ;AN000;
num_synonyms   DB       3                 ;AN000;3 ways to specify /STATUS
slash_sta      DB       "/STA",0          ;AN000;
slash_stat     DB       "/STAT",0         ;AN000;
slash_status   DB       "/STATUS",0       ;AN000;


Sw_Options	LABEL BYTE

		DW	0		; Match Mask
		DW	0		; Function Mask
		DW	result		; ptr to result buffer (shared)
		DW	Sw_values	; ptr to values (shared)
		DB	1		; count of synonyms
slash_?		DB	"/?",0		; text to match






Sw_values   LABEL    BYTE                 ;AN000;

   DB    0              ;AN000;no values allowed on /STATUS


first_pos_values    LABEL BYTE   ;AN000;value list for all positional parameters that appear first

   DB       include_string_list  ;AN000;   ;have string values

   DB       0                    ;AN000;numerics treated as strings

   DB       0                    ;AN000;no number choices

   DB       number_of_first_positional_strings          ;AN000;

   start_first_positional_strings   LABEL    BYTE     ;used to calculate previous field;AN000;

   ;screen modes

   DB       BW40_item_tag     ;AC000;
   DW       OFFSET BW40_str   ;AC000;
   DB       BW80_item_tag     ;AC000;
   DW       OFFSET BW80_str   ;AC000;
   DB       CO40_item_tag     ;AC000;
   DW       OFFSET CO40_str   ;AC000;
   DB       CO80_item_tag     ;AC000;
   DW       OFFSET CO80_str   ;AC000;
   DB       MONO_item_tag     ;AC000;
   DW       OFFSET MONO_str   ;AC000;
   DB       fourty_item_tag   ;AC000;
   DW       OFFSET fourty_str ;AC000;
   DB       eighty_item_tag   ;AC000;
   DW       OFFSET eighty_str ;AC000;


   DB       con_item_tag      ;AN000;
   DW       OFFSET con_str    ;AN000;

   ;com port names

   DB       COM1_item_tag     ;AN000;
   DW       OFFSET COM1_str   ;AN000;
   DB       COM2_item_tag     ;AN000;
   DW       OFFSET COM2_str   ;AN000;
   DB       COM3_item_tag     ;AN000;
   DW       OFFSET COM3_str   ;AN000;
   DB       COM4_item_tag     ;AN000;
   DW       OFFSET COM4_str   ;AN000;

   ;printer port names

   DB       PRN_item_tag      ;AN000;
   DW       OFFSET PRN_str    ;AN000;
   DB       LPT1_item_tag     ;AN000;
   DW       OFFSET LPT1_str   ;AN000;
   DB       LPT2_item_tag     ;AN000;
   DW       OFFSET LPT2_str   ;AN000;
   DB       LPT3_item_tag     ;AN000;
   DW       OFFSET LPT3_str   ;AN000;

   ;LPT special cases

   DB       LPT1132_item_tag  ;AN000;
   DW       OFFSET LPT1132_str;AN000;
   DB       LPT2132_item_tag  ;AN000;
   DW       OFFSET LPT2132_str;AN000;
   DB       LPT3132_item_tag  ;AN000;
   DW       OFFSET LPT3132_str;AN000;
   DB       LPT180_item_tag   ;AN000;
   DW       OFFSET LPT180_str ;AN000;
   DB       LPT280_item_tag   ;AN000;
   DW       OFFSET LPT280_str ;AN000;
   DB       LPT380_item_tag   ;AN000;
   DW       OFFSET LPT380_str ;AN000;


number_of_first_positional_strings  EQU   ($ - start_first_positional_strings)/3 ;each entry is 3 bytes (byte, word);AN000;



second_pos_values    LABEL BYTE  ;AN000;;value list for all positional parameters that appear second

   DB       include_string_list  ;AN000;   ;have string values

   DB       0                    ;AN000;numerics treated as strings

   DB       0                    ;AN000;no number choices

   DB       number_of_second_positional_strings         ;AN000;

   start_second_positional_strings   LABEL    BYTE     ;used to calculate previous field;AN000;


   ;codepage strings

   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CODE_str      ;AN000;
   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CODEPAGE_str  ;AN000;
   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CP_str        ;AN000;

   ;invalid choice, included for usable error reporting: if come across refresh right after CON then issue invalid number of parms

   DB       REFRESH_item_tag     ;AC007;
   DW       OFFSET REF_str       ;AC007;
   DB       REFRESH_item_tag     ;AC007;
   DW       OFFSET REFRESH_str   ;AC007;

   ;shift directions

   DB       L_item_tag           ;AN000;
   DW       OFFSET L_str         ;AN000;
   DB       R_item_tag           ;AN000;
   DW       OFFSET R_str         ;AN000;


   ;columns values

;  DB       eighty_item_tag      ;AN000;
;  DW       OFFSET eighty_str    ;AN000;   ;strings because values also used as positional parms
   DB       onethirtytwo_item_tag;AN000;
   DW       OFFSET onethirtytwo_str    ;AN000;

number_of_second_positional_strings  EQU   ($ - start_second_positional_strings)/3 ;each entry is 3 bytes (byte, word);AN000;


third_pos_values    LABEL BYTE   ;AN000;value list for all positional parameters that appear third

   DB       include_string_list  ;AN000;   ;have string values

   DB       0                    ;AN000;numerics treated as strings

   DB       0                    ;AN000;no number choices

   DB       number_of_third_positional_strings                  ;AN000;

   start_third_positional_strings   LABEL    BYTE     ;used to calculate previous field;AN000;

number_of_third_positional_strings  EQU   ($ - start_third_positional_strings)/3 ;each entry is 3 bytes (byte, word);AN000;


first_lpt_pos_values    LABEL BYTE   ;AN000;value list for all possible chars per line

   DB       include_string_list  ;AN000;   ;have string values

   DB       0                    ;AN000;numerics treated as strings

   DB       0                    ;AN000;no number choices

   DB       number_of_first_lpt_positional_strings          ;AN000;

   start_first_lpt_positional_strings   LABEL    BYTE     ;used to calculate previous field;AN000;

   DB       eighty_item_tag
   DW       OFFSET eighty_str
   DB       onethirtytwo_item_tag
   DW       OFFSET onethirtytwo_str     ;AN000;
   DB       CODEPAGE_item_tag
   DW       OFFSET CODE_str      ;AN000;
   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CODEPAGE_str  ;AN000;
   DB       CODEPAGE_item_tag    ;AN000;
   DW       OFFSET CP_str        ;AN000;

   ;invalid choice, included for usable error reporting: if come across refresh right after CON then issue invalid number of parms

   DB       REFRESH_item_tag     ;AC007;
   DW       OFFSET REF_str       ;AC007;
   DB       REFRESH_item_tag     ;AC007;
   DW       OFFSET REFRESH_str   ;AC007;

number_of_first_lpt_positional_strings  EQU   ($ - start_first_lpt_positional_strings)/3 ;each entry is 3 bytes (byte, word);AN000;


second_lpt_pos_values    LABEL BYTE   ;AN000;value list for all possible lines per inch

   DB       include_string_list  ;AN000;   ;have string values

   DB       0                    ;AN000;numerics treated as strings

   DB       0                    ;AN000;no number choices

   DB       number_of_second_lpt_positional_strings          ;AN000;

   start_second_lpt_positional_strings   LABEL    BYTE     ;used to calculate previous field;AN000;

   DB       eight_item_tag                ;AN000;
   DW       OFFSET eight_str              ;AN000;
   DB       six_item_tag                  ;AN000;
   DW       OFFSET six_str     ;AN000;
   DB       REFRESH_item_tag     ;AN000;
   DW       OFFSET REF_str       ;AN000;
   DB       REFRESH_item_tag     ;AN000;
   DW       OFFSET REFRESH_str   ;AN000;

number_of_second_lpt_positional_strings  EQU   ($ - start_second_lpt_positional_strings)/3 ;3 bytes per entry (byte,word);AN000;


third_lpt_pos_values    LABEL BYTE   ;AN000;value list for all possible retry settings

   DB       include_string_list  ;AN000;   ;have string values

   DB       0                    ;AN000;no numeric ranges

   DB       0                    ;AN000;no number choices

   DB       number_of_third_lpt_positional_strings          ;AN000;

   start_third_lpt_positional_strings   LABEL    BYTE     ;used to calculate previous field;AN000;

   DB       B_item_tag                    ;AN000;
   DW       OFFSET B_str                  ;AN000;
   DB       E_item_tag                    ;AN000;
   DW       OFFSET E_str                  ;AN000;
   DB       R_item_tag                    ;AN000;
   DW       OFFSET R_str                  ;AN000;
   DB       NONE_item_tag                 ;AN663;
   DW       OFFSET N_str                  ;AN663;
   DB       NONE_item_tag                 ;AN000;
   DW       OFFSET NONE_str               ;AN000;
   DB       OFF_item_tag                  ;AN000;
   DW       OFFSET OFF_str                ;AN000;
   DB       P_item_tag
   DW       OFFSET P_str

number_of_third_lpt_positional_strings  EQU   ($ - start_third_lpt_positional_strings)/3 ;each entry is 3 bytes (byte, word);AN000;



;strings

                                          ;AN000;
zero_str                  DB  "0",0       ;AN000;
one_str                   DB  "1",0       ;AN000;
one_point_five_str        DB  "1.5",0     ;AN000;
two_str                   DB  "2",0       ;AN000;
three_str                 DB  "3",0       ;AN000;
four_str                  DB  "4",0       ;AN000;
five_str                  DB  "5",0       ;AN000;  ;data bit, typamatic rate
six_str                   DB  "6",0       ;AN000;
seven_str                 DB  "7",0       ;AN000;
eight_str                 DB  "8",0       ;AN000;
nine_str                  DB  "9",0       ;AN000;
eleven_str                DB  "11",0      ;AN000; ;first two chars of 110
twelve_str                DB  "12",0      ;AN000;
fifteen_str               DB  "15",0      ;AN000; ;abbreviated form of 150, 15 is also a RATE= candidate
nineteen_str              DB  "19",0      ;AN000; ;used for baud rates and RATE=
nineteen_point_two_str    DB  "19.2",0    ;AN000;
nineteen_point_two_K_str  DB  "19.2K",0   ;AN000; ;mutant baud rate
twentyfour_str            DB  "24",0      ;AN000; ;24 is also a typamatic rate
thirty_str                DB  "30",0      ;AN000;
fourty_str                DB  "40",0      ;AN000;
fourtyeight_str           DB  "48",0      ;AN000;
sixty_str                 DB  "60",0      ;AN000;
eighty_str                DB  "80",0      ;AN000;
ninetysix_str             DB  "96",0      ;AN000;
oneten_str                DB  "110",0     ;AN000;
onethirtytwo_str          DB  "132",0     ;AN000;
onefifty_str              DB  "150",0     ;AN000;
threehundred_str          DB  "300",0     ;AN000;
sixhundred_str            DB  "600",0     ;AN000;
twelvehundred_str         DB  "1200",0    ;AN000;
twentyfourhundred_str     DB  "2400",0    ;AN000;
fourtyeighthundred_str    DB  "4800",0    ;AN000;
ninetysixhundred_str      DB  "9600",0    ;AN000;
nineteentwohundred_str    DB  "19200",0   ;AN000;
B_str                     DB  "B",0       ;AN000;
BW40_str                  DB  "BW40",0    ;AN000;
BW80_str                  DB  "BW80",0    ;AN000;
CO40_str                  DB  "CO40",0    ;AN000;
CO80_str                  DB  "CO80",0    ;AN000;
CODE_str                  DB  "CODE",0    ;AN000;
CODEPAGE_str              DB  "CODEPAGE",0;AN000;
COM_str                   DB  "COM",0     ;AN000;
start_COM1_str    LABEL BYTE              ;AN000;  ;used to calculate len_COMX_str, see invoke
COM1_str                  DB  "COM1",0    ;AN000;
len_COMX_str      EQU   $ - start_COM1_str;AN000;  ;all COMX strings are the same length
COM2_str                  DB  "COM2",0    ;AN000;
COM3_str                  DB  "COM3",0    ;AN000;
COM4_str                  DB  "COM4",0    ;AN000;
CON_str                   DB  "CON",0
len_CON_str       EQU  ($ - (OFFSET CON_str))                                             ;AN000;
CP_str                    DB  "CP",0                                                      ;AN000;
E_str                     DB  "E",0             ;RETRY=setting                            ;AN000;
EVEN_str                  DB  "EVEN",0                                                    ;AN000;
L_str                     DB  "L",0                                                       ;AN000;
start_LPT1_str    LABEL BYTE                 ;used to calculate len_LPTX_str, see invoke  ;AN000;
LPT1_str                  DB  "LPT1",0                                                    ;AN000;
len_LPTX_str      EQU   $ - start_LPT1_str   ;all LPTX strings are the same length        ;AN000;
LPT2_str                  DB  "LPT2",0                                                    ;AN000;
LPT3_str                  DB  "LPT3",0                                                    ;AN000;
LPT1132_str               DB  "LPT1132",0                                                 ;AN000;
LPT2132_str               DB  "LPT2132",0                                                 ;AN000;
LPT3132_str               DB  "LPT3132",0                                                 ;AN000;
LPT180_str                DB  "LPT180",0                                                  ;AN000;
LPT280_str                DB  "LPT280",0                                                  ;AN000;
LPT380_str                DB  "LPT380",0                                                  ;AN000;
M_str                     DB  "M",0
MARK_str                  DB  "MARK",0                                                    ;AN000;
MONO_str                  DB  "MONO",0                                                    ;AN000;
N_str                     DB  "N",0                                                       ;AN000;
NONE_str                  DB  "NONE",0                                                    ;AN000;
O_str                     DB  "O",0                                                       ;AN000;
ODD_str                   DB  "ODD",0                                                     ;AN000;
OFF_str                   DB  "OFF",0                                                     ;AN000;
ON_str                    DB  "ON",0                                                      ;AN000;
P_str                     DB  "P",0                                                       ;AN000;
PRN_str                   DB  "PRN",0                                                     ;AN000;
R_str                     DB  "R",0                                                       ;AN000;
REF_str                   DB  "REF",0                                                     ;AN000;
REFRESH_str               DB  "REFRESH",0                                                 ;AN000;
S_str                     DB  "S",0
SPACE_str                 DB  "SPACE",0                                                   ;AN000;
T_str                     DB  "T",0                                                       ;AN000;


result       result_def<>                                       ;AN000;

parm_lst    parm_list_entry  max_parms DUP (<>)                 ;AN000;



;                                                                                        
;  D A T A  ͼ


;
;******************************************************************************************

;-------------------------------------------------------------------------------
;
;
; SEARCH_ITEM_TAGS
; ----------------
;  Search the item tags in input value list for the input item tag.
;
;
;
;
;
;
;  INPUT: i_CL - first item tag in the group
;         search_stop - last item_tag in the group, the sentinal for the REPEAT
;                       loop.
;
;
;  RETURN: match_found indicates that the item tag returned by the parser was
;          found in the group passed in.
;
;
;  MESSAGES: none
;
;
;
;
;  REGISTER
;  USAGE:       To be determined at I2 time.
;
;
;  CONVENTIONS:
;
;
;
;
;  ASSUMPTIONS:
;
;
;  SIDE EFFECT:
;
;
;

search_item_tags  PROC  NEAR                          ;AN000;


MOV   match_found,false                               ;AN000;
.REPEAT
   .IF <parm_list[current_parm_DI].item_tag EQ i_CL> THEN   ;AN000;
      MOV   match_found,true                  ;AN000;
      MOV   i_CL,last_databit_item_tag           ;AN000;set end of loop trigger
   .ENDIF                                     ;AN000;
   INC   i_CL                                 ;AN000;
.UNTIL <i_CL GT search_stop>      ;AN000;

RET

search_item_tags  ENDP                                ;AN000;

;-------------------------------------------------------------------------------
;
;
; CHECK_FOR_KEYWORD
; ---------------------
;
; Scan the list of keywords (OFFSETS) looking for a match with
; parm_list[current_parm_DI].keyword_switch_ptr.
;
;
;
;  INPUT: uses global variables.
;
;
;  RETURN: match_found is set to true if a match is found.
;
;
;  MESSAGES: none
;
;
;
;  REGISTER
;  USAGE:       DX - loop index
;               SI - displacement into the list of pointers
;               CX - holder of pointer to keywords for compare
;
;
;
;  CONVENTIONS:
;
;
;
;
;
;
;  ASSUMPTIONS: The list of con_keyword pointers is consecutive words.
;               number_of_keywords has the number of OFFSETS in the list
;               start_of_keyword_ptrs has the first OFFSET in the list and can
;               be addressed off of.
;
;
;
;  SIDE EFFECT: DL - lost
;               SI - lost
;               CX - lost
;               match_found - lost
;
;
;

check_for_keyword   PROC  NEAR                        ;AN000;

MOV   match_found,false                            ;AN000;
MOV   SI,0                                            ;AN000;
MOV   DL,0                          ;AN000;;index for the loop
.WHILE <DL LT number_of_keywords> AND    ;AN000;;check each pointer in the list
.WHILE <match_found EQ false> DO     ;AN000;
   MOV   CX,start_of_keyword_ptrs[SI]    ;AN000;
   .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ CX> THEN ;AN000;IF synonym ptr=CON keyword ptr THEN
       MOV   match_found,true                          ;AN000;
   .ENDIF                     ;AN000;
   INC   SI          ;AN000;                                     ;AN000;
   INC   SI                 ;AN000;                              ;AN000;
   INC   DL                        ;AN000;;increment loop counter
.ENDWHILE            ;AN000;

RET                                ;AN000;

check_for_keyword   ENDP           ;AN000;

;-------------------------------------------------------------------------------

setup_invalid_parameter  PROC  NEAR     ;AN000;

PUBLIC setup_invalid_parameter

MOV   message,OFFSET CRLF        ;AN000;the common message doesn't have a CR,LF in it and all my other messages do
PUSH  parser_return_code_AX      ;AC006;AX destroyed by sysdispmsg
display  message                 ;AN000;
POP   parser_return_code_AX


MOV   BP,command_line           ;AN000;BP points to end of current (invalid) parm
.IF <<BYTE PTR [BP]> NE end_of_line_char_0D> AND    ;AN000;IF a whitespace char or comma in the string
.IF <<BYTE PTR [BP]> NE end_of_line_char_00> THEN   ;AN000;THEN
   DEC   BP                                  ;AN000;don't include the delimeter in the display of the invalid parm
.ENDIF
MOV   BYTE PTR [BP],0           ;AN000;make the string an ASCIIZ

;offending_parameter is where the text of the bad parm is,
;offending_parameter_ptr is the address of offending_parameter By incrementing
;offending_parameter_ptr the first characters of the text string are skipped.
;This is done to skip leading whitespace.


MOV   BP,offending_parameter_ptr       ;AC006;BP=>first char in the text string
.WHILE <<BYTE PTR [BP]> EQ tab> OR       ;AC006;WHILE the char in the text string
.WHILE <<BYTE PTR [BP]> EQ " "> DO       ;AC006;      is white space DO
   INC   offending_parameter_ptr       ;AC006;point past the whitespace char
   INC   BP                            ;AC006;index next char in the string
.ENDWHILE                              ;AC006;

.IF <parser_return_code_AX EQ syntax_error_rc> THEN   ;AN000;syntax error, like "RETRY= E"
   MOV   message,OFFSET syntax_error                    ;AN000;
   PUSH  offending_parameter_ptr                          ;AN000;
   POP   syntax_error_ptr                               ;AN000;point to the offending parameter
.ELSEIF <parser_return_code_AX EQ not_in_switch_list> THEN ;AN000;
   MOV   message,OFFSET Invalid_switch
.ELSE
   MOV   message,OFFSET Invalid_parameter ;AN000;user mispelled, misordered etc.
.ENDIF                                                          ;AN000;
MOV   noerror,false                                      ;AN000;

RET

setup_invalid_parameter  ENDP           ;AN000;

;-------------------------------------------------------------------------------

setup_for_not_supported    PROC  NEAR     ;AC002;prepare replacable parm for "Function not supported on this machine - ????".

MOV   CX,offending_parameter_ptr;AN000;
MOV   not_supported_ptr,CX      ;AN000;point to string describing what is not supported for message
MOV   BP,command_line           ;AN000;BP points to end of current (invalid) parm
.IF <<BYTE PTR [BP]> NE end_of_line_char_0D> AND    ;AN000;IF a whitespace char or comma in the string
.IF <<BYTE PTR [BP]> NE end_of_line_char_00> THEN   ;AN000;THEN
   DEC   BP                                  ;AN000;don't include the delimeter in the display of the invalid parm
.ENDIF
MOV   BYTE PTR [BP],0           ;AN000;make the string an ASCIIZ
MOV   message,OFFSET function_not_supported ;AN000;"Function not supported on the computer - mark"
MOV   noerror,false             ;AN000;
MOV   looking_for,eol

RET

setup_for_not_supported    ENDP           ;AC002;

;-------------------------------------------------------------------------------
;
;
; DISPLAY_OPTIONS_EXIT
; ---------------------
;
; Display the available options to the user on standard output.
; Then exit the program so they can try again.
;
;  INPUT:       noerror already set to false by caller (parse_parm).
;               options_msg already has number of first line of message
;                (MSG_OPTIONS_FIRST).
;
;  RETURN:      returns 0 to DOS
;
;
;  MESSAGES: 	 displays all the lines of the options message(s)
;
;
;  REGISTER
;  USAGE:       
;
;
;
;  CONVENTIONS:
;
;
;  ASSUMPTIONS: 
;
;
;  SIDE EFFECT: No house cleaning is done upon exit.
;
;
;

	PUBLIC	display_options_exit
display_options_exit   PROC  NEAR

	; Display the user options message lines

	mov	dx, offset options_msg		; get ptr to msg struct
doe_loop:
	call	printf				; print this line
	cmp	word ptr[options_msg], MSG_OPTIONS_LAST	; last msg?
	je	doe_done			;  done if so
	inc	word ptr[options_msg]		; else bump msg nbr
	jmp	short doe_loop			;  and go do it
doe_done:

	; Exit MODE so the user can try again.

	mov	ah, 4Ch
	mov	al, 0
	int	21h

display_options_exit   ENDP


;
;
; PARSE_PARAMETERS
; ----------------
;
; All parameters entered on the command line are reduced to a list of values
; which completely describes the parms.  The syntactic and semantic correctness
; will be checked.  The routines that use the lists created by this routine
; can have complete trust in the validity of the parms.
;
; Most of the states of looking_for allow null, even if it is not mentioned in
; the name of the value looking_for is assigned.
;
;
;
;
;
;
;
;
;
;
;  INPUT: none, uses global variables.
;
;
;  RETURN: noerror is set to false if an error is encountered.
;
;
;  MESSAGES: "Invalid parameter  'bdprm'", where "bdprm" is the first 5 or less
;            characters of the parameter that is incorrect or unexpected.
;
;            "Must specify COM1, COM2, COM3 or COM4"
;
;            "Illegal device name"
;
;            "Invalid baud rate specified"
;
;
;
;
;  REGISTER
;  USAGE:       To be determined at I2 time.
;
;
;  CONVENTIONS: "looking_for" indicates the valid possibilities for the next parm.
;
;               "current_parm" refers to the parm just returned.  It can be an
;                            item tag, a type.
;
;               When "/STATUS" is a valid possibility it is checked for even
;               though the value of "looking_for" may not indicate it as a
;               choice.
;
;               When possible the parser control blocks will be modified at
;               the case where looking_for is being checked for rather than
;               where looking_for was set.  This will save code when more than
;               one place sets looking_for to the same state.
;
;
;
;
;  ASSUMPTIONS: The parser control blocks are setup to be the following:
;               seperators are defaults and colon (:)
;               match_flags=2011 (simple string, ignore colon, optional)
;               function_flags=0
;               keyword/switch list has only /STATUS
;               nval (number of value definitions) is 3
;               Initially no number choices.  Most numeric values will treated as strings.
;                 This is because for most of them the numeric value doesn't
;                 mean anything. Since we do not want to restrict the choices
;                 code pages they cannot be enumerated, so a range will be used.
;               The list of strings in the values block contains all the
;                 device names, all the screen modes, all the status qualifiers,
;                 and all numeric values that have no meaning in binary form,
;                 can be enumerated, or are non-integer.
;
;
;  SIDE EFFECT:
;
;
;

parse_parameters PROC              ;AN000;

;determine if on a PS/2 or later for checking COMx parameters
;C01
;C01  .IF <machine_type NE PC1> AND           ;PC1
;C01  .IF <machine_type NE PCXT> AND          ;XT, only one because each release is same to MODE
;C01  .IF <machine_type NE PCJr> AND          ;PCJr
;C01  ;.IF <machine_type NE AT1> AND ######## VAIL does support extended COM  ;first release of AT and VAIL
;C01  .IF <machine_type NE AT2> AND           ;second release of AT
;C01  .IF <machine_type NE AT3> AND           ;internal release of third version of AT
;C01  .IF <machine_type NE AT4> AND           ;scalar value and submodel byte for AT on or later than 11/15/85
;C01  .IF <machine_type NE XT286> AND         ;XT 286
;C01  .IF <machine_type NE Convertible> THEN  ;PC Convertible
;C01     MOV   type_of_machine,PS2                           ;AC002;set flag
;C01  .ENDIF


MOV   looking_for,first_parm     ;AN000;looking_for:=first_parm

.WHILE <eol_found NE true> AND NEAR    ;AN000;
.WHILE <noerror EQ true> NEAR DO ;AN000;WHILE (NOT EOL) AND noerror=true DO

;  CASE looking_for=

   ;calculate the displacement for the jump to appropriate case
   XOR   AX,AX             ;AN000;
   MOV   AL,max_looking_for      ;AN000;see the list of equates for looking_for
   SUB   AL,looking_for        ;AN000;AX=byte displacement into table of OFFSETS
   SHL   AX,1                   ;AN000;each displacement is 2 bytes
   MOV   SI,AX                  ;AN000;SI=appropriate displacement into table of offsets
   JMP   jump_table1[SI]            ;AN000;jump to case

   jump_table1    LABEL    WORD    ;AN000;    ;these entries must be in same order as the values in list of equates for looking_for

   DW OFFSET codepage_case                 ;AN000;
   DW OFFSET codepage_prms_case           ;AN000;
   DW OFFSET COM_keyword_case              ;AN000;
   DW OFFSET com_keyword_or_baud_case      ;AN000;
   DW OFFSET CON_keyword_case                ;AN000;
   DW OFFSET con_kwrd_status_or_cp_case    ;AN000;
   DW OFFSET databits_or_null_case         ;AN000;
   DW OFFSET device_name_or_eol_case       ;AN000;
   DW OFFSET eol_case                      ;AN000;
   DW OFFSET first_parm_case               ;AN000;
   DW OFFSET li_or_null_case               ;AN000;
   DW OFFSET P_case                        ;AN000;
   DW OFFSET parity_or_null_case           ;AN000;
   DW OFFSET prn_kw_status_cp_cl_null_case   ;AN000;
   DW OFFSET sd_or_dl_case                 ;AN000;
   DW OFFSET sd_or_dl_or_eol_case          ;AN000;
   DW OFFSET status_or_eol_case            ;AN000;
   DW OFFSET stopbits_or_null_case         ;AN000;
   DW OFFSET T_or_eol_case                 ;AN000;


      com_keyword_or_baud_case:              ;AN000;

PUBLIC      com_keyword_or_baud_case

         ;The com keywords are in "com_parmsx", as well as the values for the
         ;positional and keyword forms of the com parameters.  If
         ;keyword_switch_ptr comes back from parse_parm nonzero then a valid
         ;com keyword or /STATUS was found.

         CALL  parse_parm     ;AN000;/status allowed

         ;CASE current_parm=

;           /status:

                  .IF <parser_return_code_AX EQ no_error> AND                                         ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_sta>> OR     ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_stat>> OR   ;AC004;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_status>> THEN   ;AN000;

;              MOV   slash_status,deleted       ;AN000;make it so /status again is an error,also deletes /STA
;              MOV   slash_stat,deleted         ;AN000;
;              MOV   slash_sta,deleted          ;AN000;
               MOV   looking_for,eol            ;AN000;eol only valid
               MOV   request_type,com_status                         ;AN000;

;C00           BREAK  1                   ;AN000;
               SHORTBREAK  1              ;AN000;                       ;C00

                  .ENDIF                  ;AN000;


;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;

               MOV   request_type,com_status                         ;AN000;
               MOV   eol_found,true                                   ;AN000;
;C00           BREAK 1                                          ;AN000;
               SHORTBREAK 1                                     ;AN000; ;C00

                  .ENDIF                                        ;AN000;


;           com_keyword:

                  .IF <parser_return_code_AX EQ no_error> AND                                         ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr NE 0> THEN  ;AN000;wasn't /STATUS so must be a keyword

               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET baud_equal>> THEN   ;AN000;IF synonym ptr=> BAUD= THEN
                  MOV   baud_specified,true                        ;AN000;
               .ENDIF                                                   ;AN000;
               delete_parser_value_list_entry keywords,current_parm ;AN000;
               MOV   looking_for,com_keyword                            ;AN000;
               MOV   parms_form,keyword                                 ;AN000;tell analyze_and_invoke how to look at the parms
;C00           BREAK 1                                                  ;AN000;
               SHORTBREAK 1                                             ;AN000;;C00

                  .ENDIF                                                ;AN000;


;           baud:    ;found a number that is a valid baud, know that have old com style com request



                  .IF <parser_return_code_AX EQ no_error> THEN   ;AN000;IF have a baud rate THEN (none of above, must be baud rate)

               .IF <parm_list[current_parm_DI].item_tag EQ nineteentwohundred_item_tag> THEN    ;AC002;IF PS2 only baud rate AND
                  MOV   new_com_initialize,true
;C01              .IF <type_of_machine NE PS2> THEN                                             ;AC002;not on PS/2
;C01                 CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01              .ENDIF                                        ;AN000;
               .ENDIF                                           ;AN008;
;AD008;        .ELSE
               MOV   looking_for,parity_or_null                 ;AN000;
               MOV   request_type,initialize_com_port             ;AN000;
;AD008;        .ENDIF
;C00           BREAK 1                                          ;AN000;
               SHORTBREAK 1                                     ;AN000; ;C00

                  .ELSE                   ;AN000;


;           otherwise:

               CALL  setup_invalid_parameter                 ;AN000;
;              BREAK 1

                  .ENDIF

         ENDCASE_1:

         BREAK 0                          ;AN000;



      com_keyword_case:

         ;At this point the com keywords are in the keyword list, the only valid
         ;parms that can follow are com keywords.  Assume that one and only one
         ;com keyword has been found and removed from the list of keywords.

PUBLIC com_keyword_case

         MOV   parms.parmsx_ptr,OFFSET com_keywords_parmsx ;AN000;only com keywords are in the control blocks
         MOV   i_CL,1                                      ;AN000;
         .WHILE <i_CL LE number_of_com_keywords> AND NEAR  ;AN000;one iteration more than number of parms left so will find eol
         .WHILE <eol_found EQ false> AND NEAR                         ;AN000;
         .WHILE <noerror EQ true> DO NEAR                       ;AN000;

            .SELECT                    ;AC002;check for PS/2 specific parms
            .WHEN <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET baud_equal>> THEN   ;AC002;IF synonym ptr=> BAUD= THEN
               .IF <parm_list[current_parm_DI].item_tag EQ nineteentwohundred_item_tag> THEN    ;AC002;IF PS2 only baud rate AND
                  MOV   new_com_initialize,true
;C01              .IF <type_of_machine NE PS2> THEN                                             ;AC002;not on PS/2
;C01                 CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01               .ENDIF
               .ENDIF
            .WHEN <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET parity_equal>> THEN   ;AC002;IF parity= THEN
               .IF <parm_list[current_parm_DI].item_tag EQ mark_item_tag> OR      ;AC002;IF PS2 only parity
               .IF <parm_list[current_parm_DI].item_tag EQ space_item_tag> THEN    ;AC002;IF PS2 only parity AND
                  MOV   new_com_initialize,true
;C01              .IF <type_of_machine NE PS2> THEN                                             ;AC002;not on PS/2
;C01                 CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01              .ENDIF
               .ENDIF
            .WHEN <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET data_equal>> THEN   ;AC002;IF data= THEN
               .IF <parm_list[current_parm_DI].item_tag EQ five_item_tag> OR      ;AC002;IF PS2 only data bits
               .IF <parm_list[current_parm_DI].item_tag EQ six_item_tag> THEN    ;AC002;IF PS2 only data bits AND
                  MOV   new_com_initialize,true
;C01              .IF <type_of_machine NE PS2> THEN                                             ;AC002;not on PS/2
;C01                 CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01              .ENDIF
               .ENDIF
            .WHEN <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET stop_equal>> THEN   ;AC002;IF stop= THEN
               .IF <parm_list[current_parm_DI].item_tag EQ one_point_five_item_tag> THEN    ;AC002;IF PS2 only stop bits AND
                  MOV   new_com_initialize,true
;C01              .IF <type_of_machine NE PS2> THEN                                             ;AC002;not on PS/2
;C01                 CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01              .ENDIF
               .ENDIF
            .ENDSELECT

            PUSH  CX                         ;save the loop index
            CALL  parse_parm                                    ;AN000;
            POP   CX

            .IF <noerror EQ true> AND
            .IF <parser_return_code_AX EQ no_error> THEN        ;AN000;

               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET baud_equal>> THEN   ;AN000;IF synonym ptr=> BAUD= THEN
                  MOV   baud_specified,true                        ;AN000;
               .ENDIF                                                   ;AN000;
               delete_parser_value_list_entry keywords,current_parm ;AN000;
               INC   i_CL                                               ;AN000;

            .ELSEIF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               .IF <baud_specified EQ true> THEN                ;AN000;
                  MOV   request_type,initialize_com_port             ;AN000;
               .ELSE                                                 ;AN000;
                  MOV   message,OFFSET baud_rate_required                   ;AN000;
                  MOV   noerror,false
               .ENDIF                                                ;AN000;
               MOV   eol_found,true                        ;AN000;

            .ELSE NEAR                        ;AN000;

               CALL  setup_invalid_parameter                 ;AN000;

            .ENDIF                                      ;AN000;

         .ENDWHILE                                                      ;AN000;

         MOV   looking_for,eol           ;AN000;if haven't already encountered an error then check for extraneous parms

         BREAK 0    ;AN000;com_keyword


      status_or_eol_case:

;     status_or_eol:    ;Have found the only or the last status qualifier, must find /STATUS or eol_found NExt
                        ;Assume that /STATUS is the only switch in the appropriate parser control block
                        ;Assume that request_type has already been set

         CALL  parse_parm                 ;AN000;

         .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_sta>> OR            ;AN000;
         .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_stat>> OR   ;AC004;
         .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_status>> THEN   ;AN000;found /status

            MOV   looking_for,eol                            ;AN000;

         .ELSEIF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;encountered EOL

            MOV   eol_found,true                ;AN000;

         .ELSE                  ;AN000;

            CALL  setup_invalid_parameter      ;AN000;

         .ENDIF

         BREAK 0   ;status_or_eol                       ;AN000;



      parity_or_null_case:

PUBLIC   parity_or_null_case

         ;the parser control blocks have paritys as strings
         ;modify parser control blocks list of valid paritys based on the
         ;machine type.


         CALL  parse_parm                               ;AN000;

	 .IF <parser_return_code_AX EQ operand_missing> THEN   ;AN000;valid null
            MOV   looking_for,databits_or_null      ;AN000;can't have baud,,eol
         .ELSE                                          ;AN000;
;           CASE current_parm=

;           /?:

                  .IF <parser_return_code_AX EQ no_error>
                     SHORTBREAK  5
                  .ENDIF


;              eol:

                     .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;valid

                  MOV   request_type,initialize_com_port
                  MOV   eol_found,true             ;AN000;
;C00              BREAK 5                    ;AN000;
                  SHORTBREAK 5               ;AN000;                    ;C00

                     .ENDIF

;              parity:

                     .IF <parser_return_code_AX EQ no_error> THEN    ;AN000;IF have a parity THEN (none of above, must be parity)

                  MOV   looking_for,databits_or_null                    ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ mark_item_tag> OR     ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ space_item_tag> THEN   ;AN000;
                     MOV   new_com_initialize,true
;C01                 .IF <type_of_machine NE PS2> THEN  ;AN000;IF not Roundup or later
;C01                    CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01                 .ENDIF                             ;AN000;                     ;AN000;
                  .ENDIF                                ;AN000;

                     .ELSE

;              otherwise:

                  CALL  setup_invalid_parameter       ;AN000;
;                 BREAK

                     .ENDIF                                              ;AN000;

            ENDCASE_5:           ;current_parm

         .ENDIF                                                         ;AN000;
         BREAK 0  ;AN000;parity_or_null




      databits_or_null_case:


PUBLIC      databits_or_null_case

         ;parser control blocks have all databits (as strings).
         ;modify parser control blocks to handle list of valid databits
         ;based on the machine type.

;AC002;  .IF <type_of_machine NE PS2> THEN  ;AN000;IF not Roundup or later
;AC002;     MOV   five_str,deleted     ;delete parser value list entry ;AN000;
;AC002;     MOV   six_str,deleted          ;delete_parser_value_list_entry ;AN000;
;AC002;  .ENDIF                                                         ;AN000;

         ;the parser control blocks have data bits valid for this machine
         CALL  parse_parm                                       ;AN000;

         .IF <parser_return_code_AX EQ operand_missing> THEN   ;AN000;valid null
            MOV   looking_for,stopbits_or_null            ;can't have databits,,eol
         .ELSE                                                          ;AN000;
;           CASE current_parm=

;              eol:

                     .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;valid

                  MOV   request_type,initialize_com_port                ;AN000;
                  MOV   eol_found,true                        ;AN000;
;C00              BREAK 6                                               ;AN000;
                  SHORTBREAK 6                                          ;AN000;;C00

                     .ENDIF                                             ;AN000;


;              databits:

                     .IF <parser_return_code_AX EQ no_error> THEN    ;AN000;IF have a parity THEN (none of above, must be parity)

                  MOV   looking_for,stopbits_or_null                    ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ five_item_tag> OR      ;AC002;
                  .IF <parm_list[current_parm_DI].item_tag EQ six_item_tag> THEN    ;AC002;
                     MOV   new_com_initialize,true
;C01                 .IF <type_of_machine NE PS2> THEN  ;AC002;IF not Roundup or later
;C01                    CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01                 .ENDIF                             ;AC002;                     ;AN000;
                  .ENDIF                                ;AC002;
;                 BREAK 6                                               ;AN000;

                     .ELSE                                             ;AN000;


;              otherwise:

                  CALL  setup_invalid_parameter       ;AN000;
;                 BREAK

                     .ENDIF

            ENDCASE_6: ;current_parm

         .ENDIF                                                         ;AN000;
         BREAK 0  ;AN000;databits_or_null



      stopbits_or_null_case:


PUBLIC      stopbits_or_null_case

         ;parser control blocks have all stopbits (as strings).
         ;modify parser control blocks to handle list of valid stopbits
         ;based on the machine type.

;AC002;  .IF <type_of_machine NE PS2> THEN  ;AN000;IF not Roundup or later
;AC002;     MOV   one_point_five_str,deleted   ;delete_parser_value_list_entry  ;AN000;
;AC002;  .ENDIF                                                         ;AN000;


         CALL  parse_parm                                               ;AN000;
         .IF <parser_return_code_AX EQ operand_missing> THEN   ;AN000;valid null
            MOV   looking_for,P                 ;AN000;no null just before eol
         .ELSE                                  ;AN000;
;           CASE current_parm=

;           /?:

                  .IF <parser_return_code_AX EQ no_error>
                     SHORTBREAK  7
                  .ENDIF


;              eol:

                     .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;valid

                  MOV   BYTE PTR request_type,initialize_com_port        ;AN000;
                  MOV   eol_found,true                        ;AN000;
;C00              BREAK 7                               ;AN000;
                  SHORTBREAK 7                          ;AN000;         ;C00

                     .ENDIF


;              stopbits:


                     .IF <parser_return_code_AX EQ no_error> THEN    ;AN000;IF have a parity THEN (none of above, must be parity)

                  MOV   looking_for,P             ;AN000;P or eol valid next
                  .IF <parm_list[current_parm_DI].item_tag EQ one_point_five_item_tag> THEN    ;AC002;
                     MOV   new_com_initialize,true
;C01                 .IF <type_of_machine NE PS2> THEN  ;AC002;IF not Roundup or later
;C01                    CALL  setup_for_not_supported  ;AC002;set up for "Function not supported on this computer" message
;C01                 .ENDIF                             ;AC002;                     ;AN000;
                  .ENDIF                                ;AC002;

                     .ELSE


;              otherwise:

                  CALL  setup_invalid_parameter       ;AN000;
;                 BREAK

                     .ENDIF

            ENDCASE_7: ;current_parm

         .ENDIF                                         ;AN000;
         BREAK 0 ;AN000;stopbits_or_null




      P_case:           ;P or eol valid


PUBLIC P_case

         ;P is in the parser control blocks' list of strings.

         CALL parse_parm                                                ;AN000;
;        CASE current_parm=

;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;valid

               MOV   eol_found,true                ;AN000;
;C00           BREAK 8                       ;AN000;
               SHORTBREAK 8                  ;AN000;                    ;C00

                  .ENDIF



;           P:

                  .IF <parser_return_code_AX EQ no_error> THEN   ;AN000;found one of: p,e,b,r,n,none,off

               MOV   looking_for,eol      ;AN000;found last positional
               MOV   retry_requested,true

                  .ELSE


;           otherwise:

               CALL  setup_invalid_parameter       ;AN000;

                  .ENDIF


         ENDCASE_8: ;current_parm

         BREAK 0  ;AN000;P



;m
      prn_kw_status_cp_cl_null_case:

      PUBLIC   prn_kw_status_cp_cl_null_case

      ;Have encountered only LPTX so far, so any printer stuff including codepage
      ;requests can follow. All necessary keywords and switches are in the control blocks.


         CALL  parse_parm                                      ;AN000;

;        CASE current_parm=

;           LPT_mode_keyword:              ;nothing but printer keywords allowed


                  .IF <parser_return_code_AX EQ no_error> AND NEAR                                    ;AN000;
;                 .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET COLUMNS_equal>> OR   ;AN000;
;                 .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET COLS_equal>> OR   ;AN000;
;                 .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET lines_equal>> OR  ;AN000;
;                 .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET retry_equal_str>> THEN ;AN000;found a printer keyword


                  check_for_lpt_keyword      ;check for COLS= or LINES= or RETRY=, return results in match_found
                  .IF <match_found EQ true> THEN NEAR

               delete_parser_value_list_entry keywords,current_parm  ;AN000;
               MOV   parms_form,keyword                 ;AN000;indicate to modeprin how to deal with retry
               CALL  parse_parm                              ;AN000;
               MOV   DL,1                       ;AN000;one keyword found so far

               .REPEAT

;                 CASE return_code=

;                    LPT_keyword:


                           .IF <parser_return_code_AX EQ no_error> AND                                         ;AN000;
                           PUSH  DX                     ;save loop index
                           check_for_lpt_keyword      ;return results in match_found
                           POP   DX
                           .IF <match_found EQ true> THEN

                        .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET retry_equal_str>> AND
                        .IF <parm_list[current_parm_DI].item_tag NE NONE_item_tag> THEN
                           MOV   retry_requested,true   ;set up for rescode
                        .ENDIF
                        delete_parser_value_list_entry keywords,current_parm  ;AN000;
                        INC   DL                ;AN000;found another keyword
;C00                    BREAK 9                 ;AN000;
                        SHORTBREAK 9            ;AN000;                 ;C00

                           .ENDIF


;                    eol:

                           .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;valid

                        ;had at least one keyword
                        MOV   request_type,initialize_printer_port     ;AN000;
                        MOV   eol_found,true                          ;AN000;
;C00                    BREAK 9                                 ;AN000;
                        SHORTBREAK 9                            ;AN000;;C00

                           .ENDIF


;                    otherwise:     ;wrong type of keywords, /STATUS etc.

                        CALL  setup_invalid_parameter       ;AN000;
;                       BREAK

                  ENDCASE_9:

                  PUSH  DX
                  CALL  parse_parm                              ;AN000;
                  POP   DX

               .UNTIL <DL EQ number_of_LPT_keywords> OR              ;AN000;
               .UNTIL <eol_found EQ true> OR                                  ;AN000;
               .UNTIL <noerror EQ false>                                ;AN000;

;              .IF <eol_found NE true> AND
               .IF <noerror EQ true> AND                                ;AN000;
               .IF <DL EQ number_of_LPT_keywords> THEN              ;AN000;
                  MOV   looking_for,eol           ;AN000;check for extraneous parms
               .ENDIF                                           ;AN000;

               BREAK 10

                  .ENDIF   ;AN000;LPT_keyword


;           /STATUS:

                  .IF <parser_return_code_AX EQ no_error> AND           ;make sure don't have /STA:value  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_sta>> OR   ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_stat>> OR   ;AC004;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_status>> THEN  ;AN000;found /STATUS

               MOV   looking_for,eol  ;AN000;look for RETRY or codepage
               MOV   slash_status,deleted                               ;AN000;
               MOV   slash_stat,deleted                                 ;AN000;
               MOV   slash_sta,deleted                                  ;AN000;
               MOV   request_type,printer_status                        ;AN000;
               BREAK 10 ;AN000;keyword

                  .ENDIF   ;/STATUS found                               ;AN000;


;           codepage:


                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ 0> AND            ;AC007;wasn't SEL=cpnum or PREP=cpnum
                  .IF <parm_list[current_parm_DI].item_tag EQ codepage_item_tag> THEN     ;AN000;IF found "codepage" or "cp" THEN

               MOV   looking_for,codepage_prms                          ;AN000;
               MOV   codepage_str,deleted                               ;AN000;
               MOV   code_str,deleted                                   ;AN000;
               MOV   cp_str,deleted                                     ;AC007;
               BREAK 10 ;AN000;

                  .ENDIF                                                ;AN000;



;           cl:

                  .IF <parm_list[current_parm_DI].item_tag EQ onethirtytwo_item_tag> OR ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ eighty_item_tag> THEN ;AN000;

               MOV   REFRESH_str,deleted                        ;AC007;no codepage stuff legal
               MOV   REF_str,deleted                            ;AC007;
               MOV   SEL_equal,deleted                          ;AN007;
               MOV   SELECT_equal,deleted                       ;AN007;
               MOV   PREP_equal,deleted                         ;AN007;
               MOV   PREPARE_equal,deleted                      ;AN007;
               MOV   slash_status,deleted                               ;AN007;
               MOV   slash_stat,deleted                                 ;AN007;
               MOV   slash_sta,deleted                                  ;AN007;
               MOV   looking_for,li_or_null                             ;AN000;
               MOV   request_type,old_initialize_printer_port           ;AN000;found enough to know that it isn't status or keyword
               BREAK 10                                                 ;AN000;

                  .ENDIF                                                ;AN000;



;           eol:


                  .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;valid

               MOV   request_type,turn_off_reroute ;compatible with previous MODE     ;AN000;
               MOV   eol_found,true                ;AN000;
               BREAK 10                                                 ;AN000;

                  .ENDIF                                                ;AN000;



;           codepage_keyword_out_of_order:


                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREPARE_equal>> OR  ;AC007;if got here and have
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREP_equal>> OR         ;AC007;one of the codepage
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SEL_equal>> OR          ;AC007;keywords then user
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SELECT_equal>> THEN     ;AC007;forgot "CP"

               MOV   message,OFFSET Invalid_number_of_parameters                                  ;AC007;
               MOV   noerror,false                                                                ;AC007;
;C00           BREAK 10  ;AN000;CON_keyword
               SHORTBREAK 10  ;AN000;CON_keyword                        ;C00

                  .ENDIF



;           REFRESH_out_of_order:   ;AC007;forgot to include "CP"


                  .IF <parm_list[current_parm_DI].item_tag EQ REFRESH_item_tag> THEN  ;AC007;

               MOV   message,OFFSET Invalid_number_of_parameters                                  ;AC007;
               MOV   noerror,false                                                                ;AC007;
;C00           BREAK 10
               SHORTBREAK 10                                            ;C00

                  .ENDIF                                                ;AC007;



;           null:

                  .IF <parser_return_code_AX EQ no_error> AND    ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ unspecified> THEN   ;AN007;valid null

               MOV   REFRESH_str,deleted                        ;AC007;no codepage stuff legal
               MOV   REF_str,deleted                            ;AC007;
               MOV   SEL_equal,deleted                          ;AN007;
               MOV   SELECT_equal,deleted                       ;AN007;
               MOV   PREP_equal,deleted                         ;AN007;
               MOV   PREPARE_equal,deleted                      ;AN007;
               MOV   slash_status,deleted                               ;AN007;
               MOV   slash_stat,deleted                                 ;AN007;
               MOV   slash_sta,deleted                                  ;AN007;
               MOV   looking_for,li_or_null                             ;AN000;
               MOV   request_type,old_initialize_printer_port           ;AN000;found enough to know that it isn't status or keyword



;           otherwise:

                  .ELSE                                                 ;AN000;

               CALL  setup_invalid_parameter       ;AN000;
;              BREAK                                                    ;AN000;

                  .ENDIF                                                ;AN000;


         ENDCASE_10: ;current_parm=                                     ;AN000;
         BREAK 0   ;AN000;prn_kw_status_cp_cl_null_case:




      li_or_null_case:                       ;look for lines per inch or null, eol valid

PUBLIC li_or_null_case


         CALL  parse_parm                    ;AN000;
;        CASE current_parm=

;           li:

                  .IF <parm_list[current_parm_DI].item_tag EQ six_item_tag> OR         ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ eight_item_tag> THEN     ;AN000;IF found 6 or 8 THEN

               MOV   looking_for,P                                      ;AN000;
;C00           BREAK 11
               SHORTBREAK 11                                            ;C00

                  .ENDIF


;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;valid

               MOV   request_type,old_initialize_printer_port               ;AN000;
               MOV   eol_found,true                           ;AN000;
;C00           BREAK 11                                                 ;AN000;
               SHORTBREAK 11                                            ;AN000;;C00

                  .ENDIF


;           null:

                  .IF <parser_return_code_AX EQ no_error> AND    ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ unspecified> THEN   ;AN007;valid null

               MOV   looking_for,P                                   ;AN000;
;C00           BREAK 11                                                 ;AN000;
               SHORTBREAK 11                                            ;AN000;;C00

                  .ENDIF


;           otherwise:

               CALL  setup_invalid_parameter       ;AN000;
;              BREAK


         ENDCASE_11:  ;current_parm                             ;AN000;
         BREAK 0   ;AN000;li_or_null


;m
      codepage_prms_case:


         ;The desired codepage parameters are in the parser control blocks, such
         ;as: the keywords, PREPARE, REFRESH, and /STATUS.
         CALL  parse_parm                                               ;AN000;
;        CASE current_parm=


;           REFRESH:

                  .IF <parm_list[current_parm_DI].item_tag EQ REFRESH_item_tag> THEN  ;AN000;

               MOV   request_type,codepage_refresh                     ;AN000;
               MOV   looking_for,eol
               BREAK 12

                  .ENDIF


;           PREPARE=:


               ;Have to parse ((cplist) [filename])

                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREPARE_equal>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREP_equal>> THEN NEAR  ;AN000;IF PREPARE= THEN

               .IF <parm_list[current_parm_DI].parm_type EQ complx> THEN NEAR  ;AN000;should have found ((cplist) filename)
                  PUSH  SI  ;AN000;save pointer to first char past the closing right paren
                  MOV   AX,parm_list[current_parm_DI].value1    ;AN000;
                  MOV   command_line,AX                         ;AN000;point at first char past the left paren
;C02              SUB   DI,TYPE parm_list_entry                 ;AN000;not parm, just indication of complex, delete from parm list
                  SUB   DI,SIZE parm_list_entry                 ;AN000;not parm, just indication of complex, delete from parm list ;C02
                  MOV   parms.parmsx_ptr,OFFSET prepare_equal_parmsx
                  MOV   prepare_equal_match_flags,complex     ;AN000;only thing valid next
                  CALL  parse_parm              ;AN000;
                  .IF <parser_return_code_AX EQ no_error> AND           ;AN000;
                  .IF <parm_list[current_parm_DI].parm_type EQ complx> THEN       ;AN000;assume have ((cplist) filename)
                     PUSH  SI  ;AN000;save pointer to first char past the closing right paren
                     MOV   AX,parm_list[current_parm_DI].value1    ;AN000;
                     MOV   command_line,AX                         ;AN000;point at first char past the left paren
;C02                 SUB   DI,TYPE parm_list_entry              ;AN000;not parm, just indication of complex, delete from parm list
                     SUB   DI,SIZE parm_list_entry              ;AN000;not parm, just indication of complex, delete from parm list ;C02
                     MOV   prepare_equal_match_flags,numeric+optional ;AN000;number or delimeter only things valid next
                     MOV   ordinal,0                 ;AN000;zap parms count,make parser count codepage numbers
                     .REPEAT                       ;AN000;
                        CALL  parse_parm           ;AN000;
                        .IF <parser_return_code_AX EQ no_error> THEN    ;AN000;  ;AN000;
                           ADD   des_start_packet.des_strt_pklen,2     ;increment size of parm block for another cp number
                           INC   des_start_packet.des_strt_pknum       ;increment number of cp numbers
                           ADD   current_packet_cp_number,2            ;address next code page number slot
                           MOV   SI,current_packet_cp_number
                           MOV   BP,OFFSET des_start_packet
                           .IF <parm_list[current_parm_DI].item_tag EQ codepage_item_tag> THEN  ;AN000;IF not skipped slot THEN
                              MOV   DX,parm_list[current_parm_DI].value1  ;AN000;store the number if one specified for this slot
                              MOV   [SI][BP].des_strt_pkcp1,DX            ;put the number in the slot for the cp number
                           .ENDIF   ;AN000;not valid skipped codepage number, i.e. not (,850,,865) for example
                        .ELSEIF <parser_return_code_AX EQ end_of_complex> THEN ;AN000;
;C02                       SUB   DI,TYPE parm_list_entry        ;don't want an entry in the parm list for the zeroed out ")"
                           SUB   DI,SIZE parm_list_entry        ;don't want an entry in the parm list for the zeroed out ")" ;C02
                        .ELSE
                           CALL  setup_invalid_parameter       ;AN000;
                        .ENDIF                          ;AN000;
                     .UNTIL <parser_return_code_AX EQ end_of_complex> OR ;AN000;came to end of the cplist
                     .UNTIL <noerror EQ false>
                     POP   command_line      ;AN000;resume just after the closing paren of (cplist), should be at ) or filename
                  .ELSE    ;AN000;must be an error
                     MOV   message,OFFSET invalid_number_of_parameters         ;AN000;
                     MOV   noerror,false                                ;AN000;
                  .ENDIF
                  .IF <noerror EQ true> THEN    ;AN000;IF successfully broke down cplist and file name THEN
                     MOV   prepare_equal_match_flags,filespec+optional ;AN000;only thing valid is filespec
                     MOV   ordinal,0                                    ;AN000;don't need parser to count the parms anymore
                     MOV   prepare_min_parms,0                  ;AN000;filename is optional
;                    A filespec may be next so colon cannot be a delimeter.
                     modify_parser_control_block seperator_list,delete,colon  ;AN000;want to find a keyword so don't stop on colons
                     CALL  parse_parm                                      ;AN000;
                     .IF <parser_return_code_AX EQ no_error> THEN          ;AN000;
                        MOV   AX,parm_list[current_parm_DI].value1         ;AN000;AX=OFFSET of filespec just encountered
                        MOV   cp_cb.font_filespec,AX               ;AN000;set up pointer to filespec for modecp
                     .ELSEIF <parser_return_code_AX EQ end_of_complex> THEN  ;AN000;cartridge prepare, no filename
                        MOV   des_start_packet.des_strt_pkfl,DES_STRT_FL_CART     ; 0001H=CARTRIDGE PREPARE,
                     .ELSE                                                 ;AN000;
                        CALL  setup_invalid_parameter       ;AN000;
                     .ENDIF                                     ;AN000;
                     MOV   request_type,codepage_prepare                ;AN000;if encountered an error won't continue anyways
                  .ENDIF                                                ;AN000;
                  POP   command_line         ;AN000;continue parsing after the origional complex, should be eol
               .ELSE                                                    ;AN000;
                  MOV   message,OFFSET invalid_number_of_parameters ;AN000;should have found a complex
                  MOV   noerror,false                                   ;AN000;
               .ENDIF

               MOV   looking_for,eol      ;AN000;

;C00           BREAK 12                                                 ;AN000;
               SHORTBREAK 12                                            ;AN000;;C00

                  .ENDIF


;           SELECT=:


dummy1:
PUBLIC DUMMY1
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SEL_equal>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SELECT_equal>> THEN ;AN000;

               .IF <parser_return_code_AX EQ no_error> THEN             ;AN000;
                  MOV   codepage_index_holder,current_parm_DI           ;AN000;save index of the codepage parm list entry for invoke
                  MOV   request_type,codepage_select                    ;AN000;
                  MOV   looking_for,eol                                 ;AN000;
               .ELSE                                                    ;AN000;
                  CALL  setup_invalid_parameter       ;AN000;
               .ENDIF

;C00           BREAK 12                                                 ;AN000;
               SHORTBREAK 12                                            ;AN000;;C00

                  .ENDIF



;           /STATUS:


                  .IF <parser_return_code_AX EQ no_error> AND           ;make sure don't have /STA:value  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STA>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_stat>> OR   ;AC002;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STATUS>> THEN ;AN000;

               MOV   request_type,codepage_status               ;AN000;
;AX322;        .IF   <device_name EQ <OFFSET CON_str>> THEN
                  MOV   looking_for,eol                         ;AC322;
;AX322;        .ELSE
;AX322;           MOV   looking_for,eol                         ;AN000;
;AX322;        .ENDIF
;C00           BREAK 12                                         ;AN000;
               SHORTBREAK 12                                    ;AN000;;C00

                  .ENDIF


;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               MOV   request_type,codepage_status                       ;AN000;
               MOV   eol_found,true                ;AN000;
;C00           BREAK 12                                                 ;AN000;
               SHORTBREAK 12                                            ;AN000;;C00

                  .ENDIF


;           otherwise:

               CALL  setup_invalid_parameter       ;AN000;
;              BREAK


         ENDCASE_12: ;current_parm=


         BREAK 0                                                        ;AN000;




      codepage_case:       ;found PRN, only valid parms are CODEPAGE, and /STATUS
                           ;/STATUS is in the the parser control blocks

         CALL  parse_parm                                               ;AN000;
;        CASE current_parm=

;           CODEPAGE:

                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ 0> AND            ;AC007;wasn't SEL=cpnum or PREP=cpnum
                  .IF <parm_list[current_parm_DI].item_tag EQ codepage_item_tag> THEN     ;AN000;IF found "codepage" or "cp" THEN

               ;set up for codepage_prms_case
;              modify_parser_control_block keywords,addd,codepage_keywords  ;AN000;codepage parms handler assumes keywords setup
               mov   ordinal,1
               MOV   looking_for,codepage_prms                         ;AN000;
               BREAK 13                                                 ;AN000;

                  .ENDIF


;           /STATUS:       ;only CODEPAGE or end of line valid next

                  .IF <parser_return_code_AX EQ no_error> AND           ;make sure don't have /STA:value  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STA>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_stat>> OR   ;AC004;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STATUS>> THEN ;AN000;

               CALL  parse_parm                                         ;AN000;
               .IF <parm_list[current_parm_DI].item_tag EQ codepage_item_tag> THEN  ;AN000;
                  MOV   looking_for,eol ;AN000;
                  MOV   status_request,true
                  MOV   request_type,codepage_status    ;AN000;
               .ELSEIF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;
                  MOV   eol_found,true                                  ;AC005;
                  MOV   status_request,true                             ;AC005;
                  MOV   request_type,codepage_status    ;AC005;
               .ELSE                                            ;AN000;
                  CALL  setup_invalid_parameter       ;AN000;
               .ENDIF
;C00           BREAK 13                                                 ;AN000;
               SHORTBREAK 13                                            ;AN000;;C00

                  .ENDIF


;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               MOV   request_type,codepage_status                       ;AN000;
               MOV   eol_found,true                ;AN000;
;C00           BREAK 13                                         ;AN000;
               SHORTBREAK 13                                    ;AN000;;C00

                  .ENDIF



;           codepage_keyword_out_of_order:


                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREPARE_equal>> OR  ;AC007;if got here and have
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREP_equal>> OR         ;AC007;one of the codepage
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SEL_equal>> OR          ;AC007;keywords then user
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SELECT_equal>> THEN     ;AC007;forgot "CP"

               MOV   message,OFFSET Invalid_number_of_parameters                                  ;AC007;
               MOV   noerror,false                                                                ;AC007;
;C00           BREAK 13  ;AN000;CON_keyword
               SHORTBREAK 13  ;AN000;CON_keyword                        ;C00

                  .ENDIF



;           REFRESH_out_of_order:   ;AC007;forgot to include "CP"


                  .IF <parm_list[current_parm_DI].item_tag EQ REFRESH_item_tag> THEN  ;AC007;

               MOV   message,OFFSET Invalid_number_of_parameters                                  ;AC007;
               MOV   noerror,false                                                                ;AC007;
;              BREAK 13

                  .ELSE                                         ;AC007;



;           otherwise:

               CALL  setup_invalid_parameter       ;AN000;
;              BREAK

                  .ENDIF                                                ;AC007;

         ENDCASE_13:

         BREAK 0  ;AN000;



      con_kwrd_status_or_cp_case:

      PUBLIC   con_kwrd_status_or_cp_case

         MOV   parms.parmsx_ptr,OFFSET con_parmsx
         CALL  parse_parm                                       ;AN000;

;        CASE current_parm=



;           codepage:

                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ 0> AND            ;AC007;wasn't SEL=cpnum or PREP=cpnum
                  .IF <parm_list[current_parm_DI].item_tag EQ codepage_item_tag> THEN     ;AN000;IF found "codepage" or "cp" THEN

               MOV   looking_for,codepage_prms                         ;AN000;
               BREAK 14                                         ;AN000;

                  .ENDIF


;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN   ;AN000;

               MOV   request_type,all_con_status        ;AN000;found only CON on the command line
               MOV   eol_found,true             ;AN000;
               BREAK 14                                 ;AN000;

                  .ENDIF



;           /STATUS:

                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STA>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_stat>> OR   ;AC004;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STATUS>> THEN ;AN000;

               MOV   slash_status,deleted  ;AN000;
               MOV   slash_stat,deleted         ;AN000;
               MOV   slash_sta,deleted  ;AN000;
               MOV   request_type,all_con_status        ;AN000;found only CON on the command line
               MOV   looking_for,eol                    ;AC665;have MODE CON /STATUS, must find eol now
               BREAK 14                                         ;AN000;

                  .ENDIF



;           con_keyword:


                  .IF <parser_return_code_AX EQ no_error> AND           ;make sure invalid value not specified ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr NE 0> THEN  ;not pointing to /sta, not 0, must be a keyword

               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET rate_equal>> OR                               ;AN000;
               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET del_equal>> OR                                ;AN000;
               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET delay_equal>> THEN                            ;AN000;
                  INC   rate_and_delay_found            ;found one, needs to be 2 before valid;AN000;
               .ELSEIF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREPARE_equal>> OR  ;AC007;if got here and have
               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET PREP_equal>> OR         ;AC007;one of the codepage
               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SEL_equal>> OR          ;AC007;keywords then user
               .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET SELECT_equal>> THEN     ;AC007;forgot "CP"
                  MOV   message,OFFSET Invalid_number_of_parameters                                  ;AC007;
                  MOV   noerror,false                                                                ;AC007;
               .ELSE
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr NE <OFFSET COLUMNS_equal>> AND  ;AC007;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr NE <OFFSET COLS_equal>> AND  ;AC007;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr NE <OFFSET lines_equal>> THEN ;AC007;
                     CALL  setup_invalid_parameter       ;AC007;keyword other than LINES=, COLS=, RATE= or DELAY= would require CP
                  .ENDIF                                 ;AC007;and be handled above
               .ENDIF                                                                                                      ;AN000;
               delete_parser_value_list_entry keywords,current_parm ;AN000;doesn't affect anything if invalid parm
               MOV   looking_for,CON_keyword                            ;AN000;doesn't affect anything if invalid parm
;C00           BREAK 14  ;AN000;CON_keyword
               SHORTBREAK 14  ;AN000;CON_keyword                        ;C00

                  .ENDIF



;           REFRESH:                ;AC007;forgot to include "CP"


                  .IF <parm_list[current_parm_DI].item_tag EQ REFRESH_item_tag> THEN  ;AC007;

               MOV   message,OFFSET Invalid_number_of_parameters                                  ;AC007;
               MOV   noerror,false                                                                ;AC007;
;              BREAK

                  .ELSE                                 ;AC007;



;           otherwise:

               CALL  setup_invalid_parameter       ;AN000;
;              BREAK

                  .ENDIF                                ;AC007;



         ENDCASE_14:
         BREAK 0   ;AN000;con_kwrd_status_or_cp_case:




      con_keyword_case:          ;found one, it has been deleted from the parser control blocks
      PUBLIC con_keyword_case

         MOV   slash_status,deleted  ;AN000;remove /STA /STAT and STATUS
         MOV   slash_stat,deleted         ;AN000;
         MOV   slash_sta,deleted  ;AN000;

         MOV   i_CL,1                                      ;AN000;
         .WHILE <i_CL LT number_of_con_keywords> AND       ;AN000;
         .WHILE <eol_found EQ false> AND                              ;AN000;
         .WHILE <noerror EQ true> DO                            ;AN000;
            PUSH  CX

            CALL  parse_parm                                    ;AN000;

;           CASE return_code=

;              con_keyword:

                     .IF <parser_return_code_AX EQ no_error> AND           ;make sure don't have /STA:value  ;AN000;
                     .IF <parm_list[current_parm_DI].keyword_switch_ptr NE 0> THEN  ;not 0, must be a keyword              ;AN000;

                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET rate_equal>> OR                            ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET del_equal>> OR                             ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET delay_equal>> THEN                         ;AN000;
                     INC   rate_and_delay_found            ;found one, needs to be 2 before valid;AN000;
                  .ENDIF
                  delete_parser_value_list_entry keywords,current_parm ;AN000;
                  INC   i_CL                                               ;AN000;
;C00              BREAK 15                                              ;AN000;
                  SHORTBREAK 15                                         ;AN000;;C00

                     .ENDIF                                                ;AN000;


;              eol:

                     .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

                  .IF <rate_and_delay_found EQ both> OR                 ;IF both OR neither found THEN
                  .IF <rate_and_delay_found EQ false> THEN
                     MOV   request_type,set_con_features                   ;AN000;
                     MOV   eol_found,true                    ;AN000;
                  .ELSE
                     MOV   message,OFFSET rate_and_delay_together       ;RATE and DELAY must be specified together
                     MOV   noerror,false
                  .ENDIF
;C00              BREAK 15                                              ;AN000;
                  SHORTBREAK 15                                         ;AN000;;C00

                     .ENDIF


;              otherwise:

                  CALL  setup_invalid_parameter       ;AN000;
;                 BREAK

            ENDCASE_15:

            POP   CX

         .ENDWHILE                        ;AN000;

         MOV   looking_for,eol           ;AN000;check for extraneous parms

         BREAK 0 ;AN000;CON_keyword




      sd_or_dl_or_eol_case:

PUBLIC sd_or_dl_or_eol_case

         ;have found a screen mode, now may find sd, dl, or eol

         CALL   parse_parm                                              ;AN000;
;        CASE current_parm=

;           sd:                        ;found R or L

                  .IF <parm_list[current_parm_DI].item_tag EQ L_item_tag> OR   ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ R_item_tag> THEN ;AN000;

               MOV   looking_for,T_or_EOL                       ;AN000;request_type already set
;C00           BREAK 17                                         ;AN000;
               SHORTBREAK 17                                    ;AN000;;C00

                  .ENDIF

;           dl:

                  .IF <parm_list[current_parm_DI].item_tag EQ fourtythree_item_tag> OR ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ fifty_item_tag> OR   ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ twentyfive_item_tag> THEN ;AN000;

               MOV   looking_for,eol            ;AN000;request_type already set
;C00           BREAK 17                                         ;AN000;
               SHORTBREAK 17                                    ;AN000;;C00

                  .ENDIF



;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               MOV   eol_found,true                   ;AN000;request_type already set
;C00           BREAK 17                                                 ;AN000;
               SHORTBREAK 17                                            ;AN000;;C00

                  .ENDIF


;           otherwise:     regardless of what follows must have a parm here, didn't so yell

               .IF <parser_return_code_AX EQ operand_missing> THEN      ;AN000;two commas with nothing in between
                  MOV   message,OFFSET Invalid_number_of_parameters   ;AN000;
                  MOV   noerror,false                                   ;AN000;
               .ELSE                                                    ;AN000;
                  CALL  setup_invalid_parameter                       ;AN000;some bogus value or string
               .ENDIF                                                   ;AN000;

;              BREAK


         ENDCASE_17:
         BREAK 0  ;AN000;sd_or_dl_or_null



      sd_or_dl_case:

PUBLIC sd_or_dl_case

         ;have no first parm, now must find shift direction or screen lines


         CALL   parse_parm                                              ;AN000;
;        CASE current_parm=

;           sd:

                  .IF <parm_list[current_parm_DI].item_tag EQ L_item_tag> OR   ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ R_item_tag> THEN ;AN000;

               MOV   looking_for,T_or_EOL                               ;AN000;
               MOV   request_type,old_video_mode_set                   ;AN000;
;C00           BREAK 18                                                 ;AN000;
               SHORTBREAK 18                                            ;AN000;;C00

                  .ENDIF


;           dl:

                  .IF <parm_list[current_parm_DI].item_tag EQ fourtythree_item_tag> OR ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ fifty_item_tag> OR   ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ twentyfive_item_tag> THEN ;AN000;

               MOV   request_type,old_video_mode_set     ;AN000;
               MOV   looking_for,eol                  ;AN000;
;C00           BREAK 18                                                 ;AN000;
               SHORTBREAK 18                                            ;AN000;;C00

                  .ENDIF



;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               MOV   message,OFFSET invalid_number_of_parameters               ;AN000;
               MOV   noerror,false                                      ;AN000;
               MOV   eol_found,true                           ;AN000;
;C00           BREAK 18                                                 ;AN000;
               SHORTBREAK 18                                            ;AN000;;C00

                  .ENDIF


;           otherwise:

               .IF <parser_return_code_AX EQ operand_missing> THEN      ;AN000;two commas with nothing in between
                  MOV   message,OFFSET Invalid_number_of_parameters   ;AN000;
                  MOV   noerror,false                                   ;AN000;
               .ELSE                                                    ;AN000;
                  CALL  setup_invalid_parameter                       ;AN000;some bogus value or string
               .ENDIF                                                   ;AN000;
;              BREAK

         ENDCASE_18:
         BREAK 0   ;AN000;sd_or_dl



      T_or_EOL_case:


         CALL  parse_parm                                       ;AN000;

;        CASE current_parm=

;           T:

                  .IF <parm_list[current_parm_DI].item_tag EQ T_item_tag> THEN ;AN000;

               MOV   looking_for,eol      ;AN000;request_type already set
;C00           BREAK 19                                         ;AN000;
               SHORTBREAK 19                                    ;AN000;;C00

                  .ENDIF

;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               MOV   eol_found,true             ;AN000;request_type already set
;C00           BREAK 19                                         ;AN000;
               SHORTBREAK 19                                    ;AN000;;C00

                  .ENDIF


;           otherwise:

               CALL  setup_invalid_parameter       ;AN000;
;              BREAK

         ENDCASE_19:
         BREAK 0              ;AN000;



      device_name_or_eol_case:        ;have only /status so far

         ;The device names are in the parser control blocks

         CALL   parse_parm
;        CASE current_parm=

;           COM?:

                  MOV  device_name,OFFSET COM1_str                                ;AC001;
                  .IF <parm_list[current_parm_DI].item_tag EQ COM1_item_tag> OR   ;AN000;
                  MOV  device_name,OFFSET COM2_str                                ;AC001;
                  .IF <parm_list[current_parm_DI].item_tag EQ COM2_item_tag> OR   ;AN000;
                  MOV  device_name,OFFSET COM3_str                                ;AC001;
                  .IF <parm_list[current_parm_DI].item_tag EQ COM3_item_tag> OR   ;AN000;
                  MOV  device_name,OFFSET COM4_str                                ;AC001;
                  .IF <parm_list[current_parm_DI].item_tag EQ COM4_item_tag> THEN ;AN000;

               MOV   looking_for,eol                                 ;AN000;
               MOV   request_type,com_status                         ;AN000;

;C00           BREAK 20                                               ;AN000;
               SHORTBREAK 20                                          ;AN000;;C00

                  .ENDIF


;           LPT?,
            PRN:

                  MOV  device_name,OFFSET LPT1_str                                ;AC001;
                  .IF <parm_list[current_parm_DI].item_tag EQ PRN_item_tag> OR    ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT1_item_tag> OR   ;AN000;
                  MOV  device_name,OFFSET LPT2_str                                ;AC001;
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT2_item_tag> OR   ;AN000;
                  MOV  device_name,OFFSET LPT3_str                                ;AC001;
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT3_item_tag> THEN ;AN000;

               MOV   looking_for,eol        ;AN000;
               MOV   request_type,printer_status                        ;AN000;
;C00           BREAK 20                                                 ;AN000;
               SHORTBREAK 20                                            ;AN000;;C00

                  .ENDIF



;           CON:

                  .IF <parm_list[current_parm_DI].item_tag EQ CON_item_tag> THEN ;AN000;

               MOV   looking_for,eol                              ;AN000;
               MOV   request_type,all_con_status                           ;AN000;
;C00           BREAK 20                                                 ;AN000;
               SHORTBREAK 20                                            ;AN000;C00

                  .ENDIF


;           eol:

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               MOV   request_type,status_for_everything                ;AN000;
               MOV   eol_found,true                           ;AN000;
;C00           BREAK 20                                                 ;AN000;
               SHORTBREAK 20                                            ;AN000;;C00

                  .ENDIF


;           otherwise:

               CALL  setup_invalid_parameter       ;AN000;
;              BREAK

         ENDCASE_20:
         BREAK 0  ;AN000;device_name_or_eol


      first_parm_case:                          ;AN000;


PUBLIC   first_parm_case

         ;set up for calls to system parser

         MOV   command_line,OFFSET first_char_in_command_line   ;AN000;start parser at beginning of the command line
         MOV   BX,OFFSET parm_lst      ;set up parm_list        ;AN000;
         XOR   DI,DI                                            ;AN000;
;C02     SUB   DI,TYPE parm_list_entry       ;AN000;DI is negative, set up for first call to parse_parm
         SUB   DI,SIZE parm_list_entry       ;AN000;DI is negative, set up for first call to parse_parm ;C02

         MOV   parms.parmsx_ptr,OFFSET parmsx      ;AN000;set up parms block for parser input

         CALL   parse_parm     ;AN000;parse first parm, fill in "parm_list[current_parm_DI]" with the results

;        CASE current_parm=

dummy5:
PUBLIC   dummy5

;           /status:

                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STA>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_stat>> OR   ;AC004;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET slash_STATUS>> THEN ;AN000;

               MOV   slash_status,deleted                               ;AN000;make it so /status again is an error
               MOV   slash_stat,deleted         ;AN000;
               MOV   slash_sta,deleted
               MOV   looking_for,device_name_or_eol                     ;AN000;
               BREAK 21                                                 ;AN000;

                  .ENDIF


;           null:                ;no first parm

                  .IF <parser_return_code_AX EQ no_error> AND    ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag EQ unspecified> THEN   ;AN000;valid null

               MOV   looking_for,sd_or_dl                       ;AN000;
               MOV   parms.parmsx_ptr,OFFSET old_con_parmsx
               MOV   ordinal,0                                  ;AN000;start over with new parmsx block
               MOV   device_name,OFFSET CON_str
               MOV   request_type,old_video_mode_set            ;AN000;
               BREAK 21                                         ;AN000;

                  .ENDIF


            screen_modes:         ;first parm is 80, BW80, MONO etc.

            PUBLIC   screen_modes

                  .IF <parm_list[current_parm_DI].item_tag GE first_screen_mode_item_tag> AND ;AN000;
                  .IF <parm_list[current_parm_DI].item_tag LE last_screen_mode_item_tag> THEN ;AN000;

               MOV   parms.parmsx_ptr,OFFSET old_con_parmsx
               MOV   ordinal,0                                  ;AN000;start over with new parmsx block
               MOV   device_name,OFFSET CON_str
               MOV   looking_for,sd_or_dl_or_eol                ;AN000;
               MOV   request_type,old_video_mode_set            ;AN000;
               BREAK 21                                         ;AN000;

                  .ENDIF



;           LPT?132,
;           LPT?80:

                  MOV   device_name,OFFSET LPT1_str                       ;AN000;assume LPT1
                  MOV   device,"1"                              ;AC664;set up message
                  MOV   LPTNO,"1"                  ;see modeprin
;C02              MOV   parm_list[current_parm_DI+TYPE parm_list_entry].item_tag,onethirtytwo_item_tag   ;AN000;save chars/line
                  MOV   parm_list[current_parm_DI+SIZE parm_list_entry].item_tag,onethirtytwo_item_tag   ;AN000;save chars/line ;C02
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT1132_item_tag> OR ;AN000;
                  MOV   device_name,OFFSET LPT2_str                       ;AN000;assume LPT2
                  MOV   LPTNO,"2"                  ;see modeprin
                  MOV   device,"2"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT2132_item_tag> OR ;AN000;
                  MOV   device_name,OFFSET LPT3_str                       ;AN000;assume LPT3
                  MOV   LPTNO,"3"                  ;see modeprin
                  MOV   device,"3"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT3132_item_tag> OR ;AN000;
                  MOV   device_name,OFFSET LPT1_str                       ;AN000;assume LPT1
                  MOV   device,"1"                              ;AC664;set up message
                  MOV   LPTNO,"1"                  ;see modeprin
;C02              MOV   parm_list[current_parm_DI+TYPE parm_list_entry].item_tag,eighty_item_tag          ;AN000;save chars/line
                  MOV   parm_list[current_parm_DI+SIZE parm_list_entry].item_tag,eighty_item_tag          ;AN000;save chars/line ;C02
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT180_item_tag > OR ;AN000;
                  MOV   device_name,OFFSET LPT2_str                       ;AN000;assume LPT2
                  MOV   LPTNO,"2"                  ;see modeprin
                  MOV   device,"2"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT280_item_tag > OR ;AN000;
                  MOV   device_name,OFFSET LPT3_str                       ;AN000;assume LPT3
                  MOV   LPTNO,"3"                  ;see modeprin
                  MOV   device,"3"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT380_item_tag > THEN ;AN000;


;C02           ADD   DI,TYPE parm_list_entry                    ;AN000;already have chars per line so skip to next element in list
               ADD   DI,SIZE parm_list_entry                    ;AN000;already have chars per line so skip to next element in list ;C02
               MOV   parms.parmsx_ptr,OFFSET lpt_parmsx         ;AN000;
               MOV   REFRESH_str,deleted                        ;AN007;no codepage stuff legal
               MOV   REF_str,deleted                            ;AN007;
               MOV   SEL_equal,deleted                          ;AN007;
               MOV   SELECT_equal,deleted                       ;AN007;
               MOV   PREP_equal,deleted                         ;AN007;
               MOV   PREPARE_equal,deleted                      ;AN007;
               MOV   ordinal,1                          ;AN000;already found chars per line (cl)
               MOV   looking_for,li_or_null                     ;AN000;
               MOV   device_type,LPTX                           ;AN000;
               MOV   request_type,old_initialize_printer_port   ;AN000;
               BREAK 21                                         ;AN000;

                  .ELSE                   ;AN000;clean up after dorking the next parameter
;C02                 ADD   DI,TYPE parm_list_entry      ;AN000;point to next entry, the one that needs to be reinitialized
                     ADD   DI,SIZE parm_list_entry      ;AN000;point to next entry, the one that needs to be reinitialized ;C02
                     CALL  reset_parm_pointer           ;AN000;reinitialize the second parm entry, DEC DI
                  .ENDIF



;           LPT1:=,
;           LPT1=,
;           LPT2:=,
;           LPT2=,
;           LPT3:=,
;           LPT3=:


                  ;have control blocks set up to find COM strings as value of keyword

                  MOV  lptno,0                             ;lptno=BIOS digestable printer number for LPT1 set up for modeecho
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET LPT1_colon_equal>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET LPT1_equal>> OR  ;AN000;
                  MOV   lptno,1                                                                           ;set up for modeecho
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET LPT2_colon_equal>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET LPT2_equal>> OR  ;AN000;
                  MOV   lptno,2                                                                           ;set up for modeecho
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET LPT3_colon_equal>> OR  ;AN000;
                  .IF <parm_list[current_parm_DI].keyword_switch_ptr EQ <OFFSET LPT3_equal>> THEN      ;AN000;
                     MOV   device,"1"                                                    ;set up for call to modeecho
                     .IF <parm_list[current_parm_DI].item_tag EQ COM1_item_tag> OR   ;AN000;
                     MOV   device,"2"                                                    ;set up for call to modeecho
                     .IF <parm_list[current_parm_DI].item_tag EQ COM2_item_tag> OR   ;AN000;
                     MOV   device,"3"                                                    ;set up for call to modeecho
                     .IF <parm_list[current_parm_DI].item_tag EQ COM3_item_tag> OR   ;AN000;
                     MOV   device,"4"                                                    ;set up for call to modeecho
                     .IF <parm_list[current_parm_DI].item_tag EQ COM4_item_tag> THEN ;AN000;

               MOV   looking_for,eol                         ;AN000;
               MOV   request_type,printer_reroute                   ;AN000;
               MOV   reroute_requested,true                          ;AN000;
               MOV   device_type,LPTX
               BREAK 21                                                 ;AN000;

                     .ELSE                                                    ;AN000;
                        MOV   message,OFFSET com1_or_com2      ;AN000;"Must specify COM1, COM2, COM3 or COM4"
                     .ENDIF
                  .ENDIF



;           LPTX,:                     found "LPTX," so chars per line has been skipped

                  .IF <terminating_delimeter EQ comma> AND NEAR ;AC007;handle other cases later, looking only for "LPTX," now
                  MOV   device_name,OFFSET LPT1_str                       ;AN000;assume LPT1
                  MOV   device,"1"                              ;AC664;set up message
                  MOV   LPTNO,"1"                  ;see modeprin
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT1_item_tag> OR   ;AN000;
                  MOV   device_name,OFFSET LPT2_str                       ;AN000;assume LPT2
                  MOV   LPTNO,"2"                  ;see modeprin
                  MOV   device,"2"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT2_item_tag> OR   ;AN000;
                  MOV   device_name,OFFSET LPT3_str                       ;AN000;assume LPT3
                  MOV   LPTNO,"3"                  ;see modeprin
                  MOV   device,"3"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT3_item_tag> THEN ;AN000;

               MOV   parms.parmsx_ptr,OFFSET lpt_parmsx         ;AN000;
               MOV   lines_value_ptr,OFFSET LPT_lines_values            ;AN000;
               MOV   lines_match_flag,simple_string             ;AN000;printer lines values are strings
               MOV   REFRESH_str,deleted                        ;AN007;no codepage stuff legal
               MOV   REF_str,deleted                            ;AN007;
               MOV   SEL_equal,deleted                          ;AN007;
               MOV   SELECT_equal,deleted                       ;AN007;
               MOV   PREP_equal,deleted                         ;AN007;
               MOV   PREPARE_equal,deleted                      ;AN007;
               MOV   ordinal,1                                  ;AN000;new parmsx, skip chars per line positional
;C02           ADD   DI,TYPE parm_list_entry                    ;create entry for skipped chars per line     ;AN000;
               ADD   DI,SIZE parm_list_entry                    ;create entry for skipped chars per line     ;AN000;;C02
               MOV   looking_for,li_or_null                     ;AN000;
               MOV   device_type,LPTX                           ;for rescode
               MOV   request_type,old_initialize_printer_port   ;AN000;
               BREAK 21                                                 ;AN000;

                  .ENDIF




;                 need to use colon as a delimeter in following cases

                  modify_parser_control_block seperator_list,addd,colon  ;AN000;want to stop on colons

                  CALL  reset_parm_pointer      ;reset to first entry in the parm list
                  MOV   ordinal,0               ;start with the first parm again
                  MOV   command_line,OFFSET first_char_in_command_line  ;look at first part of command line again
                  CALL  parse_parm           ;AN000;parse the first parm again


;           COM?:


                  MOV   device_name,OFFSET COM1_str                       ;AN000;assume COM1
                  MOV   device,"1"                              ;AN000;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ COM1_item_tag> OR   ;AN000;
                  MOV   device_name,OFFSET COM2_str                       ;AN000;assume COM2
                  MOV   device,"2"                              ;AN000;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ COM2_item_tag> OR   ;AN000;
                  MOV   device_name,OFFSET COM3_str                       ;AN000;assume COM3
                  MOV   device,"3"                              ;AN000;;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ COM3_item_tag> OR   ;AN000;
                  MOV   device_name,OFFSET COM4_str                       ;AN000;assume COM4
                  MOV   device,"4"                              ;AN000;;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ COM4_item_tag> THEN ;AN000;

               MOV   parms.parmsx_ptr,OFFSET com_parmsx         ;AN000;
               MOV   ordinal,0                          ;AN000;new parmsx, start with new number of positionals, start at first one
               MOV   looking_for,com_keyword_or_baud            ;AN000;
               MOV   device_type,COMX                    ;AN000;;set up for rescode
               BREAK 21                                         ;AN000;

                  .ENDIF



;           LPT?:

                  MOV   device_name,OFFSET LPT1_str                       ;AN000;assume LPT1
                  MOV   device,"1"                              ;AC664;set up message
                  MOV   LPTNO,"1"                  ;see modeprin
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT1_item_tag> OR   ;AN000;
                  MOV   device_name,OFFSET LPT2_str                       ;AN000;assume LPT2
                  MOV   LPTNO,"2"                  ;see modeprin
                  MOV   device,"2"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT2_item_tag> OR   ;AN000;
                  MOV   device_name,OFFSET LPT3_str                       ;AN000;assume LPT3
                  MOV   LPTNO,"3"                  ;see modeprin
                  MOV   device,"3"                              ;AC664;set up message
                  .IF <parm_list[current_parm_DI].item_tag EQ LPT3_item_tag> THEN ;AN000;

               MOV   parms.parmsx_ptr,OFFSET lpt_parmsx         ;AN000;
               MOV   columns_value_ptr,OFFSET LPT_columns_values        ;AN000;
               MOV   lines_value_ptr,OFFSET LPT_lines_values            ;AN000;
               MOV   columns_match_flag,simple_string           ;AN000;printer columns values are strings
               MOV   lines_match_flag,simple_string             ;AN000;printer lines values are strings
               MOV   ordinal,0                                  ;AN000;new parmsx so start over counting positionals
               MOV   looking_for,prn_kw_status_cp_cl_null  ;AN000;
               MOV   device_type,LPTX                           ;for rescode
               BREAK 21                                                 ;AN000;

                  .ENDIF


;           PRN:

                  .IF <parm_list[current_parm_DI].item_tag EQ PRN_item_tag> THEN  ;AN000;

               MOV   looking_for,codepage               ;AN000;
               MOV   device_name,OFFSET LPT1_str        ;AN000;
               BREAK 21                                 ;AN000;

                  .ENDIF


;           CON:

                  .IF <parm_list[current_parm_DI].item_tag EQ CON_item_tag> THEN ;AN000;

               MOV   parms.parmsx_ptr,OFFSET con_parmsx         ;AN000;set up for con parms
               MOV   ordinal,0                                  ;AN000;start over with new parmsx block
               MOV   looking_for,BYTE PTR con_kwrd_status_or_cp   ;AN000;
               MOV   device_name,OFFSET CON_str
               BREAK 21

                  .ENDIF



;           eol:                 ;no parms specified

                  .IF <parser_return_code_AX EQ end_of_command_line> THEN ;AN000;

               MOV   request_type,status_for_everything                ;AN000;
               MOV   eol_found,true                           ;AN000;
               BREAK 21                                                 ;AN000;

                  .ENDIF



;           COM?baud:


                  MOV   parms.parmsx_ptr, OFFSET mutant_COM_parmsx
                  ;for i in 1 through 4 see if the parm is COMi
                  MOV   match_found,false                      ;AN000;
                  MOV   i_CL,0                             ;AN000;CL:="1"
                  .WHILE <i_CL LT 4> AND                ;AN000;
                  .WHILE <match_found EQ false> DO               ;AN000;
                     CALL  reset_parm_pointer              ;AN000;prepare to reparse the parm
                     INC   i_CL        ;AN000;use next number as a delimeter
                     MOV   parm_list[current_parm_DI].item_tag,i_CL        ;AN000;depends on COM1 thru 4 item tags being 1 thru 4
                     PUSH  CX                                   ;AN000;save the loop counter (the binary form)
                     ADD   i_CL,binary_to_ASCII                 ;CL=ASCII representation of the index
                     modify_parser_control_block seperator_list,addd,i_CL   ;AN000;make the number (1 to 4)a seperator
                     MOV   ordinal,0                                    ;AN000;look at first parm each time
                     MOV   command_line,OFFSET first_char_in_command_line   ;set parser up at start of the command line each time
                     PUSH  CX                              ;AN000;save the delimeter (ASCII form)
                     CALL   parse_parm                                ;AN000;
;                    .IF <parm_list[current_parm_DI].item_tag EQ COM_item_tag> THEN ;AN000;isloated "COM" so found "COM?"

                     .IF <parser_return_code_AX EQ no_error> THEN ;AN000;isloated "COM" so found "COMx"
                        MOV   match_found,true                             ;AN000;
                     .ENDIF
                     POP   CX                                 ;AN000;restore the ASCII delimeter
                     modify_parser_control_block seperator_list,delete,i_CL  ;AN000;fix parser control blocks
                     POP   CX                                 ;restore the loop counter
                  .ENDWHILE                                                ;AN000;
                  .IF <match_found EQ true> THEN   ;AN000;IF have COMX THEN look for valid baud
                     .IF <i_CL EQ 1> THEN                       ;AN000;
                        MOV   device_name,OFFSET COM1_str       ;AN000;
                        MOV   parm_list[current_parm_DI].value1,OFFSET COM1_str ;AN000;setup for modecom existence check
                        MOV   device,"1"                              ;AN000;set up message
                     .ELSEIF <i_CL EQ 2> THEN                   ;AN000;
                        MOV   device_name,OFFSET COM2_str       ;AN000;
                        MOV   parm_list[current_parm_DI].value1,OFFSET COM2_str ;AN000;setup for modecom existence check
                        MOV   device,"2"                              ;AN000;set up message
                     .ELSEIF <i_CL EQ 3> THEN                   ;AN000;
                        MOV   device_name,OFFSET COM3_str       ;AN000;
                        MOV   parm_list[current_parm_DI].value1,OFFSET COM3_str ;AN000;setup for modecom existence check
                        MOV   device,"3"                              ;AN000;set up message
                     .ELSE;IF <i_CL EQ 4> THEN                  ;AN000;
                        MOV   device_name,OFFSET COM4_str       ;AN000;
                        MOV   parm_list[current_parm_DI].value1,OFFSET COM4_str ;AN000;setup for modecom existence check
                        MOV   device,"4"                              ;AN000;set up message
                     .ENDIF                                     ;AN000;

               MOV   parms.parmsx_ptr,OFFSET com_parmsx         ;AN000;
               MOV   ordinal,0                          ;AN000;start with baud in new parmsx
               MOV   looking_for,com_keyword_or_baud                 ;AN000;
               MOV   device_type,COMX                           ;set up for rescode
;C00           BREAK 21                                              ;AN000;
               SHORTBREAK 21                                         ;AN000;;C00


;           otherwise:            ;first parm was nothing recognizable

                  .ELSE

dummy4:
PUBLIC   dummy4

               MOV   ordinal,0                                    ;AN000;parse first parm again
               MOV   command_line,OFFSET first_char_in_command_line   ;set parser up at start of the command line one more time
               modify_parser_control_block seperator_list,addd,"."    ;AN000;want to stop on periods
               modify_parser_control_block seperator_list,addd,'"'    ;AN000;want to stop on quotes
               modify_parser_control_block seperator_list,addd,'\'    ;AN000;want to stop on back slashes
               modify_parser_control_block seperator_list,addd,'['    ;AN000;want to stop on left brackets
               modify_parser_control_block seperator_list,addd,']'    ;AN000;want to stop on right brackets
               modify_parser_control_block seperator_list,addd,'+'    ;AN000;want to stop on plus signs
;AC003;        modify_parser_control_block seperator_list,addd,';'    ;AN000;want to stop on semicolons

               CALL  parse_parm
               CALL  setup_invalid_parameter          ;AN000;
;              BREAK

                  .ENDIF

         ENDCASE_21:

;C00     BREAK 0  ;AN000;first_parm
         SHORTBREAK 0  ;AN000;first_parm                                ;C00



      eol_case:

         CALL   parse_parm                                              ;AN000;
         .IF <parser_return_code_AX NE end_of_command_line> THEN        ;AN000;
            MOV   message,OFFSET invalid_number_of_parameters                  ;AN000;
            MOV   noerror,false                                         ;AN000;
         .ELSE NEAR                                             ;AN000;
            MOV   eol_found,true                                ;AN000;
         .ENDIF
;        BREAK



   ENDCASE_0: ;AN000;looking_for=

.ENDWHILE                     ;AN000;

.IF <message NE no_message> THEN
   display  message
.ENDIF

RET

parse_parameters  ENDP







;
;
; SEPERATOR_LIST
; --------------
;
; As the logic in PARSE_PARAMETERS proceeds the posibilities for the next parm
; become apparent and the parser control blocks need to be changed to correctly
; parse the next parm.  This procedure is responsible for manipulating the
; list of seperators as requested.
;
;
;
;
;  INPUT: action (in BX) - A scalar immediate indicating whether the seperator
;                           is to be added or deleted.
;
;         seperator_charactor (in AL) - The seperator character to be added or
;                                        deleted from the seperator list
;
;
;  RETURN: none
;
;
;  MESSAGES: none
;
;
;
;  REGISTER
;  USAGE:
;
;
;
;  CONVENTIONS:
;
;
;  ASSUMPTIONS: The character exists in the list before it is deleted.
;               A character being added is not already in the list.
;               There is no "extra end of line list".
;               Direction flag is cleared so REPs will increment index reg
;               ES and DS are the same and address data
;
;
;
;
;
;
;  SIDE EFFECT:
;
;
;
;
;
;  LOGIC:
;
;
;  CASE action=
;
;     add:
;
;        skip to end of seperators list  ;use parms.seperators_len to find end
;        overwrite zero with AL
;        overwrite blank space holder in the delimeter list with AL
;        INC   parms.seperators_len
;        BREAK
;
;
;     delete:
;
;        DEC   parms.seperators_len
;        scan to seperator char to be deleted
;        shift remaining chars to left
;        put zero at end for length of the extra EOL list
;        BREAK
;
;  ENDCASE
;
;
;


seperator_list  PROC  NEAR

;CASE modifier=

SHL   BX,1                       ;AN000;BX=word displacement into jump table
JMP   jump_table2[BX]            ;AN000;jump to appropriate jump

jump_table2 LABEL WORD

DW    OFFSET add_case             ;AN000;
DW    OFFSET delete_case          ;AN000;


   add_case:


      XOR   BX,BX
      MOV   BL,parms.seperators_len       ;AN000;BX=length of seperators list
      ADD   BX,OFFSET parms
      MOV   [BX].seperators,AL            ;AN000;overwrite blank with AL
      INC   parms.seperators_len          ;AN000;adjust for added seperator
;C00  BREAK 22                            ;AN000;
      SHORTBREAK 22                       ;AN000;                       ;C00


   delete_case:

      ;scan to seperator char to be deleted

      PUSH  DI

      MOV   DI,OFFSET parms
      ADD   DI,OFFSET seperators       ;ES:DI=>seperator list
      REPNE SCASB
      DEC   DI                         ;AN000;DI=>char to be deleted
      MOV   ES:[DI],BYTE PTR blank              ;duplicate but harmless blank

      POP   DI

;C00  BREAK 22                               ;AN000;
      SHORTBREAK 22                          ;AN000;                    ;C00

ENDCASE_22:

RET

seperator_list  ENDP


;-------------------------------------------------------------------------------
;
;
; KEYWORDS
; --------
;
; As the logic in PARSE_PARAMETERS proceeds the posibilities for the next parm
; become apparent and the parser control blocks need to be changed to correctly
; parse the next parm.  This procedure is responsible for manipulating the
; list of keywords as requested.
;
;
;
;
;# INPUT: action (in BX) - A scalar immediate indicating whether the keyword
;#                           is to be added or deleted.
;#
;#
;#        string (in RL) - A scalar immediate or OFFSET, indicating/pointing
;#                           to the keyword or set of keywords to be added
;#                           or deleted.
;
;
;
;  RETURN: none
;
;
;  MESSAGES: none
;
;
;
;
;  REGISTER
;  USAGE:
;
;
;
;  CONVENTIONS:
;
;
;
;
;  ASSUMPTIONS:
;
;
;
;
;  SIDE EFFECT:
;
;
;


keywords PROC NEAR

;           use result.synonym to find the the keyword to delete

            MOV   SI,parm_list[current_parm_DI].keyword_switch_ptr      ;SI=>the keyword string to be deleted
            MOV   BYTE PTR ES:[SI],deleted        ;AN000;zilch out first byte of the keyword string


   RET

keywords  ENDP

;-------------------------------------------------------------------------------


;
;
; PARSE_PARM
; ----------
;
; Add the parm found to the parm_list.  Save the pointer to the current parm
; for use by CALL  reset_parm_pointer.  When a reset call from  reset_parm
; happens the pointer to the last entry in the parm list is decremented, which
; will put the results of the next parse over that entry.
;
;
;
;
;
;
;
;
;
;
;
;  INPUT:
;
;
;  RETURN: The next parm list entry is filled with the results of the call to
;          the parser.  If the parser returns an error other than "end of
;          command line" the entry is not filled in.  If the parser returns
;          "end of command line" the .type field is set to end_of_command_line.
;
;
;  MESSAGES: none
;
;
;
;
;
;
;
;
;
;
;
;  REGISTER
;  USAGE:
;
;
;
;  CONVENTIONS:
;
;
;
;
;
;
;
;  ASSUMPTIONS:
;
;
;
;
;
;
;
;
;  SIDE EFFECT:
;
;
;

parse_parm  PROC

PUBLIC   PARSE_PARM

;C02   ADD   current_parm_DI, TYPE parm_list_entry
   ADD   current_parm_DI, SIZE parm_list_entry                          ;C02

   PUSH  current_parm_DI          ;save index into parsed parms list
   PUSH  BX                      ;save the address of the parsed parms list

   MOV     DI,OFFSET PARMS         ; ES:DI=>PARSE CONTROL DEFINITON
   MOV     SI,COMMAND_line         ; DS:SI=>unparsed portion of the command line
   MOV     DX,0                    ; RESERVED
   MOV     CX,ordinal              ; OPERAND ORDINAL
   EXTRN   SYSPARSE:NEAR
   CALL    SYSPARSE                 ;AX=return code, DX=>result buffer
   MOV     ordinal,CX               ;save for next call
   MOV     terminating_delimeter,BL ;save the character that delimited the parm

   POP   BX                      ;restore parm_list
   POP   current_parm_DI         ;nothing returned in DI anyway

   MOV   CX,command_line            ;AN000;CX=>first char of the bad parm
   MOV   offending_parameter_ptr,CX ;AN000;set pointer in message

;  .IF <parser_return_code_AX EQ no_error> THEN
      MOV   command_line,SI            ;save pointer to remainder of the command line
      .IF <parser_return_code_AX NE end_of_command_line> THEN
         MOV   DL,result.ret_type
         MOV   parm_list[current_parm_DI].parm_type,DL
         MOV   DL,result.item_tag
         MOV   parm_list[current_parm_DI].item_tag,DL
         MOV   DX,result.ret_value1
         MOV   parm_list[current_parm_DI].value1,DX
         MOV   DX,result.ret_value2
         MOV   parm_list[current_parm_DI].value2,DX
         MOV   DX,result.synonym
         MOV   parm_list[current_parm_DI].keyword_switch_ptr,DX

	 ; If we found /?, display the options for the user,
	 ; and exit to DOS so they may try again.

	 .IF	<DX EQ <OFFSET slash_?>>
	    CALL  display_options_exit	; does not return
	 .ENDIF
      .ENDIF
;  .ELSE                               ;AN000;encountered an error
;     MOV   CX,command_line            ;AN000;CX=>first char of the bad parm
;     MOV   offending_parameter_ptr,CX ;AN000;set pointer in message
;     MOV   BYTE PTR [SI],0            ;AN000;make the offending parm an ASCIIZ string
;  .ENDIF                              ;AN000;leave the call to msg services to the calling routine

   RET

parse_parm  ENDP



;
;
; RESET_PARM_POINTER
; ------------------
;
;
;
; The last entry in the parm list is decremented, which
; will put the results of the next parse over that entry.
;
;
;
;
;
;
;
;
;
;
;
;  INPUT:
;
;
;  RETURN: The current parm list entry is filled with recognizable trash
;
;
;
;
;  MESSAGES: none
;
;
;
;
;
;
;
;
;
;
;
;  REGISTER
;  USAGE:
;
;
;
;  CONVENTIONS:
;
;
;
;
;
;
;
;  ASSUMPTIONS:
;
;
;
;
;
;
;
;
;  SIDE EFFECT:
;
;
;
                                                                        ;AN000;
reset_parm_pointer  PROC



   MOV   parm_list[current_parm_DI].parm_type,bogus                     ;AN000;
   MOV   parm_list[current_parm_DI].item_tag,0FFH                       ;AN000;
   MOV   parm_list[current_parm_DI].synonym,bogus                       ;AN000;
   MOV   parm_list[current_parm_DI].value1,bogus                        ;AN000;
   MOV   parm_list[current_parm_DI].value2,bogus                        ;AN000;
   MOV   parm_list[current_parm_DI].keyword_switch_ptr,0                ;AN000;
;C02   SUB   current_parm_DI,TYPE parm_list_entry                       ;AN000;
   SUB   current_parm_DI,SIZE parm_list_entry                           ;AN000;;C02
   DEC   ordinal                                                        ;AN000;


   RET

reset_parm_pointer ENDP                                                 ;AN000;


PRINTF_CODE ENDS                                                        ;AN000;
        END                                                             ;AN000;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modevid.asm ===
PAGE	,132			;
	TITLE	MODEVID.SAL

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

.XLIST
INCLUDE STRUC.INC		 ;macro library for 'struc'
.LIST

;  P R O L O G  ͻ				   ;AN000;
;											  				   ;AN000;
															   ;AN000;
;  AC000 - P3200: Was displaying a message that Sam Nunn had deleted from the
;		  USA.MSG file because it looked like a common message.  Now
;		  I use a different (better) message.  It was "Invalid paramters",
;		  is now "Function not supported - ????".

;											  				   ;AN000;
;  P R O L O G  ͼ				   ;AN000;
															   ;AN000;
SIGNITURE SEGMENT AT 0C000H
	ORG	0
SIGWORD DW	?			;SIGNITURE OF THE EGA IS STORED HERE IF THE CARD IS PRESENT
SIGNITURE ENDS


LOW_MEM SEGMENT AT 0
	ORG	410H
EQUIP_FLAG EQU	THIS WORD
LOW_MEM ENDS


;  M A C R O S  ͻ
;											  


DISPLAY MACRO	MSG
	MOV	DX,OFFSET MSG
	CALL	PRINTF
ENDM


;-------------------------------------------------------------------------------


find_number   MACRO    num, list

;Purpose: See if num is in the list of numbers.

;Input:  num - number to be checked
;	 list - label of list to scan
;	 list_len - length of the list to scan.  This name is built from the
;		    label 'list' that is input.

;Output:       zero flag set if the number is found in 'list'

;Assumption:   A label of the name list_len exists and is in segment addressed by
;	       DS, where 'list' is the label passed in.  ES and DS are the same.

;Side effects: The direction flag is cleared.

PUSH  DI
PUSH  CX

MOV	AL,num
MOV	DI,OFFSET list
CLD				;want to increment DI
MOV	CX,list&_len		;CX=number of nums in the list
REPNE	SCASB

POP   CX
POP   DI

ENDM

;-------------------------------------------------------------------------------


SET_CURSOR_POS MACRO
	MOV	AH,2			;SET CURSOR
	MOV	DX,0			;ROW=0,COL=0
	MOV	BH,0			;SELECT SCREEN 0
	INT	10H

	ENDM

MODE_VIDEO MACRO OPTION
	MOV	AH,0			;SET MODE
	MOV	AL,OPTION
	INT	10H

	ENDM

SET_CURSOR_TYPE MACRO
	MOV	AH,1			;SET CURSOR TYPE
	MOV	CX,CURSOR_TYPE		;ROW=0,COL=0
	INT	10H

	ENDM

;											  
;  M A C R O S  ͼ


;  E Q U A T E S  ͻ
;											  

B	EQU	0		       ;POSITION OF "B" IN PARM1 FOR BW?0
W	EQU	1		       ;POSITION OF "W" IN PARM1 FOR BW?0
C	EQU	0		       ;POSITION OF "C" IN PARM1 FOR CO?0
O	EQU	1		       ;POSITION OF "O" IN PARM1 FOR CO?0
M	EQU	0		       ;POSITION OF "M" IN PARM1 FOR MONO
N	EQU	2		       ;POSITION OF "N" IN PARM1 FOR MONO
OH	EQU	3		       ;POSITION OF SECOND "O" IN PARM1 FOR MONO

all			EQU   0FEH     ;descreet value representing adapter/monitor that can be in mono and color
ALT_SELECT EQU	12H		       ;ALTERNATE SELECT FUNCTION OF INT10
AMOAMA			EQU   01       ;map to check 'all modes on all monitors active' bit of misc state info byte
bw7			EQU   7        ;another mono (emulation) mode (VGA with analog monochrome)
bw0B			EQU   0BH      ;analog black and white on a PALACE
cga			EQU   02       ;plain color card
COLOR_CURSOR_TYPE	EQU   0607H    ;CURSOR TYPE FOR ALL COLOR AND BW MODES
color6			EQU   6        ;another color supporting combination (PGA with color display)
color8			EQU   8        ;another color supporting combination
colorA			EQU   0AH      ;yet another color combo (color display or ehnanced color display on PALACE)
colorC			EQU   0CH      ;even another color combo (PALACE with analog color)
ega_color		EQU   4        ;value for color support of EGA
EGA_INFO EQU	10H		       ;RETURN EGA INFORMATION OPTION OF ALT. SELECT FUNCTION OF INT10
EGA_MONO EQU	05H
EGA_SIG EQU	0AA55H		       ;SIGNITURE FOR EGA CARD
EMPTY	EQU	0		       ;THE REMAINING 6 CHARACTERS OF PARM1  SHOULD BE 0
FALSE	EQU	0
get_sys_stat	EQU	43H	       ;get system status function of INT 15H
LCD_attached	EQU	00000000B      ;bit 0=0 if the LCD is attached
LCD_bit 	EQU	00000001B      ;mask to check the LCD attached bit of status byte
LOWERCASE EQU	20H		       ;OR THIS TO UPPER/LOWER CASE TO ASSURE LOWERCASE
mono_card		EQU   1        ;BIOS INT 10 AH=1B representation of plain mono card
MONO_CURSOR_TYPE  EQU	0B0CH
MONO_ON_IT EQU	1		       ;VALUE RETURNED FROM EGA INFORMATION IN BH IF MONO IN EFFECT
OPTION_BW4025 EQU 0		       ;40 X 25 BW
OPTION_CO4025 EQU 1		       ;40 X 25 COLOR
OPTION_BW8025 EQU 2		       ;80 X 25 BW
OPTION_CO8025 EQU 3		       ;80 X 25 COLOR
OPTION_MONO   EQU 7		       ;monochrome
parm_list		EQU   [BP]     ;addressing for array of parsed parameters in form "parm_list_entry"

COLOR_ON_IT EQU 0		       ;VALUE RETURNED FROM EGA INFORMATION IN BH IF COLOR IN EFFECT
BITBW40 EQU	10H		       ;40X25 BW USING COLOR CARD
BITBW80 EQU	20H		       ;80X25 BW USING COLOR CARD
BITMONO EQU	30H		       ;80X25 BW CARD
video_info_DI	  EQU	[DI]

;											  
;  E Q U A T E S  ͼ




;  P U B L I C S  ͻ
;											  

PUBLIC	ALT_SELECT
PUBLIC	BITBW40
PUBLIC	BITBW80
PUBLIC	BW40
PUBLIC	BW80
PUBLIC	CHECK_BUFF
PUBLIC	CO40
PUBLIC	CO80
PUBLIC	COLOR_ON_IT
PUBLIC	EGA_INFO
PUBLIC	GET_VIDEO_INFO
PUBLIC	MONO

;											  
;  P U B L I C S  ͼ



;  S T R U C T U R E S  ͻ
;											  

INCLUDE  common.stc		    ;definition of the following struc

info_block  STRUC				;layout of info returned by INT 10 AH=1B
   who_cares1	     DB    025H  DUP ("V")
   active_display    DB    "V"
   alternate_display DB    "V"
   who_cares2	     DB    6	 DUP ("V")
   misc_state_info   DB    "V"
   who_cares3	     DB    12H	 DUP ("V")
info_block  ENDS


;											  
;  S T R U C T U R E S  ͼ


	PAGE
PRINTF_CODE SEGMENT PUBLIC
	ASSUME	CS:PRINTF_CODE,DS:PRINTF_CODE,SS:PRINTF_CODE


; D A T A ͻ
;											  

color_combos   label byte	       ;list of adapter/display combinations supporting color modes
   DB	 bw0B
   DB	 color6
   DB	 color8
   DB	 colorA
   DB	 colorC
   DB	 cga
   DB	 ega_color
color_combos_len  EQU	$ - color_combos

CURSOR_TYPE	DW	0607H		;HOLDER OF APPROPRIATE CURSOR TYPE
information_block    info_block  <>	  ;area to hold info returned from INT 10 AH=1B

mono_combos    label byte
   DB	 mono_card
   DB	 ega_mono
   DB	 bw7
mono_combos_len   EQU	$ - mono_combos

;											  
; D A T A ͼ


;  E X T R N S	ͻ
;											  

EXTRN	Function_not_supported:WORD	;'INVALID PARAMETERS'
EXTRN	NOERROR:BYTE			;INDICATE THAT NO ERROR MESSAGES HAVE BEEN ISSUED YET
EXTRN	not_supported_ptr:WORD		;pointer to the screen mode that the configuration can't do.
EXTRN	machine_type:BYTE		;holder of model byte
EXTRN	parm_lst:BYTE			;the array of the structure parm_list_entry  max_pos_parms DUP (<>)
EXTRN	PRINTF:NEAR			;"C" LIKE FORMATTED SCREEN OUTPUT ROUTINE
EXTRN	PARM1:BYTE			;PARAMETER HOLDING AREA, SEE "RESCODE"
EXTRN	P14_model_byte:ABS

;											  
;  E X T R N S	ͼ



;***********************************************************
;SET VIDEO TO 40 X 25, BLACK AND WHITE
BW40	PROC	NEAR

	CALL	get_video_info
	.IF    <video_info_DI.active_display EQ all> OR
	find_number  <video_info_DI.active_display>,color_combos
	.IF    Z OR
	find_number  <video_info_DI.alternate_display>,color_combos
	.IF    Z THEN

	    MOV     DL,BITBW40		;SET FOR BW 40 X 80
	    MOV     DH,OPTION_BW4025
	    MOV     CURSOR_TYPE,COLOR_CURSOR_TYPE
					;DL HAS BYTE TO BE OR'ED INTO EQUIP_FLAG
					;DH HAS BYTE OF VIDEO OPTION
	    CALL    setup

	.ELSE

	    MOV   DI,0			  ;the screen mode is always the first parm					   ;AC000;
	    MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]				   ;AC000;
	    MOV   CX,parm_list[DI].value1										   ;AC000;
	    MOV   not_supported_ptr,CX	       ;FILL IN pointer to the parameter that is not supported			  ;AC000;
	    DISPLAY Function_not_supported	;'Function not supported - BW40"
	    MOV     NOERROR,FALSE

	.ENDIF

	RET				;RETURN TO MAIN ROUTINE
BW40	ENDP
;******************************************************
;SET VIDEO TO 80 X 25, BLACK AND WHITE
BW80	PROC	NEAR

	CALL	get_video_info
	.IF    <video_info_DI.active_display EQ all> OR
	find_number  <video_info_DI.active_display>,color_combos
	.IF    Z OR
	find_number  <video_info_DI.alternate_display>,color_combos
	.IF    Z THEN

	    MOV     DL,BITBW80		;80 X 25 BW USING GRAPHICS CARD
	    MOV     DH,OPTION_BW8025
	    MOV     CURSOR_TYPE,COLOR_CURSOR_TYPE
					;DL HAS BYTE TO BE OR'ED INTO EQUIP_FLAG
					;DH HAS BYTE OF VIDEO OPTION
	    CALL    setup

	.ELSE

	    MOV   DI,0			  ;the screen mode is always the first parm					   ;AC000;
	    MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]				   ;AC000;
	    MOV   CX,parm_list[DI].value1										   ;AC000;
	    MOV   not_supported_ptr,CX	       ;FILL IN pointer to the parameter that is not supported			  ;AC000;
	    DISPLAY Function_not_supported	;'Function not supported - BW80"
	    MOV     NOERROR,FALSE

	.ENDIF

	RET
BW80	ENDP
;******************************************************
;SET VIDEO TO 80 X 25, MONOCHROME
MONO	PROC	NEAR

	CALL	get_video_info
	.IF    <video_info_DI.active_display EQ all> OR
	find_number  <video_info_DI.active_display>,mono_combos
	.IF    Z OR
	find_number  <video_info_DI.alternate_display>,mono_combos
	.IF    Z THEN

	    MOV     DL,BITMONO	    ;EQUIP FLAG INDICATING 80 X 25 BW USING MONO CARD
	    MOV     DH,OPTION_MONO  ;MONOCHROME MODE
	    MOV     CURSOR_TYPE,MONO_CURSOR_TYPE

					;DL HAS BYTE TO BE OR'ED INTO EQUIP_FLAG
					;DH HAS BYTE OF VIDEO OPTION
		CALL	SETUP

	.ELSE

	    MOV   DI,0			  ;the screen mode is always the first parm					   ;AC000;
	    MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]				   ;AC000;
	    MOV   CX,parm_list[DI].value1										   ;AC000;
	    MOV   not_supported_ptr,CX	       ;FILL IN pointer to the parameter that is not supported			  ;AC000;
	    DISPLAY Function_not_supported	;'Function not supported - MONO"
	    MOV     NOERROR,FALSE

	.ENDIF

	RET				;RETURN TO MAIN ROUTINE
MONO	ENDP
;*******************************************************
CO40	PROC	NEAR

	CALL	get_video_info
	.IF    <video_info_DI.active_display EQ all> OR
	find_number  <video_info_DI.active_display>,color_combos
	.IF    Z OR
	find_number  <video_info_DI.alternate_display>,color_combos
	.IF    Z THEN

	   MOV	   DL,BITBW40	       ;40 X 25 USING COLOR CARD
	   MOV	   DH,OPTION_CO4025    ; REQUEST COLOR
	   MOV	   CURSOR_TYPE,COLOR_CURSOR_TYPE
				    ;DL HAS BYTE TO BE OR'ED INTO EQUIP_FLAG
				    ;DH HAS BYTE OF VIDEO OPTION
	   CALL    setup

	.ELSE

	    MOV   DI,0			  ;the screen mode is always the first parm					   ;AC000;
	    MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]				   ;AC000;
	    MOV   CX,parm_list[DI].value1										   ;AC000;
	    MOV   not_supported_ptr,CX	       ;FILL IN pointer to the parameter that is not supported			  ;AC000;
	    DISPLAY Function_not_supported	;'Function not supported - CO40"
	    MOV     NOERROR,FALSE

	.ENDIF

	RET				;RETURN TO MAIN ROUTINE
CO40	ENDP
;******************************************************
CO80	PROC	NEAR

	CALL	get_video_info
	.IF    <video_info_DI.active_display EQ all> OR
	find_number  <video_info_DI.active_display>,color_combos
	.IF    Z OR
	find_number  <video_info_DI.alternate_display>,color_combos
	.IF    Z THEN

	   MOV	   DL,BITBW80	       ;80 X 25 USING COLOR CARD
	   MOV	   DH,OPTION_CO8025    ; REQUEST COLOR
	   MOV	   CURSOR_TYPE,COLOR_CURSOR_TYPE

					;DL HAS BYTE TO BE OR'ED INTO EQUIP_FLAG
					;DH HAS BYTE OF VIDEO OPTION
	   CALL    setup

	.ELSE

	    MOV   DI,0			  ;the screen mode is always the first parm					   ;AC000;
	    MOV   BP,OFFSET parm_lst   ;address the parm list via parm_list which is [BP]				   ;AC000;
	    MOV   CX,parm_list[DI].value1										   ;AC000;
	    MOV   not_supported_ptr,CX	       ;FILL IN pointer to the parameter that is not supported			  ;AC000;
	    DISPLAY Function_not_supported	;'Function not supported - CO80"
	    MOV     NOERROR,FALSE

	.ENDIF

	RET				;RETURN TO MAIN ROUTINE
CO80	ENDP
;******************************************************
SETUP	PROC	NEAR
;INPUT: DL HAS BYTE TO BE OR'ED INTO EQUIP_FLAG
;	DH HAS BYTE OF VIDEO OPTION

	XOR	AX,AX			;ZERO A REG
	MOV	ES,AX			;POINT TO SEGMENT AT ZERO
	MOV	AX,ES:EQUIP_FLAG	;GET CURRENT STATUS FLAG BYTE
	AND	AL,0FFH-MASK VIDEO	;CLEAR VIDEO DEFINITION BITS
	OR	AL,DL			;TURN ON REQUESTED VIDEO BITS
	MOV	ES:EQUIP_FLAG,AX	;RESTORE UPDATED FLAG BYTE

	MODE_VIDEO DH			;SET MODE TO DESIRED OPTION

	SET_CURSOR_POS			;TO ROW=0, COL=0

	SET_CURSOR_TYPE 		;TO 6,7 FOR COLOR MODES, B,C FOR MONO

	RET				;RETURN TO CALLER
SETUP	ENDP
;******************************************************
GET_VIDEO_INFO	  PROC	  NEAR

;Determine what display adapters are in the machine.


;Assumption:
;
;

;Notes: I assume that if an EGA is present then it is the active display.  This
;	 is not always the case, but the routines that call for that kind of
;	 information do not care which is active, or already know.

;Conventions:  'video_info_DI'([DI]) is used to address the info table returned
;		  by INT 10 AH=1B as defined by the structure 'info_block' and
;		  stored in 'information_block'.  If the INT 10 AH=1A was
;		  successfull then the result is stored here.








PUSH  ES

XOR   AX,AX				  ;ZAP previous contents
MOV   AH,01BH				  ;functionality/state information
PUSH  CS
POP   ES
MOV   DI,OFFSET information_block	     ;initialize 'video_info_DI'
MOV   BX,0				     ;parm to allow for future expansion
INT   010H
.IF <AL EQ 01BH> THEN NEAR		     ;IF the call is supported THEN
					     ;ES:DI=>info returned from BIOS
   .IF <video_info_DI.alternate_display EQ 0> THEN NEAR  ;only 1 display, so see if it can handle all modes

      TEST  video_info_DI.misc_state_info,AMOAMA      ;check the 'all modes on all monitors active' bit
      .IF   NZ				     ;IF all modes are supported THEN
	 MOV   video_info_DI.active_display,all 	      ;return the active display type as everything
      .ENDIF

   .ENDIF

.ELSE					;display code call not supported, look for EGA
   ;SINCE the display type call was not supported SEE IF IN AN EGA ADVANCED MODE

   MOV	   AX,SIGNITURE
   MOV	   ES,AX	       ;PUT SEGMENT OF SIGNITURE OF EGA IN ES
   .IF	 <ES:SIGWORD EQ EGA_SIG> AND	     ;IF maybe an EGA IN THE MACHINE THEN
   MOV	   AH,ALT_SELECT       ;AH GETS INT FUNCTION SPECIFIER
   MOV	   BL,EGA_INFO	       ;SPECIFY IN BL THE OPTION OF THE FUNCTION OF INT 10 WE
   INT	   10H		       ;RETURN MONITOR TYPE HOOKED TO EGA IN BH
   .IF	 <BL NE 010H> THEN     ;EGA support available
      .IF   <BH EQ COLOR_ON_IT> THEN		     ;IF COLOR HOOKED TO EGA THEN
	  MOV  video_info_DI.active_display,ega_color

	  MOV	  AX,0B000H	      ;GET BASE OF MONO SCREEN BUFFER
	  CALL	  check_buff	      ;IF THERE IS MEMORY WHERE THE MONO CARD HAS IT
	  .IF  <AH EQ AL> THEN	       ;IF there is a monchrome card buffer present THEN
	     MOV   video_info_DI.alternate_display,mono_card
	  .ENDIF

      .ELSE
	  MOV  video_info_DI.active_display,ega_mono

	  MOV	  AX,0B800H		  ;AX= BASE OF GRAPHICS SCREEN BUFFER
	  CALL	  CHECK_BUFF		  ;DATA PUT OUT IN AL, DATA RETURNED IN AH
	  .IF  <AH EQ AL> THEN		  ;IF WHAT I GOT BACK IS SAME AS I PUT OUT, THEN BUFFER IS PRESENT
	     MOV   video_info_DI.alternate_display,cga
	  .ENDIF
      .ENDIF
   .ELSE				  ;no display type call, no EGA
					  ;check for convertible
      .IF   <machine_type EQ P14_model_byte> AND
      MOV     AH,get_sys_stat
      INT     15H			   ;AL=system status
      AND     AL,LCD_bit		   ;check bit 0
      .IF   <AL EQ LCD_attached> THEN
	 MOV   video_info_DI.active_display,all 	;LCD supports mono and color
      .ELSE					;no analog displays, no EGA, no LCD

	  MOV	  AX,0B000H	      ;GET BASE OF MONO SCREEN BUFFER
	  CALL	  check_buff	      ;IF THERE IS MEMORY WHERE THE MONO CARD HAS IT
	  .IF  <AH EQ AL> THEN	       ;IF there is a monchrome card buffer present THEN
	    MOV   video_info_DI.active_display,mono_card
	  .ENDIF

	  MOV	  AX,0B800H		  ;AX= BASE OF GRAPHICS SCREEN BUFFER
	  CALL	  CHECK_BUFF		  ;DATA PUT OUT IN AL, DATA RETURNED IN AH
	  .IF  <AH EQ AL> THEN		  ;IF WHAT I GOT BACK IS SAME AS I PUT OUT, THEN BUFFER IS PRESENT
	     MOV   video_info_DI.alternate_display,cga
	  .ENDIF

      .ENDIF

   .ENDIF

.ENDIF

POP   ES

RET				;RETURN TO CALLER


GET_VIDEO_INFO	  ENDP
;******************************************************
;VMONO	 PROC	 NEAR
;;VERIFY THAT A MONOCHROME CARD EXISTS OR LCD IS ATTACHED
;;Input: - AX=base of monochrome screen buffer
;;Output: - AH=AL if have monochrome card or LCD attached
;;	    AH<>AL if don't have mono card and LCD is not attached
;
;;One way to have a valid MONO setting on a P1X is to have the LCD attached.  Another is
;;to have the LCD detached and have a MONO card attached.
;;The logic is as follows:
;;
;;BEGIN
;;   ok_to_put_in_MONO_mode:=false
;;   IF on a P1X AND LCD is attached THEN
;;	ok_to_put_in_MONO_mode:=true
;;   ELSE
;;	verify_the_buffer_exists
;;   ENDIF
;;END
;
;   PUSH    AX
;   CMP     machine_type,P14_model_byte
;   $IF     E,AND
;   MOV     AH,get_sys_stat
;   INT     15H 			 ;AL=system status
;   AND     AL,LCD_bit			 ;check bit 0
;   CMP     AL,LCD_attached
;   $IF     E				 ;IF on a P1X AND LCD is attached THEN
;      POP     AX			 ;   clean the stack
;      MOV     AX,0000H 		 ;   AH=ALOK to put in MONO mode
;   $ELSE				 ;ELSE
;      POP     AX			 ;   AX=mono buffer base
;      CALL    check_buff		 ;   see if the MONO card exists
;   $ENDIF				 ;ENDIF
;RET					 ;RETURN TO MAIN ROUTINE
;VMONO	 ENDP
;******************************************************
CHECK_BUFF PROC NEAR
;SEE IF MEMORY EXISTS AT THE SEGMENT PASSED IN AX

	PUSH	DS			;SAVE DATA SEGMENT REGISTER
;				MOVE SEG ID OF VIDEO BUFFER
	MOV	DS,AX			; TO THE DATA SEGMENT REG
	MOV	CH,DS:0 		;GET A BYTE FROM THAT BUFFER
	MOV	AL,55H			;GET A SAMPLE DATA BYTE
	MOV	DS:0,AL 		; TO THE SCREEN BUFFER, IF THERE
	PUSH	BX			;TERMINATE THE BUS SO WE DON'T GET THE SAME THING
	POP	BX			;BACK BECAUSE IT WAS STILL ON THE BUS
	MOV	AH,DS:0 		;FETCH IT BACK
	MOV	DS:0,CH 		;REPAIR THE DAMAGE IN THE BUFFER
	POP	DS			;RESTORE DATA SEGMENT REGISTER
	RET
CHECK_BUFF ENDP
;********************************************************
PRINTF_CODE ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modescrn.asm ===
PAGE ,132 ;
TITLE MODESCRN.ASM - SCREEN SUPPORT FOR THE MODE COMMAND

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  MKS  C00  General cleanup.  Making short jumps out of long
;		       jumps, ridding of nops.
;
;******************************************************************************

.XLIST
INCLUDE STRUC.INC
.LIST

INCLUDE  COMMON.STC	;definitions of message sublist blocks ;AC001;

;  P R O L O G  ͻ				   ;AN000;
;											  				   ;AN000;
															   ;AN000;
;  AC000 - P3200: Was displaying a message that Sam Nunn had deleted from the
;		  USA.MSG file because it looked like a common message.  Now
;		  I use a different (better) message.  It was "Invalid paramters",
;		  is now "Function not supported - ????".

;  AX001 - P3976: Need to have all pieces of messages in MODE.SKL so have to
;		  implement the SYSGETMSG method of getting addressability to
;		  the pieces.  This means that the code does a SYSGETMSG call
;		  which returns a pointer (DS:SI) to the message piece.  The
;		  address is then put in the sublist block for the message
;		  being issued.

;  AX002 - P5159: Need to use get extended country call (6523) to get the yes
;     7-14-88	  no answer

;											  				   ;AN000;
;  P R O L O G  ͼ				   ;AN000;

;  M A C R O S  ͻ
;											  

BREAK	MACRO	X
;C00   JMP     endcase_&X
   JMP	SHORT	endcase_&X						;C00
ENDM


SCRN	MACRO COMMAND,MOD
		      MOV    AH,COMMAND ;REQUEST FUNCTION OF SCREEN BIOS
 IFNB <MOD>
		      MOV    AL,MOD	;SET MODE TO SCREEN
 ENDIF
		      INT    10H	;CALL BIOS SCREEN HANDLER
;
     ENDM
;
DISPLAY 	MACRO	MSG
IFNB <MSG>
	MOV	DX,OFFSET MSG
ENDIF
	CALL	PRINTF
ENDM


SET_LEFT_SHIFT_LIMIT	MACRO
	LOCAL	LIMIT_SET
	ASSUME	DS:ROM_BIOS
;
	PUSH	DS
	PUSH	AX
	MOV	AX,ROM_BIOS_SEG
	MOV	DS,AX
	CMP	DS:MACHINE_TYPE,JUNIOR		;IF this machine is a Junior THEN
	JNE	LIMIT_SET
	  MOV	BYTE PTR CS:LEFT_LIMIT,JR_LEFT_LIMIT	;USE THE JUNIOR'S LEFT LIMIT
	LIMIT_SET:
	POP	AX
	POP	DS
;
	ASSUME	DS:PRINTF_CODE
;
ENDM

set_submessage_ptr   MACRO submessage,message ;PUT pointer to "subMESSAGE" into submessage pointer field of "message".

MOV   AX,submessage			     ;AX=message number 		;AN001;
MOV   DH,utility_msg_class		     ;DH=message class=utility class	;AN001;
CALL  SYSGETMSG 			     ;DS:SI=>message piece				  ;AN001;
MOV   BP,OFFSET sublist_&message	     ;address the sublist control block ;AN001;
MOV   [BP].sublist_off,SI		     ;the sublist now points to the desired message piece ;AN001;
ENDM												  ;AN001;


;---------------------------------------------------------------------------
;   SET_UP_FOR_PRINTF
;PRINTF depends on DS containing the segment that the messages are in, so if
;DS is being used to address data areas elsewhere it needs to be temporarily
;set to the message file segment.
;---------------------------------------------------------------------------
;
SET_UP_FOR_PRINTF	MACRO

	PUSH	DS		;SAVE DS
	PUSH	CS
	POP	DS		;DS NOW HAS MESSAGE SEGMENT
;
ENDM

;----------------------------------------------------------------------------
;   REPLACE_DS
;Replace the contents DS had before the PRINTF call. Assume that DS was pushed.
;-----------------------------------------------------------------------------

REPLACE_DS	MACRO

	POP	DS
;
ENDM

;											  
;  M A C R O S  ͼ

CURRENT_VIDEO_STATE EQU 15 ;REQUEST TO BIOS SCREEN TO RETURN SCREEN STATE
SET_SCREEN_MODE EQU 0	      ;REQUEST TO BIOS SCREEN TO SET SCREEN MODE
COL40	 EQU	1	 ;FLAG BIT TO REQUEST 40 COL
COL80	 EQU	2	 ;FLAG BIT TO REQUEST 80 COL
CNT4	 EQU	4	 ;COUNT NO. TIMES TO DISPLAY "NUMBERS" FOR 40COL
CNT8	 EQU	8	 ;COUNT NO. TIMES TO DISPLAY "NUMBERS" FOR 80COL
FORTY	 EQU	40	 ;SCREEN WIDTH
MONO_MODE EQU	7	 ;MONOCHROME SCREEN MODE
no	 EQU	 0	;AC002;value to compare with when user responds with no character
NOEXIT	  EQU	 0		  ;EXIT SWITCH VALUE TO REPEAT LOOP
EXIT	  EQU	 1		  ;EXIT SWITCH VALUE TO LEAVE LOOP
YES	  EQU	  1	;AC002;value AX will be if user types yes character ("y", "s", "j" etc)
;





;	 OFFSETS INTO VIDEO TABLE, AT 40:90
SHIFCT40 EQU	02H		  ;SHIFT COUNT FOR 40 COL
SHIFCT80 EQU	012H		  ;SHIFT COUNT FOR 80 COL
SHIFCTGR EQU	022H		  ;SHIFT COUNT FOR GRAPHICS
CR	    EQU    13		  ;CARRIAGE RETURN
LF	    EQU    10		  ;LINE FEED
BEEP	    EQU    7		  ;SOUND THE AUDIBLE ALARM
LOWERCASE   EQU    20H		  ;ADD THIS TO UPPER, GET LOWER CASE
TRUE	EQU	0FFH

RIGHT_LIMIT EQU    01	  ;SAME FOR ALL TYPES OF MACHINES
JUNIOR	    EQU    0FDH 	  ;MACHINE TYPE SIGNITURE FOR PC JUNIOR
JR_LEFT_LIMIT  EQU 031H 	  ;LEFT LIMIT FOR SCREEN SHIFT ON PC JUNIOR
;
EGA_SIG 	EQU	0AA55H	  ;SIGNITURE FOR THE EGA CARD
;
ROM_BIOS  SEGMENT AT 0F000H
	ORG	0FFFEH
;
	MACHINE_TYPE	LABEL	BYTE		;MACHINE TYPE BURNED IN ROM
;
ROM_BIOS  ENDS

ROM_BIOS_SEG	EQU	0F000H
;
SIGNITURE  SEGMENT AT 0C000H			;SEGMENT OF EGA AREA
	ORG	0
SIGWORD DW	?			;SIGNITURE OF THE EGA IS STORED HERE IF THE CARD IS PRESENT
SIGNITURE	ENDS
;
PRINTF_CODE   SEGMENT PUBLIC
     ASSUME CS:PRINTF_CODE,DS:PRINTF_CODE
;


;  P U B L I C S  ͻ
;											  

PUBLIC	 HANDLE_40_OR_80	 ;make available to "ANALYZE_AND_INVOKE"
PUBLIC	 SHIFT_SCREEN		 ;make available to "ANALYZE_AND_INVOKE"


;											  
;  P U B L I C S  ͼ


;  E X T R N S	ͻ
;											  

EXTRN CANT_SHIFT:WORD	    ;CR,LF,"Unable to shift screen",BEEP,EOM
EXTRN PRINTF:NEAR		;interface to message service ROUTINE
EXTRN SCRNTAB:NEAR		;LOADS VIDEO INIT TABLE RETURNING POINTER TO IT
;
EXTRN PARM1:BYTE,PARM2:BYTE,PARM3:BYTE,MODE:BYTE
EXTRN NEW_VIDEO_PARMS_SEGMENT:WORD
EXTRN	NOERROR:BYTE		  ;INDICATE IF AN ERROR OCCURED YET
ENDPARM EQU	MODE
EXTRN	ALT_SELECT:ABS		;INT 10 FUNCTION GET MONITOR TYPE
EXTRN	EGA_INFO:ABS		;INT 10 FUNCTION GET INFO
EXTRN	COLOR_ON_IT:ABS 	;INT 10 RETURN FOR COLOR MONITOR HOOKED TO EGA
;
LEFT_LIMIT  DB	   02EH 	  ;SCREEN SHIFT LEFT LIMIT, MAY BE Revised
;
SWITCH	  DB	 0		  ;LOOP CONTROLLER
;AC000;OK	 DB	1		 ;INDICATOR OF VALID REQUEST:
;				     1=BAD, 0=GOOD
;
EXTRN L_item_tag:ABS			  ;see MODEpars.asm	  ;AN000;
EXTRN R_item_tag:ABS			  ;see MODEpars.asm	  ;AN000;
EXTRN T_item_tag:ABS			  ;see MODEpars.asm	  ;AN000;

EXTRN RIGHTMOST:WORD	;message number for "rightmost 9",EOM	;AC001;
EXTRN LEFTMOST:WORD    ;message number for "leftmost 0",EOM	;AC001;
EXTRN SHIFT_MSG:WORD	    ;CR,LF,"Do you see the ...",CR,LF,EOM ;AX000;
EXTRN NUMBERS:WORD   ;"0123456789"				  ;AX000;
EXTRN LEFT:WORD 		;message number for "left",EOM	  ;AC001;
EXTRN RIGHT:WORD		;message number for "right",EOM   ;AC001;
EXTRN sublist_cant_shift:BYTE	 ;definition of submessage ;AC001;
EXTRN sublist_shift_msg:BYTE	 ;definition of submessage ;AC001;
EXTRN SYSGETMSG:NEAR		 ;used to get the address of a message part ;AC001;
EXTRN utility_msg_class:ABS	 ;input for sysgetmsg	;AC001;


;											  
;  E X T R N S	ͼ



;----------------------------------------------------------------------------


HANDLE_40_OR_80   PROC	NEAR	    ;AN000;

;      SCREEN WIDTH IN BL
;
       SCRN   CURRENT_VIDEO_STATE,0 ;GET CURRENT SCREEN MODE
       MOV    DS:MODE,AL	    ;STORE CURRENT MODE
;      IF THE REQUEST WAS FOR 40 COL,
       CMP    BL,FORTY		  ;COMPARE WITH BL, OUTPUT FROM 'MODELENG'
       JNE    ELSE01
;
;AC000;  MOV	OK,0		    ;INDICATE A LEGAL FUNCTION DONE
;	 CASE	current mode =

;	    0,
;	    2,
;	    5,
;	    6,
;	    7,
;	    11:

			   .IF <DS:mode EQ 0> OR
			   .IF <DS:mode EQ 2> OR
			   .IF <DS:mode EQ 5> OR
			   .IF <DS:mode EQ 6> OR
			   .IF <DS:mode EQ 7> OR
			   .IF <DS:mode EQ 011H> THEN
	       MOV   DS:MODE,0		 ;SWITCH TO 40 COL, BW
	       BREAK 0
			   .ENDIF

;	    1,
;	    3,
;	    4,
;	    12,
;	    13:

			   .IF <DS:mode EQ 1> OR
			   .IF <DS:mode EQ 3> OR
			   .IF <DS:mode EQ 4> OR
			   .IF <DS:mode EQ 012H> OR
			   .IF <DS:mode EQ 013H> THEN
	       MOV   DS:MODE,1		 ;SWITCH TO 40 COL, COLOR
	       BREAK 0
			   .ENDIF


	 ENDCASE_0:


	 SCRN	SET_SCREEN_MODE,DS:MODE ;SWITCH TO 40 COL
;      ELSE ,SINCE REQUEST NOT FOR 40 COL,
       JMP    SHORT ENDIF01
ELSE01:
;    : : IF REQUEST FOR 80 COL
	 CMP	BL,80
	 JNE	ENDIF02
;
;AC000;    MOV	  OK,0		    ;INDICATE A LEGAL FUNCTION DONE
  ;	   CASE   current mode =

  ;	      0,
  ;	      2,
  ;	      5,
  ;	      6,
  ;	      7,
  ;	      11:

			     .IF <DS:mode EQ 0> OR
			     .IF <DS:mode EQ 2> OR
			     .IF <DS:mode EQ 5> OR
			     .IF <DS:mode EQ 6> OR
			     .IF <DS:mode EQ 7> OR
			     .IF <DS:mode EQ 011H> THEN
		 MOV   DS:MODE,2	   ;SWITCH TO 80 COL, BW
		 BREAK 1
			     .ENDIF

  ;	      1,
  ;	      3,
  ;	      4,
  ;	      12,
  ;	      13:

			     .IF <DS:mode EQ 1> OR
			     .IF <DS:mode EQ 3> OR
			     .IF <DS:mode EQ 4> OR
			     .IF <DS:mode EQ 012H> OR
			     .IF <DS:mode EQ 013H> THEN
		 MOV   DS:MODE,3	   ;SWITCH TO 80 COL, COLOR
		 BREAK 1
			     .ENDIF


	   ENDCASE_1:

	   SCRN   SET_SCREEN_MODE,DS:MODE
;    : : ENDIF ,END REQUEST FOR 80 COL
ENDIF02:
;    : ENDIF ,END REQUEST FOR 40 COL
ENDIF01:


RET		     ;AN000;

HANDLE_40_OR_80   ENDP			  ;AN000;


;------------------------------------------------------------------------------


SHIFT_SCREEN	PROC  NEAR		      ;AN000;shift the screen

;    DO SHIFT UNTIL HE CAN SEE END CHAR
     MOV    SWITCH,NOEXIT	  ;SET TO REPEAT NEXT LOOP
DO01:
;    : IF second PARM (sd) IS AN "R"?
       CMP   DS:PARM2,R_item_tag		;AC000;
       JE    SKIP03				;IT'S AN R SO TRY TO SHIFT RIGHT
       JMP   ELSE03				;NOT AN R SO CHECK FOR L
;
       SKIP03:
;AC000;  MOV	CS:OK,0 	  ;INDICATE A LEGAL FUNCTION DONE
	 SCRN	CURRENT_VIDEO_STATE,0		;CHECK CURRENT VIDEO MODE
	 CMP	AL,MONO_MODE			;IF mode >= mono THEN must be EGA mono so ...
;	 $IF	GE
	 JNGE $$IF1
;AC001;    MOV	LEFT_OR_RIGHT_PTR,OFFSET RIGHT	  ;YELL BECAUSE CAN'T SHIFT AN EGA OR MONO
	   set_submessage_ptr right,cant_shift	  ;set up message sublist with pointer to "right"
	   DISPLAY	CANT_SHIFT		  ;YELL BECAUSE CAN'T SHIFT AN EGA OR MONO
;	 $ELSE	LONG				  ;JUMP PAST SHIFT LOOP
	 JMP $$EN1
$$IF1:
;
CHECK_FOR_EGA:					;SEE IF SCREEN IS HOOKED TO EGA
	MOV	AX,SIGNITURE			;GET TO SEGMENT OF SIGNITURE WORD
	MOV	ES,AX				;ADDRESS THROUGH ES
	CMP	WORD PTR ES:SIGWORD,EGA_SIG	;IF EGA card being used THEN
	JNE	TRY_TO_SHIFT
	  MOV	  AH,ALT_SELECT   ;AH GETS INT FUNCTION SPECIFIER
	  MOV	  BL,EGA_INFO	  ;SPECIFY IN BL THE OPTION OF THE FUNCTION OF INT 10 WE
	  MOV	  BH, COLOR_ON_IT ;protect against RT PC problem
	  NOT	  BH
	  INT	  10H		  ;RETURN MONITOR TYPE HOOKED TO EGA IN BH
	  CMP	  BH,COLOR_ON_IT   ;IF COLOR HOOKED TO EGA THEN
	  JNE	  TRY_TO_SHIFT
;AC001;     MOV  LEFT_OR_RIGHT_PTR,OFFSET RIGHT  ;  YELL BECAUSE CAN'T SHIFT AN EGA
	    set_submessage_ptr right,cant_shift    ;set up message sublist with pointer to "right"
	    DISPLAY	 CANT_SHIFT
	    JMP  ELSE05 			 ;  JUMP PAST SHIFT LOOP
;
TRY_TO_SHIFT:
	 CALL	SCRNTAB 	  ;LOAD VIDEO TABLE IN WORK AREA
;	     DS NOW POINTS TO THE SEGMENT WHERE THE VIDEO TABLE WAS MOVED TO.
;	     BX HAS THE NEW OFFSET OF THE VIDEO TABLE

	  CMP	  BYTE PTR DS:[BX][SHIFCT40],RIGHT_LIMIT	;IF haven't shifted max right THEN
	  JG	  SHIFT_RIGHT
	    SET_UP_FOR_PRINTF
;AC001;     MOV 	LEFT_OR_RIGHT_PTR,OFFSET RIGHT
	    set_submessage_ptr right,cant_shift    ;set up message sublist with pointer to "right"
	    DISPLAY	CANT_SHIFT		;"Unable to shift screen right"
	    REPLACE_DS
	    JMP 	ELSE05
  SHIFT_RIGHT:
	 MOV	AL,DS:[BX][SHIFCT40]	;GET SHIFT COUNT FOR 40COL
	 SUB	AL,1		      ;SHIFT IT LEFT 1
	 MOV	DS:[BX][SHIFCT40],AL	;STORE IT BACK
	 MOV	AL,DS:[BX][SHIFCT80]	;GET SHIFT COUNT FOR 80COL
	 SUB	AL,2		      ;SHIFT LEFT 2
	 MOV	DS:[BX][SHIFCT80],AL	;STORE IT BACK
	 MOV	AL,DS:[BX][SHIFCTGR]	;GET GRAPHICS SHIFT COUNT
	 SUB	AL,1		      ;SHIFT LEFT 1
	 MOV	DS:[BX][SHIFCTGR],AL	;STORE IT BACK
;    : ELSE ,SINCE PARM2 IS NOT AN "R"
       JMP ENDIF03
ELSE03:
;    : : IF THIS CHAR IS AN "L"?
	 CMP DS:PARM2,L_item_tag		;AC000;
	 JE  SKIP05				;L WAS SPECIFIED SO TRY TO SHIFT LEFT
	 JMP	ELSE05				;WASN'T "L" OR "R" SO DONT'T TRY TO SHIFT
;	     SINCE IT IS "L",
;
	 SKIP05:
;AC000;    MOV	  CS:OK,0		  ;INDICATE A LEGAL FUNCTION DONE
	   SCRN CURRENT_VIDEO_STATE,0		;CHECK CURRENT VIDEO MODE
	   CMP	AL,MONO_MODE			;IF mode >= mono THEN must be EGA or mono so ...
	   JB	CHK_FOR_EGA
;AC001;      MOV	LEFT_OR_RIGHT_PTR,OFFSET LEFT	  ;YELL BECAUSE CAN'T SHIFT AN EGA
	     set_submessage_ptr left,cant_shift    ;set up message sublist with pointer to "left" ;AC001;
	     DISPLAY	CANT_SHIFT
	     JMP	ELSE05				  ;JUMP PAST SHIFT LOOP
;
	   CHK_FOR_EGA: 				;SEE IF SCREEN IS HOOKED TO EGA
	     MOV	AX,SIGNITURE			;GET TO SEGMENT OF SIGNITURE WORD
	     MOV	ES,AX				;ADDRESS THROUGH ES
	     CMP	WORD PTR ES:SIGWORD,EGA_SIG	;IF EGA card being used THEN
	     JNE	TRY_TO_SHIFT_LEFT
	       MOV	  AH,ALT_SELECT   ;AH GETS INT FUNCTION SPECIFIER
	       MOV	  BL,EGA_INFO	  ;SPECIFY IN BL THE OPTION OF THE FUNCTION OF INT 10 WE
	       INT	  10H		  ;RETURN MONITOR TYPE HOOKED TO EGA IN BH
	       CMP	  BH,COLOR_ON_IT   ;IF COLOR HOOKED TO EGA THEN
	       JNE	  TRY_TO_SHIFT_LEFT
;AC001; 	 MOV	LEFT_OR_RIGHT_PTR,OFFSET LEFT	;  YELL BECAUSE CAN'T SHIFT AN EGA
		 set_submessage_ptr left,cant_shift    ;set up message sublist with pointer to "left"  ;AC001;
		 DISPLAY	CANT_SHIFT
;C00		 JMP	ELSE05				;  JUMP PAST SHIFT LOOP
		 JMP	SHORT ELSE05	;C00		;  JUMP PAST SHIFT LOOP
;
TRY_TO_SHIFT_LEFT:
	   CALL   SCRNTAB	  ;LOAD VIDEO TABLE IN WORK AREA
;	     DS NOW POINTS TO THE SEGMENT OF THE RESIDENT CODE,
;	     WHERE THE VIDEO TABLE WAS MOVED TO.
;
	   SET_LEFT_SHIFT_LIMIT 	;SET LIMIT TO SUIT MACHINE TYPE
;
	   MOV	  AL,BYTE PTR DS:[BX][SHIFCT40] ;AL=current horizontal sync position
	   CMP	  AL,CS:LEFT_LIMIT		;IF haven't shifted max left THEN
	     JL 	  SHIFT_LEFT
	     SET_UP_FOR_PRINTF
;AC001;      MOV	LEFT_OR_RIGHT_PTR,OFFSET LEFT
	     set_submessage_ptr left,cant_shift    ;set up message sublist with pointer to "left"  ;AC001;
	     DISPLAY	CANT_SHIFT
	     REPLACE_DS
;C00	     JMP	ELSE05
	     JMP SHORT	ELSE05						;C00
  SHIFT_LEFT:
	   MOV	  AL,DS:[BX][SHIFCT40]	;GET SHIFT COUNT 40COL
	   ADD	  AL,1		      ;SHIFT RIGHT ONE
	   MOV	  DS:[BX][SHIFCT40],AL	;STORE IT BACK
	   MOV	  AL,DS:[BX][SHIFCT80]	;GET SHIFT COUNT 80COL
	   ADD	  AL,2		      ;SHIFT RIGHT 2
	   MOV	  DS:[BX][SHIFCT80],AL	;STORE IT BACK
	   MOV	  AL,DS:[BX][SHIFCTGR]	;GET GRAPHICS COUNT
	   ADD	  AL,1		      ;SHIFT RIGHT 8 PIXELS
	   MOV	  DS:[BX][SHIFCTGR],AL	;STORE IT BACK
;    : : ELSE ,SINCE CHAR IS NEITHER "R" NOR "L", QUIT
	 JMP	SHORT ENDIF05
;	 $ENDIF ;EGA or MONO
$$EN1:
ELSE05:
	   MOV	  CS:SWITCH,EXIT  ;REQUEST LOOP BE TERMINATED
;    : : ENDIF ,END IS THIS CHAR AN "L"? TEST
ENDIF05:
;    : ENDIF END, IS PARM2 AN "R"? TEST
ENDIF03:

PUBLIC	 ENDIF03

       MOV    AX,CS		  ;RESTORE THIS SEG
       MOV    DS,AX		  ; TO DS
;    LEAVE IF THE EXIT SWITCH IS SET
;AC001;     CMP    SWITCH,EXIT
;AC001;     JE	   ENDDO01
     .IF <switch NE exit> THEN NEAR
;
       SCRN CURRENT_VIDEO_STATE,0
       MOV    DS:MODE,AL	  ;SAVE CURRENT MODE
;	     LEAVING CURRENT MODE IN AL,
       SCRN   SET_SCREEN_MODE	  ;RESET IN CURRENT MODE
;    : IF THIS IS "T"
       CMP    DS:PARM3,T_item_tag	  ;AC000;
       JNE    ELSE06
;
;	 DECIDE WHICH QUESTION TO DISPLAY...
;    : : IF REQUESTED FUNCTION IS "R"
	 CMP	 DS:PARM2,R_item_tag	     ;AC000;
	 JNE	 ELSE08

;AC001;    MOV	   LFTM_OR_RGHTM_PTR,OFFSET LEFTMOST
	   set_submessage_ptr leftmost,shift_msg   ;set up message sublist with pointer to "leftmost"  ;AC001;
;    : : ELSE ,SINCE WAS NOT "R"
	 JMP	 SHORT ENDIF08
ELSE08:
;AC001;    MOV	   LFTM_OR_RGHTM_PTR,OFFSET RIGHTMOST
	   set_submessage_ptr rightmost,shift_msg   ;set up message sublist with pointer to "rightmost"  ;AC001;
;    : : ENDIF END FUNCTION IS "R"? TEST
ENDIF08:

;	 decide how many times to display "0123456789"
	 OR	DS:MODE,01H	  ;SET UP TO TEST FOR COLOR OR B/W
	 MOV	CX,CNT8 	  ;(GUESS IT IS 80COL) SET LOOP CTR TO 8
;    : : IF 40 COL?
	 CMP	DS:MODE,COL40
	 JNE	ENDIF07
;
	   MOV	  CX,CNT4	  ;(FIX ABOVE GUESS) SET LOOP CTR TO 4
;    : : ENDIF ,END IS IT 40 COL? TEST
ENDIF07:
;
	 .REPEAT
	    SCRN   SET_SCREEN_MODE,DS:MODE		;clear the screen
	    PUSH  CX		    ;save loop counter
	    DO02:		      ;DO UNTIL LINE IS DISPLAYED across entire screen
	       DISPLAY NUMBERS	      ;DISPLAY 0123456789
;	    ENDDO WHEN CNT IN CX = 0
	    LOOP    DO02
	    DISPLAY   SHIFT_MSG     ;AN000;DISPLAY QUESTION, msg services will do the keyboard input, see modedefs.inc
	    MOV    DL,AL	    ;AC002;DL=character user entered
	    MOV   AX,6523H	    ;AN002;yes no check get extended error
	    INT   21H		    ;AN002;AX returned with indication of yes or no
	    POP   CX		    ;restore loop counter
	 .UNTIL <AX EQ yes> OR
	 .UNTIL <AX EQ no>
;    : : IF RESPONSE IS "Y"
	 CMP	AL,YES
	 JNE	ENDIF09
	   MOV	  SWITCH,EXIT	  ;TERMINATE THE LOOP
;    : : ENDIF ,END IS RESPONSE "N"? TEST
ENDIF09:
;    : ELSE ,SINCE "T" NOT SPECIFIED
       JMP    SHORT ENDIF06
ELSE06:
	 MOV	SWITCH,EXIT	  ;TERMINATE THE LOOP
;    : ENDIF ,END IS THIS "T"? TEST
ENDIF06:
;    LEAVE IF EXIT SWITCH IS SET
     CMP    SWITCH,EXIT
     JE     ENDDO01
;
;    ENDDO GO BACK AND SHIFT MORE
     JMP    DO01
     .ENDIF
ENDDO01:
;
;    IF NO LEGAL FUNCTIONS DONE,
;AC000;;    CMP    OK,0
;AC000;     JZ	   ENDIF10

;AC000;       DISPLAY MSGI		 ;FUSS ABOUT ILLEGAL PARAMETERS
;    ENDIF ,END ARE NO LEGAL FUNCTIONS DONE? TEST
;AC000;ENDIF10:
     RET			  ;RETURN TO MODE MAIN ROUTINE
SHIFT_SCREEN	ENDP			;AN000;
PRINTF_CODE    ENDS
	 END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\modesubs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;  P R O L O G  ͻ
;											  

;  AX001 - P3976: Need to have all pieces of messages in MODE.SKL so have to
;		  implement the SYSGETMSG method of getting addressability to
;		  the pieces.  This means that the code does a SYSGETMSG call
;		  which returns a pointer (DS:SI) to the message piece.  The
;		  address is then put in the sublist block for the message
;		  being issued.

;  AC002 - P3258: PS/2 only COM parameters were being allowed on non-PS/2
;		  machines.  Added checks for baud=19200, parity=mark or space,
;		  data=5 or 6, stop=1.5 for both keyword and positional forms
;		  in MODEPARSE.ASM.  Had to enlarge the possible parm size for
;		  "Function not supported on this computer - ?????????????"

;											  
;  P R O L O G  ͼ


;  P U B L I C S  ͻ
;											  

;PUBLICs for the sublists are handled in modemes.asm
PUBLIC	 Utility_Msg_Class		  ;AN001;

;											  
;  P U B L I C S  ͼ


;
;*****************************************************************************
; External data declarations
;*****************************************************************************



;
;*****************************************************************************
; Message Retriever equates
;*****************************************************************************
;

INCLUDE  common.stc	   ;contains the following structure

;sublist_def  STRUC

;	      db  ?  ;Sublist Length, fixed
;	      db  ?  ;Reserved, not used yet		       ;AN000;
;	      dw  ?  ;offset
;sublist_seg  dw  ?  ;segment part of pointer to piece of message
;	      db  ?  ;number of this piece of the message,0 indicates special end of message format ;AN000;
;	      db  ?  ;flags
;	      db  ?  ;maximum field width
;	      db  ?  ;minimum field width
;	      db  ?  ;character to use for padding

;sublist_def  ENDS



INCLUDE  modequat.inc	   ;contains the following two equates for this file

;FLAGS field bit(s) values

;Left_Align		 equ	 0	 ;00xxxxxx
;Right_Align		 equ	 80h	 ;10xxxxxx

Char_Field_Char    equ	   0		 ;a0000000
Char_Field_ASCIIZ  equ	   00010000B	 ;a0010000

;Unsgn_Bin_Byte    equ	   11h	   ;a0010001
Unsgn_Bin_Word	  equ	  21h	  ;a0100001
Unsgn_Bin_DWord   equ	  31h	  ;a0110001

Sgn_Bin_Byte	  equ	  12h	  ;a0010010
Sgn_Bin_Word	  equ	  22h	  ;a0100010
Sgn_Bin_DWord	  equ	  32h	  ;a0110010

Bin_Hex_Byte	     equ     13h     ;a0010011
Bin_Hex_Word	     equ     23h     ;a0100011
Bin_Hex_DWord	     equ     33h     ;a0110011



Blank			equ	" "
No_Function		equ	0
No_Replace		equ	0

Msg_Ser_Class		equ	0
Ext_Err_Class		equ	1
Parse_Error_Class	equ	2
Utility_Msg_Class	equ	0FFh

Reserved		equ	0

Sublist_Length		equ	TYPE sublist_def

to_be_filled_in 	EQU	 77H	  ;conspicious number



;
;*****************************************************************************
; Message Sublist Tables
;*****************************************************************************
;
;The  following  control  blocks  are	used   for   messages  with
;replaceable  paramters.  These  control  blocks  are  used by	the
;SysDispMsg routine.
;

;---------------------------			;
first_sublist  LABEL BYTE

sublist_invalid_switch	    label byte		;AN000;description of %0
sublist_invalid_parameter   label byte		;AN000;description of %0
						;
	db		Sublist_Length		;fixed				;AN000;
	db		Reserved		;not used yet			;AN000;
offending_parameter_ptr LABEL WORD
	dw		offset	 offending_parameter	 ;pointer to string or binary value	;AN000;
	dw		to_be_filled_in 	;
	db		0			;ID, special end of message format ;AN000;
sub_typ db		Left_Align+char_field_ASCIIZ ;maybe changed	     ;AN000;
	db		0			;Max width 123, 128-"MODE "    ;AN000;
	db		1			;May be one char long	       ;AN000;
	db		Blank			;				;AN000;
;---------------------------			;

sublist_err1		label byte		;AN000;description of %0
						;
	db		Sublist_Length		;fixed				;AN000;
	db		Reserved		;not used yet			;AN000;
illegal_device_ptr	LABEL WORD
	dw		?			;pointer to device name string filled in by modecom;AN000;
	dw		to_be_filled_in 	;
	db		0			;ID, special end of message format ;AN000;
	db		Left_Align+char_field_ASCIIZ ;		;AN000;
	db		5			;Max width, "LPT1:"    ;AN000;
	db		4			;"COM3"                        ;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_PT80		label byte		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset PT80N		;where the printer number is stashed ;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;ID, only one sublist		;AN000;
	db		Left_Align+Char_Field_Char ;			   ;AN000;
	db		1			;				;AN000;
	db		1			;				;AN000;
	db		Blank			;no filler needed but still have this field to fill
;---------------------------			;
Sublist_PT132		label byte		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset PT132N		;				;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_Char ;			   ;AN000;
	db		1			;				;AN000;
	db		1			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_initmsg 	label byte		;CR,LF,"COM%c: %3s,%c,%c,%c,%c",CR,LF,EOM
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset device		;				;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;first of 6		       ;AN000;
	db		Left_Align+char_field_char			      ;AN000;
	db		1			;				;AN000;
	db		1			;one char number between 1 and 4;AN000;
	db		Blank			;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
pbaud_ptr   label byte
	dw		offset pbaud		;				;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		2			;second of 6			;AN000;
	db		Left_Align+char_field_ASCIIZ			      ;AN000;
	db		0;RPS			;19200				;AN000;
	db		3			;110, 300 etc the shortest
	db		Blank			;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
pparity_ptr LABEL BYTE				;allow access from invoke
	dw		offset pparity		;				;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		3			;third of 6		       ;AN000;
	db		Left_Align+char_field_char			      ;AN000;
	db		1			;				;AN000;
	db		1			;one char, n, o, e.
	db		Blank			;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset pdata		;				;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		4			;fourth of 6			;AN000;
	db		Left_Align+char_field_char			      ;AN000;
	db		1			;				;AN000;
	db		1			;one char number between 6 and 8;AN000;
	db		blank			;never used, will display at least the default data bits

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
pstop_ptr   LABEL BYTE
	dw		offset pstop		;				;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		5			;fifth of 6		       ;AN000;
	db		Left_Align+char_field_ASCIIZ			      ;AN000;
	db		0			;big enough for "1.5"           ;AN000;
	db		1			;one char number between 1 and 2;AN000;
	db		Blank			;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset pparm		;				;AN000;
	dw		to_be_filled_in 	;				;AN000;
	db		6			;last of 6		      ;AN000;
	db		Left_Align+char_field_char			      ;AN000;
	db		1			;				;AN000;
	db		1			;one char "P" or "-"
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_shift_msg	label byte		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
lftm_or_rghtm_ptr	label word
;AC001; dw		offset leftmost   ;filled in with pointer to "leftmost 0?" or "rightmost 9?"
	dw		?		  ;AC001;filled in with pointer to "leftmost 0?" or "rightmost 9?"
	dw		to_be_filled_in 	;				;AN000;
	db		1			;only 1 sub list			       ;AN000;
	db		Left_Align+char_field_ASCIIZ			  ;AN000;
	db		0;RPS			;rightmost 9?		       ;AN000;
	db		10			;leftmost 0?		       ;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_redirmsg	label byte		;AN000; CR,LF,"LPT%1: rerouted to COM%2:",CR,LF,EOM
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		Offset REDPT		;filled with printer number
	dw		to_be_filled_in
	db		1			;first of 2			;AN000;
	db		Left_Align+char_field_char ;			  ;AN000;
	db		1			;				;AN000;
	db		1
	db		Blank			;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		Offset REDCOM		;filled with COM port number
	dw		to_be_filled_in
	db		2			;second of 2			 ;AN000;
	db		Left_Align+char_field_char ;			  ;AN000;
	db		1			;				;AN000;
	db		1
	db		Blank			;				;AN000;

;---------------------------			;
Sublist_notremsg	label byte		;AN000; CR,LF,"LPT%1: not rerouted",CR,LF,EOM
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		Offset NOTREDPT 	;filled with printer number
	dw		to_be_filled_in
	db		1			;only one
	db		Left_Align+char_field_char ;			  ;AN000;
	db		1			;				;AN000;
	db		1
	db		Blank			;				;AN000;

;---------------------------			;
Sublist_retparto	label byte	  ;	;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
;AC001;inf_or_no_ptr	       LABEL WORD	       ;filled in with pointer to "No" or "infinit"
;AC001; dw		offset infinite      ;				     ;AN000;
	dw		?			;AC001;filled in with pointer to "No" or "infinit"
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ			   ;AN000;
	db		0;RPS			;				;AN000;
	db		2			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_cant_shift	label byte	    ;"Unable to shift screen ...." ;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
LEFT_OR_RIGHT_PTR	LABEL WORD						;AN000;
;AC001; dw		offset left		;FILLED WITH OFFSET OF 'left' or 'right'
	dw		?			;AC001;FILLED WITH OFFSET OF 'left' or 'right'
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ			   ;AN000;
	db		0;RPS			;				;AN000;
	db		4			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_CPMSG2		label byte		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
CPMSGLST2DEV		LABEL WORD		;filled with pointer to device name
	dw		?
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0			;				;AN000;
	db		3			;				;AN000;
	db		Blank			;				;AN000;

;---------------------------			;
Sublist_CPMSG6		label byte		;"Active codepage for device %S is %D",CR,LF,EOM
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
CPMSGLST6DEV		LABEL WORD		;filled with pointer to device name
	dw		?
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0			;				;AN000;
	db		3			;				;AN000;
	db		Blank			;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		OFFSET CPMSGLST6CP	;pointer to area FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID
	dw		to_be_filled_in 	;				;AN000;
	db		2			;2nd of 2			;AN000;
	db		Left_Align+Unsgn_Bin_Word ;AN000;00100001B
	db		5			;codepage numbers could be 5 digits long
	db		1			;theoretically could be 1 digit ;AN000;
	db		Blank			;				;AN000;

;---------------------------			;
Sublist_CPMSG7		label byte		;"Device %1 not prepared",CR,LF,EOM
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
CPMSGLST7DEV		LABEL WORD		;FILLED IN BY "QUERY" ROUTINE WITH PTR TO DEVICE NAME
	dw		?
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0			;don't know how long the device name
	db		3			;				;AN000;
	db		Blank			;				;AN000;

;---------------------------			;
Sublist_CPMSG8		label byte		;"%1 codepages:",CR,LF,EOM
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		?			;filled in with OFFSET TO "HARDWARE" OR "PREPARED"
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0;RPS			; both "Hardware" and                  ;AC001;
	db		8			;	"Prepared" are 8 chars long    ;AC001;
	db		Blank			;				;AN000;


;---------------------------			;
Sublist_CPMSG9		label byte		;"  Codepage %d",CR,LF,EOM

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		OFFSET CPMSGLST9CP	;pointer to area filled in by "DISPLAY_CPID" in modecp.sal
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Unsgn_Bin_Word ;00100001B
	db		3
	db		3			;				;AN000;
	db		Blank			;				;AN000;

;---------------------------			;
Sublist_CPMSG10 	label byte		;"MODE %1 Codepage function completed",CR,LF,EOM
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		?			;;FILLED IN TO POINT TO:
						;	     "Status",EOM
						;	     "Prepare",EOM
						;	     "Select",EOM
						;	     "Refresh",EOM
						;	     "Global",EOM
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0;RPS
	db		5			;				;AN000;
	db		Blank			;				;AN000;

;---------------------------			;
Sublist_CPMSG13 	label byte		;"   %D - %S Codepage",CR,LF,EOM
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
CPMSGLST13CP   LABEL WORD			;FILLED IN WITH CODEPAGE ID
	dw		?
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0;RPS			;				;AN000;
	db		3			;				;AN000;
	db		Blank			;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
CPMSGLST13TYP  LABEL WORD			;FILLED IN TO POINT TO:
							       ; "Selected",EOM
							       ; "System",EOM
	dw		?
	dw		to_be_filled_in 	;				;AN000;
	db		2			;2nd of 2			;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0;RPS			;all codepage numbers are 3 chars long
	db		6			;				;AN000;
	db		Blank			;				;AN000;


;---------------------------			;
Sublist_CPMSG17 	label byte		;"Device error during %1",BEEP,CR,LF,EOM
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		?			;;FILLED IN TO POINT TO:
						;     "Status",EOM
						;     "Prepare",EOM
						;     "Select",EOM
						;     "Refresh",EOM
						;     "write of font file to device",EOM
	dw		to_be_filled_in
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0;RPS			;"write of font file to device",EOM
	db		6			;"Status",EOM
	db		Blank			;				;AN000;


;---------------------------			;
Sublist_LINES_equal	label byte		;"LINES=%1",CR,LF,EOM
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
ROW_PTR   LABEL  WORD		;FILLED IN TO POINT TO: "NONE", or a row value
	dw		?			;
	dw		to_be_filled_in 	;filled in at initialization time with PRINTF_CODE
	db		1			;				;AN000;
row_type db		Right_Align+Char_Field_ASCIIZ ; 		    ;AN000;
	db		0;RPS			;"NONE"
	db		2			;25, 43, 50			;AN000;
	DB		blank

;---------------------------			;
Sublist_COLUMNS_equal	  label byte		  ;"COLUMNS=%1",CR,LF,EOM
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
COLUMNS_PTR   LABEL  WORD	    ;FILLED IN TO POINT TO: "NONE", or a columns value
	dw		?			;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
COLUMNS_type db 	    Right_Align+Char_Field_ASCIIZ ;			;AN000;
	db		0;RPS
	db		2			;				;AN000;
	DB		blank
;---------------------------			;
Sublist_RATE_equal     label byte	       ;"RATE=%1",CR,LF,EOM
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
RATE_PTR   LABEL  WORD		 ;FILLED IN TO POINT TO: "NONE", or a rate value
	dw		?			;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
RATE_type db		 Right_Align+Char_Field_ASCIIZ ;		     ;AN000;
	db		0;RPS
	db		2			;				;AN000;
	DB		blank
;---------------------------			;
Sublist_DELAY_equal	label byte		;"DELAY=%1",CR,LF,EOM
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
DELAY_PTR   LABEL  WORD 	  ;FILLED IN TO POINT TO: "NONE", or a delay value
	dw		?			;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
DELAY_type db		  Right_Align+Char_Field_ASCIIZ ;		      ;AN000;
	db		0;RPS
	db		1			;				;AN000;
	DB		blank
;---------------------------			;
Sublist_not_supported	label byte		;"Function not supported on this computer -%1"
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
not_supported_PTR   LABEL  WORD 		;FILLED IN TO POINT TO: the parameter that is not supported
	dw		OFFSET nada	     ;
	dw		to_be_filled_in 	;filled with segment of the .COM file	;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		0;RPS			;AC002;maximum length of the string
	db		1			;				;AN000;
	DB		blank
;---------------------------			;
Sublist_status_for_device label byte		  ;"Status for device %1:"
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
stat_dev_ptr   LABEL  WORD	     ;FILLED IN TO POINT TO ONE of the device names in parse.asm
	dw		?			;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Char_Field_ASCIIZ ; 		    ;AN000;
dev_name_size	  db	4			;changed by invoke: 3 for CON, 4 for others
	db		3			;				;AN000;
	db		Blank			;				;AN000;

;---------------------------			;

Sublist_retry_equal label byte			;"RETRY=%1"
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
retry_type_ptr	  LABEL BYTE
	dw		?			;
	dw		to_be_filled_in 	;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Char_Field_ASCIIZ ; 		    ;AN000;
	db		0;RPS			;max size, "NONE"
	db		1			;min size, "E"                  ;AN000;
	db		Blank			;				;AN000;

;---------------------------			;
sublist_syntax_error   label byte	   ;AN000;description of %0
						;
	db		Sublist_Length		;fixed				;AN000;
	db		Reserved		;not used yet			;AN000;
syntax_error_ptr	LABEL WORD
	dw		offset	 offending_parameter	 ;pointer to string or binary value	;AN000;
	dw		to_be_filled_in 	;
	db		0			;ID, special end of message format ;AN000;
	db		Left_Align+char_field_ASCIIZ	   ;AN000;
	db		0			;Max width 123, 128-"MODE "    ;AN000;
	db		1			;May be one char long	       ;AN000;
	db		Blank			;				;AN000;







Number_of_sublists   EQU   (($ - first_sublist) / (TYPE sublist_def))



;		    MESSAGE PIECES
;-------------------------------------------------------

PT80N		DB  " "   ;PT80 - CR,LF,"LPT%c: set for 80",CR,LF,EOM

PT132N		DB  " "   ;PT132 - CR,LF,"LPT%c: set for 132",CR,LF,EOM

;INITMSG - CR,LF,"COM%c: %3s,%c,%c,%c,%c",CR,LF,EOM
DEVICE	       DB  " "
pBAUD	       DB  5 DUP(" "),EOM
pPARITY        DB  "e"        ;DEFAULT IS EVEN PARITY
pDATA	       DB  "7"        ;DEFAULT IS 7 DATA BITS PER BYTE
pSTOP	       DB  "1",EOM    ;DEFAULT FOR BAUD > 110, CHANGED TO 2 FOR 110
Pparm	       DB  " "
baud_19200     DB   "19200",EOM

;REDIRMSG - CR,LF,"LPT%c: rerouted to COM%c:",CR,LF,EOM
REDPT		DB  " "
REDCOM		DB  " "

;NOTREMSG - CR,LF,"LPT%c: not rerouted",CR,LF,EOM
NOTREDPT	DB  " "

OFFENDING_PARAMETER  DB 123 DUP (EOM)

nada	    DB	  8,8,8,"   ",0        ;backspace over the " - "

CPMSGLST6CP    DW    44H   ;AC665;FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID


CPMSGLST9CP    DW    99H		 ;FILLED IN BY "QUERY" ROUTINE WITH CODEPAGE ID


row_value      DB    ?	   ;filled in by invoke.asm with screen lines requested or current setting
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\parshell.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


PRINTF_CODE SEGMENT PUBLIC

ASSUME CS:PRINTF_CODE,DS:PRINTF_CODE,ES:PRINTF_CODE,SS:PRINTF_CODE

FARSW	 EQU   0	   ;CALL parser by near call
DATESW	 EQU   0	   ;NO date checking code
TIMESW	 EQU   0	   ;NO time checking code
FILESW	 EQU   1	   ;have to check for font file name
CAPSW	 EQU   0	   ;don't have to display file names
CMPXSW	 EQU   1	   ;have complex list in codepage syntax
DRVSW	 EQU   0	   ;just a drive is never legal
QUSSW	 EQU   0	   ;quoted string is not legal
NUMSW	 EQU   1	   ;need to check a numeric value occaisionally
KEYSW	 EQU   1	   ;oodles of keywords to check
SWSW	 EQU   1	   ;/status
VAL1SW	 EQU   1	   ;handle numeric ranges
VAL2SW	 EQU   1	   ;handle list of numbers
VAL3SW	 EQU   1	   ;handle list of strings
BASESW	 EQU   1	   ;use DS addressability for PSDATA.INC variables
;INCSW	  EQU	1

include  version.inc
INCLUDE  PARSE.ASM

PUBLIC	 SYSPARSE

PRINTF_CODE ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\mode\rescode.asm ===
PAGE	,132			;

	TITLE	CODE TO BE MADE RESIDENT BY MODE

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #			  Description
;  --------  ---  ---  ------------------------------------------------------
;  03/26/90  MKS  C00  General cleanup.  Making short jumps out of long
;		       jumps, ridding of nops.
;  03/26/90  MKS  C03  Microsoft Bug #336.  Making MODE act like the bios,
;		       only checking DSR instead of both DSR and CTS.
;
;******************************************************************************
;
;----------------------------------------------------------------------------
;
; M001 : Returning a special value back to BIOS so that BIOS does not retry
;        an operation broken by CTRL BRK
;
; M007 : Bug#4058. Instead of checking just for DSR, check for DSR OR CTS
;	 to find whether printer is ready or not.
;
;----------------------------------------------------------------------------
;
.XLIST
   INCLUDE STRUC.INC
.LIST
;.SALL

;  P R O L O G  ͻ				   ;AN000;
;											  				   ;AN000;
															   ;AN000;
;  AC000 - P2852: Infinite retry check at beginning of INT 14 handler was using
;		  wrong bit pattern.

;  AC001 - P5148: retry_flag was addressing the wrong segment

;											  				   ;AN000;
;  P R O L O G  ͼ				   ;AN000;
															   ;AN000;

;  M A C R O S  ͻ
;											  

DISPLAY MACRO	MSG
	MOV	DX,OFFSET MSG
	CALL	PRINTF
	ENDM

GET_INT_VECT MACRO INT_NO		;Input: "INT_NO" - the interrupt to be gotten
	PUSH	AX
	MOV	AL,INT_NO		;
	MOV	AH,35H			;FUNCTION CALL "GET 