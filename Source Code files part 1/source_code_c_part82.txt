     {
            m_aPhysFreeListA.push_back(m_aReplacedPagesA.back());
            m_aReplacedPagesA.pop_back();
        }
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    // Ensure maps are in sync.
    // ========================

    dwRes = ResyncMaps();
    if (dwRes)
    {
		// Revert operation one
		while(revertCount>0)
			{
			m_aReplacedPagesA.push_back(m_aPhysFreeListA.back());
			// we allready have space from the operation one
			m_aPhysFreeListA.pop_back();	
			revertCount--;
			};
    	
        return dwRes;
    }

    // Write out temp map file.  The atomic rename/rollforward
    // is handled by CPageSource.
    // =======================================================

 
    dwRes = WriteMap(hFile);
    m_dwLastCheckpoint = GetCurrentTime();

    return dwRes; // May reflect WriteMap failure
}

//***************************************************************************
//
//  CPageFile::InitFreeList
//
//  Initializes the free list by a one-time analysis of the map.
//
//***************************************************************************
// rev2
DWORD CPageFile::InitFreeList()
{
    DWORD dwRes = NO_ERROR;
    try
    {
        for (DWORD i = 0; i < m_aPageMapA.size(); i++)
        {
            DWORD dwMapId = m_aPageMapA[i];
            if (dwMapId == WMIREP_INVALID_PAGE)
                m_aLogicalFreeListA.push_back(i);
        }
    }
    catch (CX_MemoryException &)
    {
        dwRes = ERROR_OUTOFMEMORY;
    }

    return dwRes;
}

//***************************************************************************
//
//  CPageFile::Trans_Begin
//
//***************************************************************************
// rev2
DWORD CPageFile::Trans_Begin()
{
    if (m_bInTransaction)
    {
    	_ASSERT(0, L"WinMgmt: Trans_Begin: Nested transactions are not allowed!\n");
        return ERROR_INVALID_OPERATION;
    }

    DWORD dwRes = ResyncMaps();
    if (dwRes)
    {
        return dwRes;
    }

    m_bInTransaction = TRUE;
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::Release
//
//  No checks for a checkpoint.
//
//***************************************************************************
// rev2
ULONG CPageFile::Release()
{
    LONG lRes = InterlockedDecrement(&m_lRef);
    if (lRes != 0)
        return (ULONG) lRes;

//    delete this;	//NOTE:  We are now an embedded object!
    return 0;
}

//***************************************************************************
//
//  ShellSort
//
//  Generic DWORD sort using Donald Shell algorithm.
//
//***************************************************************************
// rev2
static void ShellSort(std::vector <DWORD, wbem_allocator<DWORD> > &Array)
{
    for (int nInterval = 1; nInterval < Array.size() / 9; nInterval = nInterval * 3 + 1);

    while (nInterval)
    {
        for (int iCursor = nInterval; iCursor < Array.size(); iCursor++)
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 && Array[iBackscan] < Array[iBackscan-nInterval])
            {
                DWORD dwTemp = Array[iBackscan-nInterval];
                Array[iBackscan-nInterval] = Array[iBackscan];
                Array[iBackscan] = dwTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}

//***************************************************************************
//
//  StripHiBits
//
//  Removes the hi bit from the physical disk ids so that they are no
//  longer marked as 'replaced' in a transaction.
//
//***************************************************************************
//  rev2
void StripHiBits(std::vector <DWORD, wbem_allocator<DWORD> > &Array)
{
    for (int i = 0; i < Array.size(); i++)
    {
        DWORD dwVal = Array[i];
        if (dwVal != WMIREP_INVALID_PAGE)
            Array[i] = MERE_PAGE_ID(dwVal);
    }
}

//***************************************************************************
//
//  MoveCurrentToPrevious
//
//  Removes the CURRENT_TRANSACTION bit from the array and makes
//  it the PREVIOUS_TRANSACTION.
//
//***************************************************************************
//  rev2
void MoveCurrentToPrevious(std::vector <DWORD, wbem_allocator<DWORD> > &Array)
{
    for (int i = 0; i < Array.size(); i++)
    {
        DWORD dwVal = Array[i];
        if (dwVal != WMIREP_INVALID_PAGE && (dwVal & CURRENT_TRANSACTION))
            Array[i] = MERE_PAGE_ID(dwVal) | PREVIOUS_TRANSACTION;
    }
}

//***************************************************************************
//
//  CPageFile::FreePage
//
//  Frees a page within the current transaction.  The logical id
//  is not removed from the map; its entry is simply assigned to
//  'InvalidPage' (0xFFFFFFFF) and the entry is added to the
//  logical free list.
//
//  If the associated physical page has been written within
//  the transaction, it is simply added to the free list.  If the page
//  was never written to within this transaction, it is added to
//  the replaced list.
//
//***************************************************************************
//  rev2
DWORD CPageFile::FreePage(
    DWORD dwFlags,
    DWORD dwId
    )
{
    DWORD dwPhysId;

    if (!m_bInTransaction)
    {
        return ERROR_INVALID_OPERATION;
    }

    // Make sure the page is 'freeable'.
    // =================================

    if (dwId >= m_aPageMapB.size())
        return ERROR_INVALID_PARAMETER;

    // Remove from page map.
    // =====================

    try
    {
        dwPhysId = m_aPageMapB[dwId];
        if (dwPhysId == WMIREP_INVALID_PAGE)
            return ERROR_INVALID_OPERATION; // Freeing a 'freed' page?

        //Reserve space for all structures!
    	m_aLogicalFreeListB.reserve(m_aLogicalFreeListB.size() + 1);
        m_aLogicalFreeListA.reserve(max(m_aLogicalFreeListA.size(), m_aLogicalFreeListB.size()+1));
        if (dwPhysId & CURRENT_TRANSACTION)
        {
           m_aPhysFreeListB.reserve(m_aPhysFreeListB.size()+1+m_aDeferredFreeList.size());
           m_aPhysFreeListA.reserve(max(m_aPhysFreeListA.size(), m_aPhysFreeListB.size()+1+m_aDeferredFreeList.size()));
        }
        else if (dwPhysId & PREVIOUS_TRANSACTION)
        {
           m_aDeferredFreeList.reserve(m_aDeferredFreeList.size()+1);
        }
        else // previous checkpoint
        {
           m_aReplacedPagesB.reserve(m_aReplacedPagesB.size()+1);
           m_aReplacedPagesA.reserve(max(m_aReplacedPagesA.size(), m_aReplacedPagesB.size()+1));
        }

    	//Carry out the operation now we have all the memory we need
        m_aPageMapB[dwId] = WMIREP_INVALID_PAGE;
        m_aLogicalFreeListB.push_back( MERE_PAGE_ID(dwId));
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    if (dwPhysId == WMIREP_RESERVED_PAGE)
    {
        // The logical page was freed without being ever actually committed to
        // a physical page. Legal, but weird.  The caller had a change of heart.
        return NO_ERROR;
    }

    // Examine physical page to determine its ancestry.  There are
    // three cases.
    // 1. If the page was created within the current transaction,
    //    we simply add it back to the free list.
    // 2. If the page was created in a previous transaction, we add
    //    it to the deferred free list.
    // 3. If the page was created in the previous checkpoint, we add
    //    it to the replaced pages list.
    // ==============================================================

    try
    {
        if (dwPhysId & CURRENT_TRANSACTION)
           m_aPhysFreeListB.push_back(MERE_PAGE_ID(dwPhysId));
        else if (dwPhysId & PREVIOUS_TRANSACTION)
           m_aDeferredFreeList.push_back(MERE_PAGE_ID(dwPhysId));
        else // previous checkpoint
           m_aReplacedPagesB.push_back(MERE_PAGE_ID(dwPhysId));
    }
    catch(CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    return NO_ERROR;
}


//***************************************************************************
//
//  CPageFile::GetPage
//
//  Gets a page.  Doesn't have to be within a transaction.  However, the
//  "B" generation map is always used so that getting within a transaction
//  will reference the correct page.
//
//***************************************************************************
//  rev2
DWORD CPageFile::GetPage(
    DWORD dwId,
    DWORD dwFlags,
    LPVOID pPage
    )
{
    DWORD dwRes;

    if (pPage == 0)
        return ERROR_INVALID_PARAMETER;

	CInCritSec _(&m_cs);

    // Determine physical id from logical id.
    // ======================================

    if (dwId >= m_aPageMapB.size())
        return ERROR_FILE_NOT_FOUND;

    DWORD dwPhysId = m_aPageMapB[dwId];
    if (dwPhysId == WMIREP_INVALID_PAGE || dwPhysId == WMIREP_RESERVED_PAGE)
        return ERROR_INVALID_OPERATION;

    LPBYTE pTemp = 0;
    dwRes = m_Cache.Read(MERE_PAGE_ID(dwPhysId), &pTemp);
    if (dwRes == 0)
        memcpy(pPage, pTemp, m_dwPageSize);

    return dwRes;
}

//***************************************************************************
//
//  CPageFile::PutPage
//
//  Writes a page. Must be within a transaction.   If the page has been
//  written for the first time within the transaction, a new replacement
//  page is allocated and the original page is added to the 'replaced'
//  pages list.   If the page has already been updated within this transaction,
//  it is simply updated again.  We know this because the physical page
//  id has the ms bit set (MAP_REPLACED_PAGE_FLAG).
//
//***************************************************************************
//  rev2
DWORD CPageFile::PutPage(
    DWORD dwId,
    DWORD dwFlags,
    LPVOID pPage
    )
{
    DWORD dwRes = 0, dwNewPhysId = WMIREP_INVALID_PAGE;

    if (pPage == 0)
        return ERROR_INVALID_PARAMETER;

    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;

    // Allocate some memory to hold the page, since we are reading
    // the caller's copy and not acquiring it.
    // ============================================================

    LPBYTE pPageCopy = new BYTE[m_dwPageSize];
    if (pPageCopy == 0)
        return ERROR_OUTOFMEMORY;
    memcpy(pPageCopy, pPage, m_dwPageSize);
    std::auto_ptr <BYTE> _autodelete(pPageCopy);

    // Look up the page.
    // =================

    if (dwId >= m_aPageMapB.size())
        return ERROR_INVALID_PARAMETER;

    DWORD dwPhysId = m_aPageMapB[dwId];
    if (dwPhysId == WMIREP_INVALID_PAGE)    // Unexpected
        return ERROR_GEN_FAILURE;

    // See if the page has already been written within this transaction.
    // =================================================================

    if ((CURRENT_TRANSACTION & dwPhysId)!= 0 && dwPhysId != WMIREP_RESERVED_PAGE)
    {
        // Just update it again.
        // =====================
        
        dwRes = m_Cache.Write(MERE_PAGE_ID(dwPhysId), LPBYTE(pPageCopy));

        if (dwRes == 0)
            _autodelete.release(); // memory acquired by cache
        return dwRes;
    }

    //Before we change anything else, lets pre-allocate any memory we may need!
    if (dwPhysId != WMIREP_RESERVED_PAGE)
    {
        try
        {
            if (dwPhysId & PREVIOUS_TRANSACTION)
                m_aDeferredFreeList.reserve(m_aDeferredFreeList.size()+1);
            else
            {
                m_aReplacedPagesB.reserve(m_aReplacedPagesB.size()+1);
                m_aReplacedPagesA.reserve(max(m_aReplacedPagesA.size(), m_aReplacedPagesB.size()+1));
            }
        }
        catch (CX_MemoryException &)
        {
            return ERROR_OUTOFMEMORY;
        }
    }
    

    // If here, we are going to have to get a new page for writing, regardless
    // of any special casing.  So, we'll do that part first and then decide
    // what to do with the old physical page.
    // ========================================================================

    dwRes = AllocPhysPage(&dwNewPhysId);
    if (dwRes)
    {
        return dwRes;
    }

    m_aPageMapB[dwId] = dwNewPhysId | CURRENT_TRANSACTION;

    dwRes = m_Cache.Write(MERE_PAGE_ID(dwNewPhysId), LPBYTE(pPageCopy));

    if (dwRes)
        return dwRes;
    _autodelete.release();    // Memory safely acquired by cache

    // If the old page ID was WMIREP_RESERVED_PAGE, we actually were
    // creating a page and there was no old page to update.
    // =====================================================================

    if (dwPhysId != WMIREP_RESERVED_PAGE)
    {
        // If here, the old page was either part of the previous checkpoint
        // or the previous set of transactions (the case of rewriting in the
        // current transaction was handled up above).

        try
        {
            if (dwPhysId & PREVIOUS_TRANSACTION)
                m_aDeferredFreeList.push_back(MERE_PAGE_ID(dwPhysId));
            else
                m_aReplacedPagesB.push_back(MERE_PAGE_ID(dwPhysId));
        }
        catch (CX_MemoryException &)
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    return dwRes;
}



//***************************************************************************
//
//  CPageFile::ReclaimLogicalPages
//
//  Reclaims <dwCount> contiguous logical pages from the free list, if possible.
//  This is done by simply sorting the free list, and then seeing if
//  any contiguous entries have successive ids.
//
//  Returns NO_ERROR on success, ERROR_NOT_FOUND if no sequence could be
//  found, or other errors which are considered critical.
//
//  Callers verified for proper use of return code.
//
//***************************************************************************
//  rev2
DWORD CPageFile::ReclaimLogicalPages(
    DWORD dwCount,
    DWORD *pdwId
    )
{
    std::vector <DWORD, wbem_allocator<DWORD> > &v = m_aLogicalFreeListB;

    DWORD dwSize = v.size();

    if (dwSize < dwCount)
        return ERROR_NOT_FOUND;

    // Special case for one page.
    // ==========================

    if (dwCount == 1)
    {
        try
        {
            *pdwId = v.back();
            v.pop_back();
            m_aPageMapB[*pdwId] = WMIREP_RESERVED_PAGE;
        }
        catch(CX_MemoryException &)
        {
            return ERROR_OUTOFMEMORY;
        }
        return NO_ERROR;
    }

    // If here, a multi-page sequence was requested.
    // =============================================
    ShellSort(v);

    DWORD dwContiguous = 1;
    DWORD dwStart = 0;

    for (DWORD dwIx = 0; dwIx+1 < dwSize; dwIx++)
    {
        if (v[dwIx]+1 == v[dwIx+1])
        {
            dwContiguous++;
        }
        else
        {
            dwContiguous = 1;
            dwStart = dwIx + 1;
        }

        // Have we achieved our goal?

        if (dwContiguous == dwCount)
        {
            *pdwId = v[dwStart];

            // Remove reclaimed pages from free list.
            // ======================================

            DWORD dwCount2 = dwCount;

            try
            {
                v.erase(v.begin()+dwStart, v.begin()+dwStart+dwCount);
            }
            catch(CX_MemoryException &)
            {
                return ERROR_OUTOFMEMORY;
            }

            // Change entries in page map to 'reserved'
            // ========================================

            dwCount2 = dwCount;
            for (DWORD i = *pdwId; dwCount2--; i++)
            {
                m_aPageMapB[i] = WMIREP_RESERVED_PAGE;
            }

            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}


//***************************************************************************
//
//  CPageFile::AllocPhysPage
//
//  Finds a free page, first by attempting to reuse the free list,
//  and only if it is zero-length by allocating a new extent to the file.
//
//  The page is marked as CURRENT_TRANSACTION before being returned.
//
//***************************************************************************
// rev2
DWORD CPageFile::AllocPhysPage(DWORD *pdwId)
{
    // Check the physical free list.
    // =============================

    if (m_aPhysFreeListB.size() == 0)
    {
        // No free pages.  Allocate a new one.
        // ===================================

        if (m_dwPhysPagesB == MAX_NUM_PAGES)
        {
            *pdwId = WMIREP_INVALID_PAGE;
            return ERROR_DISK_FULL;
        }

        *pdwId = m_dwPhysPagesB++;
        return NO_ERROR;
    }

    // Get the free page id from the block nearest the start of the file.
    // ==================================================================

	DWORD dwCurId = (DWORD)-1;
	DWORD dwCurValue = (DWORD) -1;
	for (DWORD dwIndex = 0; dwIndex != m_aPhysFreeListB.size(); dwIndex++)
	{
		if (m_aPhysFreeListB[dwIndex] < dwCurValue)
		{
			dwCurValue = m_aPhysFreeListB[dwIndex];
			dwCurId = dwIndex;
		}
	}

	*pdwId = dwCurValue;

    // Remove the entry from the free list.
    // ====================================
    m_aPhysFreeListB.erase(m_aPhysFreeListB.begin()+dwCurId);

    return NO_ERROR;
}


//***************************************************************************
//
//  CPageFile::NewPage
//
//  Allocates one or more contiguous logical page ids for writing.
//
//  This function makes no reference or use of physical pages.
//
//  First examines the free list.  If there aren't any, then a new range
//  of ids is assigned.  These pages must be freed, even if they aren't
//  written, once this call is completed.
//
//***************************************************************************
// rev2
DWORD CPageFile::NewPage(
    DWORD dwFlags,
    DWORD dwRequestedCount,
    DWORD *pdwFirstId
    )
{
    DWORD dwRes;

    if (!m_bInTransaction)
        return ERROR_INVALID_OPERATION;

    // See if the logical free list can satisfy the request.
    // =====================================================

    dwRes = ReclaimLogicalPages(dwRequestedCount, pdwFirstId);
    if (dwRes == NO_ERROR)
        return NO_ERROR;

    if (dwRes != ERROR_NOT_FOUND)
    {
        return dwRes;
    }

    // If here, we have to allocate new pages altogether.
    // We do this by adding them to the map as 'reserved'
    // pages.
    // ===================================================

    //reserve the space up front
	try
	{
	    m_aPageMapB.reserve(m_aPageMapB.size() + dwRequestedCount);
	    m_aPageMapA.reserve(max(m_aPageMapA.size(), m_aPageMapB.size()+dwRequestedCount));
	}
	catch(CX_MemoryException &)
	{
	    return ERROR_OUTOFMEMORY;
	}

    DWORD dwStart = m_aPageMapB.size();

    for (DWORD dwIx = 0; dwIx < dwRequestedCount; dwIx++)
    {
        try
        {
            m_aPageMapB.push_back(WMIREP_RESERVED_PAGE);
        }
        catch(CX_MemoryException &)
        {
            return ERROR_OUTOFMEMORY;
        }

    }

    *pdwFirstId = dwStart;
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::CPageFile
//
//***************************************************************************
//  rev2
CPageFile::CPageFile(const wchar_t *wszStoreName)
: m_wszStoreName(wszStoreName), m_Cache(wszStoreName)
{
    m_lRef = 1;
    m_dwPageSize = 0;
    m_dwCacheSpillRatio = 0;
    m_bInTransaction = 0;
    m_dwLastCheckpoint = GetCurrentTime();
    m_dwTransVersion = 0;

    m_dwPhysPagesA = 0;
    m_dwPhysPagesB = 0;
    m_bCsInit = false;
}

//***************************************************************************
//
//  CPageFile::~CPageFile
//
//***************************************************************************
//  rev2
CPageFile::~CPageFile()
{
    if (m_bCsInit)
    	DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//  FileExists
//
//***************************************************************************
// rev2
BOOL CPageSource::FileExists(LPCWSTR pszFile, NTSTATUS& Status  )
{
    if (!NT_SUCCESS(Status)) return FALSE;
    
    UNICODE_STRING PathName;
    FILE_BASIC_INFORMATION BasicInfo;
    OBJECT_ATTRIBUTES Obja;
    
    CFileName PreFixPath;
    if (PreFixPath == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        return FALSE;
    }
    StringCchCopyW(PreFixPath,PreFixPath.Length(), L"\\??\\");
    StringCchCopyW(PreFixPath+4,PreFixPath.Length()-4,pszFile);

    Status = RtlInitUnicodeStringEx(&PathName,PreFixPath);
    if (!NT_SUCCESS(Status) )
    	return FALSE;

    InitializeObjectAttributes(
        &Obja,
        &PathName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    GETTIME(Counter::OpTypeExist);
       
    Status = NtQueryAttributesFile(&Obja,&BasicInfo);

    if (NT_SUCCESS(Status) )
		return TRUE;
    else if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
		Status = STATUS_SUCCESS;    
    else
	{
#ifdef DBG
		DbgPrintfA(0,"NtQueryAttributesFile(%S) status %d\n",pszFile,Status);			    
#endif
	}

	return FALSE;    
}

struct MapProlog {
	DWORD dwSig;
	DWORD TransID;
	DWORD PhysSize;
	DWORD PageSize;
};

//***************************************************************************
//
//  CPageFile::Map_Startup
//
//  Since this can only happen *after* a successful checkpoint or
//  a reboot, we won't set any internal status, as it doesn't affect
//  the page set.  It only affects rollforward/rollback at the checkpoint
//  level.
//
//***************************************************************************
// rev2
DWORD CPageFile::RollForwardV1Maps(WString& sDirectory)
{
    WString sSemaphore;
    WString sBTreeMap;
    WString sBTreeMapNew;
    WString sObjMap;
    WString sObjMapNew;

	try
	{
	    sSemaphore = sDirectory;
	    sSemaphore += L"\\ROLL_FORWARD";       

	    sBTreeMap =  sDirectory;
	    sBTreeMap += L"\\" ;
	    sBTreeMap += WMIREP_BTREE_MAP;

	    sBTreeMapNew = sDirectory;
	    sBTreeMapNew += L"\\";
	    sBTreeMapNew += WMIREP_BTREE_MAP_NEW;

	    sObjMap =  sDirectory;
	    sObjMap += L"\\" ;
	    sObjMap += WMIREP_OBJECT_MAP;

	    sObjMapNew = sDirectory;
	    sObjMapNew += L"\\";
	    sObjMapNew += WMIREP_OBJECT_MAP_NEW;
	}
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    // To decide what to do, we need to know which files exist and which don't.
    // ========================================================================

    NTSTATUS status = STATUS_SUCCESS;

    BOOL bSemaphore             = CPageSource::FileExists(sSemaphore,status); //(WMIREP_ROLL_FORWARD);    
    BOOL bExists_BTreeMap       = CPageSource::FileExists(sBTreeMap,status); //(WMIREP_BTREE_MAP);
    BOOL bExists_BTreeMapNew    = CPageSource::FileExists(sBTreeMapNew,status); //(WMIREP_BTREE_MAP_NEW);
    BOOL bExists_ObjMap         = CPageSource::FileExists(sObjMap,status); //(WMIREP_OBJECT_MAP);
    BOOL bExists_ObjMapNew      = CPageSource::FileExists(sObjMapNew,status); //(WMIREP_OBJECT_MAP_NEW);

    if (!NT_SUCCESS(status))
		RtlNtStatusToDosError( status );

    if (bSemaphore)
    {
    	//Deal with foll forward of tree map file...
		if (bExists_BTreeMapNew)
		{
			if (bExists_BTreeMap) 
				if (!DeleteFileW((const wchar_t *)sBTreeMap))
					return GetLastError();
		    if (!MoveFileW((const wchar_t *)sBTreeMapNew,(const wchar_t *)sBTreeMap))
		    	return GetLastError();
		}

		//Deal with foll forward of object map file...
		if (bExists_ObjMapNew)
		{
			if (bExists_ObjMap)
				if (!DeleteFileW((const wchar_t *)sObjMap))
					return GetLastError();
		    if (!MoveFileW((const wchar_t *)sObjMapNew,(const wchar_t *)sObjMap))
		    	return GetLastError();
		}

	    if (!DeleteFileW((const wchar_t *)sSemaphore))
	    	return GetLastError();

	    return NO_ERROR;
    }
    
    //delete any .MAP.NEW files. they might still be there if there was no semaphore
    if (bExists_BTreeMapNew)
        if (!DeleteFileW((const wchar_t *)sBTreeMapNew))
        	return GetLastError();
    if (bExists_ObjMapNew)
        if (!DeleteFileW((const wchar_t *)sObjMapNew))
        	return GetLastError();

	if ( bExists_BTreeMap && 
	   bExists_ObjMap)
	{
	    // this is the good case
	    return NO_ERROR;
	} 
	else if (!bExists_ObjMap &&
      !bExists_BTreeMap )
    {
	    return NO_ERROR;
    } 
	else 
	{	
		//We have MAP files and not all the data files!  We need to tidy up!
		if (bExists_BTreeMap) 
			if (!DeleteFileW((const wchar_t *)sBTreeMap))
				return GetLastError();
		if (bExists_ObjMap) 
			if (!DeleteFileW((const wchar_t *)sObjMap))
				return GetLastError();
	}	
	
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageFile::Init
//
//  If failure occurs, we assume another call will follow.
//
//***************************************************************************
// rev2
DWORD CPageFile::Init(
	WString & sMainFile,
    DWORD dwPageSize,
    DWORD dwCacheSize,
    DWORD dwCacheSpillRatio
    )
{
    if ( dwPageSize == 0 ) 
    	return ERROR_INVALID_PARAMETER;

	if (!m_bCsInit)
	{
		m_bCsInit = InitializeCriticalSectionAndSpinCount(&m_cs,0)?true:false;
		if (!m_bCsInit) 
			return ERROR_OUTOFMEMORY;
	}
	m_dwPageSize = dwPageSize;
	m_dwCacheSpillRatio = dwCacheSpillRatio;

    DWORD dwRes = m_Cache.Init((const wchar_t *)sMainFile, 
                                                       m_dwPageSize,
                                                       dwCacheSize,
                                                       m_dwCacheSpillRatio);
    return dwRes;
}

DWORD CPageFile::DeInit()
{

	m_Cache.DeInit();

    m_aPageMapA.clear();
    m_aPhysFreeListA.clear();
    m_aLogicalFreeListA.clear();
    m_aReplacedPagesA.clear();
    m_dwPhysPagesA = 0;
    
    m_aPageMapB.clear();
    m_aPhysFreeListB.clear();
	m_aLogicalFreeListB.clear();
    m_aReplacedPagesB.clear();
    m_dwPhysPagesB = 0;
    
    m_aDeferredFreeList.clear();

    m_dwTransVersion = 0;

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CPageFile::CompactPages
//
// Moves the last dwNumPages pages from the end of the file to an empty space 
// somewhere earlier in the file.  
//
//***************************************************************************
//
DWORD CPageFile::CompactPages(DWORD dwNumPages)
{
	DWORD dwRet = NO_ERROR;

	//Need to loop though this little operation for the number of pages required
	//or until we exit the loop prematurely because we are compacted
	for (DWORD dwIter = 0; dwIter != dwNumPages; dwIter++)
	{
		//Now we need to find the physical page with the highest ID as this is the 
		//next candidate to be moved

		DWORD dwLogicalIdCandidate = 0;
		DWORD dwPhysicalIdCandidate = 0;

		for (DWORD dwLogicalPageId = 0; dwLogicalPageId != m_aPageMapB.size(); dwLogicalPageId++)
		{
			if (m_aPageMapB[dwLogicalPageId] == WMIREP_INVALID_PAGE)
				continue;
			if (m_aPageMapB[dwLogicalPageId] == WMIREP_RESERVED_PAGE)
				continue;
			if (MERE_PAGE_ID(m_aPageMapB[dwLogicalPageId]) > dwPhysicalIdCandidate)
			{
				//We found a candidate
				dwLogicalIdCandidate = dwLogicalPageId;
				dwPhysicalIdCandidate = MERE_PAGE_ID(m_aPageMapB[dwLogicalPageId]);
			}
		}

		//Find the lowest physical page ID available for use
		DWORD dwFirstPhysicalFreePage = (DWORD) -1;
		for (DWORD dwIndex = 0; dwIndex != m_aPhysFreeListB.size(); dwIndex++)
		{
			if (m_aPhysFreeListB[dwIndex] < dwFirstPhysicalFreePage)
			{
				dwFirstPhysicalFreePage = m_aPhysFreeListB[dwIndex];
			}
		}

		if (dwFirstPhysicalFreePage == (DWORD) -1)
		{
			//Wow!  There is no free space, so we will just exist!
			break;
		}

		if (dwFirstPhysicalFreePage > dwPhysicalIdCandidate)
		{
			//We are done!  There are no free pages before the last
			//actual physically stored page
			break;
		}

		//If here we have work to do for this iteration.
		//Just read and write the page.  The write will
		//go to a new page that is allocated in this earlier
		//page
		BYTE *pPage = new BYTE[m_dwPageSize];
		if (pPage == NULL)
		{
			dwRet = ERROR_OUTOFMEMORY;
			break;
		}
	    std::auto_ptr <BYTE> _autodelete(pPage);

		dwRet = GetPage(dwLogicalIdCandidate, 0, pPage);
		if (dwRet != 0)
			break;

		dwRet = PutPage(dwLogicalIdCandidate, 0, pPage);
		if (dwRet != 0)
			break;

		
	}
	return dwRet;
}

#ifdef WMI_PRIVATE_DBG
DWORD CPageFile::DumpFileInformation(HANDLE hFile)
{
	wchar_t wszDebug[60];
	DWORD dwPhysicalPageId = 0;
	DWORD dwLogicalPageId = 0;
	for (DWORD i = 0; i != m_aPageMapA.size(); i++)
	{
		if ((m_aPageMapA[i] != WMIREP_INVALID_PAGE) && (dwPhysicalPageId < m_aPageMapA[i]))
		{
			dwPhysicalPageId = m_aPageMapA[i];
			dwLogicalPageId = i;
		}
	}
	LARGE_INTEGER dataFileSize;
	dataFileSize.QuadPart = 0;
	m_Cache.GetFileSize(&dataFileSize);
	StringCchPrintfW(wszDebug, 60, L"%s, <0x%X> <0x%X> <0x%X%08X>\n", m_wszStoreName, dwPhysicalPageId, dwLogicalPageId, dataFileSize.HighPart, dataFileSize.LowPart);
	ERRORTRACE((LOG_REPDRV, "%S", wszDebug));
	OutputDebugStringW(wszDebug);

	return ERROR_SUCCESS;
}
#endif

//***************************************************************************
//
//  CPageFile::Dump
//
//***************************************************************************
//
void CPageFile::DumpFreeListInfo()
{
    int i;
    printf("------Free List Info--------\n");
    printf("   Phys Free List (B) =\n");
    for (i = 0; i < m_aPhysFreeListB.size(); i++)
        printf("      0x%X\n", m_aPhysFreeListB[i]);

    printf("   Replaced Pages (B) =\n");
    for (i = 0; i < m_aReplacedPagesB.size(); i++)
        printf("      0x%X\n", m_aReplacedPagesB[i]);

    printf("   Deferred Free List =\n");
    for (i = 0; i < m_aDeferredFreeList.size(); i++)
        printf("      0x%X\n", m_aDeferredFreeList[i]);
    printf("-----End Free List Info -----------\n");

    printf("   Logical Free List =\n");
    for (i = 0; i < m_aLogicalFreeListB.size(); i++)
        printf("      0x%X\n", m_aLogicalFreeListB[i]);
    printf("-----End Free List Info -----------\n");
}

//***************************************************************************
//
//  CPageFile::Dump
//
//***************************************************************************
//  rev2
void CPageFile::Dump(FILE *f)
{
    fprintf(f, "---Page File Dump---\n");
    fprintf(f, "Ref count = %d\n", m_lRef);
    fprintf(f, "Page size = 0x%x\n", m_dwPageSize);
    fprintf(f, "In transaction = %d\n", m_bInTransaction);
    fprintf(f, "Time since last checkpoint = %d\n", GetCurrentTime() - m_dwLastCheckpoint);
    fprintf(f, "Transaction version = %d\n", m_dwTransVersion);

    fprintf(f, "   ---Logical Page Map <Generation A>---\n");
    fprintf(f, "   Phys pages = %d\n", m_dwPhysPagesA);

    int i;
    for (i = 0; i < m_aPageMapA.size(); i++)
        fprintf(f, "   Page[%d] = phys id 0x%x (%d)\n", i, m_aPageMapA[i], m_aPageMapA[i]);

    fprintf(f, "   ---<Generation A Physical Free List>---\n");
    for (i = 0; i < m_aPhysFreeListA.size(); i++)
        fprintf(f, "   phys free = %d\n", m_aPhysFreeListA[i]);

    fprintf(f, "   ---<Generation A Logical Free List>---\n");
    for (i = 0; i < m_aLogicalFreeListA.size(); i++)
        fprintf(f, "   logical free = %d\n", m_aLogicalFreeListA[i]);

    fprintf(f, "   ---<Generation A Replaced Page List>---\n");
    for (i = 0; i < m_aReplacedPagesA.size(); i++)
        fprintf(f, "   replaced = %d\n", m_aReplacedPagesA[i]);

    fprintf(f, "   ---END Generation A mapping---\n");

    fprintf(f, "   ---Logical Page Map <Generation B>---\n");
    fprintf(f, "   Phys pages = %d\n", m_dwPhysPagesB);

    for (i = 0; i < m_aPageMapB.size(); i++)
        fprintf(f, "   Page[%d] = phys id 0x%x (%d)\n", i, m_aPageMapB[i], m_aPageMapB[i]);

    fprintf(f, "   ---<Generation B Physical Free List>---\n");
    for (i = 0; i < m_aPhysFreeListB.size(); i++)
        fprintf(f, "   phys free = %d\n", m_aPhysFreeListB[i]);

    fprintf(f, "   ---<Generation B Logical Free List>---\n");
    for (i = 0; i < m_aLogicalFreeListB.size(); i++)
        fprintf(f, "   logical free = %d\n", m_aLogicalFreeListB[i]);

    fprintf(f, "   ---<Generation B Replaced Page List>---\n");
    for (i = 0; i < m_aReplacedPagesB.size(); i++)
        fprintf(f, "   replaced = %d\n", m_aReplacedPagesB[i]);

    fprintf(f, "   ---END Generation B mapping---\n");
    fprintf(f, "END Page File Dump\n");
}


//***************************************************************************
//
//  CPageSource::GetBTreePageFile
//
//***************************************************************************
// rev2
DWORD CPageSource::GetBTreePageFile(OUT CPageFile **pPF)
{
    *pPF = &m_BTreePF;
    m_BTreePF.AddRef();
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::GetObjectHeapPageFile
//
//***************************************************************************
// rev2
DWORD CPageSource::GetObjectHeapPageFile(OUT CPageFile **pPF)
{
    *pPF = &m_ObjPF;
    m_ObjPF.AddRef();
    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::BeginTrans
//
//  If either object gets messed up due to out-of-mem, out-of-disk for
//  the cache, etc., then error codes will be returned.  Calling this
//  forever won't help anything.  Rollback may help, but RollbackCheckpoint
//  is likely required.
//
//***************************************************************************                                                      //
//  rev2
DWORD CPageSource::BeginTrans()
{
    DWORD dwRes;

    if (m_dwStatus)
    	return m_dwStatus;

    dwRes = m_ObjPF.Trans_Begin();
    if (dwRes)
    {
    	_ASSERT(0, L"WinMgmt: BeginTrans failed because of object store\n");
        return dwRes;
    }

    dwRes = m_BTreePF.Trans_Begin();
    if (dwRes)
    {
    	_ASSERT(0, L"WinMgmt: BeginTrans failed because of BTree store\n");
        return dwRes;
    }

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::Init
//
//  Called once at startup
//
//***************************************************************************
//
DWORD CPageSource::Init()
{
    DWORD dwRes;
    wchar_t *p1 = 0, *p2 = 0;
    p1 = new wchar_t[MAX_PATH+1];
    if (!p1)
        return ERROR_OUTOFMEMORY;
    std::auto_ptr <wchar_t> _1(p1);
    p2 = new wchar_t[MAX_PATH+1];
    if (!p2)
        return ERROR_OUTOFMEMORY;
    std::auto_ptr <wchar_t> _2(p2);

    // Set up working directory, filenames, etc.
    // =========================================

    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                        0, KEY_READ, &hKey);

    if (lRes)
        return ERROR_GEN_FAILURE;
    DWORD dwLen = MAX_PATH*2;   // in bytes

    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL,
                            (LPBYTE)(wchar_t*)p1, &dwLen);
    ExpandEnvironmentStringsW(p1, p2, MAX_PATH);

    try
    {
        m_sDirectory = p2;
        m_sDirectory += L"\\FS";
        
        m_FileMainData = m_sDirectory;
        m_FileMainData += L"\\";
        m_FileMainData += WMIREP_OBJECT_DATA;

        m_FileMainBtr = m_sDirectory;
        m_FileMainBtr += L"\\";
        m_FileMainBtr += WMIREP_BTREE_DATA;

        m_FileMap1= m_sDirectory;
        m_FileMap1 += L"\\";
        m_FileMap1 += WMIREP_MAP_1;
        
        m_FileMap2 = m_sDirectory;
        m_FileMap2 += L"\\";
        m_FileMap2 += WMIREP_MAP_2;
        
        m_FileMapVer = m_sDirectory;
        m_FileMapVer += L"\\";
        m_FileMapVer += WMIREP_MAP_VER;
    }
    catch (CX_MemoryException &)
    {
        RegCloseKey(hKey);
        return ERROR_OUTOFMEMORY;
    }

    // Read cache settings.
    // ====================

    m_dwPageSize = WMIREP_PAGE_SIZE;
    m_dwCacheSize = 32;
    m_dwCacheSpillRatio = 4;
    DWORD dwTemp = 0;
    dwLen = sizeof(DWORD);

    lRes = RegQueryValueExW(hKey, L"Repository Page Size", NULL, NULL,
                            (LPBYTE)&dwTemp, &dwLen);
    if (lRes == 0)
        m_dwPageSize = dwTemp;

    dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"Repository Cache Size", NULL, NULL,
                            (LPBYTE)&dwTemp, &dwLen);
    if (lRes == 0)
        m_dwCacheSize = dwTemp;

    dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"Repository Cache Spill Ratio", NULL, NULL,
                            (LPBYTE)&dwTemp, &dwLen);
    if (lRes == 0)
        m_dwCacheSpillRatio = dwTemp;

    RegCloseKey(hKey);

    dwRes = Startup();
    return dwRes;
}

//***************************************************************************
//
//  CPageSource::Shutdown
//
//***************************************************************************
//  rev2
DWORD CPageSource::Shutdown(DWORD dwFlags)
{
    DWORD dwRes = Checkpoint(false);
	m_ObjPF.DeInit();
	m_BTreePF.DeInit();
	m_ObjPF.Release();
	m_BTreePF.Release();

	CloseMapFiles();
    
    return dwRes;
}


//***************************************************************************
//
//  CPageSource::CommitTrans
//
//***************************************************************************
//  rev2
DWORD CPageSource::CommitTrans()
{
    DWORD dwRes;

    dwRes = m_ObjPF.Trans_Commit();
    if (dwRes)
    {
    	_ASSERT(0, L"WinMgmt: CommitTrans failed in object store\n");
        return dwRes;
    }

    dwRes = m_BTreePF.Trans_Commit();
    if (dwRes)
    {
    	_ASSERT(0, L"WinMgmt: CommitTrans failed in BTree store\n");
        return dwRes;
    }

    // at this point only increment the Transaction Version
    m_BTreePF.IncrementTransVersion();
    m_ObjPF.IncrementTransVersion();

    if (m_BTreePF.GetTransVersion() != m_ObjPF.GetTransVersion())
    {
    	_ASSERT(0, L"WinMgmt: CommitTrans failed due to transaction missmatch\n");
        return ERROR_REVISION_MISMATCH;
    }

    return dwRes;
}

//***************************************************************************
//
//  CPageSource::RollbackTrans
//
//  This needs to succeed and clear out the out-of-memory status flag
//  once it does.
//
//***************************************************************************
//  rev2
DWORD CPageSource::RollbackTrans()
{
    DWORD dwRes;

    dwRes = m_ObjPF.Trans_Rollback();
    if (dwRes)
    {
    	_ASSERT(0, L"WinMgmt: RollbackTrans failed because of object store\n");
        return dwRes;
    }

    dwRes = m_BTreePF.Trans_Rollback();
    if (dwRes)
    {
    	_ASSERT(0, L"WinMgmt: RollbackTrans failed because of BTree store\n");
        return dwRes;
    }

    if (m_BTreePF.GetTransVersion() != m_ObjPF.GetTransVersion())
    {
    	_ASSERT(0, L"WinMgmt: RollbackTrans failed because of transaction missmatch\n");
        return ERROR_REVISION_MISMATCH;
    }

    return dwRes;
}

//***************************************************************************
//
//  CPageSource::Checkpoint
//
//***************************************************************************
//
DWORD CPageSource::Checkpoint(bool bCompactPages)
{
    DWORD dwRes = 0;
    m_dwStatus = 0;

	if (bCompactPages)
	{
		CompactPages(10);
	}

	DWORD dwNextFileMapVer = m_dwFileMapVer==1?2:1;
	HANDLE hNextMapFile = m_dwFileMapVer==1?m_hFileMap2:m_hFileMap1;

	//Lets move to the start of the file we are going to write to during this operations
	LARGE_INTEGER pos;
	pos.QuadPart = 0;
	if (SetFilePointerEx(hNextMapFile, pos, 0, FILE_BEGIN) == 0)
		return m_dwStatus = GetLastError();
    dwRes = m_ObjPF.Trans_Checkpoint(hNextMapFile);
    if (dwRes)
        return m_dwStatus = dwRes;

    dwRes = m_BTreePF.Trans_Checkpoint(hNextMapFile);
    if (dwRes)
        return m_dwStatus = dwRes;

    if (FlushFileBuffers(hNextMapFile) == 0)
    	return m_dwStatus = GetLastError();

    if (m_BTreePF.GetTransVersion() != m_ObjPF.GetTransVersion())
    {
        return m_dwStatus = ERROR_REVISION_MISMATCH;
    }

	DWORD dwNumBytesWritten = 0;
	if (SetFilePointerEx(m_hFileMapVer, pos, 0, FILE_BEGIN) == 0)
		return m_dwStatus = GetLastError();

	if ((WriteFile(m_hFileMapVer, &dwNextFileMapVer, sizeof(dwNextFileMapVer), &dwNumBytesWritten, NULL) == 0) ||
		dwNumBytesWritten != sizeof(dwNextFileMapVer))
		return m_dwStatus = GetLastError();

	if (FlushFileBuffers(m_hFileMapVer) == 0)
		return m_dwStatus = GetLastError();

    //Flip to the new version of the MAP file
    m_dwFileMapVer = dwNextFileMapVer;

    m_dwLastCheckpoint = GetCurrentTime();

    return NO_ERROR;
}

//***************************************************************************
//
//  CPageSource::Restart
//
//***************************************************************************
//
DWORD CPageSource::Startup()
{
    DWORD dwRes = ERROR_SUCCESS;
    bool bReadMapFiles = true;
	bool bV2RepositoryExists = true;
	bool bV1RepositoryExists = false;
	bool bRecoveredRepository = false;

    // Do rollback or rollforward, depending on last system status.
    // ======================================
    if (dwRes == ERROR_SUCCESS)
	    dwRes = V2ReposititoryExists(&bV2RepositoryExists);

    if (dwRes == ERROR_SUCCESS)
    	dwRes = V1ReposititoryExists(&bV1RepositoryExists);

	if ((dwRes == ERROR_SUCCESS) && bV1RepositoryExists && bV2RepositoryExists)
	{
		ERRORTRACE((LOG_REPDRV, "New and old repository MAP files existed so we deleted the repository\n"));
		dwRes= DeleteRepository();
	}
    else if ((dwRes == ERROR_SUCCESS) && !bV2RepositoryExists && bV1RepositoryExists)
    {
	    dwRes = CPageFile::RollForwardV1Maps(m_sDirectory);
	    if (dwRes == ERROR_SUCCESS)
	    {
			ERRORTRACE((LOG_REPDRV, "Repository version 1 MAP files are being upgraded to version 2\n"));
	    	dwRes = UpgradeV1Maps();

	    	if (dwRes != ERROR_SUCCESS)
	    	{

				ERRORTRACE((LOG_REPDRV, "Repository upgrade of the MAP files failed. Deleting repository\n"));
				dwRes= DeleteRepository();
	    	}
	    }
	    else
	    {

			ERRORTRACE((LOG_REPDRV, "Repository roll-forward of V1 MAPs failed. Deleting repository\n"));
			dwRes= DeleteRepository();
	    }
    }

StartupRecovery:	//Calls here if we needed to delete the repositorty!

    if (dwRes == ERROR_SUCCESS)
    {
	    dwRes = OpenMapFiles();

		//This special case failure means we have not written to the file yet!
	    if (dwRes == ERROR_FILE_NOT_FOUND)
	    {
	    	bReadMapFiles = false;
	    	dwRes = ERROR_SUCCESS;
	    }
    }

    if (dwRes == ERROR_SUCCESS)
    {
		dwRes = m_ObjPF.Init(
			m_FileMainData,
			m_dwPageSize,
			m_dwCacheSize,
			m_dwCacheSpillRatio
			);
    }

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = m_BTreePF.Init(
			m_FileMainBtr,
			m_dwPageSize,
			m_dwCacheSize,
			m_dwCacheSpillRatio);
	}

	if (bReadMapFiles)
	{
		if (dwRes == ERROR_SUCCESS)
			dwRes = m_ObjPF.ReadMap(m_dwFileMapVer==1?m_hFileMap1:m_hFileMap2);

		if (dwRes == ERROR_SUCCESS)
			dwRes = m_BTreePF.ReadMap(m_dwFileMapVer==1?m_hFileMap1:m_hFileMap2);
	}

	

	if (dwRes != ERROR_SUCCESS)
	{
		m_ObjPF.DeInit();
		m_BTreePF.DeInit();
		CloseMapFiles();
	}

	if ((dwRes == ERROR_INTERNAL_DB_CORRUPTION) && !bRecoveredRepository)
	{
		bRecoveredRepository = true;
		dwRes = DeleteRepository();
		if (dwRes == ERROR_SUCCESS)
			goto StartupRecovery;
	}
	
	return dwRes;
}

//***************************************************************************
//
//  CPageSource::Dump
//
//***************************************************************************
//  rev2
void CPageSource::Dump(FILE *f)
{
    // no impl
}

//***************************************************************************
//
//  CPageSource::CPageSource
//
//***************************************************************************
// rev2
CPageSource::CPageSource()
: m_BTreePF(L"BTree Store"), m_ObjPF(L"Object Store")
{
	m_dwStatus = 0;
    m_dwPageSize = 0;
    m_dwLastCheckpoint = GetCurrentTime();
}

//***************************************************************************
//
//  CPageSource::~CPageSource
//
//***************************************************************************
// rev2
CPageSource::~CPageSource()
{
    m_BTreePF.Release();
    m_ObjPF.Release();    
}

//***************************************************************************
//
//  CPageSource::EmptyCaches
//
//***************************************************************************
//  rev2
DWORD CPageSource::EmptyCaches()
{
    DWORD dwRet = ERROR_SUCCESS;
	dwRet = m_BTreePF.EmptyCache();
    if (dwRet == ERROR_SUCCESS)
        dwRet = m_ObjPF.EmptyCache();
    return dwRet;
}

//***************************************************************************
//
//  CPageSource::CompactPages
//
//	Takes the last n pages and shuffles them up to the start of the file.
//	Pre-conditions: 
//		* Write lock held on the repository
//		* No active read or write operations (all transactions finished)
//		* No unflushed operations, or check-points (although not totally necessary!)
//
//***************************************************************************
HRESULT CPageSource::CompactPages(DWORD dwNumPages)
{
	DWORD dwRet = ERROR_SUCCESS;

	dwRet = BeginTrans();

	if (dwRet == ERROR_SUCCESS)
	{
		if (dwRet == ERROR_SUCCESS)
			dwRet = m_BTreePF.CompactPages(dwNumPages);
		if (dwRet == ERROR_SUCCESS)
			dwRet = m_ObjPF.CompactPages(dwNumPages);

		if (dwRet == ERROR_SUCCESS)
		{
			dwRet = CommitTrans();
		}
		else
		{
			dwRet = RollbackTrans();
		}
	}

	return dwRet;
}



//***************************************************************************
//
//  CPageSource::OpenMapFiles
//
//***************************************************************************
//
DWORD CPageSource::OpenMapFiles()
{
    m_hFileMap1 = CreateFileW(m_FileMap1, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, &g_SA,
            OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFileMap1 == INVALID_HANDLE_VALUE)
    	return GetLastError();
    
    m_hFileMap2 = CreateFileW(m_FileMap2, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, &g_SA,
            OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFileMap2 == INVALID_HANDLE_VALUE)
    {
    	CloseHandle(m_hFileMap1);
    	m_hFileMap1 = INVALID_HANDLE_VALUE;
    	return GetLastError();
    }

	m_hFileMapVer = CreateFileW(m_FileMapVer, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, &g_SA,
            OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFileMapVer == INVALID_HANDLE_VALUE)
    {
    	CloseHandle(m_hFileMap1);
    	m_hFileMap1 = INVALID_HANDLE_VALUE;
    	CloseHandle(m_hFileMap2);
    	m_hFileMap2 = INVALID_HANDLE_VALUE;
    	return GetLastError();
    }

	DWORD dwNumBytesRead = 0;
	m_dwFileMapVer = 1;
    if (!ReadFile(m_hFileMapVer, &m_dwFileMapVer, sizeof(m_dwFileMapVer), &dwNumBytesRead, NULL))
    {
    	CloseHandle(m_hFileMap1);
    	m_hFileMap1 = INVALID_HANDLE_VALUE;
    	CloseHandle(m_hFileMap2);
    	m_hFileMap2 = INVALID_HANDLE_VALUE;
    	return GetLastError();
    }
    else if (dwNumBytesRead == 0)
    	return ERROR_FILE_NOT_FOUND;
    else if (dwNumBytesRead != sizeof(m_dwFileMapVer))
	{
    	CloseHandle(m_hFileMap1);
    	m_hFileMap1 = INVALID_HANDLE_VALUE;
    	CloseHandle(m_hFileMap2);
    	m_hFileMap2 = INVALID_HANDLE_VALUE;
		return ERROR_FILE_INVALID;
    }

	return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CPageSource::CloseMapFiles
//
//***************************************************************************
//
DWORD CPageSource::CloseMapFiles()
{
	if (m_hFileMap1 != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFileMap1);
	if (m_hFileMap2 != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFileMap2);
	if (m_hFileMapVer != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFileMapVer);

	m_hFileMap1 = INVALID_HANDLE_VALUE;
	m_hFileMap2 = INVALID_HANDLE_VALUE;
	m_hFileMapVer = INVALID_HANDLE_VALUE;

	return ERROR_SUCCESS;
}

//***************************************************************************
//
//  CPageSource::V1ReposititoryExists
//
// 	Need to check if the V1 MAP files exist.
//		WMIREP_OBJECT_MAP
//		WMIREP_OBJECT_MAP_NEW
//		WMIREP_BTREE_MAP
//		WMIREP_BTREE_MAP_NEW
//		WMIREP_ROLL_FORWARD
//	If any of these exist then we return success
//
//***************************************************************************
DWORD CPageSource::V1ReposititoryExists(bool *pbV1RepositoryExists)
{
    WString sSemaphore;
    WString sBTreeMap;
    WString sBTreeMapNew;
    WString sObjMap;
    WString sObjMapNew;
	try
	{
	    sSemaphore = m_sDirectory;
	    sSemaphore += L"\\ROLL_FORWARD";       

	    sBTreeMap =  m_sDirectory;
	    sBTreeMap += L"\\" ;
	    sBTreeMap += WMIREP_BTREE_MAP;

	    sBTreeMapNew = m_sDirectory;
	    sBTreeMapNew += L"\\";
	    sBTreeMapNew += WMIREP_BTREE_MAP_NEW;

	    sObjMap =  m_sDirectory;
	    sObjMap += L"\\" ;
	    sObjMap += WMIREP_OBJECT_MAP;

	    sObjMapNew = m_sDirectory;
	    sObjMapNew += L"\\";
	    sObjMapNew += WMIREP_OBJECT_MAP_NEW;
	}
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }
    NTSTATUS status = STATUS_SUCCESS;

    BOOL bSemaphore				= FileExists(sSemaphore, status); //(WMIREP_ROLL_FORWARD); 
    BOOL bExists_BTreeMap		= FileExists(sBTreeMap, status); //(WMIREP_BTREE_MAP);
    BOOL bExists_BTreeMapNew	= FileExists(sBTreeMapNew, status); //(WMIREP_BTREE_MAP_NEW);
    BOOL bExists_ObjMap         = FileExists(sObjMap, status); //(WMIREP_OBJECT_MAP);
    BOOL bExists_ObjMapNew      = FileExists(sObjMapNew, status); //(WMIREP_OBJECT_MAP_NEW);

	if (bSemaphore|bExists_BTreeMap|bExists_BTreeMapNew|bExists_ObjMap|bExists_ObjMapNew)
	    *pbV1RepositoryExists = true;
    else
    	*pbV1RepositoryExists = false;

    return status;
}

//***************************************************************************
//
//  CPageSource::V2ReposititoryExists
//
// 	Need to check if the V2 MAP files exist.
//		WMIREP_MAP_1
//		WMIREP_MAP_2
//		WMIREP_MAP_VER
//	If any of these exist then we return success
//
//***************************************************************************
DWORD CPageSource::V2ReposititoryExists(bool *pbV2RepositoryExists)
{
    NTSTATUS status = STATUS_SUCCESS;

    BOOL bExists_Map1    = FileExists(m_FileMap1, status);
    BOOL bExists_Map2	 = FileExists(m_FileMap2, status);
    BOOL bExists_MapVer  = FileExists(m_FileMapVer, status);

	if (bExists_Map1|bExists_Map2|bExists_MapVer)
    	*pbV2RepositoryExists = true;
	else
		*pbV2RepositoryExists = false;

    return status;
}

//***************************************************************************
//
//  CPageSource::UpgradeV1ToV2Maps
//
//	Merges the 2 MAP files into 1, and creates a blank second one
//
//***************************************************************************
DWORD CPageSource::UpgradeV1Maps()
{
	DWORD dwRes = 0;
	//Open the two old files
    WString sBTreeMap;
    WString sObjMap;
	try
	{
	    sBTreeMap =  m_sDirectory;
	    sBTreeMap += L"\\" ;
	    sBTreeMap += WMIREP_BTREE_MAP;

	    sObjMap =  m_sDirectory;
	    sObjMap += L"\\" ;
	    sObjMap += WMIREP_OBJECT_MAP;
	}
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }
    HANDLE hFileBtreeMap = CreateFile(sBTreeMap, GENERIC_READ, FILE_SHARE_READ, &g_SA, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    HANDLE hFileObjMap = CreateFile(sObjMap, GENERIC_READ, FILE_SHARE_READ, &g_SA, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

	if ((hFileBtreeMap == INVALID_HANDLE_VALUE) || (hFileObjMap == INVALID_HANDLE_VALUE))
		dwRes = ERROR_GEN_FAILURE;
	
	//Open the two new files
    if (dwRes == ERROR_SUCCESS)
    {
	    dwRes = OpenMapFiles();
	    if (dwRes != ERROR_FILE_NOT_FOUND)
	    {
	    	//It should not be there!
	    	dwRes = ERROR_GEN_FAILURE;
	    }
	    else
	    	dwRes = 0;
    }

    if (dwRes == ERROR_SUCCESS)
    {
		dwRes = m_ObjPF.Init(
				m_FileMainData,
				m_dwPageSize,
				m_dwCacheSize,
				m_dwCacheSpillRatio
				);
    }

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = m_BTreePF.Init(
			m_FileMainBtr,
			m_dwPageSize,
			m_dwCacheSize,
			m_dwCacheSpillRatio);
	}

	//read the maps using the old ones
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_ObjPF.ReadMap(hFileObjMap);

	if (dwRes == ERROR_SUCCESS)
		dwRes = m_BTreePF.ReadMap(hFileBtreeMap);

	//write the maps using the new ones
	LARGE_INTEGER pos;
	pos.QuadPart = 0;
	if (dwRes == ERROR_SUCCESS)
		if (SetFilePointerEx(m_hFileMap1, pos, 0, FILE_BEGIN) == 0)
			dwRes = GetLastError();
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_ObjPF.WriteMap(m_hFileMap1);

	if (dwRes == ERROR_SUCCESS)
		dwRes = m_BTreePF.WriteMap(m_hFileMap1);

    if ((dwRes == ERROR_SUCCESS) && (FlushFileBuffers(m_hFileMap1) == 0))
    	dwRes = GetLastError();

	DWORD dwNumBytesWritten = 0;
	if (dwRes == ERROR_SUCCESS)
		if (SetFilePointerEx(m_hFileMapVer, pos, 0, FILE_BEGIN) == 0)
			dwRes = GetLastError();
	DWORD dwNextFileMapVer = 1;
	if (dwRes == ERROR_SUCCESS)
		if ((WriteFile(m_hFileMapVer, &dwNextFileMapVer, sizeof(dwNextFileMapVer), &dwNumBytesWritten, NULL) == 0) ||
			dwNumBytesWritten != sizeof(dwNextFileMapVer))
			dwRes = GetLastError();

	if (dwRes == ERROR_SUCCESS)
		if (FlushFileBuffers(m_hFileMapVer) == 0)
			dwRes = GetLastError();


	//close the files
	CloseMapFiles();
	m_hFileMap1 = INVALID_HANDLE_VALUE;
	m_hFileMap2 = INVALID_HANDLE_VALUE;
	if (hFileBtreeMap != INVALID_HANDLE_VALUE)
		CloseHandle(hFileBtreeMap);
	if (hFileObjMap != INVALID_HANDLE_VALUE)
		CloseHandle(hFileObjMap);
	hFileBtreeMap = INVALID_HANDLE_VALUE;
	hFileObjMap = INVALID_HANDLE_VALUE;
	m_ObjPF.DeInit();
	m_BTreePF.DeInit();

	if (dwRes != ERROR_SUCCESS)
	{
		//If we failed, delete the new MAP files to keep things consistent
		DeleteFile(m_FileMap1);
		DeleteFile(m_FileMap2);
		DeleteFile(m_FileMapVer);
	}
	else
	{
		//otherwise delete the new files
		DeleteFile(sBTreeMap);
		DeleteFile(sObjMap);
	}

	//clear all the structures
	return dwRes;
}

DWORD CPageSource::DeleteRepository()
{
	if ((!DeleteFileW(m_FileMainData)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(m_FileMainBtr)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(m_FileMap1)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(m_FileMap2)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(m_FileMapVer)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();

	//Lets also delete the old MAP files too!  Just in case!
    WString sSemaphore;
    WString sBTreeMap;
    WString sBTreeMapNew;
    WString sObjMap;
    WString sObjMapNew;
	try
	{
	    sSemaphore = m_sDirectory;
	    sSemaphore += L"\\ROLL_FORWARD";       

	    sBTreeMap =  m_sDirectory;
	    sBTreeMap += L"\\" ;
	    sBTreeMap += WMIREP_BTREE_MAP;

	    sBTreeMapNew = m_sDirectory;
	    sBTreeMapNew += L"\\";
	    sBTreeMapNew += WMIREP_BTREE_MAP_NEW;

	    sObjMap =  m_sDirectory;
	    sObjMap += L"\\" ;
	    sObjMap += WMIREP_OBJECT_MAP;

	    sObjMapNew = m_sDirectory;
	    sObjMapNew += L"\\";
	    sObjMapNew += WMIREP_OBJECT_MAP_NEW;
	}
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

	if ((!DeleteFileW(sSemaphore)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(sBTreeMap)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(sBTreeMapNew)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(sObjMap)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();
	if ((!DeleteFileW(sObjMapNew)) && (GetLastError() != ERROR_FILE_NOT_FOUND))
		return GetLastError();

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\repositorypackager.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.CPP

Abstract:

    Recursively packages the contents of the repository directory into a single file,
    and unpackages it.

History:

    paulall      07-26-00  Created.
    a-shawnb  07-27-00  Finished.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "RepositoryPackager.h"
#include <arrtempl.h> // for CReleaseMe
#include <algorithm>
#include <functional>
#include <cstring>
#include "a51tools.h"
//#include <autoptr.h>

wchar_t * CRepositoryPackager::backupFiles_[] = {L"$WinMgmt.CFG",L"INDEX.BTR",L"OBJECTS.DATA",L"Mapping1.map",L"Mapping2.map", L"Mapping.Ver"};
wchar_t * CRepositoryPackager::repDirectory_ = L"FS";

int __cdecl _adap_wbem_wcsicmp(const unsigned short * a,const unsigned short * b)
{
    return wbem_wcsicmp(a,b);
}

bool CRepositoryPackager::needBackup(const wchar_t * fileName) const 
{
    const int maxSize = sizeof(backupFiles_)/sizeof(backupFiles_[0]);
    return (std::find_if(&backupFiles_[0], &backupFiles_[maxSize], std::not1(std::bind1st(std::ptr_fun(_adap_wbem_wcsicmp),fileName))) != backupFiles_+maxSize);
};
/******************************************************************************
 *
 *    CRepositoryPackager::PackageRepository
 *
 *    Description:
 *        Iterates deeply through the repository directly and packages it up 
 *        into the given file specified by the given parameter.
 *        Repository directory is the one retrieved from the registry.
 *
 *    Parameters:
 *        wszFilename:    Filename we package everything up into
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageRepository(const wchar_t *wszFilename)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    CFileName  wszRepositoryDirectory;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    int lBackupFileNameLen = 0;
    bool bBackupFileExists = false;
    
    CFileName wszBackupFileName;
    if ((wszBackupFileName == NULL) || (wszRepositoryDirectory == NULL))
        hres = WBEM_E_OUT_OF_MEMORY;

    //Get the root directory of the repository
    if (SUCCEEDED(hres))
        hres = GetRepositoryDirectory(wszRepositoryDirectory);

    //Create a new file to package contents up to...
    if (SUCCEEDED(hres))
    {
        hFile = CreateFileW(wszFilename, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            if ((GetLastError() != ERROR_FILE_EXISTS) && (GetLastError() != ERROR_ALREADY_EXISTS ))
            {
                hres = WBEM_E_INVALID_PARAMETER;
            }
            else
            {
                //We need to back up the existing file in case we fail and need to restore it
                StringCchCopyW(wszBackupFileName, wszBackupFileName.Length(), wszFilename);
                StringCchCatW(wszBackupFileName, wszBackupFileName.Length(), L".");
                lBackupFileNameLen = wcslen(wszBackupFileName);

                for (int i = 0; i != 100; i++)
                {
                    _itow(i, wszBackupFileName+lBackupFileNameLen, 10);
                    if (MoveFileW(wszFilename, wszBackupFileName))
                    {
                        //We
Succeeded!
                        bBackupFileExists = true;

                        //Now we need to open the file again!
                        hFile = CreateFileW(wszFilename, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (hFile == INVALID_HANDLE_VALUE)
                        {
                            hres = WBEM_E_INVALID_PARAMETER;
                        }
                        break;
                    }
                }
                //If we failed with all them we may as well just give up here!
                if (!bBackupFileExists)
                    hres = WBEM_E_INVALID_PARAMETER;
            }
        }
    }

    //Write the package header...
    if (SUCCEEDED(hres))
    {
        hres = PackageHeader(hFile);
    }

    if (SUCCEEDED(hres))
    {
        hres = PackageAllFiles(hFile, wszRepositoryDirectory);
    }

    //Write the end of package marker
    if (SUCCEEDED(hres))
        hres = PackageTrailer(hFile);


    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    //If things failed we should delete the file...
    if (FAILED(hres))
        DeleteFileW(wszFilename);

    //If there is a backup file, rename it back in failure case
    //or delete in other cases
    if (FAILED(hres) && bBackupFileExists && wszBackupFileName)
        MoveFileW(wszBackupFileName, wszFilename);
    else if (bBackupFileExists && wszBackupFileName)
        DeleteFileW(wszBackupFileName);

    return hres;
}


/******************************************************************************
 *
 *    CRepositoryPackager::UnpackageRepository
 *
 *    Description:
 *        Given the filename of a packaged up repository we unpack everything
 *        into the repository directory specified in the registry.  The 
 *        directory should have no files in it before doing this.
 *
 *    Parameters:
 *        wszFilename:    Filename we unpackage everything from
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnpackageRepository(const wchar_t *wszFilename)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    wchar_t wszRepositoryDirectory[MAX_PATH+1];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    //Get the root directory of the repository
    hres = GetRepositoryDirectory(wszRepositoryDirectory);

    //open the file for unpacking...
    if (SUCCEEDED(hres))
    {
        hFile = CreateFileW(wszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            hres = WBEM_E_INVALID_PARAMETER;
    }

    //unpack the package header...
    if (SUCCEEDED(hres))
    {
        hres = UnPackageHeader(hFile);
    }

    //unpack the file...
    if (SUCCEEDED(hres))
    {
        hres = UnPackageContentsOfDirectory(hFile, wszRepositoryDirectory);
    }

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    //If things failed we should delete the partially unpacked repository...
    if (FAILED(hres))
        DeleteRepository();

    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::DeleteRepository
 *
 *    Description:
 *        Delete all files and directories under the repository directory.
 *        The repository directory location is retrieved from the registry.
 *
 *    Parameters:
 *        <none>
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteRepository()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    wchar_t *wszRepositoryOrg = new wchar_t[MAX_PATH+1];
    CVectorDeleteMe<wchar_t> vdm1(wszRepositoryOrg);

    if (!wszRepositoryOrg)
        hr = WBEM_E_OUT_OF_MEMORY;
    
    if (SUCCEEDED(hr))
        hr = GetRepositoryDirectory(wszRepositoryOrg);

    //MOVE EACH OF THE FILES, ONE BY ONE
    for (int i = 0; SUCCEEDED(hr) && (i != 6); i++)
    {
        static wchar_t *filename[] = {L"$WinMgmt.CFG",L"INDEX.BTR",L"OBJECTS.DATA",L"Mapping1.map",L"Mapping2.map", L"Mapping.Ver"};
        CFileName wszDestinationFile;
        if (!wszDestinationFile)
            hr = WBEM_E_OUT_OF_MEMORY;
        else
        {
            StringCchCopyW(wszDestinationFile, wszDestinationFile.Length(), wszRepositoryOrg);

            if (i != 0)
            {
                StringCchCatW(wszDestinationFile, wszDestinationFile.Length(), L"\\fs");
            }
            StringCchCatW(wszDestinationFile, wszDestinationFile.Length(), filename[i]);

            if (!DeleteFileW(wszDestinationFile))
            {
                if ((GetLastError() != ERROR_FILE_NOT_FOUND) && (GetLastError() != ERROR_PATH_NOT_FOUND))
                {
                    hr = WBEM_E_FAILED;

                    break;
                }
            }
        }
    }

    return hr;
}


HRESULT CRepositoryPackager::PackageAllFiles(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
    //
    // internally PackageFile check for existence
    // this is a matter only when $WinMgMt.CFG is packeged, since it cannot be there
    // if PackeageFile is called from within the FindFirst/FindNext loop, then the
    // existence of the file is ensured by the context
    //
    HRESULT hres = PackageFile(hFile, wszRepositoryDirectory, backupFiles_[0]);
    if (FAILED(hres))
        return hres;

    hres = PackageDirectory(hFile, wszRepositoryDirectory, repDirectory_);
    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::PackageContentsOfDirectory
 *
 *    Description:
 *        Given a directory, iterates through all files and directories and
 *        calls into the function to package it into the file specified by the
 *        file handle passed to the method.
 *
 *    Parameters:
 *        hFile:                    Handle to the destination file.
 *        wszRepositoryDirectory:    Directory to process
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
    HRESULT hres  = WBEM_S_NO_ERROR;

    WIN32_FIND_DATAW findFileData;
    HANDLE hff = INVALID_HANDLE_VALUE;

    //create file search pattern...
    CFileName wszSearchPattern;
    if (wszSearchPattern == NULL)
        hres = WBEM_E_OUT_OF_MEMORY;
    else
    {
        StringCchCopyW(wszSearchPattern, wszSearchPattern.Length(), wszRepositoryDirectory);
        StringCchCatW(wszSearchPattern, wszSearchPattern.Length(), L"\\*");
    }

    //Start the file iteration in this directory...
    if (SUCCEEDED(hres))
    {
        hff = FindFirstFileW(wszSearchPattern, &findFileData);
        if (hff == INVALID_HANDLE_VALUE)
        {
            hres = WBEM_E_FAILED;
        }
    }
    
    if (SUCCEEDED(hres))
    {
        do
        {
            //If we have a filename of '.' or '..' we ignore it...
            if ((wcscmp(findFileData.cFileName, L".") == 0) ||
                (wcscmp(findFileData.cFileName, L"..") == 0))
            {
                //Do nothing with these...
            }
            else
            {
                //This is a file, so we need to deal with that...
                hres = PackageFile(hFile, wszRepositoryDirectory, findFileData.cFileName);
                if (FAILED(hres))
                    break;
            }
            
        } while (FindNextFileW(hff, &findFileData));
    }

    if (hff != INVALID_HANDLE_VALUE)
        FindClose(hff);

    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::GetRepositoryDirectory
 *
 *    Description:
 *        Retrieves the location of the repository directory from the registry.
 *
 *    Parameters:
 *        wszRepositoryDirectory:    Array to store location in.
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = (MAX_PATH + 1)*sizeof(wchar_t);
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
    RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

    if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
        return WBEM_E_FAILED;

    return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *    CRepositoryPackager::PackageHeader
 *
 *    Description:
 *        Stores the header package in the given file.  This is a footprint
 *        so we can recognise if this really is one of our files when 
 *        we try to decode it.  Also it allows us to version it.
 *
 *    Parameters:
 *        hFile:    File handle to store header in.
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageHeader(HANDLE hFile)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    PACKAGE_HEADER header;
    StringCchCopyA(header.szSignature, 10, "FS PKG1.1");    //NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

    DWORD dwSize = 0;
    if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
        hres = WBEM_E_FAILED;
    
    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::PackageDirectory
 *
 *    Description:
 *        This is the code which processes a directory.  It stores the namespace
 *        header and footer marker in the file, and also iterates through
 *        all files and directories in that directory.
 *
 *    Parameters:
 *        hFile:                File handle to store directory information in.
 *        wszParentDirectory:    Full path of parent directory
 *        eszSubDirectory:    Name of sub-directory to process
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    {
        PACKAGE_SPACER_NAMESPACE header;
        header.dwSpacerType = PACKAGE_TYPE_NAMESPACE_START;
        StringCchCopyW(header.wszNamespaceName, MAX_PATH+1, wszSubDirectory);
        DWORD dwSize = 0;
        if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
            hres = WBEM_E_FAILED;
    }
    
    //Get full path of new directory...
    CFileName wszFullDirectoryName;
    if (wszFullDirectoryName == NULL) hres = WBEM_E_OUT_OF_MEMORY;
    
    if (SUCCEEDED(hres))
    {
        StringCchCopyW(wszFullDirectoryName, wszFullDirectoryName.Length(), wszParentDirectory);
        StringCchCatW(wszFullDirectoryName, wszFullDirectoryName.Length(), L"\\");
        StringCchCatW(wszFullDirectoryName, wszFullDirectoryName.Length(), wszSubDirectory);
    }

    //Package the contents of that directory...
    if (SUCCEEDED(hres))
    {
        hres = PackageContentsOfDirectory(hFile, wszFullDirectoryName);
    }

    //Now need to write the end of package marker...
    if (SUCCEEDED(hres))
    {
        PACKAGE_SPACER header2;
        header2.dwSpacerType = PACKAGE_TYPE_NAMESPACE_END;
        DWORD dwSize = 0;
        if ((WriteFile(hFile, &header2, sizeof(header2), &dwSize, NULL) == 0) || (dwSize != sizeof(header2)))
            hres = WBEM_E_FAILED;
    }

    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::PackageFile
 *
 *    Description:
 *        This is the code which processes a file.  It stores the file header
 *        and the contents of the file into the destination file whose handle
 *        is passed in.  The file directory and name is passed in.
 *
 *    Parameters:
 *        hFile:                File handle to store directory information in.
 *        wszParentDirectory:    Full path of parent directory
 *        wszFilename:        Name of file to process
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename)
{
    if (needBackup(wszFilename) == false) return WBEM_S_NO_ERROR;
    
    HRESULT hres = WBEM_S_NO_ERROR;

    PACKAGE_SPACER_FILE header;
    header.dwSpacerType = PACKAGE_TYPE_FILE;
    StringCchCopyW(header.wszFileName, MAX_PATH+1, wszFilename);

    WIN32_FILE_ATTRIBUTE_DATA fileAttribs;
    CFileName wszFullFileName;
    if (wszFullFileName == NULL)
        hres = WBEM_E_OUT_OF_MEMORY;

    if (SUCCEEDED(hres))
    {
        StringCchCopyW(wszFullFileName, wszFullFileName.Length(), wszParentDirectory);
        StringCchCatW(wszFullFileName, wszFullFileName.Length(), L"\\");
        StringCchCatW(wszFullFileName, wszFullFileName.Length(), wszFilename);

        if (GetFileAttributesExW(wszFullFileName, GetFileExInfoStandard, &fileAttribs) == 0)
        {
            if (ERROR_FILE_NOT_FOUND == GetLastError())
                return WBEM_S_NO_ERROR;
            else
                hres = WBEM_E_FAILED;
        }
        else
        {
            header.dwFileSize = fileAttribs.nFileSizeLow;
        }
    }

    //Write header...
    if (SUCCEEDED(hres))
    {
        DWORD dwSize = 0;
        if ((WriteFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
            hres = WBEM_E_FAILED;
    }
    
    //Now need to write actual contents of file to current one... but only if the file is not 0 bytes long...
    if (SUCCEEDED(hres) && (header.dwFileSize != 0))
    {
        HANDLE hFromFile = CreateFileW(wszFullFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFromFile == INVALID_HANDLE_VALUE)
            hres = WBEM_E_FAILED;

        BYTE *pFileBlob = NULL;
        if (SUCCEEDED(hres))
        {
            pFileBlob = new BYTE[header.dwFileSize];
            if (pFileBlob == NULL)
                hres = WBEM_E_OUT_OF_MEMORY;
        }

        if (SUCCEEDED(hres))
        {
            DWORD dwSize = 0;
            if ((ReadFile(hFromFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
                hres = WBEM_E_FAILED;
        }

        if (SUCCEEDED(hres))
        {
            DWORD dwSize = 0;
            if ((WriteFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
                hres = WBEM_E_FAILED;
        }

        delete pFileBlob;

        if (hFromFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFromFile);
    }

    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::PackageTrailer
 *
 *    Description:
 *        Writes the end of file marker to the file.
 *
 *    Parameters:
 *        hFile:                File handle to store directory information in.
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageTrailer(HANDLE hFile)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    PACKAGE_SPACER trailer;
    trailer.dwSpacerType = PACKAGE_TYPE_END_OF_FILE;

    DWORD dwSize = 0;
    if ((WriteFile(hFile, &trailer, sizeof(trailer), &dwSize, NULL) == 0) || (dwSize != sizeof(trailer)))
        hres = WBEM_E_FAILED;
    
    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::UnPackageHeader
 *
 *    Description:
 *        Unpacks the header package in the given file.  This allows us to recognise
 *        if this really is one of our files. Also it allows us to version it.
 *
 *    Parameters:
 *        hFile:    File handle to unpack header from.
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageHeader(HANDLE hFile)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    PACKAGE_HEADER header;

    DWORD dwSize = 0;
    if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
    {
        hres = WBEM_E_FAILED;
    }
    else if (strncmp(header.szSignature,"FS PKG1.1", 9) != 0)
    {
        hres = WBEM_E_FAILED;
    }

    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::UnPackageContentsOfDirectory
 *
 *    Description:
 *        Unpack the contents of a namespace/directory.
 *        If a subdirectory is encountered, then it calls UnPackageDirectory to handle it.
 *        If a file is encountered, then it calls UnPackageFile to handle it.
 *        If no errors occur, then it will enventually encounter the end of the namespace,
 *        which will terminate the loop and return control to the calling function.
 *
 *    Parameters:
 *        hFile:                    Handle to the file to unpack from
 *        wszRepositoryDirectory:    Directory to write to.
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    PACKAGE_SPACER header;
    DWORD dwSize;

    while (hres == WBEM_S_NO_ERROR)
    {
        // this loop will be exited when we either
        // - successfully process a complete directory/namespace
        // - encounter an error

        dwSize = 0;
        if ((ReadFile(hFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
        {
            hres = WBEM_E_FAILED;
        }
        else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_START)
        {
            hres = UnPackageDirectory(hFile, wszRepositoryDirectory);
        }
        else if (header.dwSpacerType == PACKAGE_TYPE_NAMESPACE_END)
        {
            // done with this directory   
            break;
        }
        else if (header.dwSpacerType == PACKAGE_TYPE_FILE)
        {
            hres = UnPackageFile(hFile, wszRepositoryDirectory);
        }
        else if (header.dwSpacerType == PACKAGE_TYPE_END_OF_FILE)
        {
            // done unpacking
            break;
        }
        else
        {
            hres = WBEM_E_FAILED;
        }
    }

    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::UnPackageDirectory
 *
 *    Description:
 *        Unpack the start of a namespace, then call UnPackageContentsOfDirectory
 *        to handle everything within it.
 *
 *    Parameters:
 *        hFile:                File handle to unpack directory information from.
 *        wszParentDirectory:    Full path of parent directory
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory)
{    
    PACKAGE_SPACER_NAMESPACE header;

    // read namespace/directory name
    DWORD dwSize = 0;
    DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
    if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
    {
        return WBEM_E_FAILED;
    }

    //Get full path of new directory...
    CFileName wszFullDirectoryName;
    if (NULL == (wchar_t *)wszFullDirectoryName) return WBEM_E_OUT_OF_MEMORY;
    
    StringCchCopyW(wszFullDirectoryName, wszFullDirectoryName.Length(), wszParentDirectory);
    StringCchCatW(wszFullDirectoryName, wszFullDirectoryName.Length(), L"\\");
    StringCchCatW(wszFullDirectoryName, wszFullDirectoryName.Length(), header.wszNamespaceName);

    // create directory
    if (!CreateDirectoryW(wszFullDirectoryName, NULL))
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS) return WBEM_E_FAILED;
    }

    // UnPackage the contents into the new directory...
    return UnPackageContentsOfDirectory(hFile, wszFullDirectoryName);    
}

/******************************************************************************
 *
 *    CRepositoryPackager::UnPackageFile
 *
 *    Description:
 *        Unpack a file.
 *
 *    Parameters:
 *        hFile:                File handle to unpack file information from.
 *        wszParentDirectory:    Full path of parent directory
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    PACKAGE_SPACER_FILE header;

    // read file name and size
    DWORD dwSize = 0;
    DWORD dwSizeToRead = sizeof(header)-sizeof(PACKAGE_SPACER);
    if ((ReadFile(hFile, ((LPBYTE)&header)+sizeof(PACKAGE_SPACER), dwSizeToRead, &dwSize, NULL) == 0) || (dwSize != dwSizeToRead))
    {
        hres = WBEM_E_FAILED;
    }

    //Get full path of new file...
    CFileName wszFullFileName;
    if (NULL == (wchar_t *)wszFullFileName) hres =  WBEM_E_OUT_OF_MEMORY;

    if (SUCCEEDED(hres))
    {
        StringCchCopyW(wszFullFileName, wszFullFileName.Length(), wszParentDirectory);
        StringCchCatW(wszFullFileName, wszFullFileName.Length(), L"\\");
        StringCchCatW(wszFullFileName, wszFullFileName.Length(), header.wszFileName);
    }

    // create the file
    HANDLE hNewFile = INVALID_HANDLE_VALUE;
    if (SUCCEEDED(hres))
    {
        hNewFile = CreateFileW(wszFullFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hNewFile == INVALID_HANDLE_VALUE)
            hres = WBEM_E_FAILED;
    }

    // read file blob and write to file if size is greater than zero
    if (SUCCEEDED(hres))
    {
        if (header.dwFileSize > 0)
        {
            BYTE* pFileBlob = new BYTE[header.dwFileSize];
            if (pFileBlob == NULL)
                hres = WBEM_E_OUT_OF_MEMORY;

            if (SUCCEEDED(hres))
            {
                dwSize = 0;
                if ((ReadFile(hFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
                {
                    hres = WBEM_E_FAILED;
                }
            }

            // write file
            if (SUCCEEDED(hres))
            {
                dwSize = 0;
                if ((WriteFile(hNewFile, pFileBlob, header.dwFileSize, &dwSize, NULL) == 0) || (dwSize != header.dwFileSize))
                    hres = WBEM_E_FAILED;
            }

            if (pFileBlob)
                delete pFileBlob;
        }
    }

    if (hNewFile != INVALID_HANDLE_VALUE)
        CloseHandle(hNewFile);
    
    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::DeleteContentsOfDirectory
 *
 *    Description:
 *        Given a directory, iterates through all files and directories and
 *        calls into the function to delete it.
 *
 *    Parameters:
 *        wszRepositoryDirectory:    Directory to process
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    CFileName wszFullFileName;
    if (wszFullFileName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    WIN32_FIND_DATAW findFileData;
    HANDLE hff = INVALID_HANDLE_VALUE;

    //create file search pattern...
    CFileName wszSearchPattern;
    if (wszSearchPattern == NULL)
        hres = WBEM_E_OUT_OF_MEMORY;
    else
    {
        StringCchCopyW(wszSearchPattern, wszSearchPattern.Length(), wszRepositoryDirectory);
        StringCchCatW(wszSearchPattern, wszSearchPattern.Length(), L"\\*");
    }

    //Start the file iteration in this directory...
    if (SUCCEEDED(hres))
    {
        hff = FindFirstFileW(wszSearchPattern, &findFileData);
        if (hff == INVALID_HANDLE_VALUE)
        {
            hres = WBEM_E_FAILED;
        }
    }
    
    if (SUCCEEDED(hres))
    {
        do
        {
            //If we have a filename of '.' or '..' we ignore it...
            if ((wcscmp(findFileData.cFileName, L".") == 0) ||
                (wcscmp(findFileData.cFileName, L"..") == 0))
            {
                //Do nothing with these...
            }
            else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                //This is a directory, so we need to deal with that...
                hres = PackageDeleteDirectory(wszRepositoryDirectory, findFileData.cFileName);
                if (FAILED(hres))
                    break;
            }
            else
            {
                //This is a file, so we need to deal with that...
                StringCchCopyW(wszFullFileName, wszFullFileName.Length(), wszRepositoryDirectory);
                StringCchCatW(wszFullFileName, wszFullFileName.Length(), L"\\");
                StringCchCatW(wszFullFileName, wszFullFileName.Length(), findFileData.cFileName);
                if (!DeleteFileW(wszFullFileName))
                {
                    hres = WBEM_E_FAILED;
                    break;
                }
            }
            
        } while (FindNextFileW(hff, &findFileData));
    }
    
    if (hff != INVALID_HANDLE_VALUE)
        FindClose(hff);

    return hres;
}

/******************************************************************************
 *
 *    CRepositoryPackager::PackageDeleteDirectory
 *
 *    Description:
 *        This is the code which processes a directory.  It iterates through
 *        all files and directories in that directory.
 *
 *    Parameters:
 *        wszParentDirectory:    Full path of parent directory
 *        eszSubDirectory:    Name of sub-directory to process
 *
 *    Return:
 *        HRESULT:        WBEM_S_NO_ERROR            If successful
 *                        WBEM_E_OUT_OF_MEMORY    If out of memory
 *                        WBEM_E_FAILED            If anything else failed
 *
 ******************************************************************************
 */
HRESULT CRepositoryPackager::PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //Get full path of new directory...
    CFileName wszFullDirectoryName;
    if (wszFullDirectoryName == NULL) return WBEM_E_OUT_OF_MEMORY;    
    
    if (SUCCEEDED(hres))
    {
        StringCchCopyW(wszFullDirectoryName, wszFullDirectoryName.Length(), wszParentDirectory);
        StringCchCatW(wszFullDirectoryName, wszFullDirectoryName.Length(), L"\\");
        StringCchCatW(wszFullDirectoryName, wszFullDirectoryName.Length(), wszSubDirectory);
    }

    //Package the contents of that directory...
    if (SUCCEEDED(hres))
    {
        hres = DeleteContentsOfDirectory(wszFullDirectoryName);
    }

    // now that the directory is empty, remove it
    if (!RemoveDirectoryW(wszFullDirectoryName))
        hres = WBEM_E_FAILED;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\repositorypackager.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RepositoryPackager.h

Abstract:

    Recursively packages the contents of the repository directory into a single file,
	and unpackages it.

History:

    paulall	  07/26/00  Created.
	a-shawnb  07/27/00  Finished.

--*/

#ifndef __REPOSITORYPACKAGER_H_
#define __REPOSITORYPACKAGER_H_

#define PACKAGE_TYPE_NAMESPACE_START	1
#define PACKAGE_TYPE_NAMESPACE_END		2
#define PACKAGE_TYPE_FILE				3
#define PACKAGE_TYPE_END_OF_FILE		4

typedef struct _PACKAGE_HEADER
{
	char szSignature[10];
} PACKAGE_HEADER;

typedef struct _PACKAGE_SPACER
{
	DWORD dwSpacerType;
} PACKAGE_SPACER;

typedef struct _PACKAGER_SPACER_NAMESPACE : _PACKAGE_SPACER
{
	wchar_t wszNamespaceName[MAX_PATH+1];
} PACKAGE_SPACER_NAMESPACE;

typedef struct _PACKAGER_SPACER_FILE : _PACKAGE_SPACER
{
	wchar_t wszFileName[MAX_PATH+1];
	DWORD dwFileSize;
} PACKAGE_SPACER_FILE;

class CRepositoryPackager
{
    static wchar_t * backupFiles_[];
    static wchar_t * repDirectory_;
private:
	bool needBackup(const wchar_t*) const;
	HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
	
	HRESULT PackageHeader(HANDLE hFile);
	HRESULT PackageAllFiles(HANDLE hFile, const wchar_t *wszRepositoryDirectory);	
	HRESULT PackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);
	HRESULT PackageFile(HANDLE hFile, const wchar_t *wszParentDirectory, wchar_t *wszFilename);
	HRESULT PackageTrailer(HANDLE hFile);
	
	HRESULT UnPackageHeader(HANDLE hFile);
	HRESULT UnPackageContentsOfDirectory(HANDLE hFile, const wchar_t *wszRepositoryDirectory);
	HRESULT UnPackageDirectory(HANDLE hFile, const wchar_t *wszParentDirectory);
	HRESULT UnPackageFile(HANDLE hFile, const wchar_t *wszParentDirectory);

	HRESULT DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory);
	HRESULT PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);

public:
	CRepositoryPackager() {}
	~CRepositoryPackager() {}
	
	HRESULT PackageRepository(const wchar_t *wszFilename);
	HRESULT UnpackageRepository(const wchar_t *wszFilename);
	HRESULT DeleteRepository();
};

#endif // __REPOSITORYPACKAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\upgrade.cpp ===
/*++

Copyright (C) 2000-2002 Microsoft Corporation

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <time.h>
#include "a51rep.h"
#include <md5.h>
#include <objpath.h>
#include "a51tools.h"
#include "corex.h"
#include <persistcfg.h>
#include "upgrade.h"


extern DWORD g_dwSecTlsIndex;

//=====================================================================
//
//  CLocalizationUpgrade::CLocalizationUpgrade
//
//  Description: 
// 
//  Parameters:
//      pContol         Life Control
//      pRepository     Pointer to repository pointer
//=====================================================================
CLocalizationUpgrade::CLocalizationUpgrade(CLifeControl* pControl, CRepository * pRepository)
: m_pControl(pControl), m_pRepository(pRepository)
{
}

//=====================================================================
//
//  CLocalizationUpgrade::~CLocalizationUpgrade
//
//  Description: 
//
//  Parameters:
//
//=====================================================================
CLocalizationUpgrade::~CLocalizationUpgrade()
{
}

//=====================================================================
//
//  CLocalizationUpgrade::DoUpgrade
//
//  Description: 
//      Control routing to bootstrap the upgrade process.  If the registry key 
//      already exists then it does nothing.
//
//  Parameters:
//
//=====================================================================
HRESULT CLocalizationUpgrade::DoUpgrade()
{
    HRESULT hRes = 0;

    //Check to make sure we even need to do the upgrade!
    HKEY hKey;
    LONG lRes;
    bool bDoUpgrade = false;
    //Get the current database version
    DWORD dwVal = 0;
    CDbVerRead cfg;
    cfg.TidyUp();
    cfg.ReadDbVer(dwVal);

    if (dwVal != 6)
        return WBEM_NO_ERROR;
    
    try
    {
        hRes = OldHash(L"__namespace", m_namespaceClassHash);
        if (FAILED(hRes))
            return hRes;
        hRes = OldHash(L"", m_emptyClassHash);
        if (FAILED(hRes))
            return hRes;
        hRes = OldHash(A51_SYSTEMCLASS_NS, m_systemNamespaceHash);
        if (FAILED(hRes))
            return hRes;

        //Reset a TLS entry if necessary!  Otherwise we may not find any
        //instances of __thisNamespace!
        LPVOID pOldTlsEntry = NULL;
        if (g_dwSecTlsIndex != -1)
        {
            pOldTlsEntry = TlsGetValue(g_dwSecTlsIndex);
            TlsSetValue(g_dwSecTlsIndex, 0);
        }

        //Set the Class Cache size to 0 bytes so it does not
        //cache anything during this process.  if it did, we
        //would get kind of screwed up really badly!
        g_Glob.m_ForestCache.SetMaxMemory(0, 10000);

        CAutoWriteLock lock(&g_readWriteLock);
        if (lock.Lock())
        {
            lRes = g_Glob.m_FileCache.BeginTransaction();
            if (lRes)
                hRes = A51TranslateErrorCode(lRes);

            if (SUCCEEDED(hRes))
            {
                m_pass = 1;
                DEBUGTRACE((LOG_REPDRV, "============== LOCALE UPGRADE : Enumerate Child Namespaces =============\n"));
                //1 Enumeration all namespaces
                //Deals with class enumeration, and deletion if there is a conflict,
                //and enumerates all the instances in the namespace checking both types
                //of hashes and recording differences
                hRes = EnumerateChildNamespaces(L"root");


                //1 Don't do anything unless we have something to do!
                if (m_keyHash.Size() ||m_pathHash.Size())
                {
                    //1 Process namespace collisions
                    if (SUCCEEDED(hRes))
                    {
                        m_pass = 2;
                        DEBUGTRACE((LOG_REPDRV, "============== LOCALE UPGRADE : Namespace Collision Detection =============\n"));
                        hRes = ProcessNamespaceCollisions();
                    }

                    if (SUCCEEDED(hRes))
                    {
                        m_pass = 3;
                        DEBUGTRACE((LOG_REPDRV, "============== LOCALE UPGRADE: Fixup BTree Changes =============\n"));
                        //1 Phase 3 - fixup changed hashes
                        //Iterate through the entire BTree and fix-up all failures
                        hRes = FixupBTree();
                    }
                }
                else
                {
                    ERRORTRACE((LOG_REPDRV, "============== LOCALE UPGRADE : No Changes Needed! =============\n"));
                }
            }

            if (SUCCEEDED(hRes))
            {
                ERRORTRACE((LOG_REPDRV, "============== LOCALE UPGRADE: Committing Changes =============\n"));
                g_Glob.m_FileCache.CommitTransaction();
            }
            else
            {
                ERRORTRACE((LOG_REPDRV, "============== LOCALE UPGRADE: Rolling back all Changes =============\n"));
                g_Glob.m_FileCache.AbortTransaction();
            }
            //Regardless of the error code, the class cache is probably totally screwed 
            //up, so we need to do dramatic stuff to it!
            //This will also reset the class cache to it's default sizes!
            g_Glob.m_ForestCache.Deinitialize();
            g_Glob.m_ForestCache.Initialize();
        }
        if (g_dwSecTlsIndex != -1)
        {
            TlsSetValue(g_dwSecTlsIndex, pOldTlsEntry);
        }

        if (SUCCEEDED(hRes))
        {
            ERRORTRACE((LOG_REPDRV, "============== LOCALE UPGRADE: Fixup SUCCEEDED =============\n"));
        }
        else
        {
            ERRORTRACE((LOG_REPDRV, "============== LOCALE UPGRADE: Fixup FAILED =============\n"));
        }
    }
    catch (...)
    {
        g_Glob.m_FileCache.AbortTransaction();
        ERRORTRACE((LOG_REPDRV, "============== LOCALE UPGRADE: Something threw an exception =============\n"));
    }


    CPersistentConfig pCfg;
    pCfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, A51_REP_FS_VERSION);


    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::EnumerateChildNamespaces
//
//  Description: 
//      Enumerates all child namespaces of the namespace passed, adds 
//      the namespaces to the m_namespaces structure, and iterates down 
//      into those namespaces
//
//  Parameters:
//      wsRootNamespace     Namespace name to enumerate.  E.G.  root\default
//
//=====================================================================
HRESULT CLocalizationUpgrade::EnumerateChildNamespaces(const wchar_t * wsRootNamespace)
{
    //We know the namespace we need to look under, we know the class key root, so we
    //can enumerate all the instances of that class and do a FileToInstance on them all.  From
    //that we can add the event and the entry to the namespace list, and do the enumeration
    //of child namespaces on them
    LONG lRes = 0;
    HRESULT hRes = 0;
    CFileName wsNamespaceHash;
    if (wsNamespaceHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    wchar_t *wszNewNamespaceHash = new wchar_t[MAX_HASH_LEN+1];
    if (wszNewNamespaceHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm(wszNewNamespaceHash);

    hRes = NewHash(wsRootNamespace, wszNewNamespaceHash);
    if (FAILED(hRes))
        return hRes;

    //Create the hashed path to the Key Root for the namespace
    StringCchCopyW(wsNamespaceHash, MAX_PATH, g_Glob.GetRootDir());
    StringCchCatW(wsNamespaceHash, MAX_PATH, L"\\NS_");
    hRes = OldHash(wsRootNamespace, wsNamespaceHash + g_Glob.GetRootDirLen()+4);
    if (FAILED(hRes))
        return hRes;

    hRes = IndexExists(wsNamespaceHash);
    if (hRes == WBEM_E_NOT_FOUND)
    {
        //Try using NewHash instead!
        hRes = NewHash(wsRootNamespace, wsNamespaceHash + g_Glob.GetRootDirLen()+4);
        if (FAILED(hRes))
            return hRes;

        hRes = IndexExists(wsNamespaceHash);
        if (hRes == WBEM_E_NOT_FOUND)
            return WBEM_NO_ERROR;   //NOthing in this namespace!
        else if (FAILED(hRes))
            return hRes;
    }
    else if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_REPDRV, ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n"));
    DEBUGTRACE((LOG_REPDRV, "Processing namespace: %S, %S\n", wsRootNamespace, wsNamespaceHash+g_Glob.GetRootDirLen()+1));

    //2 Store namespace path for pass 2 of update
    hRes = m_namespaces.AddStrings(wsRootNamespace, wsNamespaceHash);
    if (FAILED(hRes))
        return hRes;

    //2 Create a CNamespaceHandle so we can access objects in this namespace
    CNamespaceHandle *pNs = new CNamespaceHandle(m_pControl, m_pRepository);
    if (pNs == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNamespaceHandle> cdm(pNs);
    hRes = pNs->Initialize2(wsRootNamespace, wsNamespaceHash+g_Glob.GetRootDirLen()+4);
    if (FAILED(hRes))
        return hRes;

    //2  Fixup all the classes in this namespace
    //NOTE: We need to do this BEFORE we process the hash for the namespace
    //because otherwise it will be stored in a different place and so 
    //instance enumeration will fail!
    hRes = ProcessSystemClassesRecursively(pNs, 
                                     wsNamespaceHash+g_Glob.GetRootDirLen()+4, 
                                     m_emptyClassHash);
    if (FAILED(hRes))
        return hRes;
    
    hRes = ProcessClassesRecursively(pNs, 
                                     wsNamespaceHash+g_Glob.GetRootDirLen()+4, 
                                     m_emptyClassHash);
    if (FAILED(hRes))
        return hRes;

    hRes = EnumerateInstances(pNs, wszNewNamespaceHash);
    if (FAILED(hRes))
        return hRes;
    
    StringCchCatW(wsNamespaceHash, MAX_PATH, L"\\" A51_KEYROOTINST_DIR_PREFIX);
    StringCchCatW(wsNamespaceHash, MAX_PATH, m_namespaceClassHash);
    StringCchCatW(wsNamespaceHash, MAX_PATH, L"\\" A51_INSTDEF_FILE_PREFIX);

    //2 Process Hash for this namespace
    bool bDifferent = false;
    hRes = ProcessHash(wsRootNamespace, &bDifferent);
    if (FAILED(hRes))
        return hRes;

    //2 Enumerate all the child namespaces
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.ObjectEnumerationBegin(wsNamespaceHash, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        BYTE *pBlob = NULL;
        DWORD dwSize = 0;
        while(1)
        {
            lRes = g_Glob.m_FileCache.ObjectEnumerationNext(pEnumHandle, wsNamespaceHash, &pBlob, &dwSize);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                lRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
                break;
            
            //Get the instance
            _IWmiObject* pInstance = NULL;
            hRes = pNs->FileToInstance(NULL, wsNamespaceHash, pBlob, dwSize, &pInstance, true);

            //Free the blob
            g_Glob.m_FileCache.ObjectEnumerationFree(pEnumHandle, pBlob);

            if (FAILED(hRes))
                break;
            CReleaseMe rm2(pInstance);


            //Extract the string from the object
            VARIANT vName;
            VariantInit(&vName);
            CClearMe cm(&vName);
            hRes = pInstance->Get(L"Name", 0, &vName, NULL, NULL);
            if(FAILED(hRes))
                break;
            if(V_VT(&vName) != VT_BSTR)
            {
                hRes = WBEM_E_INVALID_OBJECT;
                break;
            }

            //Create the full namespace path
            wchar_t *wszChildNamespacePath = new wchar_t[wcslen(wsRootNamespace)+1+wcslen(V_BSTR(&vName)) + 1];
            if (wszChildNamespacePath == NULL)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            CVectorDeleteMe<wchar_t> vdm(wszChildNamespacePath);
            
            StringCchCopyW(wszChildNamespacePath, MAX_PATH, wsRootNamespace);
            StringCchCatW(wszChildNamespacePath, MAX_PATH, L"\\");
            StringCchCatW(wszChildNamespacePath, MAX_PATH, V_BSTR(&vName));

            //2 Process all child namespaces in this namespace
            hRes = EnumerateChildNamespaces(wszChildNamespacePath);
            if (FAILED(hRes))
                break;
        }

        g_Glob.m_FileCache.ObjectEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
    }

    if (lRes)
        hRes = A51TranslateErrorCode(lRes);

    return hRes;
}

HRESULT CLocalizationUpgrade::ProcessSystemClassesRecursively(CNamespaceHandle *pNs,
                                                              const wchar_t *namespaceHash, 
                                                              const wchar_t *parentClassHash)
{
    HRESULT hRes= 0;
    unsigned long lRes = 0;

    CFileName wszChildClasses;
    if (wszChildClasses == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wchar_t *childClassHash = new wchar_t[MAX_HASH_LEN+1];
    if (childClassHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm(childClassHash);
    
    //Create full class reference path for parent/class relationship
    StringCchCopyW(wszChildClasses, wszChildClasses.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\NS_");
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), m_systemNamespaceHash);
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\CR_");
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), parentClassHash);
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\C_");

    //Enumerate the child classes
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszChildClasses, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, wszChildClasses, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                hRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
            {
                hRes = A51TranslateErrorCode(lRes);
                break;
            }

            //extract the class hash
            StringCchCopyW(childClassHash, MAX_HASH_LEN+1, wszChildClasses + wcslen(wszChildClasses)-32);
            
            //Process user derived classes from this system class
            hRes = ProcessClassesRecursively(pNs, namespaceHash, childClassHash);
            if (FAILED(hRes))
                break;

            //Process other system classes that are derived from this class
            hRes = ProcessSystemClassesRecursively(pNs, namespaceHash, childClassHash);
            if (FAILED(hRes))
                break;
        }
        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
        if (lRes)
            hRes = A51TranslateErrorCode(lRes);
    }

    return hRes;
}
//=====================================================================
//
//  CLocalizationUpgrade::ProcessClassesRecursively
//
//  Description: 
//      Recursively enumerates all the classes from the one specified 
//      and fixes it up as necessary
//
//  Parameters:
//      classIndex     full path to a class definition 
//
//=====================================================================
HRESULT CLocalizationUpgrade::ProcessClassesRecursively(CNamespaceHandle *pNs,
                                                              const wchar_t *namespaceHash, 
                                                              const wchar_t *parentClassHash)
{
    HRESULT hRes= 0;
    unsigned long lRes = 0;

    CFileName wszChildClasses;
    if (wszChildClasses == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wchar_t *childClassHash = new wchar_t[MAX_HASH_LEN+1];
    if (childClassHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<wchar_t> vdm(childClassHash);
    
    //Create full class reference path for parent/class relationship
    StringCchCopyW(wszChildClasses, wszChildClasses.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\NS_");
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), namespaceHash);
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\CR_");
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), parentClassHash);
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\C_");

    //Enumerate the child classes
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszChildClasses, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, wszChildClasses, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                hRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
            {
                hRes = A51TranslateErrorCode(lRes);
                break;
            }

            //extract the class hash
            StringCchCopyW(childClassHash, MAX_HASH_LEN+1, wszChildClasses + wcslen(wszChildClasses)-32);
            
            //Process this class - this class calls back into this class to do the recursion!
            hRes = ProcessClass(pNs, namespaceHash, parentClassHash, childClassHash);
            if (FAILED(hRes))
                break;
        }
        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
        if (lRes)
            hRes = A51TranslateErrorCode(lRes);
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::ProcessClass
//
//  Description: 
//      retrieves the class, calculates new and old class hash, and
//      if they are different fixes up the CD hash, child class hashes
//      and the parent class hash to this one
//
//  Parameters:
//      namespaceHash       namespace hash
//      parentClassHash     parent class hash
//      childClassHash      hash of class to process
//
//=====================================================================
HRESULT CLocalizationUpgrade::ProcessClass(CNamespaceHandle *pNs,
                                              const wchar_t *namespaceHash, 
                                              const wchar_t *parentClassHash,
                                              const wchar_t *childClassHash)
{
    HRESULT hRes = 0;
    
    //Make a class definition string for this class class
    CFileName classDefinition;
    if (classDefinition == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(classDefinition, classDefinition.Length(), g_Glob.GetRootDir());
    StringCchCatW(classDefinition, classDefinition.Length(), L"\\NS_");
    StringCchCatW(classDefinition, classDefinition.Length(), namespaceHash);
    StringCchCatW(classDefinition, classDefinition.Length(), L"\\CD_");
    StringCchCatW(classDefinition, classDefinition.Length(), childClassHash);

    _IWmiObject * pClass = NULL;
    __int64 nTime;
    bool bSystemClass;
    hRes = pNs->FileToClass(classDefinition, &pClass, false, &nTime, &bSystemClass);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe rm(pClass);
    
    //Extract the string from the object
    VARIANT vName;
    VariantInit(&vName);
    CClearMe cm(&vName);
    hRes = pClass->Get(L"__class", 0, &vName, NULL, NULL);
    if(FAILED(hRes))
        return hRes;
    if(V_VT(&vName) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    MoveMemory(classDefinition, classDefinition+g_Glob.GetRootDirLen()+1, (wcslen(classDefinition+g_Glob.GetRootDirLen()+1)+1)*sizeof(wchar_t));

    DEBUGTRACE((LOG_REPDRV, "Processing Class: %S, %S\n", V_BSTR(&vName), classDefinition));
    bool bDifferent = false;
    hRes = ProcessHash(V_BSTR(&vName), &bDifferent);
    if (FAILED(hRes))
        return hRes;

    //Lets check that the hash we just generated was not the same as the one we are using!
    if (bDifferent)
    {
        wchar_t *newClassHash;
        hRes=GetNewHash(childClassHash, &newClassHash);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //There are no differences!
            hRes=WBEM_NO_ERROR;
            bDifferent = false;
        }
    }
    

    if (bDifferent)
    {
        CFileName newIndexEntry;
        if (newIndexEntry == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        
        //We need to fixup this entry
        hRes = FixupIndex(classDefinition, newIndexEntry, bDifferent);
        if (FAILED(hRes))
            return hRes;

        bool bClassDeleted = false;
        if (bDifferent)
        {
            hRes = WriteClassIndex(pNs, classDefinition, newIndexEntry, &bClassDeleted);
            if (FAILED(hRes))
                return hRes;
        }

        //Now we need to fix up parent/class relationships?

        //Finally, process the child classes
        if (!bClassDeleted)
            return ProcessClassesRecursively(pNs, namespaceHash, newIndexEntry+wcslen(newIndexEntry)-32);
        else
            return WBEM_NO_ERROR;
    }
    else
        return ProcessClassesRecursively(pNs, namespaceHash, childClassHash);
    
}
//=====================================================================
//
//  CLocalizationUpgrade::EnumerateInstances
//
//  Description: 
//      Enumerates all instances in a specified namespace
//
//  Parameters:
//      pNs     -   We need to retrieve an instance, so we need a namespace handle to do that
//
//=====================================================================
HRESULT CLocalizationUpgrade::EnumerateInstances(CNamespaceHandle *pNs, const wchar_t *wszNewNamespaceHash)
{
    unsigned long lRes = 0;
    HRESULT hRes = 0;
    CFileName wsInstancePath;
    if (wsInstancePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CFileName wsInstanceShortPath;
    if (wsInstanceShortPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wsInstancePath, wsInstancePath.Length(), pNs->m_wszClassRootDir);
    StringCchCatW(wsInstancePath, wsInstancePath.Length(), L"\\" A51_KEYROOTINST_DIR_PREFIX);

    //Enumerate all the objects
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wsInstancePath, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, wsInstanceShortPath, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                lRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
                break;

            //Need to strip out the .X.Y.Z and make long path version
            wcstok(wsInstanceShortPath, L".");
            StringCchCopyW(wsInstancePath + g_Glob.GetRootDirLen()+1, wsInstancePath.Length() - g_Glob.GetRootDirLen() -1, wsInstanceShortPath);

            //2 check if this is an INSTANCE or a REFERENCE!
            //We are only interested if we are an instance.  Instances are ns_..\KI..\I_..x.y.z
            //Reference is ns_..\KI_..\IR_..\R_..\I_..x.y.z
            //We can validate this by checking for the existance of the _ in the I_ entry!
            //for reference it would be an R from the IR_ entry!
            if ((wcslen(wsInstanceShortPath) > 73) && (wsInstanceShortPath[73] == L'_'))
            {
                //2 Retrieve the object blob
                DWORD dwLen = 0;
                BYTE *pBuffer = NULL;
                lRes = g_Glob.m_FileCache.ReadObject(wsInstancePath, &dwLen, &pBuffer);
                if (lRes)
                {
                    hRes = A51TranslateErrorCode(lRes);
                    break;
                }
                CTempFreeMe tfm(pBuffer, dwLen);

                //2 Extract class hash from blob
                wchar_t *wsOldClassHash = new wchar_t[MAX_HASH_LEN+1];
                wchar_t *wsNewClassHash = NULL;
                if (wsOldClassHash == NULL)
                {
                    hRes = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
                CVectorDeleteMe<wchar_t> vdm(wsOldClassHash);
                StringCchCopyNW(wsOldClassHash, MAX_HASH_LEN+1, (wchar_t*)pBuffer, 32);
                hRes = GetNewHash(wsOldClassHash, &wsNewClassHash);
                if (hRes == WBEM_E_NOT_FOUND)
                    hRes = WBEM_NO_ERROR;
                 else if (FAILED(hRes))
                    break;
                else
                    StringCchCopyW(wsOldClassHash, MAX_HASH_LEN+1, wsNewClassHash);

                //Build up the full class definition fror this class
                CFileName wszClassDefinition;
                if (wszClassDefinition == NULL)
                {
                    hRes = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
                StringCchCopyW(wszClassDefinition, wszClassDefinition.Length(), g_Glob.GetRootDir());
                StringCchCatW(wszClassDefinition, wszClassDefinition.Length(), L"\\");
                StringCchCatNW(wszClassDefinition, wszClassDefinition.Length(), wsInstanceShortPath, 3+32+1);
                StringCchCatW(wszClassDefinition, wszClassDefinition.Length(), L"CD_");
                StringCchCatW(wszClassDefinition, wszClassDefinition.Length(), wsOldClassHash);
                _IWmiObject *pClass = NULL;
                __int64 nTime;
                bool bSystemClass;
                hRes = pNs->FileToClass(wszClassDefinition, &pClass, false, &nTime, &bSystemClass);
                if (FAILED(hRes))
                    break;
                CReleaseMe rm3(pClass);
                    
                //2 Get the instance
                _IWmiObject* pInstance = NULL;
                hRes = pNs->FileToInstance(pClass, wsInstancePath, pBuffer, dwLen, &pInstance, true);
                if (FAILED(hRes))
                    break;
                CReleaseMe rm2(pInstance);

                //2    Get the path
                VARIANT var;
                VariantInit(&var);
                hRes = pInstance->Get(L"__relpath", 0, &var, 0, 0);
                if (FAILED(hRes))
                    break;
                CClearMe cm2(&var);
                dwLen = (wcslen(V_BSTR(&var)) + 1) ;
                wchar_t *strKey = (WCHAR*)TempAlloc(dwLen* sizeof(WCHAR));
                if(strKey == NULL)
                {
                    hRes = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
                CTempFreeMe tfm3(strKey, dwLen* sizeof(WCHAR));

                bool bIsClass;
                LPWSTR __wszClassName = NULL;
                hRes = pNs->ComputeKeyFromPath(V_BSTR(&var), strKey, dwLen, &__wszClassName, &bIsClass);
                if(FAILED(hRes))
                    break;
                DEBUGTRACE((LOG_REPDRV, "Processing Instance Hash: %S='%S', %S\n", __wszClassName, strKey, wsInstanceShortPath));
                TempFree(__wszClassName);
                
                bool bDifferent = false;
                hRes = ProcessHash(strKey, &bDifferent);
                if (FAILED(hRes))
                    break;

                hRes = ProcessFullPath(wsInstancePath, wszNewNamespaceHash);
                if (FAILED(hRes))
                    break;
            }
            else
            {
                DEBUGTRACE((LOG_REPDRV, "Ignoring Instance reference: %S\n", wsInstanceShortPath));
            }

        }

        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
    }

    if (lRes)
        hRes = A51TranslateErrorCode(lRes);

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::ProcessHash
//
//  Description: 
//      Does the actual comparison of old and new hash of the given string.  
//      If different it records it for later use.
//
//  Parameters:
//      wszName     Class name, namespace name, instance key.
//
//=====================================================================
HRESULT CLocalizationUpgrade::ProcessHash(const wchar_t *wszName, bool *pDifferent)
{
    //Hash using old ToUpper method
    //Hash using new ToUpper method
    //If they are not the same add to the m_keyHash structure

    HRESULT hRes = 0;
    wchar_t wszOldHash[MAX_HASH_LEN+1];
    wchar_t wszNewHash[MAX_HASH_LEN+1];
    hRes = OldHash(wszName, wszOldHash);
    if (SUCCEEDED(hRes))
        hRes = NewHash(wszName, wszNewHash);

    if (SUCCEEDED(hRes))
    {
        if (wcscmp(wszOldHash, wszNewHash) != 0)
        {
            DEBUGTRACE((LOG_REPDRV, "Hash difference detected for: %S, %S, %S\n", wszName, wszOldHash, wszNewHash));
            //2 The hashes are different!  We need to process them
            hRes = m_keyHash.AddStrings(wszOldHash, wszNewHash);
            *pDifferent = true;
        }
    }

    return hRes;
}
//=====================================================================
//
//  CLocalizationUpgrade::ProcessFullPath
//
//  Description: 
//      Takes an key root instance path and checks that the full hash using 
//      old and new methods match.  If they are different it records for later 
//      usage
//
//  Parameters:
//      wszOldPath      - Instance string c:\windows\...\NS_<hash>\KI_<hash>\I_hash.X.Y.Z
//
//=====================================================================
HRESULT CLocalizationUpgrade::ProcessFullPath(CFileName &wszOldFullPath, const wchar_t *wszNewNamespaceHash)
{
    //Hash using old ToUpper method
    //Hash using new ToUpper method
    //If they are not the same add to the m_pathHash structure

    HRESULT hRes = 0;
    bool bChanged = false;
    wchar_t wszOldHash[MAX_HASH_LEN+1];
    wchar_t wszNewHash[MAX_HASH_LEN+1];

    CFileName wsOldShortPath;
    CFileName wszNewFullPath;
    CFileName wszNewShortPath;
    if ((wsOldShortPath == NULL) || (wszNewFullPath == NULL) || (wszNewShortPath == NULL))
        return WBEM_E_OUT_OF_MEMORY;

    //Need to fixup the old path with new hashes before we continue!
    //Fixup requires short path to work and we have full path currently!
    StringCchCopyW(wsOldShortPath, wsOldShortPath.Length(), wszOldFullPath+g_Glob.GetRootDirLen()+1);
    hRes = FixupIndex(wsOldShortPath, wszNewShortPath, bChanged);
    if (FAILED(hRes) || !bChanged)
        return hRes;

    //Copy the new namespace hash into the string to be sure!
    wmemcpy(wszNewShortPath+3, wszNewNamespaceHash, 32);

    //Now we need to add the FULL path to the start of each path before we hash it.  Kind 
    //of crazy, but that's the way it was done!
    StringCchCopyW(wszNewFullPath, wszNewFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszNewFullPath, wszNewFullPath.Length(), L"\\");
    StringCchCatW(wszNewFullPath, wszNewFullPath.Length(), wszNewShortPath);

    hRes = OldHash(wszOldFullPath, wszOldHash);
    if (FAILED(hRes))
        return hRes;
    
    hRes = NewHash(wszNewFullPath, wszNewHash);
    if (FAILED(hRes))
        return hRes;

    if (wcscmp(wszOldHash, wszNewHash) != 0)
    {
        //2 The hashes are different!  We need to process them
        DEBUGTRACE((LOG_REPDRV, "Path difference detected for: %S, %S, %S, %S\n", wszOldFullPath, wszNewShortPath, wszOldHash, wszNewHash));
        hRes = m_pathHash.AddStrings(wszOldHash, wszNewHash);
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::OldHash
//
//  Description: 
//      Generates a 32 character hash of the given string.  It does it in 
//      the OLD way which is case screwed up
//
//  Parameters:
//      wszName         Name to hash
//      wszHash         Returns the hash of the name
//
//=====================================================================
static wchar_t g_HexDigit[] = { L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F'};
HRESULT CLocalizationUpgrade::OldHash(const wchar_t *wszName, wchar_t *wszHash)
{
    DWORD dwBufferSize = wcslen(wszName)*2+2;
    LPWSTR wszBuffer = (WCHAR*)TempAlloc(dwBufferSize);
    if (wszBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(wszBuffer, dwBufferSize);

    OldStringToUpper(wszBuffer, wszName);

    BYTE RawHash[16];
    MD5::Transform((void*)wszBuffer, wcslen(wszBuffer)*2, RawHash);

    WCHAR* pwc = wszHash;
    for(int i = 0; i < 16; i++)
    {
        *(pwc++) = g_HexDigit[RawHash[i]/16];
        *(pwc++) = g_HexDigit[RawHash[i]%16];
    }
    *pwc = 0;
    return WBEM_NO_ERROR;
}

//=====================================================================
//
//  CLocalizationUpgrade::NewHash
//
//  Description: 
//      Hashes the given name using the new locale invariant specific 
//      conversion to upper case
//
//  Parameters:
//      wszName     -       Name to hash
//      wszHash     -       Returns hash
//
//=====================================================================
HRESULT CLocalizationUpgrade::NewHash(const wchar_t *wszName, wchar_t *wszHash)
{
    DWORD dwBufferSize = wcslen(wszName)*2+2;
    LPWSTR wszBuffer = (WCHAR*)TempAlloc(dwBufferSize);
    if (wszBuffer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CTempFreeMe vdm(wszBuffer, dwBufferSize);

    NewStringToUpper(wszBuffer, wszName);

    BYTE RawHash[16];
    MD5::Transform((void*)wszBuffer, wcslen(wszBuffer)*2, RawHash);

    WCHAR* pwc = wszHash;
    for(int i = 0; i < 16; i++)
    {
        *(pwc++) = g_HexDigit[RawHash[i]/16];
        *(pwc++) = g_HexDigit[RawHash[i]%16];
    }
    *pwc = 0;
    return WBEM_NO_ERROR;
}


//=====================================================================
//
//  CLocalizationUpgrade::FixupBTree
//
//  Description: 
//      Method that bootstraps the fixup of the BTree by iterating through 
//      all namespaces
//
//  Parameters:
//
//=====================================================================
HRESULT CLocalizationUpgrade::FixupBTree()
{
    HRESULT hRes = NO_ERROR;
    //Lets iterate through the namespace list and iterate through everything in that namespace
    //fixing things up and fixing things as we go
    for (unsigned int i = 0; i != m_namespaces.Size(); i++)
    {
        hRes = FixupNamespace(m_namespaces[i]->m_wsz2);
        if (FAILED(hRes))
            break;
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::FixupNamespace
//
//  Description: 
//      Enumerates all items within the namespace, andcalls into method to 
//      do all the work
//
//  Parameters:
//      wszNamespace    -   in the format of a FULL namespace path... c:\windows\...\NS_<hash>
//
//=====================================================================
HRESULT CLocalizationUpgrade::FixupNamespace(const wchar_t *wszNamespace)
{
    HRESULT hRes = NO_ERROR;
    long lRes = NO_ERROR;
    CFileName indexEntry;
    if (indexEntry == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CFileName newEntry;
    if (newEntry == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    bool bChanged = false;

    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszNamespace, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, indexEntry, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                lRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
                break;

            bChanged = false;
            hRes = FixupIndex(indexEntry, newEntry, bChanged);
            if (FAILED(hRes))
                break;

            if (bChanged)
            {
                hRes = WriteIndex(indexEntry, newEntry);
                if (FAILED(hRes))
                    break;
            }

            if (IsInstanceReference(newEntry))
            {
                hRes = FixupIndexReferenceBlob(newEntry);
                if (FAILED(hRes))
                    break;
            }

            if (IsKeyRootInstancePath(newEntry))
            {
                hRes = FixupInstanceBlob(newEntry);
                if (FAILED(hRes))
                    break;
            }
        }
        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
    }

    if (lRes)
        hRes = A51TranslateErrorCode(lRes);

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::FixupIndex
//
//  Description: 
//      Fixes up the entry with all the new hashes we detected and returns the new entry
//
//  Parameters:
//      oldIndexEntry       -       Entry to fix up, in format of NS_<hash>\....
//      newIndexEntry       -       oldIndexEntry with all hashes substituted to new entries
//      bChanged            -       Returns a flag to say if it was changed
//
//=====================================================================
HRESULT CLocalizationUpgrade::FixupIndex(CFileName &oldIndexEntry, CFileName &newIndexEntry, bool &bChanged)
{
    //Need to check each hash to see if it has a problem.  To do this we can search for each '_'
    //character and check the hash after that entry.  If we see a match, we need to correct it.
    //Any changes we detect need to be written back, then we need to delete the main entry.
    //If we write it back, we need to check an entry doesn't already exist because if it does we 
    //need to discard this entry, and if we have an associated object we need to delete it, then log 
    //an event log entry to describe what we did!

    CFileName scratchIndex;
    if (scratchIndex == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(scratchIndex, scratchIndex.Length(), oldIndexEntry);

    StringCchCopyW(newIndexEntry, newIndexEntry.Length(), oldIndexEntry);

    wchar_t *wszSection = wcstok(scratchIndex, L"_");;
    wchar_t *wszHash = wcstok(NULL, L"\\.");
    wchar_t *pNewHash = NULL;
    bool bInstanceReferenceDetected = false;
    bool bUsePathHash = false;
    HRESULT hRes = 0;

    while (wszHash != NULL)
    {
        if (!bInstanceReferenceDetected)
        {
            if (wcsncmp(wszSection, A51_INSTREF_DIR_PREFIX, 2) == 0)
            {
                bInstanceReferenceDetected = true;
            }
        }
        else if (bInstanceReferenceDetected && (wszSection != NULL))
        {
            if (wcsncmp(wszSection, A51_REF_FILE_PREFIX, 1) == 0)
            {
                bUsePathHash = true;
            }
        }

        //Now the wszCursor points to just the hash, so we can check the hash out!
        if (bUsePathHash)
        {
            hRes = GetNewPath(wszHash, &pNewHash);
            bUsePathHash = false;
        }
        else
        {
            hRes = GetNewHash(wszHash, &pNewHash);
        }
        if (hRes == WBEM_NO_ERROR)
        {
            if ((m_pass != 3) && (wcsncmp(wszSection, L"NS_", 3) == 0))
            {
                //Do nothing!
            }
            else
            {
                //We have a difference
                bChanged = true;
                wmemcpy(((wchar_t*)newIndexEntry)+(wszHash-((wchar_t*)scratchIndex)), pNewHash, MAX_HASH_LEN);
            }
        }
        else if (hRes == WBEM_E_NOT_FOUND)
            hRes = WBEM_NO_ERROR;
        
        //Search for next extry
        wszSection = wcstok(NULL, L"_");
        if (wszSection)
            wszHash = wcstok(NULL, L"\\.");
        else
            wszHash = NULL;
    }

    if (bChanged)
    {
        DEBUGTRACE((LOG_REPDRV, "Fixed up index: %S, %S\n", (const wchar_t *)oldIndexEntry, (const wchar_t *)newIndexEntry));
    }
    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::GetNewHash
//
//  Description: 
//      Given an old hash, returns a new hash if one exists, otherwise WBEM_E_NOT_FOUND
//
//  Parameters:
//      wszOldHash  -  Old hash string to search for - 32 character string
//      pNewHash    -  pointer to a 32-character string of new entry if one exists, NULL otherwise
//
//  Return Code
//      WBEM_E_NOT_FOUND if a HASH is not found
//
//=====================================================================
HRESULT CLocalizationUpgrade::GetNewHash(const wchar_t *wszOldHash, wchar_t **pNewHash)
{
    return m_keyHash.FindStrings(wszOldHash, pNewHash);
}

//=====================================================================
//
//  CLocalizationUpgrade::GetNewPath
//
//  Description: 
//      Given an old hash, returns a new hash if one exists, otherwise WBEM_E_NOT_FOUND
//
//  Parameters:
//      wszOldHash      -  Old hash string to search for - 32 character string
//      pNewHash        -  pointer to a 32-character string of new entry if one exists, NULL otherwise
//
//  Return Code
//      WBEM_E_NOT_FOUND if a HASH is not found
//
//=====================================================================
HRESULT CLocalizationUpgrade::GetNewPath(const wchar_t *wszOldHash, wchar_t **pNewHash)
{
    return m_pathHash.FindStrings(wszOldHash, pNewHash);
}

//=====================================================================
//
//  CLocalizationUpgrade::WriteIndex
//
//  Description: 
//      Checks if the new index exists.  If not writes the new entry and deletes the old one.  If the link points to an
//      object then it deletes that, unless this is the instance class link object link.
//      If there is a conflict calls into the method to deal with that.  
//
//  Parameters:
//      wszOldIndex         -       old path of format NS_<hash>\...
//      wszNewIndex         -       new path of format NS_<hash>\...
//
//=====================================================================
HRESULT CLocalizationUpgrade::WriteIndex(CFileName &wszOldIndex, const wchar_t *wszNewIndex)
{
    //We need to determine if we have a collision before we write the index.  Therefore we
    //need to strip off the X.Y.Z entry if it exists and retrieve it.  If it exists then we have 
    //to delete our index and delete the associated object
    CFileName wszScratchIndex;
    if (wszScratchIndex == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszScratchIndex, wszScratchIndex.Length(), wszNewIndex);
    
    wchar_t *wszObjectLocation = NULL;
    if (wcstok(wszScratchIndex, L".") != NULL)
        wszObjectLocation = wcstok(NULL, L"");

    CFileName wszFullPath;
    if (wszFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
    StringCchCatW(wszFullPath, wszFullPath.Length(), wszScratchIndex);

    HRESULT hRes = IndexExists(wszFullPath);
    if (hRes == WBEM_NO_ERROR)
    {
        //2 We have a conflict, therefore we need to delete the OLD entry!
        long lRes = 0;
        DEBUGTRACE((LOG_REPDRV, "Index Collision detected: %S\n", (const wchar_t *)wszOldIndex));
        hRes = FixupIndexConflict(wszOldIndex);
    }
    else if (hRes == WBEM_E_NOT_FOUND)
    {
        hRes = WBEM_NO_ERROR;
        //2 Write the new index
        if (wszObjectLocation)
        {
            //Put the .X.Y.Z on the end!
            StringCchCatW(wszFullPath, wszFullPath.Length(), L".");
            StringCchCatW(wszFullPath, wszFullPath.Length(), wszObjectLocation);
        }
        long lRes = g_Glob.m_FileCache.WriteLink(wszFullPath);
        if(lRes != ERROR_SUCCESS)
            hRes = A51TranslateErrorCode(lRes);
        else
        {
            //2 Delete the old link
            //strip off .X.Y.Z off old entry
            StringCchCopyW(wszScratchIndex, wszScratchIndex.Length(), wszOldIndex);
            wcstok(wszScratchIndex, L".");
            //Build path
            StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
            StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
            StringCchCatW(wszFullPath, wszFullPath.Length(), wszScratchIndex);
            //Do delete
            lRes = g_Glob.m_FileCache.DeleteLink(wszFullPath);
            if(lRes != ERROR_SUCCESS)
                hRes = A51TranslateErrorCode(lRes);
        }
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::WriteClassIndex
//
//  Description: 
//      Checks if the new index exists.  If not writes the new entry and deletes the old one.  If the link points to an
//      object then it deletes that, unless this is the instance class link object link.
//      If there is a conflict calls into the method to deal with that.  
//
//  Parameters:
//      wszOldIndex         -       old path of format NS_<hash>\...
//      wszNewIndex         -       new path of format NS_<hash>\...
//
//=====================================================================
HRESULT CLocalizationUpgrade::WriteClassIndex(CNamespaceHandle *pNs, CFileName &wszOldIndex, const wchar_t *wszNewIndex, bool *pClassDeleted)
{
    //We need to re-read the old index because we don't have the .X.Y.X on the end.
    HRESULT hRes = g_Glob.m_FileCache.ReadNextIndex(wszOldIndex, wszOldIndex);
    if (FAILED(hRes))
        return hRes;

    //Save off and remove the .X.Y.Z
    wchar_t *wszObjectLocation = NULL;
    if (wcstok(wszOldIndex, L".") != NULL)
        wszObjectLocation = wcstok(NULL, L"");
    
    //We need to determine if we have a collision before we write the index.  
    //If it exists then we have 
    //to delete our index and delete the associated object
    
    CFileName wszFullPath;
    if (wszFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
    StringCchCatW(wszFullPath, wszFullPath.Length(), wszNewIndex);

    hRes = IndexExists(wszFullPath);
    if (hRes == WBEM_NO_ERROR)
    {
        //2 We have a conflict, therefore we need to delete the old class!
        DEBUGTRACE((LOG_REPDRV, "Class Index Collision detected: %S\n", (const wchar_t *)wszOldIndex));
        *pClassDeleted = true;
        hRes = DeleteClass(pNs, wszOldIndex);
    }
    else if (hRes == WBEM_E_NOT_FOUND)
    {
        hRes = WBEM_NO_ERROR;
        //2 Write the new index
        if (wszObjectLocation)
        {
            //Put the .X.Y.Z on the end!
            StringCchCatW(wszFullPath, wszFullPath.Length(), L".");
            StringCchCatW(wszFullPath, wszFullPath.Length(), wszObjectLocation);
        }
        long lRes = g_Glob.m_FileCache.WriteLink(wszFullPath);
        if(lRes != ERROR_SUCCESS)
            hRes = A51TranslateErrorCode(lRes);
        else
        {
            //2 Delete the old link
            //Build path
            StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
            StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
            StringCchCatW(wszFullPath, wszFullPath.Length(), wszOldIndex);
            //Do delete
            lRes = g_Glob.m_FileCache.DeleteLink(wszFullPath);
            if(lRes != ERROR_SUCCESS)
                hRes = A51TranslateErrorCode(lRes);
        }
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::IndexExists
//
//  Description: 
//      Checks to see if a specific index exists.  Returns WBEM_E_NOT_FOUND if not, or WBEM_NO_ERROR if it 
//      does.
//
//  Parameters:
//      wszIndex        -       full path of index to find - c:\windows\...\ns_<>\....
// 
//  Returns:
//      WBEM_E_NOT_FOUND if index does not exist
//      WBEM_NO_ERROR if it exists.
//
//=====================================================================
HRESULT CLocalizationUpgrade::IndexExists(const wchar_t *wszIndex)
{
    HRESULT hRes = NO_ERROR;
    long lRes = NO_ERROR;
    CFileName indexEntry;
    if (indexEntry == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszIndex, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, indexEntry, true);

        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }

    if (lRes)
        hRes = A51TranslateErrorCode(lRes);

    //make sure index we retrieved was from this index
    if (SUCCEEDED(hRes))
        if (wcsncmp(wszIndex+g_Glob.GetRootDirLen()+1, indexEntry, wcslen(wszIndex+g_Glob.GetRootDirLen()+1)) != 0)
            hRes = WBEM_E_NOT_FOUND;

    return hRes;
}


//=====================================================================
//
//  CLocalizationUpgrade::ProcessNamespaceCollisions
//
//  Description: 
//      Searches through the namespace list for collisions.  If one exists then we delete the namespace
//      recursively
//
//  Parameters:
//
//=====================================================================
HRESULT CLocalizationUpgrade::ProcessNamespaceCollisions()
{
    HRESULT hRes = NO_ERROR;
    wchar_t thisNamespace[MAX_HASH_LEN+1];
    wchar_t thatNamespace[MAX_HASH_LEN+1];
    bool bDeletedSomething = false;
    //Lets iterate through the namespace list and calculate the hash.
    //Then we will itterate through the rest of the namespace list and check the
    //hash with that one.  If we have a collision, we need to delete it!
    do
    {
        bDeletedSomething = false;
        for (int i = 0; i != m_namespaces.Size(); i++)
        {
            //Hash this entry
            hRes = NewHash(m_namespaces[i]->m_wsz1, thisNamespace);
            if (FAILED(hRes))
                break;
                
            for (int j = (i+1); j < m_namespaces.Size(); j++)
            {
                //Hash this entry
                hRes = NewHash(m_namespaces[j]->m_wsz1, thatNamespace);
                if (FAILED(hRes))
                    break;

                //If they are the same we need to delete this one
                if (wcscmp(thisNamespace, thatNamespace) == 0)
                {
                    //OK, so we have a collision! Lets deal with it!
                    hRes = DeleteNamespaceRecursive(m_namespaces[i]->m_wsz1);
                    if (FAILED(hRes))
                        break;

                    //We need to start again with the iteration as we may have deleted several entries
                    //from the array at this point
                    bDeletedSomething = true;

                    break;
                }
            }
            if (FAILED(hRes) || bDeletedSomething)
                break;
        }
    } while (SUCCEEDED(hRes) && bDeletedSomething);

    return hRes;
}


//=====================================================================
//
//  CLocalizationUpgrade::DeleteNamespaceRecursive
//
//  Description: 
//      Searches through the namespace list for any which start with the one we passed in.  Any matches are 
//      deleted
//
//  Parameters:
//      wszNamespace    -   namespace name in the format like root\default
//
//=====================================================================
HRESULT CLocalizationUpgrade::DeleteNamespaceRecursive(const wchar_t *wszNamespace)
{
    LONG lRes = 0;
    HRESULT hRes = NO_ERROR;
    wchar_t *wszNamespaceHash = new wchar_t[MAX_HASH_LEN+1];
    if (wszNamespaceHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    hRes = OldHash(wszNamespace, wszNamespaceHash);
    if (FAILED(hRes))
        return hRes;

    CFileName wszNamespacePath;
    if (wszNamespacePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //Create the hashed path to the Key Root for the namespace
    StringCchCopyW(wszNamespacePath, MAX_PATH, g_Glob.GetRootDir());
    StringCchCatW(wszNamespacePath, MAX_PATH, L"\\NS_");
    StringCchCatW(wszNamespacePath, MAX_PATH, wszNamespaceHash);

    DEBUGTRACE((LOG_REPDRV, "Deleting namespace (recursive): %S, %S\n", wszNamespace, wszNamespacePath+g_Glob.GetRootDirLen()+1));

    //2 Create a CNamespaceHandle so we can access objects in this namespace
    CNamespaceHandle *pNs = new CNamespaceHandle(m_pControl, m_pRepository);
    if (pNs == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNamespaceHandle> cdm(pNs);
    hRes = pNs->Initialize2(wszNamespace, wszNamespaceHash);
    if (FAILED(hRes))
        return hRes;

    StringCchCatW(wszNamespacePath, MAX_PATH, L"\\" A51_KEYROOTINST_DIR_PREFIX);
    StringCchCatW(wszNamespacePath, MAX_PATH, m_namespaceClassHash);
    StringCchCatW(wszNamespacePath, MAX_PATH, L"\\" A51_INSTDEF_FILE_PREFIX);

    //2 Enumerate all the child namespaces
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.ObjectEnumerationBegin(wszNamespacePath, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        BYTE *pBlob = NULL;
        DWORD dwSize = 0;
        while(1)
        {
            lRes = g_Glob.m_FileCache.ObjectEnumerationNext(pEnumHandle, wszNamespacePath, &pBlob, &dwSize);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                lRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
                break;
            
            //Get the instance
            _IWmiObject* pInstance = NULL;
            hRes = pNs->FileToInstance(NULL, wszNamespacePath, pBlob, dwSize, &pInstance, true);

            //Free the blob
            g_Glob.m_FileCache.ObjectEnumerationFree(pEnumHandle, pBlob);

            if (FAILED(hRes))
                break;
            CReleaseMe rm2(pInstance);

            //Extract the string from the object
            VARIANT vName;
            VariantInit(&vName);
            CClearMe cm(&vName);
            hRes = pInstance->Get(L"Name", 0, &vName, NULL, NULL);
            if(FAILED(hRes))
                break;
            if(V_VT(&vName) != VT_BSTR)
            {
                hRes = WBEM_E_INVALID_OBJECT;
                break;
            }

            //Create the full namespace path
            wchar_t *wszChildNamespacePath = new wchar_t[wcslen(wszNamespace)+1+wcslen(V_BSTR(&vName)) + 1];
            if (wszChildNamespacePath == NULL)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
                break;
            }
            CVectorDeleteMe<wchar_t> vdm(wszChildNamespacePath);
            
            StringCchCopyW(wszChildNamespacePath, MAX_PATH, wszNamespace);
            StringCchCatW(wszChildNamespacePath, MAX_PATH, L"\\");
            StringCchCatW(wszChildNamespacePath, MAX_PATH, V_BSTR(&vName));

            //2 Process all child namespaces in this namespace
            hRes = DeleteNamespaceRecursive(wszChildNamespacePath);
            if (FAILED(hRes))
                break;
        }

        g_Glob.m_FileCache.ObjectEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
    }

    if (lRes)
        hRes = A51TranslateErrorCode(lRes);

    if (SUCCEEDED(hRes))
    {
        StringCchCopyW(wszNamespacePath, MAX_PATH, g_Glob.GetRootDir());
        StringCchCatW(wszNamespacePath, MAX_PATH, L"\\NS_");
        StringCchCatW(wszNamespacePath, MAX_PATH, wszNamespaceHash);
        hRes = DeleteNamespace(wszNamespace, wszNamespacePath);
    }

    //2 Remote namespace path 
    if (SUCCEEDED(hRes))
    {
        hRes = m_namespaces.RemoveString(wszNamespace);

        //Small chance that we get NOT_FOUND if we have not done full enumeration yet!
        if (hRes == WBEM_E_NOT_FOUND)
            hRes = WBEM_NO_ERROR;
    }
    
    return hRes;
}
//=====================================================================
//
//  CLocalizationUpgrade::DeleteNamespace
//
//  Description: 
//      Deletes the specified namespace using the DeleteNode, then goes into the parent namespace and deletes
//      the instance from that namespace
//
//  Parameters:
//      wszNamespaceName        -       namespace name in format root\default
//      wszNamespaceHash        -       Full namespace hash in format c:\windows\...\NS_<hash>
//
//=====================================================================
HRESULT CLocalizationUpgrade::DeleteNamespace(const wchar_t *wszNamespaceName,const wchar_t *wszNamespaceHash)
{
    HRESULT hRes = NO_ERROR;
    LONG lRes = NO_ERROR;

    DEBUGTRACE((LOG_REPDRV, "Deleting namespace: %S, %S\n", wszNamespaceName, wszNamespaceHash+g_Glob.GetRootDirLen()+1));

    //2 Delete the actual namespace contents
    lRes = g_Glob.m_FileCache.DeleteNode(wszNamespaceHash);
    if (lRes != 0)
        return A51TranslateErrorCode(lRes);

    //2 Calculate parent namespace name
    wchar_t *wszParentNamespaceName = new wchar_t[wcslen(wszNamespaceName)+1];
    wchar_t *wszThisNamespaceName = NULL;
    if (wszParentNamespaceName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszParentNamespaceName, wcslen(wszNamespaceName)+1, wszNamespaceName);

    for (int i = wcslen(wszParentNamespaceName) - 1; i != 0; i--)
    {
        if (wszParentNamespaceName[i] == L'\\')
        {
            wszParentNamespaceName[i] = L'\0';
            wszThisNamespaceName = wszParentNamespaceName+i+1;
            break;
        }
    }

    //2 Calculate parent namespace hash
    wchar_t wszParentNamespaceHash[MAX_HASH_LEN+1];
    hRes = OldHash(wszParentNamespaceName, wszParentNamespaceHash);
    if (FAILED(hRes))
        return hRes;

    //2Calculate this namespaces hash
    wchar_t wszThisNamespaceHash[MAX_HASH_LEN+1];
    hRes = OldHash(wszThisNamespaceName, wszThisNamespaceHash);
    if (FAILED(hRes))
        return hRes;

    //2 Calculate __namespace class hash
    wchar_t wszNamespaceClassHash[MAX_HASH_LEN+1];
    hRes = OldHash(L"__namespace", wszNamespaceClassHash);
    if (FAILED(hRes))
        return hRes;

    CFileName wszKI;
    CFileName wszCI;
    if ((wszKI == NULL) || (wszCI == NULL))
        return WBEM_E_OUT_OF_MEMORY;

    //2 Build KI instance path
    StringCchCopyW(wszKI,wszKI.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszKI, wszKI.Length(), L"\\NS_");
    StringCchCatW(wszKI, wszKI.Length(), wszParentNamespaceHash);

    StringCchCopyW(wszCI, wszCI.Length(), wszKI);

    StringCchCatW(wszKI, wszKI.Length(), L"\\KI_");
    StringCchCatW(wszKI, wszKI.Length(), wszNamespaceClassHash);
    StringCchCatW(wszKI, wszKI.Length(), L"\\I_");
    StringCchCatW(wszKI, wszKI.Length(), wszThisNamespaceHash);

    //2 Retrieve instance blob so we can get the class hash for this instance
    wchar_t wszClassHash[MAX_HASH_LEN+1];
    BYTE *pBuffer = NULL;
    DWORD dwLen = 0;
    lRes = g_Glob.m_FileCache.ReadObject(wszKI, &dwLen, &pBuffer, false);
    if (lRes)
    {
        //If this object does not exist, then we have probably already deleted the parent namespace!
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = 0;
        return A51TranslateErrorCode(lRes);
    }
    StringCchCopyNW(wszClassHash, MAX_HASH_LEN+1, (wchar_t*)pBuffer, MAX_HASH_LEN);
    TempFree(pBuffer, dwLen);

    //2 Build the CI instance path
    StringCchCatW(wszCI, wszCI.Length(), L"\\CI_");
    StringCchCatW(wszCI, wszCI.Length(), wszClassHash);
    StringCchCatW(wszCI, wszCI.Length(), L"\\IL_");
    StringCchCatW(wszCI, wszCI.Length(), wszThisNamespaceHash);

    //2 Delete the KI link and object
    lRes = g_Glob.m_FileCache.DeleteObject(wszKI);
    if (lRes)
        return A51TranslateErrorCode(lRes);

    //2Delete the CI link only
    lRes = g_Glob.m_FileCache.DeleteLink(wszCI);
    if (lRes)
        return A51TranslateErrorCode(lRes);

    //OK, now, in theory, we should really, if we were really good citizens, delete any references that could be in this object!
    //However nothing too bad will happen if we don't, so we won't!

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::FixupIndexConflict
//
//  Description: 
//      Method is called if the old and new index exists.  If the link is for a class definition, we have a lot more
//      work to do, so call into the handling method.  Otherwise we just delete the old index, and object
//      if it exists. If it is a KI_ index then we do not delete the object because the CI index entry will
//      delete it instead
//
//  Parameters:
//      wszOldIndex     --  Index to update in format NS_<hash>\KI_<>\I_<>.X.Y.Z. It must have the 
//                                  X.Y.Z entry if one exists
//
//=====================================================================
HRESULT CLocalizationUpgrade::FixupIndexConflict(CFileName &wszOldIndex)
{
    //If it is a class definition, we have a lot of work to do as we need to delete the class, all sub-classes, and all instances.
    //If the class is derived from __namespace then we need to delete the namespace recursively as well

    if (IsClassDefinitionPath(wszOldIndex))
    {
        DEBUGTRACE((LOG_REPDRV, "TRYING TO FIX UP A CLASS IN THE WRONG PLACE\n"));
        _ASSERT(1, L"TRYING TO FIX UP A CLASS IN THE WRONG PLACE");
        return WBEM_E_FAILED;
    }
    else
    {
        LONG lRes = 0;
        //This is the simple case, we just have to delete the old link or object
        CFileName wszFullPath;
        if (wszFullPath == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
        StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
        StringCchCatW(wszFullPath, wszFullPath.Length(), wszOldIndex);

        //Strip off the .X.Y.Z entry if it exists
        wchar_t *wszObjectLocation = wcstok(wszFullPath+g_Glob.GetRootDirLen()+1, L".");
        if (wszObjectLocation)
            wszObjectLocation = wcstok(NULL, L"");
        
        if (wszObjectLocation && !IsKeyRootInstancePath(wszOldIndex))
            lRes = g_Glob.m_FileCache.DeleteObject(wszFullPath);
        else
            lRes = g_Glob.m_FileCache.DeleteLink(wszFullPath);

        return A51TranslateErrorCode(lRes);
    }
}

//=====================================================================
//
//  CLocalizationUpgrade::IsClassDefinitionPath
//
//  Description: 
//      Checks the link to see if this is a class definition or not
//
//  Parameters:
//      wszPath         -       link in the format NS_<>\CD_<>, or something else
//
//  Returns:
//      true        -   link is a class definition
//      false       -   is not one
//
//=====================================================================
bool CLocalizationUpgrade::IsClassDefinitionPath(const wchar_t *wszPath)
{
    WCHAR* pDot = wcschr(wszPath, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;

    if ((*pDot == L'C') && (*(pDot+1) == L'D')&& (*(pDot+2) == L'_'))
        return true;
    else
        return false;
}
//=====================================================================
//
//  CLocalizationUpgrade::IsKeyRootInstancePath
//
//  Description: 
//      Returns if this is a key root instance entry
//
//  Parameters:
//      wszPath     -       index in format NS_<>\KI_<>\I_, or somthing like that
//
//  Returns:
//      true        -       if this is a KI_<>\I_<> entry
//      false       -       otherwise
//
//=====================================================================
bool CLocalizationUpgrade::IsKeyRootInstancePath(const wchar_t *wszPath)
{
    WCHAR* pDot = wcschr(wszPath, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;

    pDot = wcschr(pDot, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;

    if ((*pDot == L'I') && (*(pDot+1) == L'_'))
        return true;
    else
        return false;
}

//=====================================================================
//
//  CLocalizationUpgrade::IsInstanceReference
//
//  Description: 
//      Returns if this is a instance reference entry
//
//  Parameters:
//      wszPath     -       index in format NS_<>\KI_<>\IR_<>\R, or somthing like that
//
//  Returns:
//      true        -       if this is a NS_<>\KI_<>\IR_<>\R entry
//      false       -       otherwise
//
//=====================================================================
bool CLocalizationUpgrade::IsInstanceReference(const wchar_t *wszPath)
{
    WCHAR* pDot = wcschr(wszPath, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;

    pDot = wcschr(pDot, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;

    pDot = wcschr(pDot, L'\\');
    if(pDot == NULL)
        return false;

    pDot++;
    
    if ((*pDot == L'R') && (*(pDot+1) == L'_'))
        return true;
    else
        return false;
}


//=====================================================================
//
//  CLocalizationUpgrade::DeleteClass
//
//  Description: 
//      Recursively deletes the class definition, sub-classes and instances.  If the instance is 
//      a namespace then we need to delete that also
//
//  Parameters:
//      wszClassDefinitionPath - short path of class definition (ns_...\CD_....X.Y.Z.  XYZ is optional!  We kill it!
//
//=====================================================================
HRESULT CLocalizationUpgrade::DeleteClass(CNamespaceHandle *pNs, CFileName &wszClassDefinitionPath)
{
    HRESULT hRes =0;
    LONG lRes = 0;

    DEBUGTRACE((LOG_REPDRV, "Deleting Class: %S\n", wszClassDefinitionPath));
    CFileName wszKeyRootClass;
    if (wszKeyRootClass == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CFileName wszFullPath;
    if (wszFullPath == NULL)
        hRes = WBEM_E_OUT_OF_MEMORY;
            
    wchar_t *wszParentClassHash = new wchar_t[MAX_HASH_LEN+1];
    if (wszParentClassHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //Kill the .X.Y.Z on the end of the definition, in case it was passed in that way
    wcstok((wchar_t*)wszClassDefinitionPath,L".");

    StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
    StringCchCatW(wszFullPath, wszFullPath.Length(), wszClassDefinitionPath);
    
    hRes = DeleteChildClasses(pNs, wszClassDefinitionPath);

    if (SUCCEEDED(hRes))
        hRes = RetrieveKeyRootClass(wszClassDefinitionPath, wszKeyRootClass);

    if (SUCCEEDED(hRes))
    {
        hRes = RetrieveParentClassHash(wszFullPath, wszParentClassHash);
        if (hRes == WBEM_S_NO_MORE_DATA)
            hRes = 0;
    }

    if (SUCCEEDED(hRes) && wcslen(wszKeyRootClass) > 0)
        hRes = DeleteInstances(pNs, wszClassDefinitionPath, wszKeyRootClass);

    if (SUCCEEDED(hRes))
    {
        //Need to build the full path
        lRes = g_Glob.m_FileCache.DeleteObject(wszFullPath);
        hRes = A51TranslateErrorCode(lRes);
    }
    if (SUCCEEDED(hRes))
        hRes = DeleteClassRelationships(wszFullPath, wszParentClassHash);

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::DeleteChildClasses
//
//  Description: 
//      Enumerates child classes from a given parent class definition, and calls DeleteClass on each
//
//  Parameters:
//      wszParentClassDefinition    -      NS_<>\CD_<> of parent class
//
//=====================================================================
HRESULT CLocalizationUpgrade::DeleteChildClasses(CNamespaceHandle *pNs, const wchar_t *wszParentClassDefinition)
{
    HRESULT hRes= 0;
    unsigned long lRes = 0;

    //Build up a string for this classes c:\...\NS_...\CR_...\C_ enumeration
    CFileName wszChildClasses;
    if (wszChildClasses == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CFileName wszClassDefinition;
    if (wszClassDefinition == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszClassDefinition, wszClassDefinition.Length(), wszParentClassDefinition);

    //Create full class definition path
    StringCchCopyW(wszChildClasses, wszChildClasses.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\");
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), wszParentClassDefinition);

    //change the CD_ into CR_
    wszChildClasses[g_Glob.GetRootDirLen()+1+3+32+2] = L'R';

    //Add the \C_ on the end
    StringCchCatW(wszChildClasses, wszChildClasses.Length(), L"\\C_");

    //Enumerate the child classes
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszChildClasses, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, wszChildClasses, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                hRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
            {
                hRes = A51TranslateErrorCode(lRes);
                break;
            }

            //Build a NS_...\CD_... from the NS_...\CR_...\C_... path, using last hash
            StringCchCopyW(wszClassDefinition+wcslen(wszClassDefinition) - 32, 
                                        wszClassDefinition.Length() - wcslen(wszClassDefinition) + 32, 
                                        wszChildClasses + wcslen(wszChildClasses)-32);
            //Delete all child classes
            hRes = DeleteClass(pNs, wszClassDefinition);
            if (FAILED(hRes))
                break;
        }
        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
        if (lRes)
            hRes = A51TranslateErrorCode(lRes);
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::DeleteInstances
//
//  Description: 
//      Enumerates all instances for a specified class definition and calls DeleteInstance
//
//  Parameters:
//      wszClassDefinition      -       NS_<>\CD_<> of class whose instances are to be deleted
//      wszKeyRootClass     -          hash of key root class in 32-character format
//
//=====================================================================
HRESULT CLocalizationUpgrade::DeleteInstances(CNamespaceHandle *pNs, const wchar_t *wszClassDefinition, CFileName &wszKeyRootClass)
{
    LONG lRes = 0;
    HRESULT hRes = 0;
    
    //Need to enumerate all NS_\CI_<class defn hash>\IL_...
    //for each, we need to deltete the instance

    CFileName wszClassInstance;
    if (wszClassInstance == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(wszClassInstance, wszClassInstance.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszClassInstance, wszClassInstance.Length(), L"\\");
    StringCchCatW(wszClassInstance, wszClassInstance.Length(), wszClassDefinition);
    wszClassInstance[g_Glob.GetRootDirLen() + 1+3+32+1+1] = L'I';
    StringCchCatW(wszClassInstance, wszClassInstance.Length(), L"\\IL_");

    //Enumerate the instances
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszClassInstance, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, wszClassInstance, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                hRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
            {
                hRes = A51TranslateErrorCode(lRes);
                break;
            }

            hRes = DeleteInstance(pNs, wszClassInstance, wszKeyRootClass);
            if (FAILED(hRes))
                break;
        }
        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
        if (lRes)
            hRes = A51TranslateErrorCode(lRes);
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::DeleteInstance
//
//  Description: 
//      Deletes the instance links for a given instance
//
//  Parameters:
//      wszClassInstanceLink        -       NS_<>\CI_<>\IL_<> format of instance to delete
//      wszKeyRoot                      -       Hash of key root class for this instance
//
//=====================================================================
HRESULT CLocalizationUpgrade::DeleteInstance(CNamespaceHandle *pNs, const wchar_t *wszClassInstanceLink, CFileName &wszKeyRoot)
{
    HRESULT hRes = 0;
    LONG lRes = 0;

    //Remove .X.Y.Z from end of string if it exists
    wcstok((wchar_t *)wszClassInstanceLink, L".");

    DEBUGTRACE((LOG_REPDRV, "Deleting Instance: %S\n", wszClassInstanceLink));
    
    if (wcscmp(wszKeyRoot, m_namespaceClassHash) == 0)
    {
        return DeleteInstanceAsNamespace(pNs, wszClassInstanceLink);
    }
    
    //build KI entry and delete the object
    CFileName wszKI;
    if (wszKI == NULL)
        return NULL;

    StringCchCopyW(wszKI, wszKI.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszKI, wszKI.Length(), L"\\");
    StringCchCatNW(wszKI, wszKI.Length(), wszClassInstanceLink, 3+32);
    StringCchCatW(wszKI, wszKI.Length(), L"\\KI_");
    StringCchCatW(wszKI, wszKI.Length(), wszKeyRoot);
    StringCchCatW(wszKI, wszKI.Length(), L"\\I_");
    StringCchCatW(wszKI, wszKI.Length(), wszClassInstanceLink + wcslen(wszClassInstanceLink) - 32);

    lRes = g_Glob.m_FileCache.DeleteObject(wszKI);
    if (lRes)
        return A51TranslateErrorCode(lRes);

    //Build instance reference enumerator link
    StringCchCopyW(wszKI, wszKI.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszKI, wszKI.Length(), L"\\");
    StringCchCatNW(wszKI, wszKI.Length(), wszClassInstanceLink, 3+32);
    StringCchCatW(wszKI, wszKI.Length(), L"\\KI_");
    StringCchCatW(wszKI, wszKI.Length(), wszKeyRoot);
    StringCchCatW(wszKI, wszKI.Length(), L"\\IR_");
    StringCchCatW(wszKI, wszKI.Length(), wszClassInstanceLink + wcslen(wszClassInstanceLink) - 32);
    StringCchCatW(wszKI, wszKI.Length(), L"\\R_");

    hRes = DeleteInstanceReferences(wszKI);

    if (SUCCEEDED(hRes))
    {
        //Now delete the class instance link
        StringCchCopyW(wszKI, wszKI.Length(), g_Glob.GetRootDir());
        StringCchCatW(wszKI, wszKI.Length(), L"\\");
        StringCchCatW(wszKI, wszKI.Length(), wszClassInstanceLink);
        lRes = g_Glob.m_FileCache.DeleteLink(wszKI);
        if (lRes)
            hRes = A51TranslateErrorCode(lRes);
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::DeleteInstanceReferences
//
//  Description: 
//      Enumerates the instance references for the given instance link and deletes the link and object
//
//  Parameters:
//      wszInstLink     -       key root instance link of references to be deleted in format NS_<>\KI_<>\I_<>
//
//=====================================================================
//NOTE: FULL LINK PASSED IN!
HRESULT CLocalizationUpgrade::DeleteInstanceReferences(CFileName &wszInstLink)
{
    LONG lRes = 0;
    CFileName wszFullPath;
    if (wszFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
    
    //Enumerate the instances
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszInstLink, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, wszInstLink, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                lRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
            {
                break;
            }
            //Convert to a FULL path
            StringCchCatW(wszFullPath+g_Glob.GetRootDirLen()+1, wszFullPath.Length()-g_Glob.GetRootDirLen()-1, wszInstLink);
            lRes =  g_Glob.m_FileCache.DeleteObject(wszFullPath);
            if (lRes)
                break;
        }
        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
    }

    return A51TranslateErrorCode(lRes);;
}


//=====================================================================
//
//  CLocalizationUpgrade::DeleteClassRelationships
//
//  Description: 
//      Deletes all class relationships, including parent/child and references
//
//  Parameters:
//      wszPath     -       Full path of class definition, c:\windows\...\NS_<>\CD_<>
//
//=====================================================================
HRESULT CLocalizationUpgrade::DeleteClassRelationships(CFileName &wszPath, 
                                             const wchar_t wszParentClassHash[MAX_HASH_LEN+1])
{
    //Convert from the class definition to a class relationship path
    CFileName wszCRLink;
    if (wszCRLink == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(wszCRLink, wszCRLink.Length(), wszPath);
    wszCRLink[g_Glob.GetRootDirLen()+1+3+32+1+1] = L'R';

    HRESULT hRes = 0;
    LONG lRes = 0;
    CFileName wszFullPath;
    if (wszFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
    
    //Enumerate the instances
    LPVOID pEnumHandle  = NULL;
    lRes = g_Glob.m_FileCache.IndexEnumerationBegin(wszCRLink, &pEnumHandle);
    if (lRes == ERROR_SUCCESS)
    {
        while(1)
        {
            lRes = g_Glob.m_FileCache.IndexEnumerationNext(pEnumHandle, wszCRLink, true);
            if (lRes == ERROR_NO_MORE_FILES)
            {
                lRes = ERROR_SUCCESS;
                break;
            }
            else if (lRes)
            {
                break;
            }
            //Convert to a FULL path
            StringCchCopyW(wszFullPath+g_Glob.GetRootDirLen()+1, wszFullPath.Length()-g_Glob.GetRootDirLen()-1, wszCRLink);
            lRes =  g_Glob.m_FileCache.DeleteLink(wszFullPath);
            if (lRes)
                break;
        }
        g_Glob.m_FileCache.IndexEnumerationEnd(pEnumHandle);
    }
    else
    {
        if (lRes == ERROR_FILE_NOT_FOUND)
            lRes = ERROR_SUCCESS;
    }

    hRes = A51TranslateErrorCode(lRes);
    
    if (SUCCEEDED(hRes))
    {
        //Now we need to delete our parent's relationship to us!
        StringCchCopyW(wszCRLink, wszCRLink.Length(), wszPath);
        wszCRLink[g_Glob.GetRootDirLen()+1+3+32+1+1] = L'R';
        StringCchCopyW(wszCRLink+g_Glob.GetRootDirLen()+1+3+32+1+3, wszCRLink.Length()-g_Glob.GetRootDirLen()-1-3-32-1-3, wszParentClassHash);
        StringCchCatW(wszCRLink, wszCRLink.Length(), L"\\C_");
        StringCchCatW(wszCRLink, wszCRLink.Length(), wszPath+g_Glob.GetRootDirLen()+1+3+32+1+3);
        lRes = g_Glob.m_FileCache.DeleteLink(wszCRLink);
        hRes = A51TranslateErrorCode(lRes);
    }

    return hRes;
}

//=====================================================================
//
//  CLocalizationUpgrade::RetrieveKeyRootClass
//
//  Description: 
//      Searches for instances under KI_<> for all classes in the hierarchy chain for the specified class.
//      This is a slower process because we have to retrieve each class blob and get the hash of the 
//      parent class
//
//  Parameters:
//      wszClassDefinitionPath      -       Path of class definition to retrieve key root class, NS_<>\CD_<>
//      wszKeyRootClass             -       This is where we put the 32-character hash of the key root class
//                                                      or empty string if there is none!
//
//=====================================================================
HRESULT CLocalizationUpgrade::RetrieveKeyRootClass(CFileName &wszClassDefinitionPath, CFileName &wszKeyRootClass)
{
    HRESULT hRes = 0;
    LONG lRes = 0;
    CFileName wszFullClassPath;
    if (wszFullClassPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CFileName wszFullKIPath;
    if (wszFullKIPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullClassPath, wszFullClassPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullClassPath, wszFullClassPath.Length(), L"\\");
    StringCchCatW(wszFullClassPath, wszFullClassPath.Length(), wszClassDefinitionPath);

    StringCchCopyW(wszFullKIPath, wszFullKIPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullKIPath, wszFullKIPath.Length(), L"\\");
    StringCchCatW(wszFullKIPath, wszFullKIPath.Length(), wszClassDefinitionPath);

    //convert the class definition to a instance definition
    wszFullKIPath[g_Glob.GetRootDirLen()+1+3+32+1]=L'K';
    wszFullKIPath[g_Glob.GetRootDirLen()+1+3+32+2]=L'I';
    StringCchCatW(wszFullKIPath, wszFullKIPath.Length(), L"\\I_");

    wszKeyRootClass[0] = L'\0';

    do
    {
        //Check if we have any instances
        hRes = IndexExists(wszFullKIPath);
        if (SUCCEEDED(hRes))
        {
            //We have the entry we are looking for
            StringCchCopyNW(wszKeyRootClass, wszKeyRootClass.Length(), wszFullKIPath+g_Glob.GetRootDirLen()+1+3+32+1+3, 32);
            break;
        }
        else if (hRes != WBEM_E_NOT_FOUND)
        {
            break;
        }
        hRes = 0;

        //Retrieve the class hash of the parent class
        hRes = RetrieveParentClassHash(wszFullClassPath, wszFullKIPath + g_Glob.GetRootDirLen() + 1 + 3 + 32 + 1 + 3);
        if (hRes == WBEM_S_NO_MORE_DATA)
        {
            hRes = 0;
            break;
        }
        StringCchCatW(wszFullKIPath, wszFullKIPath.Length(), L"\\I_");
        StringCchCopyNW(wszFullClassPath + g_Glob.GetRootDirLen() + 1 + 3 + 32 + 1 + 3,
            wszFullClassPath.Length() - g_Glob.GetRootDirLen() - 1 - 3 - 32 - 1 - 3, 
            wszFullKIPath + g_Glob.GetRootDirLen() + 1 + 3 + 32 + 1 + 3,
            32);
        if (FAILED(hRes))
            break;
    } while (1);

    return hRes;
}

HRESULT CLocalizationUpgrade::RetrieveParentClassHash(CFileName &wszFullClassPath, 
                                                            wchar_t wszParentClassHash[MAX_HASH_LEN+1])
{
    LONG lRes = 0;
    HRESULT hRes = 0;
    
    //Retrieve the class hash of the parent class
    BYTE *pBuffer = NULL;
    DWORD dwLen = 0;
    lRes = g_Glob.m_FileCache.ReadObject(wszFullClassPath, &dwLen, &pBuffer, true);
    if (lRes == ERROR_FILE_NOT_FOUND)
    {
        //This is probably a class from the system namespace!
        CFileName wszSysClassPath;
        if (wszSysClassPath == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        StringCchCopyW(wszSysClassPath, wszSysClassPath.Length(), wszFullClassPath);
        wmemcpy(wszSysClassPath+g_Glob.GetRootDirLen()+1+3, m_systemNamespaceHash, 32);
        lRes = g_Glob.m_FileCache.ReadObject(wszSysClassPath, &dwLen, &pBuffer, true);
        if (lRes)
            return A51TranslateErrorCode(lRes);
    }
    else if (lRes)
    {
        return A51TranslateErrorCode(lRes);
    }
    CTempFreeMe tfm(pBuffer, dwLen);

    //Null terminate the class name - safe to update buffer as it is always bigger than
    //just the name!
    wchar_t *wszSuperclassName = (wchar_t*)(pBuffer+sizeof(DWORD));
    wszSuperclassName[*(DWORD*)pBuffer] = L'\0';

    //Now we need to validate that this parent is generated using the OldHash
    //method and not NewHash!
    wchar_t wszOldHash[MAX_HASH_LEN+1];
    wchar_t wszNewHash[MAX_HASH_LEN+1];
    hRes = OldHash(wszSuperclassName, wszOldHash);
    if (FAILED(hRes))
        return hRes;
    hRes = NewHash(wszSuperclassName, wszNewHash);
    if (FAILED(hRes))
        return hRes;

    if (wcsncmp(L"", wszSuperclassName, *((DWORD*)pBuffer)) == 0)
    {
        StringCchCopyW(wszParentClassHash, MAX_HASH_LEN+1, wszNewHash);
        return WBEM_S_NO_MORE_DATA;
    }

    if (wcscmp(wszOldHash, wszNewHash) == 0)
    {
        //No difference so nothing extra to do!
        StringCchCopyW(wszParentClassHash, MAX_HASH_LEN+1, wszNewHash);
        return WBEM_NO_ERROR;
    }

    //There is a possibility of using either new or old, so we need to dig deeper!
    CFileName wszParentClass;
    if (wszParentClass == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszParentClass, wszParentClass.Length(), wszFullClassPath);
    wmemcpy(wszParentClass+g_Glob.GetRootDirLen()+1+3+32+1+3, wszOldHash, 32);

    hRes = IndexExists(wszParentClass);
    if (hRes == WBEM_E_NOT_FOUND)
    {
        //Try with the other hash!
        wmemcpy(wszParentClass+g_Glob.GetRootDirLen()+1+3+32+1+3, wszNewHash, 32);

        hRes = IndexExists(wszParentClass);
        if (hRes == WBEM_NO_ERROR)
            StringCchCopyW(wszParentClassHash, MAX_HASH_LEN+1, wszNewHash);

    }
    else if (hRes == WBEM_NO_ERROR)
    {
        StringCchCopyW(wszParentClassHash, MAX_HASH_LEN+1, wszOldHash);
    }
    
    return hRes;
}


HRESULT CLocalizationUpgrade::DeleteInstanceAsNamespace(CNamespaceHandle *pNs, 
                                                    const wchar_t *wszClassInstanceLink)
{
    HRESULT hRes = NULL;
    
    //Retrieve the instance and get the key from it
    CFileName wszKIInstanceLink;
    if (wszKIInstanceLink == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(wszKIInstanceLink, wszKIInstanceLink.Length(),g_Glob.GetRootDir());
    StringCchCatW(wszKIInstanceLink, wszKIInstanceLink.Length(), L"\\");
    StringCchCatNW(wszKIInstanceLink, wszKIInstanceLink.Length(), wszClassInstanceLink, 3+32);
    StringCchCatW(wszKIInstanceLink, wszKIInstanceLink.Length(), L"\\KI_");
    StringCchCatW(wszKIInstanceLink, wszKIInstanceLink.Length(), m_namespaceClassHash);
    StringCchCatW(wszKIInstanceLink, wszKIInstanceLink.Length(), L"\\I_");
    StringCchCatW(wszKIInstanceLink, wszKIInstanceLink.Length(), wszClassInstanceLink + wcslen(wszClassInstanceLink) - 32);

    _IWmiObject *pInstance = NULL;
    hRes = pNs->FileToInstance(NULL, wszKIInstanceLink, NULL, 0, &pInstance, true);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe rm2(pInstance);

    //Extract the string from the object
    VARIANT vName;
    VariantInit(&vName);
    CClearMe cm(&vName);
    hRes = pInstance->Get(L"Name", 0, &vName, NULL, NULL);
    if(FAILED(hRes))
        return hRes;
    if(V_VT(&vName) != VT_BSTR)
    {
        return  WBEM_E_INVALID_OBJECT;
    }

    //Build the full namespace name
    size_t len = wcslen(pNs->m_wsNamespace) + 1 + wcslen(V_BSTR(&vName)) + 1;
    wchar_t *wszNamespaceName = new wchar_t[len];
    if (wszNamespaceName == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszNamespaceName, len, pNs->m_wsNamespace);
    StringCchCatW(wszNamespaceName, len, L"\\");
    StringCchCatW(wszNamespaceName, len, V_BSTR(&vName));
    
    return DeleteNamespaceRecursive(wszNamespaceName);
}

//=====================================================================
//
//  CLocalizationUpgrade::FixupIndexReferenceBlob
//
//  Description: 
//      Retrieves the instance reference blob and fixes up the entry in
//      there, then writes it back.
//
//  Parameters:
//      wszReferenceIndex      -       Path to an index reference path: ns\ki\ir\r
//
//=====================================================================
HRESULT CLocalizationUpgrade::FixupIndexReferenceBlob(CFileName &wszReferenceIndex)
{
    HRESULT hRes =0;
    //Create full path name
    CFileName wszFullPath;
    if (wszFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
    StringCchCatW(wszFullPath, wszFullPath.Length(), wszReferenceIndex);
    //remove the .X.Y.Z as this would screw everything up - both reading and writing
    wcstok(wszFullPath + g_Glob.GetRootDirLen(), L".");

    //Retrieve the blob
    LONG lRes = 0;
    DWORD dwLen = 0;
    BYTE *pBuffer = NULL;
    lRes = g_Glob.m_FileCache.ReadObject(wszFullPath, &dwLen, &pBuffer);
    if (lRes)
        return A51TranslateErrorCode(lRes);
    CTempFreeMe tfm(pBuffer, dwLen);

    //Find the path
    BYTE *pPath = pBuffer;
    DWORD dwLen2;
    memcpy(&dwLen2, pPath, sizeof(DWORD));
    pPath += (sizeof(wchar_t)*dwLen2) + sizeof(DWORD);
    memcpy(&dwLen2, pPath, sizeof(DWORD));
    pPath += (sizeof(wchar_t)*dwLen2) + sizeof(DWORD);
    memcpy(&dwLen2, pPath, sizeof(DWORD));
    pPath += (sizeof(wchar_t)*dwLen2) + sizeof(DWORD);
    memcpy(&dwLen2, pPath, sizeof(DWORD));
    pPath += sizeof(DWORD) + sizeof(L'\\');
    dwLen2 --;

    //Extract the path
    CFileName wszInstPath, wszNewInstPath;
    if ((wszInstPath == NULL) || (wszNewInstPath == NULL))
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyNW(wszInstPath, wszInstPath.Length(), (wchar_t*)pPath, dwLen2);
    
    //fixup the path
    bool bChanged = false;
    hRes = FixupIndex(wszInstPath, wszNewInstPath, bChanged);
    if (FAILED(hRes))
        return hRes;

    if (bChanged)
    {
        DEBUGTRACE((LOG_REPDRV, "Fixing up instance path in reference blob: %S\n", wszReferenceIndex));
        //re-insert into the blob
        wmemcpy((wchar_t*)pPath, wszNewInstPath, dwLen2);
        
        //write back
        lRes = g_Glob.m_FileCache.WriteObject(wszFullPath, NULL, dwLen, pBuffer);
        if (lRes)
            return A51TranslateErrorCode(lRes);
    }

    return 0;
}


//=====================================================================
//
//  CLocalizationUpgrade::FixupInstanceBlob
//
//  Description: 
//      Retrieves the instance  blob and fixes up the class entry in
//      there, then writes it back.
//
//  Parameters:
//      wszInstanceIndex      -       Path to an instance reference path: ns\ki\i
//
//=====================================================================
HRESULT CLocalizationUpgrade::FixupInstanceBlob(CFileName &wszInstanceIndex)
{
    HRESULT hRes =0;
    //Create full path name
    CFileName wszFullPath;
    if (wszFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(wszFullPath, wszFullPath.Length(), g_Glob.GetRootDir());
    StringCchCatW(wszFullPath, wszFullPath.Length(), L"\\");
    StringCchCatW(wszFullPath, wszFullPath.Length(), wszInstanceIndex);
    //remove the .X.Y.Z as this would screw everything up - both reading and writing
    wcstok(wszFullPath + g_Glob.GetRootDirLen(), L".");

    //Retrieve the blob
    LONG lRes = 0;
    DWORD dwLen = 0;
    BYTE *pBuffer = NULL;
    lRes = g_Glob.m_FileCache.ReadObject(wszFullPath, &dwLen, &pBuffer);
    if (lRes)
        return A51TranslateErrorCode(lRes);
    CTempFreeMe tfm(pBuffer, dwLen);

    //Extract the class hash
    wchar_t *wszClassHash = new wchar_t [MAX_HASH_LEN+1];
    if (wszClassHash == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyNW(wszClassHash, MAX_HASH_LEN+1, (wchar_t*)pBuffer, 32);
    
    //fixup the path
    wchar_t *wszNewHash = NULL;
    hRes = GetNewHash(wszClassHash, &wszNewHash);
    if (hRes == WBEM_E_NOT_FOUND)
        return WBEM_NO_ERROR;
    else if (FAILED(hRes))
        return hRes;
    else
    {
        DEBUGTRACE((LOG_REPDRV, "Fixing up class hash in instance blob: %S\n", wszInstanceIndex));
        //re-insert into the blob
        wmemcpy((wchar_t*)pBuffer, wszNewHash, 32);

        //Build the CI full path also as we need to write both back
        CFileName wsCIPath;
        if (wsCIPath == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        StringCchCopyW(wsCIPath, wsCIPath.Length(), g_Glob.GetRootDir());
        StringCchCatW(wsCIPath, wsCIPath.Length(), L"\\");
        StringCchCatNW(wsCIPath, wsCIPath.Length(), wszInstanceIndex, 3+32);
        StringCchCatW(wsCIPath, wsCIPath.Length(), L"\\CI_");
        StringCchCatW(wsCIPath, wsCIPath.Length(), wszNewHash);
        StringCchCatW(wsCIPath, wsCIPath.Length(), L"\\IL_");
        StringCchCatN(wsCIPath, wsCIPath.Length(), wszInstanceIndex + 3+32+1+3+32+1+2, 32);
        
        //write back
        lRes = g_Glob.m_FileCache.WriteObject(wszFullPath, wsCIPath, dwLen, pBuffer);
        if (lRes)
            return A51TranslateErrorCode(lRes);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\upgrade.h ===
/*******************************************************************************/ 
/*                                                                             */ 
/*    Copyright - Microsoft Corporation.  All rights reserved.                 */ 
/*                                                                             */ 
/*******************************************************************************/


#include <persistcfg.h>
class CDbVerRead : public CPersistentConfig
{
    public:
        BOOL ReadDbVer(DWORD &dwVal)
        {
            return GetPersistentCfgValue(PERSIST_CFGVAL_CORE_FSREP_VERSION, dwVal);
        }
};

class CUniqueStringPair
{
    private:
        CFlexArray m_array;
            
    class CStringPair
    {
        public:
            wchar_t *m_wsz1;
            wchar_t *m_wsz2;
            
            CStringPair(const wchar_t *wsz1, const wchar_t *wsz2)
            {
                m_wsz1 = new wchar_t [wcslen(wsz1)+1];
                m_wsz2 = new wchar_t [wcslen(wsz2)+1];

                if (m_wsz1 && m_wsz2)
                {
                    StringCchCopyW(m_wsz1, wcslen(wsz1)+1, wsz1);
                    StringCchCopyW(m_wsz2, wcslen(wsz2)+1, wsz2);
                }
                else
                {
                    delete [] m_wsz1;
                    delete [] m_wsz2;
                    m_wsz1 = NULL;
                    m_wsz2 = NULL;
                    throw CX_MemoryException();
                }
            }
            ~CStringPair()
            {
                delete [] m_wsz1;
                delete [] m_wsz2;
            }
    };

public:
    CUniqueStringPair() {}
    ~CUniqueStringPair()
    {
        for (unsigned int i = 0; i != m_array.Size(); i++)
        {
            CStringPair *pEntry = (CStringPair*)m_array[i];
            delete pEntry;
            m_array[i] = NULL;
        }
        m_array.Empty();
    }

    HRESULT AddStrings(const wchar_t *wszKey, const wchar_t *wsz)
    {
        wchar_t *wszExisting = NULL;
        HRESULT hRes = FindStrings(wszKey, &wszExisting);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            CStringPair *pEntry = new CStringPair(wszKey, wsz);
            if (pEntry)
            {
                if (m_array.Add(pEntry) != 0)
                    hRes = WBEM_E_OUT_OF_MEMORY;
                else
                    hRes = WBEM_NO_ERROR;
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }
                
        }
        return hRes;
    }
    HRESULT FindStrings(const wchar_t *wszKey, wchar_t **wsz)
    {
        HRESULT hRes = WBEM_E_NOT_FOUND;
        for (unsigned int i = 0; i != m_array.Size(); i++)
        {
            CStringPair *pEntry = (CStringPair*) m_array[i];
            if (wcscmp(wszKey, pEntry->m_wsz1) == 0)
            {
                *wsz = pEntry->m_wsz2;
                hRes = WBEM_NO_ERROR;
                break;
            }
        }

        return hRes;
    }

    HRESULT RemoveString(const wchar_t *wszKey)
    {

        HRESULT hRes = WBEM_E_NOT_FOUND;
        for (unsigned int i = 0; i != m_array.Size(); i++)
        {
            CStringPair *pEntry = (CStringPair*) m_array[i];
            if (wcscmp(wszKey, pEntry->m_wsz1) == 0)
            {
                delete pEntry;
                m_array.RemoveAt(i);
                hRes = WBEM_NO_ERROR;
                break;
            }
        }

        return hRes;
    }

    CStringPair* operator [] (int nSubscript)
    {
        if (nSubscript >= Size())
            return (CStringPair*)NULL;
        else
            return (CStringPair*)m_array[nSubscript];    
    }
    size_t Size() { return m_array.Size(); }
};


class CLocalizationUpgrade
{
    
    public:
        CLocalizationUpgrade(CLifeControl* pControl, CRepository * pRepository);
        ~CLocalizationUpgrade();

        HRESULT DoUpgrade();


    private:
        CRepository * m_pRepository;
        CLifeControl* m_pControl;
        CUniqueStringPair m_keyHash;        //Keyed on: OLD HASH
        CUniqueStringPair m_pathHash;       //Keyed on: OLD PATH HASH
        CUniqueStringPair m_namespaces; //Keyed on:  Namespace Path
        wchar_t     m_namespaceClassHash[MAX_HASH_LEN+1];
        wchar_t     m_emptyClassHash[MAX_HASH_LEN+1];
        wchar_t     m_systemNamespaceHash[MAX_HASH_LEN+1];
        int         m_pass;

        HRESULT ProcessSystemClassesRecursively(CNamespaceHandle *pNs,
                                                        const wchar_t *namespaceHash, 
                                                        const wchar_t *parentClassHash);
        HRESULT EnumerateChildNamespaces(const wchar_t *wsRootNamespace);
        HRESULT ProcessClassesRecursively(CNamespaceHandle *pNs,const wchar_t *namespaceHash, const wchar_t *classHash);
        HRESULT ProcessClass(CNamespaceHandle *pNs,
                                const wchar_t *namespaceHash, 
                                const wchar_t *parentClassHash,
                                const wchar_t *childClassHash);
        HRESULT EnumerateInstances(CNamespaceHandle *pNs, const wchar_t *wszNewNamespaceHash);

        HRESULT ProcessNamespaceCollisions();
        HRESULT DeleteNamespaceRecursive(const wchar_t *wszFullNamespacePath);
        HRESULT DeleteNamespace(const wchar_t *wszNamespaceName, const wchar_t *wszNamespaceHash);
        HRESULT DeleteClass(CNamespaceHandle *pNs, CFileName &wszClassDefinitionPath);
        HRESULT DeleteChildClasses(CNamespaceHandle *pNs, const wchar_t *wszParentClassDefinition);
        HRESULT DeleteInstances(CNamespaceHandle *pNs, const wchar_t *wszClassDefinition, CFileName &wszKeyRootClass);
        HRESULT DeleteInstance(CNamespaceHandle *pNs, const wchar_t *wszClassInstanceLink, CFileName &wszKeyRoot);
        HRESULT DeleteInstanceReferences(CFileName &wszInstLink);
        HRESULT DeleteParentChildLink(wchar_t *wszClassDefinition);
        HRESULT DeleteClassRelationships(CFileName &wszClassDefinitionPath, const wchar_t wszParentClassHash[MAX_HASH_LEN+1]);
        HRESULT RetrieveKeyRootClass(CFileName &wszClassDefinitionPath, CFileName &wszKeyRootClass);
        HRESULT RetrieveParentClassHash(CFileName &wszClassDefinitionPath, 
                                              wchar_t wszParentClassHash[MAX_HASH_LEN+1]);
        HRESULT DeleteInstanceAsNamespace(CNamespaceHandle *pNs, const wchar_t *wszClassInstanceLink);

        HRESULT ProcessHash(const wchar_t *wszName, bool *bDifferent);
        HRESULT ProcessFullPath(CFileName &wszName, const wchar_t *wszNewNamespaceHash);

        HRESULT FixupBTree();
        HRESULT FixupNamespace(const wchar_t *wszNamespace);
        HRESULT FixupIndex(CFileName &oldIndexEntry, CFileName &newIndexEntry, bool &bChanged);
        HRESULT FixupIndexConflict(CFileName &wszOldIndex);
        HRESULT FixupIndexReferenceBlob(CFileName &wszReferenceIndex);
        HRESULT FixupInstanceBlob(CFileName &wszInstanceIndex);

        HRESULT WriteIndex(CFileName &wszOldIndex, const wchar_t *wszNewIndex);
        HRESULT WriteClassIndex(CNamespaceHandle *pNs, CFileName &wszOldIndex, const wchar_t *wszNewIndex, bool *bClassDeleted);
        HRESULT IndexExists(const wchar_t *wszIndex);
        bool IsClassDefinitionPath(const wchar_t *wszPath);
        bool IsKeyRootInstancePath(const wchar_t *wszPath);
        bool IsInstanceReference(const wchar_t *wszPath);

        HRESULT OldHash(const wchar_t *wszName, wchar_t *wszHash);
        HRESULT NewHash(const wchar_t *wszName, wchar_t *wszHash);

        HRESULT GetNewHash(const wchar_t *wszOldHash, wchar_t **pNewHash);
        HRESULT GetNewPath(const wchar_t *wszOldHash, wchar_t **pNewHash);

        void OldStringToUpper(wchar_t* pwcTo, const wchar_t* pwcFrom)
        {
            while(*pwcFrom)
            {
                if(*pwcFrom >= 'a' && *pwcFrom <= 'z')
                    *pwcTo = *pwcFrom + ('A'-'a');
                else
                    *pwcTo = *pwcFrom;
                pwcTo++;
                pwcFrom++;
            }
            *pwcTo = 0;
        }

        void NewStringToUpper(wchar_t* pwcTo, const wchar_t* pwcFrom)
        {
            while(*pwcFrom)
            {
                if(*pwcFrom >= 'a' && *pwcFrom <= 'z')
                    *pwcTo = *pwcFrom + ('A'-'a');
                else if(*pwcFrom < 128)
                    *pwcTo = *pwcFrom;
                else 
                    if (LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, pwcFrom, 1, pwcTo, 1) == 0)
                    {
                        *pwcTo = *pwcFrom;
                        DEBUGTRACE((LOG_REPDRV, "Failed to convert %C to upper case\n", *pwcFrom));
                    }

                pwcTo++;
                pwcFrom++;
            }
            *pwcTo = 0;
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\varobjheap.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    VarObjHeap.CPP

Abstract:

    Implements the storage of variable length objects over the top of of a fixed
	length page system. It keeps a set of admin pages for holding the pages active
	by this subsystem, along with how much space is used on each.  When a page becomes
	empty it frees up the page to the page system.  It also deals with blocks that span
	multiple pages

History:
	paulall		02-Feb-2001		Created  

--*/
#include "precomp.h"
#include "VarObjHeap.h"
#include "pagemgr.h"
#include <wbemutil.h>


//**************************************************************************************
//CVarObjHeap will do little other than initialize variables.  The Initialize method
//deals with starting everything up.
//**************************************************************************************
CVarObjHeap::CVarObjHeap()
: m_pObjectFile(NULL), m_dwPageSize(0), m_dwStatus(AdminPagesNeedReading)
{
}

//**************************************************************************************
//~CVarObjHeap will break the connection with the transacted object file layer
//**************************************************************************************
CVarObjHeap::~CVarObjHeap()
{
	Shutdown(0);
}

//**************************************************************************************
//Initialize will create the link with the transacted object file layer
//**************************************************************************************
DWORD CVarObjHeap::Initialize(CPageSource *pPageManager)
{
	//Initialize the object file layer...
	DWORD dwRes = pPageManager->GetObjectHeapPageFile(&m_pObjectFile);

	if (dwRes == ERROR_SUCCESS)
		m_dwPageSize = m_pObjectFile->GetPageSize();

	if (dwRes == ERROR_SUCCESS)
	{
		m_dwStatus = AdminPagesNeedReading;
		dwRes = ReadAdminPages(pPageManager, true);
	}

	return dwRes;
}

//**************************************************************************************
//Shutdown will close the transactioned object file layer and tidy up anything else
//that is needed.
//**************************************************************************************
DWORD CVarObjHeap::Shutdown(DWORD dwShutdownType)
{
	DWORD dwRes = ERROR_SUCCESS;

	//Flush the admin pages... remember the error though!
	dwRes = FlushAdminPages();

	if (m_pObjectFile)
	{
		m_pObjectFile->Release();
		m_pObjectFile = NULL;
	}

	//Delete the admin pages structures
	m_aAdminPages.Lock();
	while (m_aAdminPages.Size())
	{	
		VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[0];
		delete [] pEntry->pbPage;
		delete pEntry;
		m_aAdminPages.RemoveAt(0);
	}
	m_aAdminPages.Unlock();

	return dwRes;
}

//**************************************************************************************
//InvalidateCache - called when a transaction is aborted and we need to re-read cached
//data.  Data we cache is mainlyh the admin pages, therefore we should just re-read
//them.
//**************************************************************************************
DWORD CVarObjHeap::InvalidateCache()
{
	m_dwStatus = AdminPagesNeedReading;
	return ReadAdminPages(0, true);
}

DWORD CVarObjHeap::FlushCaches()
{
	m_dwStatus = AdminPagesNeedReading;
	return ReadAdminPages(0, false);
}

//**************************************************************************************
//ReadBuffer retrieves the appropriate page(s) from the virtual page store and copies 
//off the actual block from those page(s).  It may reside on the main page if it is small,
//it may reside on main page and some of the next page, or it may reside on main page, 
//one or more whole pages following that, followed by a partial (or full) page.
//**************************************************************************************
DWORD CVarObjHeap::ReadBuffer(/* in */  ULONG ulPageId, 
								/* in */  ULONG ulOffsetId, 
								/* out */ BYTE **ppReturnedBlock,
								/* out */ DWORD *pdwBlockSize)
{
	if ((ulPageId == 0) || (ulOffsetId == 0))
            return ERROR_INVALID_PARAMETER;

	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
#ifdef DBG
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
#endif
		return ERROR_INTERNAL_ERROR;
	}
	//We need to retrieve the page from the file store, and then we need to retrieve the 
	//block from the the page.  We need to allocate the appropriate memory and copy it
	//into that memory.


	BYTE *pbPage = new BYTE[m_dwPageSize];
	if (pbPage == NULL)
		dwRes = ERROR_OUTOFMEMORY;
	CVectorDeleteMe<BYTE> vdm1(pbPage);

	//So, first we need to retrieve the page...
	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = m_pObjectFile->GetPage(ulPageId, 0, pbPage);
		_ASSERT(dwRes != ERROR_FILE_NOT_FOUND, "WinMgmt: Page was requested that could not be found!");
	}

	//Retrieve the REAL offset and size to the block based on offsetId
	BYTE *pOffsetPointer = NULL;
	DWORD dwBlockSize = 0;
	DWORD dwCRC32 = 0;
	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = OffsetToPointer(ulOffsetId, pbPage, &pOffsetPointer, &dwBlockSize, &dwCRC32);
		_ASSERT(dwRes != ERROR_FILE_NOT_FOUND, "WinMgmt: Offset within page not found!\n");
	}

	//We can now allocate the real block now as we know how big it is.  We may not have all 
	//the pages in memory yet though!
	BYTE *pBlock = NULL;
	if (dwRes == ERROR_SUCCESS)
		pBlock = new BYTE[dwBlockSize];

	if ((dwRes == ERROR_SUCCESS) && (pBlock == NULL))
		dwRes = ERROR_OUTOFMEMORY;

	DWORD dwBlockNumber = 0;
	DWORD dwAmountCopiedSoFar = 0;
	
	//Copy off the first block
	if (dwRes == ERROR_SUCCESS)
	{
		DWORD dwSizeOfFirstPageBlock = min(dwBlockSize, DWORD((pbPage + m_dwPageSize) - pOffsetPointer));
		dwAmountCopiedSoFar = dwSizeOfFirstPageBlock;
		memcpy(pBlock, pOffsetPointer, dwSizeOfFirstPageBlock);
	}
	//We should now loop through the pages (retrieving them if necessary) and copying
	//the data into our buffer
	while ((dwRes == ERROR_SUCCESS) && (dwAmountCopiedSoFar < dwBlockSize))
	{
		dwBlockNumber++;
		
		//Read the next page...
		dwRes = m_pObjectFile->GetPage(ulPageId + dwBlockNumber, 0, pbPage);
		_ASSERT(dwRes != ERROR_FILE_NOT_FOUND, "WinMgmt: Page was requested that could not be found!");

		if (dwRes == ERROR_SUCCESS)
		{
			//Distinguish if this is a full page or not...
			if ((dwAmountCopiedSoFar + m_dwPageSize) > dwBlockSize)
			{
				//This is a partial block, so copy as much as is needed
				DWORD dwPartialSize = dwBlockSize - dwAmountCopiedSoFar;
				memcpy((pBlock + dwAmountCopiedSoFar), pbPage, dwPartialSize);
				dwAmountCopiedSoFar += dwPartialSize;
			}
			else
			{
				//This is a full block, so grab it all...
				memcpy((pBlock + dwAmountCopiedSoFar), pbPage, m_dwPageSize);
				dwAmountCopiedSoFar += m_dwPageSize;
			}
		}
	}
#ifdef DBG
	if (dwRes == ERROR_SUCCESS)
	{
		//Can only check for single-page blocks!
		if (ulOffsetId != 1)
		{
			dwRes = ValidatePageCRCWithAdminPage(pbPage, ulPageId);
		}
	}
#endif

	//If we are successful, lets do a CRC check on the object
	if (dwRes == ERROR_SUCCESS)
	{
		try 
		{
			DWORD dwNewCRC32 = CreateCRC32(pBlock, dwBlockSize);
			FINALIZE_CRC32(dwNewCRC32);
			if (dwNewCRC32 != dwCRC32)
			{
#ifdef DBG
				OutputDebugString(L"WinMgmt: CRC check on an object retrieved from repository is invalid\n");
				DebugBreak();
#endif
				dwRes = ERROR_INTERNAL_ERROR;
			}

		}
		catch (...)
		{
#ifdef DBG
			OutputDebugString(L"WinMgmt: CRC check on an object retrieved from repository is invalid\n");
			DebugBreak();
#endif
			dwRes = ERROR_INTERNAL_ERROR;
		}
	}
	//If successful we need to return the pointer to the object
	if (dwRes == ERROR_SUCCESS)
	{
		*ppReturnedBlock = pBlock;
		*pdwBlockSize = dwBlockSize;
	}
	else
	{
		delete [] pBlock;
	}

	return dwRes;
}

//**************************************************************************************
//WriteNewBuffer will write a new page based on size of BYTE *, and return the
//new virtual pageId and offsetId of the block. Although we may use multiple pages
//we only need to return the details of the first page.
//**************************************************************************************
DWORD CVarObjHeap::WriteNewBuffer(/* in */ ULONG ulBlockSize, 
									/* in */ const BYTE *pBlock, 
									/* out */ ULONG *pulPageId, 
									/* out */ ULONG *pulOffsetId)
{
	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
#ifdef DBG
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
#endif
		return ERROR_INTERNAL_ERROR;
	}

	//If this block will not fit on a single page we call the dedicated method!
	if (ulBlockSize > (m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2)))
		return AllocateMultiPageBuffer(ulBlockSize, pBlock, pulPageId, pulOffsetId);

	BYTE *pbPage = new BYTE[m_dwPageSize];
	if (pbPage == NULL)
		dwRes = ERROR_OUTOFMEMORY;
	CVectorDeleteMe<BYTE> vdm(pbPage);

	DWORD dwPageId = 0;

	//We are going to loop for a few times in case our admin pages for some reason 
	//are out of sink with the actual pages.
	for (int i = 0; i != 10 ; i++)
	{
		//Find a page that has enough space for this
		if (dwRes == ERROR_SUCCESS)
			dwRes = FindPageWithSpace(ulBlockSize, &dwPageId);

		if (dwRes == ERROR_SUCCESS)
		{
			//There is a page with space in it!
			//Read the page from the file
			dwRes = m_pObjectFile->GetPage(dwPageId, 0, pbPage);

	#ifdef DBG
			if (dwRes == ERROR_SUCCESS)
				dwRes = ValidatePageCRCWithAdminPage(pbPage, dwPageId);
			if (dwRes == ERROR_SUCCESS)
				dwRes = ValidatePageFreeSpaceWithAdminPage(pbPage, dwPageId);		
	#endif /* DBG */

			if (dwRes == ERROR_SUCCESS)
			{
				DWORD ulFreeSpaceLeft = 0;
				dwRes = ValidatePageFreeSpace(pbPage, ulBlockSize, &ulFreeSpaceLeft);

				if (dwRes == ERROR_INTERNAL_ERROR)
				{
					ERRORTRACE((LOG_WBEMCORE, 
						"****REPOSITORY INCONSISTENCY DETECTED!****\n"
						"****Admin page recorded page %ul had enough space available for %ul bytes****\n"
						"****In reality it did not have enough space, and only has %ul left****\n"
						"****Adjusting space in admin page to match actual space in page****\n",
						dwPageId, ulBlockSize + sizeof(VarObjObjOffsetEntry), ulFreeSpaceLeft
						));
					//Something is screwed up on this page.  Initiate recovery sequence.
					DWORD dwCRC32 = 0;
					dwCRC32 = CreateCRC32(pbPage, m_dwPageSize);
					FINALIZE_CRC32(dwCRC32);

					UpdateAdminPageForAllocate2(dwPageId, ulFreeSpaceLeft, dwCRC32);


					if (i == 9)
					{
						ERRORTRACE((LOG_WBEMCORE, 
							"****TOO MANY REPOSITORY INCONSISTENCIES DETECTED!****\n"
							"****ABORTING CURRENT OPERATION!****\n"
							));
						break;
					}
					else
					{
						dwRes = ERROR_SUCCESS;	//cancel error so we can try again
						continue;
					}
				}
			}
			else
				break;	//something bad happened, lets bail
		}
		else if (dwRes == ERROR_FILE_NOT_FOUND)
		{
			//We didn't find space so we allocate a new page

			dwRes = AllocateNewPage(ulBlockSize, &dwPageId, pbPage);
			break;
		}

		if (dwRes == ERROR_SUCCESS)
			break;
	}

	//We now have a page, albeit a new page or an existing one, so now we need
	//to allocate space from it
	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = AllocateFromPage(dwPageId, pbPage, ulBlockSize, pBlock, pulOffsetId);
	}

	//Write the page to the object file
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_pObjectFile->PutPage(dwPageId, 0, pbPage);

	DWORD dwCRC32 = 0;
	if (dwRes == ERROR_SUCCESS)
	{
		dwCRC32 = CreateCRC32(pbPage, m_dwPageSize);
		FINALIZE_CRC32(dwCRC32);
	}

	if (dwRes == ERROR_SUCCESS)
		dwRes = UpdateAdminPageForAllocate(dwPageId, ulBlockSize, dwCRC32);

	if (dwRes == ERROR_SUCCESS)
		dwRes = FlushAdminPages();
	
	//Update the pageId for the client caller
	if (dwRes == ERROR_SUCCESS)
	{
		*pulPageId = dwPageId;
		if ((*pulPageId == 0) || (*pulOffsetId == 0))
                {
                        dwRes = ERROR_INTERNAL_ERROR;
#ifdef DBG
			DebugBreak();                        
#endif
                }
	}

#ifdef DBG
	if (dwRes == ERROR_SUCCESS)
		dwRes = ValidatePageFreeSpaceWithAdminPage(pbPage, dwPageId);	
	if (dwRes == ERROR_SUCCESS)
		dwRes = ValidateAllCRC32OnPage(pbPage);
#endif
	return dwRes;
}

//**************************************************************************************
//WriteExistingBuffer will update an existing block with new data.  The old virtual page 
//and offset are passed in, and new ones are returned.  They may or may not be the same
//depending on if it still fits in the page or not.
//**************************************************************************************
DWORD CVarObjHeap::WriteExistingBuffer(/* in */ ULONG ulBlockSize, 
				       /* in */ const BYTE *pBlock, 
				       /* in */ ULONG ulOldPageId, 
				       /* in */ ULONG ulOldOffsetId, 
				       /* out */ ULONG *pulNewPageId, 
				       /* out */ ULONG *pulNewOffsetId)
{
	//Validate the in parameters!
	if ((ulOldPageId == 0) || (ulOldOffsetId == 0))
	{
#ifdef DBG
		DebugBreak();
#endif
		return ERROR_INTERNAL_ERROR;
	}

	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
#ifdef DBG
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
#endif
		return ERROR_INTERNAL_ERROR;
	}

	//We need to retrieve the page that is being updated, then we need to overwrite the 
	//original stuff in the page.  We may need to shuffle all the existing blocks around
	//within the page to make sure everything is fully packed.  We may need to adjust
	//the free-page list with the amount of space we have available on this page.
	//TODO!  Do this properly!!!
	dwRes = DeleteBuffer(ulOldPageId, ulOldOffsetId);
	if (dwRes == ERROR_SUCCESS)
		dwRes = WriteNewBuffer(ulBlockSize, pBlock, pulNewPageId, pulNewOffsetId);

	//Validate the out parameters!
	if ((*pulNewPageId == 0) || (*pulNewOffsetId == 0))
	{
#ifdef DBG
		DebugBreak();
#endif
		dwRes = ERROR_INTERNAL_ERROR;
	}
	
	return dwRes;
}

//**************************************************************************************
//DeleteBuffer is called to delete the item in the store given the virtual pageId and 
//offsetId.
//**************************************************************************************
DWORD CVarObjHeap::DeleteBuffer(/* in */ ULONG ulPageId, 
								  /* in */ ULONG ulOffsetId)
{
	DWORD dwRes = ERROR_SUCCESS;
	if (m_dwStatus == NoError)
	{
		//Nothing to do... help with compiler prediction logic
	}
	else if ((m_dwStatus == AdminPageReadFailure) || (m_dwStatus == AdminPagesNeedReading))
	{
		dwRes = ReadAdminPages(0, true);
		if (dwRes != ERROR_SUCCESS)
			return dwRes;
	}
	else if (m_dwStatus == RootAdminPageCreationFailure)
	{
#ifdef DBG
		OutputDebugString(L"WinMgmt: Repository initialization failed and we were still called to retrieve stuff! Yeah, right!\n");
		DebugBreak();
#endif
		return ERROR_INTERNAL_ERROR;
	}

	//Allocate space for the page we are going to manipulate
	BYTE *pbPage = new BYTE[m_dwPageSize];
	if (pbPage == NULL)
		dwRes = ERROR_OUTOFMEMORY;
	CVectorDeleteMe<BYTE> vdm(pbPage);

	//Retrieve the page that contains this object
	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = m_pObjectFile->GetPage(ulPageId, 0, pbPage);
		_ASSERT(dwRes != ERROR_FILE_NOT_FOUND, "WinMgmt: Page not found!\n");
	}

	//If this object is a multi-page object we have a different algorithm
	if (dwRes == ERROR_SUCCESS)
	{
		if (MultiPageObject(pbPage))
			return DeleteMultiPageBuffer(ulPageId, ulOffsetId, pbPage);
	}

	//Remove the object from this page
	DWORD dwSize = 0;
	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = RemoveFromPage(ulPageId, ulOffsetId, pbPage, &dwSize);
		_ASSERT(dwRes != ERROR_FILE_NOT_FOUND, "WinMgmt: Offset within page not found!\n");
	}

	DWORD dwCRC32 = 0;
	if (dwRes == ERROR_SUCCESS)
	{
		dwCRC32 = CreateCRC32(pbPage, m_dwPageSize);
		FINALIZE_CRC32(dwCRC32);
	}

	//Update the admin page, possibly even deleting the page!
	bool bPageDeleted = false;
	if (dwRes == ERROR_SUCCESS)
		dwRes = UpdateAdminPageForDelete(ulPageId, dwSize, dwCRC32, &bPageDeleted);

	//Flush the page back to the object file and update admin page
	if ((dwRes == ERROR_SUCCESS) && !bPageDeleted)
	{
		dwRes = m_pObjectFile->PutPage(ulPageId, 0, pbPage);
	}

	//Flush the admin pages
	if (dwRes == ERROR_SUCCESS)
		dwRes = FlushAdminPages();

	return dwRes;
}


//**************************************************************************************
//AllocateFromPage - adds an allocation to the end of the existing allocations
//**************************************************************************************
DWORD CVarObjHeap::AllocateFromPage(/* in */ DWORD dwPageId, 
									  /* in */ BYTE *pbPage,
									  /* in */ ULONG ulBlockSize, 
									  /* in */ const BYTE *pBlock, 
									  /* out*/ ULONG *pdwNewOffset)
{
#ifdef XFILES_DEBUG
	if (dwPageId == 0x125)
	{
		OutputDebugString(L"===============================\n");
		OutputDebugString(L"Start of AllocateFromPage\n");
		DumpPageOffsetTable(dwPageId, pbPage);
	}
#endif
	DWORD dwRes = ERROR_SUCCESS;
	
	//Get a pointer to the start of the offset table
	VarObjObjOffsetEntry *pOffsetEntry = (VarObjObjOffsetEntry *) pbPage;

	//This is the location where the last block resided and size so we can calculate
	//where the new block goes
	DWORD dwLastOffset = pOffsetEntry[0].dwPhysicalStartOffset;
	DWORD dwLastSize = 0;
	DWORD dwNewOffsetId = 0;
	bool bNewOffsetIdClash = false;

	do
	{
	    dwNewOffsetId = GetTickCount() + (DWORD)rand();
	} while (dwNewOffsetId == 0);


	//Loop through the table until we get to the end... adjusting the offset within the 
	//entries along the way to account for the fact we will be shifting them by the size
	//of an offset entry.
	for (DWORD dwOffsetIndex = 0; pOffsetEntry[dwOffsetIndex].dwOffsetId != 0; dwOffsetIndex++)
	{
		//Shuffle the size of this offset by one entry because we will be doing a memcpy
		//when this is done so we have room for our new entry.
		pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset += sizeof VarObjObjOffsetEntry;
		dwLastOffset = pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset;
		dwLastSize = pOffsetEntry[dwOffsetIndex].dwBlockLength;

		if (pOffsetEntry[dwOffsetIndex].dwOffsetId == dwNewOffsetId)
		{
			bNewOffsetIdClash = true;
		}
	}

	//While we have an offset clash we need to keep re-calculating
	while (bNewOffsetIdClash)
	{
		bNewOffsetIdClash = false;
    	do
    	{
    	    dwNewOffsetId = GetTickCount() + (DWORD)rand();
    	} while (dwNewOffsetId == 0);
    	
		for (DWORD dwIndex = 0; pOffsetEntry[dwIndex].dwOffsetId != 0; dwIndex++)
		{
			if (pOffsetEntry[dwIndex].dwOffsetId == dwNewOffsetId)
			{
				bNewOffsetIdClash = true;
				break;
			}
		}
	}

	//Now dwOffsetIndex is where we are going to insert this new offset entry, and dwLastOffset + dwLastSize
	//is the new location where we need to copy this data...

	//Only problem now though is that we need to shuffle all data along by the size of an offset entry!
	MoveMemory(&pOffsetEntry[dwOffsetIndex+1], &pOffsetEntry[dwOffsetIndex], ((dwLastOffset + dwLastSize) - pOffsetEntry[0].dwPhysicalStartOffset) + sizeof(VarObjObjOffsetEntry));

	//Write the new entry in the offset table
	pOffsetEntry[dwOffsetIndex].dwOffsetId = dwNewOffsetId;

	if (dwLastOffset == 0)
	{
		//First block of the page!
		pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset = (sizeof(VarObjObjOffsetEntry) * 2);
	}
	else
	{
		pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset = dwLastOffset + dwLastSize;
	}

	pOffsetEntry[dwOffsetIndex].dwBlockLength = ulBlockSize;

#if XFILES_DEBUG
	if (dwPageId == 0x125)
	{
		OutputDebugString(L"===============================\n");
		OutputDebugString(L"Start of AllocateFromPage\n");
		DumpPageOffsetTable(dwPageId, pbPage);
	}
#endif

	//Write the block to the page
#ifdef DBG
	if (pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset + ulBlockSize > m_dwPageSize)
	{
		OutputDebugString(L"WinMgmt: Object heap is about to write past the end of a page boundary and will cause heap corruption if we continue!\n");
		DebugBreak();
		dwRes = ERROR_INTERNAL_ERROR;
	}
#endif

	if (dwRes == ERROR_SUCCESS)
	{
		//Generate the CRC
		DWORD dwCRC32 = CreateCRC32(pBlock, ulBlockSize);
		FINALIZE_CRC32(dwCRC32);
		pOffsetEntry[dwOffsetIndex].dwCRC = dwCRC32;

		//Copy the blob into the block
		CopyMemory(pbPage + pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset, pBlock, ulBlockSize);

		//Return the offset ID
		*pdwNewOffset = dwNewOffsetId;
	}

	return dwRes;
}

//**************************************************************************************
//OffsetToPointer - Given and offsetId and a page, calculate the physical pointer to the 
//object and also return the size of the block.
//**************************************************************************************
DWORD CVarObjHeap::OffsetToPointer(/* in */ ULONG ulOffsetId, 
									 /* in */ BYTE  *pbPage, 
									 /* out*/ BYTE  **pOffsetPointer, 
									 /* out*/ ULONG *pdwBlockSize,
									 /* out*/ DWORD *pdwCRC32)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	//Get a pointer to the start of the offset table
	VarObjObjOffsetEntry *pOffsetEntry = (VarObjObjOffsetEntry *) pbPage;

	//Loop through the table until we find the one we are interested in
	for (DWORD dwOffsetIndex = 0; pOffsetEntry[dwOffsetIndex].dwOffsetId != 0; dwOffsetIndex++)
	{
		if (pOffsetEntry[dwOffsetIndex].dwOffsetId == ulOffsetId)
		{
			dwRes = ERROR_SUCCESS;
			*pdwBlockSize = pOffsetEntry[dwOffsetIndex].dwBlockLength;
			*pOffsetPointer = pbPage + pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset;
			*pdwCRC32 = pOffsetEntry[dwOffsetIndex].dwCRC;

			break;
		}
	}

	return dwRes;
}


//**************************************************************************************
//ReadAdminPages - Reads the admin pages into memory and marks them as clean (no changes)
//**************************************************************************************
DWORD CVarObjHeap::ReadAdminPages(CPageSource *pTransactionManager, bool bReReadPages)
{
	m_aAdminPages.Lock();

	//Check it wasn't lock contention that meant we had multiple 
	//threads trying to re-read the admin pages.
	if (m_dwStatus == NoError)
	{
		m_aAdminPages.Unlock();
		return ERROR_SUCCESS;
	}

	//Delete anything we may already have in the list in case we need to re-read it in 
	//case of an aborted transaction.
	while (m_aAdminPages.Size())
	{	
		VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[0];
		delete [] pEntry->pbPage;
		delete pEntry;
		m_aAdminPages.RemoveAt(0);
	}


	DWORD dwRes = ERROR_SUCCESS;
	if (bReReadPages)
	{
		m_dwStatus = AdminPagesNeedReading;

		DWORD dwAdminPageId = 0;	//First admin page always resides on page 0
		do
		{
			bool bDirty = false;
			BYTE *pbAdminPage = new BYTE[m_dwPageSize];
			VarObjAdminPageEntry *pEntry = new VarObjAdminPageEntry;
			if ((pbAdminPage == NULL) || (pEntry == NULL))
			{
				dwRes = ERROR_OUTOFMEMORY;
				m_dwStatus = AdminPageReadFailure;
			}

			if (dwRes == ERROR_SUCCESS)
			{
				dwRes = m_pObjectFile->GetPage(dwAdminPageId, 0, pbAdminPage);

				if ((dwRes == ERROR_FILE_NOT_FOUND) && (dwAdminPageId != 0))
				{
					_ASSERT(0, "WinMgmt: We lost the admin pages!\n");
				}

				if ((dwRes == ERROR_FILE_NOT_FOUND) && (dwAdminPageId == 0))
				{
					//This is the first attempt, so we need to create the admin page!
					dwRes = m_pObjectFile->NewPage(1, 1, &dwAdminPageId);
					if (dwRes == ERROR_SUCCESS)
					{
						//Write the default data to the admin page
						bDirty = true;	
						VarObjHeapAdminPage* pAdminPage = (VarObjHeapAdminPage*)pbAdminPage;
						pAdminPage->dwNextAdminPage = 0;
						pAdminPage->dwNumberEntriesOnPage = 0;
						pAdminPage->dwVersion = VAROBJ_VERSION;

						dwRes = m_pObjectFile->PutPage(dwAdminPageId, 0, pbAdminPage);
						if (dwRes != ERROR_SUCCESS)
						{
							m_dwStatus = RootAdminPageCreationFailure;
						}
					}
					else
					{
						m_dwStatus = RootAdminPageCreationFailure;
					}
				}
				else if ((dwAdminPageId == 0) && (dwRes != ERROR_SUCCESS))
				{
					m_dwStatus = AdminPageReadFailure;
				}
			}

			if (dwRes == ERROR_SUCCESS)
			{
				pEntry->dwPageId = dwAdminPageId;
				pEntry->pbPage = pbAdminPage;
				pEntry->bDirty = bDirty;
			}

			if ((dwRes == ERROR_SUCCESS) && (m_aAdminPages.Add(pEntry) != CFlexArray::no_error))
			{
				dwRes = ERROR_OUTOFMEMORY;
				m_dwStatus = AdminPageReadFailure;
			}

			if (dwRes == ERROR_SUCCESS)
				dwAdminPageId = ((VarObjHeapAdminPage*)pbAdminPage)->dwNextAdminPage;
			else
			{
				//Tidy up!
				delete [] pbAdminPage;
				delete pEntry;
			}
		}
		while ((dwRes == ERROR_SUCCESS) && (dwAdminPageId != 0));

		//If we had a problem we need to delete everything in the admin list
		if (dwRes != ERROR_SUCCESS)
		{
			while (m_aAdminPages.Size())
			{	
				VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[0];
				delete [] pEntry->pbPage;
				delete pEntry;
				m_aAdminPages.RemoveAt(0);
			}
		}

		if (dwRes == ERROR_SUCCESS)
		{
			m_dwStatus = NoError;
		}

	}
	m_aAdminPages.Unlock();

	return dwRes;
}

//**************************************************************************************
//FlushAdminPages - Writes each of the changed admin pages back to the object file
//**************************************************************************************
DWORD CVarObjHeap::FlushAdminPages()
{
	DWORD dwRes = ERROR_SUCCESS;
	m_aAdminPages.Lock();
	for (DWORD dwIndex = 0; dwIndex != m_aAdminPages.Size(); dwIndex++)
	{	
		VarObjAdminPageEntry * pEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwIndex];
#if DBG
		if ((dwIndex == 0) && (pEntry->dwPageId != 0))
		{
			OutputDebugString(L"WinMgmt: Repository corrupt!  First admin page should always be page 0!\n");
			DebugBreak();
		}
		VarObjHeapAdminPage *pAdminPage = (VarObjHeapAdminPage*) pEntry->pbPage;
		if ((dwIndex != 0) && (pAdminPage->dwVersion != 0))
		{
			OutputDebugString(L"WinMmgt: Repository corrupt!  Trailing admin pages should have version stamp of 0!\n");
			DebugBreak();
		}
#endif
		if (pEntry->bDirty)
			dwRes = m_pObjectFile->PutPage(pEntry->dwPageId, 0, pEntry->pbPage);
		if (dwRes == ERROR_SUCCESS)
			pEntry->bDirty = false;
		else
			break;
	}
	m_aAdminPages.Unlock();
	return dwRes;
}

//**************************************************************************************
//Find a page form the admin pages that can accomodate a particular buffer size
//**************************************************************************************
DWORD CVarObjHeap::FindPageWithSpace(/* in */ DWORD dwRequiredSize, 
									   /* out*/ DWORD *pdwPageId)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;
	
	m_aAdminPages.Lock();
	for (DWORD dwPageIndex = 0; (*pdwPageId == 0) &&  (dwPageIndex != m_aAdminPages.Size()); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));
#if DBG
		if ((dwPageIndex != 0) && (pAdminPage->dwVersion != 0))
		{
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt as version is invalid!\n");
			DebugBreak();
		}
		if (pAdminPage->dwNumberEntriesOnPage > ((m_dwPageSize - sizeof(VarObjHeapAdminPage)) / sizeof(VarObjHeapFreeList)))
		{
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt because it thinks there are more entries than fit on the page!\n");
			DebugBreak();
		}
#endif

		for (DWORD dwFreeIndex = 0; (*pdwPageId == 0) && (dwFreeIndex != pAdminPage->dwNumberEntriesOnPage); dwFreeIndex++)
		{
			if (pFreeListEntry[dwFreeIndex].dwFreeSpace >= (dwRequiredSize + sizeof(VarObjObjOffsetEntry)))
			{
				*pdwPageId = pFreeListEntry[dwFreeIndex].dwPageId;
				dwRes = ERROR_SUCCESS;
			}
		}
	}
	m_aAdminPages.Unlock();
	return dwRes;
}

//**************************************************************************************
//Allocate a new page for use with objects.  
//**************************************************************************************
DWORD CVarObjHeap::AllocateNewPage(/* in */ DWORD ulBlockSize, 
									 /* out*/ DWORD *pdwPageId, 
									 /* in */ BYTE *pbNewObjectPage)
{
	DWORD dwRes = ERROR_SUCCESS;
	
	//Allocate a new page from the object file
	if (dwRes == ERROR_SUCCESS)
		dwRes = m_pObjectFile->NewPage(0, 1, pdwPageId);

	if (dwRes != ERROR_SUCCESS)
		return dwRes;
	
	//We need to know if we get to the end without finding space because at that point
	//we need to allocate a new admin page!
	dwRes = ERROR_FILE_NOT_FOUND;

	//Find an admin page that has space for this new entry
	m_aAdminPages.Lock();
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		if ((sizeof(VarObjHeapAdminPage) + ((pAdminPage->dwNumberEntriesOnPage + 1) * sizeof(VarObjHeapFreeList))) <= m_dwPageSize)
		{
			dwRes = ERROR_SUCCESS;
			break;
		}
	}
	m_aAdminPages.Unlock();

	if (dwRes == ERROR_FILE_NOT_FOUND)
	{
		//We did not find an admin page with any additional slots available.  We need to allocate
		//a new admin page
		dwRes = ERROR_SUCCESS;

		DWORD dwNewAdminPageId = 0;

		//We need to allocate a new page in the object file
		dwRes = m_pObjectFile->NewPage(0, 1, &dwNewAdminPageId);

		//we need to allocate all the memory for the admin page cache
		BYTE *pbNewAdminPage = NULL;
		VarObjAdminPageEntry *pAdminPageEntry = NULL;
		if (dwRes == ERROR_SUCCESS)
		{
			pbNewAdminPage = new BYTE[m_dwPageSize];
			pAdminPageEntry = new VarObjAdminPageEntry;

			if ((pbNewAdminPage == NULL) || (pAdminPageEntry == NULL))
				dwRes = ERROR_OUTOFMEMORY;
		}
		if (dwRes == ERROR_SUCCESS)
		{
			if (m_aAdminPages.Add(pAdminPageEntry) != CFlexArray::no_error)
			{
				dwRes = ERROR_OUTOFMEMORY;
			}
		}
		if (dwRes != ERROR_SUCCESS)
		{
			 delete [] pbNewAdminPage;
			 delete pAdminPageEntry;
		}

		if (dwRes == ERROR_SUCCESS)
		{
			//Write the admin page entry detail
			pAdminPageEntry->dwPageId = dwNewAdminPageId;
			pAdminPageEntry->pbPage = pbNewAdminPage;
			pAdminPageEntry->bDirty = true;		//new page needs to be written!

			//Hook the previous admin page to this one (we have already added the new one remember!
			VarObjAdminPageEntry *pPreviousAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[m_aAdminPages.Size() - 2];
			VarObjHeapAdminPage *pPreviousAdminPage = (VarObjHeapAdminPage *)(pPreviousAdminPageEntry->pbPage);
			pPreviousAdminPage->dwNextAdminPage = dwNewAdminPageId;
			pPreviousAdminPageEntry->bDirty = true;	//We just changed the page so it needs to be marked for flushing

			//Initialize this new admin page with everything necessary
			VarObjHeapAdminPage *pNewAdminPage = (VarObjHeapAdminPage *)pbNewAdminPage;
			pNewAdminPage->dwNextAdminPage = 0;
			pNewAdminPage->dwNumberEntriesOnPage = 0;
			pNewAdminPage->dwVersion = 0;	//not used on anything but the first page!

			//Now we have all the details in there, we can set the index to this page so we can allocate 
			//add the new object page to it!
			dwPageIndex = m_aAdminPages.Size() - 1;
		}
	}

	//By here we now have the admin page we have space to put this new page entry!
	if (dwRes == ERROR_SUCCESS)
	{
		//cached admin page entry, update the dirty bit as we are changing it
		VarObjAdminPageEntry *pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex];
		pAdminPageEntry->bDirty = true;

		//Admin page header, update the number of entries 
		VarObjHeapAdminPage *pAdminPage = (VarObjHeapAdminPage *)pAdminPageEntry->pbPage;
		pAdminPage->dwNumberEntriesOnPage++;

		//Add the entry to the end!
		VarObjHeapFreeList *pFreeList = (VarObjHeapFreeList *)(pAdminPageEntry->pbPage + sizeof(VarObjHeapAdminPage) + (sizeof(VarObjHeapFreeList) * (pAdminPage->dwNumberEntriesOnPage - 1)));
		pFreeList->dwPageId = *pdwPageId;
		pFreeList->dwFreeSpace = m_dwPageSize - sizeof(VarObjObjOffsetEntry);
		pFreeList->dwCRC32 = 0;
		pFreeList->dwReserved = 0;

		//Now we need to need to initialize the new object page to look like an empty page
		ZeroMemory(pbNewObjectPage, sizeof(VarObjObjOffsetEntry));

	}
	return dwRes;
}

//**************************************************************************************
//Allocates a multi-page entry in the object file.  This requires
//different algorithms to work things out so is a special case
//**************************************************************************************
DWORD CVarObjHeap::AllocateMultiPageBuffer(/* in */ ULONG ulBlockSize, 
											 /* in */ const BYTE *pBlock, 
											 /* out */ ULONG *pulPageId, 
											 /* out */ ULONG *pulOffsetId)
{
	DWORD dwRes = ERROR_SUCCESS;
	
	//Whole pages calculation
	DWORD dwNumberPagesNeeded = (ulBlockSize + (sizeof(VarObjObjOffsetEntry) * 2)) / m_dwPageSize;

	//Partial page calculation
	if ((ulBlockSize + (sizeof(VarObjObjOffsetEntry) * 2) % m_dwPageSize) != 0)
		dwNumberPagesNeeded++;

	DWORD dwFirstPageId = 0;
	dwRes = m_pObjectFile->NewPage(0, dwNumberPagesNeeded, &dwFirstPageId);

	for (DWORD dwCurrentOffset = 0, dwPageIndex = 0; dwPageIndex != dwNumberPagesNeeded; dwPageIndex++)
	{
		BYTE *pPage = new BYTE[m_dwPageSize];
		if (pPage == NULL)
			dwRes = ERROR_OUTOFMEMORY;
		CVectorDeleteMe<BYTE> vdm(pPage);

		if (dwRes == ERROR_SUCCESS)
		{
			if (dwCurrentOffset == 0)
			{
				//We have to write the header for the offset page
				ZeroMemory(pPage, sizeof(VarObjObjOffsetEntry) * 2);
				VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pPage;
				pEntry->dwBlockLength = ulBlockSize;
				pEntry->dwOffsetId = 1;
				pEntry->dwPhysicalStartOffset = sizeof(VarObjObjOffsetEntry) * 2;

				DWORD dwCRC32 = CreateCRC32(pBlock, ulBlockSize);
				FINALIZE_CRC32(dwCRC32);
				pEntry->dwCRC = dwCRC32;

				//Fill the rest of this page
				CopyMemory(pPage + (sizeof(VarObjObjOffsetEntry) * 2), pBlock, m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2));
				dwCurrentOffset = m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2);
			}
			else
			{
				if (ulBlockSize - dwCurrentOffset > m_dwPageSize)
				{
					CopyMemory(pPage, pBlock + dwCurrentOffset, m_dwPageSize);
					dwCurrentOffset += m_dwPageSize;
				}
				else
				{
					CopyMemory(pPage, pBlock + dwCurrentOffset, ulBlockSize - dwCurrentOffset);
					dwCurrentOffset += (ulBlockSize - dwCurrentOffset);

					//NOTE!!!  dwCurrentOffset should equal ulBlockSize now!!!!!
				}
			}

			dwRes = m_pObjectFile->PutPage(dwFirstPageId + dwPageIndex, 0, pPage);
		}
		if (FAILED(dwRes))
			break;
	}

	if (dwRes == ERROR_SUCCESS)
	{
		//Set up the pageId and offset details the client requested
		*pulPageId = dwFirstPageId;
		*pulOffsetId = 1;
	}

	return dwRes;
}

//**************************************************************************************
//DeleteMultiPageBuffer - handles the deletion of an object when it spans
//multiple pages
//******************4********************************************************************
DWORD CVarObjHeap::DeleteMultiPageBuffer(/* in */ ULONG ulPageId, 
										   /* in */ ULONG ulOffsetId, 
										   /* in */ BYTE *pbPage)
{
	DWORD dwRes = ERROR_SUCCESS;

	//Calculate how many pages are used:
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*)pbPage;

	//Whole pages calculation
	DWORD dwNumberPagesNeeded = (pEntry->dwBlockLength + (sizeof(VarObjObjOffsetEntry) * 2)) / m_dwPageSize;

	//Partial page calculation
	if ((pEntry->dwBlockLength + (sizeof(VarObjObjOffsetEntry) * 2) % m_dwPageSize) != 0)
		dwNumberPagesNeeded++;

	for (DWORD dwPageIndex = 0; dwPageIndex != dwNumberPagesNeeded; dwPageIndex ++)
	{
		dwRes = m_pObjectFile->FreePage(0, ulPageId + dwPageIndex);

		if (FAILED(dwRes))
			break;
	}
	
	return dwRes;
}

//**************************************************************************************
//DeleteFromPage - removes an object from a specific object page
//**************************************************************************************
DWORD CVarObjHeap::RemoveFromPage(/* in */ ULONG ulPageId, 
									/* in */ ULONG ulOffsetId,
									/* in */ BYTE *pbPage,
									/* out*/ DWORD *pdwSize)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	//Need to remove the entry from the offset table, subtracting the deleted object size
	//from the offset of all items following it
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*)pbPage;
	DWORD dwFoundOffset = 0;
	DWORD dwFoundSize = 0;
	DWORD dwFoundIndex = 0;
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex ++)
	{

		if (pEntry[dwIndex].dwOffsetId == ulOffsetId)
		{
			//This is ours, so record the details
			dwFoundOffset = pEntry[dwIndex].dwPhysicalStartOffset;
			dwFoundSize = pEntry[dwIndex].dwBlockLength;
			*pdwSize = dwFoundSize;
			dwRes = ERROR_SUCCESS;
			dwFoundIndex = dwIndex;
		}
		else if (dwRes == ERROR_SUCCESS)
		{
			//We have already found it so we need to adjust this entry
			//to account for the removed space
			pEntry[dwIndex - 1].dwPhysicalStartOffset = pEntry[dwIndex].dwPhysicalStartOffset - dwFoundSize - sizeof(VarObjObjOffsetEntry);
			pEntry[dwIndex - 1].dwBlockLength = pEntry[dwIndex].dwBlockLength;
			pEntry[dwIndex - 1].dwOffsetId = pEntry[dwIndex].dwOffsetId;
			pEntry[dwIndex - 1].dwCRC = pEntry[dwIndex].dwCRC;
		}
		else
		{
			//Adjust for the fact that we are removing an entry for the offset table
			pEntry[dwIndex].dwPhysicalStartOffset -= sizeof(VarObjObjOffsetEntry);
		}
	}

	if (dwRes == ERROR_SUCCESS)
	{
		//We need to adjust the end-of-list by one place also
		pEntry[dwIndex - 1].dwPhysicalStartOffset = 0;
		pEntry[dwIndex - 1].dwBlockLength = 0;
		pEntry[dwIndex - 1].dwOffsetId = 0;
		pEntry[dwIndex - 1].dwCRC = 0;

		//Now we need to adjust all entries up to the deleted one by the size of 
		//the offset table entry... although if this was the first item in the list then there
		//is nothing to do
		if (dwFoundIndex != 0)
		{
			MoveMemory(pbPage + pEntry[0].dwPhysicalStartOffset,
				pbPage + pEntry[0].dwPhysicalStartOffset + sizeof(VarObjObjOffsetEntry), 
				dwFoundOffset - (pEntry[0].dwPhysicalStartOffset + sizeof(VarObjObjOffsetEntry)));
		}

		//Now we need to shuffle all entries that appeared after this entry back one... if this
		//was the last entry then we don't have anything to do.
		if (pEntry[dwFoundIndex].dwOffsetId != 0)
		{
			MoveMemory(pbPage + pEntry[dwFoundIndex].dwPhysicalStartOffset,
				pbPage + dwFoundOffset + dwFoundSize,
				(pEntry[dwIndex - 2].dwPhysicalStartOffset + pEntry[dwIndex - 2].dwBlockLength) - (pEntry[dwFoundIndex].dwPhysicalStartOffset));
		}

	}
	

	return dwRes;
}


//**************************************************************************************
//UpdateAdminPageForAllocate - Updates the admin page to decrement the amount
//of free space on a page by this amount ( + sizeof(VarObjObjOffsetEntry))
//**************************************************************************************
DWORD CVarObjHeap::UpdateAdminPageForAllocate(/* in */ ULONG ulPageId,
												/* in */ ULONG ulBlockSize,
												/* in */ DWORD dwNewCRC)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	//Find an admin page that has this page
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjAdminPageEntry* pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex];
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(pAdminPageEntry->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
		{
			if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
			{
				pFreeListEntry[dwEntry].dwFreeSpace -= (ulBlockSize + sizeof(VarObjObjOffsetEntry));
				pFreeListEntry[dwEntry].dwCRC32 = dwNewCRC;
				pAdminPageEntry->bDirty = true;
#if XFILES_DEBUG
				wchar_t buf[100];
				swprintf(buf, L"Page 0x%08X has allocated 0x%08X bytes.  Space left 0x%08X\n", ulPageId, ulBlockSize + sizeof(VarObjObjOffsetEntry), pFreeListEntry[dwEntry].dwFreeSpace);
				OutputDebugString(buf);
#endif
				dwRes = ERROR_SUCCESS;
				break;
			}
		}

		if (dwRes == ERROR_SUCCESS)
			break;
	}

	return dwRes;
}
//**************************************************************************************
//UpdateAdminPageForAllocate2 - Updates the admin page to set the actual free
//space on page
//**************************************************************************************
DWORD CVarObjHeap::UpdateAdminPageForAllocate2(/* in */ ULONG ulPageId,
												/* in */ ULONG ulPageFreeSpace,
												/* in */ DWORD dwNewCRC)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;

	//Find an admin page that has this page
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjAdminPageEntry* pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex];
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(pAdminPageEntry->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
		{
			if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
			{
				pFreeListEntry[dwEntry].dwFreeSpace = ulPageFreeSpace;
				pFreeListEntry[dwEntry].dwCRC32 = dwNewCRC;
				pAdminPageEntry->bDirty = true;
#if XFILES_DEBUG
				wchar_t buf[100];
				swprintf(buf, L"Page 0x%08X has allocated 0x%08X bytes.  Space left 0x%08X\n", ulPageId, ulBlockSize + sizeof(VarObjObjOffsetEntry), pFreeListEntry[dwEntry].dwFreeSpace);
				OutputDebugString(buf);
#endif
				dwRes = ERROR_SUCCESS;
				break;
			}
		}

		if (dwRes == ERROR_SUCCESS)
			break;
	}

	return dwRes;
}

//**************************************************************************************
//UpdateAdminPageForDelete - Updates the admin page for giving space back.  If the page 
//is totally empty we should delete the page altogether.  Note that the space taken
//up is sizeof(VarObjObjOffsetEntry) more than specified because of the offset entry!
//**************************************************************************************
DWORD CVarObjHeap::UpdateAdminPageForDelete(/* in */ ULONG ulPageId,
											  /* in */ ULONG ulBlockSize,
											  /* in */ DWORD dwNewCRC,
											  /* out */ bool *pbPageDeleted)
{
	DWORD dwRes = ERROR_FILE_NOT_FOUND;
	bool bFinished = false;

	//Find an admin page that has this page
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjAdminPageEntry* pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex];
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(pAdminPageEntry->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
		{
			if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
			{
				pFreeListEntry[dwEntry].dwFreeSpace += (ulBlockSize + sizeof(VarObjObjOffsetEntry));
				pFreeListEntry[dwEntry].dwCRC32 = dwNewCRC;
				dwRes = ERROR_SUCCESS;
				bFinished = true;
				pAdminPageEntry->bDirty = true;
#if XFILES_DEBUG
				wchar_t buf[100];
				swprintf(buf, L"Page 0x%08X has deallocated 0x%08X bytes.  Space left 0x%08X\n", ulPageId, ulBlockSize + sizeof(VarObjObjOffsetEntry), pFreeListEntry[dwEntry].dwFreeSpace);
				OutputDebugString(buf);
#endif

				if (pFreeListEntry[dwEntry].dwFreeSpace == (m_dwPageSize - sizeof(VarObjObjOffsetEntry)))
				{
					dwRes = RemoveEntryFromAdminPage(dwPageIndex, dwEntry);

					if (dwRes == ERROR_SUCCESS)
					{
						dwRes = m_pObjectFile->FreePage(0, ulPageId);
						*pbPageDeleted = true;
					}
				}
				break;
			}
		}
		if (bFinished)
			break;
	}

	return dwRes;
}

//**************************************************************************************
//Deletes a page, and updates the admin pages as appropriage.  If the admin page
//is now enpty we delete this admin page and update the next pointer of the previous 
//page.  We do not delete the first admin page however as it has a special pageId
//that is reserved.
//**************************************************************************************
DWORD CVarObjHeap::DeletePage(/* in */ DWORD ulPageId)
{
	DWORD dwRes = m_pObjectFile->FreePage(0, ulPageId);
	bool bFinished = false;

	if (dwRes == ERROR_SUCCESS)
	{
		dwRes = ERROR_FILE_NOT_FOUND;
		for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
		{	
			VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
			VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

			for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
			{
				if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
				{
					dwRes = RemoveEntryFromAdminPage(dwPageIndex, dwEntry);
					bFinished = true;
					break;
				}
			}
			if (bFinished)
				break;
		}
	}

	return dwRes;
}

//**************************************************************************************
//Removes an object page entry from an admin page, removing the
//admin page if it is no longer needed
//**************************************************************************************
DWORD CVarObjHeap::RemoveEntryFromAdminPage(/* in */ DWORD dwAdminPageIndex, 
											  /* in */ DWORD dwAdminPageEntry)
{
	DWORD dwRes = ERROR_SUCCESS;

	VarObjAdminPageEntry *pAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwAdminPageIndex];
	VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)pAdminPageEntry->pbPage;
	VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

	pAdminPage->dwNumberEntriesOnPage--;
	if ((pAdminPage->dwNumberEntriesOnPage == 0) && (dwAdminPageIndex != 0))
	{
		//Need to delete this admin page... update the previous pages next admin page entry
		VarObjAdminPageEntry *pPreviousAdminPageEntry = (VarObjAdminPageEntry*)m_aAdminPages[dwAdminPageIndex - 1];
		VarObjHeapAdminPage * pPreviousAdminPage = (VarObjHeapAdminPage *)pPreviousAdminPageEntry->pbPage;
		pPreviousAdminPage->dwNextAdminPage = pAdminPage->dwNextAdminPage;
		//Set the dirty bit on that page so it gets flushed!
		pPreviousAdminPageEntry->bDirty = true;
		
		//Do the actual free page of this admin page
		dwRes = m_pObjectFile->FreePage(0, pAdminPageEntry->dwPageId);

		if (dwRes == ERROR_SUCCESS)
		{
			m_aAdminPages.RemoveAt(dwAdminPageIndex);
			delete pAdminPageEntry;
		}

	}
	else if ((pAdminPage->dwNumberEntriesOnPage == 0) && (dwAdminPageIndex == 0))
	{
		//The first admin page cannot be deleted so we just ignore this
	}
	else if (pAdminPage->dwNumberEntriesOnPage != 0)
	{
		//We just need to delete the entry, so shuffle the entries about
		//in the page
		MoveMemory(&pFreeListEntry[dwAdminPageEntry], &pFreeListEntry[dwAdminPageEntry+1], sizeof(VarObjHeapFreeList) * (pAdminPage->dwNumberEntriesOnPage - dwAdminPageEntry));
	}

	return dwRes;
}

//Given a page we validate that there is in fact enough space
//for this block.  If there is not it asserts.  This implies
//that the admin page is not in sync with the actual pages.
DWORD CVarObjHeap::ValidatePageFreeSpace(/* in */ const BYTE *pbPage, 
							/* in */ DWORD ulBlockSize,
							/* out */ DWORD *pulFreeSpaceLeft)
{
	DWORD dwRes = ERROR_SUCCESS;
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pbPage;
	DWORD dwNextAvailableOffset = pEntry[0].dwPhysicalStartOffset + pEntry[0].dwBlockLength;

	//Search through the offset table until we find the last entry
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex++)
	{
		dwNextAvailableOffset = pEntry[dwIndex].dwPhysicalStartOffset + pEntry[dwIndex].dwBlockLength;
	}

	*pulFreeSpaceLeft = m_dwPageSize - dwNextAvailableOffset;

	if ((dwNextAvailableOffset + ulBlockSize + sizeof(VarObjObjOffsetEntry))> m_dwPageSize)
	{
		dwRes = ERROR_INTERNAL_ERROR;
#ifdef DBG
		OutputDebugString(L"WinMgmt Repository Corruption: Object heap admin page free space information is out of sync with actual pages!\n");
		DebugBreak();
#endif
	}
	
	return dwRes;
}

#ifdef DBG
//Given a page and a page ID, it validates the amount of free space
//on the page is equal to the amount the admin page thinks is on 
//there.
DWORD CVarObjHeap::ValidatePageFreeSpaceWithAdminPage(/* in */ const BYTE *pbPage,
													  /* in */ DWORD ulPageId)
{
	DWORD dwRes = ERROR_SUCCESS;
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pbPage;
	DWORD dwNextAvailableOffset = pEntry[0].dwPhysicalStartOffset + pEntry[0].dwBlockLength;

	//Search through the offset table until we find the last entry
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex++)
	{
		dwNextAvailableOffset = pEntry[dwIndex].dwPhysicalStartOffset + pEntry[dwIndex].dwBlockLength;
	}

	DWORD dwFreeSpace = m_dwPageSize - dwNextAvailableOffset;

	//Find the page in the admin page table	
	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		for (DWORD dwEntry = 0; dwEntry != pAdminPage->dwNumberEntriesOnPage; dwEntry ++)
		{
			//If this is the page we are interested in...
			if (ulPageId == pFreeListEntry[dwEntry].dwPageId)
			{
				//check the free space matches...
				if (pFreeListEntry[dwEntry].dwFreeSpace != dwFreeSpace)
				{
#ifdef DBG
					//Oops, it doesn't!  We have a problem!
					OutputDebugString(L"WinMgmt Repository Corruption: Free space in page is out of sink with the free space listed in admin page!\n");
					DebugBreak();
#endif
					return ERROR_INTERNAL_ERROR;
				}
				return ERROR_SUCCESS;
			}
		}
	}
	return dwRes;
}

//Dumps the offset table of a page to the debugger
DWORD CVarObjHeap::DumpPageOffsetTable(/* in */ DWORD dwPageId, 
									   /* in */ const BYTE *pbPage)
{
	wchar_t buf[100];
	OutputDebugString(L"================================\n");
	StringCchPrintfW(buf, 100, L"Dumping offset table for pageId <0x%X>\n", dwPageId);
	OutputDebugString(buf);
	OutputDebugString(L"================================\n");
	DWORD dwRes = ERROR_SUCCESS;
	VarObjObjOffsetEntry *pEntry = (VarObjObjOffsetEntry*) pbPage;
	for (DWORD dwIndex = 0; pEntry[dwIndex].dwOffsetId != 0; dwIndex++)
	{
		StringCchPrintfW(buf, 100, L"0x%08X, 0x%08X, 0x%08X, 0x%08X\n", dwIndex, pEntry[dwIndex].dwOffsetId, pEntry[dwIndex].dwBlockLength, pEntry[dwIndex].dwPhysicalStartOffset);
		OutputDebugString(buf);
	}
	StringCchPrintfW(buf, 100, L"0x%08X, 0x%08X, 0x%08X, 0x%08X\n", dwIndex, pEntry[dwIndex].dwOffsetId, pEntry[dwIndex].dwBlockLength, pEntry[dwIndex].dwPhysicalStartOffset);
	OutputDebugString(buf);
	OutputDebugString(L"================================\n");

	return ERROR_SUCCESS;
}
#endif /* DBG */

static DWORD g_CRCTable[] =
{
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

//Creates a CRC for a block
DWORD CVarObjHeap::CreateCRC32(/* in */ const BYTE *pBlock,
							   /* in */ DWORD dwSize,
							   /* in */ DWORD dwPreviousCRC)
{
    if(dwSize == 0)
        return dwPreviousCRC;

    DWORD dwNewCRC = 0;

    for (int n = 0; n < dwSize; n++)
    {
        dwNewCRC = g_CRCTable[ BYTE(dwPreviousCRC ^ DWORD(pBlock[n]))] 
            ^ ((dwPreviousCRC >> 8) & 0x00FFFFFF);
        dwPreviousCRC = dwNewCRC;            
    }
    
    return dwNewCRC;
}

#ifdef DBG
//Checks the CRCs of all objects on a page (cannot do this
//for a multi-page object though as we only have the first
//page!)
DWORD CVarObjHeap::ValidateAllCRC32OnPage(/* in */ const BYTE *pbPage)
{
	DWORD dwRes = ERROR_SUCCESS;

	//Get a pointer to the start of the offset table
	VarObjObjOffsetEntry *pOffsetEntry = (VarObjObjOffsetEntry *) pbPage;

	//Loop through the table until we find the one we are interested in
	for (DWORD dwOffsetIndex = 0; pOffsetEntry[dwOffsetIndex].dwOffsetId != 0; dwOffsetIndex++)
	{
		if (pOffsetEntry[dwOffsetIndex].dwBlockLength > (m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2)))
		{
			break;
		}
		else
		{
			try 
			{
				DWORD dwNewCRC32 = CreateCRC32(pbPage + pOffsetEntry[dwOffsetIndex].dwPhysicalStartOffset, pOffsetEntry[dwOffsetIndex].dwBlockLength);
				FINALIZE_CRC32(dwNewCRC32);
				if (dwNewCRC32 != pOffsetEntry[dwOffsetIndex].dwCRC)
				{
#ifdef DBG
					OutputDebugString(L"WinMgmt: Page Check: CRC check on an object retrieved from repository is invalid\n");
					DebugBreak();
#endif
					dwRes = ERROR_INTERNAL_ERROR;
				}

			}
			catch (...)
			{
#ifdef DBG
				OutputDebugString(L"WinMgmt: Page Check: CRC check on an object retrieved from repository is invalid\n");
				DebugBreak();
#endif
				dwRes = ERROR_INTERNAL_ERROR;
			}
		}
	}
	return dwRes;
}

//Validates the page check-sum with the admin page
DWORD CVarObjHeap::ValidatePageCRCWithAdminPage(/* in */ const BYTE *pbPage,
								   /* in */ DWORD dwPageId)
{
	DWORD dwCRC32 = 0;
	dwCRC32 = CreateCRC32(pbPage, m_dwPageSize);
	FINALIZE_CRC32(dwCRC32);

	for (DWORD dwPageIndex = 0; dwPageIndex != m_aAdminPages.Size(); dwPageIndex++)
	{	
		VarObjHeapAdminPage * pAdminPage = (VarObjHeapAdminPage *)(((VarObjAdminPageEntry*)m_aAdminPages[dwPageIndex])->pbPage);
		VarObjHeapFreeList *pFreeListEntry = (VarObjHeapFreeList *)(((BYTE*)pAdminPage) + sizeof (VarObjHeapAdminPage));

		if ((dwPageIndex != 0) && (pAdminPage->dwVersion != 0))
		{
#ifdef DBG
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt as version is invalid!\n");
			DebugBreak();
#endif
			return ERROR_INTERNAL_ERROR;
		}
		if (pAdminPage->dwNumberEntriesOnPage > ((m_dwPageSize - sizeof(VarObjHeapAdminPage)) / sizeof(VarObjHeapFreeList)))
		{
#ifdef DBG
			OutputDebugString(L"WinMgmt: Repository admin page is corrupt because it thinks there are more entries than fit on the page!\n");
			DebugBreak();
#endif
			return ERROR_INTERNAL_ERROR;
		}

		for (DWORD dwFreeIndex = 0; dwFreeIndex != pAdminPage->dwNumberEntriesOnPage; dwFreeIndex++)
		{
			if (pFreeListEntry[dwFreeIndex].dwPageId == dwPageId)
			{
				if (pFreeListEntry[dwFreeIndex].dwCRC32 == 0)
					return ERROR_SUCCESS;
				else if (pFreeListEntry[dwFreeIndex].dwCRC32 == dwCRC32)
					return ERROR_SUCCESS;
				else
				{
#ifdef DBG
					OutputDebugString(L"WinMgmt: Repository admin page has an invalid CRC for the object page!\n");
					DebugBreak();
#endif
					return ERROR_INTERNAL_ERROR;
				}
			}
		}
	}
#ifdef DBG
	OutputDebugString(L"WinMgmt: Requested page was not found in the admin page list!\n");
	DebugBreak();
#endif
	return ERROR_INTERNAL_ERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\varobjheap.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    VarObjHeap.H

Abstract:

    Implements the storage of variable length objects over the top of of a fixed
	length page system. It keeps a set of admin pages for holding the pages active
	by this subsystem, along with how much space is used on each.  When a page becomes
	empty it frees up the page to the page system.  It also deals with blocks that span
	multiple pages

History:
	paulall		02-Feb-2001		Created  

--*/

#include <unk.h>
#include <arrtempl.h>
#include <statsync.h>

class CPageFile;
class CPageSource;

#define VAROBJ_VERSION 1

//**************************************************************************************
//VarObjAdminPageEntry - This is a structure that is stored within the
//m_aAdminPages cache.  It has an entry for each of the admin pages
//that we cache.  It stores the PageId (0 for the first one!), 
//pointer to the actual page, and a flag to determine if we need to
//flush it next time around.
//**************************************************************************************
typedef struct _VarObjAdminPageEntry
{
	DWORD dwPageId;
	BYTE *pbPage;
	bool bDirty;
} VarObjAdminPageEntry;

//**************************************************************************************
//VarObjObjOffsetEntry: There is an array of these objects stored at the 
//start of the object page to point out where each object is stored.
//If this is a continuation block we do not have one of these, however
//continuation blocks have consecutive pageIds so it should be fairly easy 
//to conclude
//**************************************************************************************
typedef struct _VarObjObjOffsetEntry
{
	DWORD dwOffsetId;
	DWORD dwPhysicalStartOffset;
	DWORD dwBlockLength;
	DWORD dwCRC;
} VarObjObjOffsetEntry;

//**************************************************************************************
//VarObjHeapAdminPage - This is the header of each of the admin pages
//that are stored in the object file.  The version is only relevant 
//in the first page (page 0).  The last entry is a buffer to make 
//it 4-DWORD structure rather than 3.  May use it at a later date.
//Should always set it to 0 for now.
//**************************************************************************************
typedef struct _VarObjHeapAdminPage
{
	DWORD dwVersion;
	DWORD dwNextAdminPage;
	DWORD dwNumberEntriesOnPage;

	//VarObjHeapFreeList aFreeListEntries[dwNumberEntriesOnPage];
} VarObjHeapAdminPage;


//**************************************************************************************
//VarObjHeapFreeList - This structure follows the admin page header
//and there is an entry for each page we use to store objects.  The
//page may not be full, so we do not shuffle items on a second page
//to this page when we delete an entry.
//**************************************************************************************
typedef struct _VarObjHeapFreeList
{
	DWORD dwPageId;
	DWORD dwFreeSpace;
	DWORD dwCRC32;
	DWORD dwReserved;
} VarObjHeapFreeList;

//**************************************************************************************
//CVarObjHeap - This is the implementation of the variable sized object store
//over the top of the transacted fixed page manager.  It tracks the admin pages
//that hold all pages we use to store objects in (it caches these pages), and
//also manages cases when an object is too big to fit on a single page.
//**************************************************************************************
class CVarObjHeap
{
private:
	//Current status of admin page
	enum 
	{ 
		NoError = 0, 
		AdminPageReadFailure = 1, 
		RootAdminPageCreationFailure = 2,
		AdminPagesNeedReading = 3
	} m_dwStatus;

	//Pointer to the transacted file for the object storage
	CPageFile *m_pObjectFile;

	//Page size used within the object storage file.
	DWORD m_dwPageSize;


	//Admin page structure
	CLockableFlexArray<CStaticCritSec> m_aAdminPages;

protected:
	//Adds an allocation to the end of the existing allocations
	DWORD AllocateFromPage(/* in */ DWORD dwPageId, 
							 /* in */ BYTE *pbPage,
							 /* in */ ULONG ulBlockSize, 
							 /* in */ const BYTE *pBlock, 
							 /* out*/ ULONG *pdwNewOffset);

	//Allocates a multi-page entry in the object file.  This requires
	//different algorithms to work things out so is a special case
	DWORD AllocateMultiPageBuffer(/* in */ ULONG ulBlockSize, 
									/* in */ const BYTE *pBlock, 
									/* out */ ULONG *pulPageId, 
									/* out */ ULONG *pulOffsetId);

	//Given and offsetId and a page, calculate the physical pointer to the object and also 
	//return the size of the block
	DWORD OffsetToPointer(/* in */ ULONG ulOffsetId, 
							/* in */ BYTE *pbPage, 
							/* out*/ BYTE **pOffsetPointer, 
							/* out*/ ULONG *pdwBlockSize,
							/* out*/ DWORD *pdwCRC32);

	//Reads the admin pages into memory and marks them as clean (no changes)
	//setting bReReadPages to false has an affect of clearing the pages out
	DWORD ReadAdminPages(CPageSource *pTransactionManager, bool bReReadPages);

	//Writes each of the changed admin pages back to the object file
	DWORD FlushAdminPages();

	//Find a page form the admin pages that can accomodate a particular buffer size
	DWORD FindPageWithSpace(/* in */ DWORD dwRequiredSize, 
							  /* out*/ DWORD *pdwPageId);

	//Allocate a new page for use with objects.  A buffer for the new page is passed
	//in, however the PageId of this page is passed out
	DWORD AllocateNewPage(/* in */ DWORD ulBlockSize, 
							/* out*/ DWORD *dwPageId, 
							/* in */ BYTE *pbNewObjectPage);

	//Deletes a page, and updates the admin pages as appropriage
	DWORD DeletePage(/* in */ DWORD ulPageId);

	//DeleteFromPage - removes an object from a specific object page
	DWORD RemoveFromPage(/* in */ ULONG ulPageId, 
						   /* in */ ULONG ulOffsetId,
						   /* in */ BYTE *pbPage,
						   /* out*/ DWORD *pdwSize);

	//MultiPageObject - returns true if the provided page is the first page
	//of a multi-page object
	bool MultiPageObject(/* in */ BYTE *pbPage) { return ((VarObjObjOffsetEntry*) pbPage)->dwBlockLength > (m_dwPageSize - (sizeof(VarObjObjOffsetEntry) * 2)); }

	//DeleteMultiPageBuffer - handles the deletion of an object when it spans
	//multiple pages
	DWORD DeleteMultiPageBuffer(/* in */ ULONG ulPageId, 
								  /* in */ ULONG ulOffsetId, 
								  /* in */ BYTE *pbPage);

	//UpdateAdminPageForAllocate - Updates the admin page to decrement the amount
	//of free space on a page by this amount ( + sizeof(VarObjObjOffsetEntry))
	DWORD UpdateAdminPageForAllocate(/* in */ ULONG ulPageId,
									   /* in */ ULONG ulBlockSize,
									   /* in */ DWORD dwCRC32);
	DWORD UpdateAdminPageForAllocate2(/* in */ ULONG ulPageId,
									   /* in */ ULONG ulFreeSpaceOnPage,
									   /* in */ DWORD dwCRC32);

	//UpdateAdminPageForDelete - Updates the admin page for giving space back.  If 
	//the page is totally empty we should delete the page altogether
	DWORD UpdateAdminPageForDelete(/* in */ ULONG ulPageId,
									 /* in */ ULONG ulBlockSize,
									 /* in */ DWORD dwCRC32,
									 /* out */ bool *pbPageDeleted);

	//Removes an object page entry from an admin page, removing the
	//admin page if it is no longer needed
	DWORD RemoveEntryFromAdminPage(/* in */ DWORD dwAdminPageIndex, 
								     /* in */ DWORD dwAdminPageEntry);

	//Returns a CRC based on a given block of memory
	#define FINALIZE_CRC32(x)    (x=~x)
	DWORD CreateCRC32(/* in */ const BYTE *pBlock,
					  /* in */ DWORD dwSize,
					  /* in */ DWORD dwPreviousCRC = (DWORD) -1);	 // Must be 0xFFFFFFFF if no previous CRC

	//Given a page we validate that there is in fact enough space
	//for this block.  If there is not it asserts.  This implies
	//that the admin page is not in sync with the actual pages.
	DWORD ValidatePageFreeSpace(/* in */ const BYTE *pbPage, 
								/* in */ DWORD ulBlockSize,
								/* out */ DWORD *pulFreeSpaceLeftOnPage);

#ifdef DBG
	//Given a page and a page ID, it validates the amount of free space
	//on the page is equal to the amount the admin page thinks is on 
	//there.
	DWORD ValidatePageFreeSpaceWithAdminPage(/* in */ const BYTE *pbPage,
											 /* in */ DWORD ulPageId);

	//Dumps the offset table of a page to the debugger
	DWORD DumpPageOffsetTable(/* in */ DWORD dwPageId, 
							  /* in */ const BYTE *pbPage);
	
	//Checks the CRCs of all objects on a page (cannot do this
	//for a multi-page object though as we only have the first
	//page!)
	DWORD ValidateAllCRC32OnPage(/* in */ const BYTE *pbPage);

	//Validates the page check-sum with the admin page
	DWORD ValidatePageCRCWithAdminPage(/* in */ const BYTE *pbPage,
									   /* in */ DWORD dwPageId);
#endif /* DBG */

public:
	CVarObjHeap();
	~CVarObjHeap();

	DWORD Initialize(CPageSource *pPageManager);
	DWORD Shutdown(DWORD dwShutdownType);

	//Re-read admin pages
	DWORD InvalidateCache();

	//Discard admin pages
	DWORD FlushCaches();

	//ReadBuffer pages the virtual page and offset of the block and returns a new[]-ed block
	DWORD ReadBuffer(/* in */ ULONG ulPageId, 
					   /* in */ ULONG ulOffsetId, 
					   /* out */ BYTE **ppReturnedBlock,
					   /* out */ DWORD *pdwBlockSize);

	//WriteNewBuffer will write a new page based on size of BYTE *, and return the
	//new virtual pageId and offsetId of the block.
	DWORD WriteNewBuffer(/* in */ ULONG ulBlockSize, 
						   /* in */ const BYTE *pBlock, 
						   /* out */ ULONG *pulPageId, 
						   /* out */ ULONG *pulOffsetId);

	//WriteExistingBuffer will update an existing block with new data.  The old virtual page 
	//and offset are passed in, and new ones are returned.  They may or may not be the same
	//depending on if it still fits in the page or not.
	DWORD WriteExistingBuffer(/* in */ ULONG ulBlockSize, 
							    /* in */ const BYTE *pBlock, 
								/* in */ ULONG ulOldPageId, 
								/* in */ ULONG ulOldOffsetId, 
								/* out */ ULONG *pulNewPageId, 
								/* out */ ULONG *pulNewOffsetId);

	//DeleteBuffer is called to delete the item in the store given the virtual pageId and 
	//offsetId.
	DWORD DeleteBuffer(/* in */ ULONG ulPageId, 
					     /* in */ ULONG ulOffsetId);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\win9xsecurity.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    Win9xSecurity.cpp

Abstract:

	This class handles the importing of Win9x security data that was extracted from an old MMF format repository.

History:

	03/17/2001	shbrown - created

--*/
#include "precomp.h"
#include <wbemcomn.h>
#include "Win9xSecurity.h"
#include <oahelp.inl>

bool CWin9xSecurity::Win9xBlobFileExists()
{
	CFileName wszFilePath;
	if (wszFilePath == NULL)
		return false;
	
	if (!GetRepositoryDirectory(wszFilePath))
		return false;

	StringCchCatW(wszFilePath, wszFilePath.Length(), BLOB9X_FILENAME);
	DWORD dwAttributes = GetFileAttributesW(wszFilePath);
	if (dwAttributes != -1)
	{
		DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
						FILE_ATTRIBUTE_DIRECTORY |
						FILE_ATTRIBUTE_OFFLINE |
						FILE_ATTRIBUTE_REPARSE_POINT |
						FILE_ATTRIBUTE_SPARSE_FILE;

		if (!(dwAttributes & dwMask))
			return true;
	}
	return false;
}


HRESULT CWin9xSecurity::ImportWin9xSecurity()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

	CFileName wszFilePath;
	if (wszFilePath == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	if (GetRepositoryDirectory(wszFilePath))
	{
		StringCchCatW(wszFilePath, wszFilePath.Length(), BLOB9X_FILENAME);
	    m_h9xBlobFile = CreateFileW(wszFilePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	}

	// get a session and begin a transaction
    CSession* pSession = new CSession(m_pControl);
	if (pSession == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pSession->AddRef();
    CReleaseMe relMe(pSession);

    hRes = pSession->BeginWriteTransaction(0);
    if (FAILED(hRes))
    {
        return hRes;
    }

	// process the file
    if (m_h9xBlobFile != INVALID_HANDLE_VALUE)
    {
		try
		{
			hRes = DecodeWin9xBlobFile();
		}
		catch (...)
		{
			ERRORTRACE((LOG_WBEMCORE, "Traversal of Win9x security data import file failed\n"));
			hRes = WBEM_E_FAILED;
		}
        CloseHandle(m_h9xBlobFile);
    }
    else
    {
		ERRORTRACE((LOG_WBEMCORE, "Could not open the Win9x security data import file for reading\n"));
		hRes = WBEM_E_FAILED;
    }

    if (SUCCEEDED(hRes))
	{
		if (DeleteWin9xBlobFile())
			hRes = pSession->CommitTransaction(0);
		else
		{
			ERRORTRACE((LOG_WBEMCORE, "Win9x security data import completed but failed to delete import file\n"));
			pSession->AbortTransaction(0);
			hRes = WBEM_E_FAILED;
		}
	}
	else
	{
		ERRORTRACE((LOG_WBEMCORE, "Win9x security data import failed to complete\n"));
		pSession->AbortTransaction(0);
	}

    return hRes;
}

HRESULT CWin9xSecurity::DecodeWin9xBlobFile()
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	// read the file header
	if (!ReadWin9xHeader())
		return WBEM_E_FAILED;

	// import the file
	BLOB9X_SPACER header;
	DWORD dwSize;
	while (hRes == WBEM_S_NO_ERROR)
	{
		// this loop will be exited when we either...
		// - successfully process the whole import file, or
		// - encounter an error

		dwSize = 0;
		if ((ReadFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
		{
			hRes = WBEM_E_FAILED;
		}
		else if ((header.dwSpacerType == BLOB9X_TYPE_SECURITY_INSTANCE) ||
				 (header.dwSpacerType == BLOB9X_TYPE_SECURITY_BLOB))
		{
			hRes = ProcessWin9xBlob(&header);
		}
		else if (header.dwSpacerType == BLOB9X_TYPE_END_OF_FILE)
		{
			break;
		}
		else
		{
			hRes = WBEM_E_FAILED;
		}
	}

	if (SUCCEEDED(hRes))
		hRes = RecursiveInheritSecurity(NULL, L"root");	// force namespaces to inherit their inheritable security settings

	return hRes;
}

bool CWin9xSecurity::ReadWin9xHeader()
{
	BLOB9X_HEADER header;
    DWORD dwSize = 0;
    if ((ReadFile(m_h9xBlobFile, &header, sizeof(header), &dwSize, NULL) == 0) || (dwSize != sizeof(header)))
    {
		ERRORTRACE((LOG_WBEMCORE, "Failed to retrieve the Win9x import file header information\n"));
		return false;
    }

	if (strncmp(header.szSignature, BLOB9X_SIGNATURE, 9) != 0)
    {
		ERRORTRACE((LOG_WBEMCORE, "The import file is not a Win9x import file\n"));
		return false;
    }

	return true;
}

HRESULT CWin9xSecurity::ProcessWin9xBlob(BLOB9X_SPACER* pHeader)
{
	if (pHeader->dwNamespaceNameSize == 0)
	{
		ERRORTRACE((LOG_WBEMCORE, "Namespace name size is zero in Win9x import blob\n"));
		return WBEM_E_FAILED;
	}

	if (pHeader->dwBlobSize == 0)
	{
		ERRORTRACE((LOG_WBEMCORE, "Blob size is zero in Win9x import blob\n"));
		return WBEM_E_FAILED;
	}

	// read the namespace name
	wchar_t* wszNamespaceName = new wchar_t[pHeader->dwNamespaceNameSize];
	if (!wszNamespaceName)
		return WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> delMe1(wszNamespaceName);
	DWORD dwSize = 0;
	if ((ReadFile(m_h9xBlobFile, wszNamespaceName, pHeader->dwNamespaceNameSize, &dwSize, NULL) == 0) || (dwSize != pHeader->dwNamespaceNameSize))
		return WBEM_E_FAILED;

	// read the parent namespace name if it exists
	wchar_t* wszParentClass = NULL;
	if (pHeader->dwParentClassNameSize)
	{
		wszParentClass = new wchar_t[pHeader->dwParentClassNameSize];
		if (!wszParentClass)
			return WBEM_E_OUT_OF_MEMORY;
		dwSize = 0;
		if ((ReadFile(m_h9xBlobFile, wszParentClass, pHeader->dwParentClassNameSize, &dwSize, NULL) == 0) || (dwSize != pHeader->dwParentClassNameSize))
		{
			delete [] wszParentClass;
			return WBEM_E_FAILED;
		}
	}
	CVectorDeleteMe<wchar_t> delMe2(wszParentClass);

	// read in the blob
    char* pObjectBlob = new char[pHeader->dwBlobSize];
	if (!pObjectBlob)
		return WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<char> delMe3(pObjectBlob);
	dwSize = 0;
	if ((ReadFile(m_h9xBlobFile, pObjectBlob, pHeader->dwBlobSize, &dwSize, NULL) == 0) || (dwSize != pHeader->dwBlobSize))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to read Win9x security blob for namespace %S\n", wszNamespaceName));
		return WBEM_E_FAILED;
	}

	// get handle to the namespace so it can be used below
	CNamespaceHandle* pNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pNamespaceHandle->AddRef();
    CReleaseMe relme(pNamespaceHandle);

	HRESULT hRes = pNamespaceHandle->Initialize(wszNamespaceName);
	if (SUCCEEDED(hRes))
	{
		// process the blob according to its type
		if (pHeader->dwSpacerType == BLOB9X_TYPE_SECURITY_INSTANCE)
			hRes = ProcessWin9xSecurityInstance(pNamespaceHandle, wszParentClass, pObjectBlob, pHeader->dwBlobSize);
		else // (pHeader->dwSpacerType == BLOB9X_TYPE_SECURITY_BLOB)
			hRes = ProcessWin9xSecurityBlob(pNamespaceHandle, wszNamespaceName, pObjectBlob);
	}
	return hRes;
}

HRESULT CWin9xSecurity::ProcessWin9xSecurityInstance(CNamespaceHandle* pNamespaceHandle, wchar_t* wszParentClass, char* pObjectBlob, DWORD dwBlobSize)
{
	// get parent class from the repository
    _IWmiObject* pParentClass = 0;
    HRESULT hRes = pNamespaceHandle->GetObjectByPath(wszParentClass, 0, IID_IWbemClassObject, (LPVOID*)&pParentClass);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to retrieve class %S from the repository; HRESULT = %#lx\n", wszParentClass, hRes));
		return hRes;
	}
    CReleaseMe relMe1(pParentClass);

	// merge object blob with parent class to produce instance
    _IWmiObject* pInstance = 0;
	hRes = pParentClass->Merge(WMIOBJECT_MERGE_FLAG_INSTANCE, dwBlobSize, pObjectBlob, &pInstance);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Unable to merge instance; HRESULT = %#lx\n", hRes));
		return hRes;
	}
    CReleaseMe relMe2(pInstance);

	// convert security class instance to ACE
    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", wszParentClass) == 0)
        bGroup = true;

    CNtAce* pAce = ConvertOldObjectToAce(pInstance, bGroup);
    if(!pAce)
    {
		ERRORTRACE((LOG_WBEMCORE, "Unable to convert old security instance to ACE"));
		return WBEM_E_FAILED;
	}
	CDeleteMe<CNtAce> delMe(pAce);

	// store the ACE
	hRes = StoreAce(pAce);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Unable to store ACE; HRESULT = %#lx\n", hRes));
		return hRes;
	}

	return hRes;
}

// this function was stolen from coredll\secure.cpp with minor modifications to remove calls to IsNT()
CNtAce* CWin9xSecurity::ConvertOldObjectToAce(_IWmiObject* pObj, bool bGroup)
{
    // Get the properties out of the old object

    CVARIANT vName;
    if (pObj->Get(L"Name", 0, &vName, 0, 0) != 0)
    	return NULL;
    LPWSTR pName = NULL;
    if(vName.GetType() != VT_BSTR)
        return NULL;                // ignore this one.
    pName = LPWSTR(vName);

    CVARIANT vDomain;
    LPWSTR pDomain = L".";
    if (pObj->Get(L"Authority", 0, &vDomain, 0, 0) != 0)
    {
    	return NULL;
    }
    if(vDomain.GetType() == VT_BSTR)
        pDomain = LPWSTR(vDomain);

    bool bEditSecurity = false;
    bool bEnabled = false;
    bool bExecMethods = false;

    DWORD dwMask = 0;
    CVARIANT vEnabled;
    CVARIANT vEditSecurity;
    CVARIANT vExecMethods;
    CVARIANT vPermission;

    pObj->Get(L"Enabled", 0, &vEnabled, 0, 0);
    pObj->Get(L"EditSecurity", 0, &vEditSecurity, 0, 0);
    pObj->Get(L"ExecuteMethods", 0, &vExecMethods, 0, 0);
    pObj->Get(L"Permissions", 0, &vPermission, 0, 0);

    if (vEnabled.GetType() != VT_NULL && vEnabled.GetBool())
        bEnabled = true;

    if (vEditSecurity.GetType() != VT_NULL && vEditSecurity.GetBool())
        bEditSecurity = true;

    if (vExecMethods.GetType() != VT_NULL && vExecMethods.GetBool())
        bExecMethods = true;

    DWORD dwPermission = 0;
    if (vPermission.GetType() != VT_NULL && vPermission.GetLONG() > dwPermission)
            dwPermission = vPermission.GetLONG();

    // Now translate the old settings into new ones
    if(bEnabled)
        dwMask = WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER;

    if(bEditSecurity)
        dwMask |= READ_CONTROL;

    if(bEditSecurity && dwPermission > 0)
        dwMask |= WRITE_DAC;

    if(bExecMethods)
        dwMask |= WBEM_METHOD_EXECUTE;

    if(dwPermission >= 1)
        dwMask |= WBEM_PARTIAL_WRITE_REP;

    if(dwPermission >= 2)
        dwMask |= WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | WBEM_WRITE_PROVIDER;


    // By default, CNtSid will look up the group name from either the local machine,
    // the domain, or a trusted domain.  So we need to be explicit

    WString wc;
    if(pDomain)
        if(wbem_wcsicmp(pDomain, L"."))
        {
            wc = pDomain;
            wc += L"\\";
        }
    wc += pName;

    // under m1, groups that were not enabled were just ignored.  Therefore the bits
    // cannot be transfer over since m3 has allows and denies, but no noops.  Also,
    // win9x doesnt have denies, do we want to noop those users also.

    if(!bEnabled && bGroup)
        dwMask = 0;

    // In general, m1 just supported allows.  However, a user entry that was not enabled was
    // treated as a deny.  Note that win9x does not allow actual denies.

    DWORD dwType = ACCESS_ALLOWED_ACE_TYPE;
    if(!bGroup && !bEnabled)
    {
        dwMask |= (WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER);
        dwType = ACCESS_DENIED_ACE_TYPE;
    }

    CNtSid Sid(wc, NULL);
    if(Sid.GetStatus() != CNtSid::NoError)
    {
        ERRORTRACE((LOG_WBEMCORE, "Error converting m1 security ace, name = %S, error = 0x%x", wc, Sid.GetStatus()));
        return NULL;
    }
    CNtAce * pace = new CNtAce(dwMask, dwType, CONTAINER_INHERIT_ACE, Sid);
    return pace;
}

HRESULT CWin9xSecurity::StoreAce(CNtAce* pAce)
{
	// get handle to the root namespace
	CNamespaceHandle* pRootNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pRootNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pRootNamespaceHandle->AddRef();
    CReleaseMe relme1(pRootNamespaceHandle);
	HRESULT hRes = pRootNamespaceHandle->Initialize(L"root");
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to connect to namespace; HRESULT = %#lx\n", hRes));
		return hRes;
	}

	// get root namespace SD
	CNtSecurityDescriptor sdRoot;
	hRes = GetSDFromNamespace(pRootNamespaceHandle, sdRoot);
	if (FAILED(hRes))
		return hRes;

    // Delete all entries in the SD with the same name
    wchar_t* wszAccountName;
    hRes = pAce->GetFullUserName2(&wszAccountName);
    if(FAILED(hRes))
		return hRes;    
    CVectorDeleteMe<wchar_t> delMe(wszAccountName);

	if (!StripMatchingEntries(sdRoot, wszAccountName))
		return WBEM_E_FAILED;

	// add in the new security
	if (!AddAceToSD(sdRoot, pAce))
		return WBEM_E_FAILED;

	// set the security
	hRes = SetNamespaceSecurity(pRootNamespaceHandle, sdRoot);

	return hRes;
}

bool CWin9xSecurity::StripMatchingEntries(CNtSecurityDescriptor& sd, const wchar_t* wszAccountName)
{
    // Get the DACL
    CNtAcl* pAcl;
    pAcl = sd.GetDacl();
    if(!pAcl)
        return false;
    CDeleteMe<CNtAcl> dm(pAcl);

    // enumerate through the aces
    DWORD dwNumAces = pAcl->GetNumAces();
    BOOL bChanged = FALSE;
	HRESULT hRes = WBEM_S_NO_ERROR;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce* pAce = pAcl->GetAce(nIndex);
        if(pAce)
        {
			wchar_t* wszAceListUserName;
			hRes = pAce->GetFullUserName2(&wszAceListUserName);
			if(FAILED(hRes))
				return false;
			CVectorDeleteMe<wchar_t> delMe(wszAceListUserName);

			if(wbem_wcsicmp(wszAceListUserName, wszAccountName) == 0)
			{
				if (!pAcl->DeleteAce(nIndex))
					return false;
				bChanged = TRUE;
			}
        }
    }

    if(bChanged)
	{
        if (!sd.SetDacl(pAcl))
			return false;
	}

    return true;
}

bool CWin9xSecurity::AddAceToSD(CNtSecurityDescriptor& sd, CNtAce* pAce)
{
    CNtAcl* pacl = sd.GetDacl();
    if(!pacl)
        return false;
    CDeleteMe<CNtAcl> delMe(pacl);

	if (!pacl->AddAce(pAce))
		return false;

	if (!sd.SetDacl(pacl))
		return false;

	return true;
}

HRESULT CWin9xSecurity::ProcessWin9xSecurityBlob(CNamespaceHandle* pNamespaceHandle, const wchar_t* wszNamespaceName, const char* pObjectBlob)
{
	HRESULT hRes = WBEM_S_NO_ERROR;

	// convert the Win9x security blob into a more proper NT security blob
	char* pNsSecurity = NULL;
	if (!ConvertSecurityBlob(pObjectBlob, &pNsSecurity))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to convert Win9x security blob for namespace %S\n", wszNamespaceName));
		return WBEM_E_FAILED;
	}
	CVectorDeleteMe<char> delMe1(pNsSecurity);

	// get the parent namespace name, and if a parent exists, get a pointer to it so it can be used below
	CNamespaceHandle* pParentNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pParentNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pParentNamespaceHandle->AddRef();
    CReleaseMe relme(pParentNamespaceHandle);

	size_t dwParentNamespaceNameLen = wcslen(wszNamespaceName)+1;
	wchar_t* wszParentNamespaceName = new wchar_t[dwParentNamespaceNameLen];
	if (!wszParentNamespaceName)
		return WBEM_E_OUT_OF_MEMORY;
	CVectorDeleteMe<wchar_t> delMe2(wszParentNamespaceName);

	StringCchCopyW(wszParentNamespaceName, dwParentNamespaceNameLen, wszNamespaceName);
	wchar_t* pSlash = wcsrchr(wszParentNamespaceName, '\\');
	bool bRoot = true;
	if (pSlash)
	{
		bRoot = false;
		*pSlash = L'\0';
		hRes = pParentNamespaceHandle->Initialize(wszParentNamespaceName);
		if (FAILED(hRes))
			return hRes;
	}

	// now transform the old security blob that consisted of a header and array of ACE's
	// into a proper Security Descriptor that can be stored in the property
	CNtSecurityDescriptor mmfNsSD;
	hRes = TransformBlobToSD(bRoot, pParentNamespaceHandle, pNsSecurity, 0, mmfNsSD);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to convert security blob to SD for namespace %S\n", wszNamespaceName));
		return hRes;
	}

	// now set the security
	hRes = SetNamespaceSecurity(pNamespaceHandle, mmfNsSD);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to set namespace security for namespace %S\n", wszNamespaceName));
		return hRes;
	}

	return hRes;
}

bool CWin9xSecurity::ConvertSecurityBlob(const char* pOrgNsSecurity, char** ppNewNsSecurity)
{
	// convert an old Win9x pseudo-blob into a blob with NT-style ACE's

	if (!pOrgNsSecurity || !ppNewNsSecurity)
		return false;

    DWORD* pdwData = (DWORD*)pOrgNsSecurity;
    DWORD dwSize = *pdwData;

    pdwData++;
    DWORD dwVersion = *pdwData;

    if(dwVersion != 1 || dwSize == 0 || dwSize > 64000)
	{
		ERRORTRACE((LOG_WBEMCORE, "Invalid security blob header\n"));
		return false;
	}

    pdwData++;
    DWORD dwStoredAsNT = *pdwData;
	if (dwStoredAsNT)
	{
		ERRORTRACE((LOG_WBEMCORE, "NT security blob detected; should be Win9x\n"));
		return false;
	}

    CFlexAceArray AceList;
    if (!AceList.DeserializeWin9xSecurityBlob(pOrgNsSecurity))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to deserialize a Win9x security blob\n"));
		return false;
	}
	
	// serialize the new WinNT blob
	if (!AceList.SerializeWinNTSecurityBlob(ppNewNsSecurity))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to serialize a WinNT security blob\n"));
		return false;
	}
	return true;
}

HRESULT CWin9xSecurity::TransformBlobToSD(bool bRoot, CNamespaceHandle* pParentNamespaceHandle, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD)
{
	// now transform the old security blob that consisted of a header and array of ACE's
	// into a proper Security Descriptor that can be stored in the property

	// build up an ACL from our blob, if we have one
	CNtAcl acl;

	if (pNsSecurity)
	{
		DWORD* pdwData = (DWORD*) pNsSecurity;
		pdwData += 3;
		int iAceCount = (int)*pdwData;
		pdwData += 2;
		BYTE* pAceData = (BYTE*)pdwData;

		PGENERIC_ACE pAce = NULL;
		for (int iCnt = 0; iCnt < iAceCount; iCnt++)
		{
			pAce = (PGENERIC_ACE)pAceData;
			if (!pAce)
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to access GENERIC_ACE within security blob\n"));
				return WBEM_E_FAILED;
			}

			CNtAce ace(pAce);
			if(ace.GetStatus() != 0)
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to construct CNtAce from GENERIC_ACE\n"));
				return WBEM_E_FAILED;
			}

			acl.AddAce(&ace);
			if (acl.GetStatus() != 0)
			{
				ERRORTRACE((LOG_WBEMCORE, "Failed to add ACE to ACL\n"));
				return WBEM_E_FAILED;
			}

			pAceData += ace.GetSize();
		}
	}

	// for Win9x, the security blob for ROOT would not have had any default
	// root aces for administrators and everyone, so create them
    if (bRoot)
    {
		if (!AddDefaultRootAces(&acl))
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to create default root ACE's\n"));
			return WBEM_E_FAILED;
		}
	}

	// a real SD was constructed and passed in by reference, now set it up properly
	if (!SetOwnerAndGroup(mmfNsSD))
		return WBEM_E_FAILED;
	mmfNsSD.SetDacl(&acl);
	if (mmfNsSD.GetStatus() != 0)
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to convert namespace security blob to SD\n"));
		return WBEM_E_FAILED;
	}

	// add in the parent's inheritable aces, if this is not ROOT
	if (!bRoot)
	{
		HRESULT hRes = GetParentsInheritableAces(pParentNamespaceHandle, mmfNsSD);
		if (FAILED(hRes))
		{
			ERRORTRACE((LOG_WBEMCORE, "Failed to inherit parent's inheritable ACE's; HRESULT = %#lx\n", hRes));
			return hRes;
		}
	}

	return WBEM_S_NO_ERROR;
}

HRESULT CWin9xSecurity::SetNamespaceSecurity(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& mmfNsSD)
{
	if (!pNamespaceHandle)
		return WBEM_E_FAILED;

	// get the singleton object
    IWbemClassObject* pThisNamespace = NULL;
	size_t dwThisNamespaceLen = wcslen(L"__thisnamespace=@")+1;
	wchar_t* wszThisNamespace = new wchar_t[dwThisNamespaceLen];
	if (wszThisNamespace == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	StringCchCopyW(wszThisNamespace, dwThisNamespaceLen, L"__thisnamespace=@");
    HRESULT hRes = pNamespaceHandle->GetObjectByPath(wszThisNamespace, 0, IID_IWbemClassObject, (LPVOID*)&pThisNamespace);
    delete [] wszThisNamespace;
    wszThisNamespace = NULL;
	if (FAILED(hRes))
    {
		ERRORTRACE((LOG_WBEMCORE, "Failed to get singleton namespace object; HRESULT = %#lx\n", hRes));
		return hRes;
    }
	CReleaseMe relMe(pThisNamespace);

	// copy SD data into a safearray
	SAFEARRAY FAR* psa;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = mmfNsSD.GetSize();
	psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
	if (!psa)
		return WBEM_E_OUT_OF_MEMORY;

	char* pData = NULL;
	hRes = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed SafeArrayAccessData; HRESULT = %#lx\n", hRes));
		return hRes;
	}
	memcpy(pData, mmfNsSD.GetPtr(), mmfNsSD.GetSize());
	hRes = SafeArrayUnaccessData(psa);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed SafeArrayUnaccessData; HRESULT = %#lx\n", hRes));
		return hRes;
	}
	pData = NULL;

	// put the safearray into a variant and set the property on the instance
	VARIANT var;
	var.vt = VT_UI1|VT_ARRAY;
	var.parray = psa;
	hRes = pThisNamespace->Put(L"SECURITY_DESCRIPTOR" , 0, &var, 0);
	VariantClear(&var);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to put SECURITY_DESCRIPTOR property; HRESULT = %#lx\n", hRes));
		return hRes;
	}

	// put back the instance
	CEventCollector eventCollector;
    hRes = pNamespaceHandle->PutObject(IID_IWbemClassObject, pThisNamespace, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL, eventCollector);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to put back singleton instance; HRESULT = %#lx\n", hRes));
		return hRes;
	}
	return hRes;
}

bool CWin9xSecurity::AddDefaultRootAces(CNtAcl * pacl)
{
	if (!pacl)
		return false;

    PSID pRawSid;

	// add Administrator
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmin(pRawSid);
        FreeSid(pRawSid);
        DWORD dwMask = FULL_RIGHTS;
        CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, SidAdmin);
		if ( NULL == pace )
			return false;

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
		if (pacl->GetStatus() != 0)
			return false;
    }

	// add Everyone
    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;
    if(AllocateAndInitializeSid( &id2, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        DWORD dwMask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER;
        CNtAce * pace = new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE, CONTAINER_INHERIT_ACE, SidUsers);
		if ( NULL == pace )
			return false;

        CDeleteMe<CNtAce> dm(pace);
        pacl->AddAce(pace);
		if (pacl->GetStatus() != 0)
			return false;
	}

	return true;
}

HRESULT CWin9xSecurity::GetParentsInheritableAces(CNamespaceHandle* pParentNamespaceHandle, CNtSecurityDescriptor &sd)
{
	if (!pParentNamespaceHandle)
		return WBEM_E_FAILED;

    // Get the parent namespace's SD
	CNtSecurityDescriptor sdParent;
	HRESULT hRes = GetSDFromNamespace(pParentNamespaceHandle, sdParent);
	if (FAILED(hRes))
		return hRes;

	// strip out the inherited aces so we have a consistent SD
	if (!StripOutInheritedAces(sd))
		return WBEM_E_FAILED;

    // Go through the parents dacl and add any inheritable aces to ours.
	if (!CopyInheritAces(sd, sdParent))
		return WBEM_E_FAILED;

	return hRes;
}

HRESULT CWin9xSecurity::GetSDFromNamespace(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& sd)
{
	if (!pNamespaceHandle)
		return WBEM_E_FAILED;

	// get the singleton object
    IWbemClassObject* pThisNamespace = NULL;
	size_t dwThisNamespaceLen = wcslen(L"__thisnamespace=@")+1;
	wchar_t* wszThisNamespace = new wchar_t[dwThisNamespaceLen];
	if (wszThisNamespace==NULL)
		return WBEM_E_OUT_OF_MEMORY;
	StringCchCopyW(wszThisNamespace, dwThisNamespaceLen, L"__thisnamespace=@");
    HRESULT hRes = pNamespaceHandle->GetObjectByPath(wszThisNamespace, 0, IID_IWbemClassObject, (LPVOID*)&pThisNamespace);
    delete [] wszThisNamespace;
    wszThisNamespace=NULL;
	if (FAILED(hRes))
    {
		ERRORTRACE((LOG_WBEMCORE, "Failed to get singleton namespace object; HRESULT = %#lx\n", hRes));
		return hRes;
    }
	CReleaseMe relMe(pThisNamespace);

    // Get the security descriptor argument
    VARIANT var;
    VariantInit(&var);
    hRes = pThisNamespace->Get(L"SECURITY_DESCRIPTOR", 0, &var, NULL, NULL);
    if (FAILED(hRes))
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "Failed to get SECURITY_DESCRIPTOR property; HRESULT = %#lx\n", hRes));
		return hRes;
    }

    if(var.vt != (VT_ARRAY | VT_UI1))
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "Failed to get SECURITY_DESCRIPTOR property due to incorrect variant type\n"));
		return WBEM_E_FAILED;
    }

    SAFEARRAY* psa = var.parray;
    PSECURITY_DESCRIPTOR pSD;
    hRes = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    if (FAILED(hRes))
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "GetSDFromNamespace failed SafeArrayAccessData; HRESULT = %#lx\n", hRes));
		return hRes;
    }

    BOOL bValid = IsValidSecurityDescriptor(pSD);
    if (!bValid)
    {
        VariantClear(&var);
		ERRORTRACE((LOG_WBEMCORE, "GetSDFromNamespace retrieved an invalid security descriptor\n"));
		return WBEM_E_FAILED;
    }

    CNtSecurityDescriptor sdNew(pSD);

    // Check to make sure the owner and group is not NULL!!!!
	CNtSid *pTmpSid = sdNew.GetOwner();
	if (pTmpSid == NULL)
	{
        ERRORTRACE((LOG_WBEMCORE, "Security descriptor was retrieved and it had no owner\n"));
	}
	delete pTmpSid;

	pTmpSid = sdNew.GetGroup();
	if (pTmpSid == NULL)
	{
        ERRORTRACE((LOG_WBEMCORE, "Security descriptor was retrieved and it had no group\n"));
	}
	delete pTmpSid;
	
	sd = sdNew;
    SafeArrayUnaccessData(psa);
    VariantClear(&var);
	return hRes;
}

bool CWin9xSecurity::StripOutInheritedAces(CNtSecurityDescriptor& sd)
{
    // Get the DACL
    CNtAcl* pAcl;
    pAcl = sd.GetDacl();
    if(!pAcl)
        return false;
    CDeleteMe<CNtAcl> dm(pAcl);

    // enumerate through the aces
    DWORD dwNumAces = pAcl->GetNumAces();
    BOOL bChanged = FALSE;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce *pAce = pAcl->GetAce(nIndex);
        CDeleteMe<CNtAce> dm2(pAce);
        if(pAce)
        {
            long lFlags = pAce->GetFlags();
            if(lFlags & INHERITED_ACE)
            {
                pAcl->DeleteAce(nIndex);
                bChanged = TRUE;
            }
        }
    }
    if(bChanged)
        sd.SetDacl(pAcl);
    return true;
}

bool CWin9xSecurity::CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent)
{
	// Get the acl list for both SDs

    CNtAcl * pacl = sd.GetDacl();
    if(pacl == NULL)
        return false;
    CDeleteMe<CNtAcl> dm0(pacl);

    CNtAcl * paclParent = sdParent.GetDacl();
    if(paclParent == NULL)
        return false;
    CDeleteMe<CNtAcl> dm1(paclParent);

	int iNumParent = paclParent->GetNumAces();
	for(int iCnt = 0; iCnt < iNumParent; iCnt++)
	{
	    CNtAce *pParentAce = paclParent->GetAce(iCnt);
        CDeleteMe<CNtAce> dm2(pParentAce);

		long lFlags = pParentAce->GetFlags();
		if(lFlags & CONTAINER_INHERIT_ACE)
		{

			if(lFlags & NO_PROPAGATE_INHERIT_ACE)
				lFlags ^= CONTAINER_INHERIT_ACE;
			lFlags |= INHERITED_ACE;

			// If this is an inherit only ace we need to clear this
			// in the children.
			// NT RAID: 161761		[marioh]
			if ( lFlags & INHERIT_ONLY_ACE )
				lFlags ^= INHERIT_ONLY_ACE;

			pParentAce->SetFlags(lFlags);
			pacl->AddAce(pParentAce);
		}
	}
	sd.SetDacl(pacl);
	return true;
}

BOOL CWin9xSecurity::SetOwnerAndGroup(CNtSecurityDescriptor &sd)
{
    PSID pRawSid;
    BOOL bRet = FALSE;

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmins(pRawSid);
        bRet = sd.SetGroup(&SidAdmins);		// Access check doesn't really care what you put,
											// so long as you put something for the owner
        if(bRet)
            bRet = sd.SetOwner(&SidAdmins);
        FreeSid(pRawSid);
        return bRet;
    }
    return bRet;
}

//
// CNamespaceListSink is used by the query in RecursiveInheritSecurity below
//
class CNamespaceListSink : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
    CWStringArray &m_aNamespaceList;
public:
    CNamespaceListSink(CWStringArray &aNamespaceList)
        : m_aNamespaceList(aNamespaceList)
    {
    }
    ~CNamespaceListSink()
    {
    }
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        HRESULT hRes;
        for (int i = 0; i != lNumObjects; i++)
        {
            if (apObjects[i] != NULL)
            {
                _IWmiObject *pInst = NULL;
                hRes = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pInst);
                if (FAILED(hRes))
                    return hRes;
                CReleaseMe rm(pInst);

                BSTR strKey = NULL;
                hRes = pInst->GetKeyString(0, &strKey);
                if(FAILED(hRes))
                    return hRes;
                CSysFreeMe sfm(strKey);
                if (m_aNamespaceList.Add(strKey) != CWStringArray::no_error)
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, BSTR, IWbemClassObject*)
    {
        return WBEM_S_NO_ERROR;
    }
};

HRESULT CWin9xSecurity::RecursiveInheritSecurity(CNamespaceHandle* pParentNamespaceHandle, const wchar_t *wszNamespace)
{
	// force namespaces to inherit their inheritable security settings

    HRESULT hRes = WBEM_S_NO_ERROR;

	// get handle to the namespace
	CNamespaceHandle* pNamespaceHandle = new CNamespaceHandle(m_pControl, m_pRepository);
	if (!pNamespaceHandle)
		return WBEM_E_OUT_OF_MEMORY;
    pNamespaceHandle->AddRef();
    CReleaseMe relme1(pNamespaceHandle);
	hRes = pNamespaceHandle->Initialize(wszNamespace);
	if (FAILED(hRes))
	{
		ERRORTRACE((LOG_WBEMCORE, "Failed to connect to namespace; HRESULT = %#lx\n", hRes));
		return hRes;
	}

    // inherit parent's inheritable security if there is a parent
	if (pParentNamespaceHandle)
	{
		CNtSecurityDescriptor sdNamespace;
		hRes = GetSDFromNamespace(pNamespaceHandle, sdNamespace);
		if (FAILED(hRes))
			return hRes;

		hRes = GetParentsInheritableAces(pParentNamespaceHandle, sdNamespace);
		if (FAILED(hRes))
			return hRes;

		hRes = SetNamespaceSecurity(pNamespaceHandle, sdNamespace);
		if (FAILED(hRes))
			return hRes;
	}

	//Enumerate child namespaces
	CWStringArray aListNamespaces;
	CNamespaceListSink* pSink = new CNamespaceListSink(aListNamespaces);
	if (!pSink)
		return WBEM_E_OUT_OF_MEMORY;
	pSink->AddRef();
	CReleaseMe relme2(pSink);

    if (SUCCEEDED(hRes))
    {
		IWbemQuery *pQuery = NULL;
		hRes = CoCreateInstance(CLSID_WbemQuery, NULL, CLSCTX_INPROC_SERVER, IID_IWbemQuery, (void **)&pQuery);
		if (FAILED(hRes))
			return hRes;
		CReleaseMe relme3(pQuery);

		hRes = pQuery->Parse(L"SQL", L"select * from __namespace", 0);
		if (FAILED(hRes))
			return hRes;

		hRes = pNamespaceHandle->ExecQuerySink(pQuery, 0, 0, pSink, NULL);
    }

    //Work through list and call ourselves with that namespace name
    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i != aListNamespaces.Size(); i++)
        {
            //Build the full name of this namespace
            size_t dwChildNamespaceLen = wcslen(wszNamespace) + wcslen(aListNamespaces[i]) + wcslen(L"\\") + 1;
            wchar_t *wszChildNamespace = new wchar_t[dwChildNamespaceLen];
            if (wszChildNamespace == NULL)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
                break;
            }
			CVectorDeleteMe<wchar_t> delMe(wszChildNamespace);

            StringCchCopyW(wszChildNamespace, dwChildNamespaceLen, wszNamespace);
            StringCchCatW(wszChildNamespace, dwChildNamespaceLen,L"\\");
            StringCchCatW(wszChildNamespace, dwChildNamespaceLen,aListNamespaces[i]);

            // Do the inherit
            hRes = RecursiveInheritSecurity(pNamespaceHandle, wszChildNamespace);
			if (FAILED(hRes))
				break;
        }
    }

    return hRes;
}

BOOL CWin9xSecurity::DeleteWin9xBlobFile()
{
	// delete the file
	CFileName wszFilePath;
	if (wszFilePath == NULL)
		return FALSE;
	if (!GetRepositoryDirectory(wszFilePath))
		return FALSE;

	StringCchCatW(wszFilePath, wszFilePath.Length(), BLOB9X_FILENAME);
	return DeleteFileW(wszFilePath);
}

bool CWin9xSecurity::GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\WBEM\\CIMOM", 0, KEY_READ, &hKey))
        return false;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = (MAX_PATH + 1)*sizeof(wchar_t);
    long lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return false;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return false;

	return true;
}

//***************************************************************************
//
//  CFlexAceArray::~CFlexAceArray()
//
//  Cleans up safe array entries.
//
//***************************************************************************

CFlexAceArray::~CFlexAceArray()
{
    for(int iCnt = 0; iCnt < Size(); iCnt++)
    {
        CBaseAce* pAce = (CBaseAce*)GetAt(iCnt);
        if(pAce)
            delete pAce;
    }
	Empty();
}

//***************************************************************************
//
//  bool CFlexAceArray::DeserializeWin9xSecurityBlob()
//
//  Description. Deserializes the Win9x pseudo-aces out of a blob.
//  The blob starts off with 5 dwords preceding the aces themselves:
//  <TOTAL SIZE><VERSION><ISNT><ACE_COUNT><RESERVED><ACE> ... <ACE>
//
//***************************************************************************

bool CFlexAceArray::DeserializeWin9xSecurityBlob(const char* pData)
{
	if (!pData)
		return false;

    DWORD* pdwData = (DWORD*)pData;
    pdwData += 3;
    int iAceCount = (int)*pdwData;
    pdwData += 2;

    // Set the ace data
    BYTE* pAceData = (BYTE*)pdwData;
    DWORD dwAceSize = 0;
    CBaseAce* pAce = NULL;
    for (int iCnt = 0; iCnt < iAceCount; iCnt++)
    {
		// if the user is preceeded by a ".\" advance the pointer past it
		if (wbem_wcsnicmp((WCHAR*)pAceData, L".\\", 2) == 0)
			pAceData += 4;

        dwAceSize = 2*(wcslen((WCHAR*)pAceData) + 1) + 12;
        pAce = new CNtAce();
        if (!pAce)
            return false;

        // Deserialize Win9x pseudo ace into NT ace
        pAce->Deserialize(pAceData);

		// only add ACE's that we were successful in creating
		if (pAce->GetStatus() == 0)
	        Add(pAce);

        pAceData += dwAceSize;
    }
	return true;
}

//***************************************************************************
//
//  bool CFlexAceArray::SerializeWinNTSecurityBlob()
//
//  Description. Serializes the WinNT aces into a blob.
//  The blob starts off with 5 dwords preceding the aces themselves:
//  <TOTAL SIZE><VERSION><ISNT><ACE_COUNT><RESERVED><ACE> ... <ACE>
//
//  "version" should be 1.  
//  "ISNT" should be 1
//
//***************************************************************************
	
bool CFlexAceArray::SerializeWinNTSecurityBlob(char** ppData)
{
    // Start by determining the total size needed
    DWORD dwSize = 5 * sizeof(DWORD);               // for the header stuff
    int iAceCount = Size();                         // get count of aces stored in array
    CBaseAce* pAce = NULL;
    for (int iCnt = 0; iCnt < iAceCount; iCnt++)    // add each of the ace sizes
    {
        pAce = (CBaseAce*)GetAt(iCnt);
        if (!pAce)
    		return false;

        dwSize += pAce->GetSerializedSize();
    }

    // Allocate the blob, set the pointer from the caller;
    BYTE* pData = new BYTE[dwSize];
    if (!pData)
    	return false;

    *ppData = (char*)pData;

    // Set the header info
    DWORD* pdwData = (DWORD *)pData;
    *pdwData = dwSize;
    pdwData++;
    *pdwData = 1;           // version
    pdwData++;
    *pdwData = 1;           // ISNT
    pdwData++;
    *pdwData = iAceCount;
    pdwData++;
    *pdwData = 0;           // reserved
    pdwData++;

    // Set the ace data
    BYTE* pAceData = (BYTE*)pdwData;
	size_t leftSize = dwSize - (pAceData - pData);
    for(iCnt = 0; iCnt < iAceCount; iCnt++)
    {
        pAce = (CBaseAce*)GetAt(iCnt);
        pAce->Serialize(pAceData, leftSize);
        pAceData += pAce->GetSerializedSize();;
		leftSize-=pAce->GetSerializedSize();
    }
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\dumptool\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\win9xsecurity.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    Win9xSecurity.h

Abstract:

	This class handles the importing of Win9x security data that was extracted from an old MMF format repository.

History:

	03/17/2001	shbrown - created

--*/

#ifndef __wmi_win9xsecurity_h__
#define __wmi_win9xsecurity_h__

#include <wbemint.h>
#include <strutils.h>
#include <ql.h>
#include "a51rep.h"
#include "flexarry.h"
#include "winntsec.h"

#ifndef FULL_RIGHTS
#define FULL_RIGHTS WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                    WBEM_WRITE_PROVIDER | WRITE_DAC | READ_CONTROL | WBEM_ENABLE | WBEM_REMOTE_ACCESS
#endif

#define BLOB9X_FILENAME L"\\WBEM9xUpgd.dat"
#define BLOB9X_SIGNATURE "9xUpgrade"			//NOTE!  MAXIMUM OF 10 CHARACTERS (INCLUDING TERMINATOR!)

#define BLOB9X_TYPE_SECURITY_BLOB		1
#define BLOB9X_TYPE_SECURITY_INSTANCE	2
#define BLOB9X_TYPE_END_OF_FILE			3

typedef struct _BLOB9X_HEADER
{
	char szSignature[10];
} BLOB9X_HEADER;

typedef struct _BLOB9X_SPACER
{
	DWORD dwSpacerType;
	DWORD dwNamespaceNameSize;
	DWORD dwParentClassNameSize;
	DWORD dwBlobSize;
} BLOB9X_SPACER;

class CWin9xSecurity
{
public:
	CWin9xSecurity(CLifeControl* pControl, CRepository * pRepository)
		: m_h9xBlobFile(INVALID_HANDLE_VALUE), m_pControl(pControl), m_pRepository(pRepository) {};

	bool	Win9xBlobFileExists();
	HRESULT ImportWin9xSecurity();

private:
	HANDLE	m_h9xBlobFile;
	CLifeControl* m_pControl;
	CRepository * m_pRepository;

	HRESULT	DecodeWin9xBlobFile();
	bool	ReadWin9xHeader();
	HRESULT	ProcessWin9xBlob(BLOB9X_SPACER* pHeader);
	HRESULT	ProcessWin9xSecurityInstance(CNamespaceHandle* pNamespaceHandle, wchar_t* wszParentClass, char* pObjectBlob, DWORD dwBlobSize);
	CNtAce*	ConvertOldObjectToAce(_IWmiObject* pObj, bool bGroup);
	HRESULT StoreAce(CNtAce* pAce);
	bool	StripMatchingEntries(CNtSecurityDescriptor& sd, const wchar_t* wszAccountName);
	bool	AddAceToSD(CNtSecurityDescriptor& sd, CNtAce* pAce);
	HRESULT	ProcessWin9xSecurityBlob(CNamespaceHandle* pNamespaceHandle, const wchar_t* wszNamespaceName, const char* pObjectBlob);
	bool	ConvertSecurityBlob(const char* pOrgNsSecurity, char** ppNewNsSecurity);
	HRESULT	TransformBlobToSD(bool bRoot, CNamespaceHandle* pParentNamespaceHandle, const char* pNsSecurity, DWORD dwStoredAsNT, CNtSecurityDescriptor& mmfNsSD);
	HRESULT	SetNamespaceSecurity(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& mmfNsSD);
	bool	AddDefaultRootAces(CNtAcl * pacl);
	HRESULT	GetParentsInheritableAces(CNamespaceHandle* pParentNamespaceHandle, CNtSecurityDescriptor &sd);
	bool	StripOutInheritedAces(CNtSecurityDescriptor &sd);
	HRESULT	GetSDFromNamespace(CNamespaceHandle* pNamespaceHandle, CNtSecurityDescriptor& sd);
	bool	CopyInheritAces(CNtSecurityDescriptor& sd, CNtSecurityDescriptor& sdParent);
	BOOL	SetOwnerAndGroup(CNtSecurityDescriptor &sd);
	HRESULT	RecursiveInheritSecurity(CNamespaceHandle* pParentNamespaceHandle, const wchar_t *wszNamespace);
	BOOL	DeleteWin9xBlobFile();
	bool	GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
};

// Helper for ConvertSecurityBlob
// A variation of the CFlexArray which deletes the entries
class CFlexAceArray : public CFlexArray
{
public:
	CFlexAceArray(){};
	~CFlexAceArray();
    bool SerializeWinNTSecurityBlob(char** pData);
    bool DeserializeWin9xSecurityBlob(const char* pData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\dtd\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\xfiles\dumptool\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <pagemgr.h>
#include <varobjheap.h>
#include <sync.h>
#include <wbemcomn.h>

#define MAP_LEADING_SIGNATURE   0xABCD
#define MAP_TRAILING_SIGNATURE  0xDCBA

typedef std::vector <DWORD, wbem_allocator<DWORD> > XFilesMap;

DWORD ReadMapFile(const wchar_t *sFilename, XFilesMap &aPageMap, XFilesMap & aPhysFreeList);
DWORD DumpHeapAdminPages(const wchar_t *sFilename, XFilesMap &aHeapMap, XFilesMap &aHeapFreeList);
DWORD GetHeapManagedPageCount(const wchar_t *sFilename, XFilesMap &aHeapMap, DWORD &dwNumAdminPages, DWORD &dwNumMultiBlockPages, DWORD &dwNumMultiBlockObjects);
DWORD GetMapUsageCount(XFilesMap &aHeapMap, DWORD &dwHeapMapUsed, DWORD &dwHeapMapFree);
DWORD DumpMap(XFilesMap &aMap);


void __cdecl main(int argc, char *argv[ ])
{
	printf("WMI XFiles repository dumper\n\n");
	bool bDumpHeapAdminPage = false;
	bool bDumpTreeMap = false;
	bool bDumpHeapMap = false;

	for (int i = 1; i != argc; i++)
	{
		if ((_stricmp(argv[i], "/?") == 0) ||
			(_stricmp(argv[i], "-?") == 0))
		{
			printf("Usage: DumpTool.exe /?               - display this message\n"
				   "       DumpTool.exe /DumpAdminPages  - dumps the heap admin tables\n"
				   "       DumpTool.exe /DumpTreeMap     - dumps the tree map usage\n"
				   "       DumpTool.exe /DumpHeapMap     - dumps the heap map usage\n");
			return;
		}
		else if (_stricmp(argv[i], "/DumpAdminPages") == 0)
		{
			bDumpHeapAdminPage = true;
		}
		else if (_stricmp(argv[i], "/DumpTreeMap") == 0)
		{
			bDumpTreeMap = true;
		}
		else if (_stricmp(argv[i], "/DumpHeapMap") == 0)
		{
			bDumpHeapMap = true;
		}
	}

	DWORD dwRet;

	XFilesMap aBTreeMap;
	XFilesMap aBTreeFreeList;
	DWORD     dwBTreeSize = 0;
	DWORD     dwBTreeUsed = 0;
	DWORD     dwBTreeFree = 0;
	XFilesMap aHeapMap;
	XFilesMap aHeapFreeList;
	DWORD     dwHeapSize = 0;
	DWORD     dwHeapUsed = 0;
	DWORD     dwHeapFree = 0;

	//Read MAP Files
	dwRet = ReadMapFile(L"index.map", aBTreeMap, aBTreeFreeList);
	if (dwRet)
	{
		printf("Failed to retrieve index.map details.  Please run from within the repository\\fs directory\n");
		return;
	}

	GetMapUsageCount(aBTreeMap, dwBTreeUsed, dwBTreeFree);

	dwRet = ReadMapFile(L"objects.map", aHeapMap, aHeapFreeList);
	if (dwRet)
	{
		printf("Failed to retrieve objects.map details.  Please run from within the repository\\fs directory\n");
		return;
	}
	
	GetMapUsageCount(aHeapMap, dwHeapUsed, dwHeapFree);

	WIN32_FILE_ATTRIBUTE_DATA fileInfo;
	dwRet = GetFileAttributesEx(L"INDEX.BTR", GetFileExInfoStandard, &fileInfo);
	if (dwRet == 0)
	{
		printf("Failed to retrieve size of index.btr file\n");
		return;
	}
	dwBTreeSize = fileInfo.nFileSizeLow / WMIREP_PAGE_SIZE;

	dwRet = GetFileAttributesEx(L"OBJECTS.DATA", GetFileExInfoStandard, &fileInfo);
	if (dwRet == 0)
	{
		printf("Failed to retrieve size of objects.data file\n");
		return;
	}
	dwHeapSize = fileInfo.nFileSizeLow / WMIREP_PAGE_SIZE;

	//Dump MAP file usage and free space sumary
	printf("BTree has %lu pages in it, of which %lu pages are in use and %lu pages are free\n", 
		dwBTreeSize, dwBTreeUsed, dwBTreeSize - dwBTreeUsed);
	printf("Heap  has %lu pages in it, of which %lu pages are in use and %lu pages are free\n", 
		dwHeapSize, dwHeapUsed, dwHeapSize - dwHeapUsed);

	//Get number of managed pages for heap...
	DWORD dwNumAdminPages = 0;
	DWORD dwNumMultiBlockPages = 0;
	DWORD dwNumMultiBlockObjects = 0;
	dwRet = GetHeapManagedPageCount(L"OBJECTS.DATA", aHeapMap, dwNumAdminPages, dwNumMultiBlockPages, dwNumMultiBlockObjects);
	if (dwRet)
	{
		printf("Failed to retrieve number of pages used in object heap\n");
		return;
	}

	printf("Heap has %lu admin pages, \n\t%lu pages used for small block allocation, total of %lu small block allocations, \n\t%lu pages for large block allocations\n", 
		dwNumAdminPages, 
		dwNumMultiBlockPages,
		dwNumMultiBlockObjects, 
		dwHeapSize - (dwHeapSize - dwHeapUsed) - dwNumAdminPages - dwNumMultiBlockPages);

	if (bDumpHeapAdminPage)
	{
		dwRet = DumpHeapAdminPages(L"OBJECTS.DATA", aHeapMap, aHeapFreeList);
		if (dwRet)
		{
			printf("Failed to dump the admin pages in the heap\n");
			return;
		}
	}

	if (bDumpTreeMap)
	{
		printf("**** BTree MAP Usage ****\n");
		DumpMap(aBTreeMap);
	}

	if (bDumpHeapMap)
	{
		printf("**** Heap MAP Usage ****\n");
		DumpMap(aHeapMap);
	}

}

DWORD ReadMapFile(const wchar_t *sFilename, XFilesMap &aPageMap,XFilesMap & aPhysFreeList)
{
    BOOL bRes;

    HANDLE hFile = CreateFileW(sFilename, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
    {
		DWORD dwRet = GetLastError();
        return dwRet;
    }

    AutoClose _(hFile);

    // If here, read it.
    // =================

    DWORD dwSignature = 0;
    DWORD dwRead = 0;

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_LEADING_SIGNATURE)
    {
        return ERROR_INVALID_DATA;
    }

    // Read transaction version.
    // =========================

	DWORD dwTransVersion;
    bRes = ReadFile(hFile, &dwTransVersion, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    // Read in physical page count.
    // ============================
	DWORD dwPhysPages;
    bRes = ReadFile(hFile, &dwPhysPages, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    // Read in the page map length and page map.
    // =========================================

    DWORD dwNumPages = 0;
    bRes = ReadFile(hFile, &dwNumPages, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    try
    {
        aPageMap.resize(dwNumPages);
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &aPageMap[0], sizeof(DWORD)*dwNumPages, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwNumPages)
        return ERROR_INVALID_DATA;

    // Now, read in the physical free list.
    // ====================================

    DWORD dwFreeListSize = 0;
    bRes = ReadFile(hFile, &dwFreeListSize, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD))
    {
        return ERROR_INVALID_DATA;
    }

    try
    {
        aPhysFreeList.resize(dwFreeListSize);
    }
    catch (CX_MemoryException &)
    {
        return ERROR_OUTOFMEMORY;
    }

    bRes = ReadFile(hFile, &aPhysFreeList[0], sizeof(DWORD)*dwFreeListSize, &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD)*dwFreeListSize)
    {
        return ERROR_INVALID_DATA;
    }

    // Read trailing signature.
    // ========================

    bRes = ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwRead, 0);
    if (!bRes || dwRead != sizeof(DWORD) || dwSignature != MAP_TRAILING_SIGNATURE)
    {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}

DWORD DumpHeapAdminPages(const wchar_t *sFilename, XFilesMap &aHeapMap, XFilesMap &aHeapFreeList)
{
	//Open the file...
	HANDLE hFile = CreateFile(sFilename, GENERIC_READ, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return GetLastError();

    HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMapping == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hFile);
		return dwErr;
	}

    BYTE *pObj = (BYTE *)MapViewOfFile(hMapping, FILE_MAP_READ, 0,0,0);
	if (pObj == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hMapping);
		CloseHandle(hFile);
		return dwErr;;
	}

	//Do stuff...
	DWORD dwVirtualPageId = 0;
	DWORD dwTotalObjectCount = 0;

	printf("Heap admin page dump...\n");
	do
	{
		DWORD dwPhysicalPageId = aHeapMap[dwVirtualPageId];
		VarObjHeapAdminPage *pAdminPageHeader = (VarObjHeapAdminPage *)(pObj + (dwPhysicalPageId * WMIREP_PAGE_SIZE));
		VarObjHeapFreeList *pAdminPageEntry = (VarObjHeapFreeList *)((BYTE*)pAdminPageHeader + sizeof(VarObjHeapAdminPage));

		printf("Admin page %lu (physical page %lu):  number of page entries %lu\n", dwVirtualPageId, dwPhysicalPageId, pAdminPageHeader->dwNumberEntriesOnPage);

		for (DWORD dwIndex = 0; dwIndex != pAdminPageHeader->dwNumberEntriesOnPage; dwIndex++)
		{
			DWORD dwNumObjectsOnPage = 0;
			VarObjObjOffsetEntry *pObjPage = (VarObjObjOffsetEntry*)(pObj + (aHeapMap[pAdminPageEntry[dwIndex].dwPageId] * WMIREP_PAGE_SIZE));
			for (DWORD dwIndex2 = 0; pObjPage[dwIndex2].dwOffsetId != 0; dwIndex2++)
			{
				dwNumObjectsOnPage++;
			}
			printf("\tPage % 6lu (physical page % 6lu): %4lu bytes free (% 2lu%%), %4lu objects on page\n", 
				pAdminPageEntry[dwIndex].dwPageId, 
				aHeapMap[pAdminPageEntry[dwIndex].dwPageId], 
				pAdminPageEntry[dwIndex].dwFreeSpace, 
				(pAdminPageEntry[dwIndex].dwFreeSpace * 100) / WMIREP_PAGE_SIZE,
				dwNumObjectsOnPage);
		}

		dwVirtualPageId = pAdminPageHeader->dwNextAdminPage;
	} while (dwVirtualPageId != 0);

	//Tidy up
	UnmapViewOfFile(pObj);
	CloseHandle(hMapping);
	CloseHandle(hFile);

	return ERROR_SUCCESS;

}

DWORD GetHeapManagedPageCount(const wchar_t *sFilename, XFilesMap &aHeapMap, DWORD &dwNumAdminPages, DWORD &dwNumMultiBlockPages, DWORD &dwNumMultiBlockObjects)
{
	//Open the file...
	HANDLE hFile = CreateFile(sFilename, GENERIC_READ, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return GetLastError();

    HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
	if (hMapping == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hFile);
		return dwErr;
	}

    BYTE *pObj = (BYTE *)MapViewOfFile(hMapping, FILE_MAP_READ, 0,0,0);
	if (pObj == NULL)
	{
		DWORD dwErr = GetLastError();
		CloseHandle(hMapping);
		CloseHandle(hFile);
		return dwErr;;
	}

	//Do stuff...
	DWORD dwVirtualPageId = 0;

	do
	{
		dwNumAdminPages++;
		DWORD dwPhysicalPageId = aHeapMap[dwVirtualPageId];
		VarObjHeapAdminPage *pAdminPageHeader = (VarObjHeapAdminPage *)(pObj + (dwPhysicalPageId * WMIREP_PAGE_SIZE));
		VarObjHeapFreeList *pAdminPageEntry = (VarObjHeapFreeList *)((BYTE*)pAdminPageHeader + sizeof(VarObjHeapAdminPage));

		for (DWORD dwIndex = 0; dwIndex != pAdminPageHeader->dwNumberEntriesOnPage; dwIndex++)
		{
			dwNumMultiBlockPages++;
			DWORD dwNumObjectsOnPage = 0;
			VarObjObjOffsetEntry *pObjPage = (VarObjObjOffsetEntry*)(pObj + (aHeapMap[pAdminPageEntry[dwIndex].dwPageId] * WMIREP_PAGE_SIZE));
			for (DWORD dwIndex2 = 0; pObjPage[dwIndex2].dwOffsetId != 0; dwIndex2++)
			{
				dwNumMultiBlockObjects++;
			}
		}

		dwVirtualPageId = pAdminPageHeader->dwNextAdminPage;
	} while (dwVirtualPageId != 0);

	//Tidy up
	UnmapViewOfFile(pObj);
	CloseHandle(hMapping);
	CloseHandle(hFile);

	return ERROR_SUCCESS;

}
DWORD GetMapUsageCount(XFilesMap &aMap, DWORD &dwMapUsed, DWORD &dwMapFree)
{
    for (DWORD i = 0; i < aMap.size(); i++)
    {
        if (aMap[i] == WMIREP_INVALID_PAGE)
            dwMapFree++;
		else
			dwMapUsed++;
    }
	return ERROR_SUCCESS;
}

void ShellSort(XFilesMap &Array)
{
    for (int nInterval = 1; nInterval < Array.size() / 9; nInterval = nInterval * 3 + 1);

    while (nInterval)
    {
        for (int iCursor = nInterval; iCursor < Array.size(); iCursor++)
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 && Array[iBackscan] < Array[iBackscan-nInterval])
            {
                DWORD dwTemp = Array[iBackscan-nInterval];
                Array[iBackscan-nInterval] = Array[iBackscan];
                Array[iBackscan] = dwTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


DWORD DumpMap(XFilesMap &aMap)
{
	//Need to sort it... and need our own copy...
	XFilesMap aNewMap = aMap;
	ShellSort(aNewMap);

	printf("**** Usage dump... **** \n");
	DWORD dwStartId = aNewMap[0];
	for (DWORD dwOffset = 1; dwOffset < aNewMap.size(); dwOffset++)
	{
		if (dwStartId == 0xFFFFFFFF)
			break;

		//Work up to the end of this run
		for (DWORD dwCurrentRun = 1; (dwStartId+dwCurrentRun) == aNewMap[dwOffset]; dwOffset++, dwCurrentRun++)
		{
		}

		//Finished slot... dump usage use
		if (dwStartId == aNewMap[dwOffset-1])
		{
			//Single location slot...
			printf("% 6lu          Used\n", dwStartId);
		}
		else
		{
			//Multiple location slot...
			printf("% 6lu - % 6lu Used\n", dwStartId, aNewMap[dwOffset-1]);
		}

		if (dwOffset+1 <= aNewMap.size())
		{
			//Dump free space usage now
			if (aNewMap[dwOffset-1]+1 == aNewMap[dwOffset]-1)
			{
				//Single location slot...
				printf("% 6lu          Free\n", aNewMap[dwOffset-1]+1);
			}
			else
			{
				//Multiple location slot...
				printf("% 6lu - % 6lu Free\n", aNewMap[dwOffset-1]+1, aNewMap[dwOffset]-1);
			}
			dwStartId = aNewMap[dwOffset];
		}
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\classfac.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  rajesh  2/25/2000   Created.
//
//  Contains the class factory for 2 components - CWmiToXml and CXml2Wmi  
//
//***************************************************************************

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>


#include "maindll.h"
#include "classfac.h"
#include "wmiconv.h"
#include "wmi2xml.h"

//***************************************************************************
//
// CWmiToXmlFactory::CWmiToXmlFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CWmiToXmlFactory::CWmiToXmlFactory()
{
    m_cRef=0L;
    InterlockedIncrement(&g_cObj);
	return;
}

//***************************************************************************
//
// CWmiToXmlFactory::~CWmiToXmlFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CWmiToXmlFactory::~CWmiToXmlFactory(void)
{
    InterlockedDecrement(&g_cObj);
	return;
}

//***************************************************************************
//
// CWmiToXmlFactory::QueryInterface
// CWmiToXmlFactory::AddRef
// CWmiToXmlFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CWmiToXmlFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiToXmlFactory::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CWmiToXmlFactory::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CWmiToXmlFactory::CreateInstance
//
//  Description:
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CWmiToXmlFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid,
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj;
    HRESULT      hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    pObj = new CWmiToXml;

    if (NULL == pObj)
        return ResultFromScode(E_OUTOFMEMORY);;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CWmiToXmlFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
//
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CWmiToXmlFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}


/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 






// ***************************************************************************
//
// CWmiToXmlFactory::CWmiToXmlFactory
//
// DESCRIPTION:
//
// Constructor
//
// ***************************************************************************

CXmlToWmiFactory::CXmlToWmiFactory()
{
    m_cRef=0L;
    InterlockedIncrement(&g_cObj);

	// Make sure Globals are initialized
	// The corresponding call ReleaseDLLResources() call
	// is made in DllCanUnloadNow()
	AllocateDLLResources();
	return;
}

// ***************************************************************************
//
// CWmiToXmlFactory::~CWmiToXmlFactory
//
// DESCRIPTION:
//
// Destructor
//
// ***************************************************************************

CXmlToWmiFactory::~CXmlToWmiFactory(void)
{
    InterlockedDecrement(&g_cObj);
	return;
}

// ***************************************************************************
//
// CWmiToXmlFactory::QueryInterface
// CWmiToXmlFactory::AddRef
// CWmiToXmlFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
// ***************************************************************************


STDMETHODIMP CXmlToWmiFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CXmlToWmiFactory::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CXmlToWmiFactory::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;

    delete this;
    return 0L;
}

// ***************************************************************************
//
//  SCODE CWmiToXmlFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
// ***************************************************************************

STDMETHODIMP CXmlToWmiFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj;
    HRESULT      hr;

    *ppvObj=NULL;
    
    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    pObj = new CXml2Wmi;
	
    if (NULL == pObj)
        return ResultFromScode(E_OUTOFMEMORY);;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

// ***************************************************************************
//
//  SCODE CWmiToXmlFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
// ***************************************************************************


STDMETHODIMP CXmlToWmiFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\classfac.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  classfac.h
//
//  alanbos  13-Feb-98   Created.
//
//  Class factory interface.
//
//***************************************************************************

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTFactory
//
//  DESCRIPTION:
//
//
//***************************************************************************

class CWmiToXmlFactory : public IClassFactory
{
protected:
	long           m_cRef;

public:

    CWmiToXmlFactory(void);
    ~CWmiToXmlFactory(void);
    
    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};


/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 

// ***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTFactory
//
//  DESCRIPTION:
//
//
// ***************************************************************************

class CXmlToWmiFactory : public IClassFactory
{
protected:
	long           m_cRef;

public:

    CXmlToWmiFactory(void);
    ~CXmlToWmiFactory(void);
    
    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\tests\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmixmlidl\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\precomp.h ===
#include <tchar.h>
#include <stdio.h>
#include <windows.h>
#include <initguid.h>
#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\maindll.h ===
#ifndef WMI_TO_XML_MAIN_DLL_H
#define WMI_TO_XML_MAIN_DLL_H

// These globals are initialized in the OpenWbemTextSource() call to the class factory
// and released in the CloseWbemTextSource() call
extern BSTR g_strName;
extern BSTR g_strSuperClass;
extern BSTR g_strType;
extern BSTR g_strClassOrigin;
extern BSTR g_strSize;
extern BSTR g_strClassName;
extern BSTR g_strValueType;
extern BSTR g_strToSubClass;
extern BSTR g_strToInstance;
extern BSTR g_strAmended;
extern BSTR g_strOverridable;
extern BSTR g_strArraySize;
extern BSTR g_strReferenceClass;

// This is the object factory used to create free-form objects
// This is initialized in OpenWbemTextSource() and released in CloseWbemTextSource()
extern _IWmiObjectFactory *g_pObjectFactory;

// A couple of routines to allocate and deallocate global variables
HRESULT ReleaseDLLResources();
HRESULT AllocateDLLResources();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\wmi2xml.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WMI2XML.H
//
//  rajesh  3/25/2000   Created.
//
// Contains the class definition of the component that implements the IWbemXMLConvertor
// interface
//
//***************************************************************************

#ifndef _WBEM2XML_H_
#define _WBEM2XML_H_

// Use this to protect features that rely on MSXML fixes
#define	WAITING_FOR_MSXML_FIX	0

// These macros are used to write BSTRs, special characters etc. to the IStream
#define WRITEBSTR(X)	pOutputStream->Write ((void const *)X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTR(X)	pOutputStream->Write ((void const *)X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTRL(X,L) pOutputStream->Write ((void const *)X, L * sizeof (OLECHAR), NULL);
#define WRITECDATASTART		WRITEBSTR(CDATASTART)
#define WRITECDATAEND		WRITEBSTR(CDATAEND)
#define WRITEAMP	        WRITEBSTR(AMPERSAND)
#define WRITELT		        WRITEBSTR(LEFTCHEVRON)
#define WRITEGT		        WRITEBSTR(RIGHTCHEVRON)

// TODO : Make sure this is disabled before release
#ifdef WMIXML_DONL	
#define WRITENEWLINE			pOutputStream->Write (XMLNEWLINE, 4, NULL);
#else
#define WRITENEWLINE
#endif



// Filter for deciding the level of naming information in the output XML
typedef enum PathLevel
{
	// No name - corresponds to CLASS|INSTANCE
	pathLevelAnonymous, 
	// namespace-relative name - Corresponds to CLASS|(INSTANCENAME, INSTANCE)
	pathLevelNamed,
	// host-relative name - Corresponds to (LOCALCLASSPATH,CLASS)|(LOCALINSTANCEPATH,INSTANCE)
	pathLevelLocal,
	// Full name with host, namespace, classname and keyvalue bindings for an instance - Corresponds to (CLASSPATH,CLASS)|(INSTANCEPATH,INSTANCE)
	pathLevelFull		
}	PathLevel;

// Filter for Qualifiers
typedef enum WmiXMLQualifierFilterEnum
{
    wmiXMLQualifierFilterNone = 0x0,
	wmiXMLQualifierFilterLocal = 0x1,
    wmiXMLQualifierFilterPropagated = 0x2,
	wmiXMLQualifierFilterAll = 0x3
} WmiXMLQualifierFilterEnum;

// Controls the amount of class origin information in the output
typedef enum WmiXMLClassOriginFilterEnum
{
    wmiXMLClassOriginFilterNone = 0x0,
	wmiXMLClassOriginFilterClass = 0x1,
	wmiXMLClassOriginFilterInstance = 0x2,
	wmiXMLClassOriginFilterAll = 0x3
} WmiXMLClassOriginFilterEnum;

//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiToXml
//
//  DESCRIPTION:
//
//  Performs conversion from WMI to XML.
//
//***************************************************************************

class CWmiToXml : public IWbemXMLConvertor
{
private:

	// This is the enumeration of the names of properties that the control
	// looks for in an IWbemContext object for modifying its output
	enum
	{
		WMI_EXTENSIONS_ARG,
		PATH_LEVEL_ARG,
		QUALIFIER_FILTER_ARG,
		CLASS_ORIGIN_FILTER_ARG,
		LOCAL_ONLY_ARG,
		EXCLUDE_SYSTEM_PROPERTIES_ARG
	};
	static const LPCWSTR s_wmiToXmlArgs[];

	
	long					m_cRef; // COM Ref count

	// Flags that modify the output
	// These are filled up from the IWbemContext object
	// that is passed for most function calls
	PathLevel						m_iPathLevel;
	VARIANT_BOOL					m_bAllowWMIExtensions;
	WmiXMLQualifierFilterEnum		m_iQualifierFilter;
	WmiXMLClassOriginFilterEnum		m_iClassOriginFilter;
	VARIANT_BOOL					m_bLocalOnly;
	VARIANT_BOOL					m_bExcludeSystemProperties;

	BOOL				PropertyDefinedForClass (IWbemClassObject *pObject, BSTR bsPropertyName, BSTR strClassBasis);

	STDMETHODIMP		MapClass (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis);
	STDMETHODIMP		MapClassName (IStream *pOutputStream, BSTR bsClassName);
	STDMETHODIMP		MapClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapLocalClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapInstance (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis);
	STDMETHODIMP		MapInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapLocalInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapInstanceName (IStream *pOutputStream, ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath);
	STDMETHODIMP		MapNamespacePath (IStream *pOutputStream, ParsedObjectPath *pObjectPath);
	STDMETHODIMP		MapLocalNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath);
	STDMETHODIMP		MapLocalNamespacePath (IStream *pOutputStream, ParsedObjectPath *pObjectPath);
	STDMETHODIMP		MapQualifiers (IStream *pOutputStream, IWbemQualifierSet *pQualSet, IWbemQualifierSet *pQualSet2 = NULL);
	STDMETHODIMP		MapQualifier (IStream *pOutputStream, BSTR name, long flavor, VARIANT &var);
	STDMETHODIMP		MapProperties (IStream *pOutputStream, IWbemClassObject *pObject, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis, bool bIsClass);
	STDMETHODIMP		MapProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, CIMTYPE cimtype,
										BOOL isArray, long flavor, bool bIsClass);
	STDMETHODIMP		MapObjectProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, BOOL isArray, long flavor, bool bIsClass);
	STDMETHODIMP		MapReferenceProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, bool isArray, long flavor, bool bIsClass);
	void				MapArraySize (IStream *pOutputStream, IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapMethods (IStream *pOutputStream, IWbemClassObject *pObject);
	void				MapMethod (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, IWbemClassObject *pInParams, IWbemClassObject *pOutParams);
	void				MapParameter (IStream *pOutputStream, BSTR paramName, IWbemQualifierSet *pQualSet, 
								CIMTYPE cimtype, IWbemQualifierSet *pQualSet2 = NULL);
	void				MapReturnParameter(IStream *pOutputStream, BSTR strParameterName, VARIANT &variant);

	STDMETHODIMP		MapType (IStream *pOutputStream, CIMTYPE cimtype);
	STDMETHODIMP		MapValue (IStream *pOutputStream, VARIANT &var);
	STDMETHODIMP		MapValue (IStream *pOutputStream, CIMTYPE cimtype, BOOL isArray, VARIANT &var);
	STDMETHODIMP		MapEmbeddedObjectValue (IStream *pOutputStream, BOOL isArray, VARIANT &var);
	STDMETHODIMP		MapKeyValue (IStream *pOutputStream, VARIANT &var);
	void				MapStrongType (IStream *pOutputStream, IWbemQualifierSet *pQualSet);
	void				MapLocal (IStream *pOutputStream, long flavor);
	void				MapClassOrigin (IStream *pOutputStream, BSTR &classOrigin, bool bIsClass);
	STDMETHODIMP		MapMethodReturnType(IStream *pOutputStream, VARIANT *pValue, CIMTYPE returnCimType, IWbemClassObject *pOutputParams);

	// Primitive functions to map individual values
	void				MapLongValue (IStream *pOutputStream, long val);
	void				MapShortValue (IStream *pOutputStream, short val);
	void				MapDoubleValue (IStream *pOutputStream, double val);
	void				MapFloatValue (IStream *pOutputStream, float val);
	void				MapBoolValue (IStream *pOutputStream, BOOL val);
	void				MapByteValue (IStream *pOutputStream, unsigned char val);
	void				MapCharValue (IStream *pOutputStream, long val);
	void				MapStringValue (IStream *pOutputStream, BSTR &val);
	STDMETHODIMP		MapReferenceValue (IStream *pOutputStream, bool isArray, VARIANT &var);
	void				MapReferenceValue (IStream *pOutputStream, ParsedObjectPath *pObjectPath, BSTR strPath);

	bool IsReference (VARIANT &var, ParsedObjectPath **ppObjectPath);
	void GetFlagsFromContext(IWbemContext  *pInputFlags);

public:

	CWmiToXml();
    virtual ~CWmiToXml();

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


	// Functions of the IWbemXMLConvertor interface
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapObjectToXML( 
        /* [in] */ IWbemClassObject  *pObject,
		/* [in] */ BSTR *ppPropertyList, DWORD dwNumProperties,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream,
		/* [in[ */ BSTR strClassBasis);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPropertyToXML( 
        /* [in] */ IWbemClassObject  *pObject,
		/* [in] */ BSTR strPropertyName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapInstanceNameToXML( 
        /* [in] */ BSTR  strInstanceName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapClassNameToXML( 
        /* [in] */ BSTR  strClassName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapInstancePathToXML( 
        /* [in] */ BSTR  strInstancePath,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapClassPathToXML( 
        /* [in] */ BSTR  strClassPath,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapMethodResultToXML( 
        /* [in] */ IWbemClassObject  *pMethodResult,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\quals.cpp ===
#include "precomp.h"
#include <olectl.h>
#include <wbemidl.h>
#include <wbemint.h>

#include "wmiconv.h"
#include "maindll.h"

/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 * Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
 *!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


HRESULT CXml2Wmi::AddQualifier (
	IXMLDOMNode *pNode, // A <QUALIFIER> element
	IWbemQualifierSet *pQualSet,
	bool bIsObjectQualifier // Indicates whether this is for an object or for a property
)
{
	HRESULT hr = S_OK;

	BSTR strName = NULL;
	BSTR strType = NULL;
	BSTR strOverridable = NULL;
	BSTR strToSubclass = NULL;
	BSTR strToInstance = NULL;
	BSTR strAmended = NULL;

	// Get the Name of the Qualifier - this is a mandatory attribute
	if(SUCCEEDED(hr))
		hr = GetBstrAttribute (pNode, g_strName, &strName);

	// Dont map the CIMTYPE QUalifier
	// Dont map the "abstract" qualifiers for objects, but map them for properties (for whatever reason)
	if(SUCCEEDED(hr) && _wcsicmp(strName, L"CIMTYPE") == 0 ||
		(bIsObjectQualifier && _wcsicmp(strName, L"abstract") == 0))
	{
		SysFreeString(strName);
		return S_OK;
	}

	// Get a few more attributes - some of these are optional
	// In such cases, we dont check the return value
	if(SUCCEEDED(hr))
		hr = GetBstrAttribute (pNode, g_strType, &strType);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strOverridable, &strOverridable);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strToSubClass, &strToSubclass);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strToInstance, &strToInstance);
	if(SUCCEEDED(hr))
		GetBstrAttribute (pNode, g_strAmended, &strAmended);

	// Build up the flavor of the Qualifier
	//======================================================
	long flavor = 0;
	if(SUCCEEDED(hr))
	{
		if (!strOverridable || (0 == _wcsicmp (strOverridable, L"true")))
			flavor |= WBEM_FLAVOR_OVERRIDABLE;
		else if (0 == _wcsicmp (strOverridable, L"false"))
			flavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;
		else
			hr = WBEM_E_FAILED;
	}
	if (SUCCEEDED(hr))
	{
		if (!strToSubclass || (0 == _wcsicmp (strToSubclass, L"true")))
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
		else if (0 != _wcsicmp (strToSubclass, L"false"))
			hr = WBEM_E_FAILED;
	}
	if (SUCCEEDED(hr))
	{
		if (strToInstance && (0 == _wcsicmp (strToInstance, L"true")))
			flavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
		else if (strToInstance && (0 != _wcsicmp (strToInstance, L"false")))
			hr = WBEM_E_FAILED;
	}
	if (SUCCEEDED(hr))
	{
		if (strAmended && (0 == _wcsicmp (strAmended, L"true")))
			flavor |= WBEM_FLAVOR_AMENDED;
		else if (strAmended && (0 != _wcsicmp (strAmended, L"false")))
			hr = WBEM_E_FAILED;
	}

	// Map the Qualifier type
	CIMTYPE cimtype = CIM_ILLEGAL;
	if (CIM_ILLEGAL == (cimtype = CimtypeFromString (strType)))
		hr = WBEM_E_FAILED;

	// Map the Qualifier value
	//============================
	VARIANT value;
	VariantInit (&value);
	if (SUCCEEDED (hr))
	{
		IXMLDOMNodeList *pNodeList = NULL;
		long length = 0;
		if (SUCCEEDED(hr = pNode->get_childNodes (&pNodeList)))
		{
			if (SUCCEEDED(hr = pNodeList->get_length (&length)) && (1 == length))
			{
				// Get the first node
				IXMLDOMNode *pValueNode = NULL;
				if (SUCCEEDED(hr = pNodeList->nextNode (&pValueNode)) && pValueNode)
				{
					// Get its name
					BSTR strNodeName = NULL;
					if(SUCCEEDED(hr = pValueNode->get_nodeName(&strNodeName)))
					{
						if (0 == _wcsicmp(strNodeName, VALUE_TAG))
						{
							BSTR bsValue = NULL;
							if(SUCCEEDED(hr = pValueNode->get_text(&bsValue)))
							{
								hr = MapStringQualiferValue (bsValue, value, cimtype);
								SysFreeString (bsValue);
							}
						}
						else if (0 == _wcsicmp(strNodeName, VALUEARRAY_TAG))
						{
							hr = MapStringArrayQualiferValue (pValueNode, value, cimtype);
						}

						SysFreeString (strNodeName);
					}
					pValueNode->Release ();
					pValueNode = NULL;
				}
			}

			pNodeList->Release ();
		}
	}

	// Put it all together
	if (SUCCEEDED (hr))
		hr = pQualSet->Put (strName, &value, flavor);

	SysFreeString (strName);
	SysFreeString (strType);
	SysFreeString (strOverridable);
	SysFreeString (strToSubclass);
	SysFreeString (strToInstance);
	SysFreeString (strAmended);

	VariantClear (&value);

	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::MapStringValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXml2Wmi::MapStringQualiferValue (BSTR bsValue, VARIANT &curValue, CIMTYPE cimtype)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;
	VariantInit (&curValue);

	// We're assuming it's not an array
	if (!(cimtype & CIM_FLAG_ARRAY))
	{
		switch (cimtype)
		{
			// RAJESHR - more rigorous syntax checking
			case CIM_UINT8:
			{
				curValue.vt = VT_UI1;
				curValue.bVal = (BYTE) wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
			break;

			case CIM_SINT8:
			case CIM_SINT16:
			{
				curValue.vt = VT_I2;
				curValue.iVal = (short) wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
			break;

			case CIM_UINT16:
			case CIM_UINT32:
			case CIM_SINT32:
			{
				curValue.vt = VT_I4;
				curValue.lVal = wcstol (bsValue, NULL, 0);
				hr = S_OK;
			}
			break;

			case CIM_REAL32:
			{
				curValue.vt = VT_R4;
				curValue.fltVal = (float) wcstod (bsValue, NULL);
				hr = S_OK;
			}
			break;

			case CIM_REAL64:
			{
				curValue.vt = VT_R8;
				curValue.dblVal = wcstod (bsValue, NULL);
				hr = S_OK;
			}
			break;

			case CIM_BOOLEAN:
			{
				curValue.vt = VT_BOOL;
				curValue.boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
							VARIANT_TRUE : VARIANT_FALSE;
				hr = S_OK;
			}
			break;

			case CIM_CHAR16:
			{
				// As per the XML Spec, the following are invalid character values in an XML Stream:
				// Char ::=  #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

				// As per the CIM Operations spec, they need to be escaped as follows:
				//	If the value is not a legal XML character
				//  (as defined in [2, section 2.2] by the Char production)
				//	then it MUST be escaped using a \x<hex> escape convention
				//	where <hex> is a hexadecimal constant consisting of
				//	between one and four digits

				curValue.vt = VT_I2;
				if(_wcsnicmp(bsValue, L"\\x", 2) == 0)
					// It is an escaped value
					swscanf (bsValue+2, L"%x", &(curValue.iVal));
				else
					// It is a normal value
					swscanf (bsValue, L"%c", &(curValue.iVal));
				hr = S_OK;
			}
			break;

			case CIM_STRING:
			case CIM_UINT64:
			case CIM_SINT64:
			case CIM_DATETIME:
			{
				curValue.vt = VT_BSTR;
				curValue.bstrVal = SysAllocString (bsValue);
				hr = S_OK;
			}
			break;
		}
	}

	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::MapStringArrayValue
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		pValueNode		the VALUE.ARRAY node
//		curValue		Placeholder for new value (set on return)
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXml2Wmi::MapStringArrayQualiferValue (
	IXMLDOMNode *pValueNode,
	VARIANT &curValue,
	CIMTYPE cimtype
)
{
	HRESULT hr = WBEM_E_TYPE_MISMATCH;

	// Build a safearray value from the node list
	IXMLDOMNodeList *pValueList = NULL;

	if (SUCCEEDED (pValueNode->get_childNodes (&pValueList)))
	{
		long length = 0;
		pValueList->get_length (&length);
		SAFEARRAYBOUND	rgsabound [1];
		rgsabound [0].lLbound = 0;
		rgsabound [0].cElements = length;
		VARTYPE vt = VTFromCIMType (cimtype & ~CIM_FLAG_ARRAY);
		SAFEARRAY *pArray = NULL;
		if( pArray = SafeArrayCreate (vt, 1, rgsabound))
		{
			IXMLDOMNode *pValue = NULL;
			long ix = 0;
			bool error = false;
			while (!error && SUCCEEDED(pValueList->nextNode(&pValue)) && pValue)
			{
				// Check whether this is a VALUE element
				BSTR strValName = NULL;
				if (SUCCEEDED(pValue->get_nodeName (&strValName)))
				{
					if (0 == _wcsicmp (strValName, VALUE_TAG))
					{
						BSTR bsValue = NULL;
						pValue->get_text (&bsValue);
						if(FAILED(MapStringQualiferValueIntoArray (bsValue, pArray, &ix, vt,
							cimtype & ~CIM_FLAG_ARRAY)))
								error = true;

						SysFreeString (bsValue);
						ix++;
					}
					else
						error = true;

					SysFreeString (strValName);
				}
				else
					error = true;

				pValue->Release ();
				pValue = NULL;
			}

			if(error)
				SafeArrayDestroy(pArray);
			else
			{
				curValue.vt = VT_ARRAY|vt;
				curValue.parray = pArray;
				hr = S_OK;
			}
		}
		else
			hr = E_OUTOFMEMORY;

		pValueList->Release();
	}
	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::MapStringValueIntoArray
//
//  DESCRIPTION:
//
//  Maps XML VALUE.ARRAY/VALUE element content into its WMI VARIANT equivalent form
//
//  PARAMETERS:
//
//		bsValue			the VALUE element content
//		pArray			SAFEARRAY in which to map the value
//		ix				index to map the value into
//		vt				VARTYPE of the SAFEARRAY
//		cimtype			for mapping purposes
//
//  RETURN VALUES:
//
//
//***************************************************************************

HRESULT CXml2Wmi::MapStringQualiferValueIntoArray (
	BSTR bsValue,
	SAFEARRAY *pArray,
	long *ix,
	VARTYPE vt,
	CIMTYPE cimtype)
{
	HRESULT hr = E_FAIL;
	switch (vt)
	{
		case VT_UI1:
		{
			BYTE bVal = (BYTE) wcstol (bsValue, NULL, 0);
			hr = SafeArrayPutElement (pArray, ix, &bVal);
		}
		break;

		case VT_I2:
		{
			short iVal;

			if (CIM_CHAR16 == cimtype)
				swscanf (bsValue, L"%c", &(iVal));
			else
				iVal = (short) wcstol (bsValue, NULL, 0);

			hr = SafeArrayPutElement (pArray, ix, &iVal);
		}
		break;

		case VT_I4:
		{
			long lVal = wcstol (bsValue, NULL, 0);
			hr = SafeArrayPutElement (pArray, ix, &lVal);
		}
		break;

		case VT_R4:
		{
			float fltVal = (float) wcstod (bsValue, NULL);
			hr = SafeArrayPutElement (pArray, ix, &fltVal);
		}
		break;

		case VT_R8:
		{
			double dblVal = wcstod (bsValue, NULL);
			hr = SafeArrayPutElement (pArray, ix, &dblVal);
		}
		break;

		case VT_BOOL:
		{
			VARIANT_BOOL boolVal = (0 == _wcsicmp (bsValue, L"TRUE")) ?
						VARIANT_TRUE : VARIANT_FALSE;
			hr = SafeArrayPutElement (pArray, ix, &boolVal);
		}
		break;

		case VT_BSTR:
			// No need to SysAllocString() since SafeArrayPutElement() does this automatically
			hr = SafeArrayPutElement (pArray, ix, bsValue);
			break;
	}
	return hr;
}

//***************************************************************************
//
//  HRESULT CXml2Wmi::VTFromCIMType
//
//  DESCRIPTION:
//
//  Utility function to map CIMTYPE to its VARTYPE equivalent
//
//  PARAMETERS:
//
//		cimtype			the CIMTYPE to be mapped
//
//  RETURN VALUES:
//
//		The corresponding VARTYPE, or VT_NULL if error
//
//***************************************************************************

VARTYPE CXml2Wmi::VTFromCIMType (CIMTYPE cimtype)
{
	VARTYPE vt = VT_NULL;

	switch (cimtype & ~CIM_FLAG_ARRAY)
	{
		case CIM_UINT8:
			vt = VT_UI1;
			break;

		case CIM_SINT8:
		case CIM_SINT16:
			vt = VT_I2;
			break;

		case CIM_UINT16:
		case CIM_UINT32:
		case CIM_SINT32:
			vt = VT_I4;
			break;

		case CIM_REAL32:
			vt = VT_R4;
			break;

		case CIM_REAL64:
			vt = VT_R8;
			break;

		case CIM_BOOLEAN:
			vt = VT_BOOL;
			break;

		case CIM_CHAR16:
			vt = VT_I2;
			break;

		case CIM_STRING:
		case CIM_UINT64:
		case CIM_SINT64:
		case CIM_DATETIME:
			vt = VT_BSTR;
			break;
	}

	return vt;
}

//***************************************************************************
//
//  HRESULT CXmlToWmi::CIMTypeFromString
//
//  DESCRIPTION:
//
//  Utility function to map type attribute string to its CIMTYPE equivalent
//
//  PARAMETERS:
//
//		bsType			the type string to be mapped
//
//  RETURN VALUES:
//
//		The corresponding CIMTYPE, or CIM_ILLEGAL if error
//
//***************************************************************************
CIMTYPE CXml2Wmi::CimtypeFromString (BSTR bsType)
{
	CIMTYPE cimtype = CIM_ILLEGAL;

	if (bsType)
	{
		if (0 == _wcsicmp (bsType, L"string"))
			cimtype = CIM_STRING;
		else if (0 == _wcsicmp (bsType, L"uint32"))
			cimtype = CIM_UINT32;
		else if (0 == _wcsicmp (bsType, L"boolean"))
			cimtype = CIM_BOOLEAN;
		else if (0 == _wcsicmp (bsType, L"sint32"))
			cimtype = CIM_SINT32;
		else if (0 == _wcsicmp (bsType, L"char16"))
			cimtype = CIM_CHAR16;
		else if (0 == _wcsicmp (bsType, L"uint8"))
			cimtype = CIM_UINT8;
		else if (0 == _wcsicmp (bsType, L"uint16"))
			cimtype = CIM_UINT16;
		else if (0 == _wcsicmp (bsType, L"sint16"))
			cimtype = CIM_SINT16;
		else if (0 == _wcsicmp (bsType, L"uint64"))
			cimtype = CIM_UINT64;
		else if (0 == _wcsicmp (bsType, L"sint64"))
			cimtype = CIM_SINT64;
		else if (0 == _wcsicmp (bsType, L"datetime"))
			cimtype = CIM_DATETIME;
		else if (0 == _wcsicmp (bsType, L"real32"))
			cimtype = CIM_REAL32;
		else if (0 == _wcsicmp (bsType, L"real64"))
			cimtype = CIM_REAL64;
	}

	return cimtype;
}


HRESULT CXml2Wmi::MakeObjectAbstract(IWbemClassObject *pObj, IXMLDOMNode *pAbstractQualifierNode)
{
	HRESULT hr = E_FAIL;

	// Get the object qualifeir set
	IWbemQualifierSet *pQuals = NULL;
	if(SUCCEEDED(hr = pObj->GetQualifierSet(&pQuals)))
	{
		// Add the "abstract" qualiifer
		hr = AddQualifier(pAbstractQualifierNode, pQuals);
		pQuals->Release();
	}
	return hr;
}

  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\tests\main.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <objbase.h>
#include <wbemcli.h>



void FillUpContext(IWbemContext *pContext)
{
	VARIANT vValue;

	// IncludeQualifiers
	VariantInit(&vValue);
	vValue.vt = VT_BOOL;
	vValue.boolVal = VARIANT_FALSE;
	pContext->SetValue(L"IncludeQualifiers", 0, &vValue);
	VariantClear(&vValue);

	// PathLevel
	// 
	// pathLevelAnonymous = 0
	// pathLevelNamed,
	// pathLevelLocal,
	// pathLevelFull		

	VariantInit(&vValue);
	vValue.vt = VT_I4;
	vValue.lVal = 0;
	pContext->SetValue(L"PathLevel", 0, &vValue);
	VariantClear(&vValue);

	// ExcludeSystemProperties
	VariantInit(&vValue);
	vValue.vt = VT_BOOL;
	vValue.boolVal = VARIANT_TRUE;
	pContext->SetValue(L"ExcludeSystemProperties", 0, &vValue);
	VariantClear(&vValue);

}

int _cdecl main(int argc, char * argv[])
{
	if(FAILED(CoInitialize(NULL)))
		return 1;
	HRESULT hr = E_FAIL;
	IWbemObjectTextSrc *pSrc = NULL;

	IWbemLocator *pL = NULL;
	if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
												IID_IWbemLocator, (void**) &pL)))
	{
		// Create a context object
		IWbemContext *pContext = NULL;
		if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER,
													IID_IWbemContext, (void**) &pContext)))
		{
			FillUpContext(pContext);
			IWbemServices *pConnection = NULL;
			BSTR strNs = SysAllocString(L"root\\cimv2");
			BSTR strText = NULL;
			if(SUCCEEDED(hr = pL->ConnectServer(strNs, NULL, NULL, NULL, 0, NULL, NULL, &pConnection)))
			{
				IWbemClassObject *pClass = NULL;
				//BSTR strObj = SysAllocString(L"MethCLass.KeyProp=\"abc\"");
				// BSTR strObj = SysAllocString(L"MethCLass");
				BSTR strObj = SysAllocString(L"Win32_LogicalDisk");

				
				if(SUCCEEDED(hr = CoCreateInstance (CLSID_WbemObjectTextSrc, NULL, CLSCTX_INPROC_SERVER,
															IID_IWbemObjectTextSrc, (void**) &pSrc)))
				{
					// Test for GetObject
					if(SUCCEEDED(hr = pConnection->GetObject(strObj, 0, NULL, &pClass, NULL)))
					{
						if(SUCCEEDED(hr = pSrc->GetText(0, pClass, WMI_OBJ_TEXT_CIM_DTD_2_0, pContext, &strText)))
						{
							printf("GETOBJECT SUCCEEDED\n");
							printf("================================================\n");
							wprintf(strText);
						}
						else
							printf("GetText failed with %x\n", hr);
						pClass->Release();
					}
					else
						printf("GetObject  failed with %x\n", hr);

				}
				else
					printf("CoCreateInstance on WbemObjectTextSrc failed with %x\n", hr);


				// Test for PutClass
				
				strText = SysAllocString(
					L"<CLASS NAME=\"abc\"><PROPERTY NAME=\"__PATH\" TYPE=\"string\"><VALUE>\\\\CALVINIDS\\root\\DEFAULT:abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__NAMESPACE\" TYPE=\"string\"><VALUE>root\\DEFAULT</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__SERVER\" TYPE=\"string\"><VALUE>CALVINIDS</VALUE></PROPERTY><PROPERTY.ARRAY NAME=\"__DERIVATION\" TYPE=\"string\"><VALUE.ARRAY></VALUE.ARRAY></PROPERTY.ARRAY>"
					L"<PROPERTY NAME=\"__PROPERTY_COUNT\" TYPE=\"sint32\"><VALUE>1</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__RELPATH\" TYPE=\"string\"><VALUE>abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__DYNASTY\" TYPE=\"string\"><VALUE>abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__SUPERCLASS\" TYPE=\"string\"></PROPERTY>"
					L"<PROPERTY NAME=\"__CLASS\" TYPE=\"string\"><VALUE>abc</VALUE></PROPERTY>"
					L"<PROPERTY NAME=\"__GENUS\" TYPE=\"sint32\"><VALUE>1</VALUE></PROPERTY>"
					L"<PROPERTY.ARRAY NAME=\"__SECURITY_DESCRIPTOR\" TYPE=\"uint8\"></PROPERTY.ARRAY>"
					L"<PROPERTY NAME=\"__TCREATED\" TYPE=\"uint64\"></PROPERTY>"
					L"<PROPERTY NAME=\"__TEXPIRATION\" TYPE=\"uint64\"></PROPERTY>"
					L"<PROPERTY NAME=\"__TMODIFIED\" TYPE=\"uint64\"></PROPERTY>"
					L"<PROPERTY NAME=\"ssad\" TYPE=\"string\"></PROPERTY></CLASS>");

				IWbemClassObject *pNewObj = NULL;
				/* strText = SysAllocString(L"<INSTANCE CLASSNAME=\"BLUESCREEN\">"\
					L"<PROPERTY NAME=\"STOPCODE\" TYPE=\"string\"><VALUE>e2</VALUE></PROPERTY>"\
					L"<PROPERTY.ARRAY NAME=\"IPADDRESS\" TYPE=\"string\">"\
					L"<VALUE.ARRAY>"\
					L"<VALUE>\"192.168.0.10\"</VALUE>"\
					L"</VALUE.ARRAY>"\
					L"</PROPERTY.ARRAY>"\
					L"</INSTANCE>");*/
				// strText = SysAllocString(L"<CLASS NAME='test'><PROPERTY></PROPERTY></CLASS>");

				if(SUCCEEDED(hr = pSrc->CreateFromText(0, strText, WMI_OBJ_TEXT_CIM_DTD_2_0, NULL, &pNewObj)))
				{
					wprintf(L"\n\nCREATEFROMTEXT() SUCCEEDED FOR %s\n\n", strText); 
					// Test to get the RELPATH
					VARIANT var;
					VariantInit(&var);
					if(FAILED(pNewObj->Get (L"__RELPATH", 0, &var, NULL, NULL)))
						exit(0);

					BSTR strXML = NULL;
					if(SUCCEEDED(hr = pSrc->GetText(0, pNewObj, WMI_OBJ_TEXT_WMI_DTD_2_0, NULL, &strXML)))
					{
						printf("PutClass Succeeded: Result is\n");
						wprintf(strXML);
					}
					else
						printf("GetText on new class failed!\n");
				}
				else
					printf("\n\nCREATEFROMTEXT() FAILED with %x\n\n", hr); 
				


				// Test for ExecQuery
				//BSTR strQuery = SysAllocString(L"Select GroupName, Name, UserName from Win32_ProgramGroup");
				BSTR strQuery = SysAllocString(L"Select * from Win32_ProgramGroup");
				BSTR strQueryLang = SysAllocString(L"WQL");
				IEnumWbemClassObject *pEnum = NULL;
				if(FAILED(hr = CoSetProxyBlanket(pConnection, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, NULL,
					RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_DEFAULT)))
				{
					printf("Failed to set proxy blanket\n");
					exit(1);
				}

				if(SUCCEEDED(hr = pConnection->ExecQuery(strQueryLang, strQuery, 0, NULL, &pEnum)))
				{
					IWbemClassObject *pNextObject = NULL;
					DWORD dwCount = 1;
					while(SUCCEEDED(pEnum->Next(WBEM_INFINITE , 1, &pNextObject, &dwCount)) && dwCount == 1)
					{
						BSTR strText = NULL;
						if(SUCCEEDED(hr = pSrc->GetText(0, pNextObject, WMI_OBJ_TEXT_WMI_DTD_2_0, pContext, &strText)))
						{
							printf("EXECQUERY SUCCEEDED\n");
							printf("================================================\n");
							wprintf(strText);
							SysFreeString(strText);
						}
						else
							printf("GetText failed with %x\n", hr);
						pNextObject->Release();
					}
					pEnum->Release();
				}
				else
					printf("ExecQuery  failed with %x\n", hr);
			
			
			}
			else
				printf("ConnectServer on root\\cimv2 failed with %x\n", hr);
		}
	}
	else
		printf("CoCreateInstance on Locator failed with %x\n", hr);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\maindll.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  MAINDLL.CPP
//
//  rajesh  3/25/2000   Created.
//
// Contains the DLL entry points for the wmi2xml.dll
// This DLL can be used as a COM DLL with 2 components that implement the
// IWbemXMLConvertor and IXMLWbemConvertor interfaces, or it can be treated
// as a non-COM DLL with the entry points WbemObjectToText() and TextToWbemObject()
// The COM usage is done by the WMI Client API that uses XML. It uses the COM 
// components in this DLL to convert to/from XML and WMI.
// The non-COM usage is by the WMI Core for purposed of implementation of th
// IWbemObjectTextSrc interfaces. WMI Core uses the entry points WbemObjectToText
// and TextToWbemObject to implement that interface when used with XML representations
//
//***************************************************************************

#include "precomp.h"
#include <olectl.h>
#include <wbemidl.h>
#include <wbemint.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "classfac.h"
#include "wmiconv.h"
#include "maindll.h"

// These the the CLSIDs of the 2 Components implemented in this DLL
// {610037EC-CE06-11d3-93FC-00805F853771}
DEFINE_GUID(CLSID_WbemXMLConvertor,
0x610037ec, 0xce06, 0x11d3, 0x93, 0xfc, 0x0, 0x80, 0x5f, 0x85, 0x37, 0x71);
// {41388E26-F847-4a9d-96C0-9A847DBA4CFE}
DEFINE_GUID(CLSID_XMLWbemConvertor,
0x41388e26, 0xf847, 0x4a9d, 0x96, 0xc0, 0x9a, 0x84, 0x7d, 0xba, 0x4c, 0xfe);


// Count number of objects and number of locks.
long g_cObj = 0 ;
long g_cLock = 0 ;
HMODULE ghModule = NULL;

// An Object Factory used by TextToWbemObject
_IWmiObjectFactory *g_pObjectFactory = NULL;

// Some const BSTRs
BSTR g_strName = NULL;
BSTR g_strSuperClass = NULL;
BSTR g_strType = NULL;
BSTR g_strClassOrigin = NULL;
BSTR g_strSize = NULL;
BSTR g_strClassName = NULL;
BSTR g_strValueType = NULL;
BSTR g_strToSubClass = NULL;
BSTR g_strToInstance = NULL;
BSTR g_strAmended = NULL;
BSTR g_strOverridable = NULL;
BSTR g_strArraySize = NULL;
BSTR g_strReferenceClass = NULL;

// A critical section to create/delete globals 
CRITICAL_SECTION g_StaticsCreationDeletion;

// A boolean that indicates whether globals have been initialized
bool g_bGlobalsInitialized = false;

// Control-specific registry strings
LPCTSTR WMI_XML_DESCRIPTION	= __TEXT("WMI TO XML Helper");
LPCTSTR XML_WMI_DESCRIPTION	= __TEXT("XML TO WMI Helper");

// Standard registry key/value names
LPCTSTR INPROC32_STR			= __TEXT("InprocServer32");
LPCTSTR INPROC_STR				= __TEXT("InprocServer");
LPCTSTR THREADING_MODEL_STR		= __TEXT("ThreadingModel");
LPCTSTR BOTH_STR				= __TEXT("Both");
LPCTSTR CLSID_STR				= __TEXT("SOFTWARE\\CLASSES\\CLSID\\");
LPCTSTR OBJECT_TXT_SRC_STR		= __TEXT("SOFTWARE\\Microsoft\\WBEM\\TextSource");
LPCTSTR XMLENCODER_STR			= __TEXT("SOFTWARE\\Microsoft\\WBEM\\xml\\Encoders");
LPCTSTR XMLDECODER_STR			= __TEXT("SOFTWARE\\Microsoft\\WBEM\\xml\\Decoders");
LPCTSTR VERSION_1				= __TEXT("1.0");
LPCTSTR VERSION_2				= __TEXT("2.0");

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.
//
//  PARAMETERS:
//
//		hModule           instance handle
//		ulReason          why we are being called
//		pvReserved        reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************
BOOL WINAPI DllMain( HINSTANCE hModule,
                       DWORD  ulReason,
                       LPVOID lpReserved
					 )
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
			DeleteCriticalSection(&g_StaticsCreationDeletion);
			return TRUE;

		case DLL_PROCESS_ATTACH:
			InitializeCriticalSection(&g_StaticsCreationDeletion);
			ghModule = hModule;
	        return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr = E_FAIL;
/*
    if (CLSID_WbemXMLConvertor == rclsid)
	{
		CWmiToXmlFactory *pObj = NULL;
	    
		if (NULL == (pObj = new CWmiToXmlFactory()))
			return ResultFromScode(E_OUTOFMEMORY);
		
		hr=pObj->QueryInterface(riid, ppv);

		if ( FAILED ( hr ) )
		{
			delete pObj ;
		}
	}
	*/
	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
    else if (CLSID_XMLWbemConvertor == rclsid)
	{
		CXmlToWmiFactory *pObj = NULL;
	    
        if (NULL == (pObj = new CXmlToWmiFactory()))
			return ResultFromScode(E_OUTOFMEMORY);
		hr=pObj->QueryInterface(riid, ppv);

		if ( FAILED ( hr ) )
		{
			delete pObj ;
		}
	}
	
	else
        return E_FAIL;
*/

    return hr ;
}


//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	//It is OK to unload if there are no objects or locks on the
    // class factory.

    if (0L==g_cObj && 0L==g_cLock) 
	{
		ReleaseDLLResources();
		return S_OK;
	}

	return S_FALSE;
}


/***************************************************************************
 *
 * SetKeyAndValue
 *
 * Description: Helper function for DllRegisterServer that creates
 * a key, sets a value, and closes that key. If pszSubkey is NULL, then
 * the value is created for the pszKey key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR to the name of a subkey
 *  pszValueName    LPTSTR to the value name to use
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(LPCTSTR pszKey, LPCTSTR pszSubkey, LPCTSTR pszValueName, LPCTSTR pszValue)
{
    HKEY        hKey;
    TCHAR       szKey[256];

    _tcscpy(szKey, pszKey);

	// If a sub key is mentioned, use it.
    if (NULL != pszSubkey)
    {
		_tcscat(szKey, __TEXT("\\"));
        _tcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		szKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue,
			(_tcslen(pszValue)+1)*sizeof(TCHAR)))
		{
		    RegCloseKey(hKey);
			return FALSE;
		}
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 *
 * DeleteKey
 *
 * Description: Helper function for DllUnRegisterServer that deletes the subkey
 * of a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteKey(LPCTSTR pszKey, LPCTSTR pszSubkey)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteKey(hKey, pszSubkey))
	{
	    RegCloseKey(hKey);
		return FALSE;
	}

    RegCloseKey(hKey);
    return TRUE;
}


/***************************************************************************
 *
 * DeleteValue
 *
 * Description: Helper function for DllUnRegisterServer that deletes a value
 * under a key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the name of the key
 *  pszValue		LPTSTR to the name of a value under the key
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL DeleteValue(LPCTSTR pszKey, LPCTSTR pszValue)
{
    HKEY        hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		pszKey, 0, NULL, REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

	if(ERROR_SUCCESS != RegDeleteValue(hKey, pszValue))
	{
	    RegCloseKey(hKey);
		return FALSE;
	}
    RegCloseKey(hKey);
    return TRUE;
}



//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
	TCHAR szModule[512];
	DWORD dwLength = GetModuleFileName(ghModule, szModule, sizeof(szModule)/sizeof(TCHAR));

	if(dwLength < 512)
	{
		memset((szModule + dwLength),0,sizeof(TCHAR));
	}
	else
	{
		return SELFREG_E_CLASS;
	}

	TCHAR szWmiXmlClassID[128];
	TCHAR szWmiXmlCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemXMLConvertor, szWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWmiXmlClassID[128];
	if(StringFromGUID2(CLSID_WbemXMLConvertor, wszWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWmiXmlClassID, -1, szWmiXmlCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWmiXmlCLSIDClassID, CLSID_STR);
	_tcscat(szWmiXmlCLSIDClassID, szWmiXmlClassID);

	// Don't care about the return values. This is because
	// the registration of this COM component has been removed
	// This is added to remove registration from previous installations
	DeleteKey(szWmiXmlCLSIDClassID, INPROC32_STR);		
	DeleteKey(CLSID_STR, szWmiXmlClassID);

/*	//
	// Create entries under CLSID for the Wmi to XML convertor
	//
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, NULL, NULL, WMI_XML_DESCRIPTION))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szWmiXmlCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, BOTH_STR))
		return SELFREG_E_CLASS;
*/
	TCHAR szXmlWmiClassID[128];
	TCHAR szXmlWmiCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_XMLWbemConvertor, szXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszXmlWmiClassID[128];
	if(StringFromGUID2(CLSID_XMLWbemConvertor, wszXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszXmlWmiClassID, -1, szXmlWmiCLSIDClassID, 128, NULL, NULL);

#endif


	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
	_tcscpy(szXmlWmiCLSIDClassID, CLSID_STR);
	_tcscat(szXmlWmiCLSIDClassID, szXmlWmiClassID);


	//
	// Create entries under CLSID for the XML to WMI convertor
	//
	if (FALSE == SetKeyAndValue(szXmlWmiCLSIDClassID, NULL, NULL, XML_WMI_DESCRIPTION))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szXmlWmiCLSIDClassID, INPROC32_STR, NULL, szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(szXmlWmiCLSIDClassID, INPROC32_STR, THREADING_MODEL_STR, BOTH_STR))
		return SELFREG_E_CLASS;

	*/

	// Now create entries for the Core team's implementation of the IWbemObjectTxtSrc interface
	if (FALSE == SetKeyAndValue(OBJECT_TXT_SRC_STR, 
						L"1", // WMI_OBJ_TEXT_CIM_DTD_2_0
						L"TextSourceDLL", szModule))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(OBJECT_TXT_SRC_STR, 
						L"2", // WMI_OBJ_TEXT_WMI_DTD_2_0, NULL
						L"TextSourceDLL", szModule))
		return SELFREG_E_CLASS;


	// We're done with the COM Entries. Now, we need to create our component specific entries.
	// Each WMI XML Encoder/Decoder is registered underneath the key HKLM/Software/Microsoft/WBEM/XML/Encoders
	// For each encoding (including these 2), we will have to create a value with the DTD version as name
	// and a value of the CLSID of the component. So, here we go
	// Remove the braces from the string representation first
	szWmiXmlClassID[wcslen(szWmiXmlClassID)-1] = NULL;
	if (FALSE == SetKeyAndValue(XMLENCODER_STR, NULL, VERSION_1, szWmiXmlClassID+1))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(XMLENCODER_STR, NULL, VERSION_2, szWmiXmlClassID+1))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(XMLDECODER_STR, NULL, VERSION_1, szXmlWmiClassID+1))
		return SELFREG_E_CLASS;
	if (FALSE == SetKeyAndValue(XMLDECODER_STR, NULL, VERSION_2, szXmlWmiClassID+1))
		return SELFREG_E_CLASS;

	return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	TCHAR szModule[512];
	DWORD dwLength = GetModuleFileName(ghModule,szModule, sizeof(szModule)/sizeof(TCHAR));

	if(dwLength < 512)
	{
		memset((szModule + dwLength),0,sizeof(TCHAR));
	}
	else
	{
		return SELFREG_E_CLASS;
	}

	TCHAR szWmiXmlClassID[128];
	TCHAR szWmiXmlCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_WbemXMLConvertor, szWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszWmiXmlClassID[128];
	if(StringFromGUID2(CLSID_WbemXMLConvertor, wszWmiXmlClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszWmiXmlClassID, -1, szWmiXmlClassID, 128, NULL, NULL);

#endif

	_tcscpy(szWmiXmlCLSIDClassID, CLSID_STR);
	_tcscat(szWmiXmlCLSIDClassID, szWmiXmlClassID);

	//
	// Delete the keys for the WMI to XML COM obhect
	//
	// Don't care about the return values. This is because
	// the registration of this COM component has been removed
	// This is retained to remove any old installations of the DLL
	DeleteKey(szWmiXmlCLSIDClassID, INPROC32_STR);		
	DeleteKey(CLSID_STR, szWmiXmlClassID);

	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 

	TCHAR szXmlWmiClassID[128];
	TCHAR szXmlWmiCLSIDClassID[128];

#ifdef UNICODE
	if(StringFromGUID2(CLSID_XMLWbemConvertor, szXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
#else
	WCHAR wszXmlWmiClassID[128];
	if(StringFromGUID2(CLSID_XMLWbemConvertor, wszXmlWmiClassID, 128) == 0)
		return SELFREG_E_CLASS;
	WideCharToMultiByte(CP_ACP, 0, wszXmlWmiClassID, -1, szXmlWmiCLSIDClassID, 128, NULL, NULL);

#endif

	_tcscpy(szXmlWmiCLSIDClassID, CLSID_STR);
	_tcscat(szXmlWmiCLSIDClassID, szXmlWmiClassID);

	//
	// Delete the keys for the XML to WMI COM obhect
	//
	if(FALSE == DeleteKey(szXmlWmiCLSIDClassID, INPROC32_STR))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteKey(CLSID_STR, szXmlWmiClassID))
		return SELFREG_E_CLASS;

	*/

	// Remove the  entries for the Core team's implementation of the IWbemObjectTxtSrc interface
	if (FALSE == DeleteKey(OBJECT_TXT_SRC_STR, /*WMI_OBJ_TEXT_CIM_DTD_2_0, NULL*/ L"1"))
		return SELFREG_E_CLASS;
	if (FALSE == DeleteKey(OBJECT_TXT_SRC_STR, /*WMI_OBJ_TEXT_WMI_DTD_2_0, NULL*/ L"2"))
		return SELFREG_E_CLASS;

	// Delete the non-COM Registry stuff
	if(FALSE == DeleteValue(XMLENCODER_STR, VERSION_1))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteValue(XMLENCODER_STR, VERSION_2))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteValue(XMLDECODER_STR, VERSION_1))
		return SELFREG_E_CLASS;
	if(FALSE == DeleteValue(XMLDECODER_STR, VERSION_2))
		return SELFREG_E_CLASS;
    return NOERROR;
}

// This is called only if this DLL is treated as a NON COM DLL
HRESULT AllocateDLLResources()
{
	HRESULT hr = E_FAIL;
	EnterCriticalSection(&g_StaticsCreationDeletion);
	if(!g_bGlobalsInitialized)
	{
		g_bGlobalsInitialized = true;

		// Increment the object count since this is a COM DLL too.
		// Otherwise a COM Client in the process would call CoFreeUnusedLibraries and
		// this would result in unloading of the DLL while a C++ client is
		// holding on to a proc address obtained using Loadlibrary/GetProcAddress
		InterlockedIncrement(&g_cObj);

		// Create an object factory for use in TextToWbemObject
		if(SUCCEEDED(hr = CoCreateInstance(CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER,
													IID__IWmiObjectFactory, (LPVOID *)&g_pObjectFactory)))
		{
			if(	(g_strName = SysAllocString(L"NAME"))				&&
				(g_strSuperClass = SysAllocString(L"SUPERCLASS")) &&
				(g_strType = SysAllocString(L"TYPE"))				&&
				(g_strClassOrigin = SysAllocString(L"CLASSORIGIN")) &&
				(g_strSize = SysAllocString(L"ARRAYSIZE"))		&&
				(g_strClassName = SysAllocString(L"CLASSNAME"))	&&
				(g_strValueType = SysAllocString(L"VALUETYPE"))	&&
				(g_strToSubClass = SysAllocString(L"TOSUBCLASS"))	&&
				(g_strToInstance = SysAllocString(L"TOINSTANCE"))	&&
				(g_strAmended = SysAllocString(L"AMENDED"))		&&
				(g_strOverridable = SysAllocString(L"OVERRIDABLE")) &&
				(g_strArraySize = SysAllocString(L"ARRAYSIZE")) &&
				(g_strReferenceClass = SysAllocString(L"REFERENCECLASS")) )
			{
				hr = S_OK;
			}
			else
				hr = E_OUTOFMEMORY;
		}

		// Release resources if things did not go well
		if(FAILED(hr))
			ReleaseDLLResources();
	}
	else
		hr = S_OK;
	LeaveCriticalSection(&g_StaticsCreationDeletion);
	return hr;
}


// This is called only if this DLL is treated as a NON COM DLL
// It is the inverse operation of AllocateDLLResources()
HRESULT ReleaseDLLResources()
{
	EnterCriticalSection(&g_StaticsCreationDeletion);
	if(g_bGlobalsInitialized)
	{
		// Decrement the object count even though this isnt a COM call
		// The reason is described in the AllocateDLLResources() call
		InterlockedDecrement(&g_cObj);

		if(g_pObjectFactory)
		{
			g_pObjectFactory->Release();
			g_pObjectFactory = NULL;
		}

		SysFreeString(g_strName);
		g_strName = NULL;
		SysFreeString(g_strSuperClass);
		g_strSuperClass = NULL;
		SysFreeString(g_strType);
		g_strType = NULL;
		SysFreeString(g_strClassOrigin);
		g_strClassOrigin = NULL;
		SysFreeString(g_strSize);
		g_strSize = NULL;
		SysFreeString(g_strClassName);
		g_strClassName = NULL;
		SysFreeString(g_strValueType);
		g_strValueType = NULL;
		SysFreeString(g_strToSubClass);
		g_strToSubClass = NULL;
		SysFreeString(g_strToInstance);
		g_strToInstance = NULL;
		SysFreeString(g_strAmended);
		g_strAmended = NULL;
		SysFreeString(g_strOverridable);
		g_strOverridable = NULL;
		SysFreeString(g_strArraySize);
		g_strArraySize = NULL;
		SysFreeString(g_strReferenceClass);
		g_strReferenceClass = NULL;

		g_bGlobalsInitialized = false;
	}
	LeaveCriticalSection(&g_StaticsCreationDeletion);
	return S_OK;
}

//
// Entry Points for WMI Core's implementation of IWbemObjectTextSrc
//*****************************************************************
HRESULT OpenWbemTextSource(long lFlags, ULONG uObjTextFormat)
{
	return AllocateDLLResources();
}


HRESULT CloseWbemTextSource(long lFlags, ULONG uObjTextFormat)
{
	return ReleaseDLLResources();
}

HRESULT WbemObjectToText(long lFlags, ULONG uObjTextFormat, void *pWbemContext, void *pWbemClassObject, BSTR *pstrText)
{
	if(pWbemClassObject == NULL || pstrText == NULL)
		return WBEM_E_INVALID_PARAMETER;

	// Check to see if we support this encoding format
	if(uObjTextFormat != WMI_OBJ_TEXT_CIM_DTD_2_0 &&
		uObjTextFormat != WMI_OBJ_TEXT_WMI_DTD_2_0 )
		return WBEM_E_INVALID_PARAMETER;

    HRESULT hr = E_FAIL;

	// OpenTextSrc not called and so strings are not yet allocated and initialized
	if(!g_bGlobalsInitialized)
	{
		return WBEM_E_INVALID_OPERATION;
	}

    CWmiToXmlFactory oObjFactory;
	// Create an instance of the convertor
	IWbemXMLConvertor *pConvertor = NULL;
	if(SUCCEEDED(hr = oObjFactory.CreateInstance(NULL, IID_IWbemXMLConvertor, (LPVOID *)&pConvertor)))
	{
		// Create a stream
		IStream *pStream = NULL;
		if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
		{
			// See if we need to write a VALUE.NAMEDOBJECT, VALUE.OBJECTWITHLOCALPATH or VALUE.OBJECTWITHPATH 
			// in the output. This is indicated by the "PathLevel" value in the IWbemContext object, if any
			int iValueTagToWrite = -1;
			if(pWbemContext)
			{
				VARIANT vPathLevel;
				VariantInit(&vPathLevel);
				if(SUCCEEDED(((IWbemContext *)pWbemContext)->GetValue(L"PathLevel", 0, &vPathLevel) ) && vPathLevel.vt != VT_NULL)
				{
					if(vPathLevel.lVal<0 || vPathLevel.lVal>3)
						hr = WBEM_E_INVALID_PARAMETER;

					iValueTagToWrite = vPathLevel.lVal;
					VariantClear(&vPathLevel);
				}
			}

			if(SUCCEEDED(hr))
			{
				switch(iValueTagToWrite)
				{
					case 1: pStream->Write ((void const *)L"<VALUE.NAMEDOBJECT>", wcslen (L"<VALUE.NAMEDOBJECT>") * sizeof (OLECHAR), NULL);break;
					case 2: pStream->Write ((void const *)L"<VALUE.OBJECTWITHLOCALPATH>", wcslen (L"<VALUE.OBJECTWITHLOCALPATH>") * sizeof (OLECHAR), NULL);break;
					case 3: pStream->Write ((void const *)L"<VALUE.OBJECTWITHPATH>", wcslen (L"<VALUE.OBJECTWITHPATH>") * sizeof (OLECHAR), NULL);break;
				}

				// Do the conversion
				if(SUCCEEDED(hr = pConvertor->MapObjectToXML((IWbemClassObject *)pWbemClassObject, NULL, 0,
					(IWbemContext *)pWbemContext, pStream, NULL)))
				{
					// Terminate with the correct tag
					switch(iValueTagToWrite)
					{
						case 1: pStream->Write ((void const *)L"</VALUE.NAMEDOBJECT>", wcslen (L"</VALUE.NAMEDOBJECT>") * sizeof (OLECHAR), NULL);break;
						case 2: pStream->Write ((void const *)L"</VALUE.OBJECTWITHLOCALPATH>", wcslen (L"</VALUE.OBJECTWITHLOCALPATH>") * sizeof (OLECHAR), NULL);break;
						case 3: pStream->Write ((void const *)L"</VALUE.OBJECTWITHPATH>", wcslen (L"</VALUE.OBJECTWITHPATH>") * sizeof (OLECHAR), NULL);break;
					}

					// Get the data from the stream
					LARGE_INTEGER	offset;
					offset.LowPart = offset.HighPart = 0;
					if(SUCCEEDED(hr = pStream->Seek (offset, STREAM_SEEK_SET, NULL)))
					{
						STATSTG statstg;
						if (SUCCEEDED(hr = pStream->Stat(&statstg, STATFLAG_NONAME)))
						{
							ULONG cbSize = (statstg.cbSize).LowPart;
							WCHAR *pText = NULL;

							// Convert the data to a BSTR
							if(pText = new WCHAR [(cbSize/2)])
							{
								if (SUCCEEDED(hr = pStream->Read(pText, cbSize, NULL)))
								{
									*pstrText = NULL;
									if(*pstrText = SysAllocStringLen(pText, cbSize/2))
									{
										hr = S_OK;
									}
									else
										hr = E_OUTOFMEMORY;
								}
								delete [] pText;
							}
						}
					}
				}
			}
			pStream->Release();
		}

		pConvertor->Release();
	}
	return hr;
}

HRESULT TextToWbemObject(long lFlags, ULONG uObjTextFormat, void *pWbemContext, BSTR strText, void **ppWbemClassObject)
{
	return WBEM_E_METHOD_NOT_IMPLEMENTED;

	/* Conversion to Text to Wbem Object has been cut from the WHistler Feature List and hence commented out 
	if(ppWbemClassObject == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// Check to see if we support this encoding format
	if(uObjTextFormat != WMI_OBJ_TEXT_CIM_DTD_2_0 &&
		uObjTextFormat != WMI_OBJ_TEXT_WMI_DTD_2_0 )
		return WBEM_E_INVALID_PARAMETER;

	// See if we should allow WMI extensions
	bool bAllowWMIExtensions = false;
	if(uObjTextFormat == WMI_OBJ_TEXT_WMI_DTD_2_0)
		bAllowWMIExtensions = true;

	HRESULT hr = E_FAIL;
	// Create an XML document for the body
	//==============================
	IXMLDOMDocument *pDocument = NULL;
	if(SUCCEEDED(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
								IID_IXMLDOMDocument, (LPVOID *)&pDocument)))
	{
		VARIANT_BOOL bParse = VARIANT_FALSE;
		if(SUCCEEDED(hr = pDocument->loadXML(strText, &bParse)))
		{
			if(bParse == VARIANT_TRUE)
			{
				// Get the top level element
				IXMLDOMElement *pDocElement = NULL;
				if(SUCCEEDED(hr = pDocument->get_documentElement(&pDocElement)))
				{
					BSTR strDocName = NULL;
					if(SUCCEEDED(pDocElement->get_nodeName(&strDocName)))
					{
						if(_wcsicmp(strDocName, L"CLASS") == 0)
							hr = CXml2Wmi::MapClass(pDocElement, (IWbemClassObject **)ppWbemClassObject, NULL, NULL, false, bAllowWMIExtensions);
						else if(_wcsicmp(strDocName, L"INSTANCE") == 0)
							hr = CXml2Wmi::MapInstance(pDocElement, (IWbemClassObject **)ppWbemClassObject, NULL, NULL, bAllowWMIExtensions);
						else 
							hr = WBEM_E_INVALID_SYNTAX;
						SysFreeString(strDocName);
					}
					else
						hr = WBEM_E_INVALID_SYNTAX;
					pDocElement->Release();
				}
				else
					hr = WBEM_E_FAILED;
			}
			else
			{
				// RAJESHR - This is debugging code to be removed
				IXMLDOMParseError *pError = NULL;
				if(SUCCEEDED(pDocument->get_parseError(&pError)))
				{
					LONG errorCode = 0;
					pError->get_errorCode(&errorCode);
					LONG line=0, linepos=0;
					BSTR reason=NULL, srcText = NULL;
					if(SUCCEEDED(pError->get_line(&line)) &&
						SUCCEEDED(pError->get_linepos(&linepos)) &&
						SUCCEEDED(pError->get_reason(&reason)) &&
						SUCCEEDED(pError->get_srcText(&srcText)))
					{
					}
					pError->Release();
					if(reason)
						SysFreeString(reason);
					if(srcText)
						SysFreeString(srcText);
				}
				hr = WBEM_E_INVALID_SYNTAX;
			}
		}
		else
			hr = WBEM_E_INVALID_SYNTAX;
		pDocument->Release();
	}
	return hr;
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmi2xml\wmi2xml.cpp ===
//***************************************************************************
//
//  (c) 1998 by Microsoft Corporation
//
//  WBEM2XML.CPP
//
//  alanbos  18-Feb-98   Created.
//
//  The WBEM -> XML translator
//
//***************************************************************************

#include "precomp.h"
#include <wbemidl.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#include "wmiconv.h"
#include "wmi2xml.h"

// This is the set of the names of properties that the control
// looks for in an IWbemContext object for modifying its output
const LPCWSTR CWmiToXml::s_wmiToXmlArgs[] =
{
	L"AllowWMIExtensions", // VT_BOOL - self-explanatory
	L"PathLevel", // VT_I4 see typedef enum PathLevel in wmi2xml.h
	L"IncludeQualifiers", // VT_BOOL - self-explanatory
	L"IncludeClassOrigin", // VT_BOOL  - self-explanatory
	L"LocalOnly", // VT_BOOL - local elements (methods, properties, qualifiers) are mapped.
	L"ExcludeSystemProperties", // VT_BOOL - Excludes any WMI System Properties
};


static OLECHAR *CDATASTART = OLESTR("<![CDATA[");
static OLECHAR *CDATAEND = OLESTR("]]>");
static OLECHAR *AMPERSAND = OLESTR("&amp;");
static OLECHAR *LEFTCHEVRON = OLESTR("&lt;");
static OLECHAR *RIGHTCHEVRON = OLESTR("&gt;");
static BYTE XMLNEWLINE [] = { 0x0D, 0x00, 0x0A, 0x00 };
extern long g_cObj;

CWmiToXml::CWmiToXml()
{
	m_cRef = 0;
	m_iPathLevel = pathLevelAnonymous; // RAJESHR - Is this a good default
	m_bAllowWMIExtensions = VARIANT_TRUE;
	m_bLocalOnly = VARIANT_FALSE; // RAJESHR - Change this when core team allows us to set __RELPATH
	m_iQualifierFilter = wmiXMLQualifierFilterNone; 
	m_iClassOriginFilter = wmiXMLClassOriginFilterAll;
	m_bExcludeSystemProperties = VARIANT_FALSE;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CWmiToXml::~CWmiToXml
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CWmiToXml::~CWmiToXml(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CWmiToXml::QueryInterface
// long CWmiToXml::AddRef
// long CWmiToXml::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CWmiToXml::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWbemXMLConvertor==riid)
		*ppv = reinterpret_cast<IWbemXMLConvertor*>(this);

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CWmiToXml::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CWmiToXml::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}


/* 
* This function takes in an IWbemClassObject that represents a Class and
* produces a <CLASS> element in the outputstream
*/
STDMETHODIMP CWmiToXml::MapClass (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis)
{
	HRESULT hr = WBEM_E_FAILED;

	long flav = 0;
	VARIANT var;

	// Write the CLASS tag and its attributes
	//===========================================
	WRITEBSTR( OLESTR("<CLASS NAME=\""))

	// Write the CLASSNAME
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == pObject->Get(L"__CLASS", 0, &var, NULL, &flav))
	{
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
			WRITEBSTR( var.bstrVal)
	}
	VariantClear (&var);
	WRITEBSTR( OLESTR("\""))

	// Write the SUPERCLASS if specified
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == pObject->Get(L"__SUPERCLASS", 0, &var, NULL, &flav))
	{
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			WRITEBSTR( OLESTR(" SUPERCLASS=\""))
			WRITEBSTR( var.bstrVal)
			WRITEBSTR( OLESTR("\""))
		}
	}
	VariantClear (&var);
	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE

	// Map the Qualifiers of the class
	if (pQualSet)
		hr = MapQualifiers (pOutputStream, pQualSet);
	else
		hr = S_OK;

	// Map the Properties
	if (SUCCEEDED(hr))
		hr = MapProperties(pOutputStream, pObject, ppPropertyList, dwNumProperties, strClassBasis, true);

	// Map the Methods
	if (SUCCEEDED(hr))
		hr = MapMethods (pOutputStream, pObject);

	// Terminate the CLASS element
	WRITEBSTR( OLESTR("</CLASS>"))
	WRITENEWLINE

	return hr;
}

STDMETHODIMP CWmiToXml::MapClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	HRESULT hr = E_FAIL;
	WRITEBSTR( OLESTR("<CLASSPATH>"))
	WRITENEWLINE
	if(SUCCEEDED(hr = MapNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapClassName (pOutputStream, pParsedPath->m_pClass);
	}
	WRITEBSTR( OLESTR("</CLASSPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalClassPath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	HRESULT hr = E_FAIL;
	WRITEBSTR( OLESTR("<LOCALCLASSPATH>"))
	WRITENEWLINE
	if(SUCCEEDED(hr = MapLocalNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapClassName (pOutputStream, pParsedPath->m_pClass);
	}
	WRITEBSTR( OLESTR("</LOCALCLASSPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapClassName (IStream *pOutputStream, BSTR bsClassName)
{
	WRITEBSTR( OLESTR("<CLASSNAME NAME=\""))
	WRITEBSTR( bsClassName)
	WRITEBSTR( OLESTR("\"/>"))
	return S_OK;
}

/* 
* This function takes in an IWbemClassObject that represents an Instance and
* produces an <INSTANCE> element in the outputstream
*/
STDMETHODIMP CWmiToXml::MapInstance (IStream *pOutputStream, IWbemClassObject *pObject, IWbemQualifierSet *pQualSet, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis)
{
	HRESULT hr = WBEM_E_FAILED;

	// Write the beginning of the INSTANCE Tag and its attributes
	//===========================================================
	WRITEBSTR( OLESTR("<INSTANCE CLASSNAME=\""))
	// Write the CLASSNAME
	long flav = 0;
	VARIANT var;
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == pObject->Get(L"__CLASS", 0, &var, NULL, &flav))
	{
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			WRITEBSTR( var.bstrVal)
			WRITEBSTR( OLESTR("\">"))
			WRITENEWLINE
		}
	}
	VariantClear (&var);

	// Map Instance Qualifiers if any
	if (pQualSet)
		hr = MapQualifiers (pOutputStream, pQualSet);
	else
		hr = S_OK;

	// Map the properties of the instance
	if(SUCCEEDED(hr))
			hr = MapProperties (pOutputStream, pObject, ppPropertyList, dwNumProperties, strClassBasis, false);

	// Terminate the INSTANCE element
	WRITEBSTR( OLESTR("</INSTANCE>"))
	WRITENEWLINE

	return hr;
}

STDMETHODIMP CWmiToXml::MapInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<INSTANCEPATH>"))
	WRITENEWLINE
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = MapNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapInstanceName (pOutputStream, pParsedPath);
		WRITENEWLINE
	}
	WRITEBSTR( OLESTR("</INSTANCEPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalInstancePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<LOCALINSTANCEPATH>"))
	WRITENEWLINE
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = MapLocalNamespacePath (pOutputStream, pParsedPath)))
	{
		WRITENEWLINE
		hr = MapInstanceName (pOutputStream, pParsedPath);
		WRITENEWLINE
	}
	WRITEBSTR( OLESTR("</LOCALINSTANCEPATH>"))
	return hr;
}

STDMETHODIMP CWmiToXml::MapInstanceName (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<INSTANCENAME CLASSNAME=\""))
	WRITEBSTR( pParsedPath->m_pClass)
	WRITEBSTR( OLESTR("\">"))
	WRITENEWLINE

	// Now write the key bindings - only if not singleton
	if (!(pParsedPath->m_bSingletonObj))
	{
		if ((1 == pParsedPath->m_dwNumKeys) &&
			!((pParsedPath->m_paKeys [0])->m_pName))
		{
			// Use the short form
			WRITENEWLINE
			MapKeyValue (pOutputStream, (pParsedPath->m_paKeys [0])->m_vValue);
			WRITENEWLINE
		}
		else
		{
			// Write each key-value binding
			//=============================
			for (DWORD numKey = 0; numKey < pParsedPath->m_dwNumKeys; numKey++)
			{
				WRITEBSTR( OLESTR("<KEYBINDING "))

				// Write the key name
				WRITEBSTR( OLESTR(" NAME=\""))
				WRITEBSTR( (pParsedPath->m_paKeys [numKey])->m_pName)
				WRITEBSTR( OLESTR("\">"))
				WRITENEWLINE

				// Write the key value
				MapKeyValue (pOutputStream, (pParsedPath->m_paKeys [numKey])->m_vValue);
				WRITENEWLINE

				WRITEBSTR( OLESTR("</KEYBINDING>"))
				WRITENEWLINE
			}
		}
	}
	else
	{
		// Nothing to be done here, since the spec says that
		// INSTANCENAMEs without any keybindings are assumed to be singleton instances
	}

	WRITEBSTR( OLESTR("</INSTANCENAME>"))
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath)
{
	CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
	ParsedObjectPath  *pParsedPath = NULL;
	pathParser.Parse (bsNamespacePath, &pParsedPath) ;

	HRESULT hr = E_FAIL;
	if (pParsedPath)
	{
		hr = MapNamespacePath (pOutputStream, pParsedPath);
		pathParser.Free(pParsedPath);
	}
	else
		hr = WBEM_E_INVALID_SYNTAX;

	return hr;
}

STDMETHODIMP CWmiToXml::MapNamespacePath (IStream *pOutputStream, ParsedObjectPath *pParsedPath)
{
	WRITEBSTR( OLESTR("<NAMESPACEPATH>"))
	WRITENEWLINE
	WRITEBSTR( OLESTR("<HOST>"))

	if (pParsedPath->m_pServer)
		WRITEWSTR( pParsedPath->m_pServer)
	else
		WRITEBSTR( OLESTR("."))

	WRITEBSTR( OLESTR("</HOST>"))
	WRITENEWLINE

	// Map the local namespaces
	HRESULT hr = MapLocalNamespacePath (pOutputStream, pParsedPath);

	WRITEBSTR( OLESTR("</NAMESPACEPATH>"))

	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalNamespacePath (IStream *pOutputStream, BSTR bsNamespacePath)
{
	CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
	ParsedObjectPath  *pParsedPath = NULL;
	pathParser.Parse (bsNamespacePath, &pParsedPath) ;

	HRESULT hr = E_FAIL;
	if (pParsedPath)
	{
		hr = MapLocalNamespacePath (pOutputStream, pParsedPath);
		pathParser.Free(pParsedPath);
	}
	else
		hr = E_FAIL;

	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalNamespacePath (IStream *pOutputStream, ParsedObjectPath *pObjectPath)
{
	WRITEBSTR( OLESTR("<LOCALNAMESPACEPATH>"))
	WRITENEWLINE

	// Map each of the namespace components
	for (DWORD dwIndex = 0; dwIndex < pObjectPath->m_dwNumNamespaces; dwIndex++)
	{
		WRITEBSTR( OLESTR("<NAMESPACE NAME=\""))
		WRITEWSTR( pObjectPath->m_paNamespaces [dwIndex])
		WRITEBSTR( OLESTR("\"/>"))
		WRITENEWLINE
	}

	WRITEBSTR( OLESTR("</LOCALNAMESPACEPATH>"))

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapReferenceProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, bool isArray, long flavor, bool bIsClass)
{
	// CIM does not allow array references, only scalar references
	if(isArray && !m_bAllowWMIExtensions)
		return S_OK;

	HRESULT hr = WBEM_S_NO_ERROR;

	IWbemQualifierSet *pQualSet = NULL;
	if (WBEM_S_NO_ERROR == pObject->GetPropertyQualifierSet (name, &pQualSet))
	{
		// The property name
		if (isArray)
			WRITEBSTR( OLESTR("<PROPERTY.REFARRAY NAME=\""))
		else
			WRITEBSTR( OLESTR("<PROPERTY.REFERENCE NAME=\""))

		// The property name
		WRITEBSTR( name)
		WRITEBSTR( OLESTR("\""))

		// The originating class of this property
		BSTR propertyOrigin = NULL;

		if (WBEM_S_NO_ERROR == pObject->GetPropertyOrigin (name, &propertyOrigin))
		{
			MapClassOrigin (pOutputStream, propertyOrigin, bIsClass);
			SysFreeString(propertyOrigin);
			hr = S_OK;
		}

		if(SUCCEEDED(hr))
			MapLocal (pOutputStream, flavor);

		// The strong class of this property
		if(SUCCEEDED(hr))
			MapStrongType (pOutputStream, pQualSet);

		// Size of array
		if(SUCCEEDED(hr) && isArray)
			MapArraySize (pOutputStream, pQualSet);

		WRITEBSTR( OLESTR(">"))
		WRITENEWLINE

		// Map the qualifiers
		if(SUCCEEDED(hr))
			hr = MapQualifiers (pOutputStream, pQualSet);

		if(SUCCEEDED(hr))
			hr = MapReferenceValue (pOutputStream, isArray, var);

		if (isArray)
			WRITEBSTR( OLESTR("</PROPERTY.REFARRAY>"))
		else
			WRITEBSTR( OLESTR("</PROPERTY.REFERENCE>"))
		pQualSet->Release ();
	}

	return hr;
}

//***************************************************************************
//
//  CWmiToXml::IsReference
//
//  DESCRIPTION:
//
//		The purpose of this function is to examine a single
//		VARIANT value and determine whether it represents a
//		reference or not.
//
//		This is required because when mapping from a reference
//		property value we may encounter nested references within
//		the object path.  Unfortunately the object path syntax
//		is such that we cannot be certain whether a key value
//		represents a reference or a string, datetime or char
//		property.  (This is because a textual object path does
//		not contain as much information as its XML equivalent.)
//
//		This function performs a heuristic test on the value to
//		determine whether it is a reference.
//
//***************************************************************************

bool CWmiToXml::IsReference (VARIANT &var, ParsedObjectPath **ppObjectPath)
{
	ParsedObjectPath *pObjectPath = NULL;
	*ppObjectPath = NULL;
	bool isValidPath = false;

	// RAJESHR - could get the class of which this is a property value
	// and retrieve the type of the current key property - that would
	// be the authoritative answer but it doesn't come cheap.

	if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
	{

		// Parse the object path
		CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
		BOOL status = parser.Parse (var.bstrVal, &pObjectPath);

		if ((0 == status) && pObjectPath)
		{
			// If it's an instance path we should be OK
			if (pObjectPath->IsInstance ())
				isValidPath = true;
			else if (pObjectPath->IsClass ())
			{
				// Hmmm - could be a classpath.  If we have a server
				// and some namespaces that would be a lot better

				if (pObjectPath->m_pServer && (0 < pObjectPath->m_dwNumNamespaces))
				{
					// RAJESHR - At this point we could assume that it is a reference
					// However, we've found a case in PCHealth where they do a
					// select * from Win32_ProgramGroup and it so happens that
					// one of the properties has a value "ntdev\rajeshr:Accessories"
					// which is CIM_STRING but actually matches a WMI class path
					// So, we need to try to connect ot this machine or namespace here
					// to check whether it is a classpath.

				}
				else
				{
					// A potential local class path
					// RAJESHR - try grabbing the class to see if it exists in
					// the current namespace.
				}
			}
		}
		// Apply one more heuristic - see whether it begins with "umi:"
		else
		{
			if(_wcsnicmp(var.bstrVal, L"umi:", wcslen(L"umi:")) == 0)
				isValidPath = true;
		}

		if (isValidPath)
			*ppObjectPath = pObjectPath;
		else
		{
			// Reject for now - too ambiguous
			parser.Free(pObjectPath);
			pObjectPath = NULL;
		}
	}

	return isValidPath;
}

HRESULT CWmiToXml::MapReferenceValue (IStream *pOutputStream, bool isArray, VARIANT &var)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR( OLESTR("<VALUE.REFARRAY>"))
		for (long i = 0; i<=uBound; i++)
		{
			BSTR pNextElement = NULL;
			if(SUCCEEDED(hr = SafeArrayGetElement(var.parray, (LONG *)&i, (LPVOID )&pNextElement )))
			{
				// Map the value - this will be a classpath or instancepath
				if ((NULL != pNextElement) && (wcslen (pNextElement) > 0))
				{
					// Parse the object path
					// We have 2 possibilities here
					// 1. The path is a Nova style path in which case it can be transformed into
					//		a DMTF style VALUE.REFERENCE
					// 2. It is a Whistler style scoped path or an UMI path. In this case,
					//		we have to transform it into a VALUE element (inside a VALUE.REFERENCE element)
					//		with the exact string representation of the path
					// The second vase is indicated it the parsing fails.
					CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
					ParsedObjectPath  *pObjectPath = NULL;
					BOOL status = parser.Parse (pNextElement, &pObjectPath) ;

					// pObjectPath might be NULL here, in which case it falls under category 2 above
					MapReferenceValue (pOutputStream, pObjectPath, pNextElement);

					if (pObjectPath)
						parser.Free(pObjectPath);
				}

				SysFreeString(pNextElement);
			}
		}
		WRITEBSTR( OLESTR("</VALUE.REFARRAY>"))
	}
	else
	{
		// Map the value - this will be a classpath or instancepath
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			// Parse the object path
			CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
			ParsedObjectPath  *pObjectPath = NULL;
			BOOL status = parser.Parse (var.bstrVal, &pObjectPath) ;

			// We have 2 possibilities here
			// 1. The path is a Nova style path in which case it can be transformed into
			//		a DMTF style VALUE.REFERENCE
			// 2. It is a Whistler style scoped path or an UMI path. In this case,
			//		we have to transform it into a VALUE element (inside a VALUE.REFERENCE element)
			//		with the exact string representation of the path
			// The second vase is indicated it the parsing fails.
			MapReferenceValue (pOutputStream, pObjectPath, var.bstrVal);

			if (pObjectPath)
				parser.Free(pObjectPath);
		}
	}

	return hr;
}

// This function maps a reference value to XML
// We have 2 possibilities for the path in the reference value :
// 1. The path is a Nova style path in which case it can be transformed into
//		a DMTF style VALUE.REFERENCE
// 2. It is a Whistler style scoped path or an UMI path. In this case,
//		we have to transform it into a VALUE element (inside a VALUE.REFERENCE element)
//		with the exact string representation of the path
// The second vase is indicated by a NULL value for pObjectPath, in which case, we just
// use the contents of strPath
void CWmiToXml::MapReferenceValue (IStream *pOutputStream, ParsedObjectPath  *pObjectPath, BSTR strPath)
{
	WRITEBSTR( OLESTR("<VALUE.REFERENCE>"))
	WRITENEWLINE

	// Is it a Nova-style or DMTF style path?
	if(pObjectPath)
	{
		BOOL bIsAbsolutePath = (NULL != pObjectPath->m_pServer);
		BOOL bIsRelativePath = FALSE;

		if (!bIsAbsolutePath)
			bIsRelativePath = (0 < pObjectPath->m_dwNumNamespaces);

		// Is this is a class or is it an instance?
		if (pObjectPath->IsClass ())
		{
			if (bIsAbsolutePath)
				MapClassPath (pOutputStream, pObjectPath);
			else if (bIsRelativePath)
				MapLocalClassPath (pOutputStream, pObjectPath);
			else
				MapClassName (pOutputStream, pObjectPath->m_pClass);
		}
		else if (pObjectPath->IsInstance ())
		{
			if (bIsAbsolutePath)
				MapInstancePath (pOutputStream, pObjectPath);
			else if (bIsRelativePath)
				MapLocalInstancePath (pOutputStream, pObjectPath);
			else
				MapInstanceName (pOutputStream, pObjectPath);
		}
	}
	else // Ugh it is a Whistler or WMI Path
	{
		WRITEBSTR( OLESTR("<VALUE>"))
		MapStringValue(pOutputStream, strPath);
		WRITEBSTR( OLESTR("</VALUE>"))
	}

	WRITENEWLINE
	WRITEBSTR( OLESTR("</VALUE.REFERENCE>"))
}

STDMETHODIMP CWmiToXml::MapQualifiers (IStream *pOutputStream, 
			IWbemQualifierSet *pQualSet, IWbemQualifierSet *pQualSet2)
{
	if (wmiXMLQualifierFilterNone != m_iQualifierFilter)
	{
		// Map the requested filter to the flags value - default is ALL
		LONG lFlags = 0;
		if (wmiXMLQualifierFilterLocal == m_iQualifierFilter)
			lFlags = WBEM_FLAG_LOCAL_ONLY;
		else if (wmiXMLQualifierFilterPropagated == m_iQualifierFilter)
			lFlags = WBEM_FLAG_PROPAGATED_ONLY;
		else if (wmiXMLQualifierFilterAll == m_iQualifierFilter)
		{
			if(m_bLocalOnly == VARIANT_TRUE)
				lFlags = WBEM_FLAG_LOCAL_ONLY;
			// Else you get all qualifiers
		}

		pQualSet->BeginEnumeration (lFlags);

		VARIANT var;
		VariantInit (&var);
		long flavor = 0;
		BSTR name = NULL;

		while (WBEM_S_NO_ERROR  == pQualSet->Next (0, &name, &var, &flavor))
		{
			MapQualifier (pOutputStream, name, flavor, var);
			SysFreeString (name);
			name = NULL;
			VariantClear (&var);
		}

		pQualSet->EndEnumeration ();

		// Now check the subsiduary set for any qualifiers not in the first set
		if (pQualSet2)
		{
			pQualSet2->BeginEnumeration (lFlags);

			while (WBEM_S_NO_ERROR == pQualSet2->Next (0, &name, &var, &flavor))
			{
				// Is this qualifier in the primary set?
				if (WBEM_E_NOT_FOUND == pQualSet->Get (name, 0, NULL, NULL))
					MapQualifier (pOutputStream, name, flavor, var);

				SysFreeString (name);
				name = NULL;
				VariantClear (&var);
			}

			pQualSet2->EndEnumeration ();
		}
	}

	return WBEM_S_NO_ERROR;
}

void CWmiToXml::MapLocal (IStream *pOutputStream, long flavor)
{
	// default is FALSE
	if (WBEM_FLAVOR_ORIGIN_PROPAGATED == (WBEM_FLAVOR_MASK_ORIGIN & flavor))
		WRITEBSTR( OLESTR(" PROPAGATED=\"true\""))
}

STDMETHODIMP CWmiToXml::MapQualifier (IStream *pOutputStream, BSTR name, long flavor, VARIANT &var)
{
	// The qualifier name
	WRITEBSTR( OLESTR("<QUALIFIER NAME=\""))
	WRITEBSTR( name)
	WRITEBSTR( OLESTR("\""))
	MapLocal (pOutputStream, flavor);

	// The qualifier CIM type
	WRITEBSTR( OLESTR(" TYPE=\""))
	switch (var.vt & ~VT_ARRAY)
	{
		case VT_I4:
			WRITEBSTR( OLESTR("sint32"))
			break;

		case VT_R8:
			WRITEBSTR( OLESTR("real64"))
			break;

		case VT_BOOL:
			WRITEBSTR( OLESTR("boolean"))
			break;

		case VT_BSTR:
			WRITEBSTR( OLESTR("string"))
			break;
	}

	WRITEBSTR( OLESTR("\""))

	// Whether the qualifier is overridable - default is TRUE
	if (WBEM_FLAVOR_NOT_OVERRIDABLE == (WBEM_FLAVOR_MASK_PERMISSIONS & flavor))
		WRITEBSTR( OLESTR(" OVERRIDABLE=\"false\""))

	// Whether the qualifier is propagated to subclasses - default is TRUE
	if (!(WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS & flavor))
		WRITEBSTR( OLESTR(" TOSUBCLASS=\"false\""))

	// Whether the qualifier is propagated to instances - default is FALSE
	if ((WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE & flavor))
		WRITEBSTR( OLESTR(" TOINSTANCE=\"true\""))


	/* RAJESHR - This change has been put off until the CIM DTD gets modified
	 * Whether the qualifier is propagated to instances - default is FALSE
	 * This is absent from the CIM DTD
	if (m_bAllowWMIExtensions && (WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE & flavor))
		WRITEBSTR( OLESTR(" TOINSTANCE=\"true\""))
	*/

	// Whether the qualifier is an amended one - default is FALSE
	// This is absent from the CIM DTD
	if (m_bAllowWMIExtensions && (WBEM_FLAVOR_AMENDED & flavor))
		WRITEBSTR( OLESTR(" AMENDED=\"true\""))

	// Currently set TRANSLATABLE as "FALSE" by default. WMI does not use this flavor

	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE

	// Now map the value
	MapValue (pOutputStream, var);

	WRITEBSTR( OLESTR("</QUALIFIER>"))

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapValue (IStream *pOutputStream, VARIANT &var)
{
	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (var.vt & VT_ARRAY)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR( OLESTR("<VALUE.ARRAY>"))

		for (long i = 0; i <= uBound; i++)
		{
			WRITEBSTR( OLESTR("<VALUE>"))

			// Write the value itself
			switch (var.vt & ~VT_ARRAY)
			{
				case VT_I4:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapLongValue (pOutputStream, val);
				}
					break;

				case VT_R8:
				{
					double val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapDoubleValue (pOutputStream, val);
				}
					break;

				case VT_BOOL:
				{
					VARIANT_BOOL val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapBoolValue (pOutputStream, (val) ? TRUE : FALSE);
				}
					break;

				case VT_BSTR:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					MapStringValue (pOutputStream, val);
					SysFreeString (val);
				}
					break;
			}
			WRITEBSTR( OLESTR("</VALUE>"))
			WRITENEWLINE
		}

		WRITEBSTR( OLESTR("</VALUE.ARRAY>"))
	}
	else
	{
		// Simple value
		WRITEBSTR( OLESTR("<VALUE>"))
		switch (var.vt)
		{
			case VT_I4:
				MapLongValue (pOutputStream, var.lVal);
				break;

			case VT_R8:
				MapDoubleValue (pOutputStream, var.dblVal);
				break;

			case VT_BOOL:
				MapBoolValue (pOutputStream, (var.boolVal) ? TRUE : FALSE);
				break;

			case VT_BSTR:
				MapStringValue (pOutputStream, var.bstrVal);
				break;
		}

		WRITEBSTR( OLESTR("</VALUE>"))
	}

	return WBEM_S_NO_ERROR;
}

// This function is used to create a KEYVALUE element
// This element, besides having the value of the property
// also has a type indicator in the form of the VALUETYPE attribute
STDMETHODIMP CWmiToXml::MapKeyValue (IStream *pOutputStream, VARIANT &var)
{
	ParsedObjectPath *pObjectPath = NULL;

	// This could be simple value or a reference value
	// Note that keys are not allowed to be arrays
	if (IsReference (var, &pObjectPath))
	{
		// If the above function returns true, then we're sure that the variant is of type VT_BSTR
		MapReferenceValue (pOutputStream, pObjectPath, var.bstrVal);
		delete pObjectPath;
	}
	else
	{
		// Simple value
		WRITEBSTR( OLESTR("<KEYVALUE"))

		switch (var.vt)
		{
			case VT_I4:
				WRITEBSTR( OLESTR(" VALUETYPE=\"numeric\">"))
				MapLongValue (pOutputStream, var.lVal);
				break;

			case VT_R8:
				WRITEBSTR( OLESTR(" VALUETYPE=\"numeric\">"))
				MapDoubleValue (pOutputStream, var.dblVal);
				break;

			case VT_BOOL:
				WRITEBSTR( OLESTR(" VALUETYPE=\"boolean\">"))
				MapBoolValue (pOutputStream, (var.boolVal) ? TRUE : FALSE);
				break;

			case VT_BSTR:
				WRITEBSTR(OLESTR(" VALUETYPE=\"string\">"))
				// RAJESHR - We assume that the object path parser will have suitably unescaped
				// the escaped characters in the object path
				// If this is not the case, then we need to unescape it manually
				MapStringValue (pOutputStream, var.bstrVal);
				break;
		}

		WRITEBSTR( OLESTR("</KEYVALUE>"))
	}

	return WBEM_S_NO_ERROR;
}

// In this function we produce PROPERTY elements for each of the properties of an IWbemClassObject
// or if a property list is specified, then only for each of the properties in that list
STDMETHODIMP CWmiToXml::MapProperties (IStream *pOutputStream, IWbemClassObject *pObject, BSTR *ppPropertyList, DWORD dwNumProperties, BSTR strClassBasis, bool bIsClass)
{
	// Check to see if a property list is specified. If so, we map only those properties
	if (dwNumProperties && ppPropertyList)
	{
		VARIANT var;
		VariantInit (&var);
		long flavor = 0;
		CIMTYPE cimtype = CIM_ILLEGAL;

		for (DWORD i = 0; i < dwNumProperties; i++)
		{
			// A class basis may be optionally specified for this class
			// this happens in case of Enumerations and we have to filter out derived class properties
			// since the DMTF concept of SHALLOW enumeration is differnet from WMI's definition
			if (PropertyDefinedForClass (pObject, ppPropertyList [i], strClassBasis))
			{
				if (WBEM_S_NO_ERROR == pObject->Get (ppPropertyList [i], 0, &var, &cimtype, &flavor))
				{
					switch (cimtype & ~CIM_FLAG_ARRAY)
					{
						case CIM_OBJECT:
							MapObjectProperty (pOutputStream, pObject, ppPropertyList [i], var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
							break;

						case CIM_REFERENCE:
							MapReferenceProperty (pOutputStream, pObject, ppPropertyList [i], var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor,bIsClass);
							break;

						default:
							MapProperty (pOutputStream, pObject, ppPropertyList [i], var, cimtype & ~CIM_FLAG_ARRAY,
													(cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
							break;
					}
					VariantClear (&var);
				}
			}
		}
	}
	else
	{
		// Note that we cannot set the LOCAL_ONLY flag for the enumeration since this is mutually exclusive
		// with the NONSYSTEM Flag.
		// Hence we use the property flavour to check whether it is local or not below.
		// We dont want System propertied going to DMTF servers
		if(SUCCEEDED(pObject->BeginEnumeration (
			(m_bAllowWMIExtensions == VARIANT_FALSE || m_bExcludeSystemProperties == VARIANT_TRUE)? WBEM_FLAG_NONSYSTEM_ONLY : 0)))
		{
			VARIANT var;
			VariantInit (&var);
			long flavor = 0;
			CIMTYPE cimtype = CIM_ILLEGAL;
			BSTR name = NULL;

			while (WBEM_S_NO_ERROR  == pObject->Next (0, &name, &var, &cimtype, &flavor))
			{
				// If only local properties are being asked for, then skip this if it is not local 
				// Dont skip system properties though
				if(m_bLocalOnly == VARIANT_FALSE ||
					(m_bLocalOnly == VARIANT_TRUE && 
									((flavor == WBEM_FLAVOR_ORIGIN_LOCAL) || (flavor == WBEM_FLAVOR_ORIGIN_SYSTEM))   ))
				{
					// A class basis may be optionally specified for this call
					// this happens in case of Enumerations and we have to filter out derived class properties
					// since the DMTF concept of SHALLOW enumeration is differnet from WMI's definition
					if (PropertyDefinedForClass (pObject, name,strClassBasis))
					{
						switch (cimtype & ~CIM_FLAG_ARRAY)
						{
							case CIM_OBJECT:
								MapObjectProperty (pOutputStream, pObject, name, var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
								break;

							case CIM_REFERENCE:
								MapReferenceProperty (pOutputStream, pObject, name, var, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
								break;

							default:
								MapProperty (pOutputStream, pObject, name, var, cimtype & ~CIM_FLAG_ARRAY,
														(cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, flavor, bIsClass);
								break;
						}
					}
				}
				SysFreeString (name);
				VariantClear (&var);
			}
		}

		pObject->EndEnumeration ();
	}
	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var, CIMTYPE cimtype,
										BOOL isArray, long flavor, bool bIsClass)
{
	HRESULT hr = WBEM_S_NO_ERROR;
			
	// The property name
	if (isArray)
		WRITEBSTR( OLESTR("<PROPERTY.ARRAY NAME=\""))
	else
		WRITEBSTR( OLESTR("<PROPERTY NAME=\""))
	WRITEBSTR( name)
	WRITEBSTR( OLESTR("\""));
		
	// The originating class of this property
	BSTR propertyOrigin = NULL;

	if (WBEM_S_NO_ERROR == pObject->GetPropertyOrigin (name, &propertyOrigin))
	{
		MapClassOrigin (pOutputStream, propertyOrigin, bIsClass);
		SysFreeString(propertyOrigin);
	}

	MapLocal (pOutputStream, flavor);

	// The property CIM type
	hr = MapType (pOutputStream, cimtype);

	// Get the Qualifier Set of the property at this time
	// Note that system properties do not have qualifiers sets
	// Map the Array Size attribute if this is an array type
	IWbemQualifierSet *pQualSet= NULL;
	if (SUCCEEDED(hr) && (_wcsnicmp(name, L"__", 2) != 0) )
	{
		if(WBEM_S_NO_ERROR == (hr = pObject->GetPropertyQualifierSet (name, &pQualSet))) 
		{
			if (isArray)
				MapArraySize (pOutputStream, pQualSet);
		}
	}
	
	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE 

	// Map the qualifiers (note that system properties have no qualifiers)
	if(SUCCEEDED(hr) && pQualSet)
		hr = MapQualifiers (pOutputStream, pQualSet);

	// Now map the value
	if(SUCCEEDED(hr))
		hr = MapValue (pOutputStream, cimtype, isArray, var);

	if (isArray)
		WRITEBSTR( OLESTR("</PROPERTY.ARRAY>"))
	else
		WRITEBSTR( OLESTR("</PROPERTY>"))

	if(pQualSet)
		pQualSet->Release ();
	
	return hr;
}

STDMETHODIMP CWmiToXml::MapObjectProperty (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, VARIANT &var,
										BOOL isArray, long flavor, bool bIsClass)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemQualifierSet *pQualSet= NULL;

	/*
	 * Only map embedded objects when WMI extensions are allowed
	 */

	if (m_bAllowWMIExtensions)
	{
		if (WBEM_S_NO_ERROR == (hr = pObject->GetPropertyQualifierSet (name, &pQualSet)))
		{
			// The property name
			if (isArray)
				WRITEBSTR( OLESTR("<PROPERTY.OBJECTARRAY NAME=\""))
			else
				WRITEBSTR( OLESTR("<PROPERTY.OBJECT NAME=\""))
			WRITEBSTR( name)
			WRITEBSTR( OLESTR("\""));

			// The originating class of this property
			BSTR propertyOrigin = NULL;

			if (WBEM_S_NO_ERROR == pObject->GetPropertyOrigin (name, &propertyOrigin))
			{
				MapClassOrigin (pOutputStream, propertyOrigin, bIsClass);
				SysFreeString(propertyOrigin);
			}

			MapLocal (pOutputStream, flavor);
			MapStrongType (pOutputStream, pQualSet);

			if (isArray)
				MapArraySize (pOutputStream, pQualSet);

			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			MapQualifiers (pOutputStream, pQualSet);

			// Now map the value
			hr = MapEmbeddedObjectValue (pOutputStream, isArray, var);

			if (isArray)
				WRITEBSTR( OLESTR("</PROPERTY.OBJECTARRAY>"))
			else
				WRITEBSTR( OLESTR("</PROPERTY.OBJECT>"))

			pQualSet->Release ();
		}
	}

	return hr;
}


void CWmiToXml::MapArraySize (IStream *pOutputStream, IWbemQualifierSet *pQualSet)
{
	// RAJESHR - RAID 29167 covers the fact that case (1) below
	// should not be valid (but this is what the MOF compiler
	// does) - need to change the code when that bug is fixed
	// to be more strict.

	/*
	 * We defined the ARRAYSIZE element if the qualifier set
	 * satisfies one of the following constraints:
	 *
	 * 1) MAX is present with a positive integer value, and MIN
	 *    is absent.
	 *
	 * 2) MAX and MIN are both present, with the same positive
	 *    integer value.
	 */

	VARIANT var;
	VariantInit (&var);
	BOOL	isFixed = FALSE;

	if (WBEM_S_NO_ERROR == pQualSet->Get(L"MAX", 0, &var, NULL))
	{
		if ((V_VT(&var) == VT_I4) && (0 < var.lVal))
		{
			// Promising - have a candidate MAX value.  Now
			// look for a MIN
			long arraySize = var.lVal;

			if (WBEM_S_NO_ERROR == pQualSet->Get(L"MIN", 0, &var, NULL))
			{
				if ((V_VT(&var) == VT_I4) && (0 < var.lVal))
				{
					// Have a value - check if it's the same as MAX

					isFixed = (arraySize == var.lVal);
				}
			}
			else
				isFixed = TRUE;		// NO MIN only max
		}
	}

	if (isFixed)
	{
		WRITEBSTR( OLESTR(" ARRAYSIZE=\""))
		MapLongValue (pOutputStream, var.lVal);
		WRITEBSTR( OLESTR("\""))
	}

	VariantClear (&var);
}

void CWmiToXml::MapStrongType (IStream *pOutputStream, IWbemQualifierSet *pQualSet)
{
	VARIANT var;
	VariantInit(&var);

	if ((WBEM_S_NO_ERROR == pQualSet->Get(L"CIMTYPE",  0, &var,  NULL))
		&& (VT_BSTR == var.vt))
	{
		// Split out the class (if any) from the ref
		LPWSTR ptr = wcschr (var.bstrVal, OLECHAR(':'));

		if ((NULL != ptr) && (1 < wcslen(ptr)))
		{
			int classLen = wcslen(ptr) - 1;
			LPWSTR classPtr = NULL;
			if(classPtr = new OLECHAR[classLen + 1])
			{
				wcscpy (classPtr, ptr+1);
				BSTR pszClass = NULL;
				if(pszClass = SysAllocString(classPtr))
				{
					WRITEBSTR( OLESTR(" REFERENCECLASS=\""))
					WRITEBSTR( pszClass)
					WRITEBSTR( OLESTR("\""))
					SysFreeString(pszClass);
				}
				delete [] classPtr;
			}
		}
	}

	VariantClear(&var);
}

STDMETHODIMP CWmiToXml::MapType (IStream *pOutputStream, CIMTYPE cimtype)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	WRITEBSTR( OLESTR(" TYPE=\""))
	switch (cimtype)
	{
		case CIM_SINT8:
			WRITEBSTR( OLESTR("sint8"))
			break;

		case CIM_UINT8:
			WRITEBSTR( OLESTR("uint8"))
			break;

		case CIM_SINT16:
			WRITEBSTR( OLESTR("sint16"))
			break;

		case CIM_UINT16:
			WRITEBSTR( OLESTR("uint16"))
			break;

		case CIM_SINT32:
			WRITEBSTR( OLESTR("sint32"))
			break;

		case CIM_UINT32:
			WRITEBSTR( OLESTR("uint32"))
			break;

		case CIM_SINT64:
			WRITEBSTR( OLESTR("sint64"))
			break;

		case CIM_UINT64:
			WRITEBSTR( OLESTR("uint64"))
			break;

		case CIM_REAL32:
			WRITEBSTR( OLESTR("real32"))
			break;

		case CIM_REAL64:
			WRITEBSTR( OLESTR("real64"))
			break;

		case CIM_BOOLEAN:
			WRITEBSTR( OLESTR("boolean"))
			break;

		case CIM_STRING:
			WRITEBSTR( OLESTR("string"))
			break;

		case CIM_DATETIME:
			WRITEBSTR( OLESTR("datetime"))
			break;

		case CIM_CHAR16:
			WRITEBSTR( OLESTR("char16"))
			break;

		default:
			// Don't recognize this type
			hr = WBEM_E_FAILED;
	}

	WRITEBSTR( OLESTR("\""))

	return hr;
}

STDMETHODIMP CWmiToXml::MapValue (IStream *pOutputStream, CIMTYPE cimtype, BOOL isArray, VARIANT &var)
{
	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR( OLESTR("<VALUE.ARRAY>"))

		for (long i = 0; i <= uBound; i++)
		{
			WRITEBSTR( OLESTR("<VALUE>"))

			switch (cimtype)
			{
				case CIM_UINT8:
				{
					unsigned char val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapByteValue (pOutputStream, val);
				}
					break;

				case CIM_SINT8:
				case CIM_SINT16:
				{
					short val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapShortValue (pOutputStream, val);
				}
					break;

				case CIM_UINT16:
				case CIM_UINT32:
				case CIM_SINT32:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapLongValue (pOutputStream, val);
				}
					break;

				case CIM_REAL32:
				{
					float val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapFloatValue (pOutputStream, val);
				}
					break;

				case CIM_REAL64:
				{
					double val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapDoubleValue (pOutputStream, val);
				}
					break;

				case CIM_BOOLEAN:
				{
					VARIANT_BOOL val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapBoolValue (pOutputStream, (val)? TRUE : FALSE);
				}
					break;

				case CIM_CHAR16:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapCharValue (pOutputStream, val);
				}
					break;

				case CIM_STRING:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					MapStringValue (pOutputStream, val);
					SysFreeString (val);
				}
					break;

				case CIM_UINT64:
				case CIM_SINT64:
				case CIM_DATETIME:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					WRITEBSTR( val)
					SysFreeString(val);
				}
					break;
			}
			WRITEBSTR( OLESTR("</VALUE>"))
			WRITENEWLINE
		}

		WRITEBSTR( OLESTR("</VALUE.ARRAY>"))
	}
	else
	{
		// Simple value
		WRITEBSTR( OLESTR("<VALUE>"))
		switch (cimtype)
		{
			case CIM_UINT8:
				MapByteValue (pOutputStream, var.bVal);
				break;

			case CIM_SINT8:
			case CIM_SINT16:
				MapShortValue (pOutputStream, var.iVal);
				break;

			case CIM_UINT16:
			case CIM_UINT32:
			case CIM_SINT32:
				MapLongValue (pOutputStream, var.lVal);
				break;

			case CIM_REAL32:
				MapFloatValue (pOutputStream, var.fltVal);
				break;

			case CIM_REAL64:
				MapDoubleValue (pOutputStream, var.dblVal);
				break;

			case CIM_BOOLEAN:
				MapBoolValue (pOutputStream, (var.boolVal) ? TRUE : FALSE);
				break;

			case CIM_CHAR16:
				MapCharValue (pOutputStream, var.lVal);
				break;

			case CIM_STRING:
				MapStringValue (pOutputStream, var.bstrVal);
				break;

			case CIM_UINT64:
			case CIM_SINT64:
			case CIM_DATETIME:
				WRITEBSTR( var.bstrVal)
				break;
		}
		WRITEBSTR( OLESTR("</VALUE>"))
	}

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapEmbeddedObjectValue (IStream *pOutputStream, BOOL isArray, VARIANT &var)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR(OLESTR("<VALUE.OBJECTARRAY>"))
		for (long i = 0; i<=uBound; i++)
		{
			IUnknown *pNextElement = NULL;
			if(SUCCEEDED(hr = SafeArrayGetElement(var.parray, (LONG *)&i, (LPVOID )&pNextElement )))
			{
				IWbemClassObject *pEmbeddedObject = NULL;
				if(SUCCEEDED(hr = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
				{
					// Note that we always use PathLevelAnonymous here since embedded objects are VALUE.OBJECTs as per the DTD
					CWmiToXml wbemToXml;
					wbemToXml.m_iPathLevel = pathLevelAnonymous;
					wbemToXml.m_bAllowWMIExtensions = m_bAllowWMIExtensions;
					wbemToXml.m_iQualifierFilter = m_iQualifierFilter;
					wbemToXml.m_iClassOriginFilter = m_iClassOriginFilter;
					WRITEBSTR(OLESTR("<VALUE.OBJECT>"))
					hr = wbemToXml.MapObjectToXML(pEmbeddedObject, NULL, 0, NULL, pOutputStream, NULL);
					WRITEBSTR(OLESTR("</VALUE.OBJECT>"))
					pEmbeddedObject->Release();
				}
				pNextElement->Release();
				pNextElement = NULL;
			}
		}
		WRITEBSTR(OLESTR("</VALUE.OBJECTARRAY>"))
	}
	else
	{
		// Note that we always use PathLevelAnonymous here since embedded objects are VALUE.OBJECTs as per the DTD
		IWbemClassObject *pEmbeddedObject = NULL;
		if(SUCCEEDED(hr = (var.punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
		{
		
			WRITEBSTR(OLESTR("<VALUE.OBJECT>"))
			CWmiToXml wbemToXml;
			wbemToXml.m_iPathLevel = pathLevelAnonymous;
			wbemToXml.m_bAllowWMIExtensions = m_bAllowWMIExtensions;
			wbemToXml.m_iQualifierFilter = m_iQualifierFilter;
			wbemToXml.m_iClassOriginFilter = m_iClassOriginFilter;
			hr = wbemToXml.MapObjectToXML(pEmbeddedObject, NULL, 0, NULL, pOutputStream, NULL);
			pEmbeddedObject->Release();
			WRITEBSTR(OLESTR("</VALUE.OBJECT>"))
		}
	}
	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapMethods (IStream *pOutputStream, IWbemClassObject *pObject)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// Map the requested filter (local only) to the flags value - default is ALL
	LONG lFlags = 0;
	if (VARIANT_TRUE == m_bLocalOnly)
		lFlags = WBEM_FLAG_LOCAL_ONLY;

	pObject->BeginMethodEnumeration (lFlags);
	BSTR name = NULL;
	IWbemClassObject *pInParams = NULL;
	IWbemClassObject *pOutParams = NULL;

	while (WBEM_S_NO_ERROR == pObject->NextMethod (0, &name, &pInParams, &pOutParams))
	{
		MapMethod (pOutputStream, pObject, name, pInParams, pOutParams);

		if (pInParams)
		{
			pInParams->Release ();
			pInParams = NULL;
		}

		if (pOutParams)
		{
			pOutParams->Release ();
			pOutParams = NULL;
		}

		SysFreeString (name);
	}

	pObject->EndMethodEnumeration ();
	return WBEM_S_NO_ERROR;
}

void CWmiToXml::MapMethod (IStream *pOutputStream, IWbemClassObject *pObject, BSTR name, IWbemClassObject *pInParams, IWbemClassObject *pOutParams)
{
	HRESULT result = E_FAIL;
	CIMTYPE returnCimtype = 0;
	VARIANT vVariant;
	VariantInit(&vVariant);

	// First we need the return type of the method, if any
	if (pOutParams)
	{
		if (SUCCEEDED(result = pOutParams->Get (L"ReturnValue", 0, &vVariant, &returnCimtype, NULL)))
		{
			switch(returnCimtype)
			{
				case CIM_OBJECT:
					if(m_bAllowWMIExtensions)
						WRITEBSTR(OLESTR("<METHOD.OBJECT NAME=\""))
					else
					{
						// Just skip this method if WMI extensions are not allowed
						VariantClear(&vVariant);
						return;
					}
					break;
				case CIM_REFERENCE:
					if(m_bAllowWMIExtensions)
						WRITEBSTR(OLESTR("<METHOD.REFERENCE NAME=\""))
					else
					{
						// Just skip this method if WMI extensions are not allowed
						VariantClear(&vVariant);
						return;
					}
					break;
				default:
					WRITEBSTR(OLESTR("<METHOD NAME=\""))
						break;
			}
		}
		else if (result == WBEM_E_NOT_FOUND) // So this method returns a void
		{
			WRITEBSTR(OLESTR("<METHOD NAME=\""))
		}
	}
	else // This method returns a VOID
	{
		WRITEBSTR(OLESTR("<METHOD NAME=\""))
	}


	// The method name
	WRITEBSTR(name)
	WRITEBSTR(OLESTR("\" "))

	// The method return type (default is void).  This is the type of
	// the ReturnType property if present (otherwise defaults to void)
	MapMethodReturnType(pOutputStream, &vVariant, returnCimtype, pOutParams);
	VariantClear(&vVariant);

	// The class origin
	BSTR	methodOrigin = NULL;

	if (WBEM_S_NO_ERROR == pObject->GetMethodOrigin (name, &methodOrigin))
	{
		MapClassOrigin (pOutputStream, methodOrigin, true);
		SysFreeString(methodOrigin);
	}

	WRITEBSTR( OLESTR(">"))
	WRITENEWLINE

	// Now do the qualifiers of the method
	IWbemQualifierSet *pQualSet = NULL;
	if (WBEM_S_NO_ERROR == pObject->GetMethodQualifierSet (name, &pQualSet))
	{
		MapQualifiers (pOutputStream, pQualSet);
		pQualSet->Release ();
		pQualSet = NULL;
	}

	VARIANT idVar;
	VariantInit (&idVar);
	idVar.vt = VT_I4;
	idVar.lVal = 0;

	long nextId = 0;	// The next method ID to expect
	long fixedIndex = 0;

	// For each id,
	//		Get the name of the parameter (could be in, out or both)
	//		If just an in-parameter or just an out-parameter it's easy
	//		If both it's a bit tricky
	//=========================================================================

	while (TRUE)
	{
		BSTR nextInParamName = NULL;
		BSTR nextOutParamName = NULL;

		if (pInParams)
		{
			SAFEARRAY *pArray = NULL;

			if (WBEM_S_NO_ERROR ==
					pInParams->GetNames (L"ID", WBEM_FLAG_ONLY_IF_IDENTICAL|WBEM_FLAG_NONSYSTEM_ONLY,
											&idVar, &pArray))
			{
				// Did we get a match?
				if (pArray)
				{
					if ((1 == pArray->cDims) && (1 == (pArray->rgsabound[0]).cElements))
						SafeArrayGetElement (pArray, &fixedIndex, &nextInParamName);

					SafeArrayDestroy (pArray);
				}
			}
		}

		if (pOutParams)
		{
			SAFEARRAY *pArray = NULL;

			if (WBEM_S_NO_ERROR ==
					pOutParams->GetNames (L"ID", WBEM_FLAG_ONLY_IF_IDENTICAL|WBEM_FLAG_NONSYSTEM_ONLY,
											&idVar, &pArray))
			{
				// Did we get a match?
				if (pArray)
				{
					if ((1 == pArray->cDims) && (1 == (pArray->rgsabound[0]).cElements))
						SafeArrayGetElement (pArray, &fixedIndex, &nextOutParamName);

					SafeArrayDestroy (pArray);
				}
			}
		}

		// If [in] or [out] this is easy
		if ((nextInParamName && !nextOutParamName) || (!nextInParamName && nextOutParamName))
		{
			VARIANT var;
			VariantInit (&var);
			IWbemQualifierSet *pParamQualSet = NULL;
			CIMTYPE cimtype = 0;

			if (nextInParamName)
			{
				if (WBEM_S_NO_ERROR == pInParams->Get (nextInParamName, 0, &var, &cimtype, NULL))
				{
					pInParams->GetPropertyQualifierSet (nextInParamName, &pParamQualSet);
					MapParameter(pOutputStream, nextInParamName, pParamQualSet, cimtype);
				}
			}
			else
			{
				if (WBEM_S_NO_ERROR == pOutParams->Get (nextOutParamName, 0, &var, &cimtype, NULL))
				{
					pOutParams->GetPropertyQualifierSet (nextOutParamName, &pParamQualSet);
					MapParameter(pOutputStream, nextOutParamName, pParamQualSet, cimtype);
				}
			}

			if (pParamQualSet)
				pParamQualSet->Release ();

			VariantClear (&var);
		}
		else if (nextInParamName && nextOutParamName)
		{
			// The [in,out] case and we have to do a merge

			if (0 == _wcsicmp (nextInParamName, nextOutParamName))
			{
				VARIANT var;
				VariantInit (&var);
				CIMTYPE cimtype = 0;

				IWbemQualifierSet *pInParamQualSet = NULL;
				IWbemQualifierSet *pOutParamQualSet = NULL;

				if (WBEM_S_NO_ERROR == pInParams->Get (nextInParamName, 0, &var, &cimtype, NULL))
				{
					pInParams->GetPropertyQualifierSet (nextInParamName, &pInParamQualSet);
					pOutParams->GetPropertyQualifierSet (nextInParamName, &pOutParamQualSet);
					MapParameter(pOutputStream, nextInParamName, pInParamQualSet, cimtype, pOutParamQualSet);

				}

				if (pInParamQualSet)
					pInParamQualSet->Release ();

				if (pOutParamQualSet)
					pOutParamQualSet->Release ();

				VariantClear (&var);
			}
			else
			{
				// Bad news - conflicting IDs in the [in] and [out] parameter set
				// This cannot be a valid method definition
				SysFreeString (nextInParamName);
				SysFreeString (nextOutParamName);
				break;
			}
		}
		else
		{
			// Next id not found - stop now and break out
			SysFreeString (nextInParamName);
			SysFreeString (nextOutParamName);
			break;
		}

		SysFreeString (nextInParamName);
		SysFreeString (nextOutParamName);
		idVar.iVal = idVar.iVal + 1;
	}

	switch(returnCimtype)
	{
		case CIM_OBJECT:
			WRITEBSTR(OLESTR("</METHOD.OBJECT>"))
				break;
		case CIM_REFERENCE:
			WRITEBSTR(OLESTR("</METHOD.REFERENCE>"))
				break;
		default:
			WRITEBSTR(OLESTR("</METHOD>"))
				break;
	}
}

STDMETHODIMP CWmiToXml::MapMethodReturnType(IStream *pOutputStream, VARIANT *pValue, CIMTYPE returnCimType, IWbemClassObject *pOutputParams)
{
	HRESULT hr = E_FAIL;
	switch(returnCimType)
	{
		// Write a REFERENCECLASS
		case CIM_OBJECT:
		case CIM_REFERENCE:
		{
			IWbemQualifierSet *pQualifierSet = NULL;
			if(SUCCEEDED(hr = pOutputParams->GetPropertyQualifierSet(L"ReturnValue", &pQualifierSet)))
			{
				// Map the type of the return class
				MapStrongType(pOutputStream, pQualifierSet);
				pQualifierSet->Release();
			}
		}
		break;
		default:
			hr = MapType(pOutputStream, returnCimType);
			break;
	}
	return hr;
}

void CWmiToXml::MapClassOrigin (IStream *pOutputStream, BSTR &classOrigin, bool bIsClass)
{
	if ( (bIsClass && (m_iClassOriginFilter & wmiXMLClassOriginFilterClass)) ||
				   (m_iClassOriginFilter & wmiXMLClassOriginFilterInstance) )
	{
		WRITEBSTR( OLESTR(" CLASSORIGIN=\""))
		WRITEBSTR( classOrigin)
		WRITEBSTR( OLESTR("\""))
	}
}

void CWmiToXml::MapParameter (IStream *pOutputStream, BSTR paramName,
							   IWbemQualifierSet *pQualSet,
							   CIMTYPE cimtype,
							   IWbemQualifierSet *pQualSet2)
{
	/*
	 * For vanilla CIM XML we don't handle embedded object parameters
	 */

	if ((CIM_OBJECT != (cimtype & ~CIM_FLAG_ARRAY)) || m_bAllowWMIExtensions)
	{
		if (cimtype & CIM_FLAG_ARRAY)
		{
			// Map the array parameter
			if (CIM_REFERENCE == (cimtype & ~CIM_FLAG_ARRAY))
			{
				WRITEBSTR( OLESTR("<PARAMETER.REFARRAY NAME=\""))
				WRITEBSTR( paramName)
				WRITEBSTR( OLESTR("\" "))
				MapStrongType (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(" "))
				MapArraySize (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(">"))
				WRITENEWLINE

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pOutputStream, pQualSet, pQualSet2);

				WRITEBSTR( OLESTR("</PARAMETER.REFARRAY>"))
			}
			else if (CIM_OBJECT == (cimtype & ~CIM_FLAG_ARRAY))
			{
				WRITEBSTR( OLESTR("<PARAMETER.OBJECTARRAY NAME=\""))
				WRITEBSTR( paramName)
				WRITEBSTR( OLESTR("\" "))
				MapStrongType (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(" "))
				MapArraySize (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(">"))
				WRITENEWLINE

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pOutputStream, pQualSet, pQualSet2);

				WRITEBSTR( OLESTR("</PARAMETER.OBJECTARRAY>"))
			}
			else
			{
				WRITEBSTR( OLESTR("<PARAMETER.ARRAY NAME=\""))
				WRITEBSTR( paramName)
				WRITEBSTR( OLESTR("\" "))
				MapType (pOutputStream, cimtype & ~CIM_FLAG_ARRAY);
				WRITEBSTR( OLESTR(" "))
				MapArraySize (pOutputStream, pQualSet);
				WRITEBSTR( OLESTR(">"))
				WRITENEWLINE

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pOutputStream, pQualSet, pQualSet2);

				WRITEBSTR( OLESTR("</PARAMETER.ARRAY>"))
			}
		}
		else if (cimtype == CIM_REFERENCE)
		{
			// Map the reference parameter
			WRITEBSTR( OLESTR("<PARAMETER.REFERENCE NAME=\""))
			WRITEBSTR( paramName)
			WRITEBSTR( OLESTR("\" "))
			MapStrongType (pOutputStream, pQualSet);
			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pOutputStream, pQualSet, pQualSet2);

			WRITEBSTR( OLESTR("</PARAMETER.REFERENCE>"))
		}
		else if (cimtype == CIM_OBJECT)
		{
			WRITEBSTR( OLESTR("<PARAMETER.OBJECT NAME=\""))
			WRITEBSTR( paramName)
			WRITEBSTR( OLESTR("\" "))
			MapStrongType (pOutputStream, pQualSet);
			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pOutputStream, pQualSet, pQualSet2);

			WRITEBSTR( OLESTR("</PARAMETER.OBJECT>"))
		}
		else
		{
			// Vanilla parameter
			WRITEBSTR( OLESTR("<PARAMETER NAME=\""))
			WRITEBSTR( paramName)
			WRITEBSTR( OLESTR("\" "))
			MapType (pOutputStream, cimtype);
			WRITEBSTR( OLESTR(">"))
			WRITENEWLINE

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pOutputStream, pQualSet, pQualSet2);

			WRITEBSTR( OLESTR("</PARAMETER>"))
		}
	}
}


void CWmiToXml::MapByteValue (IStream *pOutputStream, unsigned char val)
{
	OLECHAR	wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR( wStr)
}

void CWmiToXml::MapLongValue (IStream *pOutputStream, long val)
{
	OLECHAR	wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR( wStr)
}

void CWmiToXml::MapShortValue (IStream *pOutputStream, short val)
{
	OLECHAR wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR( wStr)
}

void CWmiToXml::MapDoubleValue (IStream *pOutputStream, double val)
{
	VARIANT varSrc,varDst;
	VariantInit(&varSrc);
	VariantInit(&varDst);
	varSrc.vt = VT_R8;
	varSrc.dblVal = val;
	if(SUCCEEDED(VariantChangeType(&varDst,&varSrc,0,VT_BSTR)))
	{
		MapStringValue(pOutputStream,varDst.bstrVal);
	}
	VariantClear(&varSrc);
	VariantClear(&varDst);
}

void CWmiToXml::MapFloatValue (IStream *pOutputStream, float val)
{
	VARIANT varSrc,varDst;
	VariantInit(&varDst);
	VariantInit(&varSrc);
	varSrc.vt = VT_R4;
	varSrc.fltVal = val;
	if(SUCCEEDED(VariantChangeType(&varDst,&varSrc,0,VT_BSTR)))
	{
		MapStringValue(pOutputStream,varDst.bstrVal);
	}
	VariantClear(&varSrc);
	VariantClear(&varDst);

}

void CWmiToXml::MapCharValue (IStream *pOutputStream, long val)
{
	// As per the XML Spec, the following are invalid character values in an XML Stream:
	// Char ::=  #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

	// As per the CIM Operations spec, they need to be escaped as follows:
	//	If the value is not a legal XML character
	//  (as defined in [2, section 2.2] by the Char production)
	//	then it MUST be escaped using a \x<hex> escape convention
	//	where <hex> is a hexadecimal constant consisting of
	//	between one and four digits

	if(	val < 0x9 ||
		(val == 0xB || val == 0xC)	||
		(val > 0xD && val <0x20)	||
		(val >0xD7FF && val < 0xE000) ||
		(val > 0xFFFD)
		)
	{
		// Map it in the escaped manner
		OLECHAR charStr [7];
		swprintf (charStr, L"\\x%04x", val&0xffff);
		charStr[6] = NULL;
		WRITEBSTR( charStr)
	}
	else
	{
		// FIrst check to see if is one of the reserved characters in XML - < & and >
		// Map it in the normal manner
		if(val == '<')
			WRITELT
		else if (val == '>')
			WRITEGT
		else if (val == '&')
			WRITEAMP
		else
		{
			// Map it in the normal manner
			WCHAR charStr [2];
			swprintf (charStr, L"%c", val);
			charStr[1] = NULL;
			WRITEBSTR(charStr)
		}
	}
}

void CWmiToXml::MapBoolValue (IStream *pOutputStream, BOOL val)
{
	if (TRUE == val)
		WRITEBSTR( OLESTR("TRUE"))
	else
		WRITEBSTR( OLESTR("FALSE"))
}

void CWmiToXml::MapStringValue (IStream *pOutputStream, BSTR &val)
{
	/*
	 * Quote from http://www.w3.org/TR/REC-xml:
	 *
	 *  The ampersand character (&) and the left angle bracket (<) may
	 *  appear in their literal form only when used as markup delimiters,
	 *  or within a comment, a processing instruction, or a CDATA section.
	 *
	 *  If they are needed elsewhere, they must be escaped using either
	 *  numeric character references or the strings "&amp;" and "&lt;"
	 *  respectively.
	 *
	 *  The right angle bracket (>) must, for compatibility, be escaped
	 *  using "&gt;" or a character reference when it appears in the string
	 *  "]]>" in content, when that string is not marking the end of a CDATA
	 *  section.
	 *
	 *  In the content of elements, character data is any string of characters
	 *  which does not contain the start-delimiter of any markup. In a CDATA
	 *  section, character data is any string of characters not including the
	 *  CDATA-section-close delimiter, "]]>".
	 */

	// Check that < or & do not occur in the value
	size_t length = wcslen (val);
	size_t offset = 0;
	OLECHAR *pWchar = NULL;

	if ((offset = wcscspn (val, L"<&")) < length)
	{
		// A reserved character (< &) appears in the value -
		// need to escape.  We can use CDATA if it does not
		// contain the string ]]>

		if (wcsstr (val, CDATAEND))
		{
			// Bad luck - can't use CDATA. Have to escape
			// each reserved character and the CDATAEND sequence!
			// Easiest way to do this is escape all occurences
			// of >.
			//	<	->		&lt;
			//	&	->		&amp;
			//	>	->		&gt;

			offset = wcscspn (val, L"<&>");
			OLECHAR *pStr = (OLECHAR *)val;

			while (TRUE)
			{
				// Write the initial block that's safe
				if (offset > 0)
					WRITEWSTRL( pStr, offset);

				pStr += offset;

				// Escape the offending character
				if (L'<' == *pStr)
					WRITELT
				else if (L'>' == *pStr)
					WRITEGT
				else
					WRITEAMP

				// Skip over the reserved character
				pStr += 1;

				// Find the next position
				if ((offset = wcscspn (pStr, L"<&>")) >= wcslen (pStr))
					break;
			}

			// Any data left?
			if (pStr && wcslen (pStr))
				WRITEWSTR (pStr)
		}
		else
		{
			// Can escape the whole value inside a CDATA
			WRITECDATASTART
			WRITEBSTR( val)
			WRITECDATAEND
		}
	}
	else if (pWchar = wcsstr (val, CDATAEND))
	{
		// Yuck we need to escape the > inside this sequence
		//
		// ]]>  -> ]]&gt;

		OLECHAR *pStr = (OLECHAR *)val;

		while (TRUE)
		{
			offset = wcslen (pStr) - wcslen (pWchar);

			// Write the initial block that's safe
			// (NOTE: the additional two characters for the "]]"
			//  which we don't need to escape)
			WRITEWSTRL( pStr,(offset+2));

			// Skip over the CDATAEND sequence
			pStr += offset + 3;

			// Escape the offending character
			WRITEGT

			// Find the next position
			if (!(pWchar = wcsstr (pStr, CDATAEND)))
				break;
		}

		// Any data left?
		if (pStr && wcslen (pStr))
			WRITEWSTR (pStr)
	}
	else
	{
		// Just write the value
		WRITEBSTR( val)
	}
}

void CWmiToXml::MapReturnParameter(IStream *pOutputStream, BSTR strParameterName, VARIANT &variant)
{
	// Could be a PARAMETER or PARAMETER.ARRAY
	if(variant.vt & VT_ARRAY)
		WRITEBSTR( OLESTR("<PARAMVALUE.ARRAY NAME=\""))
	else
		WRITEBSTR( OLESTR("<PARAMVALUE NAME=\""))

	WRITEBSTR( strParameterName);
	WRITEBSTR( OLESTR("\">"));

	// Convert the property value to XML
	MapValue(pOutputStream, variant);
	if(variant.vt & VT_ARRAY)
		WRITEBSTR( OLESTR("</PARAMVALUE.ARRAY>"))
	else
		WRITEBSTR( OLESTR("</PARAMVALUE>"))
}


BOOL CWmiToXml::PropertyDefinedForClass (IWbemClassObject *pObject, BSTR bsPropertyName, BSTR strClassBasis)
{
	BOOL result = TRUE;

	// Given (a) Class basis for enumeration and
	// (b) property name, determine
	//   (1) CLASSORIGIN of property
	//	 (2) Dynasty of class
	// And thereby check whether property was defined
	// at the level of the class basis.
	// If no class basis is supplied, then we always return TRUE
	//============================================================
	if (strClassBasis && pObject)
	{
		// Get Property originating class
		BSTR bsOrigClass = NULL;

		if (SUCCEEDED (pObject->GetPropertyOrigin (bsPropertyName, &bsOrigClass)))
		{
			// Derivation is the Class hierarchy of the current class or instance.
			// The first element is the immediate superclass, the next is its parent,
			// and so on; the last element is the base class.
			// Now work through the derivation array. If we meet the
			// propertys' originating class before the class basis,
			// we conclude that the property was not defined in the
			// class basis

			// If we have been give a class basis, get the __DERIVATION
			// property for each object
			VARIANT vDerivation;
			VariantInit(&vDerivation);
			if (SUCCEEDED(pObject->Get (L"__DERIVATION", 0, &vDerivation, NULL, NULL)))
			{
				SAFEARRAY *pArray = vDerivation.parray;

				if (pArray && (1 == pArray->cDims) && (0 < pArray->rgsabound [0].cElements))
				{
					int lBound = pArray->rgsabound [0].lLbound;
					int uBound = pArray->rgsabound [0].cElements + lBound;
					BOOL bDone = FALSE;

					for (long i = lBound; (i < uBound) && !bDone; i++)
					{
						BSTR bsClass = NULL;

						if (SUCCEEDED (SafeArrayGetElement (pArray, &i, &bsClass)))
						{
							if (0 == _wcsicmp (bsOrigClass, bsClass))
							{
								result = FALSE;
								bDone = TRUE;
							}
							else if (0 == _wcsicmp (strClassBasis, bsClass))
								bDone = TRUE;

							SysFreeString (bsClass);
						}
					}
				}
				VariantClear(&vDerivation);
			}

			SysFreeString (bsOrigClass);
		}
	}

	return result;
}

// Functions of the IWbemXMLConvertor interface
HRESULT STDMETHODCALLTYPE CWmiToXml::MapObjectToXML(
    /* [in] */ IWbemClassObject  *pObject,
 	/* [in] */ BSTR *ppPropertyList, DWORD dwNumProperties,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream,
	/* [in[ */ BSTR strClassBasis)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	
	// Is this a class or an instance?
	VARIANT var;
	VariantInit (&var);
	long flav = 0;
	bool bIsClass = false;
	if (SUCCEEDED (pObject->Get(L"__GENUS", 0, &var, NULL, &flav)))
		bIsClass = (WBEM_GENUS_CLASS == var.lVal);
	else
		bIsClass = VARIANT_FALSE; // For now, assume that it is an instance. RAJESHR is this correct?
	VariantClear (&var);

	// Initalize the object path
	VariantInit (&var);
	
	// For pathLevelAnonymous (anonymous objects), we dont need anything more
	// For pathLevelNamed (named objects), we only need __RELPATH for a class and __RELPATH for an instance 
	// For pathLevelLocal, I wish core team had some concept
	// of machine-relative path, but they dont and hence we need the __PATH
	// For pathLevelFull, we definitely need __PATH
	LPWSTR lpszPath = NULL;
	switch(m_iPathLevel)
	{
		case pathLevelAnonymous:
			break; 
		case pathLevelNamed:
			lpszPath = L"__RELPATH";
			break;
		default:
			lpszPath = L"__PATH";
	}

	// Get the object path
	ParsedObjectPath *pParsedPath = NULL;
	CObjectPathParser pathParser;
	if(m_iPathLevel != pathLevelAnonymous)
	{
		if(FAILED(pObject->Get (lpszPath, 0, &var, NULL, NULL)))
			return WBEM_E_FAILED;
		// Now Parse it
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
		{
			pathParser.Parse (var.bstrVal, &pParsedPath) ;
			if(!pParsedPath)
			{
				VariantClear (&var);
				return WBEM_E_FAILED;
			}
		}
		else
		{
			VariantClear (&var);
			return WBEM_E_FAILED;
		}
		VariantClear (&var);
	}

	// Get the object Qualifier Set
	IWbemQualifierSet *pQualSet= NULL;
	pObject->GetQualifierSet (&pQualSet);
	
	// Whether we generate a named object or not depends
	// on what was requested
	if (pathLevelNamed == m_iPathLevel)
	{
		if(!bIsClass)
			MapInstanceName(pOutputStream, pParsedPath);
			// Nothing to be done for a class
	}
	else if (pathLevelLocal == m_iPathLevel)
	{
		if(bIsClass)
			MapLocalClassPath(pOutputStream, pParsedPath);
		else
			MapLocalInstancePath(pOutputStream, pParsedPath);
	}
	else if (pathLevelFull == m_iPathLevel)
	{
		if (bIsClass)
			MapClassPath (pOutputStream, pParsedPath);
		else
			MapInstancePath (pOutputStream, pParsedPath);
	}

	hr = (bIsClass) ? MapClass (pOutputStream, pObject, pQualSet, ppPropertyList, dwNumProperties, strClassBasis) :
						MapInstance (pOutputStream, pObject, pQualSet, ppPropertyList, dwNumProperties, strClassBasis);


	if (pQualSet)
		pQualSet->Release ();
	if(pParsedPath)
		pathParser.Free(pParsedPath);

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapInstanceNameToXML(
    /* [in] */ BSTR  strInstanceName,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	if (strInstanceName)
	{
		CObjectPathParser pathParser;
		ParsedObjectPath	*pParsedPath = NULL;
		pathParser.Parse (strInstanceName, &pParsedPath) ;

		if(pParsedPath)
		{
			hr = MapInstanceName (pOutputStream, pParsedPath);;
			pathParser.Free(pParsedPath);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapPropertyToXML(
        /* [in] */ IWbemClassObject  *pObject,
		/* [in] */ BSTR strPropertyName,
        /* [in] */ IWbemContext  *pInputFlags,
        /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	VARIANT var;
	VariantInit (&var);
	CIMTYPE cimtype;
	long flavor;

	HRESULT hr = pObject->Get (strPropertyName, 0, &var, &cimtype, &flavor);

	if (SUCCEEDED (hr))
	{
		if (CIM_REFERENCE == (cimtype & ~CIM_FLAG_ARRAY))
			MapReferenceValue (pOutputStream, (cimtype & CIM_FLAG_ARRAY) ? TRUE : FALSE, var);
		else
			MapValue (pOutputStream, cimtype & ~CIM_FLAG_ARRAY, (cimtype & CIM_FLAG_ARRAY) ?
							TRUE : FALSE, var);
	}

	VariantClear (&var);
	return hr;
}


HRESULT STDMETHODCALLTYPE CWmiToXml::MapClassNameToXML(
    /* [in] */ BSTR  strClassName,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	MapClassName(pOutputStream, strClassName);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapInstancePathToXML(
    /* [in] */ BSTR  strInstancePath,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	if (strInstancePath)
	{
		CObjectPathParser pathParser;
		ParsedObjectPath	*pParsedPath = NULL;
		pathParser.Parse (strInstancePath, &pParsedPath) ;

		if (pParsedPath)
		{
			hr = MapInstancePath (pOutputStream, pParsedPath);;
			pathParser.Free(pParsedPath);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapClassPathToXML(
    /* [in] */ BSTR  strClassPath,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;
	if (strClassPath)
	{
		CObjectPathParser pathParser;
		ParsedObjectPath	*pParsedPath = NULL;
		pathParser.Parse (strClassPath, &pParsedPath) ;

		if (pParsedPath)
		{
			hr = MapClassPath (pOutputStream, pParsedPath);;
			pathParser.Free(pParsedPath);
		}
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CWmiToXml::MapMethodResultToXML(
    /* [in] */ IWbemClassObject  *pMethodResult,
    /* [in] */ IWbemContext  *pInputFlags,
    /* [in] */ IStream  *pOutputStream)
{
	// Set private members from arguments
	GetFlagsFromContext(pInputFlags);

	HRESULT hr = WBEM_E_FAILED;

	// First Map the return Value
	// The property "ReturnValue" indicates the return value of the method call, if any
	VARIANT retValueVariant;
	VariantInit(&retValueVariant);
	CIMTYPE cimtype;
	long flavour;
	if(SUCCEEDED(pMethodResult->Get(L"ReturnValue", 0, &retValueVariant, &cimtype, &flavour)))
	{
		WRITEBSTR( OLESTR("<RETURNVALUE>"));
		MapValue(pOutputStream, retValueVariant);
		WRITEBSTR( OLESTR("</RETURNVALUE>"));
		VariantClear(&retValueVariant);
	}

	// Map each of its non-system properties, except for the "ReturnValue" property which
	// we've already mapped
	if(SUCCEEDED(hr = pMethodResult->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
	{
		BSTR strName = NULL;
		VARIANT variant;
		VariantInit(&variant);
		while(SUCCEEDED(hr = pMethodResult->Next(0, &strName, &variant, &cimtype, &flavour)) && hr != WBEM_S_NO_MORE_DATA)
		{
			if(_wcsicmp(strName, L"ReturnValue") != 0)
				MapReturnParameter(pOutputStream, strName, variant);
			VariantClear(&variant);
		}
	}

	return hr;
}

// Get all the flags from the IWbemContextObject
void CWmiToXml::GetFlagsFromContext(IWbemContext  *pInputFlags)
{
	if(pInputFlags)
	{
		if(SUCCEEDED(pInputFlags->BeginEnumeration(0)))
		{
			VARIANT vNextArgValue;
			VariantInit(&vNextArgValue);
			BSTR strNextArgName = NULL;

			while(pInputFlags->Next(0, &strNextArgName, &vNextArgValue) != WBEM_S_NO_MORE_DATA)
			{
				// VARIANT_BOOL bAllowWMIExtensions,
				if(_wcsicmp(s_wmiToXmlArgs[WMI_EXTENSIONS_ARG], strNextArgName) == 0)
					m_bAllowWMIExtensions = vNextArgValue.boolVal;

				// VARIANT_BOOL bLocalOnly,
				else if(_wcsicmp(s_wmiToXmlArgs[LOCAL_ONLY_ARG], strNextArgName) == 0)
					m_bLocalOnly = vNextArgValue.boolVal;

				//	PathLevel					m_iPathLevel;
				else if(_wcsicmp(s_wmiToXmlArgs[PATH_LEVEL_ARG], strNextArgName) == 0)
					m_iPathLevel = (PathLevel)vNextArgValue.lVal;

				// WmiXMLQualifierFilterEnum m_iQualifierFilter
				else if(_wcsicmp(s_wmiToXmlArgs[QUALIFIER_FILTER_ARG], strNextArgName) == 0)
						m_iQualifierFilter = (vNextArgValue.boolVal == VARIANT_TRUE)? wmiXMLQualifierFilterAll : wmiXMLQualifierFilterNone;

				// WmiXMLClassOriginFilterEnum	iClassOriginFilter
				else if(_wcsicmp(s_wmiToXmlArgs[CLASS_ORIGIN_FILTER_ARG], strNextArgName) == 0)
					m_iClassOriginFilter = (vNextArgValue.boolVal == VARIANT_TRUE) ? wmiXMLClassOriginFilterAll : wmiXMLClassOriginFilterNone;

				// VARIANT_BOOL bExcludeSystemProperties
				else if(_wcsicmp(s_wmiToXmlArgs[EXCLUDE_SYSTEM_PROPERTIES_ARG], strNextArgName) == 0)
					m_bExcludeSystemProperties = vNextArgValue.boolVal;

				VariantClear(&vNextArgValue);
			}
			pInputFlags->EndEnumeration();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\xmltransport\server\wmixmlidl\myext.h ===
#ifdef __midl

#define   HSE_LOG_BUFFER_LEN         80
typedef   LPVOID          HCONN;
typedef		BYTE *		LPBYTE;

//
// structure passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (* GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (* WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (* ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (* ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\common\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_ADMINPRV_TRACE) || defined(_USE_ADMINPRV_ASSERT) || defined(_USE_ADMINPRV_TIMER)

UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
    static LPCWSTR lpszFile = L"\\system32\\" ADMINPRV_COMPNAME L".ini";

    WCHAR szFilePath[2*MAX_PATH];
    UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
    if (nLen == 0)
        return nDefault;

    wcscat(szFilePath, lpszFile);
    return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif


#if defined(_USE_ADMINPRV_TRACE)

#ifdef DEBUG_DSA
DWORD g_dwTrace = 0x1;
#else
DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");
#endif

void __cdecl DSATrace(LPCTSTR lpszFormat, ...)
{
    if (g_dwTrace == 0)
        return;

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512] = {0};

    nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR)-1, lpszFormat, args);

    // was there an error? was the expanded string too long?
    ASSERT(nBuf >= 0);
    ::OutputDebugString(szBuffer);

    va_end(args);
}

#endif // defined(_USE_ADMINPRV_TRACE)

#if defined(_USE_ADMINPRV_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    if (g_dwAssert == 0)
        return FALSE;

    WCHAR szMessage[_MAX_PATH*2];

    // assume the debugger or auxiliary port
    wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
             lpszFileName, nLine);
    OutputDebugString(szMessage);

    // JonN 6/28/00 Do not MessageBox here, this is a WMI provider.
    //              Return TRUE to always DebugBreak().

    return TRUE;

}
#endif // _USE_ADMINPRV_ASSERT

#if defined(_USE_ADMINPRV_TIMER)

#ifdef TIMER_DSA
DWORD g_dwTimer = 0x1;
#else
DWORD g_dwTimer = ::GetInfoFromIniFile(L"Debug", L"Timer");
#endif

DWORD StartTicks = ::GetTickCount();
DWORD LastTicks = 0;

void __cdecl DSATimer(LPCTSTR lpszFormat, ...)
{
    if (g_dwTimer == 0)
        return;

    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512] = {0}, szBuffer2[512];

    DWORD CurrentTicks = GetTickCount() - StartTicks;
    DWORD Interval = CurrentTicks - LastTicks;
    LastTicks = CurrentTicks;

    nBuf = swprintf(szBuffer2,
                    L"%d, (%d): %ws", CurrentTicks,
                    Interval, lpszFormat);
    nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR) - 1,
                       szBuffer2, 
                       args);

    // was there an error? was the expanded string too long?
    ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

    va_end(args);
}
#endif // _USE_ADMINPRV_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\common\common.h ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service WMI providers
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       common.h
//
//  Contents:   Common macros and definitions
//
//  History:    24-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#define BAD_IN_STRING_PTR(p) (NULL == p || IsBadStringPtr(p,0))
#define BAD_IN_STRING_PTR_OPTIONAL(p) (NULL != p && IsBadStringPtr(p,0))
#define BAD_IN_READ_PTR(p,size) (NULL == p || IsBadReadPtr(p,size))
#define BAD_WRITE_PTR(p,size) (NULL == p || IsBadWritePtr(p,size))

template<class T>
bool
BAD_IN_MULTISTRUCT_PTR(T* p, size_t count)
{
    return BAD_IN_READ_PTR(p, count * sizeof(T));
}
#define BAD_IN_STRUCT_PTR(p) BAD_IN_MULTISTRUCT_PTR(p,1)

template<class T>
bool
BAD_OUT_MULTISTRUCT_PTR(T* p, size_t count)
{
    return BAD_WRITE_PTR(p, count * sizeof(T));
}
#define BAD_OUT_STRUCT_PTR(p) BAD_OUT_MULTISTRUCT_PTR(p,1)

#define ASSERT_AND_RETURN {ASSERT(false); return WBEM_E_INVALID_PARAMETER;}
#define ASSERT_AND_BREAK {ASSERT(false); break;}
#define BREAK_ON_FAIL if (FAILED(hr)) ASSERT_AND_BREAK;
#define BREAK_ON_NULL(x) if (!(x)) ASSERT_AND_BREAK;
#define BREAK_ON_NULL_(x, h, c) if (!(x)) {h = c; ASSERT_AND_BREAK;}
#define WBEM_VALIDATE_READ_PTR(p,size) \
            if (BAD_IN_READ_PTR(p,size)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRUCT_PTR(p) \
            if (BAD_IN_STRUCT_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_MULTISTRUCT_PTR(p,n) \
            if (BAD_IN_MULTISTRUCT_PTR(p,n)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_OUT_STRUCT_PTR(p) \
            if (BAD_OUT_STRUCT_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_OUT_PTRPTR(p) \
            if (NULL == p || IsBadWritePtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_INTF_PTR(p) \
            if (NULL == p || IsBadReadPtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR(p) \
            if (BAD_IN_STRING_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(p) \
            if (BAD_IN_STRING_PTR_OPTIONAL(p)) ASSERT_AND_RETURN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\domain.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       domain.cpp
//
//  Contents:   domain class implementation
//
//  Classes:    CDomainInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include <stdafx.h>

PCWSTR CSTR_PROP_LOCAL_DNS_NAME  = L"DNSname";  // String
PCWSTR CSTR_PROP_LOCAL_FLAT_NAME = L"FlatName"; // String
PCWSTR CSTR_PROP_LOCAL_SID       = L"SID";      // String
PCWSTR CSTR_PROP_LOCAL_TREE_NAME = L"TreeName"; // String
PCWSTR CSTR_PROP_LOCAL_DC_NAME   = L"DCname";   // String
// TODO: string property listing the FSMOs owned by this DC?

//Implementaion of CDomainInfo class

//+----------------------------------------------------------------------------
//
// Class:   CDomainInfo
//
//-----------------------------------------------------------------------------
CDomainInfo::CDomainInfo()
{
   TRACE(L"CDomainInfo::CDomainInfo\n");

   m_liLastEnumed.QuadPart = 0;
}

CDomainInfo::~CDomainInfo()
{
   TRACE(L"CDomainInfo::~CDomainInfo\n");

   Reset();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::Init
//
//  Synopsis:   Initializes the CDomainInfo object.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::Init(IWbemClassObject * pClassDef)
{
   TRACE(L"CDomainInfo::Init\n");

   NTSTATUS Status = STATUS_SUCCESS;
   OBJECT_ATTRIBUTES objectAttributes;
   CSmartPolicyHandle chPolicy;

   m_sipClassDefLocalDomain = pClassDef;

   InitializeObjectAttributes(&objectAttributes, NULL, 0L, NULL, NULL);

   // Get Local policy
   Status = LsaOpenPolicy(NULL,              // Local server
                          &objectAttributes,
                          MAXIMUM_ALLOWED,   // Needed for Rediscover
                          &chPolicy);

   if (!NT_SUCCESS(Status))
   {
      TRACE(L"LsaOpenPolicy failed with error %d\n", Status);
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
   }

   PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo;

   Status = LsaQueryInformationPolicy(chPolicy,
                                      PolicyDnsDomainInformation,
                                      (PVOID *)&pDnsDomainInfo);

   if (!NT_SUCCESS(Status))
   {
      TRACE(L"LsaQueryInformationPolicy failed with error %d\n", Status);
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
   }

   m_strDomainFlatName = pDnsDomainInfo->Name.Buffer;
   m_strDomainDnsName = pDnsDomainInfo->DnsDomainName.Buffer;
   m_strForestName = pDnsDomainInfo->DnsForestName.Buffer;

   if (!SetSid(pDnsDomainInfo->Sid))
   {
      ASSERT(false);
      LsaFreeMemory(pDnsDomainInfo);
      return E_OUTOFMEMORY;
   }

   LsaFreeMemory(pDnsDomainInfo);

   DWORD dwBufSize = MAX_COMPUTERNAME_LENGTH + 1;

   if (!GetComputerName(m_strDcName.GetBuffer(dwBufSize), &dwBufSize))
   {
      DWORD dwErr = GetLastError();
      TRACE(L"GetComputerName failed with error %d\n", dwErr);
      return HRESULT_FROM_WIN32(dwErr);
   }

   m_strDcName.ReleaseBuffer();

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::Reset
//
//  Synopsis:   Free the contents of the trust array and re-initialize it.
//
//-----------------------------------------------------------------------------
void
CDomainInfo::Reset(void)
{
   TRACE(L"CDomainInfo::Reset\n");

   CTrustInfo * pTrustInfo = NULL;

   if (IsEnumerated())
   {
      // Empty cache 
      for (UINT i = 0; i < m_vectTrustInfo.size(); ++i)
      {
         pTrustInfo = m_vectTrustInfo[i];
         if (pTrustInfo)
            delete pTrustInfo;
      }
      m_vectTrustInfo.clear();
   }
}

//+----------------------------------------------------------------------------
//
//  Method: CDomainInfo::SetSid
//
//-----------------------------------------------------------------------------
BOOL
CDomainInfo::SetSid(PSID pSid)
{
   if (!pSid)
   {
      return TRUE;
   }

#if !defined(NT4_BUILD)
   PWSTR buffer;

   BOOL fRet = ConvertSidToStringSid(pSid, &buffer);

   if (fRet)
   {
      m_strSid = buffer;
      LocalFree(buffer);
   }

   return fRet;
#else
// TODO: Code for NT4 ??
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::EnumerateTrusts
//
//  Synopsis:   List the trusts for this domain.
//
//-----------------------------------------------------------------------------
#if !defined(NT4_BUILD)
HRESULT
CDomainInfo::EnumerateTrusts(void)
{
   TRACE(L"CDomainInfo::EnumerateTrusts\n");

   DWORD dwRet = ERROR_SUCCESS;
   CTrustInfo * pTrustInfo = NULL;
   PDS_DOMAIN_TRUSTS rgTrusts = NULL;
   ULONG nTrustCount = 0;

   Reset();

   dwRet = DsEnumerateDomainTrusts(NULL,
                                   DS_DOMAIN_DIRECT_OUTBOUND |
                                   DS_DOMAIN_DIRECT_INBOUND,
                                   &rgTrusts,
                                   &nTrustCount);

   if (ERROR_SUCCESS != dwRet)
   {
      TRACE(L"DsEnumerateDomainTrusts failed with error %d\n", dwRet);
      return HRESULT_FROM_WIN32(dwRet);
   }

   for (ULONG i = 0; i < nTrustCount; i++) 
   {
      pTrustInfo = new CTrustInfo();
      if (!pTrustInfo)
      {
         dwRet = ERROR_NOT_ENOUGH_MEMORY;
         break;
      }
      if (rgTrusts[i].DnsDomainName)
      {
         // Downlevel domains don't have a DNS name.
         //
         pTrustInfo->SetTrustedDomain(rgTrusts[i].DnsDomainName);
      }
      else
      {
         // So use the flat name instead.
         //
         pTrustInfo->SetTrustedDomain(rgTrusts[i].NetbiosDomainName);
      }
      pTrustInfo->SetFlatName(rgTrusts[i].NetbiosDomainName);
      if (!pTrustInfo->SetSid(rgTrusts[i].DomainSid))
      {
         // NTRAID#NTBUG9-582047-2002/05/15-ericb
         delete pTrustInfo;
         dwRet = ERROR_NOT_ENOUGH_MEMORY;
         break;
      }
      pTrustInfo->SetTrustType(rgTrusts[i].TrustType);
      pTrustInfo->SetTrustDirectionFromFlags(rgTrusts[i].Flags);
      pTrustInfo->SetTrustAttributes(rgTrusts[i].TrustAttributes);
      pTrustInfo->SetFlags(rgTrusts[i].Flags);

      // NTRAID#NTBUG9-582047-2002/05/15-ericb
      try
      {
         m_vectTrustInfo.push_back(pTrustInfo);
      }
      catch (...)
      {
         dwRet = ERROR_NOT_ENOUGH_MEMORY;
         delete pTrustInfo;
         break;
      }

      pTrustInfo = NULL;
   }

   if (rgTrusts)
   {
      NetApiBufferFree(rgTrusts);
   }

   if (ERROR_SUCCESS == dwRet)
   {
      SYSTEMTIME st;

      GetSystemTime(&st);
      SystemTimeToFileTime(&st, (LPFILETIME)&m_liLastEnumed);
   }

   return HRESULT_FROM_WIN32(dwRet);
}

#else // NT4_BUILD

HRESULT
CDomainInfo::EnumerateTrusts(void)
{
   TRACE(L"CDomainInfo::EnumerateTrusts\n");

   NTSTATUS Status = STATUS_SUCCESS;
   DWORD dwErr = ERROR_SUCCESS;
   ULONG i = 0;
   CTrustInfo * pTrustInfo = NULL;

   Reset();

   LSA_ENUMERATION_HANDLE hEnumContext = NULL;
   ULONG nTrustCount = 0;
   ULONG nTotalCount = 0;
   ULONG j = 0;    
   PLSA_TRUST_INFORMATION pTrustDomainInfo = NULL;
   DWORD hResumeHandle = 0;
   LPUSER_INFO_0 pUserList = NULL;
   CTrustInfo * pTempTrustInfo = NULL;
   LPWSTR Lop = NULL;
   CSmartPolicyHandle chPolicy;
   OBJECT_ATTRIBUTES objectAttributes;

   InitializeObjectAttributes(&objectAttributes, NULL, 0L, NULL, NULL);

   //
   // We'll have to do this the old fashioned way. That means that we'll enumerate all of
   // the trust directly, save them off in a list, and then go through and enumerate all
   // of the interdomain trust accounts and merge those into the list.
   //
   do
   {
      Status = LsaOpenPolicy(NULL,              // Local server
                             &objectAttributes,
                             MAXIMUM_ALLOWED,   // Needed for Rediscover
                             &chPolicy);

      Status = LsaEnumerateTrustedDomains(chPolicy,
                                          &hEnumContext,
                                          (void**)&pTrustDomainInfo,
                                          ULONG_MAX,
                                          &nTrustCount );

      if (NT_SUCCESS(Status) || Status == STATUS_MORE_ENTRIES) 
      {
         dwErr = ERROR_SUCCESS;
         for ( i = 0; i < nTrustCount; i++ ) 
         {
            pTrustInfo = new CTrustInfo();
            CHECK_NULL( pTrustInfo, CLEAN_RETURN );
            pTrustInfo->SetTrustedDomain( pTrustDomainInfo[i].Name.Buffer );
            pTrustInfo->SetFlatName( pTrustDomainInfo[i].Name.Buffer );
            pTrustInfo->SetSid( pTrustDomainInfo[i].Sid ); // SetSid currently not implemented for NT4
            pTrustInfo->SetTrustType( TRUST_TYPE_DOWNLEVEL );
            pTrustInfo->SetTrustDirection( TRUST_DIRECTION_OUTBOUND );
            // NTRAID#NTBUG9-582047-2002/05/15-ericb
            try
            {
               m_vectTrustInfo.push_back( pTrustInfo );
            }
            catch (...)
            {
               dwRet = ERROR_NOT_ENOUGH_MEMORY;
               delete pTrustInfo;
               goto CLEAN_RETURN;
            }
            pTrustInfo = NULL;
         }
         LsaFreeMemory( pTrustDomainInfo );
         pTrustDomainInfo = NULL;
      }       
      else
         dwErr = LsaNtStatusToWinError(Status);      
   } while (Status == STATUS_MORE_ENTRIES);

   if( Status == STATUS_NO_MORE_ENTRIES )
       dwErr = ERROR_SUCCESS;
   //
   // Now, let's add in the user accounts
   //
   if ( dwErr == ERROR_SUCCESS ) 
   {
      do 
      {
         nTrustCount = 0;
         nTotalCount = 0;

         dwErr = NetUserEnum(NULL,
                             0,
                             FILTER_INTERDOMAIN_TRUST_ACCOUNT,
                             (LPBYTE *)&pUserList,
                             MAX_PREFERRED_LENGTH,
                             &nTrustCount,
                             &nTotalCount,
                             &hResumeHandle);

         if ( dwErr == ERROR_SUCCESS || dwErr == ERROR_MORE_DATA ) 
         {
            dwErr = ERROR_SUCCESS;
            for ( i = 0; i < nTrustCount; i++ ) 
            {
               Lop = wcsrchr( pUserList[ i ].usri0_name, L'$' );
               if ( Lop ) 
               {
                  *Lop = UNICODE_NULL;
               }
          
               for ( j = 0; j < m_vectTrustInfo.size(); j++ ) 
               {                                 
                  pTempTrustInfo = m_vectTrustInfo[j];                             
                  if ( _wcsicmp( pUserList[ i ].usri0_name, pTempTrustInfo->GetTrustedDomain() ) == 0 )
                  {   
                      pTempTrustInfo->SetTrustDirection( TRUST_DIRECTION_INBOUND | TRUST_DIRECTION_OUTBOUND );         
                      break;
                  }
               }

               // If it wasn't found, add it...
               if ( j == m_vectTrustInfo.size() ) 
               {
                  pTrustInfo = new CTrustInfo();
                  CHECK_NULL( pTrustInfo, CLEAN_RETURN );
                  pTrustInfo->SetTrustedDomain( pUserList[ i ].usri0_name  );
                  pTrustInfo->SetFlatName( pUserList[ i ].usri0_name  );
                  pTrustInfo->SetTrustType( TRUST_TYPE_DOWNLEVEL );
                  pTrustInfo->SetTrustDirection( TRUST_DIRECTION_INBOUND );

                  // NTRAID#NTBUG9-582047-2002/05/15-ericb
                  try
                  {
                     m_vectTrustInfo.push_back( pTrustInfo );
                  }
                  catch (...)
                  {
                     dwRet = ERROR_NOT_ENOUGH_MEMORY;
                     delete pTrustInfo;
                     goto CLEAN_RETURN;
                  }
            
                  pTrustInfo = NULL;
               }

               if ( Lop ) 
               {
                  *Lop = L'$';
               }
            }

            NetApiBufferFree( pUserList );
            pUserList = NULL;
         }

      } while ( dwErr == ERROR_MORE_DATA );
   }

CLEAN_RETURN:
   if( pUserList )
      NetApiBufferFree( pUserList );
   if( pTrustDomainInfo )
      LsaFreeMemory( pTrustDomainInfo );

   if (ERROR_SUCCESS == dwErr)
   {
      SYSTEMTIME st;

      GetSystemTime(&st);
      SystemTimeToFileTime(&st, (LPFILETIME)&m_liLastEnumed);
   }

   return HRESULT_FROM_WIN32(dwErr);
}
#endif  // NT4_BUILD

//+----------------------------------------------------------------------------
//
//  Method:    CDomainInfo::FindTrust
//
//  Synopsis:  Find a trust by trusted Domain Name
//
//-----------------------------------------------------------------------------
CTrustInfo *
CDomainInfo::FindTrust(PCWSTR pwzTrust)
{
   TRACE(L"CDomainInfo::FindTrust\n");
   TRACE(L"\nlooking for domain %s\n", pwzTrust);
   ASSERT(IsEnumerated());

   ULONG i = 0;
   for( i = 0; i < m_vectTrustInfo.size(); ++i )
   {
      int nStrComp = CompareString(LOCALE_SYSTEM_DEFAULT,
                                   NORM_IGNORECASE,
                                   (m_vectTrustInfo[i])->GetTrustedDomain(), -1,
                                   pwzTrust, -1 );
      ASSERT( nStrComp );
      
      if( CSTR_EQUAL == nStrComp )
      {
         TRACE(L"Trust found!\n");
         return m_vectTrustInfo[i];
      }
   }

   return NULL;   // Not Found
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::GetTrustByIndex
//
//  Synopsis:   Get trust info by Index
//
//-----------------------------------------------------------------------------
CTrustInfo *
CDomainInfo::GetTrustByIndex(size_t index)
{
   ASSERT(IsEnumerated());

   if (index < Size())
   {
      return m_vectTrustInfo[index];
   }
   else
   {
      ASSERT(FALSE);
      return NULL;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainInfo::IsTrustListStale
//
//  Synopsis:  Checks to see if the last emumeration time is older than the
//             passed in criteria.
//
//  Returns:   TRUE if older.
//
//  Notes:     If the trusts haven't been enumerated (m_liLastEnumed == 0),
//             then the enumeration is defined to be stale.
//
//-----------------------------------------------------------------------------
BOOL
CDomainInfo::IsTrustListStale(LARGE_INTEGER liMaxAge)
{
   TRACE(L"CDomainInfo::IsTrustListStale(0x%08x), MaxAge = %d\n",
         this, liMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);
   BOOL fStale = FALSE;
   LARGE_INTEGER liCurrentTime;
   SYSTEMTIME st;

   GetSystemTime(&st);
   SystemTimeToFileTime(&st, (LPFILETIME)&liCurrentTime);

   fStale = (m_liLastEnumed.QuadPart + liMaxAge.QuadPart) < liCurrentTime.QuadPart;

   return fStale;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDomainInfo::CreateAndSendInst
//
//  Synopsis:   Returns a copy of the current instance back to WMI
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::CreateAndSendInst(IWbemObjectSink * pResponseHandler)
{
   TRACE(L"CDomainInfo::CreateAndSendInst\n");
   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      CComPtr<IWbemClassObject> ipNewInst;
      CComVariant var;

      //
      // Create a new instance of the WMI class object
      //
      hr = m_sipClassDefLocalDomain->SpawnInstance(0, &ipNewInst);

      BREAK_ON_FAIL;
      
      // Set the DNS property value
      var = GetDnsName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_DNS_NAME, 0, &var, 0);
      TRACE(L"\tCreating instance %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the flat name property value
      var = GetFlatName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_FLAT_NAME, 0, &var, 0);
      TRACE(L"\twith flat name %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the SID property value
      var = GetSid();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_SID, 0, &var, 0);
      TRACE(L"\twith SID %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the forest name property value
      var = GetForestName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_TREE_NAME, 0, &var, 0);
      TRACE(L"\twith forest name %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the DC name property value
      var = GetDcName();
      hr  = ipNewInst->Put(CSTR_PROP_LOCAL_DC_NAME, 0, &var, 0);
      TRACE(L"\ton DC %s\n", var.bstrVal);
      BREAK_ON_FAIL;

      //
      // Send the object to the caller
      //
      // [In] param, no need to addref.

      IWbemClassObject * pNewInstance = ipNewInst;

      hr = pResponseHandler->Indicate(1, &pNewInstance);

      BREAK_ON_FAIL;

   } while(FALSE);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\common\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_ADMINPRV_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void __cdecl DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_ADMINPRV_TRACE)

#if defined(_USE_ADMINPRV_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
    if (!(f) && DSAAssertFailedLine(THIS_FILE, __LINE__)) { ::DebugBreak(); }

#define VERIFY(f)          ASSERT(f)

#endif // _USE_ADMINPRV_ASSERT

#if defined (_USE_ADMINPRV_TIMER)

void __cdecl DSATimer(LPCWSTR, ...);
#define TIMER DSATimer

#else

#define TIMER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trustmon.rc
//
#define IDS_PROJNAME                    100
#define IDS_TRUSTPRV_DESC               101
#define IDR_TrustPrv                    102
#define IDS_MIT_TRUST_STATUS            103
#define IDS_TRUST_STATUS_OK             104
#define IDS_TRUST_STATUS_FAILED         105
#define IDS_STATUS_INBOUND_ONLY         106
#define IDS_STATUS_NOT_CHECKED          107
#define IDS_STATUS_UNKNOWN              108
#define IDS_PW_VERIFY_NOT_SUPPORTED     109
#define IDS_FIXED_BY_RETARGET           110
#define IDS_STATUS_REDISCOVER           111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\domain.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       domain.h
//
//  Contents:   domain class definition
//
//  Classes:    CDomainInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef DOMAIN_H
#define DOMAIN_H

extern PCWSTR CSTR_PROP_LOCAL_DNS_NAME;
extern PCWSTR CSTR_PROP_LOCAL_FLAT_NAME;
extern PCWSTR CSTR_PROP_LOCAL_SID;
extern PCWSTR CSTR_PROP_LOCAL_TREE_NAME;
extern PCWSTR CSTR_PROP_LOCAL_DC_NAME;

#ifndef MAXDWORD
    #define MAXDWORD ((DWORD) -1)
#endif

class CTrustPrv; // forward declaration;

//+----------------------------------------------------------------------------
//
//  class CDomainInfo
//
//  Domain Information with list of all of the domain's Trusts
//
//-----------------------------------------------------------------------------
class CDomainInfo
{
public:
   CDomainInfo(void);
   ~CDomainInfo(void);

   friend class CTrustPrv;

   void   SetDnsName(PWSTR pszName) {m_strDomainDnsName = pszName;}
   PCWSTR GetDnsName(void) {return m_strDomainDnsName;}
   void   SetFlatName(PWSTR pszFlatName) {m_strDomainFlatName = pszFlatName;}
   PCWSTR GetFlatName(void) {return m_strDomainFlatName;}
   BOOL   SetSid(PSID pSid);
   PCWSTR GetSid(void) {return m_strSid;}
   void   SetForestName(PWSTR pszName) {m_strForestName = pszName;}
   PCWSTR GetForestName(void) {return m_strForestName;}
   void   SetDcName(PWSTR pszName) {m_strDcName = pszName;}
   PCWSTR GetDcName(void) {return m_strDcName;}

   HRESULT Init(IWbemClassObject * pClassDef); // Call once to initialize this object
   void    Reset(void);           // Reset the internal cache
   HRESULT EnumerateTrusts(void); // Enumerate Outgoing trusts for the local domain
   size_t  Size(void) const {return m_vectTrustInfo.size();}  // Get the number of trusts
   CTrustInfo * FindTrust(PCWSTR strTrust);  // Find trust's index
   CTrustInfo * GetTrustByIndex(size_t index); // Get trust info by Index
   BOOL    IsTrustListStale(LARGE_INTEGER liMaxAge);

protected:
   HRESULT CreateAndSendInst(IWbemObjectSink * pResponseHandler);

   // Object's Status
   BOOL IsEnumerated(void) const {return m_liLastEnumed.QuadPart != 0;}

private:

   //
   // Microsoft_LocalDomainInfo properties:
   //
   CString m_strDomainFlatName;
   CString m_strDomainDnsName;
   CString m_strForestName;
   CString m_strSid;
   CString m_strDcName;
   // TODO: FSMO holder info???

   // internal variables.
   //
   CComPtr<IWbemClassObject> m_sipClassDefLocalDomain;
   vector<CTrustInfo *> m_vectTrustInfo;   // array of trusts
   LARGE_INTEGER m_liLastEnumed;
};

class CSmartPolicyHandle
{
public:
   CSmartPolicyHandle(void) : m_hPolicy(NULL) {};
   ~CSmartPolicyHandle(void)
      {
         if( m_hPolicy )
         {
            LsaClose(m_hPolicy);
            m_hPolicy = NULL;
         }
      };

   LSA_HANDLE * operator&()
      {
         return &m_hPolicy;
      }

   operator LSA_HANDLE() const
      {
         return m_hPolicy;
      }

private:

	LSA_HANDLE m_hPolicy;
};

#endif //DOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\trustprv.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       TrustPrv.cpp
//
//  Contents:   Trust Monitor provider WMI interface class implementation
//
//  Classes:    CTrustPrv
//
//  History:    22-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#include "dbg.cpp"

PCWSTR CLASSNAME_STRING_PROVIDER = L"Microsoft_TrustProvider";
PCWSTR CLASSNAME_STRING_TRUST    = L"Microsoft_DomainTrustStatus";
PCWSTR CLASSNAME_STRING_LOCAL    = L"Microsoft_LocalDomainInfo";

PCWSTR CSTR_PROP_TRUST_LIST_LIFETIME   = L"TrustListLifetime";   // uint32
PCWSTR CSTR_PROP_TRUST_STATUS_LIFETIME = L"TrustStatusLifetime"; // uint32
PCWSTR CSTR_PROP_TRUST_CHECK_LEVEL     = L"TrustCheckLevel";     // uint32
PCWSTR CSTR_PROP_RETURN_ALL_TRUSTS     = L"ReturnAll";           // boolean

//WCHAR * const PROVIDER_CLASS_CHANGE_QUERY = L"select * from  __InstanceOperationEvent where TargetInstance.__Relpath = \"Microsoft_TrustProvider=@\"";
WCHAR * const PROVIDER_CLASS_CHANGE_QUERY = L"select * from __InstanceOperationEvent where TargetInstance isa \"Microsoft_TrustProvider\"";
WCHAR * const PROVIDER_CLASS_INSTANCE = L"Microsoft_TrustProvider=@";

//+----------------------------------------------------------------------------
//
//  class CTrustPrv
//
//-----------------------------------------------------------------------------
CTrustPrv::CTrustPrv(void) :
   m_hMutex(NULL),
   m_TrustCheckLevel(DEFAULT_TRUST_CHECK_LEVEL),
   m_fReturnAllTrusts(TRUE)
{
   TRACE(L"CTrustPrv::CTrustPrv(0x%08x)\n", this);
   m_liTrustEnumMaxAge.QuadPart = TRUSTMON_DEFAULT_ENUM_AGE;
   m_liVerifyMaxAge.QuadPart = TRUSTMON_DEFAULT_VERIFY_AGE;
}

CTrustPrv::~CTrustPrv(void)
{
   TRACE(L"CTrustPrv::~CTrustPrv\n\n");

   if (m_hMutex)
   {
      CloseHandle(m_hMutex);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemProviderInit::Initialize
//
//  Synopsis:   Initialize the provider object.
//
//  Returns:    WMI error codes
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::Initialize(
         IN LPWSTR pszUser,
         IN LONG lFlags,
         IN LPWSTR pszNamespace,
         IN LPWSTR pszLocale,
         IN IWbemServices *pNamespace,
         IN IWbemContext *pCtx,
         IN IWbemProviderInitSink *pInitSink)
{
   WBEM_VALIDATE_INTF_PTR(pNamespace);
   WBEM_VALIDATE_INTF_PTR(pCtx);
   WBEM_VALIDATE_INTF_PTR(pInitSink);
   TRACE(L"\nCTrustPrv::Initialize\n");

   HRESULT hr = WBEM_S_NO_ERROR;

   do
   { 
      m_hMutex = CreateMutex(NULL, FALSE, NULL);

      BREAK_ON_NULL_(m_hMutex, hr, WBEM_E_OUT_OF_MEMORY);

      CComPtr<IWbemClassObject> sipProviderInstance;
      IWbemClassObject * pLocalClassDef = NULL;

      //
      // Get pointers to the class definition objects. If a failure, re-compile
      // the MOF file and try once more.
      //
      for (int i = 0; i <= 1; i++)
      {
         CComBSTR sbstrObjectName = CLASSNAME_STRING_TRUST;
         hr = pNamespace->GetObject(sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &m_sipClassDefTrustStatus,
                                    NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
            continue;
         }

         sbstrObjectName = CLASSNAME_STRING_LOCAL;
         hr = pNamespace->GetObject(sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &pLocalClassDef,
                                    NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
            continue;
         }

         sbstrObjectName = CLASSNAME_STRING_PROVIDER;
         hr = pNamespace->GetObject(sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &m_sipClassDefTrustProvider,
                                    NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
            continue;
         }

         //
         // Get the instance of the provider class to read its properties.
         //

         sbstrObjectName = PROVIDER_CLASS_INSTANCE;
         hr = pNamespace->GetObject(sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &sipProviderInstance,
                                    NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
         }
         else
         {
            i = 2; // success, don't loop again.
         }
      }
      BREAK_ON_FAIL;

      //
      // Set this provider instance's runtime properties.
      //
      hr = SetProviderProps(sipProviderInstance);

      BREAK_ON_FAIL;

      //
      // Initialize the domain object.
      //
      hr = m_DomainInfo.Init(pLocalClassDef);

      BREAK_ON_FAIL;

      //
      // Register to receive change notifications for the provider class
      // properties.
      //
      /* this doesn't work, bug # 432757
      CComBSTR bstrLang(L"WQL");
      CComBSTR bstrClassQuery(PROVIDER_CLASS_CHANGE_QUERY);

      hr = pNamespace->ExecNotificationQueryAsync(bstrLang,
                                                  bstrClassQuery,
                                                  0,
                                                  NULL,
                                                  this);
      BREAK_ON_FAIL;
      */

      //
      // Let CIMOM know we are initialized.
      // Return value and SetStatus param should be consistent, so ignore
      // the return value from SetStatus itself (in retail builds).
      //
      HRESULT hr2;
      hr2 = pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
      ASSERT(!FAILED(hr2));

   } while (false);

   if (FAILED(hr))
   {
      TRACE(L"hr = 0x%08x\n", hr);
      pInitSink->SetStatus(WBEM_E_FAILED, 0);
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemObjectSink::Indicate
//
//  Synopsis:   Recieves provider object instance change notifications from WMI.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::Indicate(LONG lObjectCount,
                    IWbemClassObject ** rgpObjArray)
{
   TRACE(L"\nCTrustPrv::Indicate++++++++++++++++\n");

   if (1 > lObjectCount)
   {
      TRACE(L"\tno objects supplied!\n");
      return WBEM_S_NO_ERROR;
   }

   VARIANT var;

   HRESULT hr = (*rgpObjArray)->Get(L"TargetInstance", 0, &var, NULL, NULL);

   if (FAILED(hr) || VT_UNKNOWN != var.vt || !var.punkVal)
   {
      TRACE(L"Error, could not get the target instance, hr = 0x%08x\n", hr);
      return hr;
   }

   hr = SetProviderProps((IWbemClassObject *)var.punkVal);

   VariantClear(&var);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustPrv::SetProviderProps
//
//  Synopsis:  Set the provider runtime instance values from the instance of
//             the Microsoft_TrustProvider class.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPrv::SetProviderProps(IWbemClassObject * pClass)
{
   WBEM_VALIDATE_INTF_PTR(pClass);
   TRACE(L"\nCTrustPrv::SetProviderProps\n");

   HRESULT hr = WBEM_S_NO_ERROR;

   do
   { 
      VARIANT var;

      hr = pClass->Get(CSTR_PROP_TRUST_LIST_LIFETIME, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetTrustListLifetime(var.lVal);

      VariantClear(&var);

      hr = pClass->Get(CSTR_PROP_TRUST_STATUS_LIFETIME, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetTrustStatusLifetime(var.lVal);

      VariantClear(&var);

      hr = pClass->Get(CSTR_PROP_TRUST_CHECK_LEVEL, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetTrustCheckLevel(var.lVal);

      VariantClear(&var);

      hr = pClass->Get(CSTR_PROP_RETURN_ALL_TRUSTS, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetReturnAll(var.boolVal);

      VariantClear(&var);

   } while (false);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:  GetClass
//
//  Synopsis:  Determines if the first element of the passed in path is one
//             of the valid class names.
//
//  Returns:   TrustMonClass enum value.
//
//-----------------------------------------------------------------------------
TrustMonClass
GetClass(BSTR strClass)
{
   if (_wcsnicmp(strClass, CLASSNAME_STRING_PROVIDER, wcslen(CLASSNAME_STRING_PROVIDER)) == 0)
   {
      TRACE(L"GetClass returning %s\n", CLASSNAME_STRING_PROVIDER);
      return CLASS_PROVIDER;
   }
   else
   {
      if (_wcsnicmp(strClass, CLASSNAME_STRING_TRUST, wcslen(CLASSNAME_STRING_TRUST)) == 0)
      {
         TRACE(L"GetClass returning %s\n", CLASSNAME_STRING_TRUST);
         return CLASS_TRUST;
      }
      else
      {
         if (_wcsnicmp(strClass, CLASSNAME_STRING_LOCAL, wcslen(CLASSNAME_STRING_LOCAL)) == 0)
         {
            TRACE(L"GetClass returning %s\n", CLASSNAME_STRING_LOCAL);
            return CLASS_LOCAL;
         }
         else
         {
            TRACE(L"GetClass returning NO_CLASS\n");
            return NO_CLASS;
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemServices::GetObjectAsync
//
//  Synopsis:   Return the instance named by strObjectPath.
//
//  Returns:    WMI error codes
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::GetObjectAsync( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext * pCtx,
        IN IWbemObjectSink * pResponseHandler)
{
   HRESULT hr = WBEM_S_NO_ERROR;
   CTrustInfo * pTrust;
   TRACE(L"\nCTrustsPrv::GetObjectAsync:\n"
         L"\tObject param = %s, flags = 0x%08x\n", strObjectPath, lFlags);
   do
   {
      WBEM_VALIDATE_IN_STRING_PTR(strObjectPath);
      WBEM_VALIDATE_INTF_PTR(pCtx);
      WBEM_VALIDATE_INTF_PTR(pResponseHandler);

      //
      // Determine which class is being requested.
      // A valid class object path has the form: class_name.key_name="key_value"
      //

      TrustMonClass Class = GetClass(strObjectPath);

      if (NO_CLASS == Class)
      {
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL;
      }

      // Isolate the class name from the key name
      //

      PWSTR pwzInstance;
      PWSTR pwzKeyName = wcschr(strObjectPath, L'.');

      if (pwzKeyName)
      {
         // A request without a key name is only valid for a class that
         // is defined to have zero or only one dynamic instance (singleton).
         //
         // Isolate the key name from the class name
         //
         *pwzKeyName = L'\0'; // overwrite the period with a null
         pwzKeyName++;        // point to the first char of the key name
      }

      CClientImpersonation Client;

      switch (Class)
      {
      case CLASS_PROVIDER:
         //
         // The provider class has no dynamic instances, return a copy of the
         // static instance.
         //
         hr = CreateAndSendProv(pResponseHandler);

         BREAK_ON_FAIL;

         break;

      case CLASS_TRUST:
         //
         // There can be zero or more trusts. Thus the key name and value must
         // be specified.
         //
         hr = Client.Impersonate();

         BREAK_ON_FAIL;

         if (!pwzKeyName)
         {
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL;
         }

         pwzInstance = wcschr(pwzKeyName, L'=');

         if (!pwzInstance || L'\"' != pwzInstance[1])
         {
            // No equal sign found or the following char not a quote.
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL;
         }

         *pwzInstance = L'\0'; // isolate the key name.

         if (_wcsicmp(pwzKeyName, CSTR_PROP_TRUSTED_DOMAIN) != 0)
         {
            // Key name not correct.
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL;
         }

         pwzInstance++; // point to the first quote

         if (L'\0' == pwzInstance[1] || L'\"' == pwzInstance[1])
         {
            // No char following the quote or the next char a second quote
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL;
         }

         pwzInstance++; // point to the first char of the instance value;

         PWSTR pwzInstEnd;

         pwzInstEnd = wcschr(pwzInstance, L'\"');

         if (!pwzInstEnd)
         {
            // No terminating quote.
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL;
         }

         *pwzInstEnd = L'\0'; // replace ending quote with a null

         if (m_DomainInfo.IsTrustListStale(m_liTrustEnumMaxAge))
         {
            hr = m_DomainInfo.EnumerateTrusts();
         }

         BREAK_ON_FAIL;

         pTrust = m_DomainInfo.FindTrust(pwzInstance);

         BREAK_ON_NULL_(pTrust, hr, WBEM_E_INVALID_OBJECT_PATH);

         //
         // Verify the trust.
         //
         if (pTrust->IsVerificationStale(m_liVerifyMaxAge))
         {
            pTrust->Verify(GetTrustCheckLevel());
         }

         Client.Revert();

         //
         // Create a new instance of the object
         //
         hr = CreateAndSendTrustInst(*pTrust,
                                     m_sipClassDefTrustStatus,
                                     pResponseHandler);
         BREAK_ON_FAIL;

         break;

      case CLASS_LOCAL:
         //
         // The local domain info class has only one instance, return that.
         //
         hr = Client.Impersonate();

         BREAK_ON_FAIL;

         hr = m_DomainInfo.CreateAndSendInst(pResponseHandler);

         Client.Revert();
         BREAK_ON_FAIL;

         break;

      default:
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL;
      }

   } while(FALSE);

   return pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemServices::CreateInstanceEnumAsync
//
//  Synopsis:   Start an asyncronous enumeration of the instances of the class.
//
//  Returns:    WMI error codes
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::CreateInstanceEnumAsync( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
{
   TRACE(L"\nCTrustsPrv::CreateInstanceEnumAsync:\n"
         L"\tClass param = %s, flags = 0x%08x\n", strClass, lFlags);

   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      WBEM_VALIDATE_IN_STRING_PTR(strClass);
      WBEM_VALIDATE_INTF_PTR(pCtx);
      WBEM_VALIDATE_INTF_PTR(pResponseHandler);

      //
      // Determine which class is being requested.
      // A valid class object path has the form: class_name.key_name="key_value"
      //

      TrustMonClass Class = GetClass(strClass);

      if (NO_CLASS == Class)
      {
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL;
      }

      HANDLE hToken = NULL, hTh = NULL;
      DWORD dwErr = NO_ERROR;
      CAsyncCallWorker * pWorker = NULL;
      CClientImpersonation Client;

      switch (Class)
      {
      case CLASS_PROVIDER:
         //
         // The provider class has no dynamic instances, return a copy of the
         // static instance.
         //

         hr = CreateAndSendProv(pResponseHandler);

         BREAK_ON_FAIL;

         hr = pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

         BREAK_ON_FAIL;

         break;

      case CLASS_TRUST:
         //
         // Impersonate the client (the caller) and then obtain the
         // impersonation token. Pass that token to the new thread so that
         // it can imperonate the client.
         //
         hr = Client.Impersonate();

         BREAK_ON_FAIL;

         hTh = GetCurrentThread(); // this pseudo handle doesn't need to be closed.

         if (!hTh)
         {
            dwErr = GetLastError();
            TRACE(L"IWbemServices::CreateInstanceEnumAsync: GetCurrentThread failed with error %d\n", dwErr);
            BREAK_ON_FAIL(dwErr);
         }
         else
         {
            if (!OpenThreadToken(hTh, TOKEN_READ | TOKEN_IMPERSONATE,
                                 TRUE, &hToken))
            {
               dwErr = GetLastError();
               TRACE(L"IWbemServices::CreateInstanceEnumAsync: OpenThreadToken failed with error %d\n", dwErr);
               BREAK_ON_FAIL(dwErr);
            }
#if defined (DBG)
            else
            {
               TOKEN_USER tu[10] = {0};
               DWORD dwLen = sizeof(tu);
               if (GetTokenInformation(hToken, TokenUser, tu, dwLen, &dwLen))
               {
                  WCHAR wzName[MAX_PATH+1] = {0}, wzDomain[MAX_PATH+1] = {0};
                  DWORD dwDom = MAX_PATH;
                  SID_NAME_USE Use;
                  dwLen = MAX_PATH;
                  LookupAccountSid(NULL, tu[0].User.Sid, wzName, &dwLen, wzDomain, &dwDom, &Use);
                  TRACE(L"IWbemServices::CreateInstanceEnumAsync: TrustMon is impersonating %s\\%s\n",
                        wzDomain, wzName);
               }
               else
               {
                  TRACE(L"IWbemServices::CreateInstanceEnumAsync: GetTokenInformation failed with error %d and required buf size %d\n",
                        GetLastError(), dwLen);
               }
            }
#endif // DBG
         }
         Client.Revert();

         //
         // Spawn the worker thread to enum and return the trust instances.
         // Note that the class definition pointer is not add-ref'd here
         // because it is add-ref'd separately in the CAsyncCallWorker ctor.
         //
         pWorker = new CAsyncCallWorker(this,
                                        hToken,
                                        lFlags,
                                        m_sipClassDefTrustStatus,
                                        pResponseHandler);

         BREAK_ON_NULL_(pWorker, hr, WBEM_E_OUT_OF_MEMORY);
         uintptr_t hThread;

         hThread = _beginthread(CAsyncCallWorker::CreateInstEnum, 0, (PVOID)pWorker);

         BREAK_ON_NULL_(hThread != -1, hr, WBEM_E_OUT_OF_MEMORY);

         break;

      case CLASS_LOCAL:
         //
         // The local domain info class has only one instance, return that.
         //
         hr = Client.Impersonate();

         BREAK_ON_FAIL;

         hr = m_DomainInfo.CreateAndSendInst(pResponseHandler);

         if (FAILED(hr))
         {
            BREAK_ON_FAIL;
         }

         hr = pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

         Client.Revert();

         BREAK_ON_FAIL;

         break;

      default:
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL;
      }

   } while(FALSE);

   if (FAILED(hr))
   {
       return pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustPrv::CreateAndSendProv
//
//  Synopsis:  Return the provider parameters.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPrv::CreateAndSendProv(IWbemObjectSink * pResponseHandler)
{
   TRACE(L"CTrustsPrv::CreateAndSendProv:\n");
   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      CComPtr<IWbemClassObject> ipNewInst;
      VARIANT var;
      VariantInit(&var);

      //
      // Create a new instance of the WMI class object
      //
      hr = m_sipClassDefTrustProvider->SpawnInstance(0, &ipNewInst);

      BREAK_ON_FAIL;
      
      // Set the TrustListLifetime property value
      var.lVal = (long)GetTrustListLifetime();
      var.vt = VT_I4;
      hr = ipNewInst->Put(CSTR_PROP_TRUST_LIST_LIFETIME, 0, &var, 0);
      TRACE(L"\tTrustListLifetime %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the TrustStatusLifetime property value
      var.lVal = (long)GetTrustStatusLifetime();
      hr = ipNewInst->Put(CSTR_PROP_TRUST_STATUS_LIFETIME, 0, &var, 0);
      TRACE(L"\tTrustStatusLifetime %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the TrustCheckLevel property value
      var.lVal = (long)GetTrustCheckLevel();
      hr = ipNewInst->Put(CSTR_PROP_TRUST_CHECK_LEVEL, 0, &var, 0);
      TRACE(L"\tTrustCheckLevel %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the ReturnAll property value
      var.boolVal = (GetReturnAll()) ? VARIANT_TRUE : VARIANT_FALSE;
      var.vt = VT_BOOL;
      hr = ipNewInst->Put(CSTR_PROP_RETURN_ALL_TRUSTS, 0, &var, 0);
      TRACE(L"\tReturnAll %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      //
      // Send the object to the caller
      //
      // [In] param, no need to addref.

      IWbemClassObject * pNewInstance = ipNewInst;

      hr = pResponseHandler->Indicate(1, &pNewInstance);

      BREAK_ON_FAIL;

   } while(FALSE);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H_INCLUDED_)
#define _STDAFX_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#   define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define STRICT
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

#define _ATL_NO_UUIDOF

#pragma warning(disable: 4100) // don't warn about unreferenced formal params (not all WMI interface params are used)
#pragma warning(disable: 4127) // don't warn about conditional expression is constant
#pragma warning(disable: 4514) // don't warn about unreferenced inline removal (ATL)
#pragma warning(disable: 4505) // don't warn about unreferenced local function (ATL)

#pragma warning(push, 3) // avoid warnings from system headers when compiling at W4

#include <afx.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <vector>

using namespace std;

#include <malloc.h>
#include <process.h>
#include <wbemprov.h>
#include <ntdsapi.h>
#include <ntlsa.h>
#include <lm.h>
#include <dsgetdc.h>
#include <sddl.h>
#include <iads.h> // IADsPathname

#pragma warning(pop) // end: avoid warnings from system headers when compiling at W4

///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_ADMINPRV_TRACE
    #define _USE_ADMINPRV_ASSERT
    #define _USE_ADMINPRV_TIMER
  #endif
#endif

#define ADMINPRV_COMPNAME L"TrustMon"

#include "dbg.h"
///////////////////////////////////////////

#include "common.h"
#include "trust.h"
#include "domain.h"
#include "TrustPrv.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\trustprv.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       TrustPrv.h
//
//  Contents:   WMI provider class definition
//
//  Classes:    
//
//  History:    22-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#if !defined(_TRUSTPRV_H_INCLUDED_)
#define _TRUSTPRV_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h" // resource defines
#include "msg.h"

#define TM_PROV_NAME L"TrustMonitor"

extern PCWSTR CLASSNAME_STRING_PROVIDER;
extern PCWSTR CLASSNAME_STRING_TRUST;
extern PCWSTR CLASSNAME_STRING_LOCAL;

enum TrustMonClass {NO_CLASS, CLASS_PROVIDER, CLASS_TRUST, CLASS_LOCAL};
enum TrustCheckLevel {DONT_VERIFY = 0, SC_QUERY, PW_VERIFY, SC_RESET};
const DWORD MaxCheckLevel = (DWORD)SC_RESET; // update this if new check levels added

EXTERN_C const CLSID CLSID_TrustMonProvider;

const unsigned long TRUSTMON_FILETIMES_PER_MILLISECOND = 10000;
const DWORD TRUSTMON_FILETIMES_PER_SECOND = 1000 * TRUSTMON_FILETIMES_PER_MILLISECOND;
const __int64 TRUSTMON_FILETIMES_PER_MINUTE = 60 * (__int64)TRUSTMON_FILETIMES_PER_SECOND;
const __int64 TRUSTMON_FILETIMES_PER_HOUR = 60 * (__int64)TRUSTMON_FILETIMES_PER_MINUTE;

const __int64 TRUSTMON_DEFAULT_ENUM_AGE = 20 * TRUSTMON_FILETIMES_PER_MINUTE;
const __int64 TRUSTMON_DEFAULT_VERIFY_AGE = 3 * TRUSTMON_FILETIMES_PER_MINUTE;

const TrustCheckLevel DEFAULT_TRUST_CHECK_LEVEL = PW_VERIFY;

class CAsyncCallWorker; // forward declaration

//+----------------------------------------------------------------------------
//
// Class:   CTrustPrv
//
//-----------------------------------------------------------------------------

class CTrustPrv : 
   public IWbemServices,
   public IWbemProviderInit,
   public IWbemObjectSink,
   public CComObjectRoot,
   public CComCoClass<CTrustPrv, &CLSID_TrustMonProvider>
{
public:
   CTrustPrv(void);
   ~CTrustPrv(void);

BEGIN_COM_MAP(CTrustPrv)
   COM_INTERFACE_ENTRY(IWbemServices)
   COM_INTERFACE_ENTRY(IWbemProviderInit)
   COM_INTERFACE_ENTRY(IWbemObjectSink)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTrustPrv) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_TrustPrv)

   //
   // IWbemProviderInit
   //

   STDMETHOD(Initialize)(
        IN LPWSTR pszUser,
        IN LONG lFlags,
        IN LPWSTR pszNamespace,
        IN LPWSTR pszLocale,
        IN IWbemServices *pNamespace,
        IN IWbemContext *pCtx,
        IN IWbemProviderInitSink *pInitSink);

   //
   // IWbemServices
   //

   // +++ Implemented +++

   STDMETHOD(GetObjectAsync)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler);

   STDMETHOD(CreateInstanceEnumAsync)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler);

   // --- NOT Implemented ---

   STDMETHOD(OpenNamespace)( 
       IN const BSTR strNamespace,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemServices **ppWorkingNamespace,
       IN OUT IWbemCallResult **ppResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CancelAsyncCall)( 
       IN IWbemObjectSink *pSink)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(QueryObjectSink)( 
       IN long lFlags,
       OUT IWbemObjectSink **ppResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(GetObject)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemClassObject **ppObject,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutClass)( 
       IN IWbemClassObject *pObject,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutClassAsync)( 
       IN IWbemClassObject *pObject,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteClass)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteClassAsync)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CreateClassEnum)( 
       IN const BSTR strSuperclass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CreateClassEnumAsync)( 
       IN const BSTR strSuperclass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutInstance)( 
       IN IWbemClassObject *pInst,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutInstanceAsync)( 
       IN IWbemClassObject *pInst,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteInstance)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteInstanceAsync)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CreateInstanceEnum)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecQuery)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecQueryAsync)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecNotificationQuery)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecNotificationQueryAsync)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecMethod)( 
       IN const BSTR strObjectPath,
       IN const BSTR strMethodName,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemClassObject *pInParams,
       IN OUT IWbemClassObject **ppOutParams,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecMethodAsync)( 
       IN const BSTR strObjectPath,
       IN const BSTR strMethodName,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemClassObject *pInParams,
       IN IWbemObjectSink *pResponseHandler)
       {return WBEM_E_NOT_SUPPORTED;};

   //
   // IWbemObjectSink
   //
   STDMETHOD(Indicate)(
      IN LONG lObjectCount,
      IN IWbemClassObject ** rgpObjArray);

   STDMETHOD(SetStatus)(
      IN LONG lFlags,
      IN HRESULT hr,
      IN BSTR strParam,
      IN IWbemClassObject * pObj)
      {TRACE(L"CTrustPrv::SetStatus\n");
       return WBEM_NO_ERROR;};

   void  SetTrustListLifetime(DWORD dwMins) {m_liTrustEnumMaxAge.QuadPart = dwMins * TRUSTMON_FILETIMES_PER_MINUTE;}
   DWORD GetTrustListLifetime(void) {return (DWORD)(m_liTrustEnumMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);}
   void  SetTrustStatusLifetime(DWORD dwMins) {m_liVerifyMaxAge.QuadPart = dwMins * TRUSTMON_FILETIMES_PER_MINUTE;}
   DWORD GetTrustStatusLifetime(void) {return (DWORD)(m_liVerifyMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);}
   void  SetTrustCheckLevel(DWORD dwLevel) {if (dwLevel > MaxCheckLevel) dwLevel = MaxCheckLevel; m_TrustCheckLevel = (TrustCheckLevel)dwLevel;}
   TrustCheckLevel GetTrustCheckLevel(void) {return m_TrustCheckLevel;}
   void  SetReturnAll(BOOL fReturnAll) {m_fReturnAllTrusts = fReturnAll;}
   BOOL  GetReturnAll(void) {return m_fReturnAllTrusts;}
   HRESULT SetProviderProps(IWbemClassObject * pClass);

protected:
   CComPtr<IWbemClassObject>   m_sipClassDefTrustProvider;
   CComPtr<IWbemClassObject>   m_sipClassDefTrustStatus;

   friend class CAsyncCallWorker;

private:

   HRESULT CreateAndSendProv(IWbemObjectSink * pResponseHandler);

   CDomainInfo     m_DomainInfo;

   HANDLE          m_hMutex;
   LARGE_INTEGER   m_liTrustEnumMaxAge;
   LARGE_INTEGER   m_liVerifyMaxAge;
   TrustCheckLevel m_TrustCheckLevel;
   BOOL            m_fReturnAllTrusts;
};

//+----------------------------------------------------------------------------
//
//  class CAsyncCallWorker
//
//-----------------------------------------------------------------------------
class CAsyncCallWorker
{
public:
   CAsyncCallWorker(CTrustPrv * pTrustsImpl,
                    HANDLE hToken,
                    long lFlags,
                    IWbemClassObject * pClassDef,
                    IWbemObjectSink * pResponseHandler,
                    LPWSTR pwzInstanceName = NULL);
   ~CAsyncCallWorker();

   static VOID __cdecl CreateInstEnum(PVOID pParam);
   // unused static VOID __cdecl GetObj(PVOID pParam);

private:
   CComPtr<CTrustPrv>          m_sipTrustPrv;
   CComPtr<IWbemObjectSink>    m_sipResponseHandler;
   CComPtr<IWbemClassObject>   m_sipClassDef;
   LPWSTR                      m_pwzInstanceName;
   long                        m_lFlags;
   HANDLE                      _hToken;
};

//+----------------------------------------------------------------------------
//
//  class CClientImpersonation
//
//-----------------------------------------------------------------------------
class CClientImpersonation
{
public:
   CClientImpersonation(void) : _fImpersonating(false) {}
   ~CClientImpersonation(void) {
      if (_fImpersonating)
      {
         CoRevertToSelf();
      }
   }

   HRESULT Impersonate(void) {
      ASSERT(!_fImpersonating);
      HRESULT hr = CoImpersonateClient();
      if (SUCCEEDED(hr)) _fImpersonating = true;
      return hr;
   }

   void Revert(void) {
      if (_fImpersonating)
      {
         CoRevertToSelf();
         _fImpersonating = false;
      }
   }

private:
   bool _fImpersonating;
};

HRESULT CreateAndSendTrustInst(CTrustInfo & Trust,
                               IWbemClassObject * pClassDef,
                               IWbemObjectSink * pResponseHandler);

#define CHECK_HRESULT(hr, x) \
   if (FAILED(hr)) { \
      TRACE(L"***ERROR 0x%08x at %S line: %d\n", hr, __FILE__, __LINE__); \
      x; }

VOID WINAPI DoMofComp(HWND hWndParent,
                      HINSTANCE hModule,
                      PCTSTR ptzCommandLine,
                      INT nShowCmd);

#endif // !defined(_TRUSTPRV_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\trust.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.cpp
//
//  Contents:   Trust class implementation
//
//  Classes:    CTrustInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include <stdafx.h>

PCWSTR CSTR_PROP_TRUSTED_DOMAIN      = L"TrustedDomain";      // String
PCWSTR CSTR_PROP_FLAT_NAME           = L"FlatName";           // String
PCWSTR CSTR_PROP_SID                 = L"SID";                // String
PCWSTR CSTR_PROP_TRUST_DIRECTION     = L"TrustDirection";     // uint32
PCWSTR CSTR_PROP_TRUST_TYPE          = L"TrustType";          // uint32
PCWSTR CSTR_PROP_TRUST_ATTRIBUTES    = L"TrustAttributes";    // uint32
PCWSTR CSTR_PROP_TRUST_STATUS        = L"TrustStatus";        // uint32
PCWSTR CSTR_PROP_TRUST_STATUS_STRING = L"TrustStatusString";  // String
PCWSTR CSTR_PROP_TRUST_IS_OK         = L"TrustIsOk";          // Boolean
PCWSTR CSTR_PROP_TRUSTED_DC_NAME     = L"TrustedDCName";      // String

// Define NETLOGON_CONTROL_TC_VERIFY if not found so this will build for W2K.
// This constant is in the Whistler version of lmaccess.h
#if !defined(NETLOGON_CONTROL_TC_VERIFY)
#  define NETLOGON_CONTROL_TC_VERIFY (10)
#endif

//+----------------------------------------------------------------------------
//
//  Class:  CTrustInfo
//
//-----------------------------------------------------------------------------
CTrustInfo::CTrustInfo() : m_ulTrustDirection(0),
                           m_ulTrustType(0),
                           m_ulTrustAttributes(0),
                           m_trustStatus(ERROR_SUCCESS),
                           m_VerifyStatus(VerifyStatusNone),
                           m_fPwVerifySupported(TRUE)
{
   m_liLastVerified.QuadPart = 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::Verify
//
//  Synopsis:   Verify the status of the trust
//
//  Returns:    FALSE if the trust was not outbound.
//
//-----------------------------------------------------------------------------
BOOL
CTrustInfo::Verify(TrustCheckLevel CheckLevel)
{
   TRACE(L"CTrustInfo::Verify, verify level %d\n", CheckLevel);
   NET_API_STATUS netStatus = NERR_Success;
   NETLOGON_INFO_2 * pNetlogonInfo2 = NULL;
   VerifyStatus Status = VerifyStatusNone;
   PCWSTR pwzTrustedDomain = GetTrustedDomain();
   CString strDCName, strResetTarget = GetTrustedDomain();

   if (DONT_VERIFY == CheckLevel)
   {
      TRACE(L"\tCheck-Level set to not verify trust.\n");
      SetTrustStatus(NERR_Success, VerifyStatusTrustNotChecked);
      return TRUE;
   }

   TRACE(L"\tVerifying trust with %s\n", GetTrustedDomain());

   if (TRUST_TYPE_MIT == GetTrustType())
   {
      // don't verify non-Windows trusts.
      //
      TRACE(L"\tNot a windows trust, returning.\n");
      SetTrustStatus(NERR_Success, VerifyStatusNotWindowsTrust);
      SetLastVerifiedTime();
      return TRUE;
   }

   if (!IsTrustOutbound())
   {
      // don't verify inbound-only trusts.
      //
      TRACE(L"\tInbound-only trust, returning.\n");
      SetTrustStatus(NERR_Success, VerifyStatusNotOutboundTrust);
      SetLastVerifiedTime();
      return FALSE;
   }

   //
   // NETLOGON_CONTROL_TC_QUERY - get the status (locally) and the name of trusted DC
   // Note that the secure channel is set up only on demand, so it is not an error if
   // it is not set up. The SC_QUERY will return ERROR_NO_LOGON_SERVERS if this is the
   // case.
   //

   netStatus = I_NetLogonControl2(NULL,
                                  NETLOGON_CONTROL_TC_QUERY,
                                  2,
                                  (LPBYTE)&pwzTrustedDomain,
                                  (LPBYTE *)&pNetlogonInfo2);

   if (NERR_Success == netStatus)
   {
      ASSERT(pNetlogonInfo2);

      netStatus = pNetlogonInfo2->netlog2_tc_connection_status;

      if (netStatus == NERR_Success)
      {
         SetTrustedDCName(pNetlogonInfo2->netlog2_trusted_dc_name);
         strDCName = pNetlogonInfo2->netlog2_trusted_dc_name;
#if !defined(NT4_BUILD)
          //
          // Compose the domain\dc string for the reset command so it will not change
          // DCs as a result of the reset. This only works with NT5 or later NetLogon.
          //
          strResetTarget += L"\\";
          strResetTarget += pNetlogonInfo2->netlog2_trusted_dc_name + 2; // skip the UNC double slashes
#endif
      }
      else
      {
         if (ERROR_NO_LOGON_SERVERS == netStatus)
         {
            // This is the error returned when the SC has not yet been set up.
            // It is also returned if no DCs are reachable. DsGetDcName is called with the
            // force flag to discover if any DCs are reachable on the net.
            //
            PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
            DWORD dwRet = NO_ERROR;

#if !defined(NT4_BUILD)
            dwRet = DsGetDcName(NULL, pwzTrustedDomain, NULL, NULL, DS_FORCE_REDISCOVERY, &pDCInfo);
#endif
            if (NO_ERROR == dwRet)
            {
               // A DC is reachable, so it is safe to assume that the SC has not yet been
               // set up. Treat this as success.
               //
               netStatus = NERR_Success;
               TRACE(L"SC_QUERY has returned ERROR_NO_LOGON_SERVERS, SC not yet set up.\n");
#if !defined(NT4_BUILD)
               SetTrustedDCName(pDCInfo->DomainControllerName);
               NetApiBufferFree(pDCInfo);
#endif
            }
            else
            {
               // If there are no DCs, there is nothing to be done except return the error.
               //
               TRACE(L"DsGetDcName /FORCE has returned %d, DC not found.\n", dwRet);
               // Save the error code and fixed by method
               SetTrustStatus(dwRet, VerifyStatusBroken);
               SetLastVerifiedTime();

               return TRUE;
            }
         }
         else
         {
             TRACE(L"SC_QUERY has returned %d.\n", netStatus);
         }
      }
      NetApiBufferFree(pNetlogonInfo2);
   }
   else
   {
      TRACE(L"I_NetLogonControl2 has returned %d.\n", netStatus);
   }

   //
   // Do a trust PW verification if the other domain supports it.
   //
   if (PW_VERIFY == CheckLevel)
   {
      if (m_fPwVerifySupported)
      {
         netStatus = I_NetLogonControl2(NULL,
                                        NETLOGON_CONTROL_TC_VERIFY,
                                        2,
                                        (LPBYTE)&pwzTrustedDomain,
                                        (LPBYTE *)&pNetlogonInfo2);

         if (NERR_Success == netStatus)
         {
            ASSERT(pNetlogonInfo2);
            netStatus = pNetlogonInfo2->netlog2_tc_connection_status;
            NetApiBufferFree(pNetlogonInfo2);
         }
         if (NERR_Success == netStatus)
         {
            TRACE(L"PW Verify successful on %s\n", pwzTrustedDomain);
            Status = VerifyStatusTrustOK;
         }
         else
         {
            if (ERROR_INVALID_LEVEL == netStatus ||
                ERROR_NOT_SUPPORTED == netStatus ||
                RPC_S_PROCNUM_OUT_OF_RANGE == netStatus ||
                RPC_NT_PROCNUM_OUT_OF_RANGE == netStatus)
            {
               TRACE(L"NETLOGON_CONTROL_TC_VERIFY is not supported on %s\n", pwzTrustedDomain);
               m_fPwVerifySupported = FALSE;
               Status = VerifyStatusPwCheckNotSupported;
               netStatus = NERR_Success; // call it success since we don't know the true state
            }
            else
            {
               TRACE(L"NETLOGON_CONTROL_TC_VERIFY returned 0x%08x on %s\n", netStatus, pwzTrustedDomain);
               Status = VerifyStatusBroken;
            }
         }
      }
      else
      {
         Status = VerifyStatusPwCheckNotSupported;
      }
   }

   //
   // Try an SC Reset against the DC returned by the SC query
   //
   if (SC_RESET == CheckLevel)
   {
      PCWSTR pwzResetTarget = strResetTarget;

      netStatus = I_NetLogonControl2(NULL,
                                     NETLOGON_CONTROL_REDISCOVER,
                                     2,
                                     (LPBYTE)&pwzResetTarget,
                                     (LPBYTE *)&pNetlogonInfo2);

      if (NERR_Success == netStatus)
      {
         ASSERT(pNetlogonInfo2);
         netStatus = pNetlogonInfo2->netlog2_tc_connection_status;
         NetApiBufferFree(pNetlogonInfo2);
      }
      if (NERR_Success == netStatus)
      {
         TRACE(L"SC_RESET successfull on %s\n", pwzResetTarget);
         Status = VerifyStatusRediscover;
      }
      else
      {
         TRACE(L"SC_RESET returned 0x%08x on %s\n", netStatus, pwzResetTarget);
      }
   }

#ifdef NT4_BUILD
   //
   // Force trust pw replication from PDC to BDCs; only works on pre-W2K.
   //
   if (netStatus != NERR_Success)
   {
      // perform only once, ignore the result
      ForceReplication();
   }
#endif

   //
   // If still in an error state, do an SC reset against any DC
   //
   if (netStatus != NERR_Success)
   {
      netStatus = ForceRediscover(NULL, &strDCName);

      if (NERR_Success == netStatus)
      {
         Status = VerifyStatusRediscover;

         SetTrustedDCName(const_cast<PWSTR>((PCWSTR)strDCName));
      }
   }

   //
   // Walk through the DCs trying to establish an SC: TRCHK_RETARGET_ON_ERROR
   //
   if (NERR_Success != netStatus)
   {
      vector<LPWSTR>    dcList;
      LPBYTE      pbuf	= NULL;
    
      TRACE(L"Attempting to retarget...\n");

      //
      // Enumerate all DCs in the trusted domain
      // Attempt reconnecting to another DC.
      //
      // The returned value is not recorded.
      // (if not enumerated, skip this step)
      //
      if( NERR_Success == GetDCList(strDCName,
                                    dcList,
                                    &pbuf))
      {
         //
         // Try to connect to every DC until success
         //
         for (vector<LPWSTR>::iterator  ppszDCName = dcList.begin();
              NERR_Success != netStatus && ppszDCName != dcList.end();
              ppszDCName++)
         {
            netStatus = ForceRediscover(*ppszDCName, &strDCName);
         }
      }

      if (NERR_Success == netStatus)
      {
         SetTrustedDCName(const_cast<PWSTR>((PCWSTR)strDCName));
         Status = VerifyStatusRetarget;
      }

      //
      // Clean up the DC list
      //
      if (pbuf)
      {
         VERIFY( NERR_Success == NetApiBufferFree(pbuf));
      }
   }

   // Save the error code and Status
   SetTrustStatus(netStatus, Status);
   SetLastVerifiedTime();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::SetLastVerifiedTime
//
//  Synopsis:   Record the time of verification.
//
//-----------------------------------------------------------------------------
void
CTrustInfo::SetLastVerifiedTime(void)
{
   SYSTEMTIME st;

   GetSystemTime(&st);
   SystemTimeToFileTime(&st, (LPFILETIME)&m_liLastVerified);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustInfo::IsVerificationStale
//
//  Synopsis:  Checks to see if the last verification time is older than the
//             passed in criteria.
//
//  Returns:   TRUE if older.
//
//  Notes:     If the trust hasn't been verified (m_liLastVerified == 0),
//             then the verification is defined to be stale.
//
//-----------------------------------------------------------------------------
BOOL
CTrustInfo::IsVerificationStale(LARGE_INTEGER liMaxAge)
{
   TRACE(L"CTrustInfo::IsVerificationStale(0x%08x), MaxAge = %d\n",
         this, liMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);
   BOOL fStale = FALSE;
   LARGE_INTEGER liCurrentTime;
   SYSTEMTIME st;

   GetSystemTime(&st);
   SystemTimeToFileTime(&st, (LPFILETIME)&liCurrentTime);

   //TRACE(L"\tlast: %I64d, cur: %I64d, max: %I64d\n", m_liLastVerified, liCurrentTime, liMaxAge);

   fStale = (m_liLastVerified.QuadPart + liMaxAge.QuadPart) < liCurrentTime.QuadPart;

   return fStale;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::GetDCList
//
//  Synopsis:   Enumerate all DCs in a domain and return a list in random order.
//
//-----------------------------------------------------------------------------
NET_API_STATUS
CTrustInfo::GetDCList(PCWSTR pszKnownServer,   // OPTIONAL The server name to be placed in the end of the list
                      vector<LPWSTR> & dcList, // Vector of PCWSTRs, pointing to the DC names inside pbufptr
                      LPBYTE * pbufptr )       // This buffer must be freed with NetApiBufferFree when done.
{
    TRACE(L"CTrustInfo::GetDCList\n");

    ASSERT( pbufptr );
    ASSERT( !(*pbufptr) );

    NET_API_STATUS  netStatus        = NERR_Success;
    DWORD           dwEntriesRead    = 0;
    DWORD           dwTotalEntries   = 0;
    DWORD           dwResumeHandle   = 0;
    DWORD           dwIndKnownServer = MAXDWORD;
    DWORD           dwInd            = 0;
    
    do
    {
        // Init
        dcList.clear();
    
        //
        //  Enumerate all the servers belonging to the specified domain
        //
        netStatus = NetServerEnum( NULL,
                                   100,       // SERVER_INFO_100
                                   pbufptr,
                                   MAX_PREFERRED_LENGTH,
                                   & dwEntriesRead,
                                   & dwTotalEntries,
                                   SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL,
                                   GetTrustedDomain(),
                                   & dwResumeHandle );

        TRACE(L"NetServerEnum returned 0x%08x! (%d entries)\n", netStatus, dwEntriesRead);

        if( netStatus == ERROR_MORE_DATA )
        {
            // should never happen (no enum handle)
            ASSERT( FALSE );

            // process whatever NetServerEnum returned.
            netStatus = NERR_Success;
        }

        if( netStatus != NERR_Success ||
            !dwEntriesRead ||
            !(*pbufptr) )
        {
            TRACE(L"Failure, exiting...\n");
            
            dcList.clear();

            if( *pbufptr )
            {
                VERIFY( NERR_Success == NetApiBufferFree( *pbufptr ) );
                *pbufptr = NULL;
            }

            break;
        }

        // To simplify buffer access...
        PSERVER_INFO_100 pServerInfo100 = PSERVER_INFO_100( *pbufptr );

        // Reserve enough space for all the entries
        dcList.reserve( dwEntriesRead );

        //
        // Create a list of Servers
        //
        for( dwInd = 0;  dwInd < dwEntriesRead;  dwInd++ )
        {
            if( pszKnownServer &&
                !_wcsicmp( pszKnownServer, pServerInfo100[dwInd].sv100_name ) )
            {
                dwIndKnownServer = dwInd;     // postpone until the end
            }
            else
            {
                dcList.push_back( pServerInfo100[dwInd].sv100_name );
            }
        }

        ASSERT( dwEntriesRead );

        //
        // Known server should go to the end of the list
        //
        if( MAXDWORD != dwIndKnownServer )
        {
            TRACE(L"Server %s placed @ the end\n", pszKnownServer);

            dcList.push_back( pServerInfo100[dwIndKnownServer].sv100_name );

            // Shuffling should not include the last entry
            dwEntriesRead--;
        }

        //
        // Initialize randomizer
        //
        srand( (unsigned) time( NULL ) );

        //
        // Shuffle by replacing each entry with another random entry
        //
        for( dwInd = 0;  dwInd < (int) dwEntriesRead;  dwInd++ )
        {
            DWORD  dwRandPos = DWORD( rand() % dwEntriesRead );

            if( dwRandPos == dwInd )
                continue;
                
            // Swap!
            LPWSTR     pstrTemp = dcList[ dwRandPos ];
            dcList[ dwRandPos ] = dcList[ dwInd ];
            dcList[ dwInd ]     = pstrTemp;
        }

    } while( FALSE );

    return netStatus;
}


//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::ForceRediscover
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
NET_API_STATUS
CTrustInfo::ForceRediscover(PCWSTR pstrDCName, CString * pstrDCNameRet)
{
    TRACE(L"CTrustInfo::ForceRediscover\n");

    NET_API_STATUS    netStatus       = NERR_Success;
    NETLOGON_INFO_2 * pNetlogonInfo2  = NULL;
    CString           strTemp;
    PCWSTR pstrDomainName = GetTrustedDomain();

    if( pstrDCName )
    {
        //
        // Form domain\dc request
        //
        strTemp = pstrDomainName;
        strTemp += L"\\";
        strTemp += pstrDCName;

        // Retarget pstrDomainName to the new string
        pstrDomainName = strTemp;
    }
    
    //
    // Attempt to re-establish trust
    //
    netStatus = I_NetLogonControl2( NULL,
                                    NETLOGON_CONTROL_REDISCOVER,
                                    2,
                                    ( LPBYTE )  &pstrDomainName,
                                    ( LPBYTE *) &pNetlogonInfo2 );

    TRACE(L"I_NetLogonControl2:NETLOGON_CONTROL_REDISCOVER to %s returned 0x%08x\n",
          pstrDomainName, netStatus);
    //
    // Clean-up
    //
    if( pNetlogonInfo2 )
    {
        *pstrDCNameRet = pNetlogonInfo2->netlog2_trusted_dc_name;
        TRACE(L"netlog2_flags=0x%08x, netlog2_pdc_connection_status=0x%08x\n",
              pNetlogonInfo2->netlog2_flags,
              pNetlogonInfo2->netlog2_pdc_connection_status);

        TRACE(L"netlog2_trusted_dc_name=%s, netlog2_tc_connection_status=0x%08x\n",
              pNetlogonInfo2->netlog2_trusted_dc_name,
              pNetlogonInfo2->netlog2_tc_connection_status);

        NetApiBufferFree( pNetlogonInfo2 );
    }

    return netStatus;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustInfo::SetTrustStatus
//
//  Synopsis:  Set the status string based on the netStatus value if an error
//             else based on the VerifyStatus.
//
//-----------------------------------------------------------------------------
void
CTrustInfo::SetTrustStatus(ULONG netStatus, VerifyStatus Status)
{
   WCHAR wzBuf[512];

   m_trustStatus = netStatus;
   m_VerifyStatus = Status;

   if (NERR_Success == netStatus)
   {
      int nStrID;

      switch (Status)
      {
      case VerifyStatusNone:
         //
         // This is the default value for the Status parameter.
         //
      case VerifyStatusTrustOK:
         nStrID = IDS_TRUST_STATUS_OK;
         break;

      case VerifyStatusNotWindowsTrust:
         nStrID = IDS_MIT_TRUST_STATUS;
         break;

      case VerifyStatusNotOutboundTrust:
         nStrID = IDS_STATUS_INBOUND_ONLY;
         break;

      case VerifyStatusTrustNotChecked:
         nStrID = IDS_STATUS_NOT_CHECKED;
         break;

      case VerifyStatusPwCheckNotSupported:
         nStrID = IDS_PW_VERIFY_NOT_SUPPORTED;
         break;

      case VerifyStatusRetarget:
         nStrID = IDS_FIXED_BY_RETARGET;
         break;

      case VerifyStatusRediscover:
         nStrID = IDS_STATUS_REDISCOVER;
         break;

      case VerifyStatusBroken:
         ASSERT(FALSE); // shouldn't get here, fall through.
      default:
         nStrID = IDS_STATUS_UNKNOWN;
      }

      LoadString(_Module.GetModuleInstance(), nStrID, wzBuf, 512);
      m_strTrustStatus = wzBuf;
   }
   else
   {
      PWSTR pwzMsg;

      if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        netStatus,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PWSTR)&pwzMsg,
                        0,
                        NULL))
      {
         PWSTR pwzSuffix = wcsstr(pwzMsg, L"\r\n");
         if (pwzSuffix)
         {
            *pwzSuffix = L'\0';
         }
         m_strTrustStatus = pwzMsg;
         LocalFree(pwzMsg);
      }
      else
      {
         LoadString(_Module.GetModuleInstance(), IDS_TRUST_STATUS_FAILED, wzBuf, 512);
         m_strTrustStatus = wzBuf;
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method: CTrustInfo::SetTrustDirectionFromFlags
//
//-----------------------------------------------------------------------------
void
CTrustInfo::SetTrustDirectionFromFlags(ULONG ulFlags)
{
   m_ulTrustDirection = 0;

   if (DS_DOMAIN_DIRECT_OUTBOUND & ulFlags)
   {
      m_ulTrustDirection = TRUST_DIRECTION_OUTBOUND;
   }

   if (DS_DOMAIN_DIRECT_INBOUND & ulFlags)
   {
      m_ulTrustDirection |= TRUST_DIRECTION_INBOUND;
   }
}

//+----------------------------------------------------------------------------
//
//  Method: CTrustInfo::SetSid
//
//-----------------------------------------------------------------------------
BOOL
CTrustInfo::SetSid(PSID pSid)
{
   if (!pSid)
   {
      return TRUE;
   }

#if !defined(NT4_BUILD)
   PWSTR buffer;

   BOOL fRet = ConvertSidToStringSid(pSid, &buffer);

   if (fRet)
   {
      m_strSid = buffer;
      LocalFree(buffer);
   }

   return fRet;
#else
// TODO: Code for NT4 ??
#pragma message("need ConvertSidToStringSid for NT4");
#endif
}

#ifdef NT4_BUILD

//+----------------------------------------------------------------------------
//
//  Function:   ForceReplication
//
//  Synopsis:   Force local Domain Replication -- works only for NT4 domains
//
//-----------------------------------------------------------------------------
NET_API_STATUS ForceReplication(void)
{
    TRACE(L"ForceReplication\n");

    NET_API_STATUS    netStatus       = NERR_Success;

    LPBYTE            pbInputDataPtr  = NULL;
    PNETLOGON_INFO_1  pNetlogonInfo1  = NULL;

    netStatus = I_NetLogonControl2( NULL,
                                    NETLOGON_CONTROL_REPLICATE,
                                    1,
                                    (LPBYTE )  &pbInputDataPtr,
                                    (LPBYTE *) &pNetlogonInfo1 );

    TRACE(L"I_NetLogonControl2:NETLOGON_CONTROL_REPLICATE returned 0x%08x\n", netStatus);

    if( pNetlogonInfo1 )
    {
        TRACE(L"netlog1_flags=0x%08x, netlog1_pdc_connection_status=0x%08x\n",
              pNetlogonInfo1->netlog1_flags,
              pNetlogonInfo1->netlog1_pdc_connection_status);
    
        NetApiBufferFree( pNetlogonInfo1 );
    }

    return netStatus;
}

#endif //NT4_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\trustmon.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002
//
//  File:       trustmon.cpp
//
//  Contents:   Implementation of worker thread class and DLL Exports.
//
//  Classes:    CAsyncCallWorker
//
//  History:    22-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

CComModule _Module;

DEFINE_GUID(CLSID_TrustMonProvider,0x8065652F,0x4C29,0x4908,0xAA,0xE5,0x20,0x1C,0x89,0x19,0x04,0xC5);

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TrustMonProvider, CTrustPrv)
END_OBJECT_MAP()

WCHAR g_wzMofPath[] = L"\\system32\\wbem\\ADStatus\\TrustMon.mof";

//+----------------------------------------------------------------------------
//
//  Class: CAsyncCallWorker
//
//-----------------------------------------------------------------------------
CAsyncCallWorker::CAsyncCallWorker(CTrustPrv * pTrustPrv,
                                   HANDLE hToken,
                                   long lFlags,
                                   IWbemClassObject * pClassDef,
                                   IWbemObjectSink * pResponseHandler,
                                   LPWSTR pwzInstanceName) :
   _hToken(hToken),
   m_lFlags(lFlags),
   m_pwzInstanceName(pwzInstanceName)
{
   TRACE(L"CAsyncCallWorker::CAsyncCallWorker(0x%08x)\n", this);
   m_sipTrustPrv.p = pTrustPrv; pTrustPrv->AddRef(); // ATL CComPtr is broken!
   m_sipClassDef = pClassDef;
   m_sipResponseHandler = pResponseHandler;
}

CAsyncCallWorker::~CAsyncCallWorker()
{
   TRACE(L"CAsyncCallWorker::~CAsyncCallWorker\n\n");
   if (_hToken)
   {
      CloseHandle(_hToken);
   }
   if (m_pwzInstanceName)
   {
      delete m_pwzInstanceName;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CAsyncCallWorker::CreateInstEnum
//
//  Synopsis:   Provides the worker thread function for
//              IWbemServices::CreateInstanceEnumAsync
//
//-----------------------------------------------------------------------------
void __cdecl
CAsyncCallWorker::CreateInstEnum(PVOID pParam)
{
   TRACE(L"CAsyncCallWorker::CreateInstEnum\n");
   HRESULT hr = WBEM_S_NO_ERROR;
   DWORD dwWaitResult;
   CAsyncCallWorker * pWorker = (CAsyncCallWorker *)pParam;
   CDomainInfo * pDomain = &(pWorker->m_sipTrustPrv->m_DomainInfo);

   CoInitializeEx(NULL, COINIT_MULTITHREADED);

   do
   {
      BREAK_ON_NULL(pWorker);

      //
      // Try to get the mutex first without a wait. It is in the signalled state if
      // not owned.
      //
      dwWaitResult = WaitForSingleObject(pWorker->m_sipTrustPrv->m_hMutex, 0);

      if (WAIT_TIMEOUT == dwWaitResult)
      {
         // Mutex is owned by another thread. Rewait.

         dwWaitResult = WaitForSingleObject(pWorker->m_sipTrustPrv->m_hMutex,
                                            6000000); // timeout set to 10 minutes

         switch(dwWaitResult)
         {
         case WAIT_TIMEOUT:
            // mutex continues to be non-signalled (owned by another thread).
            hr = WBEM_E_SERVER_TOO_BUSY; // BUGBUG: returning an error.
                                         // BUGBUG: should the timeout be parameterized?
            break;

         case WAIT_OBJECT_0:
            // This thread now owns the mutex.
            break;

         case WAIT_ABANDONED: // this means the owning thread terminated without releasing the mutex.
            TRACE(L"Another thread didn't release the mutex!\n");
            break;
         }
      }

      BREAK_ON_FAIL;

      if (!SetThreadToken(NULL, pWorker->_hToken))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         TRACE(L"CAsyncCallWorker::CreateInstEnum SetThreadToken failed with error %d\n",
               hr);
         BREAK_ON_FAIL;
      }

      //
      // Re-read all the trust information if stale.
      // The trust list is not re-enumerated on every call because trusts are
      // rarely modified.
      //
      if (pDomain->IsTrustListStale(pWorker->m_sipTrustPrv->m_liTrustEnumMaxAge))
      {
         hr = pDomain->EnumerateTrusts();

         BREAK_ON_FAIL;
      }

      size_t cTrusts = pDomain->Size();

      for (size_t i = 0; i < cTrusts; i++)
      {
         if ((long)WBEM_FLAG_SEND_STATUS & pWorker->m_lFlags)
         {
            hr = pWorker->m_sipResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, 
                                                          MAKELONG(i, cTrusts),
                                                          NULL, NULL);
            BREAK_ON_FAIL;
         }

         CTrustInfo * pTrust;

         //
         // Get trust Info
         //
         pTrust = pDomain->GetTrustByIndex(i);

         BREAK_ON_NULL_(pTrust, hr, WBEM_E_INVALID_OBJECT_PATH);

         //
         // Verify the trust if stale.
         //
         if (pTrust->IsVerificationStale(pWorker->m_sipTrustPrv->m_liVerifyMaxAge))
         {
            pTrust->Verify(pWorker->m_sipTrustPrv->GetTrustCheckLevel());
         }

         CoRevertToSelf();

         //
         // Create a new instance of the object if the trust is outbound or if
         // return-all is true.
         //
         if (pTrust->IsTrustOutbound() || pWorker->m_sipTrustPrv->GetReturnAll())
         {
            hr = CreateAndSendTrustInst(*pTrust, pWorker->m_sipClassDef,
                                        pWorker->m_sipResponseHandler);
         }

         BREAK_ON_FAIL;

         if (!SetThreadToken(NULL, pWorker->_hToken))
         {
            hr = HRESULT_FROM_WIN32(GetLastError());
            TRACE(L"CAsyncCallWorker::CreateInstEnum second SetThreadToken failed with error %d\n",
                  hr);
            BREAK_ON_FAIL;
         }
      }

   } while (FALSE);

   CoRevertToSelf();

   //
   // Set status
   //
   pWorker->m_sipResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

   ReleaseMutex(pWorker->m_sipTrustPrv->m_hMutex);

   delete pWorker;

   CoUninitialize();

   _endthread();
}

//+----------------------------------------------------------------------------
//
//  Method:     CAsyncCallWorker::GetObj
//
//  Synopsis:   Provides the worker thread function for
//              IWbemServices::GetObjectAsync
//
//-----------------------------------------------------------------------------
/* unused
void __cdecl
CAsyncCallWorker::GetObj(PVOID pParam)
{
    TRACE(L"CAsyncCallWorker::GetObj\n");
    HRESULT hr = WBEM_S_NO_ERROR;
    CAsyncCallWorker * pWorker = (CAsyncCallWorker *)pParam;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    //CoImpersonateClient();

    do
    {

    } while (FALSE);

    CoRevertToSelf();

    //
    // Set status
    //
    pWorker->m_sipResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

    delete pWorker;

    CoUninitialize();

    _endthread();
}
*/

//+----------------------------------------------------------------------------
//
//  Function:   CreateAndSendTrustInst
//
//  Purpose:    Creates a new instance and sets the inital values of the
//              properties.
//
//-----------------------------------------------------------------------------
HRESULT
CreateAndSendTrustInst(CTrustInfo & Trust, IWbemClassObject * pClassDef,
                       IWbemObjectSink * pResponseHandler)
{
   TRACE(L"CreateAndSendTrustInst\n");
   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      CComPtr<IWbemClassObject> ipNewInst;
      CComVariant var;

      //
      // Create a new instance of the WMI class object
      //
      hr = pClassDef->SpawnInstance(0, &ipNewInst);
      BREAK_ON_FAIL;
      
      // Set the key property value (TrustedDomain)
      var = Trust.GetTrustedDomain();
      hr  = ipNewInst->Put(CSTR_PROP_TRUSTED_DOMAIN, 0, &var, 0);
      TRACE(L"\tCreating instance %s\n", var.bstrVal);
      BREAK_ON_FAIL;
       //Flat Name
      var = Trust.GetFlatName();
      hr  = ipNewInst->Put(CSTR_PROP_FLAT_NAME, 0, &var, 0);
      BREAK_ON_FAIL;
      //Sid
      var = Trust.GetSid();
      hr  = ipNewInst->Put(CSTR_PROP_SID, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trust Direction
      var = (long)Trust.GetTrustDirection();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_DIRECTION, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trust Type
      var = (long)Trust.GetTrustType();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_TYPE, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trust Attributes
      var = (long)Trust.GetTrustAttributes();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_ATTRIBUTES, 0, &var, 0);
      BREAK_ON_FAIL;
      // Set the TrustStatus value.
      var = (long)Trust.GetTrustStatus();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_STATUS, 0, &var, 0);
      BREAK_ON_FAIL;
      var = Trust.GetTrustStatusString();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_STATUS_STRING, 0, &var, 0);
      BREAK_ON_FAIL;
      // Set the Trust Is OK value.
      var = Trust.IsTrustOK();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_IS_OK, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trusted DC Name
      var = Trust.GetTrustedDCName();
      hr  = ipNewInst->Put(CSTR_PROP_TRUSTED_DC_NAME, 0, &var, 0);
      BREAK_ON_FAIL;

      //
      // Send the object to the caller
      //
      // [In] param, no need to addref.
      IWbemClassObject * pNewInstance = ipNewInst;
      hr = pResponseHandler->Indicate(1, &pNewInstance);

      BREAK_ON_FAIL;

   } while(FALSE);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:  DllMain
//
//  Purpose:   DLL Entry Point
//
//-----------------------------------------------------------------------------
extern "C" BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      _Module.Init(ObjectMap, hInstance);
      DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
       _Module.Term();
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:  DllCanUnloadNow
//
//  Purpose:   Used to determine whether the DLL can be unloaded by OLE
//
//-----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:  DllGetClassObject
//
//  Purpose:   Returns a class factory to create an object of the requested type
//
//-----------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}

//+----------------------------------------------------------------------------
//
//  Function:  DllRegisterServer
//
//  Purpose:   Adds Class entries to the system registry
//
//-----------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
   // Add TrustMon to the registry as an event source.
   //
   HKEY hk; 
   DWORD dwData; 
   WCHAR wzFilePath[2*MAX_PATH+1] = {0};

   GetModuleFileName(_Module.GetModuleInstance(), wzFilePath, 2*MAX_PATH);

   if (RegCreateKey(HKEY_LOCAL_MACHINE, 
                    L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" TM_PROV_NAME,
                    &hk))
   {
      TRACE(L"Could not create the registry key.");
   }
   else
   {
      // Set the name of the message file.
      //
      TRACE(L"Adding path %s to the registry\n", wzFilePath);

      // Add the name to the EventMessageFile subkey.

      if (RegSetValueEx(hk,
                        L"EventMessageFile",
                        0,
                        REG_EXPAND_SZ,
                        (LPBYTE)wzFilePath,
                        (ULONG)(wcslen(wzFilePath) + 1) * sizeof(WCHAR)))
      {
         TRACE(L"Could not set the event message file.");
      }
      else
      {
         // Set the supported event types in the TypesSupported subkey.

         dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
                  EVENTLOG_INFORMATION_TYPE; 

         if (RegSetValueEx(hk,
                           L"TypesSupported",
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD)))
         {
            TRACE(L"Could not set the supported types.");
         }
      }

      RegCloseKey(hk);
   }

   // Add a RunOnce value to do the MOF compile.
   //
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
                    0,
                    KEY_WRITE,
                    &hk))
   {
      TRACE(L"Could not open the registry key.");
   }
   else
   {
      CString csCmd = L"rundll32.exe ";
      csCmd += wzFilePath;
      csCmd += L",DoMofComp";

      if (RegSetValueEx(hk,
                        L"TrustMon",
                        0,
                        REG_SZ,
                        (LPBYTE)csCmd.GetBuffer(0),
                        csCmd.GetLength() * sizeof(WCHAR)))
      {
         TRACE(L"Could not set the runonce value.");
      }

      RegCloseKey(hk);
   }

   return _Module.RegisterServer();
}

//+----------------------------------------------------------------------------
//
//  Function:  DllUnregisterServer
//
//  Purpose:   Removes Class entries from the system registry
//
//-----------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
   return _Module.UnregisterServer();
}

//+----------------------------------------------------------------------------
//
//  Function:  DoMofComp
//
//  Purpose:   Adds the provider classes to the WMI repository. Note that the
//             function signature is that required by rundll32.exe.
//
//-----------------------------------------------------------------------------
VOID WINAPI DoMofComp(HWND hWndParent,
                      HINSTANCE hModule,
                      PCTSTR ptzCommandLine,
                      INT nShowCmd)
{
   TRACE(L"DoMofComp\n");
   UNREFERENCED_PARAMETER(hWndParent);
   UNREFERENCED_PARAMETER(hModule);
   UNREFERENCED_PARAMETER(ptzCommandLine);
   UNREFERENCED_PARAMETER(nShowCmd);
   HRESULT hr;
   CComPtr<IMofCompiler> pmc;

   CoInitialize(NULL);

   hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,
                         IID_IMofCompiler, (PVOID *)&pmc);

   CHECK_HRESULT(hr, return);

   WCHAR wzFilePath[2*MAX_PATH];
   UINT nLen = GetSystemWindowsDirectory(wzFilePath, 2*MAX_PATH);
   if (nLen == 0)
   {
      ASSERT(FALSE);
      return;
   }

   CString csMofPath = wzFilePath;

   csMofPath += g_wzMofPath;

   WBEM_COMPILE_STATUS_INFO Info;

   TRACE(L"Compiling MOF file %s\n", csMofPath.GetBuffer(0));

   hr = pmc->CompileFile(csMofPath.GetBuffer(0), NULL, NULL, NULL, NULL,
                         WBEM_FLAG_AUTORECOVER, 0, 0, &Info);

   HANDLE hEvent = RegisterEventSource(NULL, TM_PROV_NAME);

   if (!hEvent)
   {
      TRACE(L"RegisterEventSource failed with error  %d\n", GetLastError());
      return;
   }

   if (WBEM_S_NO_ERROR != hr)
   {
      TRACE(L"MofCompile failed with error 0x%08x (WMI error 0x%08x), line: %d, phase: %d\n",
            hr, Info.hRes, Info.FirstLine, Info.lPhaseError);
      //
      // Send failure to EventLog.
      //
      CString csHr, csLine;
      HMODULE hm = LoadLibrary(L"mofd.dll");

      if (hm)
      {
         WCHAR wzBuf[MAX_PATH];
         LoadString(hm, Info.hRes, wzBuf, MAX_PATH);
         csHr = wzBuf;
         FreeLibrary(hm);
      }
      else
      {
         csHr.Format(L"%d", Info.hRes);
      }

      csLine.Format(L"%d", Info.FirstLine);
      const PWSTR rgArgs[3] = {csHr.GetBuffer(0), csLine.GetBuffer(0), csMofPath.GetBuffer(0)};

      ReportEvent(hEvent,
                  EVENTLOG_ERROR_TYPE,
                  0,                       // wCategory
                  TRUSTMON_MOFCOMP_FAILED, // dwEventID
                  NULL,                    // lpUserSID
                  3,                       // wNumStrings
                  0,                       // dwDataSize
                  (PCWSTR *)rgArgs,        // lpStrings
                  NULL);                   // lpRawData
   }
   else
   {
      // Send success notice to EventLog.
      //
      ReportEvent(hEvent,
                  EVENTLOG_INFORMATION_TYPE,
                  0,                        // wCategory
                  TRUSTMON_MOFCOMP_SUCCESS, // dwEventID
                  NULL,                     // lpUserSID
                  0,                        // wNumStrings
                  0,                        // dwDataSize
                  NULL,                     // lpStrings
                  NULL);                    // lpRawData
   }

   DeregisterEventSource(hEvent);

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiprov\trustmon\trust.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.h
//
//  Contents:   Trust class definition
//
//  Classes:    CTrustInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef TRUSTINF_H
#define TRUSTINF_H

extern PCWSTR CSTR_PROP_TRUSTED_DOMAIN;
extern PCWSTR CSTR_PROP_FLAT_NAME;
extern PCWSTR CSTR_PROP_SID;
extern PCWSTR CSTR_PROP_TRUST_DIRECTION;
extern PCWSTR CSTR_PROP_TRUST_TYPE;
extern PCWSTR CSTR_PROP_TRUST_ATTRIBUTES;
extern PCWSTR CSTR_PROP_TRUST_STATUS;     // uint32
extern PCWSTR CSTR_PROP_TRUST_STATUS_STRING;
extern PCWSTR CSTR_PROP_TRUST_IS_OK;      // Boolean
extern PCWSTR CSTR_PROP_TRUSTED_DC_NAME;

enum VerifyStatus
{
   VerifyStatusNone = 0,
   VerifyStatusBroken,
   VerifyStatusTrustOK,
   VerifyStatusRediscover,
   VerifyStatusRetarget,
   VerifyStatusNotWindowsTrust,
   VerifyStatusNotOutboundTrust,
   VerifyStatusTrustNotChecked,
   VerifyStatusPwCheckNotSupported
};

class CDomainInfo; // forward declaration
enum TrustCheckLevel; // ditto

//+----------------------------------------------------------------------------
//
//  class CTrustInfo
//
//  Each instance contains information about one trust
//
//-----------------------------------------------------------------------------
class CTrustInfo
{
public:
   CTrustInfo();
   ~CTrustInfo() {};

friend class CDomainInfo;

   BOOL Verify(TrustCheckLevel CheckLevel);
   //Get List of All the DC for the Domain
   DWORD GetDCList(PCWSTR pszKnownServer, vector<LPWSTR> & dcList, LPBYTE * pbufptr);
   // Rediscover the Trust
   DWORD ForceRediscover(PCWSTR pstrDCName, CString * strDCName);

   //Funtion to Get/Set Private Members
   void   SetTrustedDomain(LPWSTR pszTrustedDomain) {m_strTrustedDomainName = (LPCWSTR)pszTrustedDomain;}
   PCWSTR GetTrustedDomain() {return m_strTrustedDomainName;}
   void   SetFlatName(LPWSTR pszFlatName) {m_strFlatName = pszFlatName;}
   PCWSTR GetFlatName() {return m_strFlatName;}
   BOOL   SetSid(PSID pSid);
   PCWSTR GetSid(void) {return m_strSid;}
   void   SetTrustDirection(ULONG ulDir) {m_ulTrustDirection = ulDir;}
   ULONG  GetTrustDirection(void) {return m_ulTrustDirection;}
   void   SetTrustType(ULONG ulTrustType) {m_ulTrustType = ulTrustType;}
   ULONG  GetTrustType(void) {return m_ulTrustType;}
   void   SetTrustAttributes(ULONG ulTrustAttributes) {m_ulTrustAttributes = ulTrustAttributes;}
   ULONG  GetTrustAttributes(void) {return m_ulTrustAttributes;}
   void   SetTrustedDCName(LPWSTR strTrustedDCName) {m_strTrustedDCName = strTrustedDCName;}
   PCWSTR GetTrustedDCName(void) {return m_strTrustedDCName;}
   void   SetTrustStatus(ULONG netStatus, VerifyStatus Status = VerifyStatusNone);
   ULONG  GetTrustStatus(void) {return m_trustStatus;}
   PCWSTR GetTrustStatusString(void) {return m_strTrustStatus;}
   ULONG  GetFlags(void) {return m_ulFlags;}
   void   SetFlags(ULONG ulFlags) {m_ulFlags = ulFlags;}
   bool   IsTrustOK(void) {return (ERROR_SUCCESS == m_trustStatus);}

   BOOL   IsVerificationStale(LARGE_INTEGER liMaxVerifyAge);
   BOOL   IsTrustOutbound(void) {return m_ulTrustDirection & TRUST_DIRECTION_OUTBOUND;}

protected:

   void   SetTrustDirectionFromFlags(ULONG ulFlags);
   void   SetLastVerifiedTime(void);

private:

   //Information about trust, for more info see Doc of TRUSTED_DOMAIN_INFORMATION_EX    
   CString       m_strTrustedDomainName; // name of the trusted domain
   CString       m_strFlatName;          // Netbios name of the trusted domain 
   CString       m_strSid;               // Sid of the trusted domian in string format
   ULONG         m_ulTrustDirection;     // indicate the direction of the trust
   ULONG         m_ulTrustType;          // Type of trust
   ULONG         m_ulTrustAttributes;    // Attributes of trust
   ULONG         m_ulFlags;              // DS_DOMAIN_TRUSTS Flags element

   CString       m_strTrustedDCName;     // Name of the DC with which trust is verified
   ULONG         m_trustStatus;          // Status of the trust; win32 error code
   CString       m_strTrustStatus;       // Status string.

   VerifyStatus  m_VerifyStatus;
   LARGE_INTEGER m_liLastVerified;
   BOOL          m_fPwVerifySupported;
};

#ifdef NT4_BUILD

DWORD ForceReplication(void);

#endif // NT4_BUILD

#endif //TRUSTINF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\columnmgrdlg.h ===
//-------------------------------------------------------------------------
// File: ColumnMgrDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK ColumnManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CColumnItem
{
	public:
		CColumnItem(LPCTSTR pcszName, LPCTSTR pcszPropertyName, bool bSelected=false);
		CColumnItem(const CColumnItem& colItem);

		bool IsSelected() { return m_bSelected; }
                bool IsPrevSelected() { return m_bPrevSelected;}
		void SetSelected(bool bValue) { m_bSelected = bValue; }
		void SetSelected(BOOL bValue) { bValue? m_bSelected = true : m_bSelected = false; }
                void SetPrevSelected(bool bvalue) { m_bPrevSelected = bvalue;}
		void SetName(LPCTSTR pcszName) { m_bstrName = pcszName; }
		LPCTSTR GetName() { return m_bstrName; }
		void SetPropertyName(LPCTSTR pcszPropertyName) { m_bstrPropertyName = pcszPropertyName; }
		LPCTSTR GetPropertyName() { return m_bstrPropertyName; }
		CColumnItem& operator=(const CColumnItem& colItem);

	protected:
		CComBSTR m_bstrName;
		CComBSTR m_bstrPropertyName;
		bool m_bSelected;
                bool m_bPrevSelected;
};

class CColumnManagerDlg
{
	public:
		CColumnManagerDlg(CSimpleArray<CColumnItem*> *pArrayColumns);
		~CColumnManagerDlg();
		INT_PTR CALLBACK ColumnManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP PopulateColumnsList();
		STDMETHODIMP AddColumnItemToList(CColumnItem* pszItem);
		STDMETHODIMP OnOK();

	protected:

		HWND m_hWnd;
		HWND m_hwndListView;
		CSimpleArray<CColumnItem*> *m_pArrayColumns;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\columnmgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: ColumnMgrDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "ColumnMgrDlg.h"

CColumnManagerDlg * g_pColumnManagerDlg =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK ColumnManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pColumnManagerDlg)
	{
		return g_pColumnManagerDlg->ColumnManagerDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CColumnManagerDlg::CColumnManagerDlg(CSimpleArray<CColumnItem*> *pArrayColumns)
{
	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pArrayColumns = pArrayColumns;
}

//-------------------------------------------------------------------------

CColumnManagerDlg::~CColumnManagerDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CColumnManagerDlg::ColumnManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();
				PopulateColumnsList();

				break;
			}

		case WM_DESTROY:
			{
				//DestroyDialog();
				break;
			}
		
		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDCANCEL:
					EndDialog(m_hWnd, IDCANCEL);
					return TRUE;

				case IDOK:
					OnOK();
					return TRUE;
					break;
				}

				break;
			}

		default:
			break;
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	
	NTDM_BEGIN_METHOD()

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_COLUMNS_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT|LVS_EX_CHECKBOXES);

	lvColumn.mask = LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::PopulateColumnsList()
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<m_pArrayColumns->GetSize(); i++)
	{
		AddColumnItemToList((*m_pArrayColumns)[i]);
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::AddColumnItemToList(CColumnItem* pszItem)
{
	HRESULT hr;
	LVITEM lvItem;
	long lIndex = 10000;
	static TCHAR test[20] = _T("cool");

	NTDM_BEGIN_METHOD()

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = (LPTSTR)pszItem->GetName();
	lvItem.lParam = (LPARAM)pszItem;

	lIndex = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lIndex);
	ListView_SetCheckState(m_hwndListView, lIndex, pszItem->IsSelected());

	NTDM_END_METHOD()

	// cleanup
	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::OnOK()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;
	BOOL bValue;

	NTDM_BEGIN_METHOD()

	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;
	
	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));
		bValue = ListView_GetCheckState(m_hwndListView, lCount);
		((CColumnItem *)lvItem.lParam)->SetSelected(bValue);
	}	
	
	NTDM_END_METHOD()

	if SUCCEEDED(hr)
		EndDialog(m_hWnd, IDOK);

	// cleanup
	return hr;
}


//---------------------------------------------------------------------------
// CColumnItem
//---------------------------------------------------------------------------

CColumnItem::CColumnItem(LPCTSTR pcszName, LPCTSTR pcszPropertyName, bool bSelected) 
{
	m_bstrName = pcszName;
	m_bstrPropertyName = pcszPropertyName;
	m_bSelected = bSelected;
	m_bPrevSelected = false;
}

//---------------------------------------------------------------------------

CColumnItem::CColumnItem(const CColumnItem& colItem)
{
	m_bstrName = colItem.m_bstrName;
	m_bstrPropertyName = colItem.m_bstrPropertyName;
	m_bSelected = colItem.m_bSelected;
}

//---------------------------------------------------------------------------

CColumnItem& CColumnItem::operator=(const CColumnItem& colItem) 
{ 
	if(this != &colItem)
	{
		m_bstrName = colItem.m_bstrName;
		m_bstrPropertyName = colItem.m_bstrPropertyName;
		m_bSelected = colItem.m_bSelected;
	}

	return *this;
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\defines.h ===
//-----------------------------------------------------------------------
// defines.h
//
// Author: Kishnan Nedungadi
//-----------------------------------------------------------------------

#ifndef __DEFINES_H
#define __DEFINES_H

#include <vector>
#include <list>

typedef std::vector<double> arrayDouble;
typedef std::vector<double>::iterator arrayDoubleIter;
typedef std::list<double> listDouble;
typedef std::list<double>::iterator listDoubleIter;

#define SZ_MAX_SIZE	256
#define MAX_LIST_ITEMS 100000

#define NTDM_BEGIN_METHOD() try {\
								hr = NOERROR;

#define NTDM_END_METHOD()		}\
							catch(...)\
								{\
									hr = E_UNEXPECTED;\
									goto error;\
								}\
							error:;

#define NTDM_ERR_IF_FAIL(stmt) if FAILED(hr = stmt)\
								{\
									CNTDMUtils::ErrorHandler(NULL, hr, FALSE);\
									;\
									goto error;\
								}

#define NTDM_ERR_MSG_IF_FAIL(stmt)	if FAILED(hr = stmt)\
									{\
										CNTDMUtils::ErrorHandler(m_hWnd, hr);\
										;\
										goto error;\
									}


#define NTDM_Hr(hrCode)		MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, hrCode)

#define NTDM_EXIT(hrVal)		{\
									hr = hrVal;\
									CNTDMUtils::ErrorHandler(NULL, hr, FALSE);\
									goto error;\
								}

#define NTDM_ERR_GETLASTERROR_IF_NULL(stmt) if(NULL == stmt)\
											{\
												hr = NTDM_Hr(GetLastError());\
												CNTDMUtils::ErrorHandler(m_hWnd, hr);\
												goto error;\
											}

#define NTDM_ERR_GETLASTERROR_IF_FALSE(stmt) if(FALSE == stmt)\
											{\
												hr = NTDM_Hr(GetLastError());\
												CNTDMUtils::ErrorHandler(m_hWnd, hr);\
												goto error;\
											}

#define NTDM_ERR_IF_NULL(stmt)	if(NULL == stmt)\
								{\
									hr = E_FAIL;\
									CNTDMUtils::ErrorHandler(m_hWnd, hr);\
									goto error;\
								}

#define NTDM_ERR_IF_MINUSONE(stmt)	if(-1 == stmt)\
									{\
										hr = E_FAIL;\
										CNTDMUtils::ErrorHandler(m_hWnd, hr);\
										goto error;\
									}


#define NTDM_ERRID_IF_NULL(stmt, err)	if(NULL == stmt)\
										{\
											hr = err;\
											CNTDMUtils::ErrorHandler(m_hWnd, hr);\
											goto error;\
										}

#define NTDM_ERR_IF_FALSE(stmt)	if(!stmt)\
								{\
									hr = E_FAIL;\
									CNTDMUtils::ErrorHandler(m_hWnd, hr);\
									goto error;\
								}

#define NTDM_DELETE_OBJECT(object)	if(object)\
									{\
										delete object;\
										object = NULL;\
									}

#define NTDM_RELEASE_IF_NOT_NULL(object)	if(object)\
											{\
												object->Release();\
											}

#define NTDM_CHECK_CB_ERR(stmt)	{\
									long ntdm_idx = stmt;\
									if(CB_ERR == ntdm_idx)\
									{\
										NTDM_EXIT(E_FAIL);\
									}\
									else if(CB_ERRSPACE == ntdm_idx)\
									{\
										NTDM_EXIT(E_OUTOFMEMORY);\
									}\
								}\

#define NTDM_FREE_BSTR(bstr)if(bstr)\
							{\
								SysFreeString(bstr);\
								bstr = NULL;\
							}


#define RGB_WHITE	0xffffff
#define RGB_BLACK	0x0
#define RGB_GLASS	0x8a8a8a
#define RGB_RED		0xff
#define RGB_BLUE	0xff0000


#define NOTEMPTY_BSTR_VARIANT(pvValue) (V_VT(pvValue)==VT_BSTR && V_BSTR(pvValue) && wcslen(V_BSTR(pvValue)))

#endif //__DEFINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\dlgfilterproperties.cpp ===
//-------------------------------------------------------------------------
// File: DlgFilterProperties.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "DlgFilterProperties.h"

CFilterPropertiesDlg * g_pFilterProperties =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK FilterPropertiesDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pFilterProperties)
	{
		return g_pFilterProperties->FilterPropertiesDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CFilterPropertiesDlg::CFilterPropertiesDlg(IWbemServices * pIWbemServices, IWbemClassObject * pIWbemClassObject)
{
	_ASSERT(pIWbemServices);
	_ASSERT(pIWbemClassObject);

	m_hWnd = NULL;
	m_hwndRulesListView = NULL;

	m_pIWbemServices = pIWbemServices;
	m_pIWbemServices->AddRef();

	m_pIWbemClassObject = pIWbemClassObject;
	m_pIWbemClassObject->AddRef();
}

//-------------------------------------------------------------------------

CFilterPropertiesDlg::~CFilterPropertiesDlg()
{
	NTDM_RELEASE_IF_NOT_NULL(m_pIWbemClassObject);
	NTDM_RELEASE_IF_NOT_NULL(m_pIWbemServices);
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CFilterPropertiesDlg::FilterPropertiesDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDOK:
				case IDCANCEL:
					EndDialog(m_hWnd, 0);
					return TRUE;
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	// Set all the properties
	ShowProperty(m_pIWbemClassObject, _T("Name"), IDC_NAME);
	ShowProperty(m_pIWbemClassObject, _T("Author"), IDC_AUTHOR);
	ShowProperty(m_pIWbemClassObject, _T("SourceOrganization"), IDC_SOURCE_ORGANIZATION);
	ShowProperty(m_pIWbemClassObject, _T("CreationDate"), IDC_CREATION_DATE);
	ShowProperty(m_pIWbemClassObject, _T("ChangeDate"), IDC_CHANGE_DATE);
	ShowProperty(m_pIWbemClassObject, _T("DsPath"), IDC_DSPATH);
	ShowProperty(m_pIWbemClassObject, _T("ID"), IDC_ID);

	//Initialize the ListView Control
	m_hwndRulesListView = GetDlgItem(m_hWnd, IDC_RULES);
	NTDM_ERR_IF_NULL(m_hwndRulesListView);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_QUERY);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndRulesListView, 0, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_QUERY_LANGUAGE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndRulesListView, 1, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_TARGET_NAMESPACE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndRulesListView, 2, &lvColumn));

	PopulateRulesList();

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndRulesListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndRulesListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndRulesListView, 2, LVSCW_AUTOSIZE_USEHEADER));

	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ClearRulesList();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::ClearRulesList()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndRulesListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndRulesListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndRulesListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::PopulateRulesList()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	SAFEARRAY *psaRules = NULL;
	long lLower, lUpper, i;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(m_pIWbemClassObject->Get(_T("Rules"), 0, &vValue, &vType, NULL));

	// Value should be an array
	if(V_VT(&vValue) != (VT_UNKNOWN | VT_ARRAY))
	{
		NTDM_EXIT(E_FAIL);
	}

	psaRules = V_ARRAY(&vValue);
	NTDM_ERR_IF_FAIL(SafeArrayGetUBound(psaRules, 1, &lUpper));
	NTDM_ERR_IF_FAIL(SafeArrayGetLBound(psaRules, 1, &lLower));

	for(i=lLower; i<=lUpper; i++)
	{
		IUnknown * pUnk = NULL;
		CComPtr<IWbemClassObject> pIRulesClassObject;

		NTDM_ERR_IF_FAIL(SafeArrayGetElement(psaRules, &i, (void *)&pUnk));
		NTDM_ERR_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIRulesClassObject));

		// Show Properties of this rule.
		NTDM_ERR_IF_FAIL(AddItemToList(pIRulesClassObject));
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::AddItemToList(IWbemClassObject * pIWbemClassObject)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("Query"), 0, &vValue, &vType, NULL));
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndRulesListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("QueryLanguage"), 0, &vValue, &vType, NULL));
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 1;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndRulesListView, &lvItem));

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("TargetNamespace"), 0, &vValue, &vType, NULL));
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 2;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndRulesListView, &lvItem));


	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::ShowProperty(IWbemClassObject * pIWbemClassObject, LPCTSTR pszPropertyName, long lResID)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(pszPropertyName, 0, &vValue, &vType, NULL));
	NTDM_ERR_IF_FAIL(VariantChangeType(&vValue, &vValue, VARIANT_ALPHABOOL|VARIANT_LOCALBOOL, VT_BSTR));

	SetDlgItemText(m_hWnd, lResID, (LPCTSTR)V_BSTR(&vValue));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\editpropertydlgs.h ===
//-------------------------------------------------------------------------
// File: EditPropertyDlgs.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

class CEditProperty
{
	public:
		CEditProperty(HWND hWndParent, LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices, long lSpecialCaseProperty=0);
		~CEditProperty();

		long Run();

		enum prop_special_cases
		{
			psc_rules = 0,
			psc_rule = 1,
			psc_ranges = 2,
			psc_range = 3
		};

	protected:
		
		HWND m_hWnd;
		VARIANT * pvSrcValue;
		CComBSTR m_bstrName;
		CComBSTR m_bstrType;
		CComPtr<IWbemServices>m_pIWbemServices;

		long m_lSpecialCaseProperty;
};

//-------------------------------------------------------------------------

class CEditPropertyDlg
{
	public:
		CEditPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue);
		~CEditPropertyDlg();

		CComVariant m_vValue;
	protected:
		
		virtual STDMETHODIMP InitializeDialog();
		virtual STDMETHODIMP DestroyDialog();

		HWND m_hWnd;
		VARIANT * pvSrcValue;
		CComBSTR m_bstrName;
		CComBSTR m_bstrType;
};

//-------------------------------------------------------------------------

class CEditStringPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditStringPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue);
		~CEditStringPropertyDlg();
		INT_PTR CALLBACK EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();


	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
};

//-------------------------------------------------------------------------

class CEditNumberPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditNumberPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue);
		~CEditNumberPropertyDlg();
		INT_PTR CALLBACK EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();


	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
};

//-------------------------------------------------------------------------

class CEditRulesPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditRulesPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices);
		~CEditRulesPropertyDlg();
		INT_PTR CALLBACK EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();
		STDMETHODIMP ClearItems();
		STDMETHODIMP PopulateItems();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP OnAdd();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();

		HWND m_hwndListView;
		CComPtr<IWbemServices>m_pIWbemServices;
};

//-------------------------------------------------------------------------

class CEditRulePropertyDlg
{
	public:
		CEditRulePropertyDlg(IWbemClassObject* pIWbemClassObject);
		~CEditRulePropertyDlg();

		INT_PTR CALLBACK EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();

		CComPtr<IWbemClassObject>m_pIWbemClassObject;

		HWND m_hWnd;
};

//-------------------------------------------------------------------------

class CEditRangeParametersPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditRangeParametersPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices);
		~CEditRangeParametersPropertyDlg();
		INT_PTR CALLBACK EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();
		STDMETHODIMP ClearItems();
		STDMETHODIMP PopulateItems();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP OnAdd();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();

		HWND m_hwndListView;
		CComPtr<IWbemServices>m_pIWbemServices;
};

//-------------------------------------------------------------------------

class CEditRangeParameterPropertyDlg
{
	public:
		CEditRangeParameterPropertyDlg(IWbemClassObject* pIWbemClassObject, IWbemServices* pIWbemServices);
		~CEditRangeParameterPropertyDlg();
		INT_PTR CALLBACK EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();
		STDMETHODIMP ClearItems();
		STDMETHODIMP PopulateItems();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP OnAdd();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();
		STDMETHODIMP GetSintRangeValues();
		STDMETHODIMP SetSintRangeValues();
		STDMETHODIMP GetUintRangeValues();
		STDMETHODIMP SetUintRangeValues();
		STDMETHODIMP GetRealRangeValues();
		STDMETHODIMP SetRealRangeValues();
		STDMETHODIMP GetSintSetValues();
		STDMETHODIMP SetSintSetValues();
		STDMETHODIMP GetUintSetValues();
		STDMETHODIMP SetUintSetValues();
		STDMETHODIMP GetStringSetValues();
		STDMETHODIMP SetStringSetValues();
		STDMETHODIMP SetRangeParamValues();

		enum range_types
		{
			rt_sintrange = 0,
			rt_uintrange = 1,
			rt_realrange = 2,
			rt_sintset = 3,
			rt_uintset = 4,
			rt_stringset = 5
		};

		CComVariant m_vValue;

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP ShowControls();

		HWND m_hwndListView;
		HWND m_hWnd;
		CComPtr<IWbemClassObject>m_pIWbemClassObject;
		CComPtr<IWbemServices>m_pIWbemServices;
};

//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\editpropertydlgs.cpp ===
//-------------------------------------------------------------------------
// File: EditPropertyDlgs.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "EditPropertyDlgs.h"


CEditStringPropertyDlg * g_pEditStringPropertyDlg =  NULL;
INT_PTR CALLBACK EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditNumberPropertyDlg * g_pEditNumberPropertyDlg =  NULL;
INT_PTR CALLBACK EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRulesPropertyDlg * g_pEditRulesPropertyDlg =  NULL;
INT_PTR CALLBACK EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRulePropertyDlg * g_pEditRulePropertyDlg =  NULL;
INT_PTR CALLBACK EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRangeParametersPropertyDlg * g_pEditRangeParametersPropertyDlg =  NULL;
INT_PTR CALLBACK EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRangeParameterPropertyDlg * g_pEditRangeParameterPropertyDlg =  NULL;
INT_PTR CALLBACK EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

//-------------------------------------------------------------------------
// CEditPropertyDlg
//-------------------------------------------------------------------------

CEditProperty::CEditProperty(HWND hWndParent, LPCTSTR pszName, LPCTSTR pszType, VARIANT *pvValue, IWbemServices *pIWbemServices, long lSpecialCaseProperty)
{
	_ASSERT(pvValue);

	m_hWnd = hWndParent;
	pvSrcValue = pvValue;
	m_bstrName = pszName;
	m_bstrType = pszType;
	m_lSpecialCaseProperty = lSpecialCaseProperty;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditProperty::~CEditProperty()
{
}


//---------------------------------------------------------------------------

long CEditProperty::Run()
{
	HRESULT hr;
	long lRetVal = IDCANCEL;
	VARIANT * pvTemp = NULL;
	long vtType;

	NTDM_BEGIN_METHOD()

	vtType = V_VT(pvSrcValue);

	if(VT_EMPTY == vtType || VT_NULL == vtType)
	{
		CNTDMUtils::GetVariantTypeFromString(m_bstrType, &vtType);
	}
	else if(m_lSpecialCaseProperty == psc_rule)
	{
		CComPtr<IWbemClassObject>pIWbemClassObject; 

		CEditRulePropertyDlg * pOld = g_pEditRulePropertyDlg;

		NTDM_ERR_MSG_IF_FAIL((V_UNKNOWN(pvSrcValue))->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));
		
		NTDM_ERR_IF_NULL((g_pEditRulePropertyDlg = new CEditRulePropertyDlg(pIWbemClassObject)));
		lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RULE), (HWND)m_hWnd, EditRulePropertyDlgProc);
		NTDM_DELETE_OBJECT(g_pEditRulePropertyDlg);
		g_pEditRulePropertyDlg = pOld;
	}
	else if(m_lSpecialCaseProperty == psc_range)
	{
		CComPtr<IWbemClassObject>pIWbemClassObject; 

		CEditRangeParameterPropertyDlg * pOld = g_pEditRangeParameterPropertyDlg;

		NTDM_ERR_MSG_IF_FAIL((V_UNKNOWN(pvSrcValue))->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));
		
		NTDM_ERR_IF_NULL((g_pEditRangeParameterPropertyDlg = new CEditRangeParameterPropertyDlg(pIWbemClassObject, m_pIWbemServices)));
		lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RANGE_PARAMETER), (HWND)m_hWnd, EditRangeParameterPropertyDlgProc);
		if(IDOK == lRetVal)
		{
			VariantClear(pvSrcValue);
			VariantCopy(pvSrcValue, &g_pEditRangeParameterPropertyDlg->m_vValue);
		}

		NTDM_DELETE_OBJECT(g_pEditRangeParameterPropertyDlg);
		g_pEditRangeParameterPropertyDlg = pOld;
	}
	else if(VT_BSTR == vtType)
	{
		// string
		CEditStringPropertyDlg * pOld = g_pEditStringPropertyDlg;

		NTDM_ERR_IF_NULL((g_pEditStringPropertyDlg = new CEditStringPropertyDlg(m_bstrName, m_bstrType, pvSrcValue)));
		lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_STRING_PROPERTY), (HWND)m_hWnd, EditStringPropertyDlgProc);
		if(IDOK == lRetVal)
		{
			VariantClear(pvSrcValue);
			VariantCopy(pvSrcValue, &g_pEditStringPropertyDlg->m_vValue);
		}

		NTDM_DELETE_OBJECT(g_pEditStringPropertyDlg);
		g_pEditStringPropertyDlg = pOld;
	}
	else if(VT_ARRAY & V_VT(pvSrcValue))
	{
		if(m_lSpecialCaseProperty == psc_rules)
		{
			// Rules
			CEditRulesPropertyDlg * pOld = g_pEditRulesPropertyDlg;

			NTDM_ERR_IF_NULL((g_pEditRulesPropertyDlg = new CEditRulesPropertyDlg(m_bstrName, m_bstrType, pvSrcValue, m_pIWbemServices)));
			
			lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RULES_PROPERTY), (HWND)m_hWnd, EditRulesPropertyDlgProc);
			if(IDOK == lRetVal)
			{
				VariantClear(pvSrcValue);
				VariantCopy(pvSrcValue, &g_pEditRulesPropertyDlg->m_vValue);
			}

			NTDM_DELETE_OBJECT(g_pEditRulesPropertyDlg);
			g_pEditRulesPropertyDlg = pOld;
		}
		else if(m_lSpecialCaseProperty == psc_ranges)
		{
			// Ranges
			CEditRangeParametersPropertyDlg * pOld = g_pEditRangeParametersPropertyDlg;

			NTDM_ERR_IF_NULL((g_pEditRangeParametersPropertyDlg = new CEditRangeParametersPropertyDlg(m_bstrName, m_bstrType, pvSrcValue, m_pIWbemServices)));
			lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RANGE_PARAMETERS_PROPERTY), (HWND)m_hWnd, EditRangeParametersPropertyDlgProc);
			if(IDOK == lRetVal)
			{
				VariantClear(pvSrcValue);
				VariantCopy(pvSrcValue, &g_pEditRangeParametersPropertyDlg->m_vValue);
			}

			NTDM_DELETE_OBJECT(g_pEditRangeParametersPropertyDlg);
			g_pEditRangeParametersPropertyDlg = pOld;
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return lRetVal;
}

//-------------------------------------------------------------------------
// CEditPropertyDlg
//-------------------------------------------------------------------------

CEditPropertyDlg::CEditPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue)
{
	_ASSERT(pvValue);

	m_hWnd = NULL;
	pvSrcValue = pvValue;
	m_vValue = *pvValue;
	m_bstrName = pszName;
	m_bstrType = pszType;
}

//-------------------------------------------------------------------------

CEditPropertyDlg::~CEditPropertyDlg()
{
}


//---------------------------------------------------------------------------

STDMETHODIMP CEditPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()

	SetDlgItemText(m_hWnd, IDC_NAME, m_bstrName);
	SetDlgItemText(m_hWnd, IDC_TYPE, m_bstrType);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------
// CEditStringPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditStringPropertyDlg)
	{
		return g_pEditStringPropertyDlg->EditStringPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditStringPropertyDlg::CEditStringPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
}

//-------------------------------------------------------------------------

CEditStringPropertyDlg::~CEditStringPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditStringPropertyDlg::EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditStringPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	// Set the string property
	SetDlgItemText(m_hWnd, IDC_VALUE, V_BSTR(&m_vValue));	

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditStringPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditStringPropertyDlg::OnOK()
{
	HRESULT hr;
	long lLength;
	TCHAR *pszTemp = NULL;

	NTDM_BEGIN_METHOD()

	lLength = GetWindowTextLength(GetDlgItem(m_hWnd, IDC_VALUE));
	if(lLength < 0)
	{
		NTDM_EXIT(E_FAIL);
	}
	else if(0 == lLength)
	{
		m_vValue = _T("");
	}
	else
	{
		pszTemp = new TCHAR[lLength+1];
		if(!pszTemp)
		{
			NTDM_EXIT(E_OUTOFMEMORY);
		}

		NTDM_ERR_GETLASTERROR_IF_NULL(GetDlgItemText(m_hWnd, IDC_VALUE, pszTemp, lLength+1));

		m_vValue = pszTemp;

		NTDM_DELETE_OBJECT(pszTemp);
	}


	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup

	NTDM_DELETE_OBJECT(pszTemp);

	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditNumberPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditNumberPropertyDlg)
	{
		return g_pEditNumberPropertyDlg->EditNumberPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditNumberPropertyDlg::CEditNumberPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
}

//-------------------------------------------------------------------------

CEditNumberPropertyDlg::~CEditNumberPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditNumberPropertyDlg::EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditNumberPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	// Set the number property
	NTDM_ERR_GETLASTERROR_IF_NULL(SetDlgItemInt(m_hWnd, IDC_VALUE, V_I4(&m_vValue), FALSE));	

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditNumberPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditNumberPropertyDlg::OnOK()
{
	HRESULT hr;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	lValue = GetDlgItemInt(m_hWnd, IDC_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);

	m_vValue = lValue;

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRulesPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRulesPropertyDlg)
	{
		return g_pEditRulesPropertyDlg->EditRulesPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRulesPropertyDlg::CEditRulesPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditRulesPropertyDlg::~CEditRulesPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRulesPropertyDlg::EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_ADD == LOWORD(wParam))
				{
					OnAdd();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_FILTER_ELEMENTS_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;

	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	m_hwndListView = GetDlgItem(m_hWnd, IDC_FILTER_ELEMENTS_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	
	NTDM_ERR_IF_FAIL(PopulateItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::ClearItems()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::PopulateItems()
{
	HRESULT hr;
	CComVariant vValue;
	SAFEARRAY *psaRules = NULL;
	long lLower, lUpper, i;
	
	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());
	
	// Set the Rules property
	psaRules = V_ARRAY(&m_vValue);
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetUBound(psaRules, 1, &lUpper));
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetLBound(psaRules, 1, &lLower));

	for(i=lLower; i<=lUpper; i++)
	{
		if(V_VT(&m_vValue) & VT_UNKNOWN)
		{
			// Rules or UNKNOWNS (i.e. IWbemClassObjects)
			IUnknown * pUnk = NULL;
			CComPtr<IWbemClassObject> pIWbemClassObject;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayGetElement(psaRules, &i, (void *)&pUnk));
			NTDM_ERR_MSG_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));

			// Show Properties of this object
			NTDM_ERR_IF_FAIL(AddItemToList(pIWbemClassObject));
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Query"), 0, &vValue, &cimType, NULL));
	lvItem.iItem = lIndex;
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();
	NTDM_ERR_IF_FAIL(ClearItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RULE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			VARIANT vValue;
			VariantInit(&vValue);
			IWbemClassObject *pIWbemClassObject;

			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;

			V_VT(&vValue) = VT_UNKNOWN;
			pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
			
			CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_rule);
			if(IDOK == editProp.Run())
			{
				ListView_DeleteItem(m_hwndListView, lSelectionMark);
				AddItemToList(pIWbemClassObject, lSelectionMark);

				pIWbemClassObject->Release();
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnAdd()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	VARIANT vValue;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_Rule");

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	VariantInit(&vValue);
	V_VT(&vValue) = VT_UNKNOWN;
	pIWbemNewInstance->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
			
	CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_rule);
	if(IDOK == editProp.Run())
	{
		AddItemToList(pIWbemNewInstance);
	}

	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RULE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			IWbemClassObject *pIWbemClassObject = NULL;
			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			pIWbemClassObject->Release();

			ListView_DeleteItem(m_hwndListView, lSelectionMark);
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnOK()
{
	HRESULT hr;
	VARIANT vValue;
	SAFEARRAY *psaRules = NULL;
	long lCount = 0;
	SAFEARRAYBOUND rgsaBound[1];
	long rgIndices[1];
	long i;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	// Get the size of the array
	lCount = ListView_GetItemCount(m_hwndListView);

	rgsaBound[0].lLbound = 0;
	rgsaBound[0].cElements = lCount;

	psaRules = SafeArrayCreate(VT_UNKNOWN, 1, rgsaBound);
	
	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	i=0;
	while(i < lCount)
	{
		IUnknown * pUnk = NULL;

		lvItem.iItem = i;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			NTDM_ERR_MSG_IF_FAIL(((IWbemClassObject *)lvItem.lParam)->QueryInterface(IID_IUnknown, (void**)&pUnk));

			rgIndices[0] = i;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayPutElement(psaRules, rgIndices, pUnk));

			pUnk->Release();
		}

		i++;
	}

	VariantClear(&vValue);
	V_VT(&vValue) = VT_ARRAY|VT_UNKNOWN;
	V_ARRAY(&vValue) = psaRules;

	m_vValue.Clear();
	m_vValue.Copy(&vValue);

	//m_vValue = vValue;

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup

	VariantClear(&vValue);

	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRulePropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRulePropertyDlg)
	{
		return g_pEditRulePropertyDlg->EditRulePropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRulePropertyDlg::CEditRulePropertyDlg(IWbemClassObject* pIWbemClassObject)
{
	m_pIWbemClassObject = pIWbemClassObject;
}

//-------------------------------------------------------------------------

CEditRulePropertyDlg::~CEditRulePropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRulePropertyDlg::EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulePropertyDlg::InitializeDialog()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("QueryLanguage"), 0, &vValue, &cimType, NULL));

	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_QUERY_LANGUAGE, vValue.bstrVal);
	}

	vValue.Clear();
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("TargetNamespace"), 0, &vValue, &cimType, NULL));

	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_TARGET_NAMESPACE, vValue.bstrVal);
	}
	
	vValue.Clear();

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Query"), 0, &vValue, &cimType, NULL));

	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_QUERY, vValue.bstrVal);
	}
	
	vValue.Clear();


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulePropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulePropertyDlg::OnOK()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	// Set the Properties
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("QueryLanguage"), m_hWnd, IDC_QUERY_LANGUAGE));
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("TargetNamespace"), m_hWnd, IDC_TARGET_NAMESPACE));
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("Query"), m_hWnd, IDC_QUERY));
	
	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRangeParametersPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRangeParametersPropertyDlg)
	{
		return g_pEditRangeParametersPropertyDlg->EditRangeParametersPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRangeParametersPropertyDlg::CEditRangeParametersPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditRangeParametersPropertyDlg::~CEditRangeParametersPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRangeParametersPropertyDlg::EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_ADD == LOWORD(wParam))
				{
					OnAdd();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_RANGE_PARAMETER_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;

	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	m_hwndListView = GetDlgItem(m_hWnd, IDC_RANGE_PARAMETER_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	
	NTDM_ERR_IF_FAIL(PopulateItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::ClearItems()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::PopulateItems()
{
	HRESULT hr;
	CComVariant vValue;
	SAFEARRAY *psaRangeParameters = NULL;
	long lLower, lUpper, i;
	
	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());
	
	// Set the RangeParameters property
	psaRangeParameters = V_ARRAY(&m_vValue);
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetUBound(psaRangeParameters, 1, &lUpper));
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetLBound(psaRangeParameters, 1, &lLower));

	for(i=lLower; i<=lUpper; i++)
	{
		if(V_VT(&m_vValue) & VT_UNKNOWN)
		{
			// RangeParameters or UNKNOWNS (i.e. IWbemClassObjects)
			IUnknown * pUnk = NULL;
			CComPtr<IWbemClassObject> pIWbemClassObject;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayGetElement(psaRangeParameters, &i, (void *)&pUnk));
			NTDM_ERR_MSG_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));

			// Show Properties of this object
			NTDM_ERR_IF_FAIL(AddItemToList(pIWbemClassObject));
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("PropertyName"), 0, &vValue, &cimType, NULL));
	lvItem.iItem = lIndex;
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();
	NTDM_ERR_IF_FAIL(ClearItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;
	VARIANT vValue;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RANGE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			IWbemClassObject *pIWbemClassObject;

			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;

			V_VT(&vValue) = VT_UNKNOWN;
			pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
			
			CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_range);
			if(IDOK == editProp.Run())
			{
				NTDM_ERR_IF_FAIL(V_UNKNOWN(&vValue)->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));
				ListView_DeleteItem(m_hwndListView, lSelectionMark);
				AddItemToList(pIWbemClassObject, lSelectionMark);

				pIWbemClassObject->Release();
			}

		}
	}


	NTDM_END_METHOD()

	// cleanup
	VariantClear(&vValue);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnAdd()
{
	HRESULT hr;
	long lSelectionMark;
	VARIANT vValue;
	VARIANT vValue2;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemInstanceObject;
	CComBSTR bstrTemp;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	bstrTemp = _T("MSFT_SintRangeParam");

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemInstanceObject));

	// Set some default values
	cimType = CIM_SINT32;
	VariantInit(&vValue2);
	V_VT(&vValue2) = VT_I4;
	V_I4(&vValue2) = 5;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("Default"), 0, &vValue2, cimType));
	V_I4(&vValue2) = 0;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("Min"), 0, &vValue2, cimType));
	V_I4(&vValue2) = 10;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("Max"), 0, &vValue2, cimType));

	cimType = CIM_UINT8;
	V_VT(&vValue2) = VT_UI1;
	V_UI1(&vValue2) = 0;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("TargetType"), 0, &vValue2, cimType));

	V_VT(&vValue) = VT_UNKNOWN;
	pIWbemInstanceObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
	
	CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_range);
	if(IDOK == editProp.Run())
	{
		NTDM_ERR_IF_FAIL(V_UNKNOWN(&vValue)->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemInstanceObject));
		AddItemToList(pIWbemInstanceObject);
	}

	NTDM_END_METHOD()

	// cleanup
	VariantClear(&vValue);
	VariantClear(&vValue2);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RULE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			IWbemClassObject *pIWbemClassObject = NULL;
			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			pIWbemClassObject->Release();

			ListView_DeleteItem(m_hwndListView, lSelectionMark);
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnOK()
{
	HRESULT hr;
	VARIANT vValue;
	SAFEARRAY *psaRangeParameters = NULL;
	long lCount = 0;
	SAFEARRAYBOUND rgsaBound[1];
	long rgIndices[1];
	long i;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	// Get the size of the array
	lCount = ListView_GetItemCount(m_hwndListView);

	rgsaBound[0].lLbound = 0;
	rgsaBound[0].cElements = lCount;

	psaRangeParameters = SafeArrayCreate(VT_UNKNOWN, 1, rgsaBound);
	
	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	i=0;
	while(i < lCount)
	{
		IUnknown * pUnk = NULL;

		lvItem.iItem = i;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			NTDM_ERR_MSG_IF_FAIL(((IWbemClassObject *)lvItem.lParam)->QueryInterface(IID_IUnknown, (void**)&pUnk));

			rgIndices[0] = i;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayPutElement(psaRangeParameters, rgIndices, pUnk));

			pUnk->Release();
		}

		i++;
	}

	VariantClear(&vValue);
	V_VT(&vValue) = VT_ARRAY|VT_UNKNOWN;
	V_ARRAY(&vValue) = psaRangeParameters;

	m_vValue.Clear();
	m_vValue.Copy(&vValue);

	//m_vValue = vValue;

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup

	VariantClear(&vValue);

	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRangeParameterPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRangeParameterPropertyDlg)
	{
		return g_pEditRangeParameterPropertyDlg->EditRangeParameterPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRangeParameterPropertyDlg::CEditRangeParameterPropertyDlg(IWbemClassObject* pIWbemClassObject, IWbemServices* pIWbemServices)
{
	m_pIWbemClassObject = pIWbemClassObject;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditRangeParameterPropertyDlg::~CEditRangeParameterPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRangeParameterPropertyDlg::EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_ADD == LOWORD(wParam))
				{
					OnAdd();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

			
				if(CBN_SELCHANGE == HIWORD(wParam) && IDC_PARAMETER_TYPE == LOWORD(wParam))
				{
					ShowControls();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_RANGE_PARAMETER_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	CComBSTR bstrName;
	CComVariant vValue;
	CIMTYPE cimType;
	CSimpleArray<BSTR> bstrArrayRangeTypes;
	long lIndex;

	NTDM_BEGIN_METHOD()
	
	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	m_hwndListView = GetDlgItem(m_hWnd, IDC_VALUES_SET_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	// Set the standard props for all types of ranges
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("PropertyName"), 0, &vValue, &cimType, NULL));
	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_PROPERTY_NAME, vValue.bstrVal);
	}

	vValue.Clear();
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("TargetClass"), 0, &vValue, &cimType, NULL));
	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_TARGET_CLASS, vValue.bstrVal);
	}

	vValue.Clear();
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("TargetType"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_TARGET_TYPE, V_UI1(&vValue), FALSE);

	vValue.Clear();

	NTDM_ERR_IF_FAIL(CNTDMUtils::GetValuesInList((long)IDS_RANGE_NAMES, bstrArrayRangeTypes));
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[0]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_sintrange));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[1]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_uintrange));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[2]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_realrange));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[3]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_sintset));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[4]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_uintset));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[5]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_stringset));

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("__CLASS"), 0, &vValue, &cimType, NULL));
	if(_tcscmp(_T("MSFT_SintRangeParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 0, 0);
		GetSintRangeValues();
	}
	else if(_tcscmp(_T("MSFT_UintRangeParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 1, 0);
		GetUintRangeValues();
	}
	else if(_tcscmp(_T("MSFT_RealRangeParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 2, 0);
		GetRealRangeValues();
	}
	else if(_tcscmp(_T("MSFT_SintSetParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 3, 0);
		GetSintSetValues();
	}
	else if(_tcscmp(_T("MSFT_UintSetParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 4, 0);
		GetUintSetValues();
	}
	else
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 5, 0);
		GetStringSetValues();
	}

	ShowControls();

	
	NTDM_ERR_IF_FAIL(PopulateItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::ClearItems()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::PopulateItems()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("PropertyName"), 0, &vValue, &cimType, NULL));
	lvItem.iItem = lIndex;
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RANGE_SELECTED);
		goto error;
	}
	else
	{
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnAdd()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	ListView_DeleteItem(m_hwndListView, lSelectionMark);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnOK()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	CComBSTR bstrTemp;
	long lIndex;
	long lValue;
	CComPtr<IWbemClassObject>pIWbemClassObject;

	NTDM_BEGIN_METHOD()

	// TODO: check values to make sure all are valid

	// delete the old instance : no need to do this just replace the element in the array
	//NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));
	//NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));
	m_pIWbemClassObject = NULL;

	// create a new instance of the range parameter based on the Range Type combo box selection
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETCURSEL, 0, 0);
	NTDM_CHECK_CB_ERR(lIndex);
	lValue = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETITEMDATA, lIndex, 0);
	if(lValue == rt_sintrange)
	{
		bstrTemp = _T("MSFT_SintRangeParam");
	}
	else if(lValue == rt_uintrange)
	{
		bstrTemp = _T("MSFT_UintRangeParam");
	}
	else if(lValue == rt_realrange)
	{
		bstrTemp = _T("MSFT_RealRangeParam");
	}
	else if(lValue == rt_sintset)
	{
		bstrTemp = _T("MSFT_SintSetParam");
	}
	else if(lValue == rt_uintset)
	{
		bstrTemp = _T("MSFT_UintSetParam");
	}
	else if(lValue == rt_stringset)
	{
		bstrTemp = _T("MSFT_StringSetParam");
	}
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &m_pIWbemClassObject));

	NTDM_ERR_IF_FAIL(SetRangeParamValues());

	if(lValue == rt_sintrange)
	{
		SetSintRangeValues();
	}
	else if(lValue == rt_uintrange)
	{
		SetUintRangeValues();
	}
	else if(lValue == rt_realrange)
	{
		SetRealRangeValues();
	}
	else if(lValue == rt_sintset)
	{
		SetSintSetValues();
	}
	else if(lValue == rt_uintset)
	{
		SetSintSetValues();
	}
	else if(lValue == rt_stringset)
	{
		SetStringSetValues();
	}

	m_vValue.Clear();
	V_VT(&m_vValue) = VT_UNKNOWN;
	NTDM_ERR_IF_FAIL(m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&m_vValue)));

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::ShowControls()
{
	HRESULT hr;
	bool bShowMinMax;
	long lIndex;
	long lVal;

	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETCURSEL, 0, 0);
	NTDM_CHECK_CB_ERR(lIndex);
	lVal = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETITEMDATA, lIndex, 0);
	if(lVal == rt_sintrange || lVal == rt_uintrange || lVal == rt_realrange)
		bShowMinMax = true;
	else
		bShowMinMax = false;


	NTDM_BEGIN_METHOD()

	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_RANGE_TEXT, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_RANGE_VALUE, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MIN_RANGE_TEXT, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MIN_RANGE_VALUE, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MAX_RANGE_TEXT, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MAX_RANGE_VALUE, bShowMinMax);

	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_SET_TEXT, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_SET_VALUE, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_VALUES_SET_TEXT, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_VALUES_SET_LIST, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_ADD, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_EDIT, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DELETE, !bShowMinMax);

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetSintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Default"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, vValue.intVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Min"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, vValue.intVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Max"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, vValue.intVal, FALSE);

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetSintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	cimType = CIM_SINT32;

	V_VT(&vValue) = VT_I4;

	lValue = GetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.intVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Default"), 0, &vValue, cimType));
	

	lValue = GetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.intVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Min"), 0, &vValue, cimType));
	
	lValue = GetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.intVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Max"), 0, &vValue, cimType));

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetUintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Default"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, vValue.uiVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Min"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, vValue.uiVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Max"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, vValue.uiVal, FALSE);

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetUintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	cimType = CIM_UINT32;

	lValue = GetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.uiVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Default"), 0, &vValue, cimType));
	

	lValue = GetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.uiVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Min"), 0, &vValue, cimType));
	
	lValue = GetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.uiVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Max"), 0, &vValue, cimType));
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetRealRangeValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetRealRangeValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetSintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetSintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetUintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetUintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetStringSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetStringSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetRangeParamValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("PropertyName"), m_hWnd, IDC_PROPERTY_NAME));
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("TargetClass"), m_hWnd, IDC_TARGET_CLASS));

	cimType = CIM_UINT8;
	lValue = GetDlgItemInt(m_hWnd, IDC_TARGET_TYPE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	V_VT(&vValue) = VT_UI1;
	V_UI1(&vValue) = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("TargetType"), 0, &vValue, cimType));
	
	NTDM_END_METHOD()

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\ntdmutils.cpp ===
//-------------------------------------------------------------------------
// File: ntdmutils.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include "Commdlg.h"
#include "Cderr.h"
#include <wbemidl.h>
#include "defines.h"
#include "resource.h"
#include "ntdmutils.h"

//-------------------------------------------------------------------------
// Globals

USHORT g_CIMTypes[] = {
	CIM_ILLEGAL,
	CIM_EMPTY	,
	CIM_SINT8	,
	CIM_UINT8	,
	CIM_SINT16	,
	CIM_UINT16	,
	CIM_SINT32	,
	CIM_UINT32	,
	CIM_SINT64	,
	CIM_UINT64	,
	CIM_REAL32	,
	CIM_REAL64	,
	CIM_BOOLEAN	,
	CIM_STRING	,
	CIM_DATETIME	,
	CIM_REFERENCE	,
	CIM_CHAR16	,
	CIM_OBJECT	,
	CIM_FLAG_ARRAY
};

USHORT g_CIMToVARIANTTypes[] = {
	VT_EMPTY,
	VT_EMPTY,
	VT_I1	,
	VT_UI1	,
	VT_I2	,
	VT_UI2	,
	VT_I4	,
	VT_UI4	,
	VT_I8	,
	VT_UI8	,
	VT_R4	,
	VT_R8	,
	VT_BOOL	,
	VT_BSTR	,
	VT_BSTR	,
	VT_BYREF,
	VT_BSTR	,
	VT_DISPATCH	,
	VT_ARRAY
};

CSimpleArray<BSTR> g_bstrCIMTypes;

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::Initialize()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(GetValuesInList((long)IDS_CIMTYPES, g_bstrCIMTypes));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::UnInitialize()
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		NTDM_FREE_BSTR((BSTR)g_bstrCIMTypes[i]);
	}

	g_bstrCIMTypes.RemoveAll();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::ErrorHandler(HWND hWnd, HRESULT err_hr, bool bShowError)
{
	if(bShowError)
		DisplayErrorInfo(hWnd, err_hr);

	return S_OK;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::DisplayErrorInfo(HWND hWnd, HRESULT err_hr)
{
	HRESULT hr;
	CComBSTR bstrSource, bstrDescription;
	CComBSTR bstrTemp;
	CComBSTR bstrAllTogether;

	NTDM_BEGIN_METHOD()

	GetDetailedErrorInfo(hWnd, bstrSource, bstrDescription, err_hr);

	bstrAllTogether.LoadString(_Module.GetResourceInstance(), IDS_ERROR_SOURCE);
	bstrAllTogether += bstrSource;
	bstrAllTogether += _T("\r\n\r\n");

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ERROR_DESCRIPTION);
	bstrAllTogether += bstrTemp;
	bstrAllTogether += bstrDescription;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ERROR);

	MessageBox(hWnd, bstrAllTogether, bstrTemp, MB_OK);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}


//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetDetailedErrorInfo(HWND hWnd, CComBSTR &bstrSource, CComBSTR &bstrDescription, HRESULT err_hr)
{
	HRESULT hr;
	CComPtr<IErrorInfo>pIErrorInfo;
	HWND m_hWnd = hWnd;

	NTDM_BEGIN_METHOD()

	bstrSource = _T("");
	bstrDescription = _T("");

	//Get Error Object
	hr = GetErrorInfo(0,&pIErrorInfo);
	if(S_OK == hr)
	{
		pIErrorInfo->GetDescription(&bstrDescription);
		pIErrorInfo->GetSource(&bstrSource);
	}

	if(S_OK == hr && !bstrDescription.Length())
	{
		CComPtr<IWbemClassObject> pIWbemClassObject;
		CComVariant vValue;
		CIMTYPE vType;

		// check if WMI error
		if SUCCEEDED(hr = pIErrorInfo->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject))
		{
			CComPtr<IWbemStatusCodeText> pIWbemStatusCodeText;

			if SUCCEEDED(hr = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID *) &pIWbemStatusCodeText))
			{
				pIWbemStatusCodeText->GetErrorCodeText(err_hr, 0, 0, &bstrDescription);
				pIWbemStatusCodeText->GetFacilityCodeText(err_hr, 0, 0, &bstrSource);

				// check for Rule Validation Results
				if SUCCEEDED(hr = pIWbemClassObject->Get(_T("RuleValidationResults"), 0, &vValue, &vType, NULL))
				{
					if(VT_NULL != V_VT(&vValue))
					{
						SAFEARRAY *pValidationResults = NULL;
						long lLower, lUpper, i;

						if(	SUCCEEDED(hr = SafeArrayGetUBound(pValidationResults, 1, &lUpper)) &&
							SUCCEEDED(hr = SafeArrayGetLBound(pValidationResults, 1, &lLower)))
						{
							CComBSTR bstrErrors;

							for(i=lLower; i<=lUpper; i++)
							{
								if(V_VT(&vValue) & VT_HRESULT)
								{
									CComBSTR bstrError;
									HRESULT hr2;

									if SUCCEEDED(hr = SafeArrayGetElement(pValidationResults, &i, (void *)&hr2))
									{
										bstrErrors += _T("\r\n\r\n");

										pIWbemStatusCodeText->GetErrorCodeText(hr2, 0, 0, &bstrError);

										bstrErrors += bstrError;
									}
								}
							}

							bstrDescription += bstrErrors;
						}
					}				
				}
			}
		}
	}


	if(!bstrDescription.Length())
	{
		TCHAR pszTemp[SZ_MAX_SIZE];
		pszTemp[0] = NULL;

		if(!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
							NULL,
							err_hr,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							pszTemp,
							SZ_MAX_SIZE,
							NULL))
		{
			FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
							NULL,
							HRESULT_CODE(err_hr),
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							pszTemp,
							SZ_MAX_SIZE,
							NULL);
		}

		bstrDescription = pszTemp;
	}

	if(!bstrDescription.Length())
	{
		bstrDescription.LoadString(_Module.GetResourceInstance(), IDS_NO_DESCRIPTION_PROVIDED);
	}

	if(!bstrSource.Length())
	{
		bstrSource.LoadString(_Module.GetResourceInstance(), IDS_NO_SOURCE_NAME_PROVIDED);
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetValuesInList(LPCTSTR strList, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken)
{
	HRESULT hr;
	BSTR bstrTemp = NULL;
	BSTR bstrItem = NULL;
	TCHAR * pszItem;

	NTDM_BEGIN_METHOD()

	if(!strList || !_tcslen(strList))
	{
		NTDM_EXIT(NOERROR);
	}

	bstrTemp = SysAllocString(strList);

	pszItem = _tcstok(bstrTemp, pcszToken);

	while(pszItem)
	{
		bstrItem = SysAllocString(pszItem);
        if (!bstrArray.Add(bstrItem))
		{
		    hr = E_FAIL;
			CNTDMUtils::ErrorHandler(NULL, hr, FALSE);
			goto error;
		}
		bstrItem = NULL;
		pszItem = _tcstok(NULL, pcszToken);
	}

	NTDM_END_METHOD()

	// cleanup
	NTDM_FREE_BSTR(bstrTemp);
	NTDM_FREE_BSTR(bstrItem);

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetValuesInList(long lResID, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken)
{
	HRESULT hr;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), lResID);
	GetValuesInList(bstrTemp, bstrArray, pcszToken);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetCIMTypeFromString(LPCTSTR pcszCIMType, long *pCimTYPE)
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		if(_tcscmp(pcszCIMType, g_bstrCIMTypes[i]) == 0)
		{
			*pCimTYPE = g_CIMTypes[i];
			break;
		}
	}

	if(i >= g_bstrCIMTypes.GetSize())
	{
		NTDM_EXIT(E_FAIL);
	}

	hr = NOERROR;

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetVariantTypeFromString(LPCTSTR pcszCIMType, long *pVariantType)
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		if(_tcscmp(pcszCIMType, g_bstrCIMTypes[i]) == 0)
		{
			*pVariantType = g_CIMToVARIANTTypes[i];
			break;
		}
	}

	if(i >= g_bstrCIMTypes.GetSize())
	{
		NTDM_EXIT(E_FAIL);
	}

	hr = NOERROR;

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::SetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID)
{
	HRESULT hr;
	CComVariant vValue;
	CComBSTR bstrTemp;
	long lLength;
	TCHAR *pszTemp = NULL;
	HWND m_hWnd = hwnd;

	NTDM_BEGIN_METHOD()

	// Set the Query language
	lLength = GetWindowTextLength(GetDlgItem(hwnd, lResID));
	if(lLength < 0)
	{
		NTDM_EXIT(E_FAIL);
	}
	else if(0 == lLength)
	{
		bstrTemp = _T("");
	}
	else
	{
		pszTemp = new TCHAR[lLength+1];
		if(!pszTemp)
		{
			NTDM_EXIT(E_OUTOFMEMORY);
		}

		NTDM_ERR_GETLASTERROR_IF_NULL(GetDlgItemText(hwnd, lResID, pszTemp, lLength+1));

		bstrTemp = pszTemp;

		delete [] pszTemp;
		pszTemp = NULL;
	}

	vValue = bstrTemp;

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Put(pszPropName, 0, &vValue, CIM_STRING));

	NTDM_END_METHOD()

	// cleanup
	delete [] pszTemp;

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetDlgItemString(HWND hwnd, long lResID, CComBSTR &bstrValue)
{
	HRESULT hr;
	CComBSTR bstrTemp;
	long lLength;
	TCHAR *pszTemp = NULL;
	HWND m_hWnd = hwnd;

	NTDM_BEGIN_METHOD()

	// Set the Query language
	lLength = GetWindowTextLength(GetDlgItem(hwnd, lResID));
	if(lLength < 0)
	{
		NTDM_EXIT(E_FAIL);
	}
	else if(0 == lLength)
	{
		bstrTemp = _T("");
	}
	else
	{
		pszTemp = new TCHAR[lLength+1];
		if(!pszTemp)
		{
			NTDM_EXIT(E_OUTOFMEMORY);
		}

		NTDM_ERR_GETLASTERROR_IF_NULL(GetDlgItemText(hwnd, lResID, pszTemp, lLength+1));

                pszTemp[lLength] = L'\0';

		bstrValue = pszTemp;

		delete [] pszTemp;
		pszTemp = NULL;
	}

	NTDM_END_METHOD()

	// cleanup
	delete [] pszTemp;

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID)
{
	HRESULT hr;
	HWND m_hWnd = hwnd;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(pszPropName, 0, &vValue, &cimType, NULL));
	SetDlgItemText(hwnd, lResID, V_BSTR(&vValue));

	NTDM_END_METHOD()

	return hr;
}

//-----------------------------------------------------------------------------------------

BOOL CNTDMUtils::SaveFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile)
{
	OPENFILENAME        ofn;
	BOOL                fRet;
	HANDLE              hFile = NULL;

	memset(&ofn, 0, sizeof(OPENFILENAME));
	ofn.lStructSize      =sizeof(OPENFILENAME);
	ofn.hwndOwner        =hwnd;
	ofn.lpstrFilter      =szFilter;
	ofn.nFilterIndex     =1L;
	ofn.lpstrFile        =pszFile;
	ofn.nMaxFile         =MAX_PATH;
	ofn.lpstrDefExt      =TEXT("*");
	ofn.Flags            =OFN_HIDEREADONLY;

	fRet=GetSaveFileName(&ofn);

	if(fRet == 0)
	{
		if(FNERR_INVALIDFILENAME == CommDlgExtendedError())
		{
			(void) StringCchCopy(pszFile, MAX_PATH, TEXT(""));
			fRet=GetSaveFileName(&ofn);
		}
	}

	return fRet;
}

//-----------------------------------------------------------------------------------------

BOOL CNTDMUtils::OpenFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile)
{
	OPENFILENAME        ofn;
	BOOL                fRet;
	HANDLE              hFile = NULL;

	memset(&ofn, 0, sizeof(OPENFILENAME));
	ofn.lStructSize      =sizeof(OPENFILENAME);
	ofn.hwndOwner        =hwnd;
	ofn.lpstrFilter      =szFilter;
	ofn.nFilterIndex     =1L;
	ofn.lpstrFile        =pszFile;
	ofn.nMaxFile         =MAX_PATH;
	ofn.lpstrDefExt      =TEXT("*");
	ofn.Flags            =OFN_HIDEREADONLY;

	fRet=GetOpenFileName(&ofn);

	if(fRet == 0)
	{
		if(FNERR_INVALIDFILENAME == CommDlgExtendedError())
		{
			(void) StringCchCopy(pszFile, MAX_PATH, TEXT(""));
			fRet=GetOpenFileName(&ofn);
		}
	}

	return fRet;
}

//-----------------------------------------------------------------------------------------

void CNTDMUtils::ReplaceCharacter(TCHAR * string_val, const TCHAR replace_old, const TCHAR replace_new)
{
	TCHAR * p_cur = string_val;

	while(*p_cur)
	{
		if(replace_old == *p_cur)
			*p_cur = replace_new;

		p_cur++;
	}
}

//-------------------------------------------------------------------------

long CNTDMUtils::DisplayMessage(HWND hParent, long iMsgID, long iTitleID, long iType)
{
	CComBSTR bstrMsg, bstrTitle;
	
	bstrMsg.LoadString(_Module.GetResourceInstance(), iMsgID);
	bstrTitle.LoadString(_Module.GetResourceInstance(), iTitleID);

	return MessageBox(hParent, bstrMsg, bstrTitle, iType);
}

//-----------------------------------------------------------------------------------------

void CNTDMUtils::DisplayDlgItem(HWND hWndDlg, long item_id, BOOL show)
{
	if(show)
	{
		ShowWindow(GetDlgItem(hWndDlg, item_id), SW_SHOW);
		EnableWindow(GetDlgItem(hWndDlg, item_id), TRUE);
	}
	else
	{
		ShowWindow(GetDlgItem(hWndDlg, item_id), SW_HIDE);
		EnableWindow(GetDlgItem(hWndDlg, item_id), FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\dlgfilterproperties.h ===
//-------------------------------------------------------------------------
// File: DlgFilterProperties.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK FilterPropertiesDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CFilterPropertiesDlg
{
	public:
		CFilterPropertiesDlg(IWbemServices * pIWbemServices, IWbemClassObject * pIWbemClassObject);
		~CFilterPropertiesDlg();
		INT_PTR CALLBACK FilterPropertiesDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP PopulateRulesList();
		STDMETHODIMP ClearRulesList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject);
		STDMETHODIMP ShowProperty(IWbemClassObject * pIWbemClassObject, LPCTSTR pszPropertyName, long lResID);

		HWND m_hWnd;
		IWbemServices * m_pIWbemServices;
		HWND m_hwndRulesListView;
		IWbemClassObject * m_pIWbemClassObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\ntdmutils.h ===
//-------------------------------------------------------------------------
// File: ntdmutils.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

class CNTDMUtils
{
	public:
		static STDMETHODIMP Initialize();
		static STDMETHODIMP UnInitialize();
		static STDMETHODIMP ErrorHandler(HWND hWnd, HRESULT err_hr, bool bShowError=true);
		static STDMETHODIMP GetValuesInList(LPCTSTR strList, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken=L";");
		static STDMETHODIMP GetValuesInList(long lResID, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken=L";");
		static STDMETHODIMP GetCIMTypeFromString(LPCTSTR pcszCIMType, long *pCimTYPE);
		static STDMETHODIMP GetVariantTypeFromString(LPCTSTR pcszCIMType, long *pVariantTYPE);
		static STDMETHODIMP SetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID);
		static STDMETHODIMP GetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID);
		static BOOL SaveFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile);
		static BOOL OpenFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile);
		static void ReplaceCharacter(TCHAR * string_val, const TCHAR replace_old, const TCHAR replace_new);
		static long DisplayMessage(HWND hParent, long iMsgID, long iTitleID=IDS_ERROR, long iType=0);
		static void DisplayDlgItem(HWND hWndDlg, long item_id, BOOL show);
		static STDMETHODIMP GetDlgItemString(HWND hwnd, long lResID, CComBSTR &bstrValue);

	protected:
		static STDMETHODIMP DisplayErrorInfo(HWND hWnd, HRESULT err_hr);
		static STDMETHODIMP GetDetailedErrorInfo(HWND hWnd, CComBSTR &bstrSource, CComBSTR &bstrDescription, HRESULT err_hr);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\policytemplateeditpropertiesdlg.cpp ===
//-------------------------------------------------------------------------
// File: PolicyTemplateEditPropertiesDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "PolicyTemplateManager.h"
#include "PolicyTemplateEditPropertiesDlg.h"
#include "EditPropertyDlgs.h"


extern USHORT g_CIMTypes[];
extern CSimpleArray<BSTR> g_bstrCIMTypes;

CEditPolicyTemplatePropertiesPageDlg * g_pEditPolicyTemplatePropertiesPage =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK EditPolicyTemplatePropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditPolicyTemplatePropertiesPage)
	{
		return g_pEditPolicyTemplatePropertiesPage->EditPolicyTemplatePropertiesPageDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditPolicyTemplatePropertiesPageDlg::CEditPolicyTemplatePropertiesPageDlg(IWbemClassObject * pIPolicyTemplateClassObject, IWbemServices * pIWbemServices)
{
	_ASSERT(pIPolicyTemplateClassObject);
	_ASSERT(pIWbemServices);

	m_hWnd = NULL;
	m_pIPolicyTemplateClassObject = pIPolicyTemplateClassObject;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditPolicyTemplatePropertiesPageDlg::~CEditPolicyTemplatePropertiesPageDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditPolicyTemplatePropertiesPageDlg::EditPolicyTemplatePropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_IMPORT == LOWORD(wParam))
				{
					OnImport();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EXPORT == LOWORD(wParam))
				{
					OnExport();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_POLICY_TEMPLATE_PROPERTIES_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrTemp;
	
	NTDM_BEGIN_METHOD()

	//Initialize the Property List Control
	m_hwndPropertiesListView = GetDlgItem(m_hWnd, IDC_POLICY_TEMPLATE_PROPERTIES_LIST);
	NTDM_ERR_IF_NULL(m_hwndPropertiesListView);
	ListView_SetExtendedListViewStyle(m_hwndPropertiesListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NAME);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 0, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_TYPE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 1, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_VALUE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 2, &lvColumn));

	PopulatePolicyTemplatePropertiesList();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearPolicyTemplatePropertiesList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::ClearPolicyTemplatePropertiesList()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ListView_DeleteAllItems(m_hwndPropertiesListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::PopulatePolicyTemplatePropertiesList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrName;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearPolicyTemplatePropertiesList());

	if(!m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY));

	while(true)
	{
		NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->Next(0, &bstrName, &vValue, &cimType, NULL));

		if(WBEM_S_NO_MORE_DATA == hr)
			break;

		NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType));
	}


	NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->EndEnumeration());

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 2, LVSCW_AUTOSIZE_USEHEADER));

	ListView_SetItemState(m_hwndPropertiesListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::AddItemToPropertyList(LPCTSTR pcszName, VARIANT * pvValue, CIMTYPE cimType, long lIndex)
{
	HRESULT hr;
	LVITEM lvItem;
	CComVariant vValue;
	long i;

	NTDM_BEGIN_METHOD()

	vValue = *pvValue;

	// Name
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = (LPTSTR)pcszName;

	lvItem.iItem = ListView_InsertItem(m_hwndPropertiesListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	// Type
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 1;
	lvItem.pszText = _T("");
	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		// if Array and the type contains CIM_FLAG_ARRAY then show array
		if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
		{
			lvItem.pszText = (LPTSTR)g_bstrCIMTypes[i];
			break;
		}
	}

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));


	// Value
	if FAILED(hr = VariantChangeType(&vValue, &vValue, VARIANT_ALPHABOOL|VARIANT_LOCALBOOL, VT_BSTR))
	{
		if(V_VT(&vValue) == VT_NULL)
		{
			vValue = _T("");
		}
		else
		{
			CComBSTR bstrTemp;
			bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_UNABLE_TO_DISPLAY);

			vValue = bstrTemp;
		}

		hr = NOERROR;
	}

	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 2;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndPropertiesListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_PROPERTY_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		TCHAR pszBuffer[SZ_MAX_SIZE];
		VARIANT vValue;
		CComBSTR bstrName;
		CComBSTR bstrType;
		CIMTYPE cimType;
		LVITEM lvItem;
		long i;

		VariantInit(&vValue);

		// get the property info
		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = lSelectionMark;
		lvItem.iSubItem = 0;
		lvItem.pszText = pszBuffer;
		lvItem.cchTextMax = SZ_MAX_SIZE;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndPropertiesListView, &lvItem));

		if(lvItem.pszText)
		{
			bstrName = lvItem.pszText;
			long lSpecialCaseProperty = 0;

			NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->Get(bstrName, 0, &vValue, &cimType, NULL));

			if(_tcscmp(_T("RangeSettings"), bstrName) == 0)
			{
				lSpecialCaseProperty = CEditProperty::psc_ranges;
			}

			for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
			{
				// if Array and the type contains CIM_FLAG_ARRAY then show array
				if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
				{
					bstrType = (LPTSTR)g_bstrCIMTypes[i];
					break;
				}
			}

			CEditProperty dlgProps(m_hWnd, lvItem.pszText, bstrType, &vValue, m_pIWbemServices, lSpecialCaseProperty);
			if(IDOK == dlgProps.Run())
			{
				// delete the selected entry
				NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->Put(bstrName, 0, &vValue, cimType));
				NTDM_ERR_IF_FALSE(ListView_DeleteItem(m_hwndPropertiesListView, lSelectionMark));
				NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType, lSelectionMark));
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnOK()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(m_pIPolicyTemplateClassObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnImport()
{
	HRESULT hr;
	CComBSTR bstrPolicyTemplate;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrTemp;

	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrPolicyTemplate.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrPolicyTemplate += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrPolicyTemplate, L'@', L'\0');

	if(CNTDMUtils::OpenFileNameDlg(bstrPolicyTemplate, _T("*.*"), m_hWnd, pszFile) && pszFile)
	{
		CComPtr<IMofCompiler>pIMofCompiler;
		CComPtr<IWbemClassObject>pINamespaceClass;
		CComPtr<IWbemClassObject>pIWbemNewInstance;
		CComPtr<IWbemClassObject>pIWbemClassObject;
		CComVariant vValue = _T("DeleteThisNamespace");
		WBEM_COMPILE_STATUS_INFO pInfo;

		// Generate a temporary namespace
		bstrTemp = _T("__Namespace");
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pINamespaceClass, NULL));
		NTDM_ERR_MSG_IF_FAIL(pINamespaceClass->SpawnInstance(0, &pIWbemNewInstance));
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(pIWbemNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

		// mofcomp the file into that namespace
		NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,IID_IMofCompiler, (void**)&pIMofCompiler));
		NTDM_ERR_IF_FAIL(pIMofCompiler->CompileFile(pszFile, _T("\\\\.\\root\\policy\\DeleteThisNamespace"), NULL, NULL, NULL, WBEM_FLAG_DONT_ADD_TO_LIST, WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_CREATE_ONLY, &pInfo));

		if(hr != WBEM_S_NO_ERROR)
		{
			CNTDMUtils::DisplayMessage(m_hWnd, IDS_FAILED_COMPILING_MOF_FILE);
			NTDM_EXIT(E_FAIL);
		}

		// get the 1st instance of MSFT_PolicyTemplate from the newly created namespace
		NTDM_ERR_IF_FAIL(GetInstanceOfClass(bstrTemp, _T("MSFT_PolicyTemplate"), &pIWbemClassObject));

		// copy the properties
		m_pIPolicyTemplateClassObject = pIWbemClassObject;
		PopulatePolicyTemplatePropertiesList();
	}

	NTDM_END_METHOD()

	// finally delete the namespace that we created above
	{
		CComVariant vValue = "\\\\.\\root\\policy:__Namespace.Name=\"DeleteThisNamespace\"";
		m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL);
	}

	return hr;
}


//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject)
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;
	CComPtr<IWbemServices>pIWbemServices;
	CComPtr<IEnumWbemClassObject>pEnumWbemClassObject;
	CComBSTR bstrClass = _T("MSFT_PolicyTemplate");
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	pszNamespace,
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	NTDM_ERR_MSG_IF_FAIL(pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));
	NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, ppWbemClassObject, &uReturned));

	if(!uReturned)
		NTDM_EXIT(E_FAIL);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}



//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnExport()
{
	HRESULT hr;
	CComBSTR bstrTemp;
	CComBSTR bstrPolicyTemplate;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrObjectText;
	HANDLE hFile = NULL;
	DWORD dwWritten;
	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrPolicyTemplate.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrPolicyTemplate += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrPolicyTemplate, L'@', L'\0');

	if(CNTDMUtils::SaveFileNameDlg(bstrPolicyTemplate, _T("*.mof"), m_hWnd, pszFile))
	{
		if(_tcslen(pszFile))
		{
			NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->GetObjectText(0, &bstrObjectText));

			// save to pszFile
			hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
							   NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(hFile == INVALID_HANDLE_VALUE)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(NULL);
				goto error;
			}

			if(hFile)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrObjectText, _tcslen(bstrObjectText) * sizeof(TCHAR), &dwWritten, NULL));
				NTDM_ERR_GETLASTERROR_IF_NULL(CloseHandle(hFile));
				hFile = NULL;
			}
		}
	}

	NTDM_END_METHOD()

	// cleanup
	if(hFile)
	{
		CloseHandle(hFile);
		hFile = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\policytemplatemanager.cpp ===
// PolicyTemplateManager.cpp : Implementation of CPolicyTemplateManager
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "PolicyTemplateManager.h"
#include "PolicyTemplateMgrDlg.h"

extern CPolicyTemplateManagerDlg *g_pPolicyTemplateManagerDlg;

/////////////////////////////////////////////////////////////////////////////
// CPolicyTemplateManager

CPolicyTemplateManager::CPolicyTemplateManager()
{
	m_hWnd = NULL;
}

//---------------------------------------------------------------------------

CPolicyTemplateManager::~CPolicyTemplateManager()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManager::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	_T("root\\policy"),
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManager::RunManager(HWND hwndParent)
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pPolicyTemplateManagerDlg = new CPolicyTemplateManagerDlg(this);
	DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_POLICY_TEMPLATE_MANAGER), (HWND)hwndParent, PolicyTemplateManagerDlgProc);
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pPolicyTemplateManagerDlg);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\policytemplatemanager.h ===
// PolicyTemplateManager.h : Declaration of the CPolicyTemplateManager

#ifndef __POLICYTEMPLATEMANAGER_H_
#define __POLICYTEMPLATEMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPolicyTemplateManager
class ATL_NO_VTABLE CPolicyTemplateManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPolicyTemplateManager, &CLSID_PolicyTemplateManager>,
	public IDispatchImpl<IPolicyTemplateManager, &IID_IPolicyTemplateManager, &LIBID_SCHEMAMANAGERLib>
{
public:
	CPolicyTemplateManager();
	~CPolicyTemplateManager();

DECLARE_REGISTRY_RESOURCEID(IDR_POLICYTEMPLATEMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPolicyTemplateManager)
	COM_INTERFACE_ENTRY(IPolicyTemplateManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISomFilterManager
public:
	STDMETHOD(RunManager)(/*[in]*/HWND hwndParent);
	STDMETHOD(ConnectToWMI)();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__POLICYTEMPLATEMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\policytemplatemgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: PolicyTemplateMgrDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "PolicyTemplateManager.h"
#include "PolicyTemplateMgrDlg.h"
#include "PolicyTemplateEditPropertiesDlg.h"

CPolicyTemplateManagerDlg * g_pPolicyTemplateManagerDlg =  NULL;
extern CEditPolicyTemplatePropertiesPageDlg * g_pEditPolicyTemplatePropertiesPage;

//-------------------------------------------------------------------------

INT_PTR CALLBACK PolicyTemplateManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pPolicyTemplateManagerDlg)
	{
		return g_pPolicyTemplateManagerDlg->PolicyTemplateManagerDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CPolicyTemplateManagerDlg::CPolicyTemplateManagerDlg(CPolicyTemplateManager * pPolicyTemplateManager)
{
	_ASSERT(pPolicyTemplateManager);

	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pPolicyTemplateManager = pPolicyTemplateManager;
}

//-------------------------------------------------------------------------

CPolicyTemplateManagerDlg::~CPolicyTemplateManagerDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CPolicyTemplateManagerDlg::PolicyTemplateManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();
				PopulatePolicyTypeList();
				OnPolicyTypeChange();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDOK:
				case IDCANCEL:
					EndDialog(m_hWnd, 0);
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_NEW == LOWORD(wParam))
				{
					OnNew();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				if(CBN_SELCHANGE == HIWORD(wParam) && IDC_POLICY_TYPE == LOWORD(wParam))
				{
					OnPolicyTypeChange();
					return TRUE;
				}


				break;
			}

		case WM_NOTIFY:
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;

			switch (lpnm->code)
			{
				case NM_DBLCLK :
				{
					if(lpnm->idFrom == IDC_SOM_FILTER_LIST)
					{
						OnEdit();
						return TRUE;
					}
					break;
				}

				default :
					break;
			}
		}

	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;
	
	NTDM_BEGIN_METHOD()

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_SOM_FILTER_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);
	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_POLICY_TYPE);
	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 1, &lvColumn));

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearPolicyTemplateList());
	NTDM_ERR_IF_FAIL(ClearPolicyTypeList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::ClearPolicyTemplateList()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::PopulatePolicyTemplatesList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemClassDefinitionObject;
	ULONG uReturned;
	CComVariant vValueClassName;
	CComBSTR bstrWQLStmt;
	CComBSTR bstrWQL;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	if(!m_pPolicyTemplateManager->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_IF_FAIL(ClearPolicyTemplateList());
	
	// Get the Policy Template Class
	NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTypeClassObject->Get(_T("ClassDefinition"), 0, &vValue, &cimType, NULL));

	// Make sure we got a Class Object back
	if(V_VT(&vValue) != VT_UNKNOWN)
	{
		NTDM_EXIT(E_FAIL);
	}

	NTDM_ERR_MSG_IF_FAIL(V_UNKNOWN(&vValue)->QueryInterface(IID_IWbemClassObject, (void**)&pIWbemClassDefinitionObject));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassDefinitionObject->Get(_T("__CLASS"), 0, &vValueClassName, &cimType, NULL));

	//vValueClassName = _T("ified");

	// Get all the policy templates that have the TargetClass property = the class we got above.
	bstrWQLStmt = _T("SELECT * FROM MSFT_MergeablePolicyTemplate WHERE TargetClass='");
	bstrWQLStmt += V_BSTR(&vValueClassName);
	bstrWQLStmt += _T("'");

	bstrWQL = _T("WQL");

	NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->ExecQuery(bstrWQL, bstrWQLStmt, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddItemToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	NTDM_ERR_IF_MINUSONE(ListView_InsertItem(m_hwndListView, &lvItem));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			g_pEditPolicyTemplatePropertiesPage = new CEditPolicyTemplatePropertiesPageDlg((IWbemClassObject *)lvItem.lParam, m_pPolicyTemplateManager->m_pIWbemServices);

			if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_POLICY_TEMPLATE_PROPERTIES), m_hWnd, EditPolicyTemplatePropertiesPageDlgProc))
			{
				// Refresh the SOM filters
				NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			CComVariant vValue;
			CIMTYPE cimType;

			IWbemClassObject * pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			
			NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));
			NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));

			// Refresh the SOM filters
			NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnNew()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_PolicyTemplate");

	NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	g_pEditPolicyTemplatePropertiesPage = new CEditPolicyTemplatePropertiesPageDlg(pIWbemNewInstance, m_pPolicyTemplateManager->m_pIWbemServices);

	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_POLICY_TEMPLATE_PROPERTIES), m_hWnd, EditPolicyTemplatePropertiesPageDlgProc))
	{
		// Refresh the SOM filters
		NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::PopulatePolicyTypeList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrClass(_T("MSFT_PolicyType"));
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	if(!m_pPolicyTemplateManager->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_IF_FAIL(ClearPolicyTypeList());

	// Get the Enumeration
	NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddPolicyTypeToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_SETCURSEL, 0, 0);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::AddPolicyTypeToList(IWbemClassObject * pIWbemClassObject)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	long lIndex;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("ID"), 0, &vValue, &vType, NULL));

	lIndex = SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_ADDSTRING, 0, (LPARAM)vValue.bstrVal);

	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)pIWbemClassObject));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::ClearPolicyTypeList()
{
	HRESULT hr;
	long lCount;
	IWbemClassObject * pIWbemClassObject = NULL;

	NTDM_BEGIN_METHOD()

	// Release all the objects.
	lCount = SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETCOUNT, 0, 0);
	NTDM_CHECK_CB_ERR(lCount);

	while(lCount > 0)
	{
		lCount--;

		pIWbemClassObject = (IWbemClassObject *)SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETITEMDATA, lCount, 0);
		if(pIWbemClassObject)
		{
			pIWbemClassObject->Release();
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnPolicyTypeChange()
{
	HRESULT hr;
	long lIndex;
	IWbemClassObject * pIWbemClassObject = NULL;

	NTDM_BEGIN_METHOD()

	// Release all the objects.
	lIndex = SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETCURSEL, 0, 0);
	NTDM_CHECK_CB_ERR(lIndex);

	pIWbemClassObject = (IWbemClassObject *)SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETITEMDATA, lIndex, 0);

	if(pIWbemClassObject)
		m_pIPolicyTypeClassObject = pIWbemClassObject;

	NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\policytemplateeditpropertiesdlg.h ===
//-------------------------------------------------------------------------
// File: PolicyTemplateEditPropertiesDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditPolicyTemplatePropertiesPageDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CPolicyTemplateManager;

class CEditPolicyTemplatePropertiesPageDlg
{
	public:
		CEditPolicyTemplatePropertiesPageDlg(IWbemClassObject * pIPolicyTemplateClassObject, IWbemServices * pIWbemServices);
		~CEditPolicyTemplatePropertiesPageDlg();
		INT_PTR CALLBACK EditPolicyTemplatePropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP PopulatePolicyTemplatePropertiesList();
		STDMETHODIMP AddItemToPropertyList(LPCTSTR pcszName, VARIANT * vValue, CIMTYPE cimType, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP ClearPolicyTemplatePropertiesList();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnOK();
		STDMETHODIMP OnImport();
		STDMETHODIMP OnExport();
		STDMETHODIMP GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject);

		HWND m_hWnd;
		HWND m_hwndPropertiesListView;
		CPolicyTemplateManager *m_pPolicyTemplateManager;
		CComPtr<IWbemClassObject>m_pIPolicyTemplateClassObject;
		CComPtr<IWbemServices>m_pIWbemServices;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SchemaManager.rc
//
#define IDS_PROJNAME                    100
#define IDS_ERROR                       101
#define IDR_SOMFILTERMANAGER            102
#define IDS_WARN_OVERWRITE              102
#define IDR_POLICYTEMPLATEMANAGER       103
#define IDR_WMIFILTERBROWSER            104
#define IDS_QUERY                       105
#define IDS_NAME                        106
#define IDS_QUERY_LANGUAGE              107
#define IDS_TARGET_NAMESPACE            108
#define IDS_TYPE                        109
#define IDS_VALUE                       110
#define IDR_WMIFILTERMANAGER            111
#define IDS_UNABLE_TO_DISPLAY           113
#define IDS_CIMTYPES                    114
#define IDS_ERR_STORING_DATA            115
#define IDS_ERR_NO_FILTER_SELECTED      118
#define IDS_ERR_NO_PROPERTY_SELECTED    119
#define IDS_ERR_NO_RULE_SELECTED        120
#define IDS_ALL_FILES_FILTER            179
#define IDS_TEXT_FILES_FILTER           180
#define IDS_ERR_COULD_NOT_CREATE_FILE   181
#define IDS_ERROR_DESCRIPTION           182
#define IDS_ERROR_SOURCE                183
#define IDS_NO_SOURCE_NAME_PROVIDED     184
#define IDS_NO_DESCRIPTION_PROVIDED     185
#define IDS_FAILED_COMPILING_MOF_FILE   186
#define IDS_MOF_FILES_FILTER            187
#define IDS_ERR_NO_RANGE_SELECTED       188
#define IDS_RANGE_NAMES                 189
#define IDS_CONFIRM_DELETE_FILTER       190
#define IDS_DELETE_FILTER               191
#define IDS_DETAILS1                    192
#define IDS_DETAILS2                    193
#define IDS_NEW_FILTER_NAME             194
#define IDS_PROMPT_FOR_SAVE             195
#define IDS_WMI_FILTER_MANAGER          196
#define IDS_DESCRIPTION                 197
#define IDS_DSPATH                      198
#define IDS_AUTHOR                      199
#define IDS_SOURCE_ORGANIZATION         200
#define IDD_SOM_FILTER_MANAGER          201
#define IDC_POLICY_TYPE                 201
#define IDS_CREATION_DATE               201
#define IDI_SOM_FILTER_MANAGER          202
#define IDC_POLICY_TEMPLATE_PROPERTIES_LIST 202
#define IDC_ALL_FILTERS                 202
#define IDD_FILTER_PROPERTIES           202
#define IDS_CHANGE_DATE                 202
#define IDD_SOM_FILTER_PROPERTIES       203
#define IDC_RANGE_PARAMETER_LIST        203
#define IDS_POLICY_TYPE                 203
#define IDD_EDIT_STRING_PROPERTY        204
#define IDC_PROPERTY_NAME               204
#define IDS_HELP_ERR                    204
#define IDD_EDIT_NUMBER_PROPERTY        205
#define IDC_TARGET_CLASS                205
#define IDD_EDIT_ARRAY_PROPERTY         206
#define IDC_TARGET_TYPE                 206
#define IDC_VIEW                        206
#define IDD_EDIT_RULES_PROPERTY         207
#define IDC_PARAMETER_TYPE              207
#define IDD_EDIT_RULE                   208
#define IDC_DEFAULT_RANGE_TEXT          208
#define IDC_DSPATH                      208
#define IDD_POLICY_TEMPLATE_MANAGER     209
#define IDC_DEFAULT_RANGE_VALUE         209
#define IDC_ID                          209
#define IDD_POLICY_TEMPLATE_PROPERTIES  210
#define IDC_MIN_RANGE_TEXT              210
#define IDC_SOURCE_ORGANIZATION         210
#define IDD_EDIT_RANGE_PARAMETERS_PROPERTY 211
#define IDC_DEFAULT_SET_TEXT            211
#define IDC_AUTHOR                      211
#define IDD_EDIT_RANGE_PARAMETER        212
#define IDC_DEFAULT_SET_VALUE           212
#define IDC_CHANGE_DATE                 212
#define IDD_EDIT_RANGE_PARAMETER1       213
#define IDC_VALUES_SET_TEXT             213
#define IDC_CREATION_DATE               213
#define IDD_EDIT_RANGE_PARAMETER2       214
#define IDC_VALUES_SET_LIST             214
#define IDC_MIN_RANGE_VALUE             215
#define IDC_SOM_FILTER_LIST             215
#define IDC_RULES                       215
#define IDD_WMI_FILTER_BROWSER_OLD      215
#define IDC_MAX_RANGE_TEXT              216
#define IDD_WMI_FILTER_MANAGER          216
#define IDC_EDIT                        217
#define IDD_WMI_FILTER_MANAGER1         217
#define IDD_COLUMN_MANAGER              217
#define IDD_POLICY_TEMPLATE_PARAMETERS  218
#define IDC_MAX_RANGE_VALUE             219
#define IDC_WMI_FILTER_LIST             220
#define IDC_FILTER_PROPERTIES_LIST      221
#define IDC_SAVE                        221
#define IDC_COLUMNS_LIST                222
#define IDC_IMPORT                      223
#define IDC_MOVE_UP                     223
#define IDC_MOVE_DOWN                   224
#define IDC_ADVANCED                    225
#define IDC_TYPE                        226
#define IDC_EDIT1                       226
#define IDC_COLUMNS                     226
#define IDC_DEFAULT_VALUE               226
#define IDC_VALUE                       227
#define IDC_QUERIES                     227
#define IDC_EDIT3                       228
#define IDC_DESCRIPTION                 228
#define IDC_FILTER_ELEMENTS_LIST        229
#define IDC_QUERIES_LIST                229
#define IDC_DUPLICATE                   229
#define IDC_ADD                         230
#define IDC_QUERY_LANGUAGE              231
#define IDC_TARGET_NAMESPACE            232
#define IDC_QUERY                       233
#define IDC_PARAMETERS                  234
#define IDC_EXPORT                      235
#define IDC_PARAMETER_NAME              235
#define IDC_DELETE                      236
#define IDC_ENFORCED                    236
#define IDC_ADD_QUERY                   237
#define IDC_LIST                        237
#define IDC_EDIT_QUERY                  238
#define IDC_RANGE                       238
#define IDC_DELETE_QUERY                239
#define IDC_ANY                         239
#define IDC_NAME                        240
#define IDC_RANGE_BOX                   240
#define IDD_WMI_FILTER_BROWSER          241
#define IDD_WMI_FILTER_MANAGER2         242
#define IDC_LIST_VALUES                 242
#define IDD_POLICY_TEMPLATE_PARAMETERS1 243
#define IDC_LIST_VALUES_TITLE           243
#define IDD_POLICY_TEMPLATE_PARAMETERS2 244
#define IDC_MINIMUM_TEXT                244
#define IDC_MINIMUM                     245
#define IDC_MAXIMUM_TEXT                246
#define IDC_MAXIMUM                     247
#define IDC_NEW                         249
#define IDC_HELP2                       250

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         248
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\schemamanager.cpp ===
// SchemaManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SchemaManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <wbemidl.h>
#include "SchemaManager.h"
#include "ntdmutils.h"

#include "SchemaManager_i.c"
#include "WMIFilterManager.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMIFilterManager, CWMIFilterManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SCHEMAMANAGERLib);
        DisableThreadLibraryCalls(hInstance);
		CNTDMUtils::Initialize();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
		CNTDMUtils::UnInitialize();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\policytemplatemgrdlg.h ===
//-------------------------------------------------------------------------
// File: PolicyTemplateMgrDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK PolicyTemplateManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CPolicyTemplateManager;

class CPolicyTemplateManagerDlg
{
	public:
		CPolicyTemplateManagerDlg(CPolicyTemplateManager * pPolicyTemplateManager);
		~CPolicyTemplateManagerDlg();
		INT_PTR CALLBACK PolicyTemplateManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP PopulatePolicyTemplatesList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnKillActive();
		STDMETHODIMP OnNew();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();
		STDMETHODIMP ClearPolicyTemplateList();
		STDMETHODIMP PopulatePolicyTypeList();
		STDMETHODIMP AddPolicyTypeToList(IWbemClassObject * pIWbemClassObject);
		STDMETHODIMP ClearPolicyTypeList();
		STDMETHODIMP OnPolicyTypeChange();

		HWND m_hWnd;
		CPolicyTemplateManager * m_pPolicyTemplateManager;
		CComPtr<IWbemClassObject>m_pIPolicyTypeClassObject;
		HWND m_hwndListView;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\somfiltermanager.cpp ===
// SomFilterManager.cpp : Implementation of CSomFilterManager
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "SomFilterManager.h"
#include "SomFilterMgrDlg.h"

extern CSomFilterManagerDlg * g_pFilterManagerDlg;

/////////////////////////////////////////////////////////////////////////////
// CSomFilterManager

CSomFilterManager::CSomFilterManager()
{
	m_hWnd = NULL;
}

//---------------------------------------------------------------------------

CSomFilterManager::~CSomFilterManager()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManager::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	_T("root\\policy"),
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManager::RunManager(HWND hwndParent, VARIANT *vSelection)
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pFilterManagerDlg = new CSomFilterManagerDlg(this);
	DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SOM_FILTER_MANAGER), (HWND)hwndParent, SomFilterManagerDlgProc);
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pFilterManagerDlg);

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CSomFilterManager::SetMultiSelection(VARIANT_BOOL vbValue)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\somfiltereditpropertiesdlg.cpp ===
//-------------------------------------------------------------------------
// File: SomFilterEditPropertiesDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "SomFilterManager.h"
#include "SomFilterEditPropertiesDlg.h"
#include "EditPropertyDlgs.h"


extern USHORT g_CIMTypes[];
extern CSimpleArray<BSTR> g_bstrCIMTypes;

CEditSomFilterPropertiesPageDlg * g_pEditSomFilterPropertiesPage =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK EditSomFilterPropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditSomFilterPropertiesPage)
	{
		return g_pEditSomFilterPropertiesPage->EditSomFilterPropertiesPageDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditSomFilterPropertiesPageDlg::CEditSomFilterPropertiesPageDlg(IWbemClassObject * pISomFilterClassObject, IWbemServices * pIWbemServices)
{
	_ASSERT(pISomFilterClassObject);
	_ASSERT(pIWbemServices);

	m_hWnd = NULL;
	m_pISomFilterClassObject = pISomFilterClassObject;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditSomFilterPropertiesPageDlg::~CEditSomFilterPropertiesPageDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditSomFilterPropertiesPageDlg::EditSomFilterPropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_IMPORT == LOWORD(wParam))
				{
					OnImport();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EXPORT == LOWORD(wParam))
				{
					OnExport();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_FILTER_PROPERTIES_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrTemp;
	
	NTDM_BEGIN_METHOD()

	//Initialize the Property List Control
	m_hwndPropertiesListView = GetDlgItem(m_hWnd, IDC_FILTER_PROPERTIES_LIST);
	NTDM_ERR_IF_NULL(m_hwndPropertiesListView);
	ListView_SetExtendedListViewStyle(m_hwndPropertiesListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NAME);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 0, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_TYPE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 1, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_VALUE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 2, &lvColumn));

	PopulateSomFilterPropertiesList();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearSomFilterPropertiesList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::ClearSomFilterPropertiesList()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ListView_DeleteAllItems(m_hwndPropertiesListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::PopulateSomFilterPropertiesList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrName;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearSomFilterPropertiesList());

	if(!m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY));

	while(true)
	{
		NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->Next(0, &bstrName, &vValue, &cimType, NULL));

		if(WBEM_S_NO_MORE_DATA == hr)
			break;

		NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType));
	}


	NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->EndEnumeration());

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 2, LVSCW_AUTOSIZE_USEHEADER));

	ListView_SetItemState(m_hwndPropertiesListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::AddItemToPropertyList(LPCTSTR pcszName, VARIANT * pvValue, CIMTYPE cimType, long lIndex)
{
	HRESULT hr;
	LVITEM lvItem;
	CComVariant vValue;
	long i;

	NTDM_BEGIN_METHOD()

	vValue = *pvValue;

	// Name
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = (LPTSTR)pcszName;

	lvItem.iItem = ListView_InsertItem(m_hwndPropertiesListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	// Type
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 1;
	lvItem.pszText = _T("");
	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		// if Array and the type contains CIM_FLAG_ARRAY then show array
		if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
		{
			lvItem.pszText = (LPTSTR)g_bstrCIMTypes[i];
			break;
		}
	}

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));


	// Value
	if FAILED(hr = VariantChangeType(&vValue, &vValue, VARIANT_ALPHABOOL|VARIANT_LOCALBOOL, VT_BSTR))
	{
		if(V_VT(&vValue) == VT_NULL)
		{
			vValue = _T("");
		}
		else
		{
			CComBSTR bstrTemp;
			bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_UNABLE_TO_DISPLAY);

			vValue = bstrTemp;
		}

		hr = NOERROR;
	}

	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 2;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndPropertiesListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_PROPERTY_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		TCHAR pszBuffer[SZ_MAX_SIZE];
		VARIANT vValue;
		CComBSTR bstrName;
		CComBSTR bstrType;
		CIMTYPE cimType;
		LVITEM lvItem;
		long i;

		VariantInit(&vValue);

		// get the property info
		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = lSelectionMark;
		lvItem.iSubItem = 0;
		lvItem.pszText = pszBuffer;
		lvItem.cchTextMax = SZ_MAX_SIZE;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndPropertiesListView, &lvItem));

		if(lvItem.pszText)
		{
			bstrName = lvItem.pszText;
			long lSpecialCaseProperty = 0;

			NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->Get(bstrName, 0, &vValue, &cimType, NULL));

			if(_tcscmp(_T("RangeSettings"), bstrName) == 0)
			{
				lSpecialCaseProperty = CEditProperty::psc_rules;
			}

			for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
			{
				// if Array and the type contains CIM_FLAG_ARRAY then show array
				if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
				{
					bstrType = (LPTSTR)g_bstrCIMTypes[i];
					break;
				}
			}

			CEditProperty dlgProps(m_hWnd, lvItem.pszText, bstrType, &vValue, m_pIWbemServices, lSpecialCaseProperty);
			if(IDOK == dlgProps.Run())
			{
				// delete the selected entry
				NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->Put(bstrName, 0, &vValue, cimType));
				NTDM_ERR_IF_FALSE(ListView_DeleteItem(m_hwndPropertiesListView, lSelectionMark));
				NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType, lSelectionMark));
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnOK()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(m_pISomFilterClassObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnImport()
{
	HRESULT hr;
	CComBSTR bstrFilter;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrTemp;

	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrFilter += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

	if(CNTDMUtils::OpenFileNameDlg(bstrFilter, _T("*.*"), m_hWnd, pszFile) && pszFile)
	{
		CComPtr<IMofCompiler>pIMofCompiler;
		CComPtr<IWbemClassObject>pINamespaceClass;
		CComPtr<IWbemClassObject>pIWbemNewInstance;
		CComPtr<IWbemClassObject>pIWbemClassObject;
		CComVariant vValue = _T("DeleteThisNamespace");
		WBEM_COMPILE_STATUS_INFO pInfo;

		// Generate a temporary namespace
		bstrTemp = _T("__Namespace");
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pINamespaceClass, NULL));
		NTDM_ERR_MSG_IF_FAIL(pINamespaceClass->SpawnInstance(0, &pIWbemNewInstance));
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(pIWbemNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

		// mofcomp the file into that namespace
		NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,IID_IMofCompiler, (void**)&pIMofCompiler));
		NTDM_ERR_IF_FAIL(pIMofCompiler->CompileFile(pszFile, _T("\\\\.\\root\\policy\\DeleteThisNamespace"), NULL, NULL, NULL, WBEM_FLAG_DONT_ADD_TO_LIST, WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_CREATE_ONLY, &pInfo));

		if(hr != WBEM_S_NO_ERROR)
		{
			CNTDMUtils::DisplayMessage(m_hWnd, IDS_FAILED_COMPILING_MOF_FILE);
			NTDM_EXIT(E_FAIL);
		}

		// get the 1st instance of MSFT_SomFilter from the newly created namespace
		NTDM_ERR_IF_FAIL(GetInstanceOfClass(bstrTemp, _T("MSFT_SomFilter"), &pIWbemClassObject));

		// copy the properties
		m_pISomFilterClassObject = pIWbemClassObject;
		PopulateSomFilterPropertiesList();
	}

	NTDM_END_METHOD()

	// finally delete the namespace that we created above
	{
		CComVariant vValue = "\\\\.\\root\\policy:__Namespace.Name=\"DeleteThisNamespace\"";
		m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL);
	}

	return hr;
}


//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject)
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;
	CComPtr<IWbemServices>pIWbemServices;
	CComPtr<IEnumWbemClassObject>pEnumWbemClassObject;
	CComBSTR bstrClass = _T("MSFT_SomFilter");
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	pszNamespace,
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	NTDM_ERR_MSG_IF_FAIL(pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));
	NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, ppWbemClassObject, &uReturned));

	if(!uReturned)
		NTDM_EXIT(E_FAIL);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}



//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnExport()
{
	HRESULT hr;
	CComBSTR bstrTemp;
	CComBSTR bstrFilter;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrObjectText;
	HANDLE hFile = NULL;
	DWORD dwWritten;
	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_TEXT_FILES_FILTER);
	bstrFilter += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

	if(CNTDMUtils::SaveFileNameDlg(bstrFilter, _T("*.txt"), m_hWnd, pszFile))
	{
		if(_tcslen(pszFile))
		{
			NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->GetObjectText(0, &bstrObjectText));

			// save to pszFile
			hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
							   NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(hFile == INVALID_HANDLE_VALUE)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(NULL);
				goto error;
			}

			if(hFile)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrObjectText, _tcslen(bstrObjectText) * sizeof(TCHAR), &dwWritten, NULL));
				NTDM_ERR_GETLASTERROR_IF_NULL(CloseHandle(hFile));
				hFile = NULL;
			}
		}
	}

	NTDM_END_METHOD()

	// cleanup
	if(hFile)
	{
		CloseHandle(hFile);
		hFile = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\somfiltermanager.h ===
// SomFilterManager.h : Declaration of the CSomFilterManager

#ifndef __SOMFILTERMANAGER_H_
#define __SOMFILTERMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSomFilterManager
class ATL_NO_VTABLE CSomFilterManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSomFilterManager, &CLSID_SomFilterManager>,
	public IDispatchImpl<ISomFilterManager, &IID_ISomFilterManager, &LIBID_SCHEMAMANAGERLib>
{
public:
	CSomFilterManager();
	~CSomFilterManager();

DECLARE_REGISTRY_RESOURCEID(IDR_SOMFILTERMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSomFilterManager)
	COM_INTERFACE_ENTRY(ISomFilterManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISomFilterManager
public:
	STDMETHOD(SetMultiSelection)(VARIANT_BOOL vbValue);
	STDMETHOD(RunManager)(HWND hwndParent, VARIANT *vSelection);
	STDMETHOD(ConnectToWMI)();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__SOMFILTERMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\somfiltereditpropertiesdlg.h ===
//-------------------------------------------------------------------------
// File: SomFilterEditPropertiesDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditSomFilterPropertiesPageDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CSomFilterManager;

class CEditSomFilterPropertiesPageDlg
{
	public:
		CEditSomFilterPropertiesPageDlg(IWbemClassObject * pISomFilterClassObject, IWbemServices * pIWbemServices);
		~CEditSomFilterPropertiesPageDlg();
		INT_PTR CALLBACK EditSomFilterPropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP PopulateSomFilterPropertiesList();
		STDMETHODIMP AddItemToPropertyList(LPCTSTR pcszName, VARIANT * vValue, CIMTYPE cimType, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP ClearSomFilterPropertiesList();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnOK();
		STDMETHODIMP OnImport();
		STDMETHODIMP OnExport();
		STDMETHODIMP GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject);

		HWND m_hWnd;
		HWND m_hwndPropertiesListView;
		CSomFilterManager *m_pSomFilterManager;
		CComPtr<IWbemClassObject>m_pISomFilterClassObject;
		CComPtr<IWbemServices>m_pIWbemServices;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D8675B3F_E62E_41AE_BF56_5ABB01A74371__INCLUDED_)
#define AFX_STDAFX_H__D8675B3F_E62E_41AE_BF56_5ABB01A74371__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <strsafe.h>

#endif // !defined(AFX_STDAFX_H__D8675B3F_E62E_41AE_BF56_5ABB01A74371__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\somfiltermgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: CDlgSomFilterManager.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "SomFilterManager.h"
#include "SomFilterMgrDlg.h"
#include "SomFilterEditPropertiesDlg.h"

CSomFilterManagerDlg * g_pFilterManagerDlg =  NULL;
extern CEditSomFilterPropertiesPageDlg * g_pEditSomFilterPropertiesPage;

//-------------------------------------------------------------------------

INT_PTR CALLBACK SomFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pFilterManagerDlg)
	{
		return g_pFilterManagerDlg->SomFilterManagerDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CSomFilterManagerDlg::CSomFilterManagerDlg(CSomFilterManager * pSomFilterManager)
{
	_ASSERT(pSomFilterManager);

	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pSomFilterManager = pSomFilterManager;
}

//-------------------------------------------------------------------------

CSomFilterManagerDlg::~CSomFilterManagerDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CSomFilterManagerDlg::SomFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				PopulateFilterList();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDCANCEL:
					EndDialog(m_hWnd, 0);
					return TRUE;

				case IDOK:
					OnOK();
					return TRUE;
					break;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_NEW == LOWORD(wParam))
				{
					OnNew();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;

			switch (lpnm->code)
			{
				case NM_DBLCLK :
				{
					if(lpnm->idFrom == IDC_SOM_FILTER_LIST)
					{
						OnEdit();
						return TRUE;
					}
					break;
				}

				default :
					break;
			}
		}

	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;
	
	NTDM_BEGIN_METHOD()

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_SOM_FILTER_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearFilterList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::ClearFilterList()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::PopulateFilterList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrClass(_T("MSFT_SomFilter"));
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	if(!m_pSomFilterManager->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_IF_FAIL(ClearFilterList());

	// Get the Enumeration
	NTDM_ERR_MSG_IF_FAIL(m_pSomFilterManager->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddItemToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	NTDM_ERR_IF_MINUSONE(ListView_InsertItem(m_hwndListView, &lvItem));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			g_pEditSomFilterPropertiesPage = new CEditSomFilterPropertiesPageDlg((IWbemClassObject *)lvItem.lParam, m_pSomFilterManager->m_pIWbemServices);

			if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SOM_FILTER_PROPERTIES), m_hWnd, EditSomFilterPropertiesPageDlgProc))
			{
				// Refresh the SOM filters
				NTDM_ERR_IF_FAIL(PopulateFilterList());
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			CComVariant vValue;
			CIMTYPE cimType;

			IWbemClassObject * pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			
			NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));
			NTDM_ERR_MSG_IF_FAIL(m_pSomFilterManager->m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));

			// Refresh the SOM filters
			NTDM_ERR_IF_FAIL(PopulateFilterList());
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::OnNew()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_SomFilter");

	NTDM_ERR_MSG_IF_FAIL(m_pSomFilterManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	g_pEditSomFilterPropertiesPage = new CEditSomFilterPropertiesPageDlg(pIWbemNewInstance, m_pSomFilterManager->m_pIWbemServices);

	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SOM_FILTER_PROPERTIES), m_hWnd, EditSomFilterPropertiesPageDlgProc))
	{
		// Refresh the SOM filters
		NTDM_ERR_IF_FAIL(PopulateFilterList());
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

BOOL CSomFilterManagerDlg::OnOK()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			m_pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			m_pIWbemClassObject->AddRef();
		}
	}

	EndDialog(m_hWnd, IDOK);

	NTDM_END_METHOD()

	// cleanup

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifilterbrowser.cpp ===
// WMIFilterBrowser.cpp : Implementation of CWMIFilterBrowser
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "WMIFilterBrowser.h"
#include "WMIFilterBrowserDlg.h"

extern CWMIFilterBrowserDlg * g_pWMIFilterBrowserDlg;

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterBrowser

CWMIFilterBrowser::CWMIFilterBrowser()
{
}

//--------------------------------------------------------------------------

CWMIFilterBrowser::~CWMIFilterBrowser()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowser::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	_T("root\\policy"),
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowser::RunBrowser(HWND hwndParent, VARIANT *vSelection)
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pWMIFilterBrowserDlg = new CWMIFilterBrowserDlg(this);
	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_WMI_FILTER_BROWSER), (HWND)hwndParent, WMIFilterBrowserDlgProc))
	{
		VariantClear(vSelection);

		V_VT(vSelection) = VT_UNKNOWN;
		NTDM_ERR_IF_FAIL(g_pWMIFilterBrowserDlg->m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&(V_UNKNOWN(vSelection))));
	}
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pWMIFilterBrowserDlg);

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowser::SetMultiSelection(VARIANT_BOOL vbValue)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifilterbrowser.h ===
// WMIFilterBrowser.h : Declaration of the CWMIFilterBrowser

#ifndef __WMIFILTERBROWSER_H_
#define __WMIFILTERBROWSER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterBrowser
class ATL_NO_VTABLE CWMIFilterBrowser : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIFilterBrowser, &CLSID_WMIFilterBrowser>,
	public IDispatchImpl<IWMIFilterBrowser, &IID_IWMIFilterBrowser, &LIBID_SCHEMAMANAGERLib>
{
public:
	CWMIFilterBrowser();
	~CWMIFilterBrowser();

DECLARE_REGISTRY_RESOURCEID(IDR_WMIFILTERBROWSER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIFilterBrowser)
	COM_INTERFACE_ENTRY(IWMIFilterBrowser)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWMIFilterBrowser
public:
	STDMETHOD(SetMultiSelection)(VARIANT_BOOL vbValue);
	STDMETHOD(RunBrowser)(HWND hwndParent, VARIANT *vSelection);
	STDMETHODIMP ConnectToWMI();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__WMIFILTERBROWSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\somfiltermgrdlg.h ===
//-------------------------------------------------------------------------
// File: CDlgQuestionnaire.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK SomFilterManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CSomFilterManager;

class CSomFilterManagerDlg
{
	public:
		CSomFilterManagerDlg(CSomFilterManager * pSomFilterManager);
		~CSomFilterManagerDlg();
		INT_PTR CALLBACK SomFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

		IWbemClassObject * m_pIWbemClassObject;

	protected:
		
		STDMETHODIMP PopulateFilterList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnKillActive();
		STDMETHODIMP OnNew();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();
		STDMETHODIMP ClearFilterList();
		BOOL OnOK();

		HWND m_hWnd;
		CSomFilterManager * m_pSomFilterManager;
		HWND m_hwndListView;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifilterbrowserdlg.cpp ===
//-------------------------------------------------------------------------
// File: WMIFilterBrowserDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "WMIFilterBrowser.h"
#include "WMIFilterBrowserDlg.h"
#include "DlgFilterProperties.h"

CWMIFilterBrowserDlg * g_pWMIFilterBrowserDlg =  NULL;
extern CFilterPropertiesDlg * g_pFilterProperties;

//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterBrowserDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pWMIFilterBrowserDlg)
	{
		return g_pWMIFilterBrowserDlg->WMIFilterBrowserDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CWMIFilterBrowserDlg::CWMIFilterBrowserDlg(CWMIFilterBrowser * pWMIFilterBrowser)
{
	_ASSERT(pWMIFilterBrowser);

	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pIWbemClassObject = NULL;
	m_pWMIFilterBrowser = pWMIFilterBrowser;
}

//-------------------------------------------------------------------------

CWMIFilterBrowserDlg::~CWMIFilterBrowserDlg()
{
	NTDM_RELEASE_IF_NOT_NULL(m_pIWbemClassObject);
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CWMIFilterBrowserDlg::WMIFilterBrowserDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();
				PopulateFilterList();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				if(BN_CLICKED == HIWORD(wParam) && IDC_VIEW == LOWORD(wParam))
				{
					ViewSelectedItem();
				}

				switch(LOWORD(wParam))
				{
				case IDOK:
					OnOK();
					return TRUE;
					break;

				case IDCANCEL:
					EndDialog(m_hWnd, IDCANCEL);
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;

			switch (lpnm->code)
			{
				case NM_DBLCLK :
				{
					if(lpnm->idFrom == IDC_ALL_FILTERS)
					{
						ViewSelectedItem();
						return TRUE;
					}
					break;
				}

				default :
					break;
			}
		}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;
	
	NTDM_BEGIN_METHOD()

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_ALL_FILTERS);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::DestroyDialog()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

BOOL CWMIFilterBrowserDlg::OnOK()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			m_pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			m_pIWbemClassObject->AddRef();
		}
	}

	EndDialog(m_hWnd, IDOK);

	NTDM_END_METHOD()

	// cleanup

	return TRUE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::PopulateFilterList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrClass(_T("MSFT_SomFilter"));
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	if(!m_pWMIFilterBrowser->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	// Get the Enumeration
	NTDM_ERR_IF_FAIL(m_pWMIFilterBrowser->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddItemToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::AddItemToList(IWbemClassObject * pIWbemClassObject)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = 0;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	NTDM_ERR_IF_MINUSONE(ListView_InsertItem(m_hwndListView, &lvItem));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::ViewSelectedItem()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			g_pFilterProperties = new CFilterPropertiesDlg(m_pWMIFilterBrowser->m_pIWbemServices, (IWbemClassObject *)lvItem.lParam);
			DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_FILTER_PROPERTIES), m_hWnd, FilterPropertiesDlgProc);
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifiltermanager.h ===
// WMIFilterManager.h : Declaration of the CWMIFilterManager

#ifndef __WMIFILTERMANAGER_H_
#define __WMIFILTERMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterManager
class ATL_NO_VTABLE CWMIFilterManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIFilterManager, &CLSID_WMIFilterManager>,
	public IDispatchImpl<IWMIFilterManager, &IID_IWMIFilterManager, &LIBID_SCHEMAMANAGERLib>
{
public:
	CWMIFilterManager();
	~CWMIFilterManager();

DECLARE_REGISTRY_RESOURCEID(IDR_WMIFILTERMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIFilterManager)
	COM_INTERFACE_ENTRY(IWMIFilterManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWMIFilterManager
public:
	STDMETHOD(SetMultiSelection)(VARIANT_BOOL vbValue);
	STDMETHOD(RunManager)(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection);
	STDMETHOD(RunBrowser)(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection);
	STDMETHOD(ConnectToWMI)();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__WMIFILTERMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifilterbrowserdlg.h ===
//-------------------------------------------------------------------------
// File: CDlgQuestionnaire.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterBrowserDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CWMIFilterBrowser;

class CWMIFilterBrowserDlg
{
	public:
		CWMIFilterBrowserDlg(CWMIFilterBrowser * pWMIFilterBrowser);
		~CWMIFilterBrowserDlg();
		INT_PTR CALLBACK WMIFilterBrowserDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

		IWbemClassObject * m_pIWbemClassObject;

	protected:
		
		STDMETHODIMP PopulateFilterList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnOK();
		STDMETHODIMP ViewSelectedItem();

		HWND m_hWnd;
		HWND m_hwndListView;
		CWMIFilterBrowser * m_pWMIFilterBrowser;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifiltermanager.cpp ===
// WMIFilterManager.cpp : Implementation of CWMIFilterManager
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "WMIFilterManager.h"
#include "WMIFilterMgrDlg.h"

extern CWMIFilterManagerDlg * g_pFilterManagerDlg;

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterManager

CWMIFilterManager::CWMIFilterManager()
{
    m_pIWbemServices = NULL;
	m_hWnd = NULL;
}

//---------------------------------------------------------------------------

CWMIFilterManager::~CWMIFilterManager()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;
	CComBSTR bstrRootPolicy( L"root\\policy" );

	if ( bstrRootPolicy.m_str == NULL )
	{
	    return E_OUTOFMEMORY;
	}

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	bstrRootPolicy,
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::RunManager(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection)
{
	HRESULT hr;

	g_pFilterManagerDlg = NULL;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pFilterManagerDlg = new CWMIFilterManagerDlg(this, false, bstrDomain);
	NTDM_ERRID_IF_NULL(g_pFilterManagerDlg, E_OUTOFMEMORY);

	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_WMI_FILTER_MANAGER), (HWND)hwndParent, WMIFilterManagerDlgProc))
	{
		if(g_pFilterManagerDlg->m_pIWbemClassObject)
		{
			VariantClear(vSelection);

			V_VT(vSelection) = VT_UNKNOWN;
			NTDM_ERR_MSG_IF_FAIL(g_pFilterManagerDlg->m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&(V_UNKNOWN(vSelection))));
		}
		else
			hr = S_FALSE;
	}
	else
	{
		hr = S_FALSE;
	}
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pFilterManagerDlg);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::RunBrowser(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection)
{
	HRESULT hr;

	g_pFilterManagerDlg = NULL;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());
	
	//brijeshb: wrap with macro for bug 228812 prefix bug. 	
	NTDM_ERR_IF_NULL((g_pFilterManagerDlg = new CWMIFilterManagerDlg(this, true, bstrDomain)));
	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_WMI_FILTER_BROWSER), (HWND)hwndParent, WMIFilterManagerDlgProc))
	{
		if(g_pFilterManagerDlg->m_pIWbemClassObject)
		{
			VariantClear(vSelection);

			V_VT(vSelection) = VT_UNKNOWN;
			NTDM_ERR_MSG_IF_FAIL(g_pFilterManagerDlg->m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&(V_UNKNOWN(vSelection))));
		}
		else
			hr = S_FALSE;
	}
	else
	{
		hr = S_FALSE;
	}
	
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pFilterManagerDlg);

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::SetMultiSelection(VARIANT_BOOL vbValue)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\prerelease.inc ===
#
# This file is used to control build options that should only appear in
# internal releases, and NOT the beta or RTM releases.  This controls
# features such as the GUI mode command prompt and the Win9x upgrade
# autostress option.
#
# To change, simply set PRERELEASE to 1 for private builds, or 0 for beta
# or RTM builds.
#
# **CHANGES HERE WILL REQUIRE A CLEAN BUILD OF THE SETUP, pnp and ntdll components **
#

!ifndef PRERELEASE
PRERELEASE=0
!endif

!if $(PRERELEASE)
C_DEFINES=$(C_DEFINES) -DPRERELEASE
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifiltermgrdlg.h ===
//-------------------------------------------------------------------------
// File: WMIFilterMgrDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

#define MAX_WMIFILTER_COLUMNS 5
#define NAME_WIDTH 60
#define DESCRIPTION_WIDTH 188
#define AUTHOR_WIDTH 100
#define CHANGE_DATE_WIDTH 80
#define CREATION_DATE_wIDTH 80



class CWMIFilterManager;
class CWMIFilterContainer;
class CColumnItem;

class CWMIFilterManagerDlg
{
	public:
		CWMIFilterManagerDlg(CWMIFilterManager * pWMIFilterManager, bool bBrowsing=false, BSTR bstrDomain=NULL);
		~CWMIFilterManagerDlg();
		INT_PTR CALLBACK WMIFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

		IWbemClassObject * m_pIWbemClassObject;

	protected:
		
		STDMETHODIMP PopulateFilterList();
		STDMETHODIMP AddFilterItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS, bool bSelect=false);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnKillActive();
		STDMETHODIMP OnNew();
		STDMETHODIMP OnDelete();
		STDMETHODIMP ClearFilterList();
		BOOL OnOK();
		STDMETHODIMP GetSelectedFilter(CWMIFilterContainer ** ppCWMIFilterContainer, long lIndex=-1);
		STDMETHODIMP SelectFilterItem(long lIndex);
		STDMETHODIMP ToggleExpandedMode();
		STDMETHODIMP OnSave();
		STDMETHODIMP OnExport();
		STDMETHODIMP OnImport();
		STDMETHODIMP CheckDirtyFlags();
		//STDMETHODIMP PopulateQueryList();
		//STDMETHODIMP UpdateQueryList();
		//STDMETHODIMP AddQueryItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
                //STDMETHODIMP OnEditQuery();
		//STDMETHODIMP OnAddQuery();
		//STDMETHODIMP OnDeleteQuery();
		//STDMETHODIMP ClearQueryList();
		STDMETHODIMP OnManageColumns();
		STDMETHODIMP SetupColumns();
		STDMETHODIMP UpdateFilterItem(long lIndex);
		STDMETHODIMP PopulateQueryEdit();
		STDMETHODIMP AddQueryItemToString(IWbemClassObject * pIWbemClassObject, CComBSTR& bstrQueries);
		STDMETHODIMP SaveQueryEdit();
		STDMETHODIMP AddEditQueryString(BSTR bstrQuery, void **ppUnk, BSTR bstrNamespace=NULL);
		STDMETHODIMP SaveToMemory();
		STDMETHODIMP OnDuplicate();
		STDMETHODIMP OnHelp();

		HWND m_hWnd;
		CWMIFilterManager * m_pWMIFilterManager;
		HWND m_hwndFilterListView;
                DWORD m_dwColumnWidth[MAX_WMIFILTER_COLUMNS];
		HWND m_hwndQueryListView;
		CComPtr<IWbemClassObject> m_pCurIWbemClassObj;
		bool m_bExpanded;
		long m_lExpandedHeight;
		CWMIFilterContainer * m_pCurCWMIFilterContainer;
		bool m_bBrowsing;
		CSimpleArray<CColumnItem*> m_ArrayColumns;
		CComBSTR m_bstrDomain;
};

class CWMIFilterContainer
{
	public:
		CWMIFilterContainer() { m_bDirty = false; m_bMemoryDirty = false;}
		~CWMIFilterContainer() {}

		bool IsDirty() { return m_bDirty; }
		void SetDirtyFlag(bool value) { m_bDirty = value; }
		bool IsMemoryDirty() { return m_bMemoryDirty; }
		void SetMemoryDirtyFlag(bool value) { m_bMemoryDirty = value; }
		
		STDMETHODIMP GetIWbemClassObject(IWbemClassObject ** ppIWbemClassObject) 
		{ 
			if(!m_pIWbemClassObject)
				return E_FAIL;

			return m_pIWbemClassObject->QueryInterface(IID_IWbemClassObject, (void **)ppIWbemClassObject);
		}

		STDMETHODIMP SetIWbemClassObject(IWbemClassObject * pIWbemClassObject)
		{
			if(!pIWbemClassObject)
			{
				m_pIWbemClassObject = NULL;
				return NOERROR;
			}
			else
			{
				return pIWbemClassObject->QueryInterface(IID_IWbemClassObject, (void **)&m_pIWbemClassObject);
			}
		}

	protected:
		bool m_bDirty;
		bool m_bMemoryDirty;
		CComPtr<IWbemClassObject>m_pIWbemClassObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmiscmgr\wmifiltermgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: WMIFilterMgrDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "ColumnMgrDlg.h"
#include "WMIFilterManager.h"
#include "WMIFilterMgrDlg.h"
#include "EditPropertyDlgs.h"
#include "HtmlHelp.h"

CWMIFilterManagerDlg * g_pFilterManagerDlg =  NULL;
extern CColumnManagerDlg * g_pColumnManagerDlg;

//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    if(g_pFilterManagerDlg)
    {
        return g_pFilterManagerDlg->WMIFilterManagerDlgProc(hDlg, iMessage, wParam, lParam);
    }

    return FALSE;
}

//-------------------------------------------------------------------------

CWMIFilterManagerDlg::CWMIFilterManagerDlg(CWMIFilterManager * pWMIFilterManager, bool bBrowsing, BSTR bstrDomain)
{
    _ASSERT(pWMIFilterManager);

    m_pIWbemClassObject = NULL;

    m_hWnd = NULL;
    m_hwndFilterListView = NULL;
    m_hwndQueryListView = NULL;
    m_pWMIFilterManager = pWMIFilterManager;
    m_bExpanded = true;
    m_lExpandedHeight = 0;
    m_pCurCWMIFilterContainer = NULL;
    m_bBrowsing = bBrowsing;
    m_bstrDomain = bstrDomain;
    m_dwColumnWidth[0] = NAME_WIDTH;
    m_dwColumnWidth[1] = DESCRIPTION_WIDTH;
    m_dwColumnWidth[2] = AUTHOR_WIDTH;
    m_dwColumnWidth[3] = CHANGE_DATE_WIDTH;
    m_dwColumnWidth[4] = CREATION_DATE_wIDTH;
}

//-------------------------------------------------------------------------

CWMIFilterManagerDlg::~CWMIFilterManagerDlg()
{
    long i;
    HRESULT hr;
    
    NTDM_BEGIN_METHOD()

    for(i=0; i<m_ArrayColumns.GetSize(); i++)
    {
            NTDM_DELETE_OBJECT(m_ArrayColumns[i]);
    }

    NTDM_END_METHOD()

    // cleanup
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CWMIFilterManagerDlg::WMIFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    LPPSHNOTIFY lppsn = NULL;
    HRESULT hr;

    switch(iMessage)
    {
        case WM_INITDIALOG:
            {
                m_hWnd = hDlg;

                InitializeDialog();

                PopulateFilterList();

                break;
            }

        case WM_KEYDOWN:
            {
                if(wParam == VK_F1)
                    OnHelp();

                break;
            }

        case WM_DESTROY:
            {
                DestroyDialog();
                break;
            }

        case WM_CLOSE:
            {
                if(SUCCEEDED(hr=CheckDirtyFlags()))
                {
                    EndDialog(m_hWnd, 0);
                }
                return 0;
            }

        case WM_COMMAND:
            {
                switch(LOWORD(wParam))
                {
                case IDCANCEL:
                    if(SUCCEEDED(hr=CheckDirtyFlags()))
                    {
                        EndDialog(m_hWnd, 0);
                    }
                    return 0;

                case IDOK:
                    OnOK();
                    return TRUE;
                    break;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_NEW == LOWORD(wParam))
                {
                    OnNew();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
                {
                    OnDelete();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_DUPLICATE == LOWORD(wParam))
                {
                    OnDuplicate();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_ADVANCED == LOWORD(wParam))
                {
                    ToggleExpandedMode();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_HELP2 == LOWORD(wParam))
                {
                    OnHelp();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_SAVE == LOWORD(wParam))
                {
                    SetFocus(GetDlgItem(hDlg, IDC_SAVE));
                    OnSave();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_IMPORT == LOWORD(wParam))
                {
                    OnImport();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_EXPORT == LOWORD(wParam))
                {
                    OnExport();
                    return TRUE;
                }

                if(BN_CLICKED == HIWORD(wParam) && IDC_COLUMNS == LOWORD(wParam))
                {
                    OnManageColumns();
                    return TRUE;
                }

                if(EN_KILLFOCUS == HIWORD(wParam) &&    (
                                                        IDC_NAME == LOWORD(wParam) || 
                                                        IDC_DESCRIPTION == LOWORD(wParam) || 
                                                        IDC_QUERIES == LOWORD(wParam)
                                                        ))
                {
                    SaveToMemory();
                    return TRUE;
                }

                if(EN_CHANGE == HIWORD(wParam) &&   (
                                                        IDC_NAME == LOWORD(wParam) || 
                                                        IDC_DESCRIPTION == LOWORD(wParam) || 
                                                        IDC_QUERIES == LOWORD(wParam)
                                                        ))
                {
                    if(m_pCurCWMIFilterContainer)
                    {
                        m_pCurCWMIFilterContainer->SetDirtyFlag(true);
                        m_pCurCWMIFilterContainer->SetMemoryDirtyFlag(true);
                    }
                    return TRUE;
                }

                break;
            }

        case WM_NOTIFY:
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            if(IDC_WMI_FILTER_LIST == lpnm->idFrom)
            {
                switch (lpnm->code)
                {
                    case LVN_ITEMCHANGED:
                    {
                        LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;

                        if(pnmv->uChanged & LVIF_STATE)
                        {
                            if(LVIS_SELECTED & pnmv->uNewState && !(LVIS_SELECTED & pnmv->uOldState))
                            {
                                SaveToMemory();
                                if FAILED(SelectFilterItem(pnmv->iItem))
                                    return TRUE;
                                else
                                    return FALSE;
                            }
                        }

                        break;
                    }

                    default :
                        break;
                }
            }
        }
    }

    return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::InitializeDialog()
{
    HRESULT hr;
    LVCOLUMN lvColumn;
    CComBSTR bstrName;
    CComBSTR bstrQuery;
    CComBSTR bstrTemp;
    RECT rect;
    CColumnItem * pNewColumnItem;
    
    NTDM_BEGIN_METHOD()
            
    bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION);
    pNewColumnItem = new CColumnItem(bstrTemp, _T("Description"), true);
    m_ArrayColumns.Add(pNewColumnItem);
    bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_AUTHOR);
    pNewColumnItem = new CColumnItem(bstrTemp, _T("Author"), true);
    m_ArrayColumns.Add(pNewColumnItem);
    bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_CHANGE_DATE);
    pNewColumnItem = new CColumnItem(bstrTemp, _T("ChangeDate"), true);
    m_ArrayColumns.Add(pNewColumnItem);
    bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_CREATION_DATE);
    pNewColumnItem = new CColumnItem(bstrTemp, _T("CreationDate"), true);
    m_ArrayColumns.Add(pNewColumnItem);

    bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);
    bstrQuery.LoadString(_Module.GetResourceInstance(), IDS_QUERY);

    GetWindowRect(m_hWnd, &rect);
    m_lExpandedHeight = rect.bottom - rect.top;

    ToggleExpandedMode();

    //Initialize the ListView Control
    m_hwndFilterListView = GetDlgItem(m_hWnd, IDC_WMI_FILTER_LIST);
    NTDM_ERR_IF_NULL(m_hwndFilterListView);

    ListView_SetExtendedListViewStyle(m_hwndFilterListView, LVS_EX_FULLROWSELECT);

    lvColumn.mask = LVCF_TEXT|LVCF_FMT;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.pszText = bstrName;

    NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndFilterListView, 0, &lvColumn));

    NTDM_ERR_IF_FAIL(SetupColumns());

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::DestroyDialog()
{
    HRESULT hr;

    NTDM_BEGIN_METHOD()

    NTDM_ERR_IF_FAIL(ClearFilterList());

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::ClearFilterList()
{
    HRESULT hr;
    LVITEM lvItem;
    long lCount;

    NTDM_BEGIN_METHOD()

    //Release each item in the ListView Control
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;

    lCount = ListView_GetItemCount(m_hwndFilterListView);

    while(lCount > 0)
    {
        lCount--;

        lvItem.iItem = lCount;

        NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

        if(lvItem.lParam)
        {
            CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
            NTDM_DELETE_OBJECT(pCWMIFilterContainer);
        }
    }

    ListView_DeleteAllItems(m_hwndFilterListView);

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::PopulateFilterList()
{
    HRESULT hr;
    CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
    CComBSTR bstrQueryLanguage(_T("WQL"));
    CComBSTR bstrQuery;
    ULONG uReturned;
    long i = 0;
    long lCount = 0;

    NTDM_BEGIN_METHOD()

    bstrQuery = _T("select * from MSFT_SomFilter where domain=\"");
    bstrQuery += m_bstrDomain;
    bstrQuery += _T("\"");

    if(!m_pWMIFilterManager->m_pIWbemServices)
        NTDM_EXIT(E_FAIL);

    NTDM_ERR_IF_FAIL(ClearFilterList());

    // Get the Enumeration
    // CComBSTR bstrClass(_T("MSFT_SomFilter"));
    // NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

    // Query for filters in provided domain
    NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->ExecQuery(bstrQueryLanguage, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

    // Loop through each item in the enumeration and add it to the list
    while(pEnumWbemClassObject)
    {
        IWbemClassObject *pIWbemClassObject = NULL;

        NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

        if(!uReturned)
            break;

        // Add current Item to the list
        AddFilterItemToList(pIWbemClassObject);

        pIWbemClassObject->Release();

        lCount++;
    }

    // disable OK if 0 items
    //Also disable the name, description and query edit controls
    if(0 == lCount)
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);

    }
    else
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), TRUE);
    }

    // auto size columns

        i = 0;
    while (true)
    {
           if (!ListView_SetColumnWidth(m_hwndFilterListView, i++, m_dwColumnWidth[i]))
               break;
    }

    ListView_SetItemState(m_hwndFilterListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::AddFilterItemToList(IWbemClassObject * pIWbemClassObject, long lIndex, bool bSelect)
{
    HRESULT hr;
    CComVariant vValue;
    CIMTYPE vType;
    LVITEM lvItem;
    CWMIFilterContainer * pFilterContainer = NULL;

    NTDM_BEGIN_METHOD()

    pFilterContainer = new CWMIFilterContainer();
    pFilterContainer->SetIWbemClassObject(pIWbemClassObject);

    NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

    lvItem.mask = LVIF_TEXT|LVIF_PARAM;
    lvItem.iItem = lIndex;
    lvItem.iSubItem = 0;
    lvItem.pszText = vValue.bstrVal;
    lvItem.lParam = (LPARAM)pFilterContainer;

    lIndex = ListView_InsertItem(m_hwndFilterListView, &lvItem);
    NTDM_ERR_IF_MINUSONE(lIndex);

    UpdateFilterItem(lIndex);

    if(bSelect)
    {
        ListView_SetItemState(m_hwndFilterListView, lIndex, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
        ListView_SetSelectionMark(m_hwndFilterListView, lIndex);
    }

    pIWbemClassObject->AddRef();

    NTDM_END_METHOD()

    // cleanup
    if FAILED(hr)
        NTDM_DELETE_OBJECT(pFilterContainer);

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::UpdateFilterItem(long lIndex)
{
    HRESULT hr;
    LVITEM lvItem;
    CComVariant vValue;
    CIMTYPE cimType;
    long i;
    long lCount = 0;

    NTDM_BEGIN_METHOD()

    //Release each item in the ListView Control
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = lIndex;
    lvItem.iSubItem = 0;

    NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

    if(lvItem.lParam)
    {
        CComPtr<IWbemClassObject>pIWbemClassObject;

        CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
        NTDM_ERR_IF_FAIL(pCWMIFilterContainer->GetIWbemClassObject(&pIWbemClassObject));

        NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &cimType, NULL));
        ListView_SetItemText(m_hwndFilterListView, lIndex, 0, V_BSTR(&vValue));

        // for each selected item in the columns array add the property
        for(i=0; i<m_ArrayColumns.GetSize(); i++)
        {
            if(m_ArrayColumns[i]->IsSelected())
            {
                lCount++;
                vValue.Clear();

                NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(m_ArrayColumns[i]->GetPropertyName(), 0, &vValue, &cimType, NULL));

                if(vValue.vt != VT_BSTR)
                    continue;

                if(cimType != CIM_DATETIME)
                {
                    ListView_SetItemText(m_hwndFilterListView, lIndex, lCount, V_BSTR(&vValue));
                }
                else
                {
                    //convert to readable date
                    CComBSTR bstrTemp;
                    TCHAR *pszCur = V_BSTR(&vValue);
                    TCHAR pszYear[5];
                    TCHAR pszMonth[3];
                    TCHAR pszDay[3];
                    
                    _tcsncpy(pszYear, pszCur, 4);
                    pszYear[4] = 0;
                    pszCur += 4;
                    _tcsncpy(pszMonth, pszCur, 2);
                    pszMonth[2] = 0;
                    pszCur += 2;
                    _tcsncpy(pszDay, pszCur, 2);
                    pszDay[2] = 0;

                    bstrTemp = pszMonth;
                    bstrTemp += _T("\\");
                    bstrTemp += pszDay;
                    bstrTemp += _T("\\");
                    bstrTemp += pszYear;

                    vValue = bstrTemp;
                    ListView_SetItemText(m_hwndFilterListView, lIndex, lCount, V_BSTR(&vValue));
                }
            }
        }
    }

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnDelete()
{
    HRESULT hr;
    CComVariant vValue;
    CIMTYPE cimType;
    long lSelectionMark;
    LVITEM lvItem;
    long lCount;

    NTDM_BEGIN_METHOD()

    if(!m_pCurIWbemClassObj)
    {
        CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
        NTDM_EXIT(E_FAIL);
    }

    if(IDNO == CNTDMUtils::DisplayMessage(m_hWnd, IDS_CONFIRM_DELETE_FILTER, IDS_DELETE_FILTER, MB_YESNO|MB_ICONWARNING))
    {
        NTDM_EXIT(E_FAIL);
    }

    NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));

    if(NOTEMPTY_BSTR_VARIANT(&vValue))
    {
        NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));
    }
    else
    {
        // This item was a new item that was never saved so no need to remove it from the CIM
    }

    lSelectionMark = ListView_GetSelectionMark(m_hwndFilterListView);
    lvItem.iItem = lSelectionMark;
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;

    NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

    if(lvItem.lParam)
    {
        CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
        NTDM_DELETE_OBJECT(pCWMIFilterContainer);
    }

    ListView_DeleteItem(m_hwndFilterListView, lSelectionMark);
    m_pCurCWMIFilterContainer = NULL;
    m_pCurIWbemClassObj = NULL;
    
    ListView_SetItemState(m_hwndFilterListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
        
    // disable OK if last item
    lCount = ListView_GetItemCount(m_hwndFilterListView);
    if(0 == lCount)
    {
                EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
                EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), TRUE);
    }


    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnNew()
{
    HRESULT hr;
    CComPtr<IWbemClassObject>pIWbemClassObject;
    CComPtr<IWbemClassObject>pIWbemNewInstance;
    CComBSTR bstrTemp;
    CComVariant vValue;
    TCHAR pszTemp[100];
    GUID guid;
    DWORD nSize = 100;
    SYSTEMTIME systemTime;
    long lCount = 0;

    NTDM_BEGIN_METHOD()

    bstrTemp = _T("MSFT_SomFilter");

    NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
    NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

    bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NEW_FILTER_NAME);
    vValue = bstrTemp;

    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
    NTDM_ERR_MSG_IF_FAIL(CoCreateGuid(&guid));
    StringFromGUID2(guid, pszTemp, 100);
    vValue = pszTemp;
    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ID"), 0, &vValue, CIM_STRING));

    vValue = m_bstrDomain;
    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("domain"), 0, &vValue, CIM_STRING));

    // Set the user name
    pszTemp[0] = 0;
    if(GetUserName(pszTemp, &nSize) && _tcslen(pszTemp))
    {
        vValue = pszTemp;
        NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Author"), 0, &vValue, CIM_STRING));
    }

    // Set the create and modified dates
    GetLocalTime(&systemTime);
    NTDM_ERR_GETLASTERROR_IF_NULL(GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &systemTime, _T("yyyyMMdd000000.000000-000"), pszTemp, 100));

    if(_tcslen(pszTemp))
    {
        // Set the create date
        vValue = pszTemp;
        NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("CreationDate"), 0, &vValue, CIM_DATETIME));
        NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ChangeDate"), 0, &vValue, CIM_DATETIME));
    }


    // Add current Item to the list
    AddFilterItemToList(pIWbemNewInstance, MAX_LIST_ITEMS, true);

    // set focus on the name edit box
    SetFocus(GetDlgItem(m_hWnd, IDC_NAME));

    NTDM_END_METHOD()

    // disable OK if last item
    lCount = ListView_GetItemCount(m_hwndFilterListView);
    if(0 == lCount)
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), TRUE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), TRUE);
        
    }

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnDuplicate()
{
    HRESULT hr;
    CComPtr<IWbemClassObject>pIWbemNewInstance;
    CComVariant vValue;
    TCHAR pszTemp[100];
    GUID guid;
    CComBSTR bstrTemp;
    DWORD nSize = 100;
    SYSTEMTIME systemTime;

    NTDM_BEGIN_METHOD()

    if(!m_pCurIWbemClassObj)
    {
        CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
        NTDM_EXIT(E_FAIL);
    }

    NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Clone(&pIWbemNewInstance));

    bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NEW_FILTER_NAME);
    vValue = bstrTemp;

    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
    NTDM_ERR_MSG_IF_FAIL(CoCreateGuid(&guid));
    StringFromGUID2(guid, pszTemp, 100);
    vValue = pszTemp;
    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ID"), 0, &vValue, CIM_STRING));

    vValue = m_bstrDomain;
    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("domain"), 0, &vValue, CIM_STRING));

    // set the name
    pszTemp[0] = 0;
    if(GetUserName(pszTemp, &nSize) && _tcslen(pszTemp))
    {
        vValue = pszTemp;
        NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Author"), 0, &vValue, CIM_STRING));
    }

    // Set the create and modified dates
    GetLocalTime(&systemTime);
    NTDM_ERR_GETLASTERROR_IF_NULL(GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &systemTime, _T("yyyyMMdd000000.000000-000"), pszTemp, 100));

    if(_tcslen(pszTemp))
    {
        // Set the create date
        vValue = pszTemp;
        NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("CreationDate"), 0, &vValue, CIM_DATETIME));
        NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ChangeDate"), 0, &vValue, CIM_DATETIME));
    }

    // Add current Item to the list
    AddFilterItemToList(pIWbemNewInstance, MAX_LIST_ITEMS, true);
    
    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

BOOL CWMIFilterManagerDlg::OnOK()
{
    HRESULT hr;

    NTDM_BEGIN_METHOD()

    NTDM_ERR_IF_FAIL(CheckDirtyFlags());

    m_pCurCWMIFilterContainer = NULL;

    NTDM_ERR_IF_FAIL(GetSelectedFilter(&m_pCurCWMIFilterContainer));
    
    if (m_pCurCWMIFilterContainer->IsDirty())
    {
        m_pIWbemClassObject = NULL;
    }
    else
    {    
        NTDM_ERR_IF_FAIL(m_pCurCWMIFilterContainer->GetIWbemClassObject(&m_pIWbemClassObject));
    }
    
    EndDialog(m_hWnd, IDOK);

    NTDM_END_METHOD()

    // cleanup

    return TRUE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::CheckDirtyFlags()
{
    HRESULT hr;
    LVITEM lvItem;
    bool bPrompt = true;
    long lCount;
    long lResult;

    NTDM_BEGIN_METHOD()

    //Release each item in the ListView Control
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;

    lCount = ListView_GetItemCount(m_hwndFilterListView);

    while(lCount > 0)
    {
        lCount--;

        lvItem.iItem = lCount;

        NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

        if(lvItem.lParam)
        {
            CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;

            if(pCWMIFilterContainer->IsDirty())
            {
                if(bPrompt)
                {

                    bPrompt = false;
                    lResult = CNTDMUtils::DisplayMessage(m_hWnd, IDS_PROMPT_FOR_SAVE, IDS_WMI_FILTER_MANAGER, MB_YESNOCANCEL|MB_ICONQUESTION);
                    if(IDNO == lResult)
                    {
                        NTDM_EXIT(NOERROR);
                    }
                    else if(IDCANCEL == lResult)
                    {
                        NTDM_EXIT(E_FAIL);
                    }
                }

                // save the current piwbemobject
                NTDM_ERR_IF_FAIL(pCWMIFilterContainer->GetIWbemClassObject(&m_pCurIWbemClassObj));
                if FAILED(hr = m_pWMIFilterManager->m_pIWbemServices->PutInstance(m_pCurIWbemClassObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL))
                {
                    ListView_SetItemState(m_hwndFilterListView, lCount, LVIS_SELECTED, LVIS_SELECTED);
                    NTDM_ERR_MSG_IF_FAIL(hr);
                }

                pCWMIFilterContainer->SetDirtyFlag(false);
            }
        }
    }

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnManageColumns()
{
    HRESULT hr;
    long lCount;

    NTDM_BEGIN_METHOD()

    g_pColumnManagerDlg = new CColumnManagerDlg(&m_ArrayColumns);
    if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_COLUMN_MANAGER), (HWND)m_hWnd, ColumnManagerDlgProc))
    {
        SetupColumns();
        lCount = ListView_GetItemCount(m_hwndFilterListView);

        while(lCount > 0)
        {
            lCount--;
            UpdateFilterItem(lCount);
        }
    }
    
    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SetupColumns()
{
    HRESULT hr;
    HWND hwndHeader = NULL;
    long i = 0;
    long lCount = 0;
        int iColumn;
    LVCOLUMN lvColumn;
        DWORD dwListWidth[MAX_WMIFILTER_COLUMNS];

    NTDM_BEGIN_METHOD()

        iColumn = 1;
        for (i = 0; i < m_ArrayColumns.GetSize(); i++)
        {
            CColumnItem *pCColumnItem =  m_ArrayColumns[i];
            
            if ( pCColumnItem->IsPrevSelected() )
            {
          //
          // The first element of m_dwColumnWidth width of "Name"
          // column, and the array m_ArrayColumn contains columns after 
          // "Name" column only
          //
          m_dwColumnWidth[i+1] = ListView_GetColumnWidth( m_hwndFilterListView,iColumn++);
            }
        }
        
    // Delete all the columns but the 1st one.
        
    while(ListView_DeleteColumn(m_hwndFilterListView, 1));
        

    for (i=0; i<m_ArrayColumns.GetSize(); i++)
    {
        CColumnItem * pCColumnItem = m_ArrayColumns[i];
                pCColumnItem->SetPrevSelected(pCColumnItem->IsSelected() );

        if(!pCColumnItem->IsSelected())
            continue;

        lCount++;
                dwListWidth[lCount] = m_dwColumnWidth[i+1];

        // Add all the selected columns
        lvColumn.mask = LVCF_TEXT|LVCF_FMT;
        lvColumn.fmt = LVCFMT_LEFT;
        lvColumn.pszText = (LPTSTR)pCColumnItem->GetName();

        NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndFilterListView, lCount, &lvColumn));
    }

    for (i=1; i<=lCount; i++)
    {
            NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndFilterListView, i, dwListWidth[i]));
    }

    
    NTDM_END_METHOD() 

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::GetSelectedFilter(CWMIFilterContainer ** ppCWMIFilterContainer, long lIndex)
{
    HRESULT hr;
    long lSelectionMark;

    NTDM_BEGIN_METHOD()

    if(-1 == lIndex)
    {
        lSelectionMark = ListView_GetSelectionMark(m_hwndFilterListView);
    }
    else
    {
        lSelectionMark = lIndex;
    }

    if(-1 == lSelectionMark)
    {
        CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
        NTDM_EXIT(E_FAIL);
    }
    else
    {
        // get a pointer to the IWbemClassObject
        LVITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iSubItem = 0;

        lvItem.iItem = lSelectionMark;

        NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

        if(lvItem.lParam)
        {
            CComPtr<IWbemClassObject>pIWbemClassObject;
            CWMIFilterContainer * pCWMIFilterContainer;
            
            *ppCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
        }
        else
        {
            NTDM_EXIT(E_FAIL);
        }

    }

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnExport()
{
    HRESULT hr;
    CComBSTR bstrTemp;
    CComBSTR bstrFilter;
    BYTE byteUnicodeHeader1 = 0xFF;
    BYTE byteUnicodeHeader2 = 0xFE;
    CComBSTR bstrNamespace = _T("#pragma namespace(\"\\\\\\\\.\\\\root\\\\policy\")");
    TCHAR pszFile[MAX_PATH];
    CComBSTR bstrObjectText;
    HANDLE hFile = NULL;
    DWORD dwWritten=0;
    pszFile[0] = 0;

    NTDM_BEGIN_METHOD()

    if(!m_pCurIWbemClassObj)
        NTDM_EXIT(E_FAIL);

    BOOL bLoadedResources = FALSE;

    bLoadedResources = ( 0 != bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER) );

    if ( bLoadedResources )
    {
        bLoadedResources = ( 0 != bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER) );
    }

    if ( ! bLoadedResources )
    {
        NTDM_EXIT(HRESULT_FROM_WIN32(GetLastError()));
    }

    bstrFilter += bstrTemp;
    CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

    if(CNTDMUtils::SaveFileNameDlg(bstrFilter, _T("*.mof"), m_hWnd, pszFile))
    {
        if(_tcslen(pszFile))
        {
            // check if the file already exists
            WIN32_FIND_DATA FindFileData;
            HANDLE hFind;

            hFind = FindFirstFile(pszFile, &FindFileData);

            if (hFind != INVALID_HANDLE_VALUE) 
            {
                FindClose(hFind);

                if(IDYES != CNTDMUtils::DisplayMessage(m_hWnd, IDS_WARN_OVERWRITE, IDS_WMI_FILTER_MANAGER, MB_YESNO|MB_ICONQUESTION))
                {
                    NTDM_EXIT(S_FALSE);
                }
            }
            

            NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->GetObjectText(0, &bstrObjectText));

            // save to pszFile
            hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile == INVALID_HANDLE_VALUE)
            {
                NTDM_ERR_GETLASTERROR_IF_NULL(NULL);
                goto error;
            }

            if(hFile)
            {
                NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, &byteUnicodeHeader1, sizeof(BYTE), &dwWritten, NULL));               
                NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, &byteUnicodeHeader2, sizeof(BYTE), &dwWritten, NULL));               
                NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrNamespace, _tcslen(bstrNamespace) * sizeof(TCHAR), &dwWritten, NULL));   
                NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrObjectText, _tcslen(bstrObjectText) * sizeof(TCHAR), &dwWritten, NULL));
                NTDM_ERR_GETLASTERROR_IF_NULL(CloseHandle(hFile));
                hFile = NULL;
            }
        }
    }

    NTDM_END_METHOD()

    // cleanup
    if(hFile)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnImport()
{
    HRESULT hr;
    CComPtr<IMofCompiler>pIMofCompiler;
    CComBSTR bstrTemp;
    CComBSTR bstrFilter;
    TCHAR pszFile[MAX_PATH];
    pszFile[0] = 0;
    WBEM_COMPILE_STATUS_INFO pInfo;

    NTDM_BEGIN_METHOD()

    NTDM_ERR_IF_FAIL(CheckDirtyFlags());

    bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
    bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
    bstrFilter += bstrTemp;
    CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

    if(CNTDMUtils::OpenFileNameDlg(bstrFilter, _T("*.mof"), m_hWnd, pszFile))
    {
        if(_tcslen(pszFile))
        {
            NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void **)&pIMofCompiler));
            NTDM_ERR_MSG_IF_FAIL(pIMofCompiler->CompileFile(pszFile, NULL, NULL, NULL, NULL, 0, 0, 0, &pInfo));

            // check if pInfo is ok
            if(pInfo.lPhaseError != 0)
            {
                CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_STORING_DATA);
            }

            NTDM_ERR_IF_FAIL(PopulateFilterList());
        }
    }

    NTDM_END_METHOD()

    // cleanup
    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::ToggleExpandedMode()
{
    HRESULT hr;
    RECT rect;
    CComBSTR bstrTemp;
    long lCount = 0;

    NTDM_BEGIN_METHOD()

    if(m_bExpanded)
    {
        GetWindowRect(m_hWnd, &rect);
        SetWindowPos(m_hWnd, HWND_NOTOPMOST, 0, 0, rect.right-rect.left, 240, SWP_NOZORDER|SWP_NOREPOSITION|SWP_NOMOVE);

        bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_DETAILS2);
        SetDlgItemText(m_hWnd, IDC_ADVANCED, bstrTemp);

        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NEW, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DELETE, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DUPLICATE, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_IMPORT, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_EXPORT, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NAME, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DESCRIPTION, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_QUERIES, false);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_SAVE, false);

        m_bExpanded = false;
    }
    else
    {
        GetWindowRect(m_hWnd, &rect);
        SetWindowPos(m_hWnd, HWND_NOTOPMOST, 0, 0, rect.right-rect.left, m_lExpandedHeight, SWP_NOZORDER|SWP_NOREPOSITION|SWP_NOMOVE);

        bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_DETAILS1);
        SetDlgItemText(m_hWnd, IDC_ADVANCED, bstrTemp);

        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NEW, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DELETE, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DUPLICATE, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_IMPORT, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_EXPORT, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NAME, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DESCRIPTION, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_QUERIES, true);
        CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_SAVE, true);

        lCount = ListView_GetItemCount(m_hwndFilterListView);
        //If there are no items, make sure the name, description and query controls are disabled.
        if (0 == lCount)
        {
                    
            EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
            EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
            EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);

        }

        m_bExpanded = true;
    }

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SelectFilterItem(long lIndex)
{
    HRESULT hr;

    NTDM_BEGIN_METHOD()

    bool bDirtyFlag = false, bMemoryDirtyFlag = false;

    m_pCurIWbemClassObj = NULL;
    m_pCurCWMIFilterContainer = NULL;

    NTDM_ERR_IF_FAIL(GetSelectedFilter(&m_pCurCWMIFilterContainer, lIndex));
    NTDM_ERR_IF_FAIL(m_pCurCWMIFilterContainer->GetIWbemClassObject(&m_pCurIWbemClassObj));

    bDirtyFlag = m_pCurCWMIFilterContainer->IsDirty();
    bMemoryDirtyFlag = m_pCurCWMIFilterContainer->IsMemoryDirty();

    NTDM_ERR_IF_FAIL(CNTDMUtils::GetStringProperty(m_pCurIWbemClassObj, _T("Name"), m_hWnd, IDC_NAME));
    NTDM_ERR_IF_FAIL(CNTDMUtils::GetStringProperty(m_pCurIWbemClassObj, _T("Description"), m_hWnd, IDC_DESCRIPTION));
    NTDM_ERR_IF_FAIL(PopulateQueryEdit());

    m_pCurCWMIFilterContainer->SetDirtyFlag(bDirtyFlag);
    m_pCurCWMIFilterContainer->SetMemoryDirtyFlag(bMemoryDirtyFlag);

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::PopulateQueryEdit()
{
    HRESULT hr;
    CComVariant vValue;
    SAFEARRAY *psaRules = NULL;
    long lLower, lUpper, i;
    CIMTYPE cimType;
    CComBSTR bstrQueries;
    
    NTDM_BEGIN_METHOD()

    NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Get(_T("Rules"), 0, &vValue, &cimType, NULL));

    if(VT_NULL != V_VT(&vValue))
    {
        // Set the Rules property
        psaRules = V_ARRAY(&vValue);
        NTDM_ERR_MSG_IF_FAIL(SafeArrayGetUBound(psaRules, 1, &lUpper));
        NTDM_ERR_MSG_IF_FAIL(SafeArrayGetLBound(psaRules, 1, &lLower));

        for(i=lLower; i<=lUpper; i++)
        {
            if(V_VT(&vValue) & VT_UNKNOWN)
            {
                // Rules or UNKNOWNS (i.e. IWbemClassObjects)
                CComPtr<IUnknown>pUnk;
                CComPtr<IWbemClassObject> pIWbemClassObject;
                NTDM_ERR_MSG_IF_FAIL(SafeArrayGetElement(psaRules, &i, (void *)&pUnk));
                NTDM_ERR_MSG_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));

                // Show Properties of this object
                if(i!= lLower)
                {
                    bstrQueries += _T("\r\n\r\n");
                }

                NTDM_ERR_IF_FAIL(AddQueryItemToString(pIWbemClassObject, bstrQueries));
            }
        }
    }

    SendDlgItemMessage(m_hWnd, IDC_QUERIES, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)bstrQueries);

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::AddQueryItemToString(IWbemClassObject * pIWbemClassObject, CComBSTR& bstrQueries)
{
    HRESULT hr;
    CComVariant vValue;
    CIMTYPE cimType;

    NTDM_BEGIN_METHOD()

    NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("TargetNameSpace"), 0, &vValue, &cimType, NULL));
    if(vValue.bstrVal && _tcscmp(_T("root\\cimv2"), vValue.bstrVal) != 0)
    {
        bstrQueries += vValue.bstrVal;
        bstrQueries +=";";
    }

    NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Query"), 0, &vValue, &cimType, NULL));

    bstrQueries += vValue.bstrVal;

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SaveQueryEdit()
{
    HRESULT hr;
    VARIANT vValue;
    SAFEARRAY *psaRules = NULL;
    SAFEARRAYBOUND rgsaBound[1];
    long rgIndices[1];
    long i;
    long lCount = 0;
    CSimpleArray<BSTR>bstrArray;
    CComBSTR bstrTemp;

    NTDM_BEGIN_METHOD()

    VariantInit(&vValue);

    //Split out the string into an array of query strings
    NTDM_ERR_IF_FAIL(CNTDMUtils::GetDlgItemString(m_hWnd, IDC_QUERIES, bstrTemp));
    NTDM_ERR_IF_FAIL(CNTDMUtils::GetValuesInList(bstrTemp, bstrArray, _T("\r\n\r\n")));

    // Get the size of the array
    lCount = bstrArray.GetSize();

    if(lCount)
    {
        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = lCount;

        psaRules = SafeArrayCreate(VT_UNKNOWN, 1, rgsaBound);
        
        for(i=0; i<lCount; i++)
        {
            CComPtr<IUnknown>pUnk;
            CSimpleArray<BSTR>bstrQueryDetails;

            NTDM_ERR_IF_FAIL(CNTDMUtils::GetValuesInList(bstrArray[i], bstrQueryDetails, _T(";")));
            if(bstrQueryDetails.GetSize() > 1)
            {
                NTDM_ERR_IF_FAIL(AddEditQueryString(bstrQueryDetails[1], (void**)&pUnk, bstrQueryDetails[0]));
            }
            else
            {
                NTDM_ERR_IF_FAIL(AddEditQueryString(bstrQueryDetails[0], (void**)&pUnk));
            }

            rgIndices[0] = i;
            NTDM_ERR_MSG_IF_FAIL(SafeArrayPutElement(psaRules, rgIndices, pUnk));
        }

        VariantClear(&vValue);
        V_VT(&vValue) = VT_ARRAY|VT_UNKNOWN;
        V_ARRAY(&vValue) = psaRules;
    }
    else
    {
        VariantClear(&vValue);
        V_VT(&vValue) = VT_NULL;
    }

    NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Put(_T("Rules"), 0, &vValue, CIM_FLAG_ARRAY|CIM_OBJECT));

    hr = S_OK;

    NTDM_END_METHOD()

    // cleanup

    VariantClear(&vValue);

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::AddEditQueryString(BSTR bstrQuery, void **ppUnk, BSTR bstrNamespace)
{
    HRESULT hr;
    CComPtr<IWbemClassObject>pIWbemClassObject;
    CComPtr<IWbemClassObject>pIWbemNewInstance;
    CComBSTR bstrTemp;
    CComVariant vValueTemp;

    NTDM_BEGIN_METHOD()

    bstrTemp = _T("MSFT_Rule");

    NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
    NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

    vValueTemp = _T("WQL");
    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("QueryLanguage"), 0, &vValueTemp, CIM_STRING));
    
    if(!bstrNamespace)
        vValueTemp = _T("root\\cimv2");
    else
        vValueTemp = bstrNamespace;
    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("TargetNameSpace"), 0, &vValueTemp, CIM_STRING));

    vValueTemp = bstrQuery;
    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Query"), 0, &vValueTemp, CIM_STRING));

    NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->QueryInterface(IID_IUnknown, ppUnk));
    
    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnSave()
{
    HRESULT hr;

    NTDM_BEGIN_METHOD()

    if(!m_pCurIWbemClassObj)
        NTDM_EXIT(E_FAIL);

    // save the current piwbemobject
    NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->PutInstance(m_pCurIWbemClassObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

    m_pCurCWMIFilterContainer->SetDirtyFlag(false);

    NTDM_END_METHOD()

    // cleanup

    return hr;
}


//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnHelp()
{
    HRESULT hr;

    NTDM_BEGIN_METHOD()

    HWND hwnd = HtmlHelp(NULL, _T("wmifltr.chm"), 0, 0);

    if(!hwnd)
    {
        CNTDMUtils::DisplayMessage(m_hWnd, IDS_HELP_ERR);
    }

    NTDM_END_METHOD()

    // cleanup

    return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SaveToMemory()
{
    HRESULT hr;
    CComBSTR bstrTemp;
    long lSelectionMark;
    CComVariant vValue;

    NTDM_BEGIN_METHOD()

    if(m_pCurCWMIFilterContainer && m_pCurCWMIFilterContainer->IsMemoryDirty())
    {
        NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pCurIWbemClassObj, _T("Name"), m_hWnd, IDC_NAME));
        NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pCurIWbemClassObj, _T("Description"), m_hWnd, IDC_DESCRIPTION));
        NTDM_ERR_IF_FAIL(SaveQueryEdit());

        lSelectionMark = ListView_GetSelectionMark(m_hwndFilterListView);
        UpdateFilterItem(lSelectionMark);

        m_pCurCWMIFilterContainer->SetMemoryDirtyFlag(false);
    }

    NTDM_END_METHOD()

    // cleanup

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\basedrv\pnpmem\memory.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module implements the routines which add and remove physical memory
    from the system.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"

//
// MM uses STATUS_NOT_SUPPORTED to indicate that the memory manager is
// not configured for dynamic memory insertion/removal.
// Unfortunately, this same error code has special meaning to PNP, so
// propagating it blindly from MM is unwise.
//

#define MAP_MMERROR(x) (x == STATUS_NOT_SUPPORTED ? STATUS_UNSUCCESSFUL : x)

#define rgzReservedResources L"\\Registry\\Machine\\Hardware\\ResourceMap\\System Resources\\Loader Reserved"
#define rgzReservedResourcesValue L".Raw"

NTSTATUS
PmAddPhysicalMemoryRange(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG End
    );

VOID
PmLogAddError(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG Size,
    IN NTSTATUS Status
    );

NTSTATUS
PmRemovePhysicalMemoryRange(
    IN ULONGLONG Start,
    IN ULONGLONG End
    );

PPM_RANGE_LIST
PmRetrieveReservedMemoryResources(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmAddPhysicalMemoryRange)
#pragma alloc_text(PAGE, PmAddPhysicalMemory)
#pragma alloc_text(PAGE, PmGetRegistryValue)
#pragma alloc_text(PAGE, PmLogAddError)
#pragma alloc_text(PAGE, PmRetrieveReservedMemoryResources)
#pragma alloc_text(PAGE, PmTrimReservedMemory)
#pragma alloc_text(PAGE, PmRemovePhysicalMemoryRange)
#pragma alloc_text(PAGE, PmRemovePhysicalMemory)
#endif

VOID
PmDumpOsMemoryRanges(PWSTR Prefix)
{
    PPHYSICAL_MEMORY_RANGE memoryRanges;
    ULONG i;
    ULONGLONG start, end;

    memoryRanges = MmGetPhysicalMemoryRanges();

    if (memoryRanges == NULL) {
        return;
    }
    for (i = 0; memoryRanges[i].NumberOfBytes.QuadPart != 0; i++) {
        start = memoryRanges[i].BaseAddress.QuadPart;
        end = start + (memoryRanges[i].NumberOfBytes.QuadPart - 1);
        
        PmPrint((PNPMEM_MEMORY, "%ws:  OS Range range 0x%16I64X to 0x%16I64X\n",
                Prefix, start, end));
    }
    ExFreePool(memoryRanges);
}

NTSTATUS
PmGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );

    //
    // handle highly unlikely case of a value that is zero sized.
    //
    if (NT_SUCCESS(status)) {
        return STATUS_UNSUCCESSFUL;
    }

    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePoolWithTag(PagedPool,
                                       keyValueLength,
                                       PNPMEM_POOL_TAG);
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

PPM_RANGE_LIST
PmRetrieveReservedMemoryResources(
    VOID
    )
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo = NULL;
    PPM_RANGE_LIST reservedResourceRanges = NULL;
    HANDLE hReserved = NULL;
    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString (&unicodeString, rgzReservedResources);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);
    status = ZwOpenKey(&hReserved, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        goto Error;
    }

    status = PmGetRegistryValue(hReserved,
                                rgzReservedResourcesValue,
                                &valueInfo);
    if (!NT_SUCCESS(status)) {
        goto Error;
    }

    if (valueInfo->Type != REG_RESOURCE_LIST) {
        goto Error;
    }

    reservedResourceRanges =
      PmCreateRangeListFromCmResourceList((PCM_RESOURCE_LIST) valueInfo->Data);

    // fall through

Error:
   if (hReserved != NULL) {
       ZwClose(hReserved);
   }

   if (valueInfo != NULL) {
       ExFreePool(valueInfo);
   }

   return reservedResourceRanges;
}

VOID
PmTrimReservedMemory(
    IN PPM_DEVICE_EXTENSION DeviceExtension,
    IN PPM_RANGE_LIST *PossiblyNewMemory
    )
{
    PPM_RANGE_LIST reservedMemoryList = NULL, newList = NULL;
    ULONG i;
    NTSTATUS status;
    BOOLEAN bResult = FALSE;

    PAGED_CODE();

    if (*PossiblyNewMemory == NULL) {
        return;
    }

    reservedMemoryList = PmRetrieveReservedMemoryResources();
    if (reservedMemoryList == NULL) {
        goto Error;
    }

    newList = PmIntersectRangeList(reservedMemoryList, *PossiblyNewMemory);
    if (newList == NULL) {
        goto Error;
    }

    if (PmIsRangeListEmpty(newList)) {
        goto Cleanup;
    }
    
    DeviceExtension->FailQueryRemoves = TRUE;

    PmFreeRangeList(newList);

    newList = PmSubtractRangeList(*PossiblyNewMemory,
                                  reservedMemoryList);
    if (newList) {
        PmFreeRangeList(*PossiblyNewMemory);
        *PossiblyNewMemory = newList;
        newList = NULL;
        goto Cleanup;
    }

    //
    // Fall through to error case where we ensure that we don't
    // innocently tell the OS to use memory that is reserved.
    //

 Error:
    PmFreeRangeList(*PossiblyNewMemory);
    *PossiblyNewMemory = NULL;
    DeviceExtension->FailQueryRemoves = TRUE;

 Cleanup:

    if (reservedMemoryList != NULL) {
        PmFreeRangeList(reservedMemoryList);
    }

    if (newList != NULL) {
        PmFreeRangeList(newList);
    }

    return;
}

VOID
PmLogAddError(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG Size,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function logs a failure to add memory

Arguments:

    DeviceObject - Device object object for which the memory add
    failed.

    Start - The start of the physical memory range.

    Size - The size of the physical memory range.

    Status - Status code returned by MM.

Return Value:

    None.

--*/
{
    PIO_ERROR_LOG_PACKET packet;
    PWCHAR stringBuffer;
    UCHAR packetSize;
    int offset;

    //
    // Allocate a packet with space for 2 16 character hex value
    // strings including null terminators for each.
    //

    packetSize = sizeof(IO_ERROR_LOG_PACKET) + (sizeof(WCHAR)*(16+1))*2;
    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,
                                                            packetSize);
    if (packet == NULL) {
        return;
    }

    packet->DumpDataSize = 0;
    packet->NumberOfStrings = 2;
    packet->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    packet->ErrorCode = PNPMEM_ERR_FAILED_TO_ADD_MEMORY;
    packet->FinalStatus = Status;
    
    stringBuffer = (PWCHAR) (packet + 1);
    offset = swprintf(stringBuffer, L"%I64X", Start);

    swprintf(stringBuffer + offset + 1, L"%I64X", Size);
    
    IoWriteErrorLogEntry(packet);
}


NTSTATUS
PmAddPhysicalMemoryRange(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG End
    )

/*++

Routine Description:

    This function uses MmAddPhysicalMemory to notify the memory manager that
    physical memory is available.

Arguments:

    DeviceObject - device object of the memory device this range is part of.

    Start - The start of the physical memory range.

    End - The end of the physical memory range.

Return Value:

    None.

--*/

{
    NTSTATUS PrevStatus;
    NTSTATUS Status;
    ULONGLONG Size;
    ULONGLONG CurrentSize;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    PAGED_CODE();

    ASSERT((Start & (PAGE_SIZE - 1)) == 0);
    ASSERT((End & (PAGE_SIZE - 1)) == (PAGE_SIZE - 1));

    //
    // This loop attempts to add the memory specified in the
    // arguments:
    //
    // If an attempt to add memory fails, a chunk half as large will
    // be tried next iteration until a chunk succeeds or the whole add
    // operation fails.
    //
    // If an attempt to add memory succeeds, a chunk twice as large
    // (bounded by the original range) will be tried next iteration.
    //
    // Loop ends when the original range is exhausted or the
    // addition of a range fails completely.
    //

    PrevStatus = Status = STATUS_SUCCESS;
    CurrentSize = Size = End - Start + 1;

    while (Size > 0) {

        StartAddress.QuadPart = Start;
        NumberOfBytes.QuadPart = CurrentSize;

        //
        // MmAddPhysicalMemory() adds the specified physical address
        // range to the system.  If any bytes are added,
        // STATUS_SUCCESS is returned and the NumberOfBytes field is
        // updated to reflect the number of bytes actually added.
        //

        Status = MmAddPhysicalMemory(
                     &StartAddress,
                     &NumberOfBytes
                 );

        if (NT_SUCCESS(Status)) {

            ASSERT((ULONGLONG)StartAddress.QuadPart == Start);
            ASSERT((NumberOfBytes.QuadPart & (PAGE_SIZE - 1)) == 0);
            ASSERT((ULONGLONG)NumberOfBytes.QuadPart <= CurrentSize);

            Start += NumberOfBytes.QuadPart;
            Size -= NumberOfBytes.QuadPart;

            //
            // If successful this iteration and the previous, then add
            // twice as much next time.
            //
            // Trim next attempt to reflect the remaining memory.
            //

            if (NT_SUCCESS(PrevStatus)) {
                CurrentSize <<= 1;
            }

            if (CurrentSize > Size) {
                CurrentSize = Size;
            }

        } else {

            //
            // Failed to add a range.  Halve the amount we're going to
            // try to add next time.  Breaks out if we're trying to
            // add less than a page.
            //

            CurrentSize = (CurrentSize >> 1) & ~(PAGE_SIZE - 1);

            if (CurrentSize < PAGE_SIZE) {
                break;
            }

        }

        PrevStatus = Status;

    }

    //
    // If the last add operation we attempted failed completely, then
    // log the error for posterity.
    //

    if (!NT_SUCCESS(Status)) {
        PmLogAddError(DeviceObject, Start, Size, Status);
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                 "Failed to add physical range 0x%I64X for 0x%I64X bytes\n",
                 Start, Size));
    }

    //
    // We don't know what portion of the range we succeeded in adding,
    // and which we failed.  Attempt in this case is all that matters.
    //

    return STATUS_SUCCESS;
}

NTSTATUS
PmAddPhysicalMemory(
    IN PDEVICE_OBJECT DeviceObject,
    IN PPM_RANGE_LIST PossiblyNewMemory
    )

/*++

Routine Description:

    This function adds the physical memory in the PM_RANGE_LIST which
    the memory manager does not yet know about to the system.  This
    requires getting a snapshot of the physical page map, then computing
    the set difference between the range list and the snapshot.  The
    difference represents the memory the memory manager does not yet know
    about.

Arguments:

    PossiblyNewMemory - The range list of physical addresses to be
    added.  This memory may already be known to the system depending
    on whether the machine POSTed with this memory installed.

Return Value:

    NTSTATUS

--*/

{
    PPM_RANGE_LIST knownPhysicalMemory, newMemory;
    NTSTATUS Status;
    NTSTATUS AddStatus;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    //
    // Find out what physical memory regions MM already knows about
    //

    knownPhysicalMemory = PmCreateRangeListFromPhysicalMemoryRanges();
    if (knownPhysicalMemory == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Any memory in the ranges provided by this device that is
    // already known to MM is assumed to come from this device.
    // Presumeably the OS was handed this memory by firmware/POST.
    //
    // Find out what memory is contained by this device that MM
    // doesn't already know about by subtracting the MM physical
    // ranges from our device's memory ranges.
    //

    newMemory = PmSubtractRangeList(
        PossiblyNewMemory,
        knownPhysicalMemory
        );

    PmFreeRangeList(knownPhysicalMemory);
    
    //
    // Either we succeeded in getting a list of memory ranges to add
    // (including a possible null list) or we failed due to
    // insufficient resources.  The latter represents a problem since
    // a memory shortage may be keeping us from adding memory to
    // relieve the memory shortage.
    // 

    if (newMemory != NULL) {

        for (ListEntry = newMemory->List.Flink;
             ListEntry != &newMemory->List;
             ListEntry = ListEntry->Flink) {

            RangeListEntry = CONTAINING_RECORD(
                ListEntry,
                PM_RANGE_LIST_ENTRY,
                ListEntry
                );

            AddStatus = PmAddPhysicalMemoryRange(
                DeviceObject,
                RangeListEntry->Start,
                RangeListEntry->End
                );

            if (!NT_SUCCESS(AddStatus)) {
                PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                        "Failed to add physical range 0x%I64X to 0x%I64X\n",
                        RangeListEntry->Start, RangeListEntry->End));
            }
        }

        PmFreeRangeList(newMemory);

    }
    return STATUS_SUCCESS;
}

NTSTATUS
PmRemovePhysicalMemoryRange(
    IN ULONGLONG Start,
    IN ULONGLONG End
    )

/*++

Routine Description:

    This function uses MmRemovePhysicalMemory to notify the memory manager that
    physical memory is no longer available.

Arguments:

    Start - The start of the physical memory range.

    End - The end of the physical memory range.

Return Value:

    None.

--*/

{
#if 0
    NTSTATUS PrevStatus;
    NTSTATUS Status;
    ULONGLONG Size;
    ULONGLONG CurrentSize;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    ASSERT((Start & (PAGE_SIZE - 1)) == 0);
    ASSERT((End & (PAGE_SIZE - 1)) == (PAGE_SIZE - 1));

    PrevStatus = Status = STATUS_SUCCESS;

    CurrentSize = Size = End - Start + 1;

    while (Size > 0) {

        StartAddress.QuadPart = Start;
        NumberOfBytes.QuadPart = CurrentSize;

        Status = MmRemovePhysicalMemory(
                     &StartAddress,
                     &NumberOfBytes
                 );
        Status = MAP_MMERROR(Status);

        if (NT_SUCCESS(Status)) {

            ASSERT((ULONGLONG)StartAddress.QuadPart == Start);
            ASSERT((NumberOfBytes.QuadPart & (PAGE_SIZE - 1)) == 0);
            ASSERT((ULONGLONG)NumberOfBytes.QuadPart <= CurrentSize);

            Start += NumberOfBytes.QuadPart;
            Size -= NumberOfBytes.QuadPart;

            if (NT_SUCCESS(PrevStatus)) {
                CurrentSize <<= 1;
            }

            if (CurrentSize > Size) {
                CurrentSize = Size;
            }

        } else {

            CurrentSize = (CurrentSize >> 1) & ~(PAGE_SIZE - 1);

            if (CurrentSize < PAGE_SIZE) {
                break;
            }

        }

        PrevStatus = Status;

    }
#else
    ULONGLONG Size;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;
    NTSTATUS Status;

    PAGED_CODE();

    Size = (End - Start) + 1;
    StartAddress.QuadPart = Start;
    NumberOfBytes.QuadPart = Size;

    Status = MmRemovePhysicalMemory(
                 &StartAddress,
                 &NumberOfBytes
             );

    Status = MAP_MMERROR(Status);

#endif

    //
    // If it failed, routine automatically readds the memory in
    // question.
    //

    return Status;
}

NTSTATUS
PmRemovePhysicalMemory(
    IN PPM_RANGE_LIST RemoveMemoryList
    )

/*++

Routine Description:

    This function removes the physical memory in the PM_RANGE_LIST which
    the memory manager is currently using from the system.  This
    requires getting a snapshot of the physical page map, then computing
    the set intersection between the source range list and the snapshot.
    The intersection represents the memory the memory manager needs to
    stop using.

Arguments:

    RemoveMemoryList - The range list of physical addresses to be removed.

Return Value:

    None.

--*/

{
    PPM_RANGE_LIST physicalMemoryList, inuseMemoryList;
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    //
    // Remove the intersection between what the OS knows about and
    // what we are providing.
    //

    physicalMemoryList = PmCreateRangeListFromPhysicalMemoryRanges();

    if (physicalMemoryList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    inuseMemoryList = PmIntersectRangeList(
        RemoveMemoryList,
        physicalMemoryList
        );

    if (inuseMemoryList != NULL) {

        Status = STATUS_SUCCESS;
    
        for (ListEntry = inuseMemoryList->List.Flink;
             ListEntry != &inuseMemoryList->List;
             ListEntry = ListEntry->Flink) {

            RangeListEntry = CONTAINING_RECORD(
                ListEntry,
                PM_RANGE_LIST_ENTRY,
                ListEntry
                );

            Status = PmRemovePhysicalMemoryRange(
                RangeListEntry->Start,
                RangeListEntry->End
                );

            if (!NT_SUCCESS(Status)) {
                //
                // If we failed to remove a particular range, bail
                // now.  Code above should re-add the memory list if
                // appropriate i.e assume that some ranges may have
                // been removed successfully.
                //
                break;
            }
        }

        PmFreeRangeList(inuseMemoryList);

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    }

    PmFreeRangeList(physicalMemoryList);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\basedrv\pnpmem\pnp.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module implements the IRP_MJ_PNP IRP processing routines for the
    Plug and Play Memory driver.  Dispatch routines are invoked through
    tables located at the bottom of the module.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"

NTSTATUS
PmPassIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmDeferProcessing(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PmStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmSurpriseRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmPassIrp)
#pragma alloc_text(PAGE, PmPnpDispatch)
#pragma alloc_text(PAGE, PmDeferProcessing)
#pragma alloc_text(PAGE, PmStartDevice)
#pragma alloc_text(PAGE, PmQueryRemoveDevice)
#pragma alloc_text(PAGE, PmRemoveDevice)
#pragma alloc_text(PAGE, PmCancelRemoveDevice)
#pragma alloc_text(PAGE, PmQueryStopDevice)
#pragma alloc_text(PAGE, PmCancelStopDevice)
#pragma alloc_text(PAGE, PmSurpriseRemoveDevice)
#pragma alloc_text(PAGE, PmQueryCapabilities)
#endif

PDRIVER_DISPATCH PmPnpDispatchTable[];
extern ULONG PmPnpDispatchTableSize;

NTSTATUS
PmPassIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(deviceExtension->AttachedDevice, Irp);
}

NTSTATUS
PmPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    BOOLEAN isRemoveDevice;
    PIO_STACK_LOCATION irpSp;
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    IoAcquireRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);

    isRemoveDevice = irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE;

    if ((irpSp->MinorFunction < PmPnpDispatchTableSize) &&
        PmPnpDispatchTable[irpSp->MinorFunction]) {

        status =
            PmPnpDispatchTable[irpSp->MinorFunction](DeviceObject,
                                                     Irp
                                                     );
    } else {
        status = PmPassIrp(DeviceObject, Irp);
    }

    if (!isRemoveDevice) {
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);
    }

    return status;
}

NTSTATUS
PmPnpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PmDeferProcessing(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    Parent - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    PPM_DEVICE_EXTENSION deviceExtension;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           PmPnpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(deviceExtension->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PmStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_START_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp;
    PPM_RANGE_LIST RangeList;
    PPM_DEVICE_EXTENSION deviceExtension;
    POWER_STATE power;
    NTSTATUS status;

    PAGED_CODE();

    status = PmDeferProcessing(DeviceObject, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    PmDumpOsMemoryRanges(L"Before Start");

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;
    ASSERT(deviceExtension->RangeList == NULL);
    
    if (irpSp->Parameters.StartDevice.AllocatedResources) {
        RangeList = PmCreateRangeListFromCmResourceList(
            irpSp->Parameters.StartDevice.AllocatedResources
            );
        if (RangeList == NULL) {
            //
            // The memory allocation failure here is more serious than
            // is intially obvious.  If we fail this allocation, we're
            // going to get removed from the stack before we find out
            // if the OS knows about this memory.  If the OS knows
            // about this memory already, then ejecting the PDO would
            // cause the memory underneath the OS to disappear.
            // Better to be on the stack, but not have added any
            // memory then to be off the stack and leave a dangerous
            // situation.
            //
            // Only solution is to arbitrarily fail
            // IRP_MN_QUERY_REMOVE.
            //
            deviceExtension->FailQueryRemoves = TRUE;
        }
    } else {
        RangeList = NULL;
    }

    PmTrimReservedMemory(deviceExtension, &RangeList);

    PmDebugDumpRangeList(PNPMEM_MEMORY, "Memory Ranges to be added:\n",
                         RangeList);
    if (deviceExtension->FailQueryRemoves) {
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY, "PNPMEM device can't be removed\n"));
    }

    if (RangeList != NULL) {

        (VOID) PmAddPhysicalMemory(DeviceObject, RangeList);
        deviceExtension->RangeList = RangeList;
    }

    power.DeviceState = PowerDeviceD0;
    PoSetPowerState(DeviceObject, DevicePowerState, power);
    deviceExtension->PowerState = PowerDeviceD0;

    PmDumpOsMemoryRanges(L"After Start ");

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
PmQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_QUERY_REMOVE_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PPM_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (!MemoryRemovalSupported) {
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                 "QueryRemove vetoed because memory removal is not supported\n"));
        status = STATUS_UNSUCCESSFUL;
    } else if (deviceExtension->FailQueryRemoves) {
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                 "QueryRemove vetoed because removing this memory device may contain special memory\n"));
        status = STATUS_UNSUCCESSFUL;
    } else if (deviceExtension->RangeList != NULL) {
        status = PmRemovePhysicalMemory(deviceExtension->RangeList);
        if (!NT_SUCCESS(status)) {
            //
            // Some ranges may have been removed, before failure.  Add
            // them back.  Should be low-cost due to optimizations in
            // PmAddPhysicalMemory.
            //

            (VOID) PmAddPhysicalMemory(DeviceObject, deviceExtension->RangeList);
        }
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    if (NT_SUCCESS(status)) {
        return PmPassIrp(DeviceObject, Irp);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
PmRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_REMOVE_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PPM_DEVICE_EXTENSION deviceExtension;
    PPM_RANGE_LIST RangeList;
    POWER_STATE power;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if ((deviceExtension->Flags & DF_SURPRISE_REMOVED) == 0) {
        power.DeviceState = PowerDeviceD3;
        PoSetPowerState(DeviceObject, DevicePowerState, power);
        deviceExtension->PowerState = PowerDeviceD0;

        if (deviceExtension->RangeList != NULL) {
            status = PmRemovePhysicalMemory(deviceExtension->RangeList);
            ASSERT(status == STATUS_SUCCESS);
            DbgBreakPoint();
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = PmPassIrp(DeviceObject, Irp);

    IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, (PVOID) Irp);

    IoDetachDevice(deviceExtension->AttachedDevice);
    deviceExtension->AttachedDevice = NULL;

    if (deviceExtension->RangeList != NULL) {
        PmFreeRangeList(deviceExtension->RangeList);
        deviceExtension->RangeList = NULL;
    }

    IoDeleteDevice(DeviceObject);

    return status;
}
    
NTSTATUS
PmCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_CANCEL_REMOVE_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    (VOID) PmDeferProcessing(DeviceObject, Irp);

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->RangeList != NULL) {
        (VOID) PmAddPhysicalMemory(DeviceObject, deviceExtension->RangeList);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
PmQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_QUERY_STOP_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_DEVICE_BUSY;
}

NTSTATUS
PmCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_CANCEL_STOP_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    (VOID) PmDeferProcessing(DeviceObject, Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
PmQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    status = PmDeferProcessing(DeviceObject, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (irpSp->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    for (i = 0; i < PowerSystemMaximum; i++) {
        deviceExtension->DeviceStateMapping[i] =
            irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
    }

    //
    // Would *LIKE* to smash the eject supported, and removable bits
    // here but this isn't really supported.  The hot plug applet pops
    // up (because the device is marked removable or ejectable) and
    // then goes away a few seconds later when the driver is installed
    // (and the capabilities requeried).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
PmSurpriseRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->RangeList != NULL) {
       PVOID parameterArray[4] = {0};
       UCHAR buffer[] = "Memory module can not be surprise removed safely\n";
     
       //
       // Memory cannot be gracefully yanked from a running
       // system.
       //

       KeBugCheckEx(FATAL_UNHANDLED_HARD_ERROR,
                    0x10001,
                    (ULONG_PTR) parameterArray,
                    (ULONG_PTR) buffer,
                    (ULONG_PTR) NULL);
        
    }

    deviceExtension->Flags |= DF_SURPRISE_REMOVED;

    if (deviceExtension->RangeList != NULL) {
        PmFreeRangeList(deviceExtension->RangeList);
        deviceExtension->RangeList = NULL;
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PmPassIrp(DeviceObject, Irp);
}

PDRIVER_DISPATCH PmPnpDispatchTable[] = {
    PmStartDevice,          // IRP_MN_START_DEVICE                    
    PmQueryRemoveDevice,    // IRP_MN_QUERY_REMOVE_DEVICE             
    PmRemoveDevice,         // IRP_MN_REMOVE_DEVICE                   
    PmCancelRemoveDevice,   // IRP_MN_CANCEL_REMOVE_DEVICE            
    NULL,                   // IRP_MN_STOP_DEVICE (never get, fails query-stop)
    PmQueryStopDevice,      // IRP_MN_QUERY_STOP_DEVICE               
    PmCancelStopDevice,     // IRP_MN_CANCEL_STOP_DEVICE              
    NULL,                   // IRP_MN_QUERY_DEVICE_RELATIONS          
    NULL,                   // IRP_MN_QUERY_INTERFACE                 
    PmQueryCapabilities,    // IRP_MN_QUERY_CAPABILITIES              
    NULL,                   // IRP_MN_QUERY_RESOURCES                 
    NULL,                   // IRP_MN_QUERY_RESOURCE_REQUIREMENTS     
    NULL,                   // IRP_MN_QUERY_DEVICE_TEXT               
    NULL,                   // IRP_MN_FILTER_RESOURCE_REQUIREMENTS    
    NULL,                   // unused                                       
    NULL,                   // IRP_MN_READ_CONFIG                     
    NULL,                   // IRP_MN_WRITE_CONFIG                    
    NULL,                   // IRP_MN_EJECT                           
    NULL,                   // IRP_MN_SET_LOCK                        
    NULL,                   // IRP_MN_QUERY_ID                        
    NULL,                   // IRP_MN_QUERY_PNP_DEVICE_STATE          
    NULL,                   // IRP_MN_QUERY_BUS_INFORMATION           
    NULL,                   // IRP_MN_DEVICE_USAGE_NOTIFICATION       
    PmSurpriseRemoveDevice, // IRP_MN_SURPRISE_REMOVAL
};

ULONG PmPnpDispatchTableSize =
    sizeof (PmPnpDispatchTable) / sizeof (PmPnpDispatchTable[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\basedrv\pnpmem\pnpmem.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pnpmem.h

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _PNPMEM_H_
#define _PNPMEM_H_

#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>
#include "errlog.h"

//
// A Range List Entry.
//

typedef struct {
    LIST_ENTRY          ListEntry;
    ULONGLONG           Start;
    ULONGLONG           End;
} PM_RANGE_LIST_ENTRY, *PPM_RANGE_LIST_ENTRY;

//
// A Range List.
//

typedef struct {
    LIST_ENTRY          List;
} PM_RANGE_LIST, *PPM_RANGE_LIST;

//
// FDO Device Extension.
//

typedef struct {
    ULONG               Flags;

    IO_REMOVE_LOCK      RemoveLock;
    PDEVICE_OBJECT      AttachedDevice;

    DEVICE_POWER_STATE  PowerState;
    DEVICE_POWER_STATE  DeviceStateMapping[PowerSystemMaximum];

    PPM_RANGE_LIST      RangeList;
    BOOLEAN             FailQueryRemoves;
} PM_DEVICE_EXTENSION, *PPM_DEVICE_EXTENSION;

#define DF_SURPRISE_REMOVED 0x01

PPM_RANGE_LIST
PmAllocateRangeList(
    VOID
    );

NTSTATUS
PmInsertRangeInList(
    PPM_RANGE_LIST InsertionList,
    ULONGLONG Start,
    ULONGLONG End
    );

VOID
PmFreeRangeList(
    IN PPM_RANGE_LIST RangeList
    );

BOOLEAN
PmIsRangeListEmpty(
    IN PPM_RANGE_LIST RangeList
    );

PPM_RANGE_LIST
PmCopyRangeList(
    IN PPM_RANGE_LIST SrcRangeList
    );

PPM_RANGE_LIST
PmInvertRangeList(
    IN PPM_RANGE_LIST SrcRangeList
    );

PPM_RANGE_LIST
PmSubtractRangeList(
    IN PPM_RANGE_LIST SrcRangeList1,
    IN PPM_RANGE_LIST SrcRangeList2
    );

PPM_RANGE_LIST
PmIntersectRangeList(
    IN PPM_RANGE_LIST SrcRangeList1,
    IN PPM_RANGE_LIST SrcRangeList2
    );

PPM_RANGE_LIST
PmCreateRangeListFromCmResourceList(
    IN PCM_RESOURCE_LIST CmResourceList
    );

PPM_RANGE_LIST
PmCreateRangeListFromPhysicalMemoryRanges(
    VOID
    );

NTSTATUS
PmAddPhysicalMemory(
    IN PDEVICE_OBJECT DeviceObject,
    IN PPM_RANGE_LIST RangeList1
    );

NTSTATUS
PmRemovePhysicalMemory(
    IN PPM_RANGE_LIST RangeList1
    );

VOID
PmTrimReservedMemory(
    IN PPM_DEVICE_EXTENSION DeviceExtension,
    IN PPM_RANGE_LIST *PossiblyNewMemory
    );

NTSTATUS
PmGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    );

VOID
PmDebugPrint(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    ...
    );

VOID
PmDebugDumpRangeList(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    PPM_RANGE_LIST RangeList
    );


#if DBG
#define PmPrint(x) PmDebugPrint x
#else
#define PmPrint(x)
#endif
    
#define PNPMEM_MEMORY (DPFLTR_INFO_LEVEL + 1)
#define PNPMEM_PNP    (DPFLTR_INFO_LEVEL + 2)

VOID
PmDumpOsMemoryRanges(
    IN PWSTR Prefix
    );

#define PNPMEM_POOL_TAG 'MMpH'

extern BOOLEAN MemoryRemovalSupported;

#endif /* _PNPMEM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_inlinestring.h ===
#if !defined(_WINDOWS_BCL_INILINESTRING_H_INCLUDED_)
#define _WINDOWS_BCL_INILINESTRING_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_inlinestring.h

Abstract:

    Definitions common for strings that maintain a buffer inline
    with the derived object.

Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <bcl_purestring.h>
#include <bcl_unicodechartraits.h>

namespace BCL {
template <typename TTraits> class CInlineString : public CPureString<TTraits>
{
protected:
    inline bool IsUsingInlineBuffer() const { return this->GetBufferPtr() == this->GetInlineBufferPtr(); }
    inline TMutableString GetInlineBufferPtr() const { return TTraits::GetInlineBufferPtr(this); }
    inline TSizeT GetInlineBufferCch() const { return TTraits::GetInlineBufferCch(this); }
    inline TMutablePair InlineMutableBufferPair() { return TTraits::InlineMutableBufferPair(this); }

    inline void DeallocateDynamicBuffer()
    {
        if (this->GetBufferPtr() != this->GetInlineBufferPtr())
        {
            TTraits::DeallocateBuffer(this->GetBufferPtr());
            this->SetBufferPointerAndCount(this->GetInlineBufferPtr(), this->GetInlineBufferCch());
            this->SetStringCch(0);
        }
    }
}; // class CInlineString
}; // namespace BCL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\basedrv\pnpmem\range.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    range.c

Abstract:

    This module implements the range list routines for the Plug and Play Memory
    driver.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"

PPM_RANGE_LIST_ENTRY
PmAllocateRangeListEntry(
    VOID
    );

VOID
PmFreeRangeListEntry(
    IN PPM_RANGE_LIST_ENTRY RangeListEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmAllocateRangeListEntry)
#pragma alloc_text(PAGE, PmInsertRangeInList)
#pragma alloc_text(PAGE, PmFreeRangeListEntry)
#pragma alloc_text(PAGE, PmAllocateRangeList)
#pragma alloc_text(PAGE, PmFreeRangeList)
#pragma alloc_text(PAGE, PmIsRangeListEmpty)
#pragma alloc_text(PAGE, PmDebugDumpRangeList)
#pragma alloc_text(PAGE, PmCopyRangeList)
#pragma alloc_text(PAGE, PmSubtractRangeList)
#pragma alloc_text(PAGE, PmIntersectRangeList)
#pragma alloc_text(PAGE, PmCreateRangeListFromCmResourceList)
#pragma alloc_text(PAGE, PmCreateRangeListFromPhysicalMemoryRanges)
#endif


PPM_RANGE_LIST_ENTRY
PmAllocateRangeListEntry(
    VOID
    )

/*++

Routine Description:

    This function allocates a range list entry from paged pool.

Arguments:

    None.

Return Value:

    Upon success a pointer to a PM_RANGE_LIST_ENTRY object is returned,
    otherwise NULL.

--*/

{
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    RangeListEntry = ExAllocatePoolWithTag(PagedPool,
                                           sizeof (PM_RANGE_LIST_ENTRY),
                                           PNPMEM_POOL_TAG
                                           );

    return RangeListEntry;
}

NTSTATUS
PmInsertRangeInList(
    PPM_RANGE_LIST InsertionList,
    ULONGLONG Start,
    ULONGLONG End
    )
{
    PPM_RANGE_LIST_ENTRY entry;

    entry = PmAllocateRangeListEntry();
    if (entry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    entry->Start = Start;
    entry->End = End;

    InsertTailList(&InsertionList->List,
                   &entry->ListEntry);

    return STATUS_SUCCESS;
}

VOID
PmFreeRangeListEntry(
    IN PPM_RANGE_LIST_ENTRY RangeListEntry
    )

/*++

Routine Description:

    This function de-allocates a range list entry object.

Arguments:

    RangeListEntry - The PM_RANGE_LIST_ENTRY to be de-allocated.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT(RangeListEntry != NULL);

    ExFreePool(RangeListEntry);
}

PPM_RANGE_LIST
PmAllocateRangeList(
    VOID
    )

/*++

Routine Description:

    This function allocates and initializes a range list from paged pool.

Arguments:

    None.

Return Value:

    Upon success a pointer to a PM_RANGE_LIST object is returned, otherwise
    NULL.

--*/

{
    PPM_RANGE_LIST RangeList;

    PAGED_CODE();

    RangeList = ExAllocatePoolWithTag(PagedPool,
                                      sizeof (PM_RANGE_LIST),
                                      PNPMEM_POOL_TAG
                                      );

    if (RangeList != NULL) {
        InitializeListHead(&RangeList->List);
    }

    return RangeList;
}

VOID
PmFreeRangeList(
    IN PPM_RANGE_LIST RangeList
    )

/*++

Routine Description:

    This function removes all entries from a range list and de-allocates it.

Arguments:

    RangeList - The PM_RANGE_LIST to be de-allocated.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    for (ListEntry = RangeList->List.Flink;
         ListEntry != &RangeList->List;
         ListEntry = RangeList->List.Flink) {

        RangeListEntry = CONTAINING_RECORD(
                             ListEntry,
                             PM_RANGE_LIST_ENTRY,
                             ListEntry
                         );

        RemoveEntryList(ListEntry);

        PmFreeRangeListEntry(RangeListEntry);

    }

    ExFreePool(RangeList);
}

BOOLEAN
PmIsRangeListEmpty(
    IN PPM_RANGE_LIST RangeList
    )

/*++

Routine Description:

    This function determines whether the specified range list is empty.

Arguments:

    RangeList - The PM_RANGE_LIST.

Return Value:

    TRUE if the PM_RANGE_LIST has no PM_RANGE_LIST_ENTRYs, otherwise FALSE.

--*/

{
    PAGED_CODE();

    return IsListEmpty(&RangeList->List);
}

VOID
PmDebugDumpRangeList(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    PPM_RANGE_LIST RangeList
    )
{
    PLIST_ENTRY listEntry;
    PPM_RANGE_LIST_ENTRY rangeListEntry;

    PmPrint((DebugPrintLevel, DebugMessage));

    if (RangeList == NULL) {
        PmPrint((DebugPrintLevel, "\tNULL\n"));
        return;
    } else if (PmIsRangeListEmpty(RangeList)) {
        PmPrint((DebugPrintLevel, "\tEmpty\n"));
        return;
    } else {
        for (listEntry = RangeList->List.Flink;
             listEntry != &RangeList->List;
             listEntry = listEntry->Flink) {

            rangeListEntry = CONTAINING_RECORD(
                listEntry,
                PM_RANGE_LIST_ENTRY,
                ListEntry
                );
            PmPrint((DebugPrintLevel, "\t0x%I64X - 0x%I64X\n",
                     rangeListEntry->Start, rangeListEntry->End));
        }
    }
}

PPM_RANGE_LIST
PmCopyRangeList(
    IN PPM_RANGE_LIST SrcRangeList
    )

/*++

Routine Description:

    This function creates a copy of a PM_RANGE_LIST and its supporting
    PM_RANGE_LIST_ENTRY objects.

Arguments:

    SrcRangeList - The PM_RANGE_LIST to be copied.

Return Value:

    Upon success a pointer to a PM_RANGE_LIST is returned, otherwise NULL.

--*/

{
    PPM_RANGE_LIST DstRangeList;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry;
    PPM_RANGE_LIST_ENTRY DstRangeListEntry;

    PAGED_CODE();

    DstRangeList = PmAllocateRangeList();

    if (DstRangeList != NULL) {

        for (ListEntry = SrcRangeList->List.Flink;
             ListEntry != &SrcRangeList->List;
             ListEntry = ListEntry->Flink) {

            SrcRangeListEntry = CONTAINING_RECORD(
                                    ListEntry,
                                    PM_RANGE_LIST_ENTRY,
                                    ListEntry
                                );

            DstRangeListEntry = PmAllocateRangeListEntry();

            if (DstRangeListEntry == NULL) {
                PmFreeRangeList(DstRangeList);
                DstRangeList = NULL;
                break;
            }

            DstRangeListEntry->Start = SrcRangeListEntry->Start;
            DstRangeListEntry->End = SrcRangeListEntry->End;

            InsertTailList(
                &DstRangeList->List,
                &DstRangeListEntry->ListEntry
            );

        }

    }

    return DstRangeList;
}

PPM_RANGE_LIST
PmSubtractRangeList(
    IN PPM_RANGE_LIST MinuendList,
    IN PPM_RANGE_LIST SubtrahendList
    )

/*++

Routine Description:

    This function creates a new range list which represents the set difference
    between MinuendList and SubtrahendList.

Arguments:

    MinuendList - The minuend range list.

    SubtrahendList - The subtrahend range list.

Return Value:

    Upon success a pointer to the destination (difference) PM_RANGE_LIST is
    returned, otherwise NULL.

--*/

{
    PPM_RANGE_LIST DstRangeList;
    PLIST_ENTRY DstListEntry;
    PPM_RANGE_LIST_ENTRY DstRangeListEntry;
    PLIST_ENTRY SrcListEntry;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry;
    ULONGLONG Start;
    ULONGLONG End;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    ASSERT(MinuendList != NULL);
    ASSERT(SubtrahendList != NULL);

    //
    // Make a copy of the minuend.
    //

    DstRangeList = PmCopyRangeList(MinuendList);

    if (DstRangeList != NULL) {

        //
        // Loop through each range list entry in the minuend.
        //

        for (DstListEntry = DstRangeList->List.Flink;
             DstListEntry != &DstRangeList->List;
             DstListEntry = DstListEntry->Flink) {

            DstRangeListEntry = CONTAINING_RECORD(
                                    DstListEntry,
                                    PM_RANGE_LIST_ENTRY,
                                    ListEntry
                                );

            //
            // Loop through each range list entry in the subtrahend.
            //

            for (SrcListEntry = SubtrahendList->List.Flink;
                 SrcListEntry != &SubtrahendList->List;
                 SrcListEntry = SrcListEntry->Flink) {

                SrcRangeListEntry = CONTAINING_RECORD(
                                        SrcListEntry,
                                        PM_RANGE_LIST_ENTRY,
                                        ListEntry
                                    );

                //
                // Compute the intersection of the minuend and subtrahend
                // range list entries.
                //

                Start = DstRangeListEntry->Start;

                if (Start < SrcRangeListEntry->Start) {
                    Start = SrcRangeListEntry->Start;
                };

                End = DstRangeListEntry->End;

                if (End > SrcRangeListEntry->End) {
                    End = SrcRangeListEntry->End;
                };

                if (Start > End) {
                    continue;
                }

                //
                // There are 4 cases:
                //
                //   1. The intersection overlaps the minuend range completely.
                //   2. The intersection overlaps the start of the minuend
                //      range.
                //   3. The intersection overlaps the end of the minuend range.
                //   4. The intersection overlaps the middle of the minuend
                //      range.
                //

                if (DstRangeListEntry->Start == Start) {

                    if (DstRangeListEntry->End == End) {

                        //
                        // Case 1: Remove the minuend range list entry.
                        //

                        ListEntry = DstListEntry;
                        DstListEntry = DstListEntry->Blink;
                        RemoveEntryList(ListEntry);
                        PmFreeRangeListEntry(DstRangeListEntry);
                        break;

                    } else {

                        //
                        // Case 2: Increase the minuend's start.
                        //

                        DstRangeListEntry->Start = End + 1;

                    }

                } else {

                    if (DstRangeListEntry->End == End) {

                        //
                        // Case 3: Decrease the minend's end.
                        //

                        DstRangeListEntry->End = Start - 1;

                    } else {

                        //
                        // Case 4: Divide the range list entry into two
                        //   pieces.  The first range list entry's end should
                        //   be just before the intersection start.  The
                        //   second range list entry's start should be just
                        //   after the intersection end.
                        //

                        RangeListEntry = PmAllocateRangeListEntry();

                        if (RangeListEntry == NULL) {
                            PmFreeRangeList(DstRangeList);
                            return NULL;
                        }

                        RangeListEntry->Start = End + 1;
                        RangeListEntry->End = DstRangeListEntry->End;

                        //
                        // BUGBUG Break the list ordering but ensure that
                        //        we'll perform the subtraction against the
                        //        new range list entry as well.
                        //

                        InsertHeadList(
                            &DstRangeListEntry->ListEntry,
                            &RangeListEntry->ListEntry
                        );

                        DstRangeListEntry->End = Start - 1;

                    }
                }
            }
        }
    }

    return DstRangeList;
}

PPM_RANGE_LIST
PmIntersectRangeList(
    IN PPM_RANGE_LIST SrcRangeList1,
    IN PPM_RANGE_LIST SrcRangeList2
    )

/*++

Routine Description:

    This function creates a new range list which represents the intersection
    between SrcRangeList1 and SrcRangeList2.

Arguments:

    SrcRangeList1, SrcRangeList - The range lists upon which to compute the
        intersection.

Return Value:

    Upon success a pointer to the destination (intersection) PM_RANGE_LIST is
    returned, otherwise NULL.

--*/

{
    PPM_RANGE_LIST DstRangeList;
    PLIST_ENTRY SrcListEntry1;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry1;
    PLIST_ENTRY SrcListEntry2;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry2;
    ULONGLONG Start;
    ULONGLONG End;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    ASSERT(SrcRangeList1 != NULL);
    ASSERT(SrcRangeList2 != NULL);

    DstRangeList = PmAllocateRangeList();

    if (DstRangeList != NULL) {

        for (SrcListEntry1 = SrcRangeList1->List.Flink;
             SrcListEntry1 != &SrcRangeList1->List;
             SrcListEntry1 = SrcListEntry1->Flink) {

            SrcRangeListEntry1 = CONTAINING_RECORD(
                                     SrcListEntry1,
                                     PM_RANGE_LIST_ENTRY,
                                     ListEntry
                                 );

            for (SrcListEntry2 = SrcRangeList2->List.Flink;
                 SrcListEntry2 != &SrcRangeList2->List;
                 SrcListEntry2 = SrcListEntry2->Flink) {

                SrcRangeListEntry2 = CONTAINING_RECORD(
                                         SrcListEntry2,
                                         PM_RANGE_LIST_ENTRY,
                                         ListEntry
                                     );

                Start = SrcRangeListEntry1->Start;

                if (Start < SrcRangeListEntry2->Start) {
                    Start = SrcRangeListEntry2->Start;
                };

                End = SrcRangeListEntry1->End;

                if (End > SrcRangeListEntry2->End) {
                    End = SrcRangeListEntry2->End;
                };

                if (Start > End) {
                    continue;
                }

                RangeListEntry = PmAllocateRangeListEntry();

                if (RangeListEntry == NULL) {
                    PmFreeRangeList(DstRangeList);
                    return NULL;
                }

                RangeListEntry->Start = Start;
                RangeListEntry->End = End;

                InsertTailList(
                    &DstRangeList->List,
                    &RangeListEntry->ListEntry
                );

            }
        }
    }

    return DstRangeList;
}

PPM_RANGE_LIST
PmCreateRangeListFromCmResourceList(
    IN PCM_RESOURCE_LIST CmResourceList
    )

/*++

Routine Description:

    This function converts a CM_RESOURCE_LIST to a PM_RANGE_LIST.  Only
    CmResourceTypeMemory descriptors are added to the PM_RANGE_LIST.

Arguments:

    CmResourceList - The CM_RESOURCE_LIST to convert.

Return Value:

    Upon success a pointer to the converted PM_RANGE_LIST is returned,
    otherwise NULL.

--*/

{
    PPM_RANGE_LIST RangeList;
    PCM_FULL_RESOURCE_DESCRIPTOR FDesc;
    ULONG FIndex;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    ULONG PIndex;
    ULONGLONG Start;
    ULONGLONG End;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    RangeList = PmAllocateRangeList();

    if (RangeList == NULL) {
        return NULL;
    }

    FDesc = CmResourceList->List;

    //
    // Note: Any Device-Specific partial descriptor (which could be
    // variably sized) is defined to be at the end and thus this code
    // is safe.
    //

    for (FIndex = 0;
         FIndex < CmResourceList->Count;
         FIndex++) {

        PDesc = FDesc->PartialResourceList.PartialDescriptors;

        for (PIndex = 0;
             PIndex < FDesc->PartialResourceList.Count;
             PIndex++, PDesc++) {

            //
            // ISSUE Fix for ia64 (andy's change), IA32 large memory region
            //

            if (PDesc->Type == CmResourceTypeMemory) {

                Start = PDesc->u.Memory.Start.QuadPart;
                End = Start + PDesc->u.Memory.Length - 1;

                RangeListEntry = PmAllocateRangeListEntry();

                if (RangeListEntry == NULL) {
                    PmFreeRangeList(RangeList);
                    return NULL;
                }

                RangeListEntry->Start = Start;
                RangeListEntry->End = End;

                InsertTailList(
                    &RangeList->List,
                    &RangeListEntry->ListEntry
                );
            }
        }

        FDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)PDesc;
    }

    return RangeList;
}

PPM_RANGE_LIST
PmCreateRangeListFromPhysicalMemoryRanges(
    VOID
    )

/*++

Routine Description:

    This function calls MmGetPhysicalRanges and converts the returned
    PHYSICAL_MEMORY_RANGE list to a PM_RANGE_LIST.

Arguments:

    None.

Return Value:

    Upon success a pointer to the converted PM_RANGE_LIST is returned,
    otherwise NULL.

--*/

{
    PPM_RANGE_LIST RangeList;
    PPHYSICAL_MEMORY_RANGE MemoryRange;
    ULONG Index;
    ULONGLONG Start;
    ULONGLONG End;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    RangeList = PmAllocateRangeList();

    if (RangeList != NULL) {

        MemoryRange = MmGetPhysicalMemoryRanges();

        if (MemoryRange == NULL) {

            PmFreeRangeList(RangeList);
            RangeList = NULL;

        } else {

            for (Index = 0;
                 MemoryRange[Index].NumberOfBytes.QuadPart != 0;
                 Index++) {

                Start = MemoryRange[Index].BaseAddress.QuadPart;
                End = Start + (MemoryRange[Index].NumberOfBytes.QuadPart - 1);

                RangeListEntry = PmAllocateRangeListEntry();

                if (RangeListEntry == NULL) {
                    PmFreeRangeList(RangeList);
                    ExFreePool(MemoryRange);
                    return NULL;
                }

                RangeListEntry->Start = Start;
                RangeListEntry->End = End;

                InsertTailList(
                    &RangeList->List,
                    &RangeListEntry->ListEntry
                );

            }

            ExFreePool(MemoryRange);

        }
    }

    return RangeList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\basedrv\pnpmem\pnpmem.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pnpmem.c

Abstract:

    This module implements the Plug and Play Memory driver entry points.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"
#include <initguid.h>
#include <poclass.h>

#define PM_DEBUG_BUFFER_SIZE   512
#define rgzMemoryManagement L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define rgzMemoryRemovable L"Memory Removable"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );
    
NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
PmPnpDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

VOID
PmUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PmAddDevice)
#pragma alloc_text(PAGE, PmUnload)
#endif

ULONG DbgMask = 0xFFFFFFFF;
BOOLEAN MemoryRemovalSupported;

#if DBG
VOID
PmDebugPrint(
    ULONG   DebugPrintLevel,
    PCCHAR  DebugMessage,
    ...
    )
/*++

Routine Description:

Arguments:

    DebugPrintLevel - The bit mask that when anded with the debuglevel, must
                        equal itself
    DebugMessage    - The string to feed through vsprintf

Return Value:

    None

--*/
{
    va_list ap;
    UCHAR   debugBuffer[PM_DEBUG_BUFFER_SIZE];

    //
    // Get the variable arguments
    //
    va_start( ap, DebugMessage );

    //
    // Call the kernel function to print the message
    //
    _vsnprintf( debugBuffer, PM_DEBUG_BUFFER_SIZE, DebugMessage, ap );

    if (DebugPrintLevel & DbgMask) {
        DbgPrint("%s", debugBuffer);
    }

    //
    // We are done with the varargs
    //
    va_end( ap );
}
#endif

NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This function creates a functional device object and attaches it to
    the physical device object (device stack).

Arguments:

    DriverObject - The driver object.

    Pdo - The physical device object.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT attachedDeviceObject;
    PPM_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Create the FDO.
    //

    status = IoCreateDevice(
                 DriverObject,
                 sizeof (PM_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_UNKNOWN,
                 0,
                 FALSE,
                 &functionalDeviceObject
                 );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Attach the FDO (indirectly) to the PDO.
    //
    
    deviceExtension = functionalDeviceObject->DeviceExtension;

    deviceExtension->AttachedDevice = IoAttachDeviceToDeviceStack(
                                          functionalDeviceObject,
                                          PhysicalDeviceObject
                                          );

    if (deviceExtension->AttachedDevice == NULL) {
        IoDeleteDevice(functionalDeviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    IoInitializeRemoveLock(&deviceExtension->RemoveLock,
                           PNPMEM_POOL_TAG, 1, 20);

    functionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
PmControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(deviceExtension->AttachedDevice, Irp);
}

VOID
PmPowerCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;
    PIRP Irp;
    NTSTATUS status;

    Irp = Context;
    deviceExtension = DeviceObject->DeviceExtension;

    Irp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
}

NTSTATUS
PmPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID NotUsed
    )
/*++

Routine Description:

   The completion routine for Power

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Not used  - context pointer

Return Value:

   NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PPM_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        SYSTEM_POWER_STATE system =
            irpStack->Parameters.Power.State.SystemState;
        POWER_STATE power;

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            power.DeviceState = deviceExtension->DeviceStateMapping[system];

            status = PoRequestPowerIrp(DeviceObject,
                              irpStack->MinorFunction,
                              power,
                              PmPowerCallback,
                              Irp, 
                              NULL);
            if (NT_SUCCESS(status)) {
                return STATUS_MORE_PROCESSING_REQUIRED;
            } else {
                Irp->IoStatus.Status = status;
            }
        }
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return STATUS_SUCCESS;
    } else {
        if (NT_SUCCESS(Irp->IoStatus.Status)) {
            PoSetPowerState(DeviceObject, DevicePowerState,
                            irpStack->Parameters.Power.State);
            deviceExtension->PowerState =
                irpStack->Parameters.Power.State.DeviceState;
        }
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return STATUS_SUCCESS;
    }
}
NTSTATUS
PmPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);
    if (status == STATUS_DELETE_PENDING) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
         PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_POWER:
        case IRP_MN_SET_POWER:
            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   PmPowerCompletion,
                                   NULL,  //Context
                                   TRUE,  //InvokeOnSuccess
                                   TRUE,  //InvokeOnError
                                   TRUE   //InvokeOnCancel
                                   );
            (VOID) PoCallDriver(deviceExtension->AttachedDevice, Irp);
            return STATUS_PENDING;
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return status;
        }
    } else {
        switch (irpStack->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpStack->Parameters.Power.State.DeviceState <=
                deviceExtension->PowerState) {

                //
                // Powering up device
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       PmPowerCompletion,
                                       NULL,   //Context
                                       TRUE,   //InvokeOnSuccess
                                       TRUE,  //InvokeOnError
                                       TRUE   //InvokeOnCancel
                                       );
                (VOID) PoCallDriver(deviceExtension->AttachedDevice, Irp);
                return STATUS_PENDING;

            } else {

                //
                // Powering down device
                //

                PoSetPowerState(DeviceObject, DevicePowerState,
                                irpStack->Parameters.Power.State);
                deviceExtension->PowerState =
                    irpStack->Parameters.Power.State.DeviceState;
                // 
                // Fall through ...
                //
            }
        case IRP_MN_QUERY_POWER:
            //
            // Fall through as the bus driver will mark this
            // STATUS_SUCCESS and complete it, if it gets that far.
            //
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            break;
        }
        status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This function initializes the driver object.

Arguments:

    DriverObject - The driver object.

    RegistryPath - The registry path for the device.

Return Value:

    STATUS_SUCCESS

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    HANDLE hMemoryManagement;
    NTSTATUS status;
    
    PAGED_CODE();

    RtlInitUnicodeString (&unicodeString, rgzMemoryManagement);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);
    status = ZwOpenKey(&hMemoryManagement, KEY_READ, &objectAttributes);
    if (NT_SUCCESS(status)) {
        status = PmGetRegistryValue(hMemoryManagement,
                                    rgzMemoryRemovable,
                                    &valueInfo);
        if (NT_SUCCESS(status)) {
            if ((valueInfo->Type == REG_DWORD) &&
                (valueInfo->DataLength >= sizeof(ULONG))) {
                MemoryRemovalSupported = (BOOLEAN) *((PULONG)valueInfo->Data);
            }
            ExFreePool(valueInfo);
        }
        ZwClose(hMemoryManagement);
    }

    DriverObject->MajorFunction[IRP_MJ_PNP] = PmPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PmPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PmControlDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PmControlDispatch;
    DriverObject->DriverExtension->AddDevice = PmAddDevice;

    return STATUS_SUCCESS;
}

VOID
PmUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    
    This is called to reverse any operations performed in DriverEntry before a
    driver is unloaded.
        
Arguments:

    DriverObject - The system owned driver object for PNPMEM
    
--*/
{
    PAGED_CODE();
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_common.h ===
#if !defined(_WINDOWS_BCL_COMMON_H_INCLUDED_)
#define _WINDOWS_BCL_COMMON_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_common.h

Abstract:

    Definitions common to all of the Base Class Libraries
    implementation.

Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <memory.h> // for memcpy
#include <string.h> // for memmove
#include <limits.h> // for CHAR_BIT

namespace BCL {

//
//  Macros for error handling in BCL functions
//
//  Rather than try to break down the purpose of each, here's a couple of
//  examples:
//
//  TCallDisposition Foo(int i) { // TCallDisposition indicates internal linkage
//      BCL_MAYFAIL_PROLOG      // first line of any function that can fail
//      int j;
//      BCL_PARAMETER_CHECK((i >= 0) && (i <= 100));
//      BCL_IFCALLFAILED_EXIT(Bar(i, &j)); // assumes Bar also has internal linkage
//      BCL_ASSERT(j >= 0);
//      BCL_INTERNAL_ERROR_CHECK(i != j);
//      BCL_MAYFAIL_EPILOG_INTERNAL // last line when internal linkage
//  }
//
//  BOOL Win32ishFoo(int i) {
//      BCL_MAYFAIL_PROLOG
//      BCL_IFCALLFAILED_EXIT(Foo(i));
//      BCL_MAYFAIL_EPILOG_PUBLIC
//  }
//

#define BCL_ORIGINATE_ERROR(_error) do { _bcl_cd = (_error); goto Exit; } while (0)

#define BCL_CALLBACK_FAILED do { goto Exit; } while (0)

#if _X86_
#define BCL_DEBUG_BREAK do { __asm { int 3 } } while (0)
#else
#define BCL_DEBUG_BREAK do { DebugBreak(VOID); } while (0)
#endif

#define BCL_ASSERTION_FAILURE_ACTION(_szExpr) BCL_DEBUG_BREAK

#define BCL_ASSERT(_e) do { if (!(_e)) { BCL_ASSERTION_FAILURE_ACTION(#_e); } } while (0)

#define BCL_COMPILE_TIME_ASSERT(_e) typedef char __c_assert[(_e) ? 1 : -1]

#define BCL_INTERNAL_ERROR_FAILURE_ACTION(_szExpr) do { BCL_DEBUG_BREAK; _bcl_cd = TCallDisposition::InternalError_RuntimeCheck(); goto Exit; } while (0)

#define BCL_INTERNAL_ERROR_CHECK(_e) do { if (!(_e)) { BCL_INTERNAL_ERROR_FAILURE_ACTION(#_e); } } while (0)

#define BCL_MAYFAIL_PROLOG \
    TCallDisposition _bcl_cd = TCallDisposition::InternalError_EpilogSkipped();

#define BCL_MAYFAIL_EPILOG_INTERNAL \
    _bcl_cd = TCallDisposition::Success(); \
    if (false) { goto Exit; } \
Exit: \
    return _bcl_cd;

#define BCL_MAYFAIL_EPILOG_PUBLIC \
    _bcl_cd = TCallDisposition::Success(); \
    if (false) { goto Exit; } \
Exit: \
    return _bcl_cd.OnPublicReturn();

#define BCL_NOFAIL_PROLOG /* nothing */
#define BCL_NOFAIL_EPILOG /* nothing */

#define BCL_PARAMETER_CHECK_FAILURE_ACTION(_p) do { _bcl_cd = TCallDisposition::BadParameter(); goto Exit; } while (0)

#define BCL_PARAMETER_CHECK(_p) do { if (!(_p)) { BCL_PARAMETER_CHECK_FAILURE_ACTION(_p); } } while (0)

#define BCL_IFCALLFAILED_EXIT(_e) do { const TCallDisposition _bcl_cd_temp = (_e); if (_bcl_cd_temp.DidFail()) { _bcl_cd = _bcl_cd_temp; goto Exit; } } while (0)

#define BCL_NUMBER_OF(_x) (sizeof(_x) / sizeof((_x)[0]))

template <typename T, typename TSizeT> class CConstantPointerAndCountPair;
template <typename T, typename TSizeT> class CMutablePointerAndCountPair;
template <typename T, typename TSizeT> class CConstantPointerAndCountRefPair;
template <typename T, typename TSizeT> class CMutablePointerAndCountRefPair;

template <typename T, typename TSizeT>
class CConstantPointerAndCountPair 
{
public:
    typedef const T *TConstantArray;
    typedef T *TMutableArray;
    typedef T TPointee;
    typedef TSizeT TCount;

    inline CConstantPointerAndCountPair() : m_prg(NULL), m_c(0) { }
    inline CConstantPointerAndCountPair(TConstantArray prg, TSizeT c) : m_prg(prg), m_c(c) { }
    inline CConstantPointerAndCountPair(const CMutablePointerAndCountPair<T, TSizeT> &r) : m_prg(r.m_prg), m_c(r.m_c) { }
    inline CConstantPointerAndCountPair(const CConstantPointerAndCountPair &r) : m_prg(r.m_prg), m_c(r.m_c) { }
    inline ~CConstantPointerAndCountPair() { }

    CConstantPointerAndCountPair &operator =(const CConstantPointerAndCountPair &r)
    {
        m_prg = r.m_prg;
        m_c = r.m_c;
        return *this;
    }

    CConstantPointerAndCountPair &operator =(const CMutablePointerAndCountPair<T, TSizeT> &r)
    {
        m_prg = r.m_prg;
        m_c = r.m_c;
        return *this;
    }

    inline TConstantArray GetPointer() const { return m_prg; }
    inline TSizeT GetCount() const { return m_c; }

    inline TConstantArray &Pointer() { return m_prg; }
    inline TSizeT &Count() { return m_c; }

    inline void SetCount(TSizeT c) { m_c = c; }
    inline void SetPointer(TConstantArray prg) { m_prg = prg; }

    inline void SetPointerAndCount(TConstantArray prg, TSizeT c) { m_prg = prg; m_c = c; }

    inline bool Valid() const { return (m_prg != NULL) || (m_c == 0); }
    
    inline CConstantPointerAndCountPair GetOffsetPair(TSizeT n) { return CConstantPointerAndCountPair(m_prg + n, m_c - n); }

protected:
    TConstantArray m_prg;
    TSizeT m_c;
}; // BCL::CConstantPointerAndCountPair<T, TSizeT>

template <typename T, typename TSizeT>
class CMutablePointerAndCountPair : public CConstantPointerAndCountPair<T, TSizeT>
{
public:
    typedef const T *TConstantArray;
    typedef T *TMutableArray;

    inline CMutablePointerAndCountPair() { }
    inline CMutablePointerAndCountPair(TMutableArray prg, TSizeT c) : CConstantPointerAndCountPair<T, TSizeT>(prg, c) { }
    inline ~CMutablePointerAndCountPair() { }

    using CConstantPointerAndCountPair<T, TSizeT>::Valid;

    CMutablePointerAndCountPair &operator =(const CMutablePointerAndCountPair &r)
    {
        m_prg = r.m_prg;
        m_c = r.m_c;
        return *this;
    }

    inline TMutableArray GetPointer() const { return const_cast<TMutableArray>(m_prg); }
    inline TSizeT GetCount() const { return m_c; }

    inline TMutableArray &Pointer() { return const_cast<TMutableArray &>(m_prg); }
    inline TSizeT &Count() { return m_c; }

    inline void SetPointer(TMutableArray prg) { m_prg = prg; }
    inline void SetCount(TSizeT c) { m_c = c; }

    inline void SetPointerAndCount(TMutableArray prg, TSizeT c) { m_prg = prg; m_c = c; }
}; // BCL::CMutablePointerAndCountPair<T, TSizeT>

template <typename T, typename TSizeT>
class CConstantPointerAndCountRefPair
{
public:
    typedef const T *TConstantArray;
    typedef T *TMutableArray;
    typedef T TPointee;
    typedef TSizeT TCount;

    inline CConstantPointerAndCountRefPair(TConstantArray &rprg, TSizeT &rc) : m_rprg(rprg), m_rc(rc) { }
    inline CConstantPointerAndCountRefPair(const CMutablePointerAndCountRefPair<T, TSizeT> &r) : m_rprg(r.m_rprg), m_rc(r.m_rc) { }
    inline CConstantPointerAndCountRefPair(const CConstantPointerAndCountRefPair &r) : m_rprg(r.m_rprg), m_rc(r.m_rc) { }
    inline ~CConstantPointerAndCountRefPair() { }

    inline CConstantPointerAndCountRefPair &operator =(const CConstantPointerAndCountPair<T, TSizeT> &r)
    {
        m_rprg = r.GetPointer();
        m_rc = r.GetCount();
        return *this;
    }

    inline operator CConstantPointerAndCountPair<T, TSizeT>() const { return BCL::CConstantPointerAndCountPair<T, TSizeT>(m_rprg, m_rc); }

    inline TConstantArray GetPointer() const { return m_rprg; }
    inline TSizeT GetCount() const { return m_rc; }

    inline TConstantArray &Pointer() { return m_rprg; }
    inline TSizeT &Count() { return m_rc; }

    inline void SetCount(TSizeT c) { m_rc = c; }
    inline void SetPointer(TConstantArray prg) { m_rprg = prg; }

    inline void SetPointerAndCount(TConstantArray prg, TSizeT c) { m_rprg = prg; m_rc = c; }

    inline bool Valid() const { return (m_rprg != NULL) || (m_rc == 0); }
    
    inline CConstantPointerAndCountPair GetOffsetPair(TSizeT n) { return CConstantPointerAndCountPair(m_rprg + n, m_rc - n); }

protected:
    TConstantArray &m_rprg;
    TSizeT &m_rc;
}; // BCL::CConstantPointerAndCountRefPair<T, TSizeT>

template <typename T, typename TSizeT>
class CMutablePointerAndCountRefPair : public CConstantPointerAndCountRefPair<T, TSizeT>
{
public:
    typedef const T *TConstantArray;
    typedef T *TMutableArray;

    inline CMutablePointerAndCountRefPair(TMutableArray &rprg, TSizeT &rc) : CConstantPointerAndCountRefPair<T, TSizeT>(rprg, rc) { }
    inline ~CMutablePointerAndCountRefPair() { }

    using CConstantPointerAndCountRefPair<T, TSizeT>::Valid;

    CMutablePointerAndCountRefPair &operator =(const CMutablePointerAndCountPair &r)
    {
        m_rprg = r.GetPointer();
        m_rc = r.GetCount();
        return *this;
    }

    inline operator CMutablePointerAndCountPair<T, TSizeT>() const { return BCL::CMutablePointerAndCountPair<T, TSizeT>(m_rprg, m_rc); }

    inline TMutableArray GetPointer() const { return const_cast<TMutableArray>(m_rprg); }
    inline TSizeT GetCount() const { return m_c; }

    inline TMutableArray &Pointer() { return const_cast<TMutableArray &>(m_rprg); }
    inline TSizeT &Count() { return m_c; }

    inline void SetPointer(TMutableArray prg) { m_rprg = prg; }
    inline void SetCount(TSizeT c) { m_rc = c; }

    inline void SetPointerAndCount(TMutableArray prg, TSizeT c) { m_rprg = prg; m_rc = c; }
}; // BCL::CMutablePointerAndCountRefPair<T, TSizeT>

#pragma intrinsic(memcmp)
#pragma intrinsic(memcpy)

inline
bool
__fastcall
IsMemoryEqual(
    const void *pv1,
    const void *pv2,
    size_t cb
    )
{
    return (memcmp(pv1, pv2, cb) == 0);
} // BCL::IsMemoryEqual

template <typename T, typename TSizeT>
inline
bool
__fastcall
IsMemoryEqual(
    const CConstantPointerAndCountPair<T, TSizeT> &rpair1,
    const CConstantPointerAndCountPair<T, TSizeT> &rpair2
    )
{
    return ((rpair1.GetCount() == rpair2.GetCount()) &&
            (BCL::IsMemoryEqual(
                rpair1.GetPointer(),
                rpair2.GetPointer(),
                rpair1.GetCount() * sizeof(T))));
} // BCL::IsMemoryEqual

template <typename TComparisonResult>
inline
TComparisonResult
__fastcall
CompareBytes(
    const void *pv1,
    const void *pv2,
    size_t cb
    )
{
    int i = memcmp(pv1, pv2, cb);
    if (i < 0)
        return TComparisonResult::LessThan();
    else if (i == 0)
        return TComparisonResult::EqualTo();
    else
        return TComparisonResult::GreaterThan();
} // BCL::CompareBytes

template <typename T, typename TSizeT, typename TComparisonResult>
inline
TComparisonResult
__fastcall
CompareBytes(
    const CConstantPointerAndCountPair<T, TSizeT> &rpair1,
    const CConstantPointerAndCountPair<T, TSizeT> &rpair2
    )
{
    TComparisonResult cr = BCL::CompareBytes<TComparisonResult>(
        rpair1.GetPointer(),
        rpair2.GetPointer(),
        ((rpair1.GetCount() < rpair2.GetCount()) ? rpair1.GetCount() : rpair2.GetCount()) * sizeof(T));
    if (cr.IsEqualTo())
    {
        if (rpair1.GetCount() < rpair2.GetCount())
            cr.SetLessThan();
        else if (rpair1.GetCount() > rpair2.GetCount())
            cr.SetGreaterThan();
    }
    return cr;
} // BCL::CompareBytes

inline
void
__fastcall
CopyBytes(
    void *pvDestination,
    const void *pvSource,
    size_t cbToCopy
    )
{
    memcpy(pvDestination, pvSource, cbToCopy);
} // BCL::CopyBytes

template <typename T, typename TSizeT>
inline
void
__fastcall
CopyBytes(
    const CMutablePointerAndCountPair<T, TSizeT> &rpairOut,
    const CConstantPointerAndCountPair<T, TSizeT> &rpairIn
    )
{
    BCL_ASSERT(rpairOut.GetCount() >= rpairIn.GetCount());
    // Be defensive...
    BCL::CopyBytes(
        rpairOut.GetPointer(),
        rpairIn.GetPointer(),
        (rpairIn.GetCount() > rpairOut.GetCount()) ? rpairOut.GetCount() : rpairIn.GetCount());
} // BCL::CopyBytes

inline
void
__fastcall
MoveBytes(
    void *pvDestination,
    const void *pvSource,
    size_t cbToCopy
    )
{
    memmove(pvDestination, pvSource, cbToCopy);
} // BCL::MoveBytes

template <typename T, typename TSizeT>
inline
void
__fastcall
MoveBytes(
    const CMutablePointerAndCountPair<T, TSizeT> &rpairOut,
    const CConstantPointerAndCountPair<T, TSizeT> &rpairIn
    )
{
    BCL_ASSERT(rpairOut.GetCount() >= rpairIn.GetCount());
    // Be defensive...
    BCL::MoveBytes(
        rpairOut.GetPointer(),
        rpairIn.GetPointer(),
        (rpairIn.GetCount() > rpairOut.GetCount()) ? rpairOut.GetCount() : rpairIn.GetCount());
} // BCL::MoveBytes

template <typename T, typename TSizeT>
inline
void
__fastcall
CopyBytesAndAdvance(
    CMutablePointerAndCountPair<T, TSizeT> &rpairOut,
    const CConstantPointerAndCountPair<T, TSizeT> &rpairIn
    )
{
    const TSizeT cToCopy = (rpairIn.GetCount() > rpairOut.GetCount()) ? rpairOut.GetCount() : rpairIn.GetCount();

    BCL_ASSERT(cToCopy == rpairIn.GetCount());

    BCL::CopyBytes(
        rpairOut.GetPointer(),
        rpairIn.GetPointer(),
        cToCopy * sizeof(T));
    rpairOut.SetPointerAndCount(rpairOut.GetPointer() + cToCopy, rpairOut.GetCount() - cToCopy);
} // BCL::CopyBytesAndAdvance

template <typename T, typename TCallDisposition>
inline TCallDisposition __fastcall AddWithOverflowCheck(T left, T right, T& output)
{
    const T Result = left + right;

    if ((Result < left) || (Result < right))
        return TCallDisposition::ArithmeticOverflow();

    output = Result;
    return TCallDisposition::Success();
}

template <typename T, typename TCallDisposition>
inline TCallDisposition __fastcall MultiplyWithOverflowCheck(T factor1, T factor2, T &rproduct)
{
    //
    //  Ok, this is somewhat tricky for SIZE_T.  Here's what we'll assume:
    //
    //  We'll assume that we can take each factor and split it into two halves
    //  by using (CHAR_BITS * sizeof(SIZE_T) / 2).  (This of course assumes that
    //  one or the other is even which is a pretty safe bet.)
    //

#define HALF_T_BITS(_t) (CHAR_BIT * sizeof(_t) / 2)
#define HALF_T_MASK(_t) ((1 << HALF_T_BITS(_t)) - 1)

    const T lowFactor1 = factor1 & HALF_T_MASK(T);
    const T highFactor1 = (factor1 >> HALF_T_BITS(T)) & HALF_T_MASK(T);
    const T lowFactor2 = factor2 & HALF_T_MASK(T);
    const T highFactor2 = (factor2 >> HALF_T_BITS(T)) & HALF_T_MASK(T);

    // If both have non-zero high halves, we definitely have an overflow

    if ((highFactor1 != 0) && (highFactor2 != 0))
        return TCallDisposition::ArithmeticOverflow();

    const T crossproduct1 = (lowFactor1 * highFactor2);
    const T crossproduct2 = (lowFactor2 * highFactor1);
    const T crossproductsum = (crossproduct1 + crossproduct2);

    if ((crossproductsum < crossproduct1) || (crossproductsum < crossproduct2))
        return TCallDisposition::ArithmeticOverflow();

    // We're going to have to shift the cross product sum by HALF_SIZE_T_BITS
    // so let's make sure we don't lose anything.
    if ((crossproductsum >> HALF_T_BITS(T)) != 0)
        return TCallDisposition::ArithmeticOverflow();

    // Ok, we should be OK...
    rproduct = (crossproductsum << HALF_T_BITS(T)) + (lowFactor1 * lowFactor2);
    return TCallDisposition::Success();
}

}; // namespace BCL

#endif // !defined(_WINDOWS_BCL_COMMON_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_ntbaseunicodestringbuffer.h ===
#if !defined(_BCL_NTBASEUNICODESTRINGBUFFER_H_INCLUDED_)
#define _BCL_NTBASEUNICODESTRINGBUFFER_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_w32baseunicodestringbuffer.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_vararg.h>
#include <bcl_ntunicodestringalgorithms.h>

#include <limits.h>

namespace BCL
{

template <typename TBuffer, typename TCallDispositionT, typename TPublicErrorReturnTypeT>
class CNtBaseUnicodeStringBufferTraits : public BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>, public BCL::CNtNullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>
{
public:
    typedef CNtBaseUnicodeStringBufferTraits TThis;

    friend BCL::CPureString<TThis>;
    friend BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>;
    typedef BCL::CPureString<TThis> TPureString;

    typedef TCallDispositionT TCallDisposition;
    typedef TPublicErrorReturnTypeT TPublicErrorReturnType;

    typedef CNtStringComparisonResult TComparisonResult;

    typedef BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> TConstantPair;
    typedef BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> TMutablePair;

    typedef CNtCaseInsensitivityData TCaseInsensitivityData;
    typedef SIZE_T TSizeT;

    typedef CNtMBCSToUnicodeDataIn TDecodingDataIn;
    typedef CNtMBCSToUnicodeDataOut TDecodingDataOut;
    typedef CNtUnicodeToMBCSDataIn TEncodingDataIn;
    typedef CNtUnicodeToMBCSDataOut TEncodingDataOut;

    typedef CConstantPointerAndCountPair<CHAR, SIZE_T> TConstantNonNativePair;
    typedef CMutablePointerAndCountPair<CHAR, SIZE_T> TMutableNonNativePair;

    typedef BCL::CNtPWSTRAllocationHelper TPWSTRAllocationHelper;
    typedef BCL::CNtPSTRAllocationHelper TPSTRAllocationHelper;

    using BCL::CNtNullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TMutableString;
    using BCL::CNtNullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TConstantString;
    using BCL::CNtNullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TMutableNonNativeString;
    using BCL::CNtNullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TConstantNonNativeString;

    // exposing the things from our private base class
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::CopyIntoBuffer;
    using BCL::CNtNullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::CopyIntoBuffer;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::DetermineRequiredCharacters;
    using BCL::CNtNullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::DetermineRequiredCharacters;

    static inline TMutablePair & __fastcall MutableBufferPair(BCL::CBaseString *p) { return static_cast<TBuffer *>(p)->m_pair; }
    static inline const TConstantPair & __fastcall BufferPair(const BCL::CBaseString *p) { return static_cast<const TConstantPair &>(static_cast<const TBuffer *>(p)->m_pair); }
    static inline TConstantPair __fastcall GetStringPair(const BCL::CBaseString *p) { return TConstantPair(TBuffer::TTraits::GetBufferPtr(p), TBuffer::TTraits::GetStringCch(p)); }
    static inline TMutablePair __fastcall GetOffsetMutableBufferPair(const BCL::CBaseString *p, TSizeT cchOffset) { BCL_ASSERT(cchOffset <= TBuffer::TTraits::GetBufferCch(p)); if (cchOffset > TBuffer::TTraits::GetBufferCch(p)) cchOffset = TBuffer::TTraits::GetBufferCch(p); return TMutablePair(const_cast<TMutableString>(TBuffer::TTraits::GetBufferPtr(p)) + cchOffset, TBuffer::TTraits::GetBufferCch(p) - cchOffset); }

    static inline bool __fastcall AnyAccessors(const BCL::CBaseString *p) { return (static_cast<const TBuffer *>(p)->m_cAttachedAccessors != 0); }
    static inline bool __fastcall NoAccessors(const BCL::CBaseString *p) { return (static_cast<const TBuffer *>(p)->m_cAttachedAccessors == 0); }
    static inline TCallDisposition __fastcall NoAccessorsCheck(const BCL::CBaseString *p) { if (TBuffer::TTraits::AnyAccessors(p)) { return TCallDisposition::InternalError_ObjectLocked(); } return TCallDisposition::Success(); }

    static inline PCWSTR __fastcall GetBufferPtr(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->m_pair.GetPointer(); }
    static inline PWSTR __fastcall GetMutableBufferPtr(BCL::CBaseString *p) { return static_cast<TBuffer *>(p)->m_pair.GetPointer(); }
    static inline SIZE_T __fastcall GetBufferCch(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->m_pair.GetCount(); }
    static inline void __fastcall SetBufferPointerAndCount(BCL::CBaseString *p, PWSTR pszBuffer, SIZE_T cchBuffer) { static_cast<TBuffer *>(p)->m_pair.SetPointerAndCount(pszBuffer, cchBuffer); }

    static inline SIZE_T __fastcall GetStringCch(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->m_cchString; }

    static inline void _fastcall SetStringCch(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_ASSERT((cch == 0) || (cch < TBuffer::TTraits::GetBufferCch(p)));
        static_cast<TBuffer *>(p)->m_cchString = cch;
        if (TBuffer::TTraits::GetBufferCch(p) != 0)
            TBuffer::TTraits::GetMutableBufferPtr(p)[cch] = L'\0';
    }

    static inline void __fastcall IntegrityCheck(const BCL::CBaseString *p) { }
    static inline PWSTR __fastcall GetInlineBufferPtr(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->GetInlineBufferPtr(); }
    static inline SIZE_T __fastcall GetInlineBufferCch(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->GetInlineBufferCch(); }

    static inline TCallDisposition __fastcall ReallocateBuffer(BCL::CBaseString *p, SIZE_T cch)
    {
        PWSTR psz = NULL;
        SIZE_T cb = (cch * sizeof(WCHAR));
        TBuffer *pBuffer = static_cast<TBuffer *>(p);

        if (cch != (cb / sizeof(WCHAR)))
            return TCallDisposition::ArithmeticOverflow();

        if (pBuffer->GetBufferPtr() != NULL)
        {
            ::SetLastError(ERROR_SUCCESS);

            psz = 
                reinterpret_cast<PWSTR>(
                    ::RtlReAllocateHeap(
                        RtlProcessHeap(),
                        0,
                        const_cast<PWSTR>(pBuffer->GetBufferPtr()),
                        cb));
            if (psz == NULL)
            {
                const DWORD dwLastError = ::GetLastError();
                // HeapReAlloc doesn't always set last error, so we rely on this
                // fact to find that the win32 last error hasn't changed from
                // before to infer ERROR_OUTOFMEMORY.  -mgrier 2/2/2002
                if (dwLastError == ERROR_SUCCESS)
                    return TCallDisposition::OutOfMemory();
                return TCallDisposition::FromWin32Error(dwLastError);
            }
        }
        else
        {
            psz = 
                reinterpret_cast<PWSTR>(
                    ::RtlAllocateHeap(
                        RtlProcessHeap(),
                        0,
                        cb));
        }

        if (psz == NULL)
            return TCallDisposition::OutOfMemory();

        pBuffer->SetBufferPointerAndCount(psz, cch);

        return TCallDisposition::Success();
    }

    static inline void __fastcall DeallocateBuffer(PCWSTR psz) { if (psz != NULL) ::RtlFreeHeap(RtlProcessHeap(), 0, reinterpret_cast<PVOID>(const_cast<PWSTR>(psz))); }

    static inline void __fastcall DeallocateDynamicBuffer(BCL::CBaseString *p) { static_cast<TBuffer *>(p)->DeallocateDynamicBuffer(); }

}; // class CNtBaseUnicodeStringBufferTraits

class CNtBaseUnicodeStringBufferAddIn
{
protected:
    enum { LengthQuantaPerChar = 1; }; // One unit of length is one character

    inline CNtBaseUnicodeStringBufferAddIn(PWSTR pszInitialBuffer, SIZE_T cchInitialBuffer) : m_pair(pszInitialBuffer, cchInitialBuffer), m_cchString(0), m_cAttachedAccessors(0) { }

    inline static BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> PairFromPCWSTR(PCWSTR psz) { return BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T>(psz, (psz == NULL) ? 0 : wcslen(psz)); }
    inline static BCL::CConstantPointerAndCountPair<CHAR, SIZE_T> PairFromPCSTR(PCSTR psz) { return BCL::CConstantPointerAndCountPair<CHAR, SIZE_T>(psz, (psz == NULL) ? 0 : strlen(psz)); }

    inline static CNtANSIToUnicodeDataIn ANSIDecodingDataIn() { return CNtANSIToUnicodeDataIn(); }
    inline static CNtOEMToUnicodeDataIn OEMDecodingDataIn() { return CNtOEMToUnicodeDataIn(); }
    inline static CNtUnicodeToANSIDataIn ANSIEncodingDataIn() { return CNtUnicodeToANSIDataIn t; }
    inline static CNtUnicodeToOEMDataIn OEMEncodingDataIn() { return CNtUnicodeToOEMDataIn t; }

    inline BCL::CPointerAndCountPair<WCHAR, SIZE_T> MutablePair() { return m_pair; }
    inline BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> ConstantPair() const { return m_pair; }

    inline BCL::CPointerAndCountPair<WCHAR, SIZE_T> MutableStringPair() { return return BCL::CPointerAndCountRefPair<WCHAR, SIZE_T>(m_pair.GetPointer(), m_cchString);  }
    inline BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> ConstantStringPair() const { return m_pair; }

private:
    BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> m_pair;
    SIZE_T m_cchString;
    LONG m_cAttachedAccessors;
};

class CNtBaseUNICODE_STRINGBufferAddIn
{
protected:
    enum { LengthQuantaPerChar = 2; }; // Two units of length are one charater

    inline CNtBaseUnicodeStringBufferAddIn(PWSTR pszInitialBuffer, USHORT cchInitialBuffer) : m_pair(pszInitialBuffer, cchInitialBuffer), m_cchString(0), m_cAttachedAccessors(0) { }

    inline static BCL::CConstantPointerAndCountPair<WCHAR, USHORT> PairFromPCWSTR(PCWSTR psz) { return BCL::CConstantPointerAndCountPair<WCHAR, USHORT>(psz, (psz == NULL) ? 0 : wcslen(psz)); }
    inline static BCL::CConstantPointerAndCountPair<CHAR, USHORT> PairFromPCSTR(PCSTR psz) { return BCL::CConstantPointerAndCountPair<CHAR, USHORT>(psz, (psz == NULL) ? 0 : strlen(psz)); }

    inline static CNtANSIToUnicodeDataIn ANSIDecodingDataIn() { return CNtANSIToUnicodeDataIn(); }
    inline static CNtOEMToUnicodeDataIn OEMDecodingDataIn() { return CNtOEMToUnicodeDataIn(); }
    inline static CNtUnicodeToANSIDataIn ANSIEncodingDataIn() { return CNtUnicodeToANSIDataIn t; }
    inline static CNtUnicodeToOEMDataIn OEMEncodingDataIn() { return CNtUnicodeToOEMDataIn t; }

    inline BCL::CPointerAndCountRefPair<WCHAR, USHORT> MutablePair() { return BCL::CPointerAndCountRefPair<WCHAR, USHORT>(m_us.Buffer, m_us.MaximumLength); }
    inline BCL::CConstantPointerAndCountPair<WCHAR, USHORT> ConstantPair() const { return BCL::CConstantPointerAndCountPair<WCHAR, USHORT>(m_us.Buffer, m_us.MaximumLength); }

    inline BCL::CPointerAndCountRefPair<WCHAR, USHORT> MutableStringPair() { return BCL::CPointerAndCountRefPair<WCHAR, USHORT>(m_us.Buffer, m_us.Length); }
    inline BCL::CConstantPointerAndCountPair<WCHAR, USHORT> ConstantStringPair() const { return BCL::CConstantPointerAndCountPair<WCHAR, USHORT>(m_us.Buffer, m_us.Length); }
private:
    UNICODE_STRING m_us;
    BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> m_pair;
    SIZE_T m_cchString;
    LONG m_cAttachedAccessors;
};

}; // namespace BCL

#endif // !defined(_BCL_NTBASEUNICODESTRINGBUFFER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_ntcommon.h ===
#if !defined(_BCL_NTCOMMON_H_INCLUDED_)
#define _BCL_NTCOMMON_H_INCLUDED_

#pragma once

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>

namespace BCL
{

class CNtStringComparisonResult
{
public:
    inline void SetLessThan() { m_iComparisonResult = -1; }
    inline bool IsLessThan() const { return m_iComparisonResult == -1; }
    inline static CNtStringComparisonResult LessThan() { CNtStringComparisonResult cr; cr.m_iComparisonResult = -1; return cr; }

    inline void SetEqualTo() { m_iComparisonResult = 0; }
    inline bool IsEqualTo() const { return m_iComparisonResult == 0; }
    inline static CNtStringComparisonResult EqualTo() { CNtStringComparisonResult cr; cr.m_iComparisonResult = 0; return cr; }

    inline void SetGreaterThan() { m_iComparisonResult = 1; }
    inline bool IsGreaterThan() const { return m_iComparisonResult == 1; }
    inline static CNtStringComparisonResult GreaterThan() { CNtStringComparisonResult cr; cr.m_iComparisonResult = 1; return cr; }

    int m_iComparisonResult;
};

class CNtUnicodeToANSIDataIn
{
public:
};

class CNtUnicodeToOEMDataIn
{
public:
};

class CNtUnicodeToANSIDataOut
{
public:
};

class CNtUnicodeToOEMDataOut
{
public:
};

class CNtANSIToUnicodeDataIn
{
public:
};

class CNtOEMToUnicodeDataIn
{
public:
};

class CNtANSIToUnicodeDataOut
{
public:
    // Nothing!
};

class CNtOEMToUnicodeDataOut
{
public:
};

class CNtStringComparisonResultOnExitHelper : public CNtStringComparisonResult
{
public:
    inline CNtStringComparisonResultOnExitHelper(int &riComparisonResult) : m_riComparisonResult(riComparisonResult) { }
    inline ~CNtStringComparisonResultOnExitHelper() { m_riComparisonResult = m_iComparisonResult; }

    CNtStringComparisonResultOnExitHelper& operator=(const CNtStringComparisonResultOnExitHelper& o) { if (this != &o) { this->m_iComparisonResult = o.m_iComparisonResult; } return *this; }

protected:
    int &m_riComparisonResult;
};

class CNtCallDisposition
{
public:
    inline bool DidFail() const { return m_NtStatus != STATUS_SUCCESS; }
    inline bool DidSucceed() const { return m_NtStatus == STATUS_SUCCESS; }

    inline void SetSuccess() { m_NtStatus = STATUS_SUCCESS; }
    inline void SetArithmeticOverflow() { m_NtStatus = STATUS_INTEGER_OVERFLOW; }
    inline void SetArithmeticUnderflow() { m_NtStatus = STATUS_INTEGER_OVERFLOW; }
    inline void SetInternalError_ObjectLocked() { m_NtStatus = STATUS_INTERNAL_ERROR; }
    inline void SetInternalError_RuntimeCheck() { m_NtStatus = STATUS_INTERNAL_ERROR; }
    inline void SetInternalError_EpilogSkipped() { m_NtStatus = STATUS_INTERNAL_ERROR; }
    inline void SetBadParameter() { m_NtStatus = STATUS_INVALID_PARAMETER; }
    inline void SetBufferOverflow() { m_NtStatus = STATUS_BUFFER_OVERFLOW; }
    inline void SetOutOfMemory() { m_NtStatus = STATUS_NO_MEMORY; }

    inline static CNtCallDisposition Success() { CNtCallDisposition t; t.m_NtStatus =  STATUS_SUCCESS; return t; }
    inline static CNtCallDisposition ArithmeticOverflow() { CNtCallDisposition t; t.m_NtStatus =  STATUS_INTEGER_OVERFLOW; return t; }
    inline static CNtCallDisposition ArithmeticUnderflow() { CNtCallDisposition t; t.m_NtStatus =  STATUS_INTEGER_OVERFLOW; return t; }
    inline static CNtCallDisposition InternalError_ObjectLocked() { CNtCallDisposition t; t.m_NtStatus =  STATUS_INTERNAL_ERROR; return t; }
    inline static CNtCallDisposition InternalError_RuntimeCheck() { CNtCallDisposition t; t.m_NtStatus =  STATUS_INTERNAL_ERROR; return t; }
    inline static CNtCallDisposition InternalError_EpilogSkipped() { CNtCallDisposition t; t.m_NtStatus =  STATUS_INTERNAL_ERROR; return t; }
    inline static CNtCallDisposition BadParameter() { CNtCallDisposition t; t.m_NtStatus =  STATUS_INVALID_PARAMETER; return t; }
    inline static CNtCallDisposition BufferOverflow() { CNtCallDisposition t; t.m_NtStatus =  STATUS_BUFFER_OVERFLOW; return t; }
    inline static CNtCallDisposition OutOfMemory() { CNtCallDisposition t; t.m_NtStatus = STATUS_NO_MEMORY; return t; }

    inline NTSTATUS OnPublicReturn() const { return m_NtStatus; }

protected:
    NTSTATUS m_NtStatus;
};

class CNtPWSTRAllocationHelper
{
    typedef CNtCallDisposition TCallDisposition;

public:
    CNtPWSTRAllocationHelper() : m_pwstr(NULL) { }
    ~CNtPWSTRAllocationHelper() { if (m_pwstr != NULL) { ::RtlFreeHeap(RtlProcessHeap(), 0, m_pwstr); m_pwstr = NULL; } }

    CNtCallDisposition Allocate(SIZE_T cch)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T cb;

        if (m_pwstr != NULL)
            BCL_ORIGINATE_ERROR(CNtCallDisposition::InternalError_RuntimeCheck());

        cb = cch * sizeof(WCHAR);
        if ((cb / sizeof(WCHAR)) != cch)
            BCL_ORIGINATE_ERROR(CNtCallDisposition::ArithmeticOverflow());

        m_pwstr = reinterpret_cast<PWSTR>(::RtlAllocateHeap(RtlProcessHeap(), 0, cb));
        if (m_pwstr == NULL)
            BCL_ORIGINATE_ERROR(CNtCallDisposition::OutOfMemory());

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    PWSTR Detach() { PWSTR pszResult = m_pwstr; m_pwstr = NULL; return pszResult; }

    operator PWSTR() const { return m_pwstr; }

private:
    PWSTR m_pwstr;
};

class CNtPSTRAllocationHelper
{
    typedef CNtCallDisposition TCallDisposition;

public:
    CNtPSTRAllocationHelper() : m_pstr(NULL) { }
    ~CNtPSTRAllocationHelper() { if (m_pstr != NULL) { ::RtlFreeHeap(RtlProcessHeap(), 0, m_pstr); m_pstr = NULL; } }

    CNtCallDisposition Allocate(SIZE_T cch /* == cb */)
    {
        BCL_MAYFAIL_PROLOG

        if (m_pstr != NULL)
            BCL_ORIGINATE_ERROR(CNtCallDisposition::InternalError_RuntimeCheck());

        m_pstr = reinterpret_cast<PSTR>(::RtlAllocateHeap(RtlProcessHeap(), 0, cch));
        if (m_pstr == NULL)
            BCL_ORIGINATE_ERROR(CNtCallDisposition::OutOfMemory());

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    PSTR Detach() { PSTR pszResult = m_pstr; m_pstr = NULL; return pszResult; }

    operator PSTR() const { return m_pstr; }

private:
    PSTR m_pstr;
};


}; // namespace BCL

#endif // !defined(_BCL_NTCOMMON_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_ntunicodefixedstringbuffer.h ===
#if !defined(_BCL_W32UNICODEFIXEDSTRINGBUFFER_H_INCLUDED_)
#define _BCL_W32UNICODEFIXEDSTRINGBUFFER_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_w32unicodefixedstringbuffer.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_w32baseunicodestringbuffer.h>

namespace BCL
{

template <SIZE_T nInlineChars> class CWin32BaseUnicodeFixedStringBuffer;

template <SIZE_T nInlineChars>
class CWin32BaseUnicodeFixedStringBufferTraits : public CWin32BaseUnicodeStringBufferTraits<CWin32BaseUnicodeFixedStringBuffer<nInlineChars>, CWin32CallDisposition, BOOL>
{
    typedef CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars> TThis;
    typedef CWin32BaseUnicodeFixedStringBuffer<nInlineChars> TBuffer;

    typedef void TAccessor;

    friend BCL::CPureString<TThis>;
    friend BCL::CInlineString<TThis>;
    friend BCL::CUnicodeCharTraits<TBuffer, TCallDisposition>;
    friend CWin32BaseUnicodeStringBufferTraits<CWin32BaseUnicodeFixedStringBuffer<nInlineChars>, CWin32CallDisposition, BOOL>;

    typedef BCL::CInlineString<TThis> TInlineString;
    typedef CWin32BaseUnicodeFixedStringBuffer<nInlineChars> TBuffer;

    static inline PWSTR __fastcall GetInlineBufferPtr(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->GetInlineBufferPtr(); }
    static inline SIZE_T __fastcall GetInlineBufferCch(const BCL::CBaseString *p) { return nInlineChars; }
    static inline TConstantPair __fastcall InlineBufferPair(const BCL::CBaseString *p) { return TConstantPair(TThis::GetInlineBufferPtr(p), TThis::GetInlineBufferCch(p)); }
    static inline TMutablePair __fastcall InlineMutableBufferPair(const BCL::CBaseString *p) { return TMutablePair(TThis::GetInlineBufferPtr(p), TThis::GetInlineBufferCch(p)); }

    static inline CWin32CallDisposition RoundBufferSize(SIZE_T cch, SIZE_T &rcchGranted) { BCL_MAYFAIL_PROLOG BCL_PARAMETER_CHECK(cch > nInlineChars); rcchGranted = 0; return CWin32CallDisposition::BufferOverflow(); BCL_MAYFAIL_EPILOG_INTERNAL }

    // We never have a non-inline buffer, so these shouldn't ever get called.
    static inline CWin32CallDisposition __fastcall ReallocateBuffer(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_ASSERT(false);
        return CWin32CallDisposition::InternalError_RuntimeCheck();
    }
    static inline void __fastcall DeallocateBuffer(PCWSTR psz)
    {
        BCL_ASSERT(false);
    }
}; // class CWin32BaseUnicodeFixedStringBufferTraits

template <SIZE_T nInlineChars>
class CWin32BaseUnicodeFixedStringBuffer : private BCL::CInlineString<CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars> >, private CWin32BaseUnicodeStringBufferAddIn
{
public:
    typedef CWin32BaseUnicodeFixedStringBuffer<nInlineChars> TThis;
    typedef CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars> TTraits;

    inline CWin32BaseUnicodeFixedStringBuffer() : CWin32BaseUnicodeStringBufferAddIn(m_rgchInlineBuffer, nInlineChars) { }
    inline ~CWin32BaseUnicodeFixedStringBuffer() { } // no dynamic buffer; nothing to do.
    operator PCWSTR() const { return this->GetStringPtr(); }

#include <bcl_stringapi.h>

private:
    inline PWSTR GetInlineBufferPtr() const { return const_cast<PWSTR>(m_rgchInlineBuffer); }

    WCHAR m_rgchInlineBuffer[nInlineChars]; // Plus one to make instantiation with nInlineChars=0 work

    friend CWin32BaseUnicodeStringBufferTraits<TThis, CWin32CallDisposition, BOOL>;
    friend CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars>;
    friend BCL::CUnicodeCharTraits<TThis, TCallDisposition>;
}; // class CWin32BaseUnicodeFixedStringBuffer

}; // namespace BCL

#endif // !defined(_BCL_W32UNICODEFIXEDSTRINGBUFFER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_vararg.h ===
#if !defined(_WINDOWS_BCL_VARARG_H_INCLUDED_)
#define _WINDOWS_BCL_VARARG_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_vararg.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <stdarg.h>

namespace BCL {

    class CVaList
    {
    public:
        inline CVaList() { }
        template <typename T> inline CVaList(T &rt) { va_start(m_ap, rt); }
        inline ~CVaList() { va_end(m_ap); }
        template <typename T> inline void NextArg(T &rt) { rt = va_arg(m_ap, T); }
        inline operator va_list() const { return m_ap; }
    private:
        va_list m_ap;
    }; // class CVaList
}; // namespace BCL

#endif // !defined(_WINDOWS_BCL_VARARG_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_ntunicodestringalgorithms.h ===
#if !defined(_BCL_NTUNICODESTRINGALGORITHMS_H_INCLUDED_)
#define _BCL_NTUNICODESTRINGALGORITHMS_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_ntunicodestringalgorithms.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_ntcommon.h>
#include <bcl_vararg.h>

#include <limits.h>

namespace BCL
{

template <typename TBuffer, typename TCallDispositionT>
class CNtNullTerminatedUnicodeStringAlgorithms
{
public:
    typedef CNtNullTerminatedUnicodeStringAlgorithms TThis;

    typedef TCallDispositionT TCallDisposition;
    typedef CNtStringComparisonResult TComparisonResult;

    typedef BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> TConstantPair;
    typedef BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> TMutablePair;

    typedef CNtCaseInsensitivityData TCaseInsensitivityData;
    typedef SIZE_T TSizeT;

    typedef CNtANSIToUnicodeDataIn TDecodingDataIn;
    typedef CNtANSIToUnicodeDataOut TDecodingDataOut;
    typedef CNtUnicodeToANSIDataIn TEncodingDataIn;
    typedef CNtUnicodeToANSIDataOut TEncodingDataOut;

    typedef CNtOEMToUnicodeDataIn TDecodingDataIn;
    typedef CNtOEMToUnicodeDataOut TDecodingDataOut;
    typedef CNtUnicodeToOEMDataIn TEncodingDataIn;
    typedef CNtUnicodeToOEMDataOut TEncodingDataOut;

    typedef CConstantPointerAndCountPair<CHAR, SIZE_T> TConstantNonNativePair;
    typedef CMutablePointerAndCountPair<CHAR, SIZE_T> TMutableNonNativePair;

    typedef PSTR TMutableNonNativeString;
    typedef PCSTR TConstantNonNativeString;

    typedef PWSTR TMutableString;
    typedef PCWSTR TConstantString;

    static inline void _fastcall SetStringCch(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_ASSERT((cch == 0) || (cch < TBuffer::TTraits::GetBufferCch(p)));
        static_cast<TBuffer *>(p)->m_cchString = cch;
        if (TBuffer::TTraits::GetBufferCch(p) != 0)
            TBuffer::TTraits::GetMutableBufferPtr(p)[cch] = L'\0';
    }

    static inline TCallDisposition __fastcall MapStringCchToBufferCch(SIZE_T cchString, SIZE_T &rcchRequired)
    {
        SIZE_T cchRequired = cchString + 1;

        if (cchRequired == 0)
            return TCallDisposition::ArithmeticOverflow();

        rcchRequired = cchRequired;

        return TCallDisposition::Success();
    }

    static inline TCallDisposition __fastcall MapBufferCchToStringCch(SIZE_T cchBuffer, SIZE_T &rcchString)
    {
        if (cchBuffer == 0)
            rcchString = 0;
        else
            rcchString = cchBuffer - 1;

        return TCallDisposition::Success();
    }

    static inline TCallDisposition __fastcall IsCharLegalLeadChar(WCHAR wch, bool &rfIsLegal)
    {
        BCL_MAYFAIL_PROLOG

        // fast common path out for ASCII; there are no combining characters in this range
        if (wch <= 0x007f)
            rfIsLegal = true;
        else
        {
            // low surrogate
            if ((wch >= 0xdc00) && (wch <= 0xdfff))
                rfIsLegal = false;
            else
                rfIsLegal = true;
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall UpperCase(BCL::CBaseString *p, const CNtCaseInsensitivityData &rcid)
    {
        BCL_MAYFAIL_PROLOG

        TBuffer::TSizeT cch, i;
        TBuffer::TMutableString pString = TBuffer::TTraits::GetMutableBufferPtr(p);

        cch = TBuffer::TTraits::GetStringCch(p);

        for (i=0; i<cch; i++)
            pString[i] = RtlUpcaseUnicodeChar(pString[i]);

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall LowerCase(BCL::CBaseString *p, const CNtCaseInsensitivityData &rcid)
    {
        BCL_MAYFAIL_PROLOG

        TBuffer::TSizeT cch, i;
        TBuffer::TMutableString pString = TBuffer::TTraits::GetMutableBufferPtr(p);

        cch = TBuffer::TTraits::GetStringCch(p);

        for (i=0; i<cch; i++)
            pString[i] = RtlDowncaseUnicodeChar(pString[i]);

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeInputType1, typename TSomeInputType2>
    static inline TCallDisposition __fastcall
    EqualStringsI(
        const TSomeInputType1 &rinput1,
        const TSomeInputType2 &rinput2,
        const CNtCaseInsensitivityData &rcid,
        bool &rfMatches
        )
    {
        BCL_MAYFAIL_PROLOG

        rfMatches = false;

        const TBuffer::TSizeT cch1 = TBuffer::TTraits::GetInputCch(rinput1);
        const TBuffer::TSizeT cch2 = TBuffer::TTraits::GetInputCch(rinput2);

        if (cch1 == cch2)
        {
            const TBuffer::TConstantString pString1 = TBuffer::TTraits::GetInputPtr(rinput1);
            const TBuffer::TConstantString pString2 = TBuffer::TTraits::GetInputPtr(rinput2);
            TBuffer::TSizeT i;

            for (i=0; i<cch1; i++)
            {
                if (RtlUpcaseUnicodeChar(pString1[i]) != RtlUpcaseUnicodeChar(pString2[i]))
                    break;
            }

            if (i == cch1)
                rfMatches = true;
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeInputType1, typename TSomeInputType2>
    static inline TCallDisposition __fastcall CompareStringsI(
        const TSomeInputType1 &rinput1,
        const TSomeInputType2 &rinput2,
        const CNtCaseInsensitivityData &, // unused
        TComparisonResult &rcr
        )
    {
        BCL_MAYFAIL_PROLOG

        rfMatches = false;

        const TBuffer::TSizeT cch1 = TBuffer::TTraits::GetInputCch(rinput1);
        const TBuffer::TSizeT cch2 = TBuffer::TTraits::GetInputCch(rinput2);
        const TBuffer::TSizeT cchMin = (cch1 < cch2) ? cch1 : cch2;
        const TBuffer::TConstantString pString1 = TBuffer::TTraits::GetInputPtr(rinput1);
        const TBuffer::TConstantString pString2 = TBuffer::TTraits::GetInputPtr(rinput2);
        WCHAR wch1, wch2;
        TBuffer::TSizeT i;

        wch1 = wch2 = L'\0';

        for (i=0; i<cchMin; i++)
        {
            if ((wch1 = RtlUpcaseUnicodeChar(pString1[i])) != (wch2 = RtlUpcaseUnicodeChar(pString2[i])))
                break;
        }

        if (i == cchMin)
        {
            // Hit the end of the common substring without finding a mismatch.  The longer one is greater.
            if (cch1 > cchMin)
                rcr.SetGreaterThan();
            else if (cch2 > cchMin)
                rcr.SetLessThan();
            else
                rcr.SetEqualTo();
        }
        else
        {
            // Simpler; wch1 and wch2 are comparable...
            if (wch1 < wch2)
                rcr.SetLessThan();
            else if (wch1 > wch2)
                rcr.SetGreaterThan();
            else
                rcr.SetEqualTo();
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeCharacterMatcher>
    inline
    static
    TCallDisposition
    ContainsI(
        const TConstantPair &rpair,
        const TSomeCharacterMatcher &rscm,
        const CNtCaseInsensitivityData &rcid,
        bool &rfFound
        )
    {
        BCL_MAYFAIL_PROLOG

        rfFound = false;

        BCL_PARAMETER_CHECK(rpair.Valid());
        SIZE_T cch = rpair.GetCount();
        SIZE_T i;
        const WCHAR *prgch = rpair.GetPointer();

        for (i=0; i<cch; )
        {
            SIZE_T cchConsumed = 0;
            bool fMatch = false;

            BCL_IFCALLFAILED_EXIT(rscm.MatchI(rcid, prgch, cchConsumed, fMatch));

            BCL_INTERNAL_ERROR_CHECK(cchConsumed != 0);

            if (fMatch)
                break;

            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::AddWithOverflowCheck(i, cchConsumed, i));
        }

        if (i != cch)
            rfFound = true;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }


    inline
    static
    TCallDisposition
    ContainsI(
        const TConstantPair &rpair,
        WCHAR ch,
        const CNtCaseInsensitivityData &rcid,
        bool &rfFound
        )
    {
        BCL_MAYFAIL_PROLOG

        rfFound = false;

        BCL_PARAMETER_CHECK(rpair.Valid());
        SIZE_T cch = rpair.GetCount();
        SIZE_T i;
        const WCHAR *prgch = rpair.GetPointer();

        for (i=0; i<cch; i++)
        {
            int iResult = ::CompareStringW(rcid.m_lcid, rcid.m_dwCmpFlags, prgch++, 1, &ch, 1);
            if (iResult == 0)
                return TCallDisposition::FromLastError();
            if (iResult == CSTR_EQUAL)
                break;
        }

        if (i != cch)
            rfFound = true;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    ContainsI(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        const CNtCaseInsensitivityData &rcid,
        bool &rfFound
        )
    {
        BCL_MAYFAIL_PROLOG

        rfFound = false;

        BCL_PARAMETER_CHECK(rpair.Valid());
        BCL_PARAMETER_CHECK(rpairCandidate.Valid());

        SIZE_T cchCandidate = rpairCandidate.GetCount();
        const WCHAR *prgwchCandidate = rpairCandidate.GetPointer();

        BCL_PARAMETER_CHECK(cchCandidate <= INT_MAX);

        if (cchCandidate == 0)
        {
            // The null string is in every string
            rfFound = true;
        }
        else
        {
            SIZE_T cch = rpair.GetCount();
            SIZE_T i;
            const WCHAR *prgch = rpair.GetPointer();

            // This is a dismal implementation of this kind of search but
            // I don't know if there's a lot you can do with neato algorithms
            // while keeping the case insensitivity a black box inside of
            // CompareStringW().  -mgrier 2/3/2002

            for (i=0; i<cch; i++)
            {
                int iResult = ::CompareStringW(
                    rcid.m_lcid,
                    rcid.m_dwCmpFlags,
                    prgch,
                    static_cast<INT>(cchCandidate),
                    prgwchCandidate,
                    static_cast<INT>(cchCandidate));

                if (iResult == 0)
                    return TCallDisposition::FromLastError();

                if (iResult == CSTR_EQUAL)
                {
                    rfFound = true;
                    break;
                }

                const WCHAR wch = *prgch++;

                // Skip ahead an additional character if this is a surrogate
                if ((wch >= 0xd800) && (wch <= 0xdbff))
                {
                    i++;
                    prgch++;
                }
            }
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    __fastcall
    FindFirstI(
        const TConstantPair &rpair,
        WCHAR ch,
        const CNtCaseInsensitivityData &rcid,
        SIZE_T &rich
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpair.Valid());
        SIZE_T cch = rpair.GetCount();
        SIZE_T i;
        const WCHAR *prgch = rpair.GetPointer();

        for (i=0; i<cch; i++)
        {
            int iResult = ::CompareStringW(rcid.m_lcid, rcid.m_dwCmpFlags, prgch++, 1, &ch, 1);
            if (iResult == 0)
                return TCallDisposition::FromLastError();
            if (iResult == CSTR_EQUAL)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    FindFirstI(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        const CNtCaseInsensitivityData &rcid,
        SIZE_T &richFound
        )
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T cch = rpair.GetCount();

        richFound = cch;

        BCL_PARAMETER_CHECK(rpair.Valid());
        BCL_PARAMETER_CHECK(rpairCandidate.Valid());

        SIZE_T cchCandidate = rpairCandidate.GetCount();
        const WCHAR *prgwchCandidate = rpairCandidate.GetPointer();

        BCL_PARAMETER_CHECK(cchCandidate <= INT_MAX);

        if (cchCandidate == 0)
        {
            // The null string is in every string
            richFound = cch;
        }
        else
        {
            SIZE_T i;
            const WCHAR *prgch = rpair.GetPointer();

            // This is a dismal implementation of this kind of search but
            // I don't know if there's a lot you can do with neato algorithms
            // while keeping the case insensitivity a black box inside of
            // CompareStringW().  -mgrier 2/3/2002

            for (i=0; i<cch; i++)
            {
                int iResult = ::CompareStringW(
                    rcid.m_lcid,
                    rcid.m_dwCmpFlags,
                    prgch,
                    static_cast<INT>(cchCandidate),
                    prgwchCandidate,
                    static_cast<INT>(cchCandidate));

                if (iResult == 0)
                    return TCallDisposition::FromLastError();

                if (iResult == CSTR_EQUAL)
                {
                    richFound = i;
                    break;
                }

                const WCHAR wch = *prgch++;

                // Skip ahead an additional character if this is a surrogate
                if ((wch >= 0xd800) && (wch <= 0xdbff))
                {
                    i++;
                    prgch++;
                }
            }
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    __fastcall
    FindLastI(
        const TConstantPair &rpair,
        WCHAR ch,
        const CNtCaseInsensitivityData &rcid,
        SIZE_T &richFound
        )
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cch = rpair.GetCount();
        const WCHAR *prgwch = rpair.GetPointer() + cch;

        richFound = cch;

        for (i=cch; i>0; i--)
        {
            int iResult = ::CompareStringW(rcid.m_lcid, rcid.m_dwCmpFlags, --prgwch, 1, &ch, 1);
            if (iResult == 0)
                return TCallDisposition::FromLastError();
            if (iResult == CSTR_EQUAL)
                break;
        }

        if (i == 0)
            richFound = cch;
        else
            richFound = i - 1;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    FindLastI(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        const CNtCaseInsensitivityData &rcid,
        SIZE_T &richFound
        )
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T cch = rpair.GetCount();

        richFound = cch;

        BCL_PARAMETER_CHECK(rpair.Valid());
        BCL_PARAMETER_CHECK(rpairCandidate.Valid());

        SIZE_T cchCandidate = rpairCandidate.GetCount();
        const WCHAR *prgwchCandidate = rpairCandidate.GetPointer();

        BCL_PARAMETER_CHECK(cchCandidate <= INT_MAX);

        if (cchCandidate == 0)
        {
            // The null string is in every string
            richFound = cch;
        }
        else
        {
            // We can't even short circuit out of here just because the candidate string
            // is longer than the target string because we don't know what kind of
            // case folding magic NLS is doing for us behind the scenes based on
            // the case insensitivity data's dwCmpFlags.

            SIZE_T i;
            const WCHAR *prgch = rpair.GetPointer();

            // This is a dismal implementation of this kind of search but
            // I don't know if there's a lot you can do with neato algorithms
            // while keeping the case insensitivity a black box inside of
            // CompareStringW().  -mgrier 2/3/2002

            for (i=0; i<cch; i++)
            {
                int iResult = ::CompareStringW(
                    rcid.m_lcid,
                    rcid.m_dwCmpFlags,
                    prgch,
                    static_cast<INT>(cchCandidate),
                    prgwchCandidate,
                    static_cast<INT>(cchCandidate));

                if (iResult == 0)
                    return TCallDisposition::FromLastError();

                if (iResult == CSTR_EQUAL)
                {
                    richFound = i;
                    // keep looking in case there's another
                }

                const WCHAR wch = *prgch++;

                // Skip ahead an additional character if this is a surrogate
                if ((wch >= 0xd800) && (wch <= 0xdbff))
                {
                    i++;
                    prgch++;
                }
            }
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall SpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CNtCaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=0; i<cchBuffer; i++)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i], rcid, fFound));
            if (!fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall ComplementSpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CNtCaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=0; i<cchBuffer; i++)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i], rcid, fFound));
            if (fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall ReverseSpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CNtCaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=cchBuffer; i>0; i--)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i-1], rcid, fFound));
            if (!fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall ReverseComplementSpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CNtCaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=cchBuffer; i>0; i--)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i], rcid, fFound));
            if (fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    DetermineRequiredCharacters(
        const CNtMBCSToUnicodeDataIn &rddi,
        const TConstantNonNativePair &rpair,
        CNtMBCSToUnicodeDataOut &rddo,
        SIZE_T &rcch
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpair.GetCount() <= INT_MAX); // limitation imposed by MultiByteToWideChar API

        int iResult = ::MultiByteToWideChar(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | MB_ERR_INVALID_CHARS,
                            rpair.GetPointer(),
                            static_cast<INT>(rpair.GetCount()),
                            NULL,
                            0);
        if (iResult == 0)
            BCL_ORIGINATE_ERROR(TCallDisposition::FromLastError());

        BCL_INTERNAL_ERROR_CHECK(iResult > 0); // I don't know why MultiByteToWide char would return negative but let's make sure

        rcch = iResult;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    CopyIntoBuffer(
        const TMutablePair &rpairOut,
        const CNtMBCSToUnicodeDataIn &rddi,
        const TConstantNonNativePair &rpairIn,
        CNtMBCSToUnicodeDataOut &rddo
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpairIn.GetCount() <= INT_MAX); // limitation imposed by MultiByteToWideChar API
        BCL_PARAMETER_CHECK(rpairOut.GetCount() <= INT_MAX); // might make sense to just clamp at INT_MAX but at least we fail correctly instead of silent truncation

        int iResult = ::MultiByteToWideChar(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | MB_ERR_INVALID_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(rpairIn.GetCount()),
                            rpairOut.GetPointer(),
                            static_cast<INT>(rpairOut.GetCount()));
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult > 0); // I don't know why MultiByteToWide char would return negative but let's make sure

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    CopyIntoBuffer(
        const TMutableNonNativePair &rpairOut,
        const CNtUnicodeToMBCSDataIn &rddi,
        const TConstantPair &rpairIn,
        CNtUnicodeToMBCSDataOut &rddo,
        SIZE_T &rcchWritten
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpairIn.GetCount() <= INT_MAX);
        BCL_PARAMETER_CHECK(rpairOut.GetCount() <= INT_MAX);

        // If we want to have any chance of returning ERROR_BUFFER_OVERFLOW
        // either we need to play the "two null chars at the end of the
        // buffer" game or we have to do this in two passes - one to
        // get the desired length and one to actually move the data.
        //
        // If someone has an approach which doesn't lose correctness but
        // avoids the double conversion, be my guest and fix this. -mgrier 2/6/2002
        int iResult = ::WideCharToMultiByte(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(rpairIn.GetCount()),
                            NULL,
                            0,
                            rddo.m_lpDefaultChar,
                            rddo.m_lpUsedDefaultChar);
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult >= 0);

        if (iResult > static_cast<INT>(rpairOut.GetCount()))
            BCL_ORIGINATE_ERROR(TCallDisposition::BufferOverflow());

        iResult = ::WideCharToMultiByte(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(rpairIn.GetCount()),
                            rpairOut.GetPointer(),
                            static_cast<INT>(rpairOut.GetCount()),
                            rddo.m_lpDefaultChar,
                            rddo.m_lpUsedDefaultChar);
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult >= 0);

        rcchWritten = iResult;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    AllocateAndCopyIntoBuffer(
        TMutableNonNativeString &rpszOut,
        const CNtUnicodeToMBCSDataIn &rddi,
        const TConstantPair &rpairIn,
        CNtUnicodeToMBCSDataOut &rddo,
        SIZE_T &rcchWritten
        )
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchInputString, cchBuffer;
        TBuffer::TTraits::TPSTRAllocationHelper pszTemp;

        BCL_PARAMETER_CHECK(rpairIn.GetCount() <= INT_MAX);

        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapStringCchToBufferCch(rpairIn.GetCount(), cchInputString));
        if (cchInputString > INT_MAX)
            BCL_ORIGINATE_ERROR(TCallDisposition::BufferOverflow());

        int iResult = ::WideCharToMultiByte(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(cchInputString),
                            NULL,
                            0,
                            rddo.m_lpDefaultChar,
                            rddo.m_lpUsedDefaultChar);
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult >= 0);

        cchBuffer = iResult;
        BCL_IFCALLFAILED_EXIT(pszTemp.Allocate(cchBuffer));

        INT iResult2 = ::WideCharToMultiByte(
                        rddi.m_CodePage,
                        rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                        rpairIn.GetPointer(),
                        static_cast<INT>(cchInputString),
                        static_cast<PSTR>(pszTemp),
                        iResult,
                        rddo.m_lpDefaultChar,
                        rddo.m_lpUsedDefaultChar);
        if (iResult2 == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult2 >= 0);

        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapBufferCchToStringCch(iResult2, rcchWritten));
        rpszOut = pszTemp.Detach();

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    AllocateAndCopyIntoBuffer(
        TMutableString &rstringOut,
        const TConstantPair &rpairIn,
        TSizeT &rcchWritten
        )
    {
        BCL_MAYFAIL_PROLOG
        TSizeT cchString = rpairIn.GetCount();
        TSizeT cchBuffer;
        TBuffer::TTraits::TPWSTRAllocationHelper pszTemp;
        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapStringCchToBufferCch(cchString, cchBuffer));
        BCL_IFCALLFAILED_EXIT(pszTemp.Allocate(cchBuffer));
        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::CopyIntoBuffer(TMutablePair(static_cast<PWSTR>(pszTemp), cchBuffer), rpairIn, rcchWritten));
        rstringOut = pszTemp.Detach();
        BCL_MAYFAIL_EPILOG_INTERNAL
    }
}; // class CNtNullTerminatedUnicodeStringAlgorithms

}; // namespace BCL

#endif // !defined(_BCL_NTUNICODESTRINGALGORITHMS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_unicodechartraits.h ===
#if !defined(_WINDOWS_BCL_UNICODECHARTRAITS_H_INCLUDED_)
#define _WINDOWS_BCL_UNICODECHARTRAITS_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_unicodechartraits.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <bcl_common.h>
#include <bcl_stringalgorithms.h>

#include <limits.h>

namespace BCL
{

template <typename TBuffer, typename TCallDisposition>
class CUnicodeCharTraits
{
    typedef CUnicodeCharTraits TThis;

public:
    typedef WCHAR *TMutableString;
    typedef const WCHAR *TConstantString;
    typedef WCHAR TChar;
    typedef SIZE_T TSizeT;
    typedef CHAR TNonNativeChar;
    typedef ULONG TMetaChar;

    typedef CConstantPointerAndCountPair<WCHAR, SIZE_T> TConstantPair;
    typedef CMutablePointerAndCountPair<WCHAR, SIZE_T> TMutablePair;

    inline static WCHAR NullCharacter() { return L'\0'; }
    inline static bool IsNullCharacter(WCHAR wch) { return (wch == L'\0'); }

    inline static bool StringCchLegal(SIZE_T cch) { return true; }
    inline static TCallDisposition RoundBufferSize(SIZE_T cch, SIZE_T &rcchGranted) { rcchGranted = ((cch + 7) & 0xfffffff8); return TCallDisposition::Success(); }

    static inline TSizeT __fastcall GetInputCch(const TConstantPair &r) { return r.GetCount(); }
    static inline TSizeT __fastcall GetInputCch(const TChar &rch) { return 1; }
    static inline TConstantString __fastcall GetInputPtr(const TConstantPair &r) { return r.GetPointer(); }
    static inline TConstantString __fastcall GetInputPtr(const TChar &rch) { return &rch; }

    inline
    static
    TCallDisposition
    __fastcall
    CopyIntoBuffer(
        const TMutablePair &rpairOut,
        const TConstantPair &rpairIn,
        TSizeT &rcchWritten
        )
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchToCopy = rpairIn.GetCount();
        const TSizeT cchBuffer = rpairOut.GetCount();

        BCL_PARAMETER_CHECK(rpairOut.Valid());
        BCL_PARAMETER_CHECK(rpairIn.Valid());

        if (cchToCopy != 0)
        {
            const TMutableString pszOutBuffer = rpairOut.GetPointer();

            if (cchToCopy > cchBuffer)
                BCL_ORIGINATE_ERROR(TCallDisposition::BufferOverflow());

            // The parameter check should verify that if there are non-zero 
            BCL::CopyBytes(pszOutBuffer, rpairIn.GetPointer(), cchToCopy * sizeof(TChar));

            rcchWritten = cchToCopy;
        }
        else
            rcchWritten = 0;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    __fastcall
    DetermineCharacterLength(
        const TConstantPair &rpairIn,
        TSizeT ichStart,
        TSizeT &rcchSpan
        )
    {
        BCL_MAYFAIL_PROLOG

        // Generic version is trivial.  See If this is a high surrogate; if so and the string isn't
        // malformed, we say "2".

        rcchSpan = 0;

        BCL_PARAMETER_CHECK(rpairIn.Valid());
        BCL_PARAMETER_CHECK(ichStart < rpairIn.Count());


    }

    inline
    static
    TCallDisposition
    __fastcall
    CopyIntoBuffer(
        const TMutablePair &rpairOut,
        TChar tch,
        TSizeT &rcchWritten
        )
    {
        const TSizeT cchBuffer = rpairOut.GetCount();

        if (cchBuffer < 1)
            return TCallDisposition::BufferOverflow();

        const TMutableString pszOutBuffer = rpairOut.GetPointer();

        if ((pszOutBuffer != NULL) && (cchBuffer != 0))
            pszOutBuffer[0] = tch;

        rcchWritten = 1;

        return TCallDisposition::Success();
    }

    inline
    static
    TCallDisposition
    CopyIntoBufferAndAdvanceCursor(
        TMutablePair &rpairBuffer,
        const TConstantPair &rpairInput
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK((rpairBuffer.GetCount() != 0) || (rpairInput.GetCount() == 0));
        BCL_PARAMETER_CHECK((rpairInput.GetPointer() != NULL) || (rpairInput.GetCount() == 0));

        if (rpairInput.GetCount() > rpairBuffer.GetCount())
            BCL_ORIGINATE_ERROR(TCallDisposition::BufferOverflow());

        if (rpairInput.GetCount() != 0)
            BCL::CopyBytesAndAdvance(rpairBuffer, rpairInput);

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    CopyIntoBufferAndAdvanceCursor(
        TMutablePair &rpairBuffer,
        TChar tch
        )
    {
        BCL_MAYFAIL_PROLOG

        // capture
        TSizeT cchBuffer = rpairBuffer.GetCount();
        TMutableString pchBuffer = rpairBuffer.GetPointer();

        BCL_PARAMETER_CHECK(rpairBuffer.Valid());

        if (cchBuffer < 1)
            BCL_ORIGINATE_ERROR(TCallDisposition::BufferOverflow());

        *pchBuffer++ = tch;
        cchBuffer--;

        rpairBuffer.SetPointerAndCount(pchBuffer, cchBuffer);

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    __fastcall
    EqualStrings(
        const TConstantPair &rpair1,
        const TConstantPair &rpair2,
        bool &rfEquals
        )
    {
        return BCL::EqualStrings<TCallDisposition, TConstantPair>(rpair1, rpair2, rfEquals);
    }

    inline
    static
    TCallDisposition
    __fastcall
    EqualStrings(
        const TConstantPair &rpair1,
        TChar tch,
        bool &rfEquals
        )
    {
        return BCL::EqualStrings<TCallDisposition, TConstantPair>(rpair1, tch, rfEquals);
    }

    template <typename TComparisonResult>
    inline
    static
    TCallDisposition
    __fastcall
    CompareStrings(
        const TConstantPair &rpair1,
        const TConstantPair &rpair2,
        TComparisonResult &rcr
        )
    {
        return BCL::CompareStrings<TCallDisposition, TConstantPair, TComparisonResult>(rpair1, rpair2, rcr);
    }

    template <typename TComparisonResult>
    inline
    static
    TCallDisposition
    __fastcall
    CompareStrings(
        const TConstantPair &rpair1,
        TChar tch,
        TComparisonResult &rcr
        )
    {
        return BCL::CompareStrings<TCallDisposition, TConstantPair, TComparisonResult>(rpair1, tch, rcr);
    }

    template <typename TSomeInputType>
    inline
    static
    TCallDisposition
    __fastcall
    DetermineRequiredCharacters(
        const TSomeInputType &rinput,
        SIZE_T &rcchOut
        )
    {
        rcchOut = TThis::GetInputCch(rinput);
        return TCallDisposition::Success();
    }

    inline
    static
    TCallDisposition
    Count(
        const TConstantPair &rpair,
        WCHAR ch,
        SIZE_T &rcchFound
        )
    {
        return BCL::Count<TCallDisposition, TConstantPair>(rpair, ch, rcchFound);
    }

    inline
    static
    TCallDisposition
    FindFirst(
        const TConstantPair &rpair,
        WCHAR ch,
        SIZE_T &richFound
        )
    {
        return BCL::FindFirst<TCallDisposition, TConstantPair>(rpair, ch, richFound);
    }

    inline
    static
    TCallDisposition
    FindFirst(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        SIZE_T &richFound
        )
    {
        return BCL::FindFirst<TCallDisposition, TConstantPair>(rpair, rpairCandidate, richFound);
    }

    inline
    static
    TCallDisposition
    FindLast(
        const TConstantPair &rpair,
        WCHAR ch,
        SIZE_T &richFound
        )
    {
        return BCL::FindLast<TCallDisposition, TConstantPair>(rpair, ch, richFound);
    }

    inline
    static
    TCallDisposition
    FindLast(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        SIZE_T &richFound
        )
    {
        return BCL::FindLast<TCallDisposition, TConstantPair>(rpair, rpairCandidate, richFound);
    }

    inline
    static
    TCallDisposition
    Contains(
        const TConstantPair &rpair,
        WCHAR ch,
        bool &rfFound
        )
    {
        return BCL::Contains<TCallDisposition, TConstantPair>(rpair, ch, rfFound);
    }

    inline
    static
    TCallDisposition
    Contains(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        bool &rfFound
        )
    {
        return BCL::Contains<TCallDisposition, TConstantPair>(rpair, rpairCandidate, rfFound);
    }

    static inline TCallDisposition __fastcall Span(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, SIZE_T &rich)
    {
        return BCL::Span<TCallDisposition, TConstantPair>(rpairBuffer, rpairSet, rich);
    }

    static inline TCallDisposition __fastcall ComplementSpan(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, SIZE_T &rich)
    {
        return BCL::ComplementSpan<TCallDisposition, TConstantPair>(rpairBuffer, rpairSet, rich);
    }

    static inline TCallDisposition __fastcall ReverseSpan(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, SIZE_T &rich)
    {
        return BCL::ReverseSpan<TCallDisposition, TConstantPair>(rpairBuffer, rpairSet, rich);
    }

    static inline TCallDisposition __fastcall ReverseComplementSpan(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, SIZE_T &rich)
    {
        return BCL::ReverseComplementSpan<TCallDisposition, TConstantPair>(rpairBuffer, rpairSet, rich);
    }

    static inline SIZE_T NullTerminatedStringLength(PCWSTR sz)
    {
        if (sz == NULL)
            return 0;

        return ::wcslen(sz);
    }

    static inline TCallDisposition __fastcall TrimStringLengthToLegalCharacters(TMutablePair &rpairBuffer, SIZE_T cchString, SIZE_T cchBufferNew, SIZE_T &rcchStringLengthOut)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T cchStringLimit;

        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapBufferCchToStringCch(cchBufferNew, cchStringLimit));

        if (cchString > cchStringLimit)
        {
            PCWSTR pszBuffer = rpairBuffer.GetPointer();
            bool fIsLegalLeadCharacter;

            while (cchStringLimit > 0)
            {
                // Let's see what's currently there and go on from there.
                BCL_IFCALLFAILED_EXIT(
                    TBuffer::TTraits::IsCharLegalLeadChar(
                        pszBuffer[cchStringLimit],
                        fIsLegalLeadCharacter));
                if (fIsLegalLeadCharacter)
                    break;
                cchStringLimit--;
            }
        }

        rcchStringLengthOut = cchStringLimit;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall AddWithOverflowCheck(SIZE_T cch1, SIZE_T cch2, SIZE_T &rcchOut)
    {
        const SIZE_T cch = cch1 + cch2;

        if ((cch < cch1) || (cch < cch2))
            return TCallDisposition::ArithmeticOverflow();

        rcchOut = cch;

        return TCallDisposition::Success();
    }

    static inline TCallDisposition __fastcall SubtractWithUnderflowCheck(SIZE_T cch1, SIZE_T cch2, SIZE_T &rcchOut)
    {
        if (cch2 > cch1)
            return TCallDisposition::ArithmeticUnderflow();

        rcchOut = cch1 - cch2;

        return TCallDisposition::Success();
    }

    static inline TCallDisposition __fastcall MultiplyWithOverflowCheck(SIZE_T factor1, SIZE_T factor2, SIZE_T &rproduct)
    {
        return BCL::MultiplyWithOverflowCheck<SIZE_T, TCallDisposition>(factor1, factor2, rproduct);
    }

    static inline TCallDisposition __fastcall EnsureBufferLargeEnoughPreserve(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchBufferRequired, cchBufferGranted;
        TSizeT cchPreservedStringLength = TBuffer::TTraits::GetStringCch(p);
        TSizeT cchPreservedBufferLength;

        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapStringCchToBufferCch(cch, cchBufferRequired));
        if (TBuffer::TTraits::GetBufferCch(p) < cchBufferRequired)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapStringCchToBufferCch(cchPreservedStringLength, cchPreservedBufferLength));

            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::RoundBufferSize(cchBufferRequired, cchBufferGranted));

            BCL_IFCALLFAILED_EXIT(
                TBuffer::TTraits::TrimStringLengthToLegalCharacters(
                    TBuffer::TTraits::MutableBufferPair(p),
                    cchPreservedStringLength,
                    cchBufferGranted,
                    cchPreservedStringLength
                    ));

            // Get a derived traits class, as appropriate for the buffer type, to do the reallocation so that
            // it can deal with buffer policy.
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ReallocateBuffer(p, cchBufferGranted));

            if (cchPreservedBufferLength > cchBufferGranted)
                cchPreservedBufferLength = cchBufferGranted;

            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapBufferCchToStringCch(cchPreservedBufferLength, cchPreservedStringLength));
            TBuffer::TTraits::SetStringCch(p, cchPreservedStringLength);
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall EnsureBufferLargeEnoughNoPreserve(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_MAYFAIL_PROLOG
        TSizeT cchBufferRequired, cchBufferGranted;

        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapStringCchToBufferCch(cch, cchBufferRequired));
        if (cchBufferRequired > TBuffer::TTraits::GetBufferCch(p))
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::RoundBufferSize(cchBufferRequired, cchBufferGranted));
            // Get a derived traits class, as appropriate for the buffer type, to do the reallocation so that
            // it can deal with buffer policy.
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ReallocateBuffer(p, cchBufferGranted));
        }

        TBuffer::TTraits::SetStringCch(p, 0);

        BCL_MAYFAIL_EPILOG_INTERNAL
    }
}; // class CUnicodeCharTraits

}; // namespace BCL

#endif // !deifned(_WINDOWS_BCL_UNICODECHARTRAITS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_purestring.h ===
#if !defined(_WINDOWS_BCL_PURESTRING_H_INCLUDED_)
#define _WINDOWS_BCL_PURESTRING_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_purestring.h

Abstract:

    Abstract algorithms and definitions for a string class.

Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <bcl_common.h>

namespace BCL {

class CBaseString { };

template <typename TTraits> class CPureString;

//
//  This is a pair of classes that manage buffers containing characters.
//
//  We don't call it a "string class" because we want to have a more
//  pure model of a string (poolable non-mutable bodies); instead this is
//  a glorified "<x>CHAR *" where as you do common operations the buffer
//  is resized appropriately.
//




//
//  Important note:
//
//  This class will not be fully functional with the BCL CUnicodeCharTraits class
//  since here in the BCL, we can't take a position about case insensitive
//  behavior or memory allocation.
//
//  Thus, this is clearly just a base class that needs to be specialized in
//  conjunction with other specializations of the char traits class(es) to be
//  usable.
//
//                              -mgrier (1/23/2002)
//

template <typename TTraits> class CPureString : public CBaseString
{
    friend TTraits;
    friend typename TTraits::TAccessor;

protected:
    typedef typename TTraits::TChar TChar;                       // e.g. WCHAR (alternately, CHAR)
    typedef typename TTraits::TNonNativeChar TNonNativeChar;     // e.g. CHAR (alternately, WCHAR)
    typedef typename TTraits::TMetaChar TMetaChar;               // e.g. ULONG for a UCS-4 character

    typedef typename TTraits::TMutableString TMutableString;     // PWSTR
    typedef typename TTraits::TConstantString TConstantString;   // PCWSTR
    typedef typename TTraits::TSizeT TSizeT;                     // SIZE_T
    typedef typename TTraits::TCallDisposition TCallDisposition;
    typedef typename TTraits::TPublicErrorReturnType TPublicErrorReturnType;

    typedef typename TTraits::TAccessor TAccessor;

    typedef typename TTraits::TCaseInsensitivityData TCaseInsensitivityData;
    typedef typename TTraits::TComparisonResult TComparisonResult;

    typedef typename TTraits::TEncodingDataIn TEncodingDataIn;
    typedef typename TTraits::TEncodingDataOut TEncodingDataOut;
    typedef typename TTraits::TDecodingDataIn TDecodingDataIn;
    typedef typename TTraits::TDecodingDataOut TDecodingDataOut;

    typedef typename TTraits::TMutableNonNativeString TMutableNonNativeString;
    typedef typename TTraits::TConstantNonNativeString TConstantNonNativeString;

    typedef typename TTraits::TConstantNonNativePair TConstantNonNativePair;
    typedef typename TTraits::TMutableNonNativePair TMutableNonNativePair;

    typedef typename TTraits::TConstantPair TConstantPair;
    typedef typename TTraits::TMutablePair TMutablePair;

    // You may not instantiate an instance of this class directly; you need to provide a derived
    // class which adds allocation/deallocation particulars.

    inline CPureString() { }

    //
    //  Note that somewhat counter-intuitively, there is neither an assignment operator,
    //  copy constructor or constructor taking a TConstantString.  This is necessary
    //  because such a constructor would need to perform a dynamic allocation
    //  if the path passed in were longer than nInlineChars which could fail and
    //  since we do not throw exceptions, constructors may not fail.  Instead the caller
    //  must just perform the default construction and then use the Assign() member
    //  function, remembering of course to check its return status.
    //

    ~CPureString()
    {
        BCL_ASSERT(this->NoAccessors());
    }

    inline void IntegrityCheck() const { TTraits::IntegrityCheck(this); }
    inline TCallDisposition __fastcall NoAccessorsCheck() const { return TTraits::NoAccessorsCheck(this); }
    inline bool AnyAccessors() const { return TTraits::AnyAccessors(this); }
    inline bool NoAccessors() const { return TTraits::NoAccessors(this); }
    inline TSizeT GetAccessorCount() const { return TTraits::GetAccessorCount(this); }
    inline TCallDisposition AttachAccessor(TAccessor *pAccessor) { return TTraits::AddAccessor(this, pAccessor); }
    inline void DetachAccessor(TAccessor *pAccessor) { TTraits::RemoveAccessor(this, pAccessor); }

    inline TConstantString GetBufferPtr() const { return TTraits::GetBufferPtr(this); }
    inline TSizeT GetBufferCch() const { return TTraits::GetBufferCch(this); }
    inline void SetBufferPointerAndCount(TMutableString psz, TSizeT cch) { TTraits::SetBufferPointerAndCount(this, psz, cch); }
    inline TSizeT GetStringCch() const { return TTraits::GetStringCch(this); }

    inline bool StringCchLegal(TSizeT cch) const { return TTraits::StringCchLegal(cch); }
    inline bool StringCchLegal(const TConstantPair &rpair) const { return TTraits::StringCchLegal(rpair.GetCount()); }

    inline TMutableString GetMutableBufferPtr() { return TTraits::GetMutableBufferPtr(this); }
    inline void SetStringCch(TSizeT cch) { TTraits::SetStringCch(this, cch); }

    // We make an explicit assumption here that the derived type holds a pair object for the
    // buffer length and pointer, but the "effective string length and pointer" aren't
    // stored together in a single pair object.  (This would require having two copies of
    // the buffer pointer - one in the buffer pair and one in the string pair.)
    //
    // Instead we do not provide a mutable string pair operation; you can get a constant
    // string pair but almost certainly what you'll get back is a temporary object.

    inline const TConstantPair &BufferPair() const { return TTraits::BufferPair(this); }
    inline TMutablePair &MutableBufferPair() { return TTraits::MutableBufferPair(this); }
    inline TMutablePair GetMutableBufferPair() { return TTraits::MutableBufferPair(this); } // return a copy

    inline const TMutablePair GetOffsetMutableBufferPair(TSizeT cchOffset) { return TTraits::GetOffsetMutableBufferPair(this, cchOffset); }
    inline const TConstantPair GetStringPair() const { return TTraits::GetStringPair(this); }
    inline const TConstantString GetStringPtr() const { return TTraits::GetStringPair(this).GetPointer(); }

    template <typename TSomeCharType>
    static inline bool IsValidParameter(const CConstantPointerAndCountPair<TSomeCharType, TSizeT> &rpair)
    {
        return (rpair.GetPointer() != NULL) || (rpair.GetCount() == 0);
    }

    template <typename TSomeCharType>
    static inline bool IsValidParameter(const CMutablePointerAndCountPair<TSomeCharType, TSizeT> &rpair)
    {
        return (rpair.GetPointer() != NULL) || (rpair.GetCount() == 0);
    }

    static inline bool IsValidParameter(TChar ch)
    {
        return true;
    }

    static inline bool IsValidParameter(TConstantString psz) { return true; }
    static inline bool IsValidParameter(TMutableString psz) { return true; }
    static inline bool IsValidParameter(TConstantNonNativeString psz) { return true; }
    static inline bool IsValidParameter(TMutableNonNativeString psz) { return true; }

    template <typename TSomeCharType>
    static inline TSizeT GetTemplateParameterBufferCch(const CConstantPointerAndCountPair<TSomeCharType, TSizeT> &rpair) { return rpair.GetCount(); }

    template <typename TSomeCharType>
    static inline TSizeT GetTemplateParameterBufferCch(const CMutablePointerAndCountPair<TSomeCharType, TSizeT> &rpair) { return rpair.GetCount(); }

    inline TCallDisposition EnsureBufferLargeEnoughPreserve(TSizeT cch)
    {
        return TTraits::EnsureBufferLargeEnoughPreserve(this, cch);
    }

    inline TCallDisposition EnsureBufferLargeEnoughNoPreserve(TSizeT cch)
    {
        return TTraits::EnsureBufferLargeEnoughNoPreserve(this, cch);
    }

    template <typename TSomeInputType>
    inline TCallDisposition ExpandBufferForInputPreserve(const TSomeInputType &rinput, TSizeT cchExtra, TSizeT &rcchString)
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cch;
        TSizeT cchSum;

        rcchString = 0;

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_PARAMETER_CHECK(this->StringCchLegal(cchExtra));

        BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rinput, cch));
        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cchExtra, cch, cchSum));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cchSum));

        rcchString = cch;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeInputType>
    inline TCallDisposition ExpandBufferForInputNoPreserve(const TSomeInputType &rinput, TSizeT cchExtra, TSizeT &rcchString)
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cch;
        TSizeT cchSum;

        rcchString = 0;

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_PARAMETER_CHECK(this->StringCchLegal(cchExtra));

        BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rinput, cch));
        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cchExtra, cch, cchSum));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughNoPreserve(cchSum));

        rcchString = cch;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeInputType>
    inline
    TPublicErrorReturnType
    __fastcall
    public_Assign(
        const TSomeInputType &rinput
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));

        this->IntegrityCheck();

        TSizeT cch;

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        BCL_IFCALLFAILED_EXIT(this->ExpandBufferForInputNoPreserve(rinput, 0, cch));

        if (cch > 0)
        {
            TSizeT cchWritten;
            BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(this->MutableBufferPair(), rinput, cchWritten));

            // cch was the buffer size we needed (including the trailing null); we don't need the trailing
            // null any more...
            this->SetStringCch(cch);
        }

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeConstantStringType>
    inline TPublicErrorReturnType
    public_AssignVa(TSomeConstantStringType pUnusedPrototype, TSizeT cStrings, va_list ap)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        TMutablePair pairCursor;
        TSizeT cch = 0;
        TSizeT i;
        va_list ap2 = ap;

        BCL_PARAMETER_CHECK(cStrings >= 0);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        for (i=0; i<cStrings; i++)
        {
            TSomeConstantStringType psz = va_arg(ap, TSomeConstantStringType);
            int cchArg = va_arg(ap, int);
            TSizeT cchThis = (cchArg < 0) ? TTraits::NullTerminatedStringLength(psz) : static_cast<TSizeT>(cchArg);
            TSizeT cchRequired;

            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(TConstantPair(psz, cchThis), cchRequired));
            BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, cchRequired, cch));
        }

        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughNoPreserve(cch));

        pairCursor.SetPointerAndCount(this->GetMutableBufferPtr(), cch);

        for (i=0; i<cStrings; i++)
        {
            TSomeConstantStringType psz = va_arg(ap2, TSomeConstantStringType);
            int cchArg = va_arg(ap2, int);
            TSizeT cchThis = (cchArg < 0) ? TTraits::NullTerminatedStringLength(psz) : static_cast<TSizeT>(cchArg);
            BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, TConstantPair(psz, cchThis)));
        }

        this->SetStringCch(cch);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomePairType>
    inline TPublicErrorReturnType
    public_AssignArray(TSizeT cStrings, const TSomePairType *prgpairs)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        TMutablePair pairCursor;
        TSizeT cch = 0;
        TSizeT i;

        BCL_PARAMETER_CHECK(cStrings >= 0);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        for (i=0; i<cStrings; i++)
        {
            TSizeT cchRequired;
            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(prgpairs[i], cchRequired));
            BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, cchRequired, cch));
        }

        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughNoPreserve(cch));

        pairCursor.SetPointerAndCount(this->GetMutableBufferPtr(), cch);

        for (i=0; i<cStrings; i++)
            BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, prgpairs[i]));

        this->SetStringCch(cch);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline
    TPublicErrorReturnType
    public_Assign(
        const TDecodingDataIn &rddi,
        const TSomeInputType &rinput,
        TDecodingDataOut &rddo
        )
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        SIZE_T cch;
        BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rddi, rinput, rddo, cch));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughNoPreserve(cch));
        BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(this->GetMutableBufferPair(), rddi, rinput, rddo));
        this->SetStringCch(cch);
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    // Note: the sematics of the *Fill() functions is to try to get the
    // string to a particular length, not to add "n" instances of the
    // input.  Thus you might use this to pad a string with dots to get to
    // a certain number of characters.  If you want to work with repetitions
    // of the input, use the *Repeat() functions.
    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_AssignFill(
        const TSomeInputType &rinput,
        TSizeT cchResultantStringMaxLength,
        TSizeT &rcchExtra // if the length of rinput converted to the native buffer type
                            // (think Unicode -> NonNative or vice versa) is not a multiple
                            // of cchResultantStringMaxLength, the remainder is
                            // returned here in rcchExtra.
        )
    {
        BCL_MAYFAIL_PROLOG

//        TSizeT cchSum;
        TSizeT cchInput;
        TSizeT cchActual = 0;
        TSizeT cchExtra = 0;

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        if (cchResultantStringMaxLength > 0)
        {
            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rinput, cchInput));

            if (cchInput > 0)
            {
                TSizeT cRepetitions;
                TMutablePair pairCursor;

                cRepetitions = cchResultantStringMaxLength / cchInput;
                cchExtra = cchResultantStringMaxLength % cchInput;

                BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughNoPreserve(cchResultantStringMaxLength));

                pairCursor = this->GetMutableBufferPair();

                while (cRepetitions > 0)
                {
                    BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, rinput));
                    cRepetitions--;
                }

                cchActual = cchResultantStringMaxLength - cchExtra;
            }
            else
            {
                cchExtra = cchResultantStringMaxLength;
            }
        }

        this->SetStringCch(cchActual);
        rcchExtra = cchExtra;

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_AssignRepeat(
        const TSomeInputType &rinput,
        TSizeT cRepetitions
        )
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchTotal = 0;

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        if (cRepetitions > 0)
        {
            TSizeT cchInput;

            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rinput, cchInput));

            if (cchInput > 0)
            {
                TMutablePair pairCursor;

                BCL_IFCALLFAILED_EXIT(TTraits::MultiplyWithOverflowCheck(cchInput, cRepetitions, cchTotal));

                BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughNoPreserve(cchTotal));
                pairCursor = this->GetMutableBufferPair();

                while (cRepetitions > 0)
                {
                    BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, rinput));
                    cRepetitions--;
                }
            }
        }

        this->SetStringCch(cchTotal);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeConstantStringType>
    inline TPublicErrorReturnType
    public_AppendVa(TSomeConstantStringType pUnusedPrototype, TSizeT cStrings, va_list ap)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        TMutablePair pairCursor;
        TSizeT cch = 0;
        TSizeT cchTemp;
        TSizeT i;
        va_list ap2 = ap;

        BCL_PARAMETER_CHECK(cStrings >= 0);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        for (i=0; i<cStrings; i++)
        {
            TSomeConstantStringType psz = va_arg(ap, TSomeConstantStringType);
            int cchArg = va_arg(ap, int);
            TSizeT cchThis = (cchArg < 0) ? TTraits::NullTerminatedStringLength(psz) : static_cast<TSizeT>(cchArg);
            TSizeT cchRequired;

            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(TConstantPair(psz, cchThis), cchRequired));
            BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, cchRequired, cch));
        }

        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, this->GetStringCch(), cch));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cch));

        pairCursor.SetPointerAndCount(this->GetOffsetMutableBufferPtr(this->GetStringCch()), cch);

        for (i=0; i<cStrings; i++)
        {
            TSomeConstantStringType psz = va_arg(ap2, TSomeConstantStringType);
            int cchArg = va_arg(ap2, int);
            TSizeT cchThis = (cchArg < 0) ? TTraits::NullTerminatedStringLength(psz) : static_cast<TSizeT>(cchArg);
            BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, TConstantPair(psz, cchThis)));
        }

        this->SetStringCch(cch);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_Append(
        const TSomeInputType &rinput
        )
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));

        TSizeT cch;

        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        BCL_IFCALLFAILED_EXIT(this->ExpandBufferForInputPreserve(rinput, this->GetStringCch(), cch));

        if (cch > 0)
        {
            TSizeT cchWritten;
            BCL_IFCALLFAILED_EXIT(
                TTraits::CopyIntoBuffer(
                    this->GetOffsetMutableBufferPair(this->GetStringCch()),
                    rinput,
                    cchWritten));
            // We can assume that adding cch to the current string cch does not
            // overflow since ExpandBufferForInputPreserve would have had the same
            // overflow
            this->SetStringCch(this->GetStringCch() + cch);
        }

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline
    TPublicErrorReturnType
    public_Append(
        const TDecodingDataIn &rddi,
        const TSomeInputType &rinput,
        TDecodingDataOut &rddo
        )
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        SIZE_T cch;
        BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rddi, rinput, rddo, cch));
        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, this->GetStringCch(), cch));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cch));
        BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(this->GetOffsetMutableBufferPair(this->GetStringCch()), rddi, rinput, rddo));
        this->SetStringCch(cch);
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_AppendArray(TSizeT cStrings, const TSomeInputType *prginput)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        TMutablePair pairCursor;
        TSizeT cch = 0;
        TSizeT i;

        BCL_PARAMETER_CHECK((prginput != NULL) || (cStrings == 0));
        BCL_PARAMETER_CHECK(cStrings >= 0);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        for (i=0; i<cStrings; i++)
        {
            TSizeT cchRequired;
            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(prginput[i], cchRequired));
            BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, cchRequired, cch));
        }

        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, this->GetStringCch(), cch));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cch));

        pairCursor = this->GetOffsetMutableBufferPair(this->GetStringCch());

        for (i=0; i<cStrings; i++)
            BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, prginput[i]));

        this->SetStringCch(cch);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    // Note: the sematics of the *Fill() functions is to try to get the
    // string to a particular length, not to add "n" instances of the
    // input.  Thus you might use this to pad a string with dots to get to
    // a certain number of characters.  If you want to work with repetitions
    // of the input, use the *Repeat() functions.
    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_AppendFill(
        const TSomeInputType &rinput,
        TSizeT cchResultantStringMaxLength,
        TSizeT &rcchExtra // if the length of rinput converted to the native buffer type
                            // (think Unicode -> NonNative or vice versa) is not a multiple
                            // of cchResultantStringMaxLength, the remainder is
                            // returned here in rcchExtra.
        )
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchInput;
        TSizeT cchExtra = 0;
        TSizeT cchString = this->GetStringCch();
        TSizeT cchActual = cchString;

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        if (cchResultantStringMaxLength > cchString)
        {
            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rinput, cchInput));

            if (cchInput > 0)
            {
                TSizeT cRepetitions;
                TMutablePair pairBuffer;
                TSizeT cchAppendPartMaxLength = cchResultantStringMaxLength - cchString;

                cRepetitions = cchAppendPartMaxLength / cchInput;
                cchExtra = cchAppendPartMaxLength % cchInput;

                BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cchResultantStringMaxLength - cchExtra));
                pairBuffer = this->GetOffsetMutableBufferPair(cchString);

                while (cRepetitions > 0)
                {
                    BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairBuffer, rinput));
                    cRepetitions--;
                }
            }
            else
            {
                // Zero input string; extra chars is simple diff (no
                // underflow since we already know that cchResultantStringMaxLength
                // is greater than cchString).
                cchExtra = cchResultantStringMaxLength - cchString;
            }

            cchActual = cchResultantStringMaxLength - cchExtra;
        }

        this->SetStringCch(cchActual);
        rcchExtra = cchExtra;

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_AppendRepeat(
        const TSomeInputType &rinput,
        TSizeT cRepetitions
        )
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchString = this->GetStringCch();
        TSizeT cchTotal = cchString;

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        if (cRepetitions > 0)
        {
            TSizeT cchInput;

            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rinput, cchInput));

            if (cchInput > 0)
            {
                TMutablePair pairCursor;

                BCL_IFCALLFAILED_EXIT(TTraits::MultiplyWithOverflowCheck(cchInput, cRepetitions, cchTotal));
                BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cchTotal, cchString, cchTotal));

                BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cchTotal));
                pairCursor = this->GetOffsetMutableBufferPair(cchString);

                while (cRepetitions > 0)
                {
                    BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, rinput));
                    cRepetitions--;
                }
            }
        }

        this->SetStringCch(cchTotal);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_Prepend(
        const TSomeInputType &rinput
        )
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));

        TSizeT cchInput;

        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        TSizeT cchSum;
        TSizeT cchWritten;

        BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rinput, cchInput));
        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(this->GetStringCch(), cchInput, cchSum));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cchSum));

        // Move current buffer "up"
        BCL::MoveBytes(this->GetMutableBufferPtr() + cchInput, this->GetBufferPtr(), this->GetStringCch() * sizeof(TChar));

        // Copy from the source string into the buffer.
        BCL_IFCALLFAILED_EXIT(
            TTraits::CopyIntoBuffer(
                this->MutableBufferPair(),
                rinput,
                cchWritten));

        this->SetStringCch(cchSum);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline
    TPublicErrorReturnType
    public_Prepend(
        const TDecodingDataIn &rddi,
        const TSomeInputType &rinput,
        TDecodingDataOut &rddo
        )
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        SIZE_T cch;
        BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(rddi, rinput, rddo, cch));
        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, this->GetStringCch(), cch));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cch));
        BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(this->GetMutableBufferPair(), rddi, rinput, rddo));
        this->SetStringCch(cch);
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType
    public_PrependArray(TSizeT cStrings, const TSomeInputType *prginput)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        TMutablePair pairCursor;
        TSizeT cch = 0;
        TSizeT i;
        TSizeT cchString = this->GetStringCch();

        BCL_PARAMETER_CHECK((prginput != NULL) || (cStrings == 0));
        BCL_PARAMETER_CHECK(cStrings >= 0);

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        for (i=0; i<cStrings; i++)
        {
            TSizeT cchRequired;
            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(prginput[i], cchRequired));
            BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, cchRequired, cch));
        }

        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(cch, cchString, cch));
        BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cch));

        // Move current buffer "up"
        BCL::MoveBytes(this->GetMutableBufferPtr() + cchString, this->GetBufferPtr(), cchString * sizeof(TChar));

        pairCursor = this->GetMutableBufferPair();

        for (i=0; i<cStrings; i++)
            BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBufferAndAdvanceCursor(pairCursor, prginput[i]));

        this->SetStringCch(cch);

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeOutputType>
    inline
    TPublicErrorReturnType
    public_CopyOut(
        const TEncodingDataIn &rddi,
        const TSomeOutputType &routput,
        TEncodingDataOut &rddo,
        TSizeT &rcchWritten
        ) const
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        TConstantPair pairString = this->GetStringPair();
        TSizeT cchOriginal, cchToCopy, cchBufferWritten;
        BCL_PARAMETER_CHECK(this->IsValidParameter(routput));
        cchOriginal = pairString.GetCount();
        BCL_IFCALLFAILED_EXIT(TTraits::MapStringCchToBufferCch(cchOriginal, cchToCopy));
        pairString.SetCount(cchToCopy);
        BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(routput, rddi, pairString, rddo, cchBufferWritten));
        BCL_IFCALLFAILED_EXIT(TTraits::MapBufferCchToStringCch(cchBufferWritten, rcchWritten));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline
    TPublicErrorReturnType
    public_CopyOut(
        const TEncodingDataIn &rddi,
        TMutableNonNativeString &routput,
        TEncodingDataOut &rddo,
        TSizeT &rcchWritten
        ) const
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_PARAMETER_CHECK(this->IsValidParameter(routput));
        BCL_IFCALLFAILED_EXIT(TTraits::AllocateAndCopyIntoBuffer(routput, rddi, this->GetStringPair(), rddo, rcchWritten));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline
    TPublicErrorReturnType
    public_CopyOut(
        const TMutablePair &routput,
        TSizeT &rcchWritten
        ) const
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        TConstantPair pairString = this->GetStringPair();
        TSizeT cchOriginal;
        TSizeT cchToCopy;
        TSizeT cchBufferWritten;
        BCL_PARAMETER_CHECK(this->IsValidParameter(routput));
        // Apply null termination length as applicable
        cchOriginal = pairString.GetCount();
        BCL_IFCALLFAILED_EXIT(TTraits::MapStringCchToBufferCch(pairString.GetCount(), cchToCopy));
        pairString.SetCount(cchToCopy);
        BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(routput, pairString, cchBufferWritten));
        BCL_IFCALLFAILED_EXIT(TTraits::MapBufferCchToStringCch(cchBufferWritten, rcchWritten));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline
    TPublicErrorReturnType
    public_CopyOut(
        TMutableString &rstringout,
        TSizeT &rcchWritten
        ) const
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_PARAMETER_CHECK(this->IsValidParameter(rstringout));
        BCL_IFCALLFAILED_EXIT(TTraits::AllocateAndCopyIntoBuffer(rstringout, this->GetStringPair(), rcchWritten));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline VOID public_Clear(bool fFreeStorage = false)
    {
        this->IntegrityCheck();

        // You can't free the storage if there's an attached accessor
        BCL_ASSERT(!fFreeStorage || this->NoAccessors());

        if (this->NoAccessors())
        {
            if (fFreeStorage)
                TTraits::DeallocateDynamicBuffer(this);
            this->SetStringCch(0);
        }
    }

    inline TPublicErrorReturnType public_UpperCase(const TCaseInsensitivityData &rcid)
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_IFCALLFAILED_EXIT(TTraits::UpperCase(this, rcid));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline TPublicErrorReturnType public_LowerCase(const TCaseInsensitivityData &rcid)
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_IFCALLFAILED_EXIT(TTraits::LowerCase(this, rcid));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_Compare(
        const TSomeInputType &rinput,
        TComparisonResult &rcrOut
        ) const
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::CompareStrings(this->GetStringPair(), rinput, rcrOut));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_CompareI(
        const TSomeInputType &rinput,
        const TCaseInsensitivityData &rcid,
        TComparisonResult &rcrOut
        ) const
    {
        BCL_MAYFAIL_PROLOG
        this->IntegrityCheck();
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::CompareStringsI(this->GetStringPair(), rinput, rcid, rcrOut));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_Equals(
        const TSomeInputType &rinputCandidate,
        bool &rfMatches
        ) const
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinputCandidate));

        BCL_IFCALLFAILED_EXIT(
            TTraits::EqualStrings(
                this->GetStringPair(),
                rinputCandidate,
                rfMatches));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_EqualsI(
        const TSomeInputType &rinputCandidate,
        const TCaseInsensitivityData &rcid,
        bool &rfMatches
        ) const
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        BCL_PARAMETER_CHECK(this->IsValidParameter(rinputCandidate));

        BCL_IFCALLFAILED_EXIT(
            TTraits::EqualStringsI(
                this->GetStringPair(),
                rinputCandidate,
                rcid,
                rfMatches));

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline __int8 GetBufferCchAs_int8() const { this->IntegrityCheck(); if (this->GetBufferCch() > _I8_MAX) return _I8_MAX; return static_cast<__int8>(this->GetBufferCch()); }
    inline __int8 GetStringCchAs_int8() const { this->IntegrityCheck(); if (this->GetStringCch() > _I8_MAX) return _I8_MAX; return static_cast<__int8>(this->GetStringCch()); }

    inline unsigned __int8 GetBufferCchAs_unsigned_int8() const { this->IntegrityCheck(); if (this->GetBufferCch() > _UI8_MAX) return _UI8_MAX; return static_cast<unsigned __int8>(this->GetBufferCch()); }
    inline unsigned __int8 GetStringCchAs_unsigned_int8() const { this->IntegrityCheck(); if (this->GetStringCch() > _UI8_MAX) return _UI8_MAX; return static_cast<unsigned __int8>(this->GetStringCch()); }

    inline __int16 GetBufferCchAs_int16() const { this->IntegrityCheck(); if (this->GetBufferCch() > _I16_MAX) return _I16_MAX; return static_cast<__int16>(this->GetBufferCch()); }
    inline __int16 GetStringCchAs_int16() const { this->IntegrityCheck(); if (this->GetStringCch() > _I16_MAX) return _I16_MAX; return static_cast<__int16>(this->GetStringCch()); }

    inline unsigned __int16 GetBufferCchAs_unsigned_int16() const { this->IntegrityCheck(); if (this->GetBufferCch() > _UI16_MAX) return _UI16_MAX; return static_cast<unsigned __int16>(this->GetBufferCch()); }
    inline unsigned __int16 GetStringCchAs_unsigned_int16() const { this->IntegrityCheck(); if (this->GetStringCch() > _UI16_MAX) return _UI16_MAX; return static_cast<unsigned __int16>(this->GetStringCch()); }

    inline __int32 GetBufferCchAs_int32() const { this->IntegrityCheck(); if (this->GetBufferCch() > _I32_MAX) return _I32_MAX; return static_cast<__int32>(this->GetBufferCch()); }
    inline __int32 GetStringCchAs_int32() const { this->IntegrityCheck(); if (this->GetStringCch() > _I32_MAX) return _I32_MAX; return static_cast<__int32>(this->GetStringCch()); }

    inline unsigned __int32 GetBufferCchAs_unsigned_int32() const { this->IntegrityCheck(); if (this->GetBufferCch() > _UI32_MAX) return _UI32_MAX; return static_cast<unsigned __int32>(this->GetBufferCch()); }
    inline unsigned __int32 GetStringCchAs_unsigned_int32() const { this->IntegrityCheck(); if (this->GetStringCch() > _UI32_MAX) return _UI32_MAX; return static_cast<unsigned __int32>(this->GetStringCch()); }

    inline __int64 GetBufferCchAs_int64() const { this->IntegrityCheck(); if (this->GetBufferCch() > _I64_MAX) return _I64_MAX; return static_cast<__int64>(this->GetBufferCch()); }
    inline __int64 GetStringCchAs_int64() const { this->IntegrityCheck(); if (this->GetStringCch() > _I64_MAX) return _I64_MAX; return static_cast<__int64>(this->GetStringCch()); }

    inline unsigned __int64 GetBufferCchAs_unsigned_int64() const { this->IntegrityCheck(); if (this->GetBufferCch() > _UI64_MAX) return _UI64_MAX; return static_cast<unsigned __int64>(this->GetBufferCch()); }
    inline unsigned __int64 GetStringCchAs_unsigned_int64() const { this->IntegrityCheck(); if (this->GetStringCch() > _UI64_MAX) return _UI64_MAX; return static_cast<unsigned __int64>(this->GetStringCch()); }

    inline char GetBufferCchAs_char() const { this->IntegrityCheck(); if (this->GetBufferCch() > CHAR_MAX) return CHAR_MAX; return static_cast<char>(this->GetBufferCch()); }
    inline char GetStringCchAs_char() const { this->IntegrityCheck(); if (this->GetStringCch() > CHAR_MAX) return CHAR_MAX; return static_cast<char>(this->GetStringCch()); }

    inline unsigned char GetBufferCchAs_unsigned_char() const { this->IntegrityCheck(); if (this->GetBufferCch() > UCHAR_MAX) return UCHAR_MAX; return static_cast<unsigned char>(this->GetBufferCch()); }
    inline unsigned char GetStringCchAs_unsigned_char() const { this->IntegrityCheck(); if (this->GetStringCch() > UCHAR_MAX) return UCHAR_MAX; return static_cast<unsigned char>(this->GetStringCch()); }

    inline unsigned char GetBufferCchAs_signed_char() const { this->IntegrityCheck(); if (this->GetBufferCch() > SCHAR_MAX) return SCHAR_MAX; return static_cast<signed char>(this->GetBufferCch()); }
    inline unsigned char GetStringCchAs_signed_char() const { this->IntegrityCheck(); if (this->GetStringCch() > SCHAR_MAX) return SCHAR_MAX; return static_cast<signed char>(this->GetStringCch()); }

    inline short GetBufferCchAs_short() const { this->IntegrityCheck(); if (this->GetBufferCch() > SHRT_MAX) return SHRT_MAX; return static_cast<short>(this->GetBufferCch()); }
    inline short GetStringCchAs_short() const { this->IntegrityCheck(); if (this->GetStringCch() > SHRT_MAX) return SHRT_MAX; return static_cast<short>(this->GetStringCch()); }

    inline unsigned short GetBufferCchAs_unsigned_short() const { this->IntegrityCheck(); if (this->GetBufferCch() > USHRT_MAX) return USHRT_MAX; return static_cast<unsigned short>(this->GetBufferCch()); }
    inline unsigned short GetStringCchAs_unsigned_short() const { this->IntegrityCheck(); if (this->GetStringCch() > USHRT_MAX) return USHRT_MAX; return static_cast<unsigned short>(this->GetStringCch()); }

    inline int GetBufferCchAs_int() const { this->IntegrityCheck(); if (this->GetBufferCch() > INT_MAX) return INT_MAX; return static_cast<int>(this->GetBufferCch()); }
    inline int GetStringCchAs_int() const { this->IntegrityCheck(); if (this->GetStringCch() > INT_MAX) return INT_MAX; return static_cast<int>(this->GetStringCch()); }

    inline unsigned int GetBufferCchAs_unsigned_int() const { this->IntegrityCheck(); if (this->GetBufferCch() > UINT_MAX) return UINT_MAX; return static_cast<unsigned int>(this->GetBufferCch()); }
    inline unsigned int GetStringCchAs_unsigned_int() const { this->IntegrityCheck(); if (this->GetStringCch() > UINT_MAX) return UINT_MAX; return static_cast<unsigned int>(this->GetStringCch()); }

    inline long GetBufferCchAs_long() const { this->IntegrityCheck(); if (this->GetBufferCch() > LONG_MAX) return LONG_MAX; return static_cast<long>(this->GetBufferCch()); }
    inline long GetStringCchAs_long() const { this->IntegrityCheck(); if (this->GetStringCch() > LONG_MAX) return LONG_MAX; return static_cast<long>(this->GetStringCch()); }

    inline unsigned long GetBufferCchAs_unsigned_long() const { this->IntegrityCheck(); if (this->GetBufferCch() > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetBufferCch()); }
    inline unsigned long GetStringCchAs_unsigned_long() const { this->IntegrityCheck(); if (this->GetStringCch() > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetStringCch()); }

    inline TSizeT GetBufferCb() const { this->IntegrityCheck(); return this->GetBufferCch() * sizeof(TChar); }
    inline int GetBufferCbAs_int() const { this->IntegrityCheck(); if ((this->GetBufferCch() * sizeof(TChar)) > INT_MAX) return INT_MAX; return static_cast<int>(this->GetBufferCch() * sizeof(TChar)); }
    inline unsigned long GetBufferCbAs_unsigned_long() const { this->IntegrityCheck(); if ((this->GetBufferCch() * sizeof(TChar)) > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetBufferCch() * sizeof(TChar)); }
    inline unsigned long GetStringCbAs_unsigned_long() const { this->IntegrityCheck(); if ((this->GetStringCch() * sizeof(TChar)) > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetStringCch() * sizeof(TChar)); }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_Span(const TSomeInputType &rinput, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::Span(this->GetStringPair(), rinput, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_SpanI(const TSomeInputType &rinput, const TCaseInsensitivityData &rcid, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::SpanI(this->GetStringPair(), rinput, rcid, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_ReverseSpan(const TSomeInputType &rinput, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::ReverseSpan(this->GetStringPair(), rinput, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_ReverseSpanI(const TSomeInputType &rinput, const TCaseInsensitivityData &rcid, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::ReverseSpanI(this->GetStringPair(), rinput, rcid, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_ComplementSpan(const TSomeInputType &rinput, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::ComplementSpan(this->GetStringPair(), rinput, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_ComplementSpanI(const TSomeInputType &rinput, const TCaseInsensitivityData &rcid, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::ComplementSpanI(this->GetStringPair(), rinput, rcid, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_ReverseComplementSpan(const TSomeInputType &rinput, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::ReverseComplementSpan(this->GetStringPair(), rinput, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_ReverseComplementSpanI(const TSomeInputType &rinput, const TCaseInsensitivityData &rcid, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::ReverseComplementSpanI(this->GetStringPair(), rinput, rcid, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_Contains(const TSomeInputType &rinput, bool &rfContainsCharacter) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::Contains(this->GetStringPair(), rinput, rfContainsCharacter));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_ContainsI(const TSomeInputType &rinput, const TCaseInsensitivityData &rcid, bool &rfContainsCharacter) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::ContainsI(this->GetStringPair(), rinput, rcid, rfContainsCharacter));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_FindFirst(const TSomeInputType &rinput, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::FindFirst(this->GetStringPair(), rinput, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_Count(const TSomeInputType &rinput, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::Count(this->GetStringPair(), rinput, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_FindLast(const TSomeInputType &rinput, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::FindLast(this->GetStringPair(), rinput, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_FindFirstI(const TSomeInputType &rinput, const TCaseInsensitivityData &rcid, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::FindFirstI(this->GetStringPair(), rinput, rcid, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeInputType>
    inline TPublicErrorReturnType public_FindLastI(const TSomeInputType &rinput, const TCaseInsensitivityData &rcid, TSizeT &rich) const
    {
        BCL_MAYFAIL_PROLOG
        BCL_PARAMETER_CHECK(this->IsValidParameter(rinput));
        BCL_IFCALLFAILED_EXIT(TTraits::FindLastI(this->GetStringPair(), rinput, rcid, rich));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline bool IsEmpty() const
    {
        return this->GetBufferPtr()[0] == 0;
    }

    template <typename TSomeCharType>
    inline TPublicErrorReturnType public_EnsureTrailingChar(TSomeCharType ch)
    {
        BCL_MAYFAIL_PROLOG

        bool fDoAppend = false;

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        if (this->GetStringCch() == 0)
            fDoAppend = true;
        else
        {
            bool fMatches = false;

            BCL_IFCALLFAILED_EXIT(TTraits::EqualsLastCharacter(this->GetBufferPtr(), this->GetStringCch(), ch, fMatches));

            if (!fMatches)
                fDoAppend = true;
        }

        if (fDoAppend)
        {
            TSizeT cch;

            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(ch, cch));

            if (cch > 1)
            {
                TSizeT cchTotal;
                BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(this->GetStringCch(), cch, cchTotal));
                BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cchTotal));
                // subtraction should only underflow if stringcch > buffercch which is bad anyways.
                BCL_INTERNAL_ERROR_CHECK(this->GetStringCch() <= this->GetBufferCch());
                BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(this->GetBufferPtr()[this->GetStringCch()], this->GetBufferCch() - this->GetStringCch(), ch));
                this->SetStringCch(cchTotal);
            }
        }

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    template <typename TSomeCharType>
    inline TPublicErrorReturnType public_EnsureTrailingCharCaseInsensitive(TSomeCharType ch, const TCaseInsensitivityData &rcid)
    {
        BCL_MAYFAIL_PROLOG

        bool fDoAppend = false;

        this->IntegrityCheck();

        // it would seem innocuous to allow assigns that don't resize the buffer to not
        // invalidate accessors, but that makes finding such bugs subject to even more
        // strenuous coverage problems than this simple error.  The simple rule is that
        // you should not have an accessor attached to a string buffer when you use
        // any of member functions that may mutate the value.
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        if (this->GetStringCch() == 0)
            fDoAppend = true;
        else
        {
            bool fMatches = false;

            BCL_IFCALLFAILED_EXIT(TTraits::EqualsLastCharacterCaseInsensitive(this->GetBufferPtr(), this->GetStringCch(), ch, rcid, fMatches));

            if (!fMatches)
                fDoAppend = true;
        }

        if (fDoAppend)
        {
            TSizeT cch;

            BCL_IFCALLFAILED_EXIT(TTraits::DetermineRequiredCharacters(ch, cch));
            if (cch > 1)
            {
                TSizeT cchSum;

                BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(this->GetStringCch(), cch, cchSum));
                BCL_IFCALLFAILED_EXIT(this->EnsureBufferLargeEnoughPreserve(cchSum));
                BCL_INTERNAL_ERROR_CHECK(this->GetStringCch() <= this->GetBufferCch());
                BCL_IFCALLFAILED_EXIT(TTraits::CopyIntoBuffer(this->GetBufferPtr()[this->GetStringCch()], this->GetBufferCch() - this->GetStringCch(), ch));
                this->SetStringCch(cchSum);
            }
        }

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline TCallDisposition Left(TSizeT newLength)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        BCL_PARAMETER_CHECK(newLength <= this->GetStringCch());
        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());

        this->SetStringCch(newLength);

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline TPublicErrorReturnType public_Left(TSizeT newLength)
    {
        BCL_MAYFAIL_PROLOG
        BCL_IFCALLFAILED_EXIT(this->Left(newLength));
        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline TCallDisposition Right(TSizeT cchRightCount)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());
        BCL_PARAMETER_CHECK(cchRightCount <= this->GetStringCch());

        if (cchRightCount < this->GetStringCch())
        {
            BCL::MoveBytes(
                this->GetMutableBufferPtr(),
                &this->GetBufferPtr()[this->GetStringCch() - cchRightCount],
                cchRightCount * sizeof(TTraits::TChar));
            this->SetStringCch(cchRightCount);
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    TPublicErrorReturnType public_Right(TSizeT cchRightCount)
    {
        BCL_MAYFAIL_PROLOG

        this->IntegrityCheck();

        BCL_IFCALLFAILED_EXIT(this->NoAccessorsCheck());
        BCL_PARAMETER_CHECK(cchRightCount <= this->GetStringCch());

        if (cchRightCount < this->GetStringCch())
        {
            BCL::MoveBytes(
                this->GetMutableBufferPtr(),
                &this->GetBufferPtr()[this->GetStringCch() - cchRightCount],
                (cchRightCount + 1)*sizeof(TTraits::TChar));
            this->SetStringCch(cchRightCount);
        }

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    TPublicErrorReturnType public_Mid(TSizeT ichStart, TSizeT cch)
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchSum;

        BCL_IFCALLFAILED_EXIT(TTraits::AddWithOverflowCheck(ichStart, cch, cchSum));

        // It's not unreasonable to end up with a zero length string, so this is <=, not <
        BCL_PARAMETER_CHECK(cchSum <= this->GetStringCch());

        BCL_IFCALLFAILED_EXIT(this->Right(this->GetStringCch() - ichStart));
        BCL_IFCALLFAILED_EXIT(this->Left(cch));

        BCL_MAYFAIL_EPILOG_PUBLIC
    }
};

template <typename TTraits> class CPureStringAccessor
{
public:
    typedef CPureString<TTraits> TBuffer;
    typedef typename TTraits::TChar TChar;
    typedef typename TTraits::TCallDisposition TCallDisposition;
    typedef typename TTraits::TMutableString TMutableString;
    typedef typename TTraits::TConstantString TConstantString;
    typedef typename TTraits::TSizeT TSizeT;
    typedef typename TTraits::TPublicErrorReturnType TPublicErrorReturnType;
    typedef BCL::CMutablePointerAndCountPair<TChar, TSizeT> TMutablePair;
    typedef BCL::CConstantPointerAndCountPair<TChar, TSizeT> TConstantPair;

    CPureStringAccessor(TBuffer* pBuffer) : m_pStringBuffer(NULL)
    {
        this->Attach(pBuffer);
    }

    CPureStringAccessor() : m_pStringBuffer(NULL) { }

    ~CPureStringAccessor()
    {
        if (m_pStringBuffer != NULL)
        {
            m_pStringBuffer->SetStringCch(TTraits::NullTerminatedStringLengthWithLimit(this->GetBufferPtr(), this->GetBufferCch()));
            m_pStringBuffer->DetachAccessor(this);
            m_pStringBuffer = NULL;
        }
    }

    bool IsAttached() const
    {
        return (m_pStringBuffer != NULL);
    }

    inline TPublicErrorReturnType Attach(TBuffer *pBuffer)
    {
        BCL_MAYFAIL_PROLOG

        BCL_INTERNAL_ERROR_CHECK(!this->IsAttached());

        BCL_IFCALLFAILED_EXIT(pBuffer->AttachAccessor(this));

        m_pStringBuffer = pBuffer;

        BCL_MAYFAIL_EPILOG_PUBLIC
    }

    inline void Detach()
    {
        BCL_ASSERT (this->IsAttached());
        if (this->IsAttached())
        {
            m_pStringBuffer->SetStringCch(TTraits::NullTerminatedStringLengthWithLimit(this->GetBufferPtr(), this->GetBufferCch()));
            m_pStringBuffer->DetachAccessor(this);
            m_pStringBuffer = NULL;
        }
    }

    inline operator TMutableString() const { BCL_ASSERT(this->IsAttached()); return this->GetBufferPtr(); }

    inline typename TTraits::TMutableString GetBufferPtr() const { BCL_ASSERT(IsAttached()); return m_pStringBuffer->GetBufferPtr(); }

    inline TSizeT GetBufferCch() const { BCL_ASSERT(this->IsAttached()); return m_pStringBuffer->GetBufferCch(); }

    inline short GetBufferCchAs_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCch() > SHORT_MAX) return SHORT_MAX; return static_cast<short>(this->GetBufferCch()) }
    inline unsigned short GetBufferCchAs_unsigned_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCch() > USHORT_MAX) return USHORT_MAX; return static_cast<unsigned short>(this->GetBufferCch()) }

    inline int GetBufferCchAs_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCch() > INT_MAX) return INT_MAX; return static_cast<int>(this->GetBufferCch()); }
    inline unsigned int GetBufferCchAs_unsigned_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCch() > UINT_MAX) return UINT_MAX; return static_cast<unsigned int>(this->GetBufferCch()); }

    inline long GetBufferCchAs_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCch() > LONG_MAX) return LONG_MAX; return static_cast<long>(this->GetBufferCch()); }
    inline unsigned long GetBufferCchAs_unsigned_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCch() > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetBufferCch()); }

    inline TSizeT GetStringCch() const { BCL_ASSERT(this->IsAttached()); return TTraits::NullTerminatedStringLengthWithLimit(this->GetBufferPtr(), this->GetBufferCch()); }

    inline short GetStringCchAs_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCch() > SHORT_MAX) return SHORT_MAX; return static_cast<short>(this->GetStringCch()) }
    inline unsigned short GetStringCchAs_unsigned_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCch() > USHORT_MAX) return USHORT_MAX; return static_cast<unsigned short>(this->GetStringCch()) }

    inline int GetStringCchAs_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCch() > INT_MAX) return INT_MAX; return static_cast<int>(this->GetStringCch()); }
    inline unsigned int GetStringCchAs_unsigned_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCch() > UINT_MAX) return UINT_MAX; return static_cast<unsigned int>(this->GetStringCch()); }

    inline long GetStringCchAs_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCch() > LONG_MAX) return LONG_MAX; return static_cast<long>(this->GetStringCch()); }
    inline unsigned long GetStringCchAs_unsigned_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCch() > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetStringCch()); }

    inline TSizeT GetBufferCb() const { BCL_ASSERT(this->IsAttached()); return m_pStringBuffer->GetBufferCb(); }

    inline short GetBufferCbAs_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCb() > SHORT_MAX) return SHORT_MAX; return static_cast<short>(this->GetBufferCb()) }
    inline unsigned short GetBufferCbAs_unsigned_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCb() > USHORT_MAX) return USHORT_MAX; return static_cast<unsigned short>(this->GetBufferCb()) }

    inline int GetBufferCbAs_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCb() > INT_MAX) return INT_MAX; return static_cast<int>(this->GetBufferCb()); }
    inline unsigned int GetBufferCbAs_unsigned_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCb() > UINT_MAX) return UINT_MAX; return static_cast<unsigned int>(this->GetBufferCb()); }

    inline long GetBufferCbAs_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCb() > LONG_MAX) return LONG_MAX; return static_cast<long>(this->GetBufferCb()); }
    inline unsigned long GetBufferCbAs_unsigned_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetBufferCb() > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetBufferCb()); }

    inline TSizeT GetStringCb() const { BCL_ASSERT(this->IsAttached()); return m_cch * sizeof(TChar); }

    inline short GetStringCbAs_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCb() > SHORT_MAX) return SHORT_MAX; return static_cast<short>(this->GetStringCb()) }
    inline unsigned short GetStringCbAs_unsigned_short() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCb() > USHORT_MAX) return USHORT_MAX; return static_cast<unsigned short>(this->GetStringCb()) }

    inline int GetStringCbAs_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCb() > INT_MAX) return INT_MAX; return static_cast<int>(this->GetStringCb()); }
    inline unsigned int GetStringCbAs_unsigned_int() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCb() > UINT_MAX) return UINT_MAX; return static_cast<unsigned int>(this->GetStringCb()); }

    inline long GetStringCbAs_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCb() > LONG_MAX) return LONG_MAX; return static_cast<long>(this->GetStringCb()); }
    inline unsigned long GetStringCbAs_unsigned_long() const { BCL_ASSERT(this->IsAttached()); if (this->GetStringCb() > ULONG_MAX) return ULONG_MAX; return static_cast<unsigned long>(this->GetStringCb()); }

protected:
    TBuffer *m_pStringBuffer;
    TMutablePair m_pairBuffer;

private:
    //
    // These two are to induce build breaks on people doing sb1 = sb2
    //
    void operator=(const CPureStringAccessor &rOtherString);
    CPureStringAccessor(const CPureStringAccessor &r);
};

}; // namespace BCL

#endif // !defined(_WINDOWS_BCL_PURESTRING_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_stringalgorithms.h ===
#if !defined(_WINDOWS_BCL_STRINGALGORITHMS_H_INCLUDED_)
#define _WINDOWS_BCL_STRINGALGORITHMS_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_stringalgorithms.h

Abstract:

    Abstract algorithms and definitions for a string class.

Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <bcl_common.h>

namespace BCL {

//
// CCharacterListMatcher and friends:
//
//  Matchers in general are classes which you can use as input
//  to find first/span/etc. as a generalized mechanism to find
//  a string or a set of characters etc.
//
//  The idea is that matchers are associated with some pattern.
//  This may be a literal string to match, or a set of
//  characters to match or a regular expression or whatever.
//
//  They have one public method, Match() which takes a
//  TConstantPair and a bool ref.  If the matcher object's
//  pattern matches the string, the bool ref is set to true;
//  otherwise false.
//
//  CCharacterListMatcher treats its pattern as a set of
//      characters to match; specifically ala Span/wcsspn.
//
//  CCharacterStringMatcher looks rather like CCharacterListMatcher,
//  but instead of a list of candidate characters to match against,
//  its pattern is a literal string and a match is when the beginning
//  of the candidate string passed in to Match() is equal to the
//  pattern string.
//

template <typename TCallDisposition, typename TConstantPair>
class CCharacterListMatcher
{
public:
    CCharacterListMatcher(const TConstantPair &rpair) : m_pair(rpair) { }

    inline bool MatchesEverything() const { return m_pair.GetCount() == 0; }
    inline typename TConstantPair::TCount RequiredSourceCch() const { return (m_pair.GetCount() == 0) ? 0 : 1; }

    inline TCallDisposition Matches(const TConstantPair &rpair, bool &rfMatches)
    {
        BCL_MAYFAIL_PROLOG

        rfMatches = false;

        BCL_PARAMETER_CHECK(rpair.Valid());

        const TConstantPair::TCount limit = m_pair.GetCount();

        // If there are no characters to match against, then we could not have
        // matched.
        if ((limit > 0) && (rpair.GetCount() > 0))
        {
            const TConstantPair::TPointee ch = rpair.GetPointer()[0];
            const TConstantPair::TConstantArray prgchPattern = m_pair.GetPointer();
            TConstantPair::TCount i;

            for (i=0; i<limit; i++)
            {
                if (prgchPattern[i] == ch)
                {
                    rfMatches = true;
                    break;
                }
            }
        }

        BCL_MAYFAIL_EPILOG
    }

protected:
    TConstantPair m_pair;
}; // class CCharacterListMatcher

template <typename TCallDisposition, typename TConstantPair>
class CCharacterStringMatcher
{
public:
    CCharacterStringMatcher(const TConstantPair &rpair) : m_pair(rpair) { }

    inline TCallDisposition Matches(const TConstantPair &rpair, bool &rfMatches)
    {
        BCL_MAYFAIL_PROLOG

        rfMatches = false;

        BCL_PARAMETER_CHECK(rpair.Valid());

        const TConstantPair::TCount cchCandidate = rpair.GetCount();
        const TConstantPair::TCount cchPattern = m_pair.GetCount();

        if (cchCandidate >= cchPattern)
        {
            if (BCL::IsMemoryEqual(rpair.GetPointer(), m_pair.GetPointer(), cchPattern * sizeof(TConstantPair::TPointee)))
            {
                rfMatches = true;
                break;
            }
        }

        BCL_MAYFAIL_EPILOG
    }

protected:
    TConstantPair m_pair;
}; // class CCharacterStringMatcher

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
__fastcall
EqualStrings(
    const TConstantPair &rpair1,
    const TConstantPair &rpair2,
    bool &rfEquals
    )
{
    BCL_MAYFAIL_PROLOG

    BCL_PARAMETER_CHECK(rpair1.Valid());
    BCL_PARAMETER_CHECK(rpair2.Valid());
    rfEquals = ((rpair1.GetCount() == rpair2.GetCount()) &&
        (BCL::IsMemoryEqual(rpair1.GetPointer(), rpair2.GetPointer(), rpair1.GetCount() * sizeof(TConstantPair::TPointee))));

    BCL_MAYFAIL_EPILOG_INTERNAL
} // EqualStrings()

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
__fastcall
EqualStrings(
    const TConstantPair &rpair1,
    typename TConstantPair::TPointee tch,
    bool &rfEquals
    )
{
    BCL_MAYFAIL_PROLOG

    BCL_PARAMETER_CHECK(rpair1.Valid());
    rfEquals = ((rpair1.GetCount() == 1) && (rpair1.GetPointer()[0] == tch));

    BCL_MAYFAIL_EPILOG_INTERNAL
} // EqualStrings

template <typename TCallDisposition, typename TConstantPair, typename TComparisonResult>
inline
TCallDisposition
__fastcall
CompareStrings(
    const TConstantPair &rpair1,
    const TConstantPair &rpair2,
    TComparisonResult &rcr
    )
{
    BCL_MAYFAIL_PROLOG
    BCL_PARAMETER_CHECK(rpair1.Valid());
    BCL_PARAMETER_CHECK(rpair2.Valid());
    rcr = BCL::CompareBytes<TConstantPair::TPointee, TConstantPair::TCount, TComparisonResult>(rpair1, rpair2);
    BCL_MAYFAIL_EPILOG_INTERNAL
} // CompareStrings

template <typename TCallDisposition, typename TConstantPair, typename TComparisonResult>
inline
TCallDisposition
__fastcall
CompareStrings(
    const TConstantPair &rpair1,
    typename TConstantPair::TPointee tch,
    TComparisonResult &rcr
    )
{
    BCL_MAYFAIL_PROLOG
    BCL_PARAMETER_CHECK(rpair1.Valid());
    rcr = BCL::CompareBytes<TConstantPair::TPointee, TConstantPair::TCount, TComparisonResult>(rpair1, TConstantPair(&tch, 1));
    BCL_MAYFAIL_EPILOG_INTERNAL
} // CompareStrings()

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
Count(
    const TConstantPair &rpair,
    typename TConstantPair::TPointee tch,
    typename TConstantPair::TCount &rcchFound
    )
{
    BCL_MAYFAIL_PROLOG;
    TConstantPair::TCount i, cch = rpair.GetCount();
    TConstantPair::TConstantArray prgwch = rpair.GetPointer();
    rcchFound = 0;
    for (i = 0; i < cch; i++)
    {
        if (prgwch[i] == tch)
            rcchFound++;
    }
    BCL_MAYFAIL_EPILOG_INTERNAL;
} // Count()

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
FindFirst(
    const TConstantPair &rpair,
    typename TConstantPair::TPointee tch,
    typename TConstantPair::TCount &richFound
    )
{
    BCL_MAYFAIL_PROLOG

    // There doesn't seem to be a builtin to do this...
    typename TConstantPair::TCount i;
    typename TConstantPair::TCount cch = rpair.GetCount();
    typename TConstantPair::TConstantArray prgwch = rpair.GetPointer();

    richFound = cch;

    for (i=0; i<cch; i++)
    {
        if (prgwch[i] == tch)
            break;
    }

    richFound = i;

    BCL_MAYFAIL_EPILOG_INTERNAL
} // FindFirst()

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
FindFirst(
    const TConstantPair &rpair,
    const TConstantPair &rpairCandidate,
    typename TConstantPair::TCount &richFound
    )
{
    BCL_MAYFAIL_PROLOG

    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    TSizeT cch = rpair.GetCount();

    richFound = cch;

    BCL_PARAMETER_CHECK(rpair.Valid());
    BCL_PARAMETER_CHECK(rpairCandidate.Valid());

    // There are some really good string searching algorithms out there.
    //
    // This isn't one of them.  -mgrier 2/3/2002

    TSizeT i;
    TConstantString prgch = rpair.GetPointer();
    TSizeT cchToFind = rpairCandidate.GetCount();

    if (cchToFind == 0)
    {
        // Every string has a substring that's the null string
        richFound = 0;
    }
    else
    {
        if (cchToFind <= cch)
        {
            TConstantString prgwchCandidate = rpairCandidate.GetPointer();
            TChar ch = prgwchCandidate[0];
            TSizeT cchMax = (cch - cchToFind) + 1;

            for (i=0; i<cchMax; i++)
            {
                if (prgch[i] == ch)
                {
                    // Hmmm... a hit.  Let's look more.
                    if (BCL::IsMemoryEqual(&prgch[i], prgwchCandidate, cchToFind * sizeof(TChar)))
                    {
                        // well done!
                        richFound = i;
                        break;
                    }
                }
            }
        }
    }

    BCL_MAYFAIL_EPILOG_INTERNAL
} // FindFirst()

template <typename TCallDisposition, typename TConstantPair, typename TMatcher>
inline
TCallDisposition
FindFirstMatch(
    const TConstantPair &rpair,
    const TMatcher &rmatcher,
    typename TConstantPair::TCount &richFound
    )
{
    BCL_MAYFAIL_PROLOG

    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    TSizeT cch = rpair.GetCount();

    richFound = cch;

    BCL_PARAMETER_CHECK(rpair.Valid());

    // There are some really good string searching algorithms out there.
    //
    // This isn't one of them.  -mgrier 2/3/2002

    TSizeT i;
    TConstantString prgch = rpair.GetPointer();

    if (rmatcher.MatchesEverything())
    {
        richFound = 0;
    }
    else
    {
        TSizeT cchMax = (cch - rmatcher.RequiredSourceCch()) + 1;

        for (i=0; i<cchMax; i++)
        {
            bool fFound = false;
            BCL_IFCALLFAILED_EXIT(rmatcher.Matches(rpair.GetOffsetPair(i), fFound));
            if (fFound)
            {
                // well done!
                richFound = i;
                break;
            }
        }
    }

    BCL_MAYFAIL_EPILOG_INTERNAL
} // FindFirst()

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
FindLast(
    const TConstantPair &rpair,
    typename TConstantPair::TPointee ch,
    typename TConstantPair::TCount &richFound
    )
{
    BCL_MAYFAIL_PROLOG

    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    // There doesn't seem to be a builtin to do this...
    TSizeT i;
    TSizeT cch = rpair.GetCount();
    TConstantString prgwch = rpair.GetPointer() + cch;

    richFound = cch;

    for (i=cch; i>0; i--)
    {
        if (*--prgwch == ch)
            break;
    }

    if (i == 0)
        richFound = cch;
    else
        richFound = i - 1;

    BCL_MAYFAIL_EPILOG_INTERNAL
} // FindLast()

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
FindLast(
    const TConstantPair &rpair,
    const TConstantPair &rpairCandidate,
    typename TConstantPair::TCount &richFound
    )
{
    BCL_MAYFAIL_PROLOG

    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    TSizeT cch = rpair.GetCount();

    richFound = cch;

    BCL_PARAMETER_CHECK(rpair.Valid());
    BCL_PARAMETER_CHECK(rpairCandidate.Valid());

    // There are some really good string searching algorithms out there.
    //
    // This isn't one of them.  -mgrier 2/3/2002

    TSizeT i;
    TConstantString prgch = rpair.GetPointer();
    TSizeT cchToFind = rpairCandidate.GetCount();

    if (cchToFind == 0)
    {
        // Every string has a substring that's the null string.  Since
        // we're interested in the index of it, it's at the end of
        // the string which is what richFound already is.
        richFound = cch;
    }
    else
    {
        if (cchToFind <= cch)
        {
            TConstantString prgwchToFind = rpairCandidate.GetPointer();
            TChar ch = prgwchToFind[0];
            TSizeT cchMax = (cch - cchToFind) + 1;

            for (i=0; i<cchMax; i++)
            {
                if (prgch[i] == ch)
                {
                    // Hmmm... a hit.  Let's look more.
                    if (BCL::IsMemoryEqual(&prgch[i], prgwchToFind, cchToFind * sizeof(TChar)))
                    {
                        // well done!  Keep looking though; we want the last one...
                        richFound = i;
                    }
                }
            }
        }
    }

    BCL_MAYFAIL_EPILOG_INTERNAL
} // FindLast()

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
Contains(
    const TConstantPair &rpair,
    typename TConstantPair::TPointee ch,
    bool &rfFound
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    rfFound = false;

    BCL_PARAMETER_CHECK(rpair.Valid());
    TSizeT cch = rpair.GetCount();
    TSizeT i;
    TConstantString prgch = rpair.GetPointer();

    for (i=0; i<cch; i++)
    {
        if (prgch[i] == ch)
            break;
    }

    if (i != cch)
        rfFound = true;

    BCL_MAYFAIL_EPILOG_INTERNAL
}

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
Contains(
    const TConstantPair &rpair,
    const TConstantPair &rpairCandidate,
    bool &rfFound
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    rfFound = false;

    BCL_PARAMETER_CHECK(rpair.Valid());
    BCL_PARAMETER_CHECK(rpairCandidate.Valid());

    // There are some really good string searching algorithms out there.
    //
    // This isn't one of them.  -mgrier 2/3/2002

    TSizeT cch = rpair.GetCount();
    TSizeT i;
    TConstantString prgch = rpair.GetPointer();
    TSizeT cchToFind = rpairCandidate.GetCount();

    if (cchToFind == 0)
    {
        // Every string has a substring that's the null string
        rfFound = true;
    }
    else
    {
        if (cchToFind <= cch)
        {
            TConstantString prgwchToFind = rpairCandidate.GetPointer();
            TChar ch = prgwchToFind[0];
            TSizeT cchMax = (cch - cchToFind) + 1;

            for (i=0; i<cch; i++)
            {
                if (prgch[i] == ch)
                {
                    // Hmmm... a hit.  Let's look more.
                    if (BCL::IsMemoryEqual(&prgch[i], prgwchToFind, cchToFind * sizeof(TChar)))
                    {
                        // well done!
                        rfFound = true;
                        break;
                    }
                }
            }
        }
    }

    BCL_MAYFAIL_EPILOG_INTERNAL
}

template <typename TCallDisposition, typename TConstantPair, typename TMatcher>
inline
TCallDisposition
ContainsMatch(
    const TConstantPair &rpair,
    const TMatcher &rmatcher,
    bool &rfFound
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    rfFound = false;

    BCL_PARAMETER_CHECK(rpair.Valid());
    BCL_PARAMETER_CHECK(rpairCandidate.Valid());

    // There are some really good string searching algorithms out there.
    //
    // This isn't one of them.  -mgrier 2/3/2002

    TSizeT cch = rpair.GetCount();
    TSizeT i;
    TConstantString prgch = rpair.GetPointer();

    for (i=0; i<cch; i++)
    {
        bool fFound; // use a local so optimizer isn't forced to modify via ref every iteration
        BCL_IFCALLFAILED_EXIT(rmatcher.Match(&prgch[i], fFound));
        if (fFound)
        {
            rfFound = true;
            break;
        }
    }

    BCL_MAYFAIL_EPILOG_INTERNAL
}

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
__fastcall
Span(
    const TConstantPair &rpairBuffer,
    const TConstantPair &rpairSet,
    typename TConstantPair::TCount &rich
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    TSizeT i;
    TSizeT cchBuffer = rpairBuffer.GetCount();
    TConstantString prgwchBuffer = rpairBuffer.GetPointer();
    bool fFound;

    for (i=0; i<cchBuffer; i++)
    {
        BCL_IFCALLFAILED_EXIT((BCL::Contains<TCallDisposition, TConstantPair>(rpairSet, prgwchBuffer[i], fFound)));
        if (!fFound)
            break;
    }

    rich = i;

    BCL_MAYFAIL_EPILOG_INTERNAL
}

template <typename TCallDisposition, typename TConstantPair, typename TMatcher>
inline
TCallDisposition
__fastcall
SpanMatch(
    const TConstantPair &rpairBuffer,
    const TMatcher &rmatcher,
    typename TConstantPair::TCount &rich
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    TSizeT i;
    TSizeT cchBuffer = rpairBuffer.GetCount();
    TConstantString prgwchBuffer = rpairBuffer.GetPointer();
    bool fFound;

    for (i=0; i<cchBuffer; i++)
    {
        BCL_IFCALLFAILED_EXIT(rmatcher.Match(rpairBuffer.GetOffsetPair(i), fFound));
        if (!fFound)
            break;
    }

    rich = i;

    BCL_MAYFAIL_EPILOG_INTERNAL
}

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
__fastcall
ComplementSpan(
    const TConstantPair &rpairBuffer,
    const TConstantPair &rpairSet,
    typename TConstantPair::TCount &rich
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    TSizeT i;
    TSizeT cchBuffer = rpairBuffer.GetCount();
    TConstantString prgwchBuffer = rpairBuffer.GetPointer();
    bool fFound;

    // This does not handle surrogates correctly

    for (i=0; i<cchBuffer; i++)
    {
        BCL_IFCALLFAILED_EXIT((BCL::Contains<TCallDisposition, TConstantPair>(rpairSet, prgwchBuffer[i], fFound)));
        if (fFound)
            break;
    }

    rich = i;

    BCL_MAYFAIL_EPILOG_INTERNAL
}

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
__fastcall
ReverseSpan(
    const TConstantPair &rpairBuffer,
    const TConstantPair &rpairSet,
    typename TConstantPair::TCount &rich
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    TSizeT i;
    TSizeT cchBuffer = rpairBuffer.GetCount();
    TConstantString prgwchBuffer = rpairBuffer.GetPointer();
    bool fFound;

    // This does not handle surrogates correctly

    for (i = cchBuffer; i>0; i--)
    {
        BCL_IFCALLFAILED_EXIT((BCL::Contains<TCallDisposition, TConstantPair>(rpairSet, prgwchBuffer[i-1], fFound)));
        if (!fFound)
            break;
    }

    rich = i;

    BCL_MAYFAIL_EPILOG_INTERNAL
}

template <typename TCallDisposition, typename TConstantPair>
inline
TCallDisposition
__fastcall
ReverseComplementSpan(
    const TConstantPair &rpairBuffer,
    const TConstantPair &rpairSet,
    typename TConstantPair::TCount &rich
    )
{
    typedef typename TConstantPair::TPointee TChar;
    typedef typename TConstantPair::TCount TSizeT;
    typedef typename TConstantPair::TConstantArray TConstantString;

    BCL_MAYFAIL_PROLOG

    TSizeT i;
    TSizeT cchBuffer = rpairBuffer.GetCount();
    TConstantString prgwchBuffer = rpairBuffer.GetPointer();
    bool fFound;

    // This does not handle surrogates correctly

    for (i = cchBuffer; i>0; i--)
    {
        BCL_IFCALLFAILED_EXIT((BCL::Contains<TCallDisposition, TConstantPair>(rpairSet, prgwchBuffer[i], fFound)));
        if (fFound)
            break;
    }

    rich = i;

    BCL_MAYFAIL_EPILOG_INTERNAL
}

}; // namespace BCL

#endif // !defined(_WINDOWS_BCL_STRINGALGORITHMS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_w32common.h ===
#if !defined(_BCL_W32COMMON_H_INCLUDED_)
#define _BCL_W32COMMON_H_INCLUDED_

#pragma once

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>

namespace BCL
{

class CWin32CaseInsensitivityData
{
public:
    inline CWin32CaseInsensitivityData(LCID lcid = LOCALE_INVARIANT, DWORD dwCmpFlags = NORM_IGNORECASE) : m_lcid(lcid), m_dwCmpFlags(dwCmpFlags) { }
    inline CWin32CaseInsensitivityData(const CWin32CaseInsensitivityData &r) : m_lcid(r.m_lcid), m_dwCmpFlags(r.m_dwCmpFlags) { }
    inline CWin32CaseInsensitivityData &operator =(const CWin32CaseInsensitivityData &r) { m_lcid = r.m_lcid; m_dwCmpFlags = r.m_dwCmpFlags; return *this; }
    inline ~CWin32CaseInsensitivityData() { }

    static inline CWin32CaseInsensitivityData LocaleInvariant() { return CWin32CaseInsensitivityData(LOCALE_INVARIANT, NORM_IGNORECASE); }

    LCID m_lcid;
    DWORD m_dwCmpFlags;
}; // class CWin32CaseInsensitivityData

class CWin32StringComparisonResult
{
public:
    inline void SetLessThan() { m_iComparisonResult = CSTR_LESS_THAN; }
    inline bool IsLessThan() const { return m_iComparisonResult == CSTR_LESS_THAN; }
    inline static CWin32StringComparisonResult LessThan() { CWin32StringComparisonResult cr; cr.m_iComparisonResult = CSTR_LESS_THAN; return cr; }

    inline void SetEqualTo() { m_iComparisonResult = CSTR_EQUAL; }
    inline bool IsEqualTo() const { return m_iComparisonResult == CSTR_EQUAL; }
    inline static CWin32StringComparisonResult EqualTo() { CWin32StringComparisonResult cr; cr.m_iComparisonResult = CSTR_EQUAL; return cr; }

    inline void SetGreaterThan() { m_iComparisonResult = CSTR_GREATER_THAN; }
    inline bool IsGreaterThan() const { return m_iComparisonResult == CSTR_GREATER_THAN; }
    inline static CWin32StringComparisonResult GreaterThan() { CWin32StringComparisonResult cr; cr.m_iComparisonResult = CSTR_GREATER_THAN; return cr; }

    int m_iComparisonResult;
};

// For CWin32UnicodeToMBCSDataIn, think of the input parameters to WideCharToMultiByte
class CWin32UnicodeToMBCSDataIn
{
public:
    UINT m_CodePage;
    DWORD m_dwFlags;
};

// For CWin32UnicodeToMBCSDataOut, think of the output parameters from WideCharToMultiByte
class CWin32UnicodeToMBCSDataOut
{
public:
    PCSTR m_lpDefaultChar;
    LPBOOL m_lpUsedDefaultChar;
};

// For CWin32MBCSToUnicodeDataIn, think of the input parameters to MultiByteToWideChar
class CWin32MBCSToUnicodeDataIn
{
public:
    UINT m_CodePage;
    DWORD m_dwFlags;
};

// For CWin32MBCSToUnicodeDataOut, think of the output parameters from MultiByteToWideChar
class CWin32MBCSToUnicodeDataOut
{
public:
    // Nothing!
};

class CWin32StringComparisonResultOnExitHelper : public CWin32StringComparisonResult
{
public:
    inline CWin32StringComparisonResultOnExitHelper(int &riComparisonResult) : m_riComparisonResult(riComparisonResult) { }
    inline ~CWin32StringComparisonResultOnExitHelper() { m_riComparisonResult = m_iComparisonResult; }

    CWin32StringComparisonResultOnExitHelper& operator=(const CWin32StringComparisonResultOnExitHelper& o) { if (this != &o) { this->m_iComparisonResult = o.m_iComparisonResult; } return *this; }

protected:
    int &m_riComparisonResult;
};

class CWin32CallDisposition
{
public:
    inline bool DidFail() const { return m_dwWin32Error != ERROR_SUCCESS; }
    inline bool DidSucceed() const { return m_dwWin32Error == ERROR_SUCCESS; }

    inline void SetSuccess() { m_dwWin32Error = ERROR_SUCCESS; }
    inline void SetArithmeticOverflow() { m_dwWin32Error = ERROR_ARITHMETIC_OVERFLOW; }
    inline void SetArithmeticUnderflow() { m_dwWin32Error = ERROR_ARITHMETIC_OVERFLOW; }
    inline void SetInternalError_ObjectLocked() { m_dwWin32Error = ERROR_INTERNAL_ERROR; }
    inline void SetInternalError_RuntimeCheck() { m_dwWin32Error = ERROR_INTERNAL_ERROR; }
    inline void SetInternalError_EpilogSkipped() { m_dwWin32Error = ERROR_INTERNAL_ERROR; }
    inline void SetBadParameter() { m_dwWin32Error = ERROR_INVALID_PARAMETER; }
    inline void SetBufferOverflow() { m_dwWin32Error = ERROR_BUFFER_OVERFLOW; }
    inline void SetOutOfMemory() { m_dwWin32Error = ERROR_OUTOFMEMORY; }

    inline static CWin32CallDisposition Success() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_SUCCESS; return t; }
    inline static CWin32CallDisposition ArithmeticOverflow() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_ARITHMETIC_OVERFLOW; return t; }
    inline static CWin32CallDisposition ArithmeticUnderflow() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_ARITHMETIC_OVERFLOW; return t; }
    inline static CWin32CallDisposition InternalError_ObjectLocked() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_INTERNAL_ERROR; return t; }
    inline static CWin32CallDisposition InternalError_RuntimeCheck() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_INTERNAL_ERROR; return t; }
    inline static CWin32CallDisposition InternalError_EpilogSkipped() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_INTERNAL_ERROR; return t; }
    inline static CWin32CallDisposition BadParameter() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_INVALID_PARAMETER; return t; }
    inline static CWin32CallDisposition BufferOverflow() { CWin32CallDisposition t; t.m_dwWin32Error =  ERROR_BUFFER_OVERFLOW; return t; }
    inline static CWin32CallDisposition OutOfMemory() { CWin32CallDisposition t; t.m_dwWin32Error = ERROR_OUTOFMEMORY; return t; }
    inline static CWin32CallDisposition FromLastError() { CWin32CallDisposition t; t.m_dwWin32Error = ::GetLastError(); return t; }

    inline static CWin32CallDisposition FromWin32Error(DWORD dwWin32Error) { CWin32CallDisposition t; t.m_dwWin32Error = dwWin32Error; return t; }

    inline BOOL OnPublicReturn() const { if (m_dwWin32Error != ERROR_SUCCESS) ::SetLastError(m_dwWin32Error); return (m_dwWin32Error == ERROR_SUCCESS); }
protected:
    DWORD m_dwWin32Error;
};

class CWin32PWSTRAllocationHelper
{
    typedef CWin32CallDisposition TCallDisposition;

public:
    CWin32PWSTRAllocationHelper() : m_pwstr(NULL) { }
    ~CWin32PWSTRAllocationHelper() { if (m_pwstr != NULL) { ::HeapFree(::GetProcessHeap(), 0, m_pwstr); m_pwstr = NULL; } }

    CWin32CallDisposition Allocate(SIZE_T cch)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T cb;

        if (m_pwstr != NULL)
            BCL_ORIGINATE_ERROR(CWin32CallDisposition::InternalError_RuntimeCheck());

        cb = cch * sizeof(WCHAR);
        if ((cb / sizeof(WCHAR)) != cch)
            BCL_ORIGINATE_ERROR(CWin32CallDisposition::ArithmeticOverflow());

        m_pwstr = reinterpret_cast<PWSTR>(::HeapAlloc(::GetProcessHeap(), 0, cb));
        if (m_pwstr == NULL)
            BCL_ORIGINATE_ERROR(CWin32CallDisposition::OutOfMemory());

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    PWSTR Detach() { PWSTR pszResult = m_pwstr; m_pwstr = NULL; return pszResult; }

    operator PWSTR() const { return m_pwstr; }

private:
    PWSTR m_pwstr;
};

class CWin32PSTRAllocationHelper
{
    typedef CWin32CallDisposition TCallDisposition;

public:
    CWin32PSTRAllocationHelper() : m_pstr(NULL) { }
    ~CWin32PSTRAllocationHelper() { if (m_pstr != NULL) { ::HeapFree(::GetProcessHeap(), 0, m_pstr); m_pstr = NULL; } }

    CWin32CallDisposition Allocate(SIZE_T cch)
    {
        BCL_MAYFAIL_PROLOG

        if (m_pstr != NULL)
            BCL_ORIGINATE_ERROR(CWin32CallDisposition::InternalError_RuntimeCheck());

        m_pstr = reinterpret_cast<PSTR>(::HeapAlloc(::GetProcessHeap(), 0, cch));
        if (m_pstr == NULL)
            BCL_ORIGINATE_ERROR(CWin32CallDisposition::OutOfMemory());

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    PSTR Detach() { PSTR pszResult = m_pstr; m_pstr = NULL; return pszResult; }

    operator PSTR() const { return m_pstr; }

private:
    PSTR m_pstr;
};


}; // namespace BCL

#endif // !defined(_BCL_W32COMMON_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_w32baseunicodestringbuffer.h ===
#if !defined(_BCL_W32BASEUNICODESTRINGBUFFER_H_INCLUDED_)
#define _BCL_W32BASEUNICODESTRINGBUFFER_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_w32baseunicodestringbuffer.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_vararg.h>
#include <bcl_w32unicodestringalgorithms.h>

#include <limits.h>

namespace BCL
{

template <typename TBuffer, typename TCallDispositionT, typename TPublicErrorReturnTypeT>
class CWin32BaseUnicodeStringBufferTraits : public BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>, public BCL::CWin32NullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>
{
public:
    typedef CWin32BaseUnicodeStringBufferTraits TThis;

    friend BCL::CPureString<TThis>;
    friend BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>;
    typedef BCL::CPureString<TThis> TPureString;

    typedef TCallDispositionT TCallDisposition;
    typedef TPublicErrorReturnTypeT TPublicErrorReturnType;

    typedef CWin32StringComparisonResult TComparisonResult;

    typedef BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> TConstantPair;
    typedef BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> TMutablePair;

    typedef CWin32CaseInsensitivityData TCaseInsensitivityData;
    typedef SIZE_T TSizeT;

    typedef CWin32MBCSToUnicodeDataIn TDecodingDataIn;
    typedef CWin32MBCSToUnicodeDataOut TDecodingDataOut;
    typedef CWin32UnicodeToMBCSDataIn TEncodingDataIn;
    typedef CWin32UnicodeToMBCSDataOut TEncodingDataOut;

    typedef CConstantPointerAndCountPair<CHAR, SIZE_T> TConstantNonNativePair;
    typedef CMutablePointerAndCountPair<CHAR, SIZE_T> TMutableNonNativePair;

    typedef BCL::CWin32PWSTRAllocationHelper TPWSTRAllocationHelper;
    typedef BCL::CWin32PSTRAllocationHelper TPSTRAllocationHelper;

    using BCL::CWin32NullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TMutableString;
    using BCL::CWin32NullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TConstantString;
    using BCL::CWin32NullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TMutableNonNativeString;
    using BCL::CWin32NullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::TConstantNonNativeString;

    // exposing the things from our private base class
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::CopyIntoBuffer;
    using BCL::CWin32NullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::CopyIntoBuffer;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::DetermineRequiredCharacters;
    using BCL::CWin32NullTerminatedUnicodeStringAlgorithms<TBuffer, TCallDispositionT>::DetermineRequiredCharacters;
#if 0
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::CopyIntoBuffer;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::NullCharacter;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::IsNullCharacter;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::StringCchLegal;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::TrimStringLengthToLegalCharacters;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::AddWithOverflowCheck;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::SubtractWithUnderflowCheck;
    using BCL::CUnicodeCharTraits<TBuffer, TCallDispositionT>::EqualStrings;
#endif // 0

    static inline TMutablePair & __fastcall MutableBufferPair(BCL::CBaseString *p) { return static_cast<TBuffer *>(p)->m_pair; }
    static inline const TConstantPair & __fastcall BufferPair(const BCL::CBaseString *p) { return static_cast<const TConstantPair &>(static_cast<const TBuffer *>(p)->m_pair); }
    static inline TConstantPair __fastcall GetStringPair(const BCL::CBaseString *p) { return TConstantPair(TBuffer::TTraits::GetBufferPtr(p), TBuffer::TTraits::GetStringCch(p)); }
    static inline TMutablePair __fastcall GetOffsetMutableBufferPair(const BCL::CBaseString *p, TSizeT cchOffset) { BCL_ASSERT(cchOffset <= TBuffer::TTraits::GetBufferCch(p)); if (cchOffset > TBuffer::TTraits::GetBufferCch(p)) cchOffset = TBuffer::TTraits::GetBufferCch(p); return TMutablePair(const_cast<TMutableString>(TBuffer::TTraits::GetBufferPtr(p)) + cchOffset, TBuffer::TTraits::GetBufferCch(p) - cchOffset); }

    static inline bool __fastcall AnyAccessors(const BCL::CBaseString *p) { return (static_cast<const TBuffer *>(p)->m_cAttachedAccessors != 0); }
    static inline bool __fastcall NoAccessors(const BCL::CBaseString *p) { return (static_cast<const TBuffer *>(p)->m_cAttachedAccessors == 0); }
    static inline TCallDisposition __fastcall NoAccessorsCheck(const BCL::CBaseString *p) { if (TBuffer::TTraits::AnyAccessors(p)) { return TCallDisposition::InternalError_ObjectLocked(); } return TCallDisposition::Success(); }

    static inline PCWSTR __fastcall GetBufferPtr(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->m_pair.GetPointer(); }
    static inline PWSTR __fastcall GetMutableBufferPtr(BCL::CBaseString *p) { return static_cast<TBuffer *>(p)->m_pair.GetPointer(); }
    static inline SIZE_T __fastcall GetBufferCch(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->m_pair.GetCount(); }
    static inline void __fastcall SetBufferPointerAndCount(BCL::CBaseString *p, PWSTR pszBuffer, SIZE_T cchBuffer) { static_cast<TBuffer *>(p)->m_pair.SetPointerAndCount(pszBuffer, cchBuffer); }

    static inline SIZE_T __fastcall GetStringCch(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->m_cchString; }

    static inline void _fastcall SetStringCch(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_ASSERT((cch == 0) || (cch < TBuffer::TTraits::GetBufferCch(p)));
        static_cast<TBuffer *>(p)->m_cchString = cch;
        if (TBuffer::TTraits::GetBufferCch(p) != 0)
            TBuffer::TTraits::GetMutableBufferPtr(p)[cch] = L'\0';
    }

    static inline void __fastcall IntegrityCheck(const BCL::CBaseString *p) { }
    static inline PWSTR __fastcall GetInlineBufferPtr(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->GetInlineBufferPtr(); }
    static inline SIZE_T __fastcall GetInlineBufferCch(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->GetInlineBufferCch(); }

    static inline TCallDisposition __fastcall ReallocateBuffer(BCL::CBaseString *p, SIZE_T cch)
    {
        PWSTR psz = NULL;
        SIZE_T cb = (cch * sizeof(WCHAR));
        TBuffer *pBuffer = static_cast<TBuffer *>(p);

        if (cch != (cb / sizeof(WCHAR)))
            return TCallDisposition::ArithmeticOverflow();

        if (pBuffer->GetBufferPtr() != NULL)
        {
            ::SetLastError(ERROR_SUCCESS);

            psz = 
                reinterpret_cast<PWSTR>(
                    ::HeapReAlloc(
                        ::GetProcessHeap(),
                        0,
                        const_cast<PWSTR>(pBuffer->GetBufferPtr()),
                        cb));
            if (psz == NULL)
            {
                const DWORD dwLastError = ::GetLastError();
                // HeapReAlloc doesn't always set last error, so we rely on this
                // fact to find that the win32 last error hasn't changed from
                // before to infer ERROR_OUTOFMEMORY.  -mgrier 2/2/2002
                if (dwLastError == ERROR_SUCCESS)
                    return TCallDisposition::OutOfMemory();
                return TCallDisposition::FromWin32Error(dwLastError);
            }
        }
        else
        {
            psz = 
                reinterpret_cast<PWSTR>(
                    ::HeapAlloc(
                        ::GetProcessHeap(),
                        0,
                        cb));
        }

        if (psz == NULL)
            return TCallDisposition::OutOfMemory();

        pBuffer->SetBufferPointerAndCount(psz, cch);

        return TCallDisposition::Success();
    }

    static inline void __fastcall DeallocateBuffer(PCWSTR psz) { if (psz != NULL) ::HeapFree(::GetProcessHeap(), 0, reinterpret_cast<PVOID>(const_cast<PWSTR>(psz))); }

    static inline void __fastcall DeallocateDynamicBuffer(BCL::CBaseString *p) { static_cast<TBuffer *>(p)->DeallocateDynamicBuffer(); }

}; // class CWin32BaseUnicodeStringBufferTraits

class CWin32BaseUnicodeStringBufferAddIn
{
protected:
    inline CWin32BaseUnicodeStringBufferAddIn(PWSTR pszInitialBuffer, SIZE_T cchInitialBuffer) : m_pair(pszInitialBuffer, cchInitialBuffer), m_cchString(0), m_cAttachedAccessors(0) { }

    inline static BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> PairFromPCWSTR(PCWSTR psz) { return BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T>(psz, (psz == NULL) ? 0 : wcslen(psz)); }
    inline static BCL::CConstantPointerAndCountPair<CHAR, SIZE_T> PairFromPCSTR(PCSTR psz) { return BCL::CConstantPointerAndCountPair<CHAR, SIZE_T>(psz, (psz == NULL) ? 0 : strlen(psz)); }
    inline static CWin32MBCSToUnicodeDataIn ACPDecodingDataIn() { CWin32MBCSToUnicodeDataIn t; t.m_CodePage = CP_ACP; t.m_dwFlags = MB_PRECOMPOSED | MB_ERR_INVALID_CHARS; return t; }
    inline static CWin32UnicodeToMBCSDataIn ACPEncodingDataIn() { CWin32UnicodeToMBCSDataIn t; t.m_CodePage = CP_ACP; t.m_dwFlags = WC_NO_BEST_FIT_CHARS; return t; }

    BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> m_pair;
    SIZE_T m_cchString;
    LONG m_cAttachedAccessors;
};

}; // namespace BCL

#endif // !defined(_BCL_W32BASEUNICODESTRINGBUFFER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_w32pathalgorithms.h ===
#if !defined(_BCL_W32PATHALGORITHMS_H_INCLUDED_)
#define _BCL_W32PATHALGORITHMS_H_INCLUDED_

#pragma once

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_w32baseunicodestringbuffer.h>

namespace BCL
{
    BOOL 
}; // namespace BCL

#endif // !defined(_BCL_W32PATHALGORITHMS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_stringapi.h ===
//
//  This is just a simple header to have all the public API functions for the
// win32 flavor string APIs so that we don't have to modify all "n" of them each
// time we revise a pattern.
//

//
//  Crib sheet for abbreviations:
//
//  Va = varags; takes a va_list
//  ACP = CP_ACP - ANSI code page; any NonNative strings are automatically interpreted as CP_ACP
//  OCMCP = CP_OEMCP. Same as ACP but for the OEM code page
//  UTF8 = CP_UTF8.  Ditto
//  I = case independent.  To follow shlwapi/crtl convention.  To modify behavior,
//          pass a CWin32CaseInsensitivityData object with appropriate additional
//          flags added.  (Everything goes through CompareStringW for behavior
//          reference.)
//  ILI = Locale Invariant.  For locale-sensitive operations like comparisons, this
//          qualifier indicates that the comparison should be done using the
//          invariant locale.
//  IILI = Case Independent Locale Invariant.  For locale-sensitive operations
//          like comparisons, this qualifier indicates that the comparison is be done
//          using the invariant locale with appropriate case ignoring switches set.
//


inline TPublicErrorReturnType Assign(const TThis& source) { return __super::public_Assign(source.GetStringPair()); }
inline TPublicErrorReturnType Assign(PCWSTR psz, SIZE_T cch) { return __super::public_Assign(TConstantPair(psz, cch)); }
inline TPublicErrorReturnType Assign(PCWSTR psz) { return __super::public_Assign(this->PairFromPCWSTR(psz)); }
inline TPublicErrorReturnType Assign(WCHAR wch) { return __super::public_Assign(wch); }
inline TPublicErrorReturnType Assign(SIZE_T cStrings, ...) { BCL::CVaList ap(cStrings); return __super::public_AssignVa(L"", cStrings, ap); }
inline TPublicErrorReturnType Assign(const TConstantPair &Pair) { return __super::public_Assign(Pair); };
inline TPublicErrorReturnType AssignArray(SIZE_T cStrings, const TMutablePair *prgpairs) { return __super::public_AssignArray(cStrings, prgpairs); }
inline TPublicErrorReturnType AssignArray(SIZE_T cStrings, const TConstantPair *prgpairs) { return __super::public_AssignArray(cStrings, prgpairs); }
inline TPublicErrorReturnType Assign(const TDecodingDataIn &rddi, PCSTR pszInput, SIZE_T cchInput, TDecodingDataOut &rddo) { return __super::public_Assign(rddi, TConstantNonNativePair(pszInput, cchInput), rddo); }
inline TPublicErrorReturnType Assign(const TDecodingDataIn &rddi, PCSTR pszInput, TDecodingDataOut &rddo) { return __super::public_Assign(rddi, this->PairFromPCSTR(pszInput), rddo); }
inline TPublicErrorReturnType AssignACP(PCSTR pszInput, SIZE_T cchInput) { TDecodingDataOut ddoTemp; return __super::public_Assign(this->ACPDecodingDataIn(), TConstantNonNativePair(pszInput, cchInput), ddoTemp); }
inline TPublicErrorReturnType AssignACP(PCSTR pszInput) { TDecodingDataOut ddoTemp; return __super::public_Assign(this->ACPDecodingDataIn(), this->PairFromPCSTR(pszInput), ddoTemp); }
inline TPublicErrorReturnType AssignFill(PCWSTR pszInput, SIZE_T cchInput, SIZE_T cchResult, SIZE_T &rcchExtra) { return __super::public_AssignFill(TConstantPair(pszInput, cchInput), cchResult, rcchExtra); }
inline TPublicErrorReturnType AssignFill(PCWSTR pszInput, SIZE_T cchResult, SIZE_T &rcchExtra) { return __super::public_AssignFill(this->PairFromPCWSTR(pszInput), cchResult, rcchExtra); }
inline TPublicErrorReturnType AssignFill(WCHAR wch, SIZE_T cchResult, SIZE_T &rcchExtra) { return __super::public_AssignFill(wch, cchResult, rcchExtra); }
inline TPublicErrorReturnType AssignRepeat(PCWSTR pszInput, SIZE_T cchInput, SIZE_T cRepetitions) { return __super::public_AssignRepeat(TConstantPair(pszInput, cchInput), cRepetitions); }
inline TPublicErrorReturnType AssignRepeat(PCWSTR pszInput, SIZE_T cRepetitions) { return __super::public_AssignRepeat(this->PairFromPCWSTR(pszInput), cRepetitions); }
inline TPublicErrorReturnType AssignRepeat(WCHAR wch, SIZE_T cRepetitions) { return __super::public_AssignRepeat(wch, cRepetitions); }
inline TPublicErrorReturnType AssignVa(SIZE_T cStrings, va_list ap) { return __super::public_AssignVa(L"", cStrings, ap); }
inline TPublicErrorReturnType Append(const TThis &str) { return __super::public_Append(str.GetStringPair()); }
inline TPublicErrorReturnType Append(const TConstantPair &Pair) { return __super::public_Append(Pair); }
inline TPublicErrorReturnType Append(PCWSTR psz, SIZE_T cch) { return __super::public_Append(TConstantPair(psz, cch)); }
inline TPublicErrorReturnType Append(PCWSTR psz) { return __super::public_Append(this->PairFromPCWSTR(psz)); }
inline TPublicErrorReturnType Append(WCHAR wch) { return __super::public_Append(wch); }
inline TPublicErrorReturnType AppendArray(SIZE_T cStrings, const TMutablePair *prgpairs) { return __super::public_AppendArray(cStrings, prgpairs); }
inline TPublicErrorReturnType AppendArray(SIZE_T cStrings, const TConstantPair *prgpairs) { return __super::public_AppendArray(cStrings, prgpairs); }
inline TPublicErrorReturnType Append(const TDecodingDataIn &rddi, PCSTR pszInput, SIZE_T cchInput, TDecodingDataOut &rddo) { return __super::public_Append(rddi, TConstantNonNativePair(pszInput, cchInput), rddo); }
inline TPublicErrorReturnType Append(const TDecodingDataIn &rddi, PCSTR pszInput, TDecodingDataOut &rddo) { return __super::public_Append(rddi, this->PairFromPCSTR(pszInput), rddo); }
inline TPublicErrorReturnType AppendACP(PCSTR pszInput, SIZE_T cchInput) { TDecodingDataOut ddoTemp; return __super::public_Append(this->ACPDecodingDataIn(), TConstantNonNativePair(pszInput, cchInput), ddoTemp); }
inline TPublicErrorReturnType AppendACP(PCSTR pszInput) { TDecodingDataOut ddoTemp; return __super::public_Append(this->ACPDecodingDataIn(), this->PairFromPCSTR(pszInput), ddoTemp); }
inline TPublicErrorReturnType AppendFill(PCWSTR pszInput, SIZE_T cchInput, SIZE_T cchResult, SIZE_T &rcchExtra) { return __super::public_AppendFill(TConstantPair(pszInput, cchInput), cchResult, rcchExtra); }
inline TPublicErrorReturnType AppendFill(PCWSTR pszInput, SIZE_T cchResult, SIZE_T &rcchExtra) { return __super::public_AppendFill(this->PairFromPCWSTR(pszInput), cchResult, rcchExtra); }
inline TPublicErrorReturnType AppendFill(WCHAR wch, SIZE_T cchResult, SIZE_T &rcchExtra) { return __super::public_AppendFill(wch, cchResult, rcchExtra); }
inline TPublicErrorReturnType AppendRepeat(PCWSTR pszInput, SIZE_T cchInput, SIZE_T cRepetitions) { return __super::public_AppendRepeat(TConstantPair(pszInput, cchInput), cRepetitions); }
inline TPublicErrorReturnType AppendRepeat(PCWSTR pszInput, SIZE_T cRepetitions) { return __super::public_AppendRepeat(this->PairFromPCWSTR(pszInput), cRepetitions); }
inline TPublicErrorReturnType AppendRepeat(WCHAR wch, SIZE_T cRepetitions) { return __super::public_AppendRepeat(wch, cRepetitions); }
inline void Clear(bool fFreeStorage = false) { __super::public_Clear(fFreeStorage); }
inline TPublicErrorReturnType Compare(const TThis &sz, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_Compare(sz.GetStringPair(), cr); }
inline TPublicErrorReturnType Compare(const TConstantPair &sz, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_Compare(sz, cr); }
inline TPublicErrorReturnType Compare(PCWSTR psz, SIZE_T cch, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_Compare(TConstantPair(psz, cch), cr); }
inline TPublicErrorReturnType Compare(PCWSTR psz, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_Compare(this->PairFromPCWSTR(psz), cr); }
inline TPublicErrorReturnType Compare(WCHAR wch, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_Compare(wch, cr); }
inline TPublicErrorReturnType CompareI(const TConstantPair &sz, const CWin32CaseInsensitivityData &rcid, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(sz, rcid, cr); }
inline TPublicErrorReturnType CompareI(const TThis &sz, const CWin32CaseInsensitivityData &rcid, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(sz.GetStringPair(), rcid, cr); }
inline TPublicErrorReturnType CompareI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(TConstantPair(psz, cch), rcid, cr); }
inline TPublicErrorReturnType CompareI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(this->PairFromPCWSTR(psz), rcid, cr); }
inline TPublicErrorReturnType CompareI(WCHAR wch, const CWin32CaseInsensitivityData &rcid, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(wch, rcid, cr); }
inline TPublicErrorReturnType CompareILI(const TThis& sz, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(sz.GetStringPair(), CWin32CaseInsensitivityData::LocaleInvariant(), cr); }
inline TPublicErrorReturnType CompareILI(const TConstantPair& sz, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(sz, CWin32CaseInsensitivityData::LocaleInvariant(), cr); }
inline TPublicErrorReturnType CompareILI(PCWSTR psz, SIZE_T cch, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), cr); }
inline TPublicErrorReturnType CompareILI(PCWSTR psz, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), cr); }
inline TPublicErrorReturnType CompareILI(WCHAR wch, int &riComparisonResult) const { CWin32StringComparisonResultOnExitHelper cr(riComparisonResult); return __super::public_CompareI(wch, CWin32CaseInsensitivityData::LocaleInvariant(), cr); }
inline TPublicErrorReturnType ComplementSpan(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_ComplementSpan(TConstantPair(psz, cch), rich); }
inline TPublicErrorReturnType ComplementSpan(PCWSTR psz, SIZE_T &rich) { return __super::public_ComplementSpan(this->PairFromPCWSTR(psz), rich); }
inline TPublicErrorReturnType ComplementSpanI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_ComplementSpanI(TConstantPair(psz, cch), rcid, rich); }
inline TPublicErrorReturnType ComplementSpanI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_ComplementSpanI(this->PairFromPCWSTR(psz), rcid, rich); }
inline TPublicErrorReturnType ComplementSpanILI(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_ComplementSpanI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType ComplementSpanILI(PCWSTR psz, SIZE_T &rich) { return __super::public_ComplementSpanI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType Contains(const TThis & psz, bool &rfContains) const { return __super::public_Contains(psz.GetStringPair(), rfContains); }
inline TPublicErrorReturnType Contains(const TConstantPair & psz, bool &rfContains) const { return __super::public_Contains(psz, rfContains); }
inline TPublicErrorReturnType Contains(PCWSTR psz, SIZE_T cch, bool &rfContains) const { return __super::public_Contains(TConstantPair(psz, cch), rfContains); }
inline TPublicErrorReturnType Contains(PCWSTR psz, bool &rfContains) const { return __super::public_Contains(this->PairFromPCWSTR(psz), rfContains); }
inline TPublicErrorReturnType Contains(WCHAR wch, bool &rfContains) const { return __super::public_Contains(wch, rfContains); }
inline TPublicErrorReturnType ContainsI(const TConstantPair & psz, const CWin32CaseInsensitivityData &rcid, bool &rfContains) const { return __super::public_ContainsI(psz, rcid, rfContains); }
inline TPublicErrorReturnType ContainsI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, bool &rfContains) const { return __super::public_ContainsI(TConstantPair(psz, cch), rcid, rfContains); }
inline TPublicErrorReturnType ContainsI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, bool &rfContains) const { return __super::public_ContainsI(this->PairFromPCWSTR(psz), rcid, rfContains); }
inline TPublicErrorReturnType ContainsI(WCHAR wch, const CWin32CaseInsensitivityData &rcid, bool &rfContains) const { return __super::public_ContainsI(wch, rcid, rfContains); }
inline TPublicErrorReturnType ContainsILI(const TConstantPair &psz, bool &rfContains) const { return __super::public_ContainsI(psz, BCL::CWin32CaseInsensitivityData::LocaleInvariant(), rfContains); }
inline TPublicErrorReturnType ContainsILI(PCWSTR psz, SIZE_T cch, bool &rfContains) const { return __super::public_ContainsI(TConstantPair(psz, cch), BCL::CWin32CaseInsensitivityData::LocaleInvariant(), rfContains); }
inline TPublicErrorReturnType ContainsILI(PCWSTR psz, bool &rfContains) const { return __super::public_ContainsI(this->PairFromPCWSTR(psz), BCL::CWin32CaseInsensitivityData::LocaleInvariant(), rfContains); }
inline TPublicErrorReturnType ContainsILI(WCHAR wch, bool &rfContains) const { return __super::public_ContainsI(wch, BCL::CWin32CaseInsensitivityData::LocaleInvariant(), rfContains); }
inline TPublicErrorReturnType CopyOut(WCHAR *prgwchBuffer, SIZE_T cchBuffer, SIZE_T &rcchWritten) const { return __super::public_CopyOut(TMutablePair(prgwchBuffer, cchBuffer), rcchWritten); }
inline TPublicErrorReturnType CopyOut(WCHAR *&rprgwchBuffer, SIZE_T &rcchWritten) const { return __super::public_CopyOut(rprgwchBuffer, rcchWritten); }
inline TPublicErrorReturnType CopyOut(const TEncodingDataIn &redi, CHAR *prgchBuffer, SIZE_T cchBuffer, TEncodingDataOut &redo, SIZE_T &rcchWritten) const { return __super::public_CopyOut(redi, TMutableNonNativePair(prgchBuffer, cchBuffer), redo, rcchWritten); }
inline TPublicErrorReturnType CopyOut(const TEncodingDataIn &redi, CHAR *&rprgchBuffer, TEncodingDataOut &redo, SIZE_T &rcchWritten) const { return __super::public_CopyOut(redi, rprgchBuffer, redo, rcchWritten); }
inline TPublicErrorReturnType CopyOutACP(CHAR *prgchBuffer, SIZE_T cchBuffer, SIZE_T &rcchWritten) const { TEncodingDataOut edoTemp; edoTemp.m_lpDefaultChar = NULL; edoTemp.m_lpUsedDefaultChar = NULL; return __super::public_CopyOut(this->ACPEncodingDataIn(), TMutableNonNativePair(prgchBuffer, cchBuffer), edoTemp, rcchWritten); }
inline TPublicErrorReturnType CopyOutACP(CHAR *&rprgchBuffer, SIZE_T &rcchWritten) const { TEncodingDataOut edoTemp; edoTemp.m_lpDefaultChar = NULL; edoTemp.m_lpUsedDefaultChar = NULL; return __super::public_CopyOut(this->ACPEncodingDataIn(), rprgchBuffer, edoTemp, rcchWritten); }
inline TPublicErrorReturnType Count(WCHAR wchCharacter, SIZE_T &rcchCount) const { return __super::public_Count(wchCharacter, rcchCount); }
inline TPublicErrorReturnType Equals(const TThis &sz, bool &rfEquals) const { return __super::public_Equals(sz.GetStringPair(), rfEquals); }
inline TPublicErrorReturnType Equals(const TConstantPair &sz, bool &rfEquals) const { return __super::public_Equals(sz, rfEquals); }
inline TPublicErrorReturnType Equals(PCWSTR psz, SIZE_T cch, bool &rfEquals) const { return __super::public_Equals(TConstantPair(psz, cch), rfEquals); }
inline TPublicErrorReturnType Equals(PCWSTR psz, bool &rfEquals) const { return __super::public_Equals(this->PairFromPCWSTR(psz), rfEquals); }
inline TPublicErrorReturnType Equals(WCHAR wch, bool &rfEquals) const { return __super::public_Equals(wch, rfEquals); }
inline TPublicErrorReturnType EqualsI(const TThis& sz, const CWin32CaseInsensitivityData &rcid, bool &rfEquals) const { return __super::public_EqualsI(sz.GetStringPair(), rcid, rfEquals); }
inline TPublicErrorReturnType EqualsI(const TConstantPair& sz, const CWin32CaseInsensitivityData &rcid, bool &rfEquals) const { return __super::public_EqualsI(sz, rcid, rfEquals); }
inline TPublicErrorReturnType EqualsI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, bool &rfEquals) const { return __super::public_EqualsI(TConstantPair(psz, cch), rcid, rfEquals); }
inline TPublicErrorReturnType EqualsI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, bool &rfEquals) const { return __super::public_EqualsI(this->PairFromPCWSTR(psz), rcid, rfEquals); }
inline TPublicErrorReturnType EqualsI(WCHAR wch, const CWin32CaseInsensitivityData &rcid, bool &rfEquals) const { return __super::public_EqualsI(wch, rcid, rfEquals); }
inline TPublicErrorReturnType EqualsILI(const TThis& sz, bool &rfEquals) const { return __super::public_EqualsI(sz.GetStringPair(), CWin32CaseInsensitivityData::LocaleInvariant(), rfEquals); }
inline TPublicErrorReturnType EqualsILI(const TConstantPair& sz, bool &rfEquals) const { return __super::public_EqualsI(sz, CWin32CaseInsensitivityData::LocaleInvariant(), rfEquals); }
inline TPublicErrorReturnType EqualsILI(PCWSTR psz, SIZE_T cch, bool &rfEquals) const { return __super::public_EqualsI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), rfEquals); }
inline TPublicErrorReturnType EqualsILI(PCWSTR psz, bool &rfEquals) const { return __super::public_EqualsI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), rfEquals); }
inline TPublicErrorReturnType EqualsILI(WCHAR wch, bool &rfEquals) const { return __super::public_EqualsI(wch, CWin32CaseInsensitivityData::LocaleInvariant(), rfEquals); }
inline TPublicErrorReturnType FindFirst(const TConstantPair& Set, SIZE_T &rich) const { return __super::public_FindFirst(Set, rich); }
inline TPublicErrorReturnType FindFirst(PCWSTR psz, SIZE_T cch, SIZE_T &rich) const { return __super::public_FindFirst(TConstantPair(psz, cch), rich); }
inline TPublicErrorReturnType FindFirst(PCWSTR psz, SIZE_T &rich) const { return __super::public_FindFirst(this->PairFromPCWSTR(psz), rich); }
inline TPublicErrorReturnType FindFirst(WCHAR wch, SIZE_T &rich) const { return __super::public_FindFirst(wch, rich); }
inline TPublicErrorReturnType FindFirstI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) const { return __super::public_FindFirstI(TConstantPair(psz, cch), rcid, rich); }
inline TPublicErrorReturnType FindFirstI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) const { return __super::public_FindFirstI(this->PairFromPCWSTR(psz), rcid, rich); }
inline TPublicErrorReturnType FindFirstI(WCHAR wch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) const { return __super::public_FindFirstI(wch, rcid, rich); }
inline TPublicErrorReturnType FindFirstILI(PCWSTR psz, SIZE_T cch, SIZE_T &rich) const { return __super::public_FindFirstI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType FindFirstILI(PCWSTR psz, SIZE_T &rich) const { return __super::public_FindFirstI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType FindFirstILI(WCHAR wch, SIZE_T &rich) const { return __super::public_FindFirstI(wch, CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType FindLast(const TConstantPair& Set, SIZE_T &rich) const { return __super::public_FindLast(Set, rich); }
inline TPublicErrorReturnType FindLast(PCWSTR psz, SIZE_T cch, SIZE_T &rich) const { return __super::public_FindLast(TConstantPair(psz, cch), rich); }
inline TPublicErrorReturnType FindLast(PCWSTR psz, SIZE_T &rich) const { return __super::public_FindLast(this->PairFromPCWSTR(psz), rich); }
inline TPublicErrorReturnType FindLast(WCHAR wch, SIZE_T &rich) const { return __super::public_FindLast(wch, rich); }
inline TPublicErrorReturnType FindLastI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) const { return __super::public_FindLastI(TConstantPair(psz, cch), rcid, rich); }
inline TPublicErrorReturnType FindLastI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) const { return __super::public_FindLastI(this->PairFromPCWSTR(psz), rcid, rich); }
inline TPublicErrorReturnType FindLastI(WCHAR wch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) const { return __super::public_FindLastI(wch, rcid, rich); }
inline TPublicErrorReturnType FindLastILI(PCWSTR psz, SIZE_T cch, SIZE_T &rich) const { return __super::public_FindLastI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType FindLastILI(PCWSTR psz, SIZE_T &rich) const { return __super::public_FindLastI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType FindLastILI(WCHAR wch, SIZE_T &rich) const { return __super::public_FindLastI(wch, CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline bool IsEmpty() const { return __super::IsEmpty(); }
inline TPublicErrorReturnType Left(SIZE_T cch) { return __super::public_Left(cch); }
inline TPublicErrorReturnType LowerCase(const CWin32CaseInsensitivityData &rcid) { return __super::public_LowerCase(rcid); }
inline TPublicErrorReturnType LoweCaseILI() { return __super::public_LowerCase(CWin32CaseInsensitivityData::LocaleInvariant()); }
inline TPublicErrorReturnType Mid(SIZE_T ichStart, SIZE_T cch) { return __super::public_Mid(ichStart, cch); }
inline TPublicErrorReturnType Prepend(PCWSTR psz, SIZE_T cch) { return __super::public_Prepend(TConstantPair(psz, cch)); }
inline TPublicErrorReturnType Prepend(PCWSTR psz) { return __super::public_Prepend(this->PairFromPCWSTR(psz)); }
inline TPublicErrorReturnType Prepend(WCHAR wch) { return __super::public_Prepend(wch); }
inline TPublicErrorReturnType PrependArray(SIZE_T cStrings, const TMutablePair *prgpairs) { return __super::public_PrependArray(cStrings, prgpairs); }
inline TPublicErrorReturnType PrependArray(SIZE_T cStrings, const TConstantPair *prgpairs) { return __super::public_PrependArray(cStrings, prgpairs); }
inline TPublicErrorReturnType Prepend(const TDecodingDataIn &rddi, PCSTR pszInput, SIZE_T cchInput, TDecodingDataOut &rddo) { return __super::public_Prepend(rddi, TConstantNonNativePair(pszInput, cchInput), rddo); }
inline TPublicErrorReturnType Prepend(const TDecodingDataIn &rddi, PCSTR pszInput, TDecodingDataOut &rddo) { return __super::public_Prepend(rddi, this->PairFromPCSTR(pszInput), rddo); }
inline TPublicErrorReturnType PrependACP(PCSTR pszInput, SIZE_T cchInput) { TDecodingDataOut ddoTemp; return __super::public_Prepend(this->ACPDecodingDataIn(), TConstantNonNativePair(pszInput, cchInput), ddoTemp); }
inline TPublicErrorReturnType PrependACP(PCSTR pszInput) { TDecodingDataOut ddoTemp; return __super::public_Prepend(this->ACPDecodingDataIn(), this->PairFromPCSTR(pszInput), ddoTemp); }
inline TPublicErrorReturnType ReverseComplementSpan(const TConstantPair& Maybies, SIZE_T &rIch) { return __super::public_ReverseComplementSpan(Maybies, rIch); }
inline TPublicErrorReturnType ReverseComplementSpan(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_ReverseComplementSpan(TConstantPair(psz, cch), rich); }
inline TPublicErrorReturnType ReverseComplementSpan(PCWSTR psz, SIZE_T &rich) { return __super::public_ReverseComplementSpan(this->PairFromPCWSTR(psz), rich); }
inline TPublicErrorReturnType ReverseComplementSpanI(const TConstantPair& Maybies, const CWin32CaseInsensitivityData &rcid, SIZE_T &rIch) { return __super::public_ReverseComplementSpanI(Maybies, rcid, rIch); }
inline TPublicErrorReturnType ReverseComplementSpanI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_ReverseComplementSpanI(TConstantPair(psz, cch), rcid, rich); }
inline TPublicErrorReturnType ReverseComplementSpanI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_ReverseComplementSpanI(this->PairFromPCWSTR(psz), rcid, rich); }
inline TPublicErrorReturnType ReverseComplementSpanILI(const TConstantPair& Maybies, SIZE_T &rIch) { return __super::public_ReverseComplementSpanI(Maybies, CWin32CaseInsensitivityData::LocaleInvariant(), rIch); }
inline TPublicErrorReturnType ReverseComplementSpanILI(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_ReverseComplementSpanI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType ReverseComplementSpanILI(PCWSTR psz, SIZE_T &rich) { return __super::public_ReverseComplementSpanI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType ReverseSpan(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_ReverseSpan(TConstantPair(psz, cch), rich); }
inline TPublicErrorReturnType ReverseSpan(PCWSTR psz, SIZE_T &rich) { return __super::public_ReverseSpan(this->PairFromPCWSTR(psz), rich); }
inline TPublicErrorReturnType ReverseSpanI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_ReverseSpanI(TConstantPair(psz, cch), rcid, rich); }
inline TPublicErrorReturnType ReverseSpanI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_ReverseSpanI(this->PairFromPCWSTR(psz), rcid, rich); }
inline TPublicErrorReturnType ReverseSpanILI(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_ReverseSpanI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType ReverseSpanILI(PCWSTR psz, SIZE_T &rich) { return __super::public_ReverseSpanI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType Right(SIZE_T cch) { return __super::public_Right(cch); }
inline TPublicErrorReturnType Span(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_Span(TConstantPair(psz, cch), rich); }
inline TPublicErrorReturnType Span(PCWSTR psz, SIZE_T &rich) { return __super::public_Span(this->PairFromPCWSTR(psz), rich); }
inline TPublicErrorReturnType SpanI(PCWSTR psz, SIZE_T cch, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_SpanI(TConstantPair(psz, cch), rcid, rich); }
inline TPublicErrorReturnType SpanI(PCWSTR psz, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich) { return __super::public_SpanI(this->PairFromPCWSTR(psz), rcid, rich); }
inline TPublicErrorReturnType SpanILI(PCWSTR psz, SIZE_T cch, SIZE_T &rich) { return __super::public_SpanI(TConstantPair(psz, cch), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType SpanILI(PCWSTR psz, SIZE_T &rich) { return __super::public_SpanI(this->PairFromPCWSTR(psz), CWin32CaseInsensitivityData::LocaleInvariant(), rich); }
inline TPublicErrorReturnType UpperCase(const CWin32CaseInsensitivityData &rcid) { return __super::public_UpperCase(rcid); }
inline TPublicErrorReturnType UpperCaseILI() { return __super::public_UpperCase(CWin32CaseInsensitivityData::LocaleInvariant()); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_w32unicodeinlinestringbuffer.h ===
#if !defined(_BCL_W32UNICODEINILINESTRINGBUFFER_H_INCLUDED_)
#define _BCL_W32UNICODEINILINESTRINGBUFFER_H_INCLUDED_

#pragma once

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_w32baseunicodestringbuffer.h>

namespace BCL
{

template <SIZE_T nInlineChars> class CWin32BaseUnicodeInlineStringBuffer;

template <SIZE_T nInlineChars>
class CWin32BaseUnicodeInlineStringBufferTraits : public CWin32BaseUnicodeStringBufferTraits<CWin32BaseUnicodeInlineStringBuffer<nInlineChars>, CWin32CallDisposition, BOOL>
{
    typedef CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars> TThis;
    typedef CWin32BaseUnicodeInlineStringBuffer<nInlineChars> TBuffer;

    typedef void TAccessor;

    friend BCL::CPureString<TThis>;
    friend BCL::CInlineString<TThis>;
    friend BCL::CUnicodeCharTraits<TBuffer, TCallDisposition>;

    friend CWin32BaseUnicodeStringBufferTraits<CWin32BaseUnicodeInlineStringBuffer<nInlineChars>, CWin32CallDisposition, BOOL >;

    typedef BCL::CInlineString<TThis> TInlineString;
    typedef CWin32BaseUnicodeInlineStringBuffer<nInlineChars> TBuffer;

    static inline PWSTR __fastcall GetInlineBufferPtr(const BCL::CBaseString *p);
    static inline SIZE_T __fastcall GetInlineBufferCch(const BCL::CBaseString *p);
    static inline TConstantPair __fastcall InlineBufferPair(const BCL::CBaseString *p);
    static inline TMutablePair __fastcall InlineMutableBufferPair(const BCL::CBaseString *p);

    static inline CWin32CallDisposition ReallocateBuffer(BCL::CBaseString *p, SIZE_T cch);
};

template <SIZE_T nInlineChars>
inline
PWSTR
__fastcall
CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>::GetInlineBufferPtr(
    const BCL::CBaseString *p
    )
{
    return static_cast<const TBuffer *>(p)->GetInlineBufferPtr();
}

template <SIZE_T nInlineChars>
inline
SIZE_T
__fastcall
CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>::GetInlineBufferCch(
    const BCL::CBaseString *p
    )
{
    return nInlineChars;
}

template <SIZE_T nInlineChars>
inline
typename CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>::TConstantPair
__fastcall
CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>::InlineBufferPair(
    const BCL::CBaseString *p
    )
{
    return TConstantPair(TThis::GetInlineBufferPtr(p), TThis::GetInlineBufferCch(p));
}

template <SIZE_T nInlineChars>
inline
typename CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>::TMutablePair
__fastcall
CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>::InlineMutableBufferPair(
    const BCL::CBaseString *p
    )
{
    return TMutablePair(TThis::GetInlineBufferPtr(p), TThis::GetInlineBufferCch(p));
}

template <SIZE_T nInlineChars>
inline
CWin32CallDisposition
CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>::ReallocateBuffer(
    BCL::CBaseString *p,
    SIZE_T cch
    )
{
    TBuffer * const pBuffer = static_cast<TBuffer *>(p);
    const PWSTR pBufferPtr = pBuffer->GetMutableBufferPtr();

    if (cch < TThis::GetInlineBufferCch(p))
    {
        if (pBufferPtr != TBuffer::TTraits::GetInlineBufferPtr(p))
        {
            if (pBufferPtr != NULL)
                TThis::DeallocateBuffer(pBufferPtr);

            TThis::SetBufferPointerAndCount(p, TThis::GetInlineBufferPtr(p), TThis::GetInlineBufferCch(p));
        }
    }
    else
    {
        const TSizeT cb = cch * sizeof(WCHAR);
        PWSTR psz = NULL;

        if (cch != (cb / sizeof(WCHAR)))
            return CWin32CallDisposition::FromWin32Error(ERROR_ARITHMETIC_OVERFLOW);

        if ((pBuffer != NULL) && (pBufferPtr != TThis::GetInlineBufferPtr(p)))
        {
            ::SetLastError(ERROR_SUCCESS);

            psz = 
                reinterpret_cast<PWSTR>(
                    ::HeapReAlloc(
                        ::GetProcessHeap(),
                        0,
                        const_cast<PWSTR>(pBufferPtr),
                        cb));

            if (psz == NULL)
            {
                const DWORD dwLastError = ::GetLastError();
                if (dwLastError == ERROR_SUCCESS)
                    return CWin32CallDisposition::FromWin32Error(ERROR_OUTOFMEMORY);

                return CWin32CallDisposition::FromWin32Error(dwLastError);
            }
        }
        else
        {
            psz = 
                reinterpret_cast<PWSTR>(
                    ::HeapAlloc(
                        ::GetProcessHeap(),
                        0,
                        cb));
        }

        if (psz == NULL)
            return CWin32CallDisposition::FromWin32Error(ERROR_OUTOFMEMORY);

        pBuffer->SetBufferPointerAndCount(psz, cch);
    }

    return CWin32CallDisposition::FromWin32Error(ERROR_SUCCESS);
}

template <SIZE_T nInlineChars>
class CWin32BaseUnicodeInlineStringBuffer : protected BCL::CInlineString<CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars> >, private BCL::CWin32BaseUnicodeStringBufferAddIn
{
public:
    typedef CWin32BaseUnicodeInlineStringBuffer<nInlineChars> TThis;
    typedef CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars> TTraits;

public:
    inline CWin32BaseUnicodeInlineStringBuffer() : CWin32BaseUnicodeStringBufferAddIn(m_rgchInlineBuffer, nInlineChars) { m_rgchInlineBuffer[0] = L'\0'; }
    inline ~CWin32BaseUnicodeInlineStringBuffer() { TTraits::DeallocateDynamicBuffer(this); }
    operator PCWSTR() const { return this->GetStringPtr(); }

#include <bcl_stringapi.h>

private:
    inline PWSTR GetInlineBufferPtr() const { return const_cast<PWSTR>(m_rgchInlineBuffer); }

    WCHAR m_rgchInlineBuffer[nInlineChars];

    friend CWin32BaseUnicodeStringBufferTraits<TThis, CWin32CallDisposition, BOOL>;
    friend CWin32BaseUnicodeInlineStringBufferTraits<nInlineChars>;
    friend BCL::CUnicodeCharTraits<TThis, TCallDisposition>;

}; // class CWin32BaseUnicodeInlineStringBuffer<>

}; // namespace BCL

#endif // !defined(_BCL_W32UNICODEINILINESTRINGBUFFER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_w32unicodefixedstringbuffer.h ===
#if !defined(_BCL_W32UNICODEFIXEDSTRINGBUFFER_H_INCLUDED_)
#define _BCL_W32UNICODEFIXEDSTRINGBUFFER_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_w32unicodefixedstringbuffer.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_w32baseunicodestringbuffer.h>

namespace BCL
{

template <SIZE_T nInlineChars> class CWin32BaseUnicodeFixedStringBuffer;

template <SIZE_T nInlineChars>
class CWin32BaseUnicodeFixedStringBufferTraits : public CWin32BaseUnicodeStringBufferTraits<CWin32BaseUnicodeFixedStringBuffer<nInlineChars>, CWin32CallDisposition, BOOL>
{
    typedef CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars> TThis;
    typedef CWin32BaseUnicodeFixedStringBuffer<nInlineChars> TBuffer;

    typedef void TAccessor;

    friend BCL::CPureString<TThis>;
    friend BCL::CInlineString<TThis>;
    friend BCL::CUnicodeCharTraits<TBuffer, TCallDisposition>;
    friend CWin32BaseUnicodeStringBufferTraits<CWin32BaseUnicodeFixedStringBuffer<nInlineChars>, CWin32CallDisposition, BOOL>;

    typedef BCL::CInlineString<TThis> TInlineString;
    typedef CWin32BaseUnicodeFixedStringBuffer<nInlineChars> TBuffer;

    static inline PWSTR __fastcall GetInlineBufferPtr(const BCL::CBaseString *p) { return static_cast<const TBuffer *>(p)->GetInlineBufferPtr(); }
    static inline SIZE_T __fastcall GetInlineBufferCch(const BCL::CBaseString *p) { return nInlineChars; }
    static inline TConstantPair __fastcall InlineBufferPair(const BCL::CBaseString *p) { return TConstantPair(TThis::GetInlineBufferPtr(p), TThis::GetInlineBufferCch(p)); }
    static inline TMutablePair __fastcall InlineMutableBufferPair(const BCL::CBaseString *p) { return TMutablePair(TThis::GetInlineBufferPtr(p), TThis::GetInlineBufferCch(p)); }

    static inline CWin32CallDisposition RoundBufferSize(SIZE_T cch, SIZE_T &rcchGranted) { BCL_MAYFAIL_PROLOG BCL_PARAMETER_CHECK(cch > nInlineChars); rcchGranted = 0; return CWin32CallDisposition::BufferOverflow(); BCL_MAYFAIL_EPILOG_INTERNAL }

    // We never have a non-inline buffer, so these shouldn't ever get called.
    static inline CWin32CallDisposition __fastcall ReallocateBuffer(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_ASSERT(false);
        return CWin32CallDisposition::InternalError_RuntimeCheck();
    }
    static inline void __fastcall DeallocateBuffer(PCWSTR psz)
    {
        BCL_ASSERT(false);
    }
}; // class CWin32BaseUnicodeFixedStringBufferTraits

template <SIZE_T nInlineChars>
class CWin32BaseUnicodeFixedStringBuffer : private BCL::CInlineString<CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars> >, private CWin32BaseUnicodeStringBufferAddIn
{
public:
    typedef CWin32BaseUnicodeFixedStringBuffer<nInlineChars> TThis;
    typedef CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars> TTraits;

    inline CWin32BaseUnicodeFixedStringBuffer() : CWin32BaseUnicodeStringBufferAddIn(m_rgchInlineBuffer, nInlineChars) { }
    inline ~CWin32BaseUnicodeFixedStringBuffer() { } // no dynamic buffer; nothing to do.
    operator PCWSTR() const { return this->GetStringPtr(); }

#include <bcl_stringapi.h>

private:
    inline PWSTR GetInlineBufferPtr() const { return const_cast<PWSTR>(m_rgchInlineBuffer); }

    WCHAR m_rgchInlineBuffer[nInlineChars]; // Plus one to make instantiation with nInlineChars=0 work

    friend CWin32BaseUnicodeStringBufferTraits<TThis, CWin32CallDisposition, BOOL>;
    friend CWin32BaseUnicodeFixedStringBufferTraits<nInlineChars>;
    friend BCL::CUnicodeCharTraits<TThis, TCallDisposition>;

}; // class CWin32BaseUnicodeFixedStringBuffer

}; // namespace BCL

#endif // !defined(_BCL_W32UNICODEFIXEDSTRINGBUFFER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_w32unicodestringalgorithms.h ===
#if !defined(_BCL_W32UNICODESTRINGALGORITHMS_H_INCLUDED_)
#define _BCL_W32UNICODESTRINGALGORITHMS_H_INCLUDED_

#pragma once

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    bcl_w32unicodestringalgorithms.h

Abstract:


Author:

    Michael Grier (MGrier) 2/6/2002

Revision History:

--*/

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_vararg.h>

#include <limits.h>

namespace BCL
{

template <typename TBuffer, typename TCallDispositionT>
class CWin32NullTerminatedUnicodeStringAlgorithms
{
public:
    typedef CWin32NullTerminatedUnicodeStringAlgorithms TThis;

    typedef TCallDispositionT TCallDisposition;
    typedef CWin32StringComparisonResult TComparisonResult;

    typedef BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> TConstantPair;
    typedef BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T> TMutablePair;

    typedef CWin32CaseInsensitivityData TCaseInsensitivityData;
    typedef SIZE_T TSizeT;

    typedef CWin32MBCSToUnicodeDataIn TDecodingDataIn;
    typedef CWin32MBCSToUnicodeDataOut TDecodingDataOut;
    typedef CWin32UnicodeToMBCSDataIn TEncodingDataIn;
    typedef CWin32UnicodeToMBCSDataOut TEncodingDataOut;

    typedef CConstantPointerAndCountPair<CHAR, SIZE_T> TConstantNonNativePair;
    typedef CMutablePointerAndCountPair<CHAR, SIZE_T> TMutableNonNativePair;

    typedef PSTR TMutableNonNativeString;
    typedef PCSTR TConstantNonNativeString;

    typedef PWSTR TMutableString;
    typedef PCWSTR TConstantString;

    static inline void _fastcall SetStringCch(BCL::CBaseString *p, SIZE_T cch)
    {
        BCL_ASSERT((cch == 0) || (cch < TBuffer::TTraits::GetBufferCch(p)));
        static_cast<TBuffer *>(p)->m_cchString = cch;
        if (TBuffer::TTraits::GetBufferCch(p) != 0)
            TBuffer::TTraits::GetMutableBufferPtr(p)[cch] = L'\0';
    }

    static inline TCallDisposition __fastcall MapStringCchToBufferCch(SIZE_T cchString, SIZE_T &rcchRequired)
    {
        SIZE_T cchRequired = cchString + 1;

        if (cchRequired == 0)
            return TCallDisposition::ArithmeticOverflow();

        rcchRequired = cchRequired;

        return TCallDisposition::Success();
    }

    static inline TCallDisposition __fastcall MapBufferCchToStringCch(SIZE_T cchBuffer, SIZE_T &rcchString)
    {
        if (cchBuffer == 0)
            rcchString = 0;
        else
            rcchString = cchBuffer - 1;

        return TCallDisposition::Success();
    }

    static inline TCallDisposition __fastcall IsCharLegalLeadChar(WCHAR wch, bool &rfIsLegal)
    {
        BCL_MAYFAIL_PROLOG

        // fast common path out for ASCII; there are no combining characters in this range
        if (wch <= 0x007f)
            rfIsLegal = true;
        else
        {
            // low surrogate
            if ((wch >= 0xdc00) && (wch <= 0xdfff))
                rfIsLegal = false;
            else
            {
                WORD wCharType = 0;

                if (!::GetStringTypeExW(LOCALE_INVARIANT, CT_CTYPE3, &wch, 1, &wCharType))
                    BCL_ORIGINATE_ERROR(TCallDisposition::FromLastError());

                // If it's not one of these types of nonspacing marks
                rfIsLegal = ((wCharType & (C3_NONSPACING | C3_DIACRITIC | C3_VOWELMARK)) == 0);
            }
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall UpperCase(BCL::CBaseString *p, const CWin32CaseInsensitivityData &rcid)
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(TBuffer::TTraits::GetStringCch(p) <= INT_MAX);

        // LCMapStringW() seems to be nice and allow for in-place case changing...

        int iResult = 
            ::LCMapStringW(
                rcid.m_lcid,
                (rcid.m_dwCmpFlags & ~(NORM_IGNORECASE)) | LCMAP_UPPERCASE,
                TBuffer::TTraits::GetBufferPtr(p),
                static_cast<INT>(TBuffer::TTraits::GetStringCch(p)),
                TBuffer::TTraits::GetMutableBufferPtr(p),
                static_cast<INT>(TBuffer::TTraits::GetStringCch(p)));

        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult == static_cast<INT>(TBuffer::TTraits::GetStringCch(p)));

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall LowerCase(BCL::CBaseString *p, const CWin32CaseInsensitivityData &rcid)
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(TBuffer::TTraits::GetStringCch(p) <= INT_MAX);

        // LCMapStringW() seems to be nice and allow for in-place case changing...

        int iResult = 
            ::LCMapStringW(
                rcid.m_lcid,
                (rcid.m_dwCmpFlags & ~(NORM_IGNORECASE)) | LCMAP_LOWERCASE,
                TBuffer::TTraits::GetBufferPtr(p),
                static_cast<INT>(TBuffer::TTraits::GetStringCch(p)),
                TBuffer::TTraits::GetMutableBufferPtr(p),
                static_cast<INT>(TBuffer::TTraits::GetStringCch(p)));

        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult == static_cast<INT>(TBuffer::TTraits::GetStringCch(p)));

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeInputType1, typename TSomeInputType2>
    static inline TCallDisposition __fastcall
    EqualStringsI(
        const TSomeInputType1 &rinput1,
        const TSomeInputType2 &rinput2,
        const CWin32CaseInsensitivityData &rcid,
        bool &rfMatches
        )
    {
        BCL_MAYFAIL_PROLOG

        rfMatches = false;

        BCL_PARAMETER_CHECK(TBuffer::TTraits::GetInputCch(rinput1) <= INT_MAX);
        BCL_PARAMETER_CHECK(TBuffer::TTraits::GetInputCch(rinput2) <= INT_MAX);

        int i = ::CompareStringW(
            rcid.m_lcid,
            rcid.m_dwCmpFlags,
            TBuffer::TTraits::GetInputPtr(rinput1),
            static_cast<INT>(TBuffer::TTraits::GetInputCch(rinput1)),
            TBuffer::TTraits::GetInputPtr(rinput2),
            static_cast<INT>(TBuffer::TTraits::GetInputCch(rinput2)));

        if (i == 0)
            BCL_ORIGINATE_ERROR(TCallDisposition::FromLastError());

        rfMatches = (i == CSTR_EQUAL);

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeInputType1, typename TSomeInputType2>
    static inline TCallDisposition __fastcall CompareStringsI(
        const TSomeInputType1 &rinput1,
        const TSomeInputType2 &rinput2,
        const CWin32CaseInsensitivityData &rcid,
        TComparisonResult &rcr
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(TBuffer::TTraits::GetInputCch(rinput1) <= INT_MAX);
        BCL_PARAMETER_CHECK(TBuffer::TTraits::GetInputCch(rinput2) <= INT_MAX);

        int i = ::CompareStringW(
            rcid.m_lcid,
            rcid.m_dwCmpFlags,
            TBuffer::TTraits::GetInputPtr(rinput1),
            static_cast<INT>(TBuffer::TTraits::GetInputCch(rinput1)),
            TBuffer::TTraits::GetInputPtr(rinput2),
            static_cast<INT>(TBuffer::TTraits::GetInputCch(rinput2)));

        if (i == 0)
            BCL_ORIGINATE_ERROR(TCallDisposition::FromLastError());

        if (i == CSTR_LESS_THAN)
            rcr.SetLessThan();
        else if (i == CSTR_EQUAL)
            rcr.SetEqualTo();
        else
        {
            BCL_INTERNAL_ERROR_CHECK(i == CSTR_GREATER_THAN);
            rcr.SetGreaterThan();
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    template <typename TSomeCharacterMatcher>
    inline
    static
    TCallDisposition
    ContainsI(
        const TConstantPair &rpair,
        const TSomeCharacterMatcher &rscm,
        const CWin32CaseInsensitivityData &rcid,
        bool &rfFound
        )
    {
        BCL_MAYFAIL_PROLOG

        rfFound = false;

        BCL_PARAMETER_CHECK(rpair.Valid());
        SIZE_T cch = rpair.GetCount();
        SIZE_T i;
        const WCHAR *prgch = rpair.GetPointer();

        for (i=0; i<cch; )
        {
            SIZE_T cchConsumed = 0;
            bool fMatch = false;

            BCL_IFCALLFAILED_EXIT(rscm.MatchI(rcid, prgch, cchConsumed, fMatch));

            BCL_INTERNAL_ERROR_CHECK(cchConsumed != 0);

            if (fMatch)
                break;

            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::AddWithOverflowCheck(i, cchConsumed, i));
        }

        if (i != cch)
            rfFound = true;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }


    inline
    static
    TCallDisposition
    ContainsI(
        const TConstantPair &rpair,
        WCHAR ch,
        const CWin32CaseInsensitivityData &rcid,
        bool &rfFound
        )
    {
        BCL_MAYFAIL_PROLOG

        rfFound = false;

        BCL_PARAMETER_CHECK(rpair.Valid());
        SIZE_T cch = rpair.GetCount();
        SIZE_T i;
        const WCHAR *prgch = rpair.GetPointer();

        for (i=0; i<cch; i++)
        {
            int iResult = ::CompareStringW(rcid.m_lcid, rcid.m_dwCmpFlags, prgch++, 1, &ch, 1);
            if (iResult == 0)
                return TCallDisposition::FromLastError();
            if (iResult == CSTR_EQUAL)
                break;
        }

        if (i != cch)
            rfFound = true;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    ContainsI(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        const CWin32CaseInsensitivityData &rcid,
        bool &rfFound
        )
    {
        BCL_MAYFAIL_PROLOG

        rfFound = false;

        BCL_PARAMETER_CHECK(rpair.Valid());
        BCL_PARAMETER_CHECK(rpairCandidate.Valid());

        SIZE_T cchCandidate = rpairCandidate.GetCount();
        const WCHAR *prgwchCandidate = rpairCandidate.GetPointer();

        BCL_PARAMETER_CHECK(cchCandidate <= INT_MAX);

        if (cchCandidate == 0)
        {
            // The null string is in every string
            rfFound = true;
        }
        else
        {
            SIZE_T cch = rpair.GetCount();
            SIZE_T i;
            const WCHAR *prgch = rpair.GetPointer();

            // This is a dismal implementation of this kind of search but
            // I don't know if there's a lot you can do with neato algorithms
            // while keeping the case insensitivity a black box inside of
            // CompareStringW().  -mgrier 2/3/2002

            for (i=0; i<cch; i++)
            {
                int iResult = ::CompareStringW(
                    rcid.m_lcid,
                    rcid.m_dwCmpFlags,
                    prgch,
                    static_cast<INT>(cchCandidate),
                    prgwchCandidate,
                    static_cast<INT>(cchCandidate));

                if (iResult == 0)
                    return TCallDisposition::FromLastError();

                if (iResult == CSTR_EQUAL)
                {
                    rfFound = true;
                    break;
                }

                const WCHAR wch = *prgch++;

                // Skip ahead an additional character if this is a surrogate
                if ((wch >= 0xd800) && (wch <= 0xdbff))
                {
                    i++;
                    prgch++;
                }
            }
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    __fastcall
    FindFirstI(
        const TConstantPair &rpair,
        WCHAR ch,
        const CWin32CaseInsensitivityData &rcid,
        SIZE_T &rich
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpair.Valid());
        SIZE_T cch = rpair.GetCount();
        SIZE_T i;
        const WCHAR *prgch = rpair.GetPointer();

        for (i=0; i<cch; i++)
        {
            int iResult = ::CompareStringW(rcid.m_lcid, rcid.m_dwCmpFlags, prgch++, 1, &ch, 1);
            if (iResult == 0)
                return TCallDisposition::FromLastError();
            if (iResult == CSTR_EQUAL)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    FindFirstI(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        const CWin32CaseInsensitivityData &rcid,
        SIZE_T &richFound
        )
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T cch = rpair.GetCount();

        richFound = cch;

        BCL_PARAMETER_CHECK(rpair.Valid());
        BCL_PARAMETER_CHECK(rpairCandidate.Valid());

        SIZE_T cchCandidate = rpairCandidate.GetCount();
        const WCHAR *prgwchCandidate = rpairCandidate.GetPointer();

        BCL_PARAMETER_CHECK(cchCandidate <= INT_MAX);

        if (cchCandidate == 0)
        {
            // The null string is in every string
            richFound = cch;
        }
        else
        {
            SIZE_T i;
            const WCHAR *prgch = rpair.GetPointer();

            // This is a dismal implementation of this kind of search but
            // I don't know if there's a lot you can do with neato algorithms
            // while keeping the case insensitivity a black box inside of
            // CompareStringW().  -mgrier 2/3/2002

            for (i=0; i<cch; i++)
            {
                int iResult = ::CompareStringW(
                    rcid.m_lcid,
                    rcid.m_dwCmpFlags,
                    prgch,
                    static_cast<INT>(cchCandidate),
                    prgwchCandidate,
                    static_cast<INT>(cchCandidate));

                if (iResult == 0)
                    return TCallDisposition::FromLastError();

                if (iResult == CSTR_EQUAL)
                {
                    richFound = i;
                    break;
                }

                const WCHAR wch = *prgch++;

                // Skip ahead an additional character if this is a surrogate
                if ((wch >= 0xd800) && (wch <= 0xdbff))
                {
                    i++;
                    prgch++;
                }
            }
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    __fastcall
    FindLastI(
        const TConstantPair &rpair,
        WCHAR ch,
        const CWin32CaseInsensitivityData &rcid,
        SIZE_T &richFound
        )
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cch = rpair.GetCount();
        const WCHAR *prgwch = rpair.GetPointer() + cch;

        richFound = cch;

        for (i=cch; i>0; i--)
        {
            int iResult = ::CompareStringW(rcid.m_lcid, rcid.m_dwCmpFlags, --prgwch, 1, &ch, 1);
            if (iResult == 0)
                return TCallDisposition::FromLastError();
            if (iResult == CSTR_EQUAL)
                break;
        }

        if (i == 0)
            richFound = cch;
        else
            richFound = i - 1;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    inline
    static
    TCallDisposition
    FindLastI(
        const TConstantPair &rpair,
        const TConstantPair &rpairCandidate,
        const CWin32CaseInsensitivityData &rcid,
        SIZE_T &richFound
        )
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T cch = rpair.GetCount();

        richFound = cch;

        BCL_PARAMETER_CHECK(rpair.Valid());
        BCL_PARAMETER_CHECK(rpairCandidate.Valid());

        SIZE_T cchCandidate = rpairCandidate.GetCount();
        const WCHAR *prgwchCandidate = rpairCandidate.GetPointer();

        BCL_PARAMETER_CHECK(cchCandidate <= INT_MAX);

        if (cchCandidate == 0)
        {
            // The null string is in every string
            richFound = cch;
        }
        else
        {
            // We can't even short circuit out of here just because the candidate string
            // is longer than the target string because we don't know what kind of
            // case folding magic NLS is doing for us behind the scenes based on
            // the case insensitivity data's dwCmpFlags.

            SIZE_T i;
            const WCHAR *prgch = rpair.GetPointer();

            // This is a dismal implementation of this kind of search but
            // I don't know if there's a lot you can do with neato algorithms
            // while keeping the case insensitivity a black box inside of
            // CompareStringW().  -mgrier 2/3/2002

            for (i=0; i<cch; i++)
            {
                int iResult = ::CompareStringW(
                    rcid.m_lcid,
                    rcid.m_dwCmpFlags,
                    prgch,
                    static_cast<INT>(cchCandidate),
                    prgwchCandidate,
                    static_cast<INT>(cchCandidate));

                if (iResult == 0)
                    return TCallDisposition::FromLastError();

                if (iResult == CSTR_EQUAL)
                {
                    richFound = i;
                    // keep looking in case there's another
                }

                const WCHAR wch = *prgch++;

                // Skip ahead an additional character if this is a surrogate
                if ((wch >= 0xd800) && (wch <= 0xdbff))
                {
                    i++;
                    prgch++;
                }
            }
        }

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall SpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=0; i<cchBuffer; i++)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i], rcid, fFound));
            if (!fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall ComplementSpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=0; i<cchBuffer; i++)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i], rcid, fFound));
            if (fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall ReverseSpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=cchBuffer; i>0; i--)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i-1], rcid, fFound));
            if (!fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition __fastcall ReverseComplementSpanI(const TConstantPair &rpairBuffer, const TConstantPair &rpairSet, const CWin32CaseInsensitivityData &rcid, SIZE_T &rich)
    {
        BCL_MAYFAIL_PROLOG

        SIZE_T i;
        SIZE_T cchBuffer = rpairBuffer.GetCount();
        const WCHAR *prgwchBuffer = rpairBuffer.GetPointer();
        bool fFound;

        // This does not handle surrogates correctly

        for (i=cchBuffer; i>0; i--)
        {
            BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::ContainsI(rpairSet, prgwchBuffer[i], rcid, fFound));
            if (fFound)
                break;
        }

        rich = i;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    DetermineRequiredCharacters(
        const CWin32MBCSToUnicodeDataIn &rddi,
        const TConstantNonNativePair &rpair,
        CWin32MBCSToUnicodeDataOut &rddo,
        SIZE_T &rcch
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpair.GetCount() <= INT_MAX); // limitation imposed by MultiByteToWideChar API

        int iResult = ::MultiByteToWideChar(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | MB_ERR_INVALID_CHARS,
                            rpair.GetPointer(),
                            static_cast<INT>(rpair.GetCount()),
                            NULL,
                            0);
        if (iResult == 0)
            BCL_ORIGINATE_ERROR(TCallDisposition::FromLastError());

        BCL_INTERNAL_ERROR_CHECK(iResult > 0); // I don't know why MultiByteToWide char would return negative but let's make sure

        rcch = iResult;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    CopyIntoBuffer(
        const TMutablePair &rpairOut,
        const CWin32MBCSToUnicodeDataIn &rddi,
        const TConstantNonNativePair &rpairIn,
        CWin32MBCSToUnicodeDataOut &rddo
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpairIn.GetCount() <= INT_MAX); // limitation imposed by MultiByteToWideChar API
        BCL_PARAMETER_CHECK(rpairOut.GetCount() <= INT_MAX); // might make sense to just clamp at INT_MAX but at least we fail correctly instead of silent truncation

        int iResult = ::MultiByteToWideChar(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | MB_ERR_INVALID_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(rpairIn.GetCount()),
                            rpairOut.GetPointer(),
                            static_cast<INT>(rpairOut.GetCount()));
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult > 0); // I don't know why MultiByteToWide char would return negative but let's make sure

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    CopyIntoBuffer(
        const TMutableNonNativePair &rpairOut,
        const CWin32UnicodeToMBCSDataIn &rddi,
        const TConstantPair &rpairIn,
        CWin32UnicodeToMBCSDataOut &rddo,
        SIZE_T &rcchWritten
        )
    {
        BCL_MAYFAIL_PROLOG

        BCL_PARAMETER_CHECK(rpairIn.GetCount() <= INT_MAX);
        BCL_PARAMETER_CHECK(rpairOut.GetCount() <= INT_MAX);

        // If we want to have any chance of returning ERROR_BUFFER_OVERFLOW
        // either we need to play the "two null chars at the end of the
        // buffer" game or we have to do this in two passes - one to
        // get the desired length and one to actually move the data.
        //
        // If someone has an approach which doesn't lose correctness but
        // avoids the double conversion, be my guest and fix this. -mgrier 2/6/2002
        int iResult = ::WideCharToMultiByte(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(rpairIn.GetCount()),
                            NULL,
                            0,
                            rddo.m_lpDefaultChar,
                            rddo.m_lpUsedDefaultChar);
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult >= 0);

        if (iResult > static_cast<INT>(rpairOut.GetCount()))
            BCL_ORIGINATE_ERROR(TCallDisposition::BufferOverflow());

        iResult = ::WideCharToMultiByte(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(rpairIn.GetCount()),
                            rpairOut.GetPointer(),
                            static_cast<INT>(rpairOut.GetCount()),
                            rddo.m_lpDefaultChar,
                            rddo.m_lpUsedDefaultChar);
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult >= 0);

        rcchWritten = iResult;

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    AllocateAndCopyIntoBuffer(
        TMutableNonNativeString &rpszOut,
        const CWin32UnicodeToMBCSDataIn &rddi,
        const TConstantPair &rpairIn,
        CWin32UnicodeToMBCSDataOut &rddo,
        SIZE_T &rcchWritten
        )
    {
        BCL_MAYFAIL_PROLOG

        TSizeT cchInputString, cchBuffer;
        TBuffer::TTraits::TPSTRAllocationHelper pszTemp;

        BCL_PARAMETER_CHECK(rpairIn.GetCount() <= INT_MAX);

        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapStringCchToBufferCch(rpairIn.GetCount(), cchInputString));
        if (cchInputString > INT_MAX)
            BCL_ORIGINATE_ERROR(TCallDisposition::BufferOverflow());

        int iResult = ::WideCharToMultiByte(
                            rddi.m_CodePage,
                            rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                            rpairIn.GetPointer(),
                            static_cast<INT>(cchInputString),
                            NULL,
                            0,
                            rddo.m_lpDefaultChar,
                            rddo.m_lpUsedDefaultChar);
        if (iResult == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult >= 0);

        cchBuffer = iResult;
        BCL_IFCALLFAILED_EXIT(pszTemp.Allocate(cchBuffer));

        INT iResult2 = ::WideCharToMultiByte(
                        rddi.m_CodePage,
                        rddi.m_dwFlags | WC_NO_BEST_FIT_CHARS,
                        rpairIn.GetPointer(),
                        static_cast<INT>(cchInputString),
                        static_cast<PSTR>(pszTemp),
                        iResult,
                        rddo.m_lpDefaultChar,
                        rddo.m_lpUsedDefaultChar);
        if (iResult2 == 0)
            return TCallDisposition::FromLastError();

        BCL_INTERNAL_ERROR_CHECK(iResult2 >= 0);

        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapBufferCchToStringCch(iResult2, rcchWritten));
        rpszOut = pszTemp.Detach();

        BCL_MAYFAIL_EPILOG_INTERNAL
    }

    static inline TCallDisposition
    AllocateAndCopyIntoBuffer(
        TMutableString &rstringOut,
        const TConstantPair &rpairIn,
        TSizeT &rcchWritten
        )
    {
        BCL_MAYFAIL_PROLOG
        TSizeT cchString = rpairIn.GetCount();
        TSizeT cchBuffer;
        TBuffer::TTraits::TPWSTRAllocationHelper pszTemp;
        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::MapStringCchToBufferCch(cchString, cchBuffer));
        BCL_IFCALLFAILED_EXIT(pszTemp.Allocate(cchBuffer));
        BCL_IFCALLFAILED_EXIT(TBuffer::TTraits::CopyIntoBuffer(TMutablePair(static_cast<PWSTR>(pszTemp), cchBuffer), rpairIn, rcchWritten));
        rstringOut = pszTemp.Detach();
        BCL_MAYFAIL_EPILOG_INTERNAL
    }
}; // class CWin32NullTerminatedUnicodeStringAlgorithms

}; // namespace BCL

#endif // !defined(_BCL_W32UNICODESTRINGALGORITHMS_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\bcl_w32unicodestringbuffer.h ===
#if !defined(_BCL_W32UNICODESTRINGBUFFER_H_INCLUDED_)
#define _BCL_W32UNICODESTRINGBUFFER_H_INCLUDED_

#pragma once

#include <windows.h>

#include <bcl_inlinestring.h>
#include <bcl_unicodechartraits.h>
#include <bcl_w32common.h>
#include <bcl_w32baseunicodestringbuffer.h>

namespace BCL
{
class CWin32UnicodeStringBuffer;

class CWin32UnicodeStringBufferTraits : public CWin32BaseUnicodeStringBufferTraits<CWin32UnicodeStringBuffer, CWin32CallDisposition, BOOL>
{
public:
    typedef CWin32UnicodeStringBufferTraits TThis;
    typedef void TAccessor;

    friend BCL::CPureString<TThis>;
    typedef CWin32UnicodeStringBuffer TBuffer;
};

class CWin32UnicodeStringBuffer : private BCL::CPureString<CWin32UnicodeStringBufferTraits>, private CWin32BaseUnicodeStringBufferAddIn
{
protected:
    inline void DeallocateDynamicBuffer();
    
public:
    typedef CWin32UnicodeStringBuffer TThis;
    typedef CWin32UnicodeStringBufferTraits TTraits;
    inline CWin32UnicodeStringBuffer() : CWin32BaseUnicodeStringBufferAddIn(NULL, 0) { }
    inline ~CWin32UnicodeStringBuffer() { TTraits::DeallocateDynamicBuffer(this); }
    operator PCWSTR() const { return this->GetStringPtr(); }

#include <bcl_stringapi.h>

private:
    friend CWin32BaseUnicodeStringBufferTraits<TThis, CWin32CallDisposition, BOOL>;
    friend CWin32UnicodeStringBufferTraits;
    friend BCL::CUnicodeCharTraits<TThis, TCallDisposition>;
    
}; // class CWin32UnicodeStringBuffer

inline
void
CWin32UnicodeStringBuffer::DeallocateDynamicBuffer()
{
    if (this->GetBufferPtr() != NULL)
    {
        TTraits::DeallocateBuffer(this->MutableBufferPair().GetPointer());
        this->MutableBufferPair() = BCL::CMutablePointerAndCountPair<WCHAR, SIZE_T>(NULL, 0);
        this->SetStringCch(0);
    }
}

}; // namespace BCL

#endif // !defined(_BCL_W32UNICODESTRINGBUFFER_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\bcl\usbtest.cpp ===
#include <bcl_common.h>
#include <bcl_w32unicodeinlinestringbuffer.h>
#include <bcl_w32unicodestringbuffer.h>
#include <bcl_w32unicodefixedstringbuffer.h>

#include <stdio.h>
#include <limits.h>

extern "C" void bar(BCL::CWin32BaseUnicodeInlineStringBuffer<50> *p);

template class BCL::CWin32BaseUnicodeInlineStringBuffer<50>;

#define SHOULDFAIL(_e, _le) do { BOOL fSuccess = (_e); BCL_ASSERT((!fSuccess) && (::GetLastError() == (_le))); } while (0)
#define SHOULDWORK(_e) do { BOOL fSuccess = (_e); BCL_ASSERT(fSuccess); } while (0)
#define CHECK(_sv, x) do { bool fEquals; SHOULDWORK(_sv.Equals(x, static_cast<SIZE_T>(BCL_NUMBER_OF(x) - 1), fEquals)); BCL_ASSERT(fEquals); } while (0)

template <typename TStringClass>
void
DoCheckCaseSensitiveComparisons(
    TStringClass &rString
    )
{
    bool fEquals;
    int iComparisonResult;

    SHOULDWORK(rString.Assign(L"foobarbazeieiomumble"));
    CHECK(rString, L"foobarbazeieiomumble");

    SHOULDWORK(rString.Equals(L"hello there", fEquals));
    BCL_ASSERT(!fEquals);

    SHOULDWORK(rString.Equals(L"foobarbazeieiomumble", fEquals));
    BCL_ASSERT(fEquals);

    SHOULDWORK(rString.Equals(L"FooBarBazEieioMumble", fEquals));
    BCL_ASSERT(!fEquals);

    SHOULDWORK(rString.Compare(L"foo", iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.Compare(L"foozle", iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);

    SHOULDWORK(rString.Assign(L'f'));
    CHECK(rString, L"f");

    SHOULDWORK(rString.Equals(L'e', fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.Equals(L'f', fEquals));
    BCL_ASSERT(fEquals);
    SHOULDWORK(rString.Equals(L'g', fEquals));
    BCL_ASSERT(!fEquals);

    SHOULDWORK(rString.Equals(L'E', fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.Equals(L'F', fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.Equals(L'G', fEquals));
    BCL_ASSERT(!fEquals);

    SHOULDWORK(rString.Compare(L'e', iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.Compare(L'f', iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_EQUAL);
    SHOULDWORK(rString.Compare(L'g', iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);

    SHOULDWORK(rString.Compare(L'E', iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.Compare(L'F', iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.Compare(L'G', iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
}

template <typename TStringClass>
void
DoCheckCaseInsensitiveComparisons(
   TStringClass &rString
   )
{
    bool fEquals;
    int iComparisonResult;

    SHOULDWORK(rString.Assign(L"foobarbazeieiomumble"));
    CHECK(rString, L"foobarbazeieiomumble");

    SHOULDWORK(rString.EqualsI(L"hello there", BCL::CWin32CaseInsensitivityData(), fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L"foobarbazeieiomumble", fEquals));
    BCL_ASSERT(fEquals);
    SHOULDWORK(rString.EqualsILI(L"foobarbazeieio", fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L"foobarbazeieiomumblexyz", fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L"FooBarBazEieioMumble", fEquals));
    BCL_ASSERT(fEquals);

    SHOULDWORK(rString.CompareI(L"FOO", BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.CompareI(L"FOOZLE", BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);
    SHOULDWORK(rString.CompareILI(L"foobarbazeieiomumble", iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_EQUAL);
    SHOULDWORK(rString.CompareILI(L"foobarbazeieio", iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.CompareILI(L"foobarbazeieiomumblexyz", iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);
    SHOULDWORK(rString.CompareILI(L"FooBarBazEieioMumble", iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_EQUAL);

    SHOULDWORK(rString.Assign(L'f'));
    CHECK(rString, L"f");

    SHOULDWORK(rString.EqualsI(L'h', BCL::CWin32CaseInsensitivityData(), fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L'f', fEquals));
    BCL_ASSERT(fEquals);
    SHOULDWORK(rString.EqualsILI(L'F', fEquals));
    BCL_ASSERT(fEquals);
    SHOULDWORK(rString.EqualsILI(L'e', fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L'E', fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L'g', fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L'G', fEquals));
    BCL_ASSERT(!fEquals);

    SHOULDWORK(rString.CompareI(L'E', BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.CompareI(L'F', BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_EQUAL);
    SHOULDWORK(rString.CompareI(L'G', BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);

    SHOULDWORK(rString.CompareI(L'e', BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.CompareI(L'f', BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_EQUAL);
    SHOULDWORK(rString.CompareI(L'g', BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);
}

template <typename TStringClass>
void
DoCheckCharacterFinding(
    TStringClass &rString
    )
{
    SIZE_T ich;
    bool fContains;

    SHOULDWORK(rString.Assign(L"bbbcccdddeeefffggg"));
    CHECK(rString, L"bbbcccdddeeefffggg");

    SHOULDWORK(rString.Contains(L'a', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L'b', fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L'g', fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L'h', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L'A', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L'B', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L'G', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L'H', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsI(L'a', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsI(L'b', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsI(L'g', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsI(L'h', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsI(L'A', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsI(L'B', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsI(L'G', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsI(L'H', BCL::CWin32CaseInsensitivityData(), fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsILI(L'a', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsILI(L'b', fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsILI(L'g', fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsILI(L'h', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsILI(L'A', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.ContainsILI(L'B', fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsILI(L'G', fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.ContainsILI(L'H', fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.FindFirst(L'a', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L'b', ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirst(L'c', ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirst(L'g', ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirst(L'h', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L'A', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L'B', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L'G', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L'H', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L'a', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L'b', ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLast(L'c', ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.FindLast(L'g', ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLast(L'h', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L'A', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L'B', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L'G', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L'H', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L'a', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L'b', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstI(L'c', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirstI(L'g', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstI(L'h', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L'A', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L'B', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstI(L'G', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstI(L'H', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L'a', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L'b', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastI(L'c', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.FindLastI(L'g', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastI(L'h', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L'A', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L'B', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastI(L'G', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastI(L'H', BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L'a', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L'b', ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstILI(L'c', ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirstILI(L'g', ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstILI(L'h', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L'A', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L'B', ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstILI(L'G', ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstILI(L'H', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L'a', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L'b', ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastILI(L'c', ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.FindLastILI(L'g', ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastILI(L'h', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L'A', ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L'B', ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastILI(L'G', ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastILI(L'H', ich));
    BCL_ASSERT(ich == 18);

}

template <typename TStringClass>
void
DoCheckStringFinding(
    TStringClass &rString
    )
{
    SIZE_T ich;
    bool fContains;

    SHOULDWORK(rString.Assign(L"bbbcccdddeeefffggg"));
    CHECK(rString, L"bbbcccdddeeefffggg");

    SHOULDWORK(rString.Contains(L"a", fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L"b", fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L"g", fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L"h", fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L"A", fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L"B", fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L"G", fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L"H", fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L"bb", fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L"bbb", fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L"bbc", fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L"bbbc", fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.Contains(L"bbbb", fContains));
    BCL_ASSERT(!fContains);

    SHOULDWORK(rString.Contains(L"ggg", fContains));
    BCL_ASSERT(fContains);

    SHOULDWORK(rString.FindFirst(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"b", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirst(L"c", ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirst(L"g", ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirst(L"h", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"B", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"G", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"H", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"b", ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLast(L"c", ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.FindLast(L"g", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLast(L"h", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"B", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"G", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"H", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"a", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"b", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstI(L"c", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirstI(L"g", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstI(L"h", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"A", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"B", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstI(L"G", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstI(L"H", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"a", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"b", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastI(L"c", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.FindLastI(L"g", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastI(L"h", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"A", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"B", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastI(L"G", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastI(L"H", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"b", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstILI(L"c", ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirstILI(L"g", ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstILI(L"h", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"B", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstILI(L"G", ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstILI(L"H", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"b", ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastILI(L"c", ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.FindLastILI(L"g", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastILI(L"h", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"B", ich));
    BCL_ASSERT(ich == 2);

    SHOULDWORK(rString.FindLastILI(L"G", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.FindLastILI(L"H", ich));
    BCL_ASSERT(ich == 18);


    //
    //
    //

    SHOULDWORK(rString.FindFirst(L"aa", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"bb", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirst(L"cc", ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirst(L"gg", ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirst(L"hh", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"AA", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"BB", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"GG", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirst(L"HH", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"aa", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"bb", ich));
    BCL_ASSERT(ich == 1);

    SHOULDWORK(rString.FindLast(L"cc", ich));
    BCL_ASSERT(ich == 4);

    SHOULDWORK(rString.FindLast(L"gg", ich));
    BCL_ASSERT(ich == 16);

    SHOULDWORK(rString.FindLast(L"hh", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"AA", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"BB", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"GG", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLast(L"HH", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"aa", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"bb", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstI(L"cc", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirstI(L"gg", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstI(L"hh", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"AA", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstI(L"BB", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstI(L"GG", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstI(L"HH", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"aa", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"bb", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 1);

    SHOULDWORK(rString.FindLastI(L"cc", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 4);

    SHOULDWORK(rString.FindLastI(L"gg", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 16);

    SHOULDWORK(rString.FindLastI(L"hh", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"AA", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastI(L"BB", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 1);

    SHOULDWORK(rString.FindLastI(L"GG", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 16);

    SHOULDWORK(rString.FindLastI(L"HH", BCL::CWin32CaseInsensitivityData(), ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"aa", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"bb", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstILI(L"cc", ich));
    BCL_ASSERT(ich == 3);

    SHOULDWORK(rString.FindFirstILI(L"gg", ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstILI(L"hh", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"AA", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindFirstILI(L"BB", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.FindFirstILI(L"GG", ich));
    BCL_ASSERT(ich == 15);

    SHOULDWORK(rString.FindFirstILI(L"HH", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"aa", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"bb", ich));
    BCL_ASSERT(ich == 1);

    SHOULDWORK(rString.FindLastILI(L"cc", ich));
    BCL_ASSERT(ich == 4);

    SHOULDWORK(rString.FindLastILI(L"gg", ich));
    BCL_ASSERT(ich == 16);

    SHOULDWORK(rString.FindLastILI(L"hh", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"AA", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.FindLastILI(L"BB", ich));
    BCL_ASSERT(ich == 1);

    SHOULDWORK(rString.FindLastILI(L"GG", ich));
    BCL_ASSERT(ich == 16);

    SHOULDWORK(rString.FindLastILI(L"HH", ich));
    BCL_ASSERT(ich == 18);
}

template <typename TStringClass>
void
DoSpanChecks(
    TStringClass &rString
    )
{
    SIZE_T ich;
    bool fContains;

    SHOULDWORK(rString.Assign(L"bbbcccdddeeefffggg"));
    CHECK(rString, L"bbbcccdddeeefffggg");

    SHOULDWORK(rString.Span(L"a", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.Span(L"abc", ich));
    BCL_ASSERT(ich == 6);

    SHOULDWORK(rString.Span(L"abcdefg", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.Span(L"", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.Span(L"A", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.Span(L"ABC", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.Span(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.Span(L"", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpan(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpan(L"abc", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpan(L"efg", ich));
    BCL_ASSERT(ich == 9);

    SHOULDWORK(rString.ComplementSpan(L"abcdefg", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpan(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpan(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpan(L"ABC", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpan(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpan(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.SpanILI(L"a", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.SpanILI(L"abc", ich));
    BCL_ASSERT(ich == 6);

    SHOULDWORK(rString.SpanILI(L"abcdefg", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.SpanILI(L"", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.SpanILI(L"A", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.SpanILI(L"ABC", ich));
    BCL_ASSERT(ich == 6);

    SHOULDWORK(rString.SpanILI(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.SpanILI(L"", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpanILI(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpanILI(L"abc", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpanILI(L"efg", ich));
    BCL_ASSERT(ich == 9);

    SHOULDWORK(rString.ComplementSpanILI(L"abcdefg", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpanILI(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpanILI(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ComplementSpanILI(L"ABC", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpanILI(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ComplementSpanILI(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"abc", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"fgh", ich));
    BCL_ASSERT(ich == 12);

    SHOULDWORK(rString.ReverseSpan(L"abcdefg", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseSpan(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"ABC", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"FGH", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpan(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseComplementSpan(L"a", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpan(L"abc", ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.ReverseComplementSpan(L"efg", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.ReverseComplementSpan(L"abcdefg", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.ReverseComplementSpan(L"", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpan(L"A", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpan(L"ABC", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpan(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpan(L"", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseSpanILI(L"a", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpanILI(L"abc", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpanILI(L"abcdefg", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseSpanILI(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpanILI(L"A", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpanILI(L"ABC", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseSpanILI(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseSpanILI(L"", ich));
    BCL_ASSERT(ich == 18);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"a", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"abc", ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"efg", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"abcdefg", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"A", ich));
    BCL_ASSERT(ich == 0);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"ABC", ich));
    BCL_ASSERT(ich == 5);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"ABCDEFG", ich));
    BCL_ASSERT(ich == 17);

    SHOULDWORK(rString.ReverseComplementSpanILI(L"", ich));
    BCL_ASSERT(ich == 0);
}

template <typename TStringClass>
void
DoNonNativeInChecks(
   TStringClass &rString
   )
{
    WCHAR rgwch[80];
    BCL::CWin32MBCSToUnicodeDataIn datain;
    BCL::CWin32MBCSToUnicodeDataOut dataout;
    SIZE_T cchWritten;

    datain.m_CodePage = CP_ACP;
    datain.m_dwFlags = MB_PRECOMPOSED;

    SHOULDWORK(rString.Assign(datain, "Foo", dataout));
    CHECK(rString, L"Foo");

    SHOULDWORK(rString.AssignACP("Foo!"));
    CHECK(rString, L"Foo!");

    // EBCDIC?  Yes, EBCDIC...
    const unsigned char rgABCInEBCDIC[] = { 0x81, 0x82, 0x83, 0 };

    datain.m_CodePage = 37;
    SHOULDWORK(rString.Assign(datain, (PSTR) rgABCInEBCDIC, dataout));
    CHECK(rString, L"abc");

    SHOULDWORK(rString.Assign(datain, (PSTR) rgABCInEBCDIC, 3, dataout));
    CHECK(rString, L"abc");

    // Let's try Hangul
    datain.m_CodePage = 1361;
//    const unsigned char rgHangul[] = { 0x88, 0xd0, 0x88, 0xd1, 0x88, 0xd2, 0x88, 0xd3, 0 };
    const unsigned char rgHangul[] = { 0x84, 0x42, 0x85, 0xa1, 0 };
    SHOULDWORK(rString.Assign(datain, (PSTR) rgHangul, dataout));

    SHOULDWORK(rString.CopyOut(rgwch, BCL_NUMBER_OF(rgwch), cchWritten));
    BCL_ASSERT(cchWritten == 2);
    BCL_ASSERT(rgwch[0] == 0x11a8);
    BCL_ASSERT(rgwch[1] == 0x1169);
    BCL_ASSERT(rgwch[2] == 0);
}

template <typename TStringClass>
void
DoNonNativeOutChecks(
   TStringClass &rString
   )
{
    CHAR rgch[80];
    BCL::CWin32UnicodeToMBCSDataIn datain;
    BCL::CWin32UnicodeToMBCSDataOut dataout;
    SIZE_T cchWritten;
    PSTR psz = NULL;

    SHOULDWORK(rString.Assign(L"Foo"));
    CHECK(rString, L"Foo");

    datain.m_CodePage = CP_ACP;
    datain.m_dwFlags = 0;
    dataout.m_lpDefaultChar = NULL;
    dataout.m_lpUsedDefaultChar = NULL;

    SHOULDWORK(rString.CopyOut(datain, rgch, BCL_NUMBER_OF(rgch), dataout, cchWritten));
    BCL_ASSERT(cchWritten == 3);
    BCL_ASSERT(rgch[0] == 'F');
    BCL_ASSERT(rgch[1] == 'o');
    BCL_ASSERT(rgch[2] == 'o');
    BCL_ASSERT(rgch[3] == 0);

    SHOULDWORK(rString.CopyOutACP(rgch, BCL_NUMBER_OF(rgch), cchWritten));
    BCL_ASSERT(cchWritten == 3);
    BCL_ASSERT(rgch[0] == 'F');
    BCL_ASSERT(rgch[1] == 'o');
    BCL_ASSERT(rgch[2] == 'o');
    BCL_ASSERT(rgch[3] == 0);

    SHOULDFAIL(rString.CopyOut(datain, rgch, 0, dataout, cchWritten), ERROR_BUFFER_OVERFLOW);
    SHOULDFAIL(rString.CopyOut(datain, rgch, 1, dataout, cchWritten), ERROR_BUFFER_OVERFLOW);
    SHOULDFAIL(rString.CopyOut(datain, rgch, 2, dataout, cchWritten), ERROR_BUFFER_OVERFLOW);
    SHOULDFAIL(rString.CopyOut(datain, rgch, 3, dataout, cchWritten), ERROR_BUFFER_OVERFLOW);

    SHOULDWORK(rString.CopyOut(datain, psz, dataout, cchWritten));
    BCL_ASSERT(cchWritten == 3);
    BCL_ASSERT(
        (psz != NULL) &&
        (psz[0] == 'F') &&
        (psz[1] == 'o') &&
        (psz[2] == 'o') &&
        (psz[3] == 0));
    ::HeapFree(::GetProcessHeap(), 0, psz);
    psz = NULL;

    SHOULDWORK(rString.CopyOutACP(psz, cchWritten));
    BCL_ASSERT(cchWritten == 3);
    BCL_ASSERT(
        (psz != NULL) &&
        (psz[0] == 'F') &&
        (psz[1] == 'o') &&
        (psz[2] == 'o') &&
        (psz[3] == 0));
    ::HeapFree(::GetProcessHeap(), 0, psz);
    psz = NULL;
}

template <typename TStringClass>
void
DoChecks(
    TStringClass &rString,
    DWORD dwMassiveStringErrorCode
    )
{
    bool fEquals;
    int iComparisonResult;
    SIZE_T cchExtra;
    BCL::CWin32CaseInsensitivityData cidTurkish(MAKELCID(MAKELANGID(LANG_TURKISH, SUBLANG_DEFAULT), SORT_DEFAULT), LCMAP_LINGUISTIC_CASING);
    BCL::CWin32CaseInsensitivityData cidGerman(MAKELCID(MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN), SORT_DEFAULT));
    BCL::CWin32CaseInsensitivityData cidFrench(MAKELCID(MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH_SWISS), SORT_DEFAULT));
    BCL::CWin32CaseInsensitivityData cidUKEnglish(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK), SORT_DEFAULT));
    BCL::CWin32CaseInsensitivityData cidUSEnglish(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT));

    SHOULDWORK(rString.Assign(L"hello", 5));
    CHECK(rString, L"hello");
    SHOULDWORK(rString.Append(L" there", 6));
    CHECK(rString, L"hello there");
    SHOULDWORK(rString.Prepend(L"Why ", 4));
    CHECK(rString, L"Why hello there");
    SHOULDWORK(rString.Prepend(L'_'));
    CHECK(rString, L"_Why hello there");

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendFill(L'x', 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AssignFill(L'x', 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L'y', 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L'y', 20, cchExtra));
    CHECK(rString, L"xxxxxxxxxxyyyyyyyyyy");
    BCL_ASSERT(cchExtra == 0);

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendFill(L"xx", 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AssignFill(L"xx", 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"yy", 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"yy", 20, cchExtra));
    CHECK(rString, L"xxxxxxxxxxyyyyyyyyyy");
    BCL_ASSERT(cchExtra == 0);

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendFill(L"x1", 10, cchExtra));
    CHECK(rString, L"x1x1x1x1x1");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AssignFill(L"x2", 10, cchExtra));
    CHECK(rString, L"x2x2x2x2x2");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"y3", 10, cchExtra));
    CHECK(rString, L"x2x2x2x2x2");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"y4", 20, cchExtra));
    CHECK(rString, L"x2x2x2x2x2y4y4y4y4y4");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.Assign(L"12345"));
    CHECK(rString, L"12345");

    SHOULDWORK(rString.AppendFill(L"67890", 7, cchExtra));
    CHECK(rString, L"12345");
    BCL_ASSERT(cchExtra == 2);

    SHOULDWORK(rString.AppendFill(L"67890", 12, cchExtra));
    CHECK(rString, L"1234567890");
    BCL_ASSERT(cchExtra == 2);

    SHOULDWORK(rString.AssignFill(L"12345", 3, cchExtra));
    CHECK(rString, L"");
    BCL_ASSERT(cchExtra == 3);

    SHOULDWORK(rString.AssignFill(L"12345", 8, cchExtra));
    CHECK(rString, L"12345");
    BCL_ASSERT(cchExtra == 3);

    SHOULDWORK(rString.AssignFill(L"12345", 13, cchExtra));
    CHECK(rString, L"1234512345");
    BCL_ASSERT(cchExtra == 3);

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendFill(L"xx", 2, 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AssignFill(L"xx", 2, 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"yy", 2, 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"yy", 2, 20, cchExtra));
    CHECK(rString, L"xxxxxxxxxxyyyyyyyyyy");
    BCL_ASSERT(cchExtra == 0);

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendFill(L"x1", 2, 10, cchExtra));
    CHECK(rString, L"x1x1x1x1x1");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AssignFill(L"x2", 2, 10, cchExtra));
    CHECK(rString, L"x2x2x2x2x2");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"y3", 2, 10, cchExtra));
    CHECK(rString, L"x2x2x2x2x2");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"y4", 2, 20, cchExtra));
    CHECK(rString, L"x2x2x2x2x2y4y4y4y4y4");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.Assign(L"12345", 5));
    CHECK(rString, L"12345");

    SHOULDWORK(rString.AppendFill(L"67890", 5, 7, cchExtra));
    CHECK(rString, L"12345");
    BCL_ASSERT(cchExtra == 2);

    SHOULDWORK(rString.AppendFill(L"67890", 5, 12, cchExtra));
    CHECK(rString, L"1234567890");
    BCL_ASSERT(cchExtra == 2);

    SHOULDWORK(rString.AssignFill(L"12345", 5, 3, cchExtra));
    CHECK(rString, L"");
    BCL_ASSERT(cchExtra == 3);

    SHOULDWORK(rString.AssignFill(L"12345", 5, 8, cchExtra));
    CHECK(rString, L"12345");
    BCL_ASSERT(cchExtra == 3);

    SHOULDWORK(rString.AssignFill(L"12345", 5, 13, cchExtra));
    CHECK(rString, L"1234512345");
    BCL_ASSERT(cchExtra == 3);

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendFill(L"xxy", 2, 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AssignFill(L"xxz", 2, 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"yya", 2, 10, cchExtra));
    CHECK(rString, L"xxxxxxxxxx");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"yya", 2, 20, cchExtra));
    CHECK(rString, L"xxxxxxxxxxyyyyyyyyyy");
    BCL_ASSERT(cchExtra == 0);

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendFill(L"x1d", 2, 10, cchExtra));
    CHECK(rString, L"x1x1x1x1x1");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AssignFill(L"x2d", 2, 10, cchExtra));
    CHECK(rString, L"x2x2x2x2x2");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"y3d", 2, 10, cchExtra));
    CHECK(rString, L"x2x2x2x2x2");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.AppendFill(L"y4d", 2, 20, cchExtra));
    CHECK(rString, L"x2x2x2x2x2y4y4y4y4y4");
    BCL_ASSERT(cchExtra == 0);

    SHOULDWORK(rString.Assign(L"12345", 5));
    CHECK(rString, L"12345");

    SHOULDWORK(rString.AppendFill(L"67890xxx", 5, 7, cchExtra));
    CHECK(rString, L"12345");
    BCL_ASSERT(cchExtra == 2);

    SHOULDWORK(rString.AppendFill(L"67890xxx", 5, 12, cchExtra));
    CHECK(rString, L"1234567890");
    BCL_ASSERT(cchExtra == 2);

    SHOULDWORK(rString.AssignFill(L"12345xxx", 5, 3, cchExtra));
    CHECK(rString, L"");
    BCL_ASSERT(cchExtra == 3);

    SHOULDWORK(rString.AssignFill(L"12345xxx", 5, 8, cchExtra));
    CHECK(rString, L"12345");
    BCL_ASSERT(cchExtra == 3);

    SHOULDWORK(rString.AssignFill(L"12345xxx", 5, 13, cchExtra));
    CHECK(rString, L"1234512345");
    BCL_ASSERT(cchExtra == 3);

    SHOULDWORK(rString.AssignRepeat(L"abc", 5));
    CHECK(rString, L"abcabcabcabcabc");

    SHOULDWORK(rString.AppendRepeat(L"def", 5));
    CHECK(rString, L"abcabcabcabcabcdefdefdefdefdef");

    SHOULDWORK(rString.AssignRepeat(L"abc", 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendRepeat(L"def", 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.AssignRepeat(L"abc", 3, 5));
    CHECK(rString, L"abcabcabcabcabc");

    SHOULDWORK(rString.AppendRepeat(L"def", 3, 5));
    CHECK(rString, L"abcabcabcabcabcdefdefdefdefdef");

    SHOULDWORK(rString.AssignRepeat(L"abc", 3, 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendRepeat(L"def", 3, 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.AssignRepeat(L"abc", 0, 5));
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendRepeat(L"def", 0, 5));
    CHECK(rString, L"");

    SHOULDWORK(rString.AssignRepeat(L"abc", 0, 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendRepeat(L"def", 0, 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.AssignRepeat(L'a', 5));
    CHECK(rString, L"aaaaa");

    SHOULDWORK(rString.AppendRepeat(L'd', 5));
    CHECK(rString, L"aaaaaddddd");

    SHOULDWORK(rString.AssignRepeat(L'a', 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.AppendRepeat(L'd', 0));
    CHECK(rString, L"");

    SHOULDWORK(rString.Assign(L"1234512345"));
    CHECK(rString, L"1234512345");

    SHOULDFAIL(rString.Assign(3, L"hello there", INT_MAX, L"hi again", INT_MAX, L"Still me", INT_MAX), ERROR_ARITHMETIC_OVERFLOW);
    CHECK(rString, L"1234512345");

    SHOULDWORK(rString.Assign(3, L"hello there", -1, L"hi again", -1, L"Still me", -1));
    CHECK(rString, L"hello therehi againStill me");

    SHOULDWORK(rString.Assign(5, L"foo", 3, L"bar", 3, L"baz", 3, L"eieio", 5, L"mumble", 6));
    CHECK(rString, L"foobarbazeieiomumble");

    SHOULDWORK(rString.Equals(L"hello there", 11, fEquals));
    BCL_ASSERT(!fEquals);

    SHOULDWORK(rString.Equals(L"foobarbazeieiomumble", 20, fEquals));
    BCL_ASSERT(fEquals);

    SHOULDWORK(rString.Equals(L"FooBarBazEieioMumble", 20, fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsI(L"hello there", 11, BCL::CWin32CaseInsensitivityData(), fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L"foobarbazeieiomumble", 20, fEquals));
    BCL_ASSERT(fEquals);
    SHOULDWORK(rString.EqualsILI(L"foobarbazeieio", 14, fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L"foobarbazeieiomumblexyz", 23, fEquals));
    BCL_ASSERT(!fEquals);
    SHOULDWORK(rString.EqualsILI(L"FooBarBazEieioMumble", 20, fEquals));
    BCL_ASSERT(fEquals);

    SHOULDWORK(rString.Compare(L"foo", 3, iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.Compare(L"foozle", 6, iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);
    SHOULDWORK(rString.CompareI(L"FOO", 3, cidUSEnglish, iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.CompareI(L"FOOZLE", 6, BCL::CWin32CaseInsensitivityData(), iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);
    SHOULDWORK(rString.CompareILI(L"foobarbazeieiomumble", 20, iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_EQUAL);
    SHOULDWORK(rString.CompareILI(L"foobarbazeieio", 14, iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_GREATER_THAN);
    SHOULDWORK(rString.CompareILI(L"foobarbazeieiomumblexyz", 23, iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_LESS_THAN);
    SHOULDWORK(rString.CompareILI(L"FooBarBazEieioMumble", 20, iComparisonResult));
    BCL_ASSERT(iComparisonResult == CSTR_EQUAL);

    rString.Clear();
    for (ULONG i=0; i<1000; i++)
    {
        if (!rString.Append(L"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"))
        {
            const DWORD dwLastError = ::GetLastError();
            BCL_ASSERT(dwLastError == dwMassiveStringErrorCode);
            break;
        }
    }

    SHOULDFAIL(rString.Assign(L"hello", 1 << 30), dwMassiveStringErrorCode);
    SHOULDFAIL(rString.Assign(L"hello", 0xffffffff), ERROR_ARITHMETIC_OVERFLOW);

    // Do it again without lengths...
    SHOULDWORK(rString.Assign(L"hello"));
    CHECK(rString, L"hello");
    SHOULDWORK(rString.Append(L" there"));
    CHECK(rString, L"hello there");
    SHOULDWORK(rString.Prepend(L"Why "));
    CHECK(rString, L"Why hello there");

    rString.Clear();
    CHECK(rString, L"");

    SHOULDWORK(rString.Assign(5, L"foo", 3, L"bar", 3, L"baz", 3, L"eieio", 5, L"mumble", 6));
    CHECK(rString, L"foobarbazeieiomumble");

    DoCheckCaseInsensitiveComparisons(rString);
    DoCheckCaseSensitiveComparisons(rString);

    SHOULDWORK(rString.Assign(L"MixedCase"));
    CHECK(rString, L"MixedCase");

    SHOULDWORK(rString.Assign(L"MixedCase"));
    CHECK(rString, L"MixedCase");

    SHOULDWORK(rString.UpperCase(cidUSEnglish));
    CHECK(rString, L"MIXEDCASE");

    SHOULDWORK(rString.Assign(L"MixedCase"));
    CHECK(rString, L"MixedCase");

    SHOULDWORK(rString.LowerCase(BCL::CWin32CaseInsensitivityData()));
    CHECK(rString, L"mixedcase");

    // Let's make that Turkish I thing happen...
    SHOULDWORK(rString.Assign(L"IxedCase"));
    CHECK(rString, L"IxedCase");

    SHOULDWORK(rString.LowerCase(cidTurkish));
    CHECK(rString, L"\x0131xedcase");



    SHOULDWORK(rString.Assign(L"MixedCase"));
    CHECK(rString, L"MixedCase");

    SHOULDWORK(rString.UpperCaseILI());
    CHECK(rString, L"MIXEDCASE");

    SHOULDWORK(rString.Assign(L"MixedCase"));
    CHECK(rString, L"MixedCase");

    SHOULDWORK(rString.LoweCaseILI());
    CHECK(rString, L"mixedcase");

    SHOULDWORK(rString.Assign(L"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"));
    CHECK(rString, L"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789");

    // verify behavior for shrinking buffer
    SHOULDWORK(rString.Assign(L"0123456789"));
    CHECK(rString, L"0123456789");

    DoCheckCharacterFinding(rString);
    DoCheckStringFinding(rString);
    DoSpanChecks(rString);
    DoNonNativeInChecks(rString);
    DoNonNativeOutChecks(rString);
}

__declspec(noinline)
void DoCaseStuff()
{
    ULONG i, j;
    FILE *f = fopen("results.txt", "w");
    if (f == NULL)
    {
        perror("Failed to open results.txt");
        return;
    }

    WCHAR *rgwchSource = new WCHAR[65536];
    WCHAR *rgwchUpper = new WCHAR[65536];
    WCHAR *rgwchLower = new WCHAR[65536];

    for (i=0; i<65536; i++)
        rgwchSource[i] = (WCHAR) i;

    for (i=0; i<65536; i++)
    {
        if (::LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, &rgwchSource[i], 1, &rgwchUpper[i], 1) == 0)
        {
            fprintf(f, "Uppercase mapping of U+%04x failed; GetLastError() = %d\n", rgwchSource[i], ::GetLastError());
            rgwchUpper[i] = 0xffff;
        }

        if (::LCMapStringW(LOCALE_INVARIANT, LCMAP_LOWERCASE, &rgwchSource[i], 1, &rgwchLower[i], 1) == 0)
        {
            fprintf(f, "Uppercase mapping of U+%04x failed; GetLastError() = %d\n", rgwchSource[i], ::GetLastError());
            rgwchLower[i] = 0xffff;
        }
    }

    fprintf(f, "\nUpper case mappings follow:\n");

    for (i=0; i<65536; i++)
    {
        if (rgwchUpper[i] != i)
            fprintf(f, "U+%04x -> U+%04x\n", i, rgwchUpper[i]);
    }

    fprintf(f, "\nLower case mappings follow:\n");

    for (i=0; i<65536; i++)
    {
        if (rgwchLower[i] != i)
            fprintf(f, "U+%04x -> U+%04x\n", i, rgwchLower[i]);
    }

    fprintf(f, "\nUpper case mappings where LCMapString disagrees with CharUpper:\nOrig, LCMapString, CharUpper\n");

    for (i=0; i<65536; i++)
    {
        if (((WCHAR) CharUpperW((LPWSTR) i)) != rgwchUpper[i])
            fprintf(f, "U+%04x,U+%04x,U+%04x\n", i, rgwchUpper[i], (WCHAR) CharUpperW((LPWSTR) i));
    }

    fprintf(f, "\nLower case mappings where LCMapString disagrees with CharLower:\nOrig, LCMapString, CharLower\n");

    for (i=0; i<65536; i++)
    {
        if (((WCHAR) CharLowerW((LPWSTR) i)) != rgwchLower[i])
            fprintf(f, "U+%04x,U+%04x,U+%04x\n", i, rgwchLower[i], (WCHAR) CharLowerW((LPWSTR) i));
    }

    fprintf(f, "\n Upper case mappings where the lower case mapping is not identity:\n Orig -> Upper -> Lower\n");

    for (i=0; i<65536; i++)
    {
        // temporaries used for clarity
        const WCHAR wchUpper = rgwchUpper[i];
        if (wchUpper != i)
        {
            const WCHAR wchLower = rgwchLower[wchUpper];
            if (wchLower != i)
                fprintf(f, "U+%04x -> U+%04x -> U+%04x\n", i, wchUpper, wchLower);
        }
    }

    fprintf(f, "\n Lower case mappings where the upper case mapping is not identity:\n Orig -> Lower -> Upper\n");

    for (i=0; i<65536; i++)
    {
        // temporaries used for clarity
        const WCHAR wchLower = rgwchLower[i];
        if (wchLower != i)
        {
            const WCHAR wchUpper = rgwchUpper[wchLower];
            if (wchUpper != i)
                fprintf(f, "U+%04x -> U+%04x -> U+%04x\n", i, wchLower, wchUpper);
        }
    }

    fprintf(f, "\n Lower-case mappings where CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, ...) says they're not equal \n");

    for (i=0; i<65536; i++)
    {
        const WCHAR wchSource = (WCHAR) i;
        const WCHAR wchLower = rgwchLower[i];
        if (wchLower != i)
        {
            int iResult = CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &wchSource, 1, &wchLower, 1);
            if (iResult == 0)
                fprintf(f, "*** Error comparing U+%04x and U+%04x - Win32 Error = %d\n", i, wchLower, GetLastError());
            else if (iResult != CSTR_EQUAL)
                fprintf(f, "U+%04x -> U+%04x but CompareString says %s (%d)\n",
                    i,
                    wchLower,
                    (iResult == CSTR_GREATER_THAN) ? "CSTR_GREATER_THAN" : ((iResult == CSTR_LESS_THAN) ? "CSTR_LESS_THAN" : "Invalid return value"),
                    iResult);
        }
    }

    fprintf(f, "\nUpper-case mappings where CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, ...) says they're not equal \n");

    for (i=0; i<65536; i++)
    {
        const WCHAR wchSource = (WCHAR) i;
        const WCHAR wchUpper = rgwchUpper[i];
        if (wchUpper != i)
        {
            int iResult = CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &wchSource, 1, &wchUpper, 1);
            if (iResult == 0)
                fprintf(f, "*** Error comparing U+%04x and U+%04x - Win32 Error = %d\n", i, wchUpper, GetLastError());
            else if (iResult != CSTR_EQUAL)
                fprintf(f, "U+%04x -> U+%04x but CompareString says %s (%d)\n",
                    i,
                    wchUpper,
                    (iResult == CSTR_GREATER_THAN) ? "CSTR_GREATER_THAN" : ((iResult == CSTR_LESS_THAN) ? "CSTR_LESS_THAN" : "Invalid return value"),
                    iResult);
        }
    }

#if 0
    fprintf(f, "\nPairs where CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, ...) says equal but not same in upper\n");

    for (i=1; i<65536; i++)
    {
        for (j=i+1; j<65536; j++)
        {
            WCHAR wch1 = (WCHAR) i;
            WCHAR wch2 = (WCHAR) j;

            int iResult = ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &wch1, 1, &wch2, 1);
            if (iResult == 0)
                fprintf(f, "*** Error comparing U+%04x and U+%04x - Win32 Error = %d\n", wch1, wch2, GetLastError());
            else
            {
                if (iResult == CSTR_EQUAL)
                {
                    if (rgwchUpper[i] != rgwchUpper[j])
                    {
//                        fprintf(f, "U+%04x -> U+%04x and U+%04x -> U+%04x but CompareString says CSTR_EQUAL\n", i, rgwchUpper[i], j, rgwchUpper[j]);
                        fprintf(f, "[%04x -> %04x] and [%04x -> %04x] =\n", i, rgwchUpper[i], j, rgwchUpper[j]);
                    }
                }
                else
                {
                    if (rgwchUpper[i] == rgwchUpper[j])
                        fprintf(
                            f,
                            "[%04x -> %04x] and [%04x -> %04x] %s\n", i, rgwchUpper[i], j, rgwchUpper[j],
                            (iResult == CSTR_GREATER_THAN) ? ">" : ((iResult == CSTR_LESS_THAN) ? "<" : "?"));
                }
            }
        }
    }

    fprintf(f, "\nPairs where CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, ...) says equal but not same in Lower\n");

    for (i=1; i<65536; i++)
    {
        for (j=i+1; j<65536; j++)
        {
            WCHAR wch1 = (WCHAR) i;
            WCHAR wch2 = (WCHAR) j;

            int iResult = ::CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, &wch1, 1, &wch2, 1);
            if (iResult == 0)
                fprintf(f, "*** Error comparing U+%04x and U+%04x - Win32 Error = %d\n", wch1, wch2, GetLastError());
            else
            {
                if (iResult == CSTR_EQUAL)
                {
                    if (rgwchLower[i] != rgwchLower[j])
                        fprintf(f, "U+%04x -> U+%04x and U+%04x -> U+%04x but CompareString says CSTR_EQUAL\n", i, rgwchLower[i], j, rgwchLower[j]);
                }
                else
                {
                    if (rgwchLower[i] == rgwchLower[j])
                        fprintf(
                            f,
                            "U+%04x -> U+%04x and U+%04x -> U+%04x but CompareString says %s (%d)\n", i, rgwchLower[i], j, rgwchLower[j],
                            (iResult == CSTR_GREATER_THAN) ? "CSTR_GREATER_THAN" : ((iResult == CSTR_LESS_THAN) ? "CSTR_LESS_THAN" : "Invalid return value"),
                            iResult);
                }
            }
        }
    }
#endif // 0


    delete []rgwchSource;
    delete []rgwchUpper;
    delete []rgwchLower;
    fclose(f);

}

void TestCodePage(UINT cp)
{
    SIZE_T i;
    UCHAR ch1, ch2;
    WCHAR wch1, wch2;
    FILE *f;
    CHAR buff[80];
    WCHAR wchBuff[132];

    sprintf(buff, "results_%d.txt", cp);
    f = fopen(buff, "w");
    if (!f)
    {
        perror("Error opening output file");
        // exit(EXIT_FAILURE);
        return;
    }

    for (i=0; i<256; i++)
    {
        buff[0] = (CHAR) i;

        if (::IsDBCSLeadByteEx(cp, buff[0]))
        {
            SIZE_T j;
            
            fprintf(f, "Lead byte: 0x%x\n", i);

            for (j=0; j<256; j++)
            {
                buff[1] = (CHAR) j;

                int iResult = ::MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, buff, 2, wchBuff, 132);
                if (iResult == 0)
                {
                    const DWORD dwLastError = ::GetLastError();
                    if (dwLastError != ERROR_NO_UNICODE_TRANSLATION)
                        fprintf(f, "(0x%x, 0x%x) Failed; GetLastError() = %d\n", i, j, dwLastError);
                }
                else
                {
                    if (iResult != 1)
                    {
                        if (iResult == 2)
                            fprintf(f, "(0x%x, 0x%x) -> (0x%x, 0x%x)\n", i, j, wchBuff[0], wchBuff[1]);
                        else
                            fprintf(f, "(0x%x, 0x%x) -> (0x%x, 0x%x, ...) (%d total)\n", i, j, wchBuff[0], wchBuff[1], iResult);
                    }

                    // Let's apply the upper casing rules in both places and see what happens.
                    int iResult2 = LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, wchBuff, iResult, wchBuff, iResult);
                    if (iResult2 == 0)
                    {
                        const DWORD dwLastError = ::GetLastError();
                        fprintf(f, "Upper casing unicode char 0x%04x [%d total] failed; last error = %u\n", wchBuff[0], iResult, dwLastError);
                    }
                    else
                    {
                        BOOL fUsedDefaultChar = FALSE;
                        // back to oem!
                        int iResult3 = ::WideCharToMultiByte(
                                cp,
                                WC_NO_BEST_FIT_CHARS,
                                wchBuff,
                                iResult2,
                                buff,
                                sizeof(buff),
                                NULL,
                                &fUsedDefaultChar);
                        if (iResult3 == 0)
                        {
                            const DWORD dwLastError = ::GetLastError();
                            fprintf(f, "Converting Unicode 0x%04x back to mbcs failed; last error = %u\n", wchBuff[0], iResult2, dwLastError);
                        }
                        else
                        {
                            fprintf(f, "(0x%x, 0x%x) -> (0x%x, 0x%x)\n", i, j, buff[0], buff[1]);
                        }
                    }
                }
            }
        }
        else
        {
            // single byte.  Hopefully easier.
            buff[0] = (CHAR) i;
            int iResult = ::MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, buff, 1, wchBuff, 132);
            if (iResult == 0)
            {
                const DWORD dwLastError = ::GetLastError();
                if (dwLastError != ERROR_NO_UNICODE_TRANSLATION)
                    fprintf(f, "(0x%x) Failed; GetLastError() = %d\n", i, dwLastError);
            }
            else
            {
                if (iResult != 1)
                {
                    if (iResult == 2)
                        fprintf(f, "MBCS (0x%x) -> Unicode (0x%x, 0x%x)\n", i, wchBuff[0], wchBuff[1]);
                    else
                        fprintf(f, "MBCS (0x%x) -> Unicode (0x%x, 0x%x, ...) (%d total)\n", i, wchBuff[0], wchBuff[1], iResult);
                }

                // Let's apply the upper casing rules in both places and see what happens.
                int iResult2 = LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, wchBuff, iResult, wchBuff, iResult);
                if (iResult2 == 0)
                {
                    const DWORD dwLastError = ::GetLastError();
                    fprintf(f, "Upper casing unicode char 0x%04x [%d total] failed; last error = %u\n", wchBuff[0], iResult, dwLastError);
                }
                else
                {
                    BOOL fUsedDefaultChar = FALSE;
                    // back to oem!
                    int iResult3 = ::WideCharToMultiByte(
                            cp,
                            WC_NO_BEST_FIT_CHARS,
                            wchBuff,
                            iResult2,
                            buff,
                            sizeof(buff),
                            NULL,
                            &fUsedDefaultChar);
                    if (iResult3 == 0)
                    {
                        const DWORD dwLastError = ::GetLastError();
                        fprintf(f, "Converting Unicode 0x%04x back to mbcs failed; last error = %u\n", wchBuff[0], iResult2, dwLastError);
                    }
                    else
                    {
                        if (fUsedDefaultChar)
                        {
                            fprintf(f, "MBCS (0x%x) -> unicode defualt char\n", i);
                        }
                        else
                        {
                            if (iResult3 == 1)
                            {
                                if (((UCHAR) buff[0]) != i)
                                    fprintf(f, "MBCS (0x%x) -> MBCS (0x%x)\n", i, (UCHAR) buff[0]);
                            }
                            else
                                fprintf(f, "MBCS (0x%x) -> MBCS (0x%x) (%d total)\n", i, (UCHAR) buff[0], iResult3);
                        }
                    }
                }
            }
        }
    }

    fclose(f);
}

int __cdecl main(int argc, char *argv[])
{
    TestCodePage(437);
    TestCodePage(850);

#if 0
    DoCaseStuff();
#endif // 0

    BCL::CWin32BaseUnicodeInlineStringBuffer<50> foo;
    BCL::CWin32UnicodeStringBuffer bar;
    BCL::CWin32BaseUnicodeFixedStringBuffer<260> baz;

    DoChecks(foo, ERROR_OUTOFMEMORY);
    DoChecks(bar, ERROR_OUTOFMEMORY);
    DoChecks(baz, ERROR_BUFFER_OVERFLOW);

    printf("%s\n", foo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\loader.inc ===
!IF "$(ENABLE_LOADER_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_LOADER_DEBUG="\"$(ENABLE_LOADER_DEBUG)"\"
!else
# Only allow MSC_OPTIMIZATION to be changed if the debugger is enabled
# otherwise, no_opt razzle windows won't be able to boot (loader too big)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!ENDIF

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

VC7_SYMBOLS=1

# No overflow checking for the loader
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\loader_dbg.inc ===
#
# set the flags necessary to build debug enabled boot loaders
#

#
# the ; is a temporary hack to make this compile until is made
# clear how to make the ##'s not get translated into CR's
#

ENABLE_LOADER_DEBUG=debugport=com1;debugbaudrate=115200

#
#
#

!include $(PROJECT_ROOT)\boot\loader.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\break.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    break.c

Abstract:

    This module implements machine dependent functions to add and delete
    breakpoints from the kernel debugger breakpoint table.

Author:

    David N. Cutler 2-Aug-1990

Revision History:

--*/

#include "bd.h"

LOGICAL BreakpointsSuspended = FALSE;

//
// Define external references.
//

LOGICAL
BdLowWriteContent(
    ULONG Index
    );

LOGICAL
BdLowRestoreBreakpoint(
    ULONG Index
    );


ULONG
BdAddBreakpoint (
    IN ULONG64 Address
    )

/*++

Routine Description:

    This routine adds an entry to the breakpoint table and returns a handle
    to the breakpoint table entry.

Arguments:

    Address - Supplies the address where to set the breakpoint.

Return Value:

    A value of zero is returned if the specified address is already in the
    breakpoint table, there are no free entries in the breakpoint table, the
    specified address is not correctly aligned, or the specified address is
    not valid. Otherwise, the index of the assigned breakpoint table entry
    plus one is returned as the function value.

--*/

{

    BD_BREAKPOINT_TYPE Content;
    ULONG Index;
    BOOLEAN Accessible;
#if defined(_IA64_)
    HARDWARE_PTE Opaque;
#endif

    //DPRINT(("KD: Setting breakpoint at 0x%08x\n", Address));
    //
    // If the specified address is not properly aligned, then return zero.
    //

    if (((ULONG_PTR)Address & BD_BREAKPOINT_ALIGN) != 0) {
        return 0;
    }

    //
    // Get the instruction to be replaced. If the instruction cannot be read,
    // then mark the breakpoint as not accessible.
    //

    if (BdMoveMemory((PCHAR)&Content,
                      (PCHAR)Address,
                      sizeof(BD_BREAKPOINT_TYPE) ) != sizeof(BD_BREAKPOINT_TYPE)) {
        Accessible = FALSE;
        //DPRINT(("KD: memory inaccessible\n"));

    } else {
        //DPRINT(("KD: memory readable...\n"));
        Accessible = TRUE;
    }

    //
    // If the specified address is not write accessible, then return zero.
    //

    if (Accessible && BdWriteCheck((PVOID)Address) == NULL) {
        //DPRINT(("KD: memory not writable!\n"));
        return 0;
    }

    //
    // Search the breakpoint table for a free entry and check if the specified
    // address is already in the breakpoint table.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (BdBreakpointTable[Index].Flags == 0) {
            break;
        }
    }

    //
    // If a free entry was found, then write breakpoint and return the handle
    // value plus one. Otherwise, return zero.
    //

    if (Index == BREAKPOINT_TABLE_SIZE) {
        //DPRINT(("KD: ran out of breakpoints!\n"));
        return 0;
    }

    //DPRINT(("KD: using Index %d\n", Index));

#if defined(_IA64_)
    if (Accessible) {
        BD_BREAKPOINT_TYPE mBuf;
        PVOID BundleAddress;

        // change template to type 0 if current instruction is MLI

        // read in intruction template if current instruction is NOT slot 0.
        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.

        if (((ULONG_PTR)Address & 0xf) != 0) {
            (ULONG_PTR)BundleAddress = (ULONG_PTR)Address & ~(0xf);
            if (BdMoveMemory(
                    (PCHAR)&mBuf,
                    (PCHAR)BundleAddress,
                    sizeof(BD_BREAKPOINT_TYPE)
                    ) != sizeof(BD_BREAKPOINT_TYPE)) {
                //DPRINT(("KD: read 0x%08x template failed\n", BundleAddress));
                // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                return 0;
            } else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IA64_MOVL;
                        if (BdMoveMemory(
                                (PCHAR)BundleAddress,
                                (PCHAR)&mBuf,
                                sizeof(BD_BREAKPOINT_TYPE)
                                ) != sizeof(BD_BREAKPOINT_TYPE)) {
                            //DPRINT(("KD: write to 0x%08x template failed\n", BundleAddress));
                            // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                            return 0;
                         }
                         else {
                             //DPRINT(("KD: change MLI template to type 0 at 0x%08x set\n", Address));
                         }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         //DPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%08x\n", BundleAddress));
                         // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                         return 0;
                    }
                }
            }
        }

        // insert break instruction

        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Content = Content;
        BdBreakpointTable[Index].Flags &= ~(BD_BREAKPOINT_STATE_MASK);
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IN_USE;
#if 0
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            BdBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
            }
#endif
            switch ((ULONG_PTR)Address & 0xf) {
            case 0:
                Content = (Content & ~(INST_SLOT0_MASK)) | (BdBreakpointInstruction << 5);
                break;

            case 4:
                Content = (Content & ~(INST_SLOT1_MASK)) | (BdBreakpointInstruction << 14);
                break;

            case 8:
                Content = (Content & ~(INST_SLOT2_MASK)) | (BdBreakpointInstruction << 23);
                break;

            default:
                // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                //DPRINT(("KD: BdAddBreakpoint bad instruction slot#\n"));
                return 0;
            }
            if (BdMoveMemory(
                    (PCHAR)Address,
                    (PCHAR)&Content,
                    sizeof(BD_BREAKPOINT_TYPE)
                    ) != sizeof(BD_BREAKPOINT_TYPE)) {

                // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                //DPRINT(("KD: BdMoveMemory failed writing BP!\n"));
                return 0;
            }
            else {
                //DPRINT(("KD: breakpoint at 0x%08x set\n", Address));
            }
        // MmDbgReleaseAddress((PVOID) Address, &Opaque);

    } else {  // memory not accessible
        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Flags &= ~(BD_BREAKPOINT_STATE_MASK);
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IN_USE;
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: breakpoint write deferred\n"));
    }
#else    // _IA64_
    if (Accessible) {
        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Content = Content;
        BdBreakpointTable[Index].Flags = BD_BREAKPOINT_IN_USE;
        if (BdMoveMemory((PCHAR)Address,
                          (PCHAR)&BdBreakpointInstruction,
                          sizeof(BD_BREAKPOINT_TYPE)) != sizeof(BD_BREAKPOINT_TYPE)) {

            //DPRINT(("KD: BdMoveMemory failed writing BP!\n"));
        }

    } else {
        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Flags = BD_BREAKPOINT_IN_USE | BD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: breakpoint write deferred\n"));
    }
#endif // _IA64_

    return Index + 1;
}

LOGICAL
BdLowWriteContent (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to replace the code that a breakpoint is
    written over.  This routine, BdAddBreakpoint,
    BdLowRestoreBreakpoint and KdSetOwedBreakpoints are responsible
    for getting data written as requested.  Callers should not
    examine or use BdOweBreakpoints, and they should not set the
    NEEDS_WRITE or NEEDS_REPLACE flags.

    Callers must still look at the return value from this function,
    however: if it returns FALSE, the breakpoint record must not be
    reused until KdSetOwedBreakpoints has finished with it.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be deleted.

Return Value:

    Returns TRUE if the breakpoint was removed, FALSE if it was deferred.

--*/

{
#if defined(_IA64_)
    BD_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif

    //
    // Do the contents need to be replaced at all?
    //

    if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_NEEDS_WRITE) {

        //
        // The breakpoint was never written out.  Clear the flag
        // and we are done.
        //

        BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: Breakpoint at 0x%08x never written; flag cleared.\n",
        //    BdBreakpointTable[Index].Address));
        return TRUE;
    }

#if !defined(_IA64_)
    if (BdBreakpointTable[Index].Content == BdBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        //DPRINT(("KD: Breakpoint at 0x%08x; instr is really BP; flag cleared.\n",
        //    BdBreakpointTable[Index].Address));

        return TRUE;
    }
#endif

    //
    // Restore the instruction contents.
    //

#if defined(_IA64_)
    // Read in memory since adjancent instructions in the same bundle may have
    // been modified after we save them.
    if (BdMoveMemory(
            (PCHAR)&mBuf,
            (PCHAR)BdBreakpointTable[Index].Address,
            sizeof(BD_BREAKPOINT_TYPE)) != sizeof(BD_BREAKPOINT_TYPE)) {
        //DPRINT(("KD: read 0x%08x failed\n", BdBreakpointTable[Index].Address));
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
        return FALSE;
    }
    else {

        switch ((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK))
                         | (BdBreakpointTable[Index].Content & INST_SLOT0_MASK);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK))
                         | (BdBreakpointTable[Index].Content & INST_SLOT1_MASK);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK))
                         | (BdBreakpointTable[Index].Content & INST_SLOT2_MASK);
            break;

        default:
            //DPRINT(("KD: illegal instruction address 0x%08x\n", BdBreakpointTable[Index].Address));
            return FALSE;
        }

        if (BdMoveMemory(
                (PCHAR)BdBreakpointTable[Index].Address,
                (PCHAR)&mBuf,
                sizeof(BD_BREAKPOINT_TYPE)) != sizeof(BD_BREAKPOINT_TYPE)) {
            //DPRINT(("KD: write to 0x%08x failed\n", BdBreakpointTable[Index].Address));
            BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
            return FALSE;
        }
        else {

            if (BdMoveMemory(
                    (PCHAR)&mBuf,
                    (PCHAR)BdBreakpointTable[Index].Address,
                    sizeof(BD_BREAKPOINT_TYPE)) == sizeof(BD_BREAKPOINT_TYPE)) {
                //DPRINT(("\tcontent after memory move = 0x%08x 0x%08x\n", (ULONG)(mBuf >> 32), (ULONG)mBuf));
            }

            // restore template to MLI if displaced instruction was MOVL

            if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IA64_MOVL) {
                (ULONG_PTR)BundleAddress = (ULONG_PTR)BdBreakpointTable[Index].Address & ~(0xf);
                if (BdMoveMemory(
                        (PCHAR)&mBuf,
                        (PCHAR)BundleAddress,
                        sizeof(BD_BREAKPOINT_TYPE)
                        ) != sizeof(BD_BREAKPOINT_TYPE)) {
                    //DPRINT(("KD: read template 0x%08x failed\n", BdBreakpointTable[Index].Address));
                    BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
                    return FALSE;
                }
                else {
                    mBuf &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
                    mBuf |= 0x4;

                    if (BdMoveMemory(
                          (PCHAR)BundleAddress,
                          (PCHAR)&mBuf,
                          sizeof(BD_BREAKPOINT_TYPE)
                          ) != sizeof(BD_BREAKPOINT_TYPE)) {
                        //DPRINT(("KD: write template to 0x%08x failed\n", BdBreakpointTable[Index].Address));
                        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
                        return FALSE;
                    } else {
                        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
                         //   BdBreakpointTable[Index].Address));
                        return TRUE;
                    }
                }
            }
            else {   // not MOVL
                //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
                 //  BdBreakpointTable[Index].Address));
                return TRUE;
            }
        }
    }
#else    // _IA64_
    if (BdMoveMemory( (PCHAR)BdBreakpointTable[Index].Address,
                        (PCHAR)&BdBreakpointTable[Index].Content,
                        sizeof(BD_BREAKPOINT_TYPE) ) != sizeof(BD_BREAKPOINT_TYPE)) {

        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
        //DPRINT(("KD: Breakpoint at 0x%08x; unable to clear, flag set.\n",
            //BdBreakpointTable[Index].Address));
        return FALSE;
    } else {
        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
            //BdBreakpointTable[Index].Address));
        return TRUE;
    }
#endif // _IA64_

}

LOGICAL
BdDeleteBreakpoint (
    IN ULONG Handle
    )

/*++

Routine Description:

    This routine deletes an entry from the breakpoint table.

Arguments:

    Handle - Supplies the index plus one of the breakpoint table entry
        which is to be deleted.

Return Value:

    A value of FALSE is returned if the specified handle is not a valid
    value or the breakpoint cannot be deleted because the old instruction
    cannot be replaced. Otherwise, a value of TRUE is returned.

--*/

{
    ULONG Index = Handle - 1;

    //
    // If the specified handle is not valid, then return FALSE.
    //

    if ((Handle == 0) || (Handle > BREAKPOINT_TABLE_SIZE)) {
        //DPRINT(("KD: Breakpoint %d invalid.\n", Index));
        return FALSE;
    }

    //
    // If the specified breakpoint table entry is not valid, then return FALSE.
    //

    if (BdBreakpointTable[Index].Flags == 0) {
        //DPRINT(("KD: Breakpoint %d already clear.\n", Index));
        return FALSE;
    }

    //
    // If the breakpoint is already suspended, just delete it from the table.
    //

    if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) {
        //DPRINT(("KD: Deleting suspended breakpoint %d \n", Index));
        if ( !(BdBreakpointTable[Index].Flags & BD_BREAKPOINT_NEEDS_REPLACE) ) {
            //DPRINT(("KD: already clear.\n"));
            BdBreakpointTable[Index].Flags = 0;
            return TRUE;
        }
    }

    //
    // Replace the instruction contents.
    //

    if (BdLowWriteContent(Index)) {

        //
        // Delete breakpoint table entry
        //

        //DPRINT(("KD: Breakpoint %d deleted successfully.\n", Index));
        BdBreakpointTable[Index].Flags = 0;
    }

    return TRUE;
}

LOGICAL
BdDeleteBreakpointRange (
    IN ULONG64 Lower,
    IN ULONG64 Upper
    )

/*++

Routine Description:

    This routine deletes all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to remove BPs.

    Upper - include upper address of range from which to remove BPs.

Return Value:

    TRUE if any breakpoints removed, FALSE otherwise.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++) {

        if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
             ((BdBreakpointTable[Index].Address >= Lower) &&
              (BdBreakpointTable[Index].Address <= Upper))
           ) {

            //
            // Breakpoint is in use and falls in range, clear it.
            //

            ReturnStatus = ReturnStatus || BdDeleteBreakpoint(Index+1);
        }
    }

    return ReturnStatus;
}

VOID
BdSuspendBreakpoint (
    ULONG Handle
    )
{
    ULONG Index = Handle - 1;

    if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
        !(BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) ) {

        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_SUSPENDED;
        BdLowWriteContent(Index);
    }

    return;

}

VOID
BdSuspendAllBreakpoints (
    VOID
    )

{
    ULONG Handle;

    BreakpointsSuspended = TRUE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        BdSuspendBreakpoint(Handle);
    }

    return;

}

LOGICAL
BdLowRestoreBreakpoint (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to write a breakpoint instruction.
    The old contents must have already been stored in the
    breakpoint record.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be written.

Return Value:

    Returns TRUE if the breakpoint was written, FALSE if it was
    not and has been marked for writing later.

--*/

{
    BD_BREAKPOINT_TYPE Content;

#if defined(_IA64_)
    BD_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif

    //
    // Does the breakpoint need to be written at all?
    //

    if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_NEEDS_REPLACE) {

        //
        // The breakpoint was never removed.  Clear the flag
        // and we are done.
        //

        BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_NEEDS_REPLACE;
        return TRUE;

    }

#if !defined(_IA64_)
    if (BdBreakpointTable[Index].Content == BdBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }
#endif

    //
    // Replace the instruction contents.
    //

#if defined(_IA64_)

    // read in intruction in case the adjacent instruction has been modified.

    if (BdMoveMemory(
            (PCHAR)&mBuf,
            (PCHAR)BdBreakpointTable[Index].Address,
            sizeof(BD_BREAKPOINT_TYPE)
            ) != sizeof(BD_BREAKPOINT_TYPE)) {
        //DPRINT(("KD: read 0x%p template failed\n", BdBreakpointTable[Index].Address));
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
        return FALSE;
    }

    switch ((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK)) | (BdBreakpointInstruction << 5);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK)) | (BdBreakpointInstruction << 14);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK)) | (BdBreakpointInstruction << 23);
            break;

        default:
            //DPRINT(("KD: BdAddBreakpoint bad instruction slot#\n"));
            return FALSE;
    }
    if (BdMoveMemory(
            (PCHAR)BdBreakpointTable[Index].Address,
            (PCHAR)&mBuf,
            sizeof(BD_BREAKPOINT_TYPE)
            ) != sizeof(BD_BREAKPOINT_TYPE)) {

        //DPRINT(("KD: BdMoveMemory failed writing BP!\n"));
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
        return FALSE;
    }
    else {

        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.
        // change template to type 0 if current instruction is MLI

        if (((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) != 0) {
            (ULONG_PTR)BundleAddress = (ULONG_PTR)BdBreakpointTable[Index].Address & ~(0xf);
            if (BdMoveMemory(
                    (PCHAR)&mBuf,
                    (PCHAR)BundleAddress,
                    sizeof(BD_BREAKPOINT_TYPE)
                    ) != sizeof(BD_BREAKPOINT_TYPE)) {
                //DPRINT(("KD: read template failed at 0x%08x\n", BundleAddress));
                BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
                return FALSE;
            }
            else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IA64_MOVL;
                        if (BdMoveMemory(
                                (PCHAR)BundleAddress,
                                (PCHAR)&mBuf,
                                sizeof(BD_BREAKPOINT_TYPE)
                                ) != sizeof(BD_BREAKPOINT_TYPE)) {
                            //DPRINT(("KD: write to 0x%08x template failed\n", BundleAddress));
                            BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
                            return FALSE;
                        }
                        else {
                             //DPRINT(("KD: change MLI template to type 0 at 0x%08x set\n", Address));
                        }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         //DPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%08x\n", BundleAddress));
                         BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
                         return FALSE;
                    }
                }
            }
        }
        //DPRINT(("KD: breakpoint at 0x%08x set\n", Address));
        return TRUE;
    }
#else     // _IA64_

    BdMoveMemory((PCHAR)BdBreakpointTable[Index].Address,
                 (PCHAR)&BdBreakpointInstruction,
                  sizeof(BD_BREAKPOINT_TYPE));
    return TRUE;
#endif  // _IA64_

}

VOID
BdRestoreAllBreakpoints (
    VOID
    )
{
    ULONG Index;

    BreakpointsSuspended = FALSE;

    for ( Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++ ) {

        if ((BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
            (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) ) {

            BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_SUSPENDED;
            BdLowRestoreBreakpoint(Index);
        }
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\bd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bd.h

Abstract:

    This module contains the data structures and function prototypes for the
    boot debugger.

Author:

    David N. Cutler (davec) 27-Nov-1996

Revision History:

--*/

#ifndef _BD_
#define _BD_

#include "bldr.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "ki.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "cpu.h"
#include "ntverp.h"

//
// Define message buffer size in bytes.
//
// N.B. This must be 0 mod 8.
//

#define BD_MESSAGE_BUFFER_SIZE 4096

//
// Define the maximum number of retries for packet sends.
//

#define MAXIMUM_RETRIES 20

//
// Define packet waiting status codes.
//

#define BD_PACKET_RECEIVED 0
#define BD_PACKET_TIMEOUT 1
#define BD_PACKET_RESEND 2

//
// Define break point table entry structure.
//

#define BD_BREAKPOINT_IN_USE 0x1
#define BD_BREAKPOINT_NEEDS_WRITE 0x2
#define BD_BREAKPOINT_SUSPENDED 0x4
#define BD_BREAKPOINT_NEEDS_REPLACE 0x8

typedef struct _BREAKPOINT_ENTRY {
    ULONG Flags;
    ULONG64 Address;
    BD_BREAKPOINT_TYPE Content;
} BREAKPOINT_ENTRY, *PBREAKPOINT_ENTRY;

extern ULONG BdFileId;

//
// Define function prototypes.
//

LOGICAL
BdPollBreakIn (
    VOID
    );

VOID
BdReboot (
    VOID
    );

//
// Breakpoint functions (break.c).
//

ULONG
BdAddBreakpoint (
    IN ULONG64 Address
    );

LOGICAL
BdDeleteBreakpoint (
    IN ULONG Handle
    );

LOGICAL
BdDeleteBreakpointRange (
    IN ULONG64 Lower,
    IN ULONG64 Upper
    );

VOID
BdRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdSuspendBreakpoint (
    ULONG Handle
    );

VOID
BdSuspendAllBreakpoints (
    VOID
    );

VOID
BdRestoreAllBreakpoints (
    VOID
    );

//
// Memory check functions (check.c)
//

PVOID
BdReadCheck (
    IN PVOID Address
    );

PVOID
BdWriteCheck (
    IN PVOID Address
    );

PVOID
BdTranslatePhysicalAddress (
    IN PHYSICAL_ADDRESS Address
    );

//
// Debugger initialization routine (port.c)
//
LOGICAL
BdPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    OUT PULONG BdFileId
    );


//
// Communication functions (comio.c)
//

ULONG
BdComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    );

USHORT
BdReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    );

VOID
BdSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    );

ULONG
BdReceivePacket (
    IN ULONG ExpectedPacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    );

VOID
BdSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    );

ULONG
BdReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    );

VOID
BdSendString (
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
BdSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    );

//
// State change message functions (message.c)
//

LOGICAL
BdReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

LOGICAL
BdReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN LOGICAL UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    );

//
// Platform independent debugger APIs (xxapi.c)
//

VOID
BdGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
BdRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

NTSTATUS
BdWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

//
// Move memory functions (move.c)
//

ULONG
BdMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
BdCopyMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

//
// CPU specific interfaces (cpuapi.c)
//

VOID
BdSetContextState (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    );

VOID
BdGetStateChange (
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    );

VOID
BdSetStateChange (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    );

VOID
BdReadControlSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteControlSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadIoSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteIoSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadMachineSpecificRegister (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteMachineSpecificRegister (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

//
// Print and prompt functions (dbgio.c)
//

VOID
BdPrintf (
    IN PCHAR Format,
    ...
    );

LOGICAL
BdPrintString (
    IN PSTRING Output
    );

LOGICAL
BdPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    );

//
// Define external data.
//

extern BD_BREAKPOINT_TYPE BdBreakpointInstruction;
extern BREAKPOINT_ENTRY BdBreakpointTable[];
extern LOGICAL BdControlCPending;
extern LOGICAL BdControlCPressed;
extern LOGICAL BdDebuggerNotPresent;
extern PBD_DEBUG_ROUTINE BdDebugRoutine;
extern ULONGLONG BdMessageBuffer[];
extern ULONG BdNextPacketIdToSend;
extern ULONG BdNumberRetries;
extern ULONG BdPacketIdExpected;
extern KPRCB BdPrcb;
extern ULONG BdRetryCount;
extern ULONG NtBuildNumber;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\data.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains global data for the boot debugger.

Author:

    David N. Cutler (davec) 27-Nov-1996

Revision History:

--*/

#include "bd.h"

//
// Define boot debugger data.
//
// Breakpoint instruction.
//

BD_BREAKPOINT_TYPE BdBreakpointInstruction;

//
// Break point table.
//

BREAKPOINT_ENTRY BdBreakpointTable[BREAKPOINT_TABLE_SIZE] = {0};

//
// Control C pressed and control C pending.
//

LOGICAL BdControlCPending = FALSE;
LOGICAL BdControlCPressed = FALSE;

//
// Debugger enabled and present.
//

LOGICAL BdDebuggerEnabled = FALSE;
LOGICAL BdDebuggerNotPresent = FALSE;

//
// Debug routine address.
//

PBD_DEBUG_ROUTINE BdDebugRoutine;

//
// Message buffer.
//
// N.B. The message buffer size is guaranteed to be 0 mod 8.
//

ULONGLONG BdMessageBuffer[BD_MESSAGE_BUFFER_SIZE / 8];

//
// Next packet id to send and next packet id to expect.
//

ULONG BdPacketIdExpected;
ULONG BdNextPacketIdToSend;

//
// Processor control block used to saved processor state.
//

KPRCB BdPrcb;

//
// Number of retries and the retry count.
//

ULONG BdNumberRetries = 5;
ULONG BdRetryCount = 5;

//
// NT build number.
//

#if DBG

ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xc0000000;

#else

ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xf0000000;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\comio.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    comio.c

Abstract:

    This module implements the I/O comunications for the portable kernel
    debugger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "bd.h"

ULONG
BdComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine computes the checksum of the specified buffer.

Arguments:

    Buffer - Supplies a pointer to the buffer.

    Length - Supplies the length of the buffer.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/

{

    ULONG Checksum = 0;

    while (Length > 0) {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }

    return Checksum;
}

USHORT
BdReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    )

/*++

Routine Description:

    This routine waits for a packet header leader.

Arguments:

    PacketType - supplies the type of packet we are expecting.

    PacketLeader - supplies a pointer to a ulong variable to receive
                   packet leader bytes.

Return Value:

    BD_PACKET_RESEND - if resend is required.
    BD_PAKCET_TIMEOUT - if timeout.
    BD_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input, PreviousByte = 0;
    ULONG PacketId = 0;
    ULONG Index;
    ULONG ReturnCode;
    BOOLEAN BreakinDetected = FALSE;

    //
    // NOTE - With all the interrupts being off, it is very hard
    // to implement the actual timeout code. (Maybe, by reading the CMOS.)
    // Here we use a loop count to wait about 3 seconds.  The CpGetByte
    // will return with error code = CP_GET_NODATA if it cannot find data
    // byte within 1 second. Kernel debugger's timeout period is 5 seconds.
    //

    Index = 0;
    do {
        ReturnCode = BlPortGetByte(BdFileId, &Input);
        if (ReturnCode == CP_GET_NODATA) {
            if (BreakinDetected) {
                BdControlCPending = TRUE;
                return BD_PACKET_RESEND;

            } else {
                return BD_PACKET_TIMEOUT;
            }

        } else if (ReturnCode == CP_GET_ERROR) {
            Index = 0;
            continue;

        } else {                    // if (ReturnCode == CP_GET_SUCCESS)
            if ( Input == PACKET_LEADER_BYTE ||
                 Input == CONTROL_PACKET_LEADER_BYTE ) {
                if ( Index == 0 ) {
                    PreviousByte = Input;
                    Index++;
                } else if (Input == PreviousByte ) {
                    Index++;
                } else {
                    PreviousByte = Input;
                    Index = 1;
                }
            } else {

                //
                // If we detect breakin character, we need to verify it
                // validity.  (It is possible that we missed a packet leader
                // and the breakin character is simply a data byte in the
                // packet.)
                // Since kernel debugger send out breakin character ONLY
                // when it is waiting for State Change packet.  The breakin
                // character should not be followed by any other character
                // except packet leader byte.
                //

                if ( Input == BREAKIN_PACKET_BYTE ) {
                    BreakinDetected = TRUE;
                } else {

                    //
                    // The following statement is ABSOLUTELY necessary.
                    //

                    BreakinDetected = FALSE;
                }
                Index = 0;
            }
        }
    } while ( Index < 4 );

    if (BreakinDetected) {
        BdControlCPending = TRUE;
    }

    //
    // return the packet leader and FALSE to indicate no resend is needed.
    //

    if ( Input == PACKET_LEADER_BYTE ) {
        *PacketLeader = PACKET_LEADER;

    } else {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }

    BdDebuggerNotPresent = FALSE;
    return BD_PACKET_RECEIVED;
}

VOID
BdSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
    if (ARGUMENT_PRESENT( (PVOID)(ULONG_PTR) PacketId )) {
        PacketHeader.PacketId = PacketId;
    }

    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;
    BdSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));
    return;
}

ULONG
BdReceivePacket (
    IN ULONG PacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    )

/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is BdrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

Return Value:

    BD_PACKET_RESEND - if resend is required.
    BD_PAKCET_TIMEOUT - if timeout.
    BD_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input;
    ULONG MessageLength;
    KD_PACKET PacketHeader;
    ULONG ReturnCode;
    ULONG Checksum;

WaitForPacketLeader:

    //
    // Read Packet Leader
    //

    ReturnCode = BdReceivePacketLeader(PacketType, &PacketHeader.PacketLeader);

    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //

    if (ReturnCode != BD_PACKET_TIMEOUT) {
        BdNumberRetries = BdRetryCount;
    }
    if (ReturnCode != BD_PACKET_RECEIVED) {
        return ReturnCode;
    }

    //
    // Read packet type.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.PacketType,
                                 sizeof(PacketHeader.PacketType));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;

    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

            //
            // If read error and it is for a control packet, simply
            // preptend that we have not seen this packet.  Hopefully
            // we will receive the packet we desire which automatically acks
            // the packet we just sent.
            //

            goto WaitForPacketLeader;

        } else {

            //
            // if read error while reading data packet, we have to ask
            // kernel debugger to resend us the packet.
            //

            goto SendResendPacket;
        }
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //

    if ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {
        return BD_PACKET_RESEND;
    }

    //
    // Read data length.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.ByteCount,
                                 sizeof(PacketHeader.ByteCount));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read Packet Id.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.PacketId,
                                 sizeof(PacketHeader.PacketId));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read packet checksum.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.Checksum,
                                 sizeof(PacketHeader.Checksum));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;

    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // A complete packet header is received.  Check its validity and
    // perform appropriate action depending on packet type.
    //

    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {
        if (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE ) {

            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (PacketHeader.PacketId !=
                (BdNextPacketIdToSend & ~SYNC_PACKET_ID))  {
                goto WaitForPacketLeader;

            } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {
                BdNextPacketIdToSend ^= 1;
                return BD_PACKET_RECEIVED;

            } else {
                goto WaitForPacketLeader;
            }

        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESET) {

            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            BdNextPacketIdToSend = INITIAL_PACKET_ID;
            BdPacketIdExpected = INITIAL_PACKET_ID;
            BdSendControlPacket(PACKET_TYPE_KD_RESET, 0L);
            return BD_PACKET_RESEND;

        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {
            return BD_PACKET_RESEND;

        } else {

            //
            // Invalid packet header, ignore it.
            //

            goto WaitForPacketLeader;
        }

    //
    // The packet header is for data packet (not control packet).
    //

    } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

        //
        // if we are waiting for ACK packet ONLY
        // and we receive a data packet header, check if the packet id
        // is what we expected.  If yes, assume the acknowledge is lost (but
        // sent), ask sender to resend and return with PACKET_RECEIVED.
        //

        if (PacketHeader.PacketId == BdPacketIdExpected) {
            BdSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            BdNextPacketIdToSend ^= 1;
            return BD_PACKET_RECEIVED;

        } else {
            BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                PacketHeader.PacketId);

            goto WaitForPacketLeader;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //
    // Check ByteCount received is valid
    //

    MessageLength = MessageHeader->MaximumLength;
    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {
        goto SendResendPacket;
    }

    *DataLength = PacketHeader.ByteCount - MessageLength;

    //
    // Read the message header.
    //

    ReturnCode = BdReceiveString(MessageHeader->Buffer, MessageLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }

    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Read the message data.
    //

    ReturnCode = BdReceiveString(MessageData->Buffer, *DataLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }

    MessageData->Length = (USHORT)*DataLength;

    //
    // Read packet trailing byte
    //

    ReturnCode = BlPortGetByte(BdFileId, &Input);
    if (ReturnCode != CP_GET_SUCCESS || Input != PACKET_TRAILING_BYTE) {
        goto SendResendPacket;
    }

    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType != PacketHeader.PacketType) {
        BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                             PacketHeader.PacketId
                             );
        goto WaitForPacketLeader;
    }

    //
    // Check PacketId is valid.
    //

    if (PacketHeader.PacketId == INITIAL_PACKET_ID ||
        PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {
        if (PacketHeader.PacketId != BdPacketIdExpected) {
            BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }

    } else {
        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //

    Checksum = BdComputeChecksum(MessageHeader->Buffer,
                                 MessageHeader->Length);


    Checksum += BdComputeChecksum(MessageData->Buffer,
                                  MessageData->Length);

    if (Checksum != PacketHeader.Checksum) {
        goto SendResendPacket;
    }

    //
    // Send Acknowledge byte and the Id of the packet received.
    // Then, update the ExpectId for next incoming packet.
    //

    BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                        PacketHeader.PacketId);

    //
    // We have successfully received the packet so update the
    // packet control variables and return sucess.
    //

    BdPacketIdExpected ^= 1;
    return BD_PACKET_RECEIVED;

SendResendPacket:
    BdSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
}

VOID
BdSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    )

/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;
    ULONG MessageDataLength;
    ULONG ReturnCode;
    PDBGKD_DEBUG_IO DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64 StateChange;

    if (ARGUMENT_PRESENT(MessageData)) {
        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = BdComputeChecksum(MessageData->Buffer,
                                                  MessageData->Length);

    } else {
        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += BdComputeChecksum(MessageHeader->Buffer,
                                               MessageHeader->Length);

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;
    BdNumberRetries = BdRetryCount;
    do {
        if (BdNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //

            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {
                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;
                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {
                    BdDebuggerNotPresent = TRUE;
                    BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    BdPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }

            } else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {
                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;
                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {
                    BdDebuggerNotPresent = TRUE;
                    BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    BdPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_FILE_IO) {
                PDBGKD_FILE_IO FileIo;
                
                FileIo = (PDBGKD_FILE_IO)MessageHeader->Buffer;
                if (FileIo->ApiNumber == DbgKdCreateFileApi) {
                    BdDebuggerNotPresent = TRUE;
                    BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    BdPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            }
        }

        //
        // Setting PacketId has to be in the do loop in case Packet Id was
        // reset.
        //

        PacketHeader.PacketId = BdNextPacketIdToSend;
        BdSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

        //
        // Output message header.
        //

        BdSendString(MessageHeader->Buffer, MessageHeader->Length);

        //
        // Output message data.
        //

        if ( MessageDataLength ) {
            BdSendString(MessageData->Buffer, MessageData->Length);
        }

        //
        // Output a packet trailing byte
        //

        BlPortPutByte(BdFileId, PACKET_TRAILING_BYTE);

        //
        // Wait for the Ack Packet
        //

        ReturnCode = BdReceivePacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                     NULL,
                                     NULL,
                                     NULL);

        if (ReturnCode == BD_PACKET_TIMEOUT) {
            BdNumberRetries--;
        }

    } while (ReturnCode != BD_PACKET_RECEIVED);

    //
    // Reset Sync bit in packet id.  The packet we sent may have Sync bit set
    //

    BdNextPacketIdToSend &= ~SYNC_PACKET_ID;

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //

    BdRetryCount = MAXIMUM_RETRIES;
}

ULONG
BdReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine reads a string from the kernel debugger port.

Arguments:

    Destination - Supplies a pointer to the input string.

    Length - Supplies the length of the string to be read.

Return Value:

    CP_GET_SUCCESS is returned if string is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{

    UCHAR Input;
    ULONG ReturnCode;

    //
    // Read bytes until either a error is encountered or the entire string
    // has been read.
    //
    while (Length > 0) {
        ReturnCode = BlPortGetByte(BdFileId, &Input);
        if (ReturnCode != CP_GET_SUCCESS) {
            return ReturnCode;
        } else {
            *Destination++ = Input;
            Length -= 1;
        }
    }

    return CP_GET_SUCCESS;
}

VOID
BdSendString (
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine writes a string to the kernel debugger port.

Arguments:

    Source - Supplies a pointer to the output string.

    Length - Supplies the length of the string to be written.

Return Value:

    None.

--*/

{

    UCHAR Output;

    //
    // Write bytes to the kernel debugger port.
    //

    while (Length > 0) {
        Output = *Source++;
        BlPortPutByte(BdFileId, Output);
        Length -= 1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\dbgio.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dbgio.c

Abstract:

    This module implements the boot debugger print and prompt functions.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

LOGICAL
BdPrintString (
    IN PSTRING Output
    )

/*++

Routine Description:

    This routine prints a string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

Return Value:

    TRUE if Control-C present in input buffer after print is done.
    FALSE otherwise.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;

    //
    // Move the output string to the message buffer.
    //

    Length = BdMoveMemory((PCHAR)BdMessageBuffer,
                          (PCHAR)Output->Buffer,
                          Output->Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the print string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdPrintStringApi;
    DebugIo.ProcessorLevel = 0;
    DebugIo.Processor = 0;
    DebugIo.u.PrintString.LengthOfString = Length;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);

    //
    // Send packet to the kernel debugger on the host machine.
    //

    BdSendPacket(PACKET_TYPE_KD_DEBUG_IO,
                 &MessageHeader,
                 &MessageData);

    return BdPollBreakIn();
}

LOGICAL
BdPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

    Input - Supplies a pointer to a string descriptor for the input string.
            (Length stored/returned in Input->Length)

Return Value:

    TRUE - A Breakin sequence was seen, caller should breakpoint and retry
    FALSE - No Breakin seen.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;
    ULONG ReturnCode;

    //
    // Move the output string to the message buffer.
    //

    Length = BdMoveMemory((PCHAR)BdMessageBuffer,
                          (PCHAR)Output->Buffer,
                          Output->Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the prompt string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdGetStringApi;
    DebugIo.ProcessorLevel = 0;
    DebugIo.Processor = 0;
    DebugIo.u.GetString.LengthOfPromptString = Length;
    DebugIo.u.GetString.LengthOfStringRead = Input->MaximumLength;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the prompt string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);

    //
    // Send packet to the kernel debugger on the host machine.
    //

    BdSendPacket(PACKET_TYPE_KD_DEBUG_IO,
                 &MessageHeader,
                 &MessageData);

    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_DEBUG_IO);
    MessageData.MaximumLength = BD_MESSAGE_BUFFER_SIZE;
    do {
        ReturnCode = BdReceivePacket(PACKET_TYPE_KD_DEBUG_IO,
                                     &MessageHeader,
                                     &MessageData,
                                     &Length);

        if (ReturnCode == BD_PACKET_RESEND) {
            return TRUE;
        }

    } while (ReturnCode != BD_PACKET_RECEIVED);


    Length = min(Length, Input->MaximumLength);
    Input->Length = (USHORT)BdMoveMemory((PCHAR)Input->Buffer,
                                         (PCHAR)BdMessageBuffer,
                                         Length);

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\file.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module contains kd host machine file I/O support.

Author:

    Matt Holle (matth) April-2001

Revision History:

--*/

#include "bd.h"
#include "bootlib.h"
#include "kddll.h"

#define TRANSFER_LENGTH 8192
#define KD_MAX_REMOTE_FILES 16

//
// Keep track of all the remote files.
typedef struct _KD_REMOTE_FILE {
    ULONG64 RemoteHandle;
} KD_REMOTE_FILE, *PKD_REMOTE_FILE;

KD_REMOTE_FILE BdRemoteFiles[KD_MAX_REMOTE_FILES];

// KD_CONTEXT KdContext;

// temporary buffer used for transferring data back and forth.
// UCHAR   TransferBuffer[TRANSFER_LENGTH];
UCHAR   BdFileTransferBuffer[TRANSFER_LENGTH];


ARC_STATUS
BdCreateRemoteFile(
    OUT PHANDLE Handle,
    OUT PULONG64 Length, OPTIONAL
    IN PCHAR FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    DBGKD_FILE_IO Irp;
    ULONG       DownloadedFileIndex;
    ULONG       Index;
    STRING      MessageData;
    STRING      MessageHeader;
    ULONG       ReturnCode;
    ULONG       PacketLength;
    ANSI_STRING aString;
    UNICODE_STRING uString;

    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }

    if( (!FileName) ||
        (strlen(FileName) > PACKET_MAX_SIZE) ) {
        
        DbgPrint( "BdCreateRemoteFile: Bad parameter\n" );
        return STATUS_INVALID_PARAMETER;
    }
    

    if (BdDebuggerNotPresent != FALSE) {
        return STATUS_DEBUGGER_INACTIVE;
    }


    //
    // Look for an open slot.
    //
    for (DownloadedFileIndex = 0; DownloadedFileIndex < KD_MAX_REMOTE_FILES; DownloadedFileIndex++) {
        if (BdRemoteFiles[DownloadedFileIndex].RemoteHandle == 0) {
            break;
        }
    }

    if (DownloadedFileIndex >= KD_MAX_REMOTE_FILES) {
        DbgPrint( "BdCreateRemoteFile: No more empty handles available for this file.\n" );
        Irp.Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    
    //
    // Fix up the packet that we'll send to the kernel debugger.
    //
    Irp.ApiNumber = DbgKdCreateFileApi;
    Irp.u.CreateFile.DesiredAccess = DesiredAccess;
    Irp.u.CreateFile.FileAttributes = FileAttributes;
    Irp.u.CreateFile.ShareAccess = ShareAccess;
    Irp.u.CreateFile.CreateDisposition = CreateDisposition;
    Irp.u.CreateFile.CreateOptions = CreateOptions;
    Irp.u.CreateFile.Handle = 0;
    Irp.u.CreateFile.Length = 0;

    MessageHeader.Length = sizeof(Irp);
    MessageHeader.MaximumLength = sizeof(Irp);
    MessageHeader.Buffer = (PCHAR)&Irp;


    //
    // Send him a unicode file name.
    //
    RtlInitString( &aString, FileName );
    uString.Buffer = (PWCHAR)BdFileTransferBuffer;
    uString.MaximumLength = sizeof(BdFileTransferBuffer);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
    MessageData.Length = (USHORT)((strlen(FileName)+1) * sizeof(WCHAR));
    MessageData.Buffer = BdFileTransferBuffer;


    //
    // Send packet to the kernel debugger on the host machine and ask him to
    // send us a handle to the file.
    //
    BdSendPacket(PACKET_TYPE_KD_FILE_IO,
                 &MessageHeader,
                 &MessageData);

    if (BdDebuggerNotPresent != FALSE) {
        Irp.Status = STATUS_DEBUGGER_INACTIVE;
        goto Exit;
    }



    //
    // We asked for the handle, now receive it.
    //
    MessageData.MaximumLength = sizeof(BdFileTransferBuffer);
    MessageData.Buffer = (PCHAR)BdFileTransferBuffer;
    
    ReturnCode = BD_PACKET_TIMEOUT;
    Index = 0;
    while( (ReturnCode == BD_PACKET_TIMEOUT) &&
           (Index < 10) ) {
        ReturnCode = BdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                     &MessageHeader,
                                     &MessageData,
                                     &PacketLength);

        Index++;
    }
    
    //
    // BdReceivePacket *may* return BD_PACKET_RECEIVED eventhough the kernel
    // debugger failed to actually find the file we wanted.  Therefore, we
    // need to check the Irp.Status value too before assuming we got the
    // information we wanted.
    //
    // Note: don't check for Irp.u.CreateFile.Length == 0 because we don't
    // want to exclude downloading zero-length files.
    //
    if( (ReturnCode == BD_PACKET_RECEIVED) &&
        (NT_SUCCESS(Irp.Status)) ) {
        Irp.Status = STATUS_SUCCESS;
    } else {
        Irp.Status = STATUS_INVALID_PARAMETER;
    }

Exit:

    if (NT_SUCCESS(Irp.Status)) {
        BdRemoteFiles[DownloadedFileIndex].RemoteHandle = Irp.u.CreateFile.Handle;
        // Add one so that zero is reserved for invalid-handle.
        *Handle = UlongToHandle(DownloadedFileIndex + 1);
        if (ARGUMENT_PRESENT(Length)) {
            *Length = Irp.u.CreateFile.Length;
        }
    }
    
    
    return Irp.Status;
}

ARC_STATUS
BdReadRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    )
{
    DBGKD_FILE_IO Irp;
    ULONG Index;
    ULONG _Completed = 0;


    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }


    Index = HandleToUlong(Handle) - 1;
    if( (Index >= KD_MAX_REMOTE_FILES) ||
        (BdRemoteFiles[Index].RemoteHandle == 0) ) {
        
        DbgPrint( "BdReadRemoteFile: Bad parameters!\n" );
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    


    Irp.ApiNumber = DbgKdReadFileApi;
    Irp.Status = STATUS_SUCCESS;
    Irp.u.ReadFile.Handle = BdRemoteFiles[Index].RemoteHandle;
    Irp.u.ReadFile.Offset = Offset;

    while (Length > 0) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        if (Length > PACKET_MAX_SIZE - sizeof(Irp)) {
            Irp.u.ReadFile.Length = PACKET_MAX_SIZE - sizeof(Irp);
        } else {
            Irp.u.ReadFile.Length = Length;
        }
    
        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        BdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = (USHORT)Irp.u.ReadFile.Length;
        MessageData.Buffer = Buffer;

        do {
            ReturnCode = BdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength);
        } while (ReturnCode == BD_PACKET_TIMEOUT);

        if (ReturnCode == BD_PACKET_RECEIVED) {
            if (!NT_SUCCESS(Irp.Status)) {
                break;
            }

            _Completed += RecvLength;
            Buffer = (PVOID)((PUCHAR)Buffer + RecvLength);
            Irp.u.ReadFile.Offset += RecvLength;
            Length -= RecvLength;
        }
    }
    
    *Completed = _Completed;
    
Exit:
    return Irp.Status;
}

ARC_STATUS
BdCloseRemoteFile(
    IN HANDLE Handle
    )
{
    DBGKD_FILE_IO Irp;
    ULONG Index;

    
    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }

    
    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if (BdRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdCloseFileApi;
    Irp.u.CloseFile.Handle = BdRemoteFiles[Index].RemoteHandle;

    for (;;) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        BdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = BD_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = (PCHAR)BdMessageBuffer;

        do {
            ReturnCode = BdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength);
        } while (ReturnCode == BD_PACKET_TIMEOUT);

        if (ReturnCode == BD_PACKET_RECEIVED) {
            break;
        }
    }
    
    if (NT_SUCCESS(Irp.Status)) {
        BdRemoteFiles[Index].RemoteHandle = 0;
    }
    
 Exit:
    return Irp.Status;
}

ARC_STATUS
BdPullRemoteFile(
    IN PCHAR FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG FileId
    )
{
    ARC_STATUS      Status = ESUCCESS;
    PUCHAR          BaseFilePointer = NULL;
    PUCHAR          WorkingMemoryPointer = NULL;
    ULONG64         Length = 0;
    HANDLE          RemoteHandle = NULL;
    ULONG64         Offset = 0;
    ULONG           basePage = 0;
    PBL_FILE_TABLE  fileTableEntry = NULL;


    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }

    
    // Open the remote file for reading.
    Status = BdCreateRemoteFile(&RemoteHandle, &Length, FileName,
                                FILE_GENERIC_READ, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ, FILE_OPEN, 0);
    if (!NT_SUCCESS(Status)) {
        //
        // File probably doesn't exist on the debugger.
        //
        goto Exit;
    }
    

    //
    // Allocate memory for the file, then download it.
    //
    Status = BlAllocateAlignedDescriptor( LoaderFirmwareTemporary,
                                          0,
                                          (ULONG)((Length + PAGE_SIZE - 1) >> PAGE_SHIFT),
                                          0,
                                          &basePage );
    if ( Status != ESUCCESS ) {
        DbgPrint( "BdPullRemoteFile: BlAllocateAlignedDescriptor failed! (%x)\n", Status );
        goto Exit;
    }



    //
    // Keep track of our pointers.
    // BaseFilePointer will point to the starting address of the block
    // we're about to download the file into.
    //
    // Working MemoryPointer will move through memory as we download small
    // chunks of the file.
    //
    BaseFilePointer = (PUCHAR)ULongToPtr( (basePage << PAGE_SHIFT) );
    WorkingMemoryPointer = BaseFilePointer;


    //
    // Download the file.
    //
    Offset = 0;
    while( Offset < Length ) {
        ULONG ReqLength, ReqCompleted;

        if((Length - Offset) > TRANSFER_LENGTH) {
            ReqLength = TRANSFER_LENGTH;
        } else {
            ReqLength = (ULONG)(Length - Offset);
        }
        
        Status = BdReadRemoteFile( RemoteHandle, 
                                   Offset, 
                                   WorkingMemoryPointer,
                                   ReqLength, 
                                   &ReqCompleted );
        if (!NT_SUCCESS(Status) || ReqCompleted == 0) {
            DbgPrint( "BdPullRemoteFile: BdReadRemoteFile failed! (%x)\n", Status );
            goto Exit;
        }

        // Increment our working pointer so we copy the next chunk
        // into the next spot in memory.
        WorkingMemoryPointer += ReqLength;

        Offset += ReqLength;
    }
    
    
    //
    // We got the file, so setup the BL_FILE_TABLE
    // entry for this file.  We'll pretend that we got this file
    // off the network because that's pretty close, and it allows
    // us to conveniently record the memory block where we're about
    // to download this file.
    //
    {
        extern BL_DEVICE_ENTRY_TABLE NetDeviceEntryTable;
        fileTableEntry = &BlFileTable[FileId];
        fileTableEntry->Flags.Open = 1;
        fileTableEntry->DeviceId = NET_DEVICE_ID;
        fileTableEntry->u.NetFileContext.FileSize = (ULONG)Length;
        fileTableEntry->u.NetFileContext.InMemoryCopy = BaseFilePointer;
        fileTableEntry->Position.QuadPart = 0;
        fileTableEntry->Flags.Read = 1;
        fileTableEntry->DeviceEntryTable = &NetDeviceEntryTable;
        RtlZeroMemory( fileTableEntry->StructureContext,  sizeof(NET_STRUCTURE_CONTEXT) );
        
        //
        // If we've called NetIntialize before (like if we're really booting from
        // the net, or if we've come through here before), then he returns immediately
        // so the call isn't expensive.
        //
        // If we're not booting from the net, and we've never called NetInitialize before,
        // then this will do nothing but setup his function table and return quickly.
        //
        NetInitialize();
    }

    DbgPrint( "BD: Loaded remote file %s\n", FileName );
    
Exit:
    if (RemoteHandle != NULL) {
        BdCloseRemoteFile(RemoteHandle);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\move.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    move.c

Abstract:

    This module contains code to implement the portable kernel debugger
    memory mover.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

ULONG
BdMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine moves data to or from the message buffer and returns the
    actual length of the information that was moved. As data is moved, checks
    are made to ensure that the data is resident in memory and a page fault
    will not occur. If a page fault would occur, then the move is truncated.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    The actual length of the move is returned as the fucntion value.

--*/

{

    PVOID Address1;
    PVOID Address2;
    ULONG ActualLength;

    //
    // If the length is greater than the size of the message buffer, then
    // reduce the length to the size of the message buffer.
    //

    if (Length > BD_MESSAGE_BUFFER_SIZE) {
        Length = BD_MESSAGE_BUFFER_SIZE;
    }

    //
    // Move the source information to the destination address.
    //

    ActualLength = Length;
    while (((ULONG_PTR)Source & 3) && (Length > 0)) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = BdWriteCheck((PVOID)Destination);
        Address2 = BdReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }

        *(PCHAR)Address1 = *(PCHAR)Address2;
        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    while (Length > 3) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = BdWriteCheck((PVOID)Destination);
        Address2 = BdReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }

        *(ULONG UNALIGNED *)Address1 = *(PULONG)Address2;
        Destination += 4;
        Source += 4;
        Length -= 4;

    }

    while (Length > 0) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = BdWriteCheck((PVOID)Destination);
        Address2 = BdReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }

        *(PCHAR)Address1 = *(PCHAR)Address2;
        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    //
    // Flush the instruction cache in case the write was into the instruction
    // stream.
    //

#if defined(_ALPHA_)

    BdSweepIcache();

#endif

    return ActualLength - Length;
}

VOID
BdCopyMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine duplicates the function pf RtlCopyMemory, but is private
    to the debugger. This allows breakpoints and watch points to be set
    RtlMoveMemory itself without risk of recursive debugger entry and the
    accompanying hang.

    N.B. Unlike BdMoveMemory, this routine does NOT check for accessability
      and may fault! Use it ONLY in the debugger and ONLY where you could
      use RtlMoveMemory.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    None.

--*/

{

    while (Length > 0) {
        *Destination = *Source;
        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module implements the initialization for the boot debgger.

Author:

    David N. Cutler (davec) 27-Nov-1996

Revision History:

--*/

#include "bd.h"

#if defined(EFI)
#include "bootefi.h"
#endif

//
// Define local data.
//

#define BAUD_OPTION "BAUDRATE"
#define PORT_OPTION "DEBUGPORT"

ULONG BdFileId;


VOID
BdInitDebugger (
    IN PCHAR LoaderName,
    IN PVOID LoaderBase,
    IN PCHAR Options
    )

/*++

Routine Description:

    This routine initializes the boot kernel debugger.

Arguments:

    Options - Supplies a pointer to the the boot options.

    Stop - Supplies a logical value that determines whether a debug message
        and breakpoint are generated.

Return Value:

    None.

--*/

{

    PCHAR BaudOption;
    ULONG BaudRate;
    ULONG Index;
    ULONG PortNumber;
    PCHAR PortOption;
    STRING String;

    //
    // If the boot debugger is not already initialized, then attempt to
    // initialize the debugger.
    //
   
    if (BdDebuggerEnabled == FALSE) {

        //
        // Set the address of the debug routine to the stub function and parse
        // any options if specified.
        //

        BdDebugRoutine = BdStub;
        if (Options != NULL) {
            _strupr(Options);

            //
            // If nodebug is not explicitly specified, then check if the baud
            // rate, com port, or debug is explicitly specified.
            //

            if (strstr(Options, "NODEBUG") == NULL) {
                PortNumber = 0;
                PortOption = strstr(Options, PORT_OPTION);
                BaudOption = strstr(Options, BAUD_OPTION);
                BaudRate = 0;
                if ((PortOption == NULL) && (BaudOption == NULL)) {
                    if (strstr(Options, "DEBUG") == NULL) {
                        return;
                    }

                } else {
                    if (PortOption != NULL) {
                        PortOption = strstr(PortOption, "COM");
                        if (PortOption != NULL) {
                            PortNumber = atol(PortOption + 3);
                        }
                    }

                    if (BaudOption != NULL) {
                        BaudOption += strlen(BAUD_OPTION);
                        while (*BaudOption == ' ') {
                            BaudOption++;
                        }

                        if (*BaudOption != '\0') {
                            BaudRate = atol(BaudOption + 1);
                        }
                    }
                }

                //
                // Attempt to initialize the debug port.
                //
                if (BdPortInitialize(BaudRate, PortNumber, &BdFileId) == FALSE) {
                    return;
                }

                //
                // Set the value of a break point instruction, set the address
                // of the debug routine to the trap function, set the debugger
                // enabled and initialize the breakpoint table.
                //

                BdBreakpointInstruction = BD_BREAKPOINT_VALUE;
                BdDebugRoutine = BdTrap;
                BdDebuggerEnabled = TRUE;
                for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
                    BdBreakpointTable[Index].Flags = 0;
                    BdBreakpointTable[Index].Address = 0;
                }

                //
                // Initialize the ID for the NEXT packet to send and the Expect
                // ID of next incoming packet.
                //

                BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                BdPacketIdExpected = INITIAL_PACKET_ID;

                //
                // Announce debugger initialized.
                //

                DbgPrint("BD: Boot Debugger Initialized\n");

                //
                // Notify the kernel debugger to load symbols for the loader.
                //

                String.Buffer = LoaderName;
                String.Length = (USHORT) strlen(LoaderName);
                DbgPrint("BD: %s base address %p\n", LoaderName, LoaderBase);
                DbgLoadImageSymbols(&String, LoaderBase, (ULONG_PTR)-1);

                if (strstr(Options, "DEBUGSTOP") != NULL) {

                    //
                    // Treat this like a request for initial breakpoint.
                    //

                    DbgBreakPoint();
                }

#if defined(EFI)
                //
                // if running under the debugger disable the watchdog so we 
                // don't get reset
                //
                DisableEFIWatchDog();
#endif

            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\poll.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    poll.c

Abstract:

    This module contains code to poll for debugger breakin.

Author:

    David N. Cutler (davec) 27-Nov-96

Revision History:

--*/

#include "bd.h"

LOGICAL
BdPollBreakIn(
    VOID
    )

/*++

Routine Description:

    This function checks to determine if a breakin packet is pending.
    If a packet is present.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

Return Value:

    A function value of TRUE is returned if a breakin packet is present.
    Otherwise, a value of FALSE is returned.

--*/

{

    LOGICAL BreakIn;
    UCHAR Input;
    ULONG Status;

    //
    // If the debugger is enabled, check if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (BdDebuggerEnabled != FALSE) {
        if (BdControlCPending != FALSE) {
            BdControlCPressed = TRUE;
            BreakIn = TRUE;
            BdControlCPending = FALSE;

        } else {
            Status = BlPortPollByte(BdFileId, &Input);
            if ((Status == CP_GET_SUCCESS) &&
                (Input == BREAKIN_PACKET_BYTE)) {
                BreakIn = TRUE;
                BdControlCPressed = TRUE;
            }
        }
    }

    return BreakIn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\message.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module implements the debugger state change message functions.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

#if ACCASM && !defined(_MSC_VER)

long asm(const char *,...);
#pragma intrinsic(asm)

#endif

KCONTINUE_STATUS
BdSendWaitContinue (
    IN ULONG OutPacketType,
    IN PSTRING OutMessageHeader,
    IN PSTRING OutMessageData OPTIONAL,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sends a packet and waits for a continue message. BreakIns
    received while waiting will always cause a resend of the packet originally
    sent out. While waiting state manipulate messages will be serviced.

    A resend always resends the original event sent to the debugger, not the
    last response to some debugger command.

Arguments:

    OutPacketType - Supplies the type of packet to send.

    OutMessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    OutMessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    ContextRecord - Exception context

Return Value:

    A value of TRUE is returned if the continue message indicates
    success, Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_MANIPULATE_STATE64 ManipulateState;
    ULONG ReturnCode;
    NTSTATUS Status;
    KCONTINUE_STATUS ContinueStatus;

    //
    // Loop servicing state manipulation message until a continue message
    // is received.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)&ManipulateState;
    MessageData.MaximumLength = BD_MESSAGE_BUFFER_SIZE;
    MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);

    //
    // Send event notification packet to debugger on host. Come back here
    // any time we see a breakin sequence.
    //

ResendPacket:
    BdSendPacket(OutPacketType,
                 OutMessageHeader,
                 OutMessageData);

    //
    // After sending packet, if there is no response from debugger and the
    // packet is for reporting symbol (un)load, the debugger will be declared
    // to be not present. Note If the packet is for reporting exception, the
    // BdSendPacket will never stop.
    //

    if (BdDebuggerNotPresent != FALSE) {
        return ContinueSuccess;
    }

    while (TRUE) {

        //
        // Wait for State Manipulate Packet without timeout.
        //

        do {
            ReturnCode = BdReceivePacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                                         &MessageHeader,
                                         &MessageData,
                                         &Length);

            if (ReturnCode == (USHORT)BD_PACKET_RESEND) {
                goto ResendPacket;
            }

        } while (ReturnCode == BD_PACKET_TIMEOUT);

        //
        // Switch on the return message API number.
        //

//        BlPrint("BdSendWait: api number %d\n", ManipulateState.ApiNumber);
        switch (ManipulateState.ApiNumber) {

        case DbgKdReadVirtualMemoryApi:
            BdReadVirtualMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteVirtualMemoryApi:
            BdWriteVirtualMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdReadPhysicalMemoryApi:
            BdReadPhysicalMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWritePhysicalMemoryApi:
            BdWritePhysicalMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdGetContextApi:
            BdGetContext(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdSetContextApi:
            BdSetContext(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteBreakPointApi:
            BdWriteBreakpoint(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdRestoreBreakPointApi:
            BdRestoreBreakpoint(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdReadControlSpaceApi:
            BdReadControlSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteControlSpaceApi:
            BdWriteControlSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdReadIoSpaceApi:
            BdReadIoSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteIoSpaceApi:
            BdWriteIoSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

#if defined(_ALPHA_) || defined(_AXP64_)

        case DbgKdReadIoSpaceExtendedApi:
            BdReadIoSpaceExtended(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteIoSpaceExtendedApi:
            BdWriteIoSpaceExtended(&ManipulateState, &MessageData, ContextRecord);
            break;

#endif

        case DbgKdContinueApi:
            if (NT_SUCCESS(ManipulateState.u.Continue.ContinueStatus) != FALSE) {
                return ContinueSuccess;

            } else {
                return ContinueError;
            }

            break;

        case DbgKdContinueApi2:
            if (NT_SUCCESS(ManipulateState.u.Continue2.ContinueStatus) != FALSE) {
                BdGetStateChange(&ManipulateState, ContextRecord);
                return ContinueSuccess;

            } else {
                return ContinueError;
            }

            break;

        case DbgKdRebootApi:
            BdReboot();
            break;

        case DbgKdGetVersionApi:
            BdGetVersion(&ManipulateState);
            break;

        case DbgKdWriteBreakPointExApi:
            Status = BdWriteBreakPointEx(&ManipulateState,
                                          &MessageData,
                                          ContextRecord);

            if (Status) {
                ManipulateState.ApiNumber = DbgKdContinueApi;
                ManipulateState.u.Continue.ContinueStatus = Status;
                return ContinueError;
            }

            break;

        case DbgKdRestoreBreakPointExApi:
            BdRestoreBreakPointEx(&ManipulateState, &MessageData, ContextRecord);
            break;

            //
            // Invalid message.
            //

        default:
            MessageData.Length = 0;
            ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
            BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                         &MessageHeader,
                         &MessageData);

            break;
        }

#ifdef _ALPHA_

        //
        //jnfix
        // this is embarrasing, we have an icache coherency problem that
        // the following imb fixes, later we must track this down to the
        // exact offending API but for now this statement allows the stub
        // work to appropriately for Alpha.
        //

#if defined(_MSC_VER)

        __PAL_IMB();

#else

        asm( "call_pal 0x86" );   // x86 = imb

#endif

#endif

    }
}

VOID
BdpSetCommonState(
    IN ULONG NewState,
    IN PCONTEXT ContextRecord,
    OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange
    )
{
    BOOLEAN DeletedBps;
    PCHAR PcMemory;
    USHORT InstrCount;
    PUCHAR InstrStream;
    
    WaitStateChange->NewState = NewState;
    WaitStateChange->ProcessorLevel = 0;
    WaitStateChange->Processor = 0;
    WaitStateChange->NumberProcessors = 1;
    WaitStateChange->Thread = 0;
    PcMemory = (PCHAR)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    WaitStateChange->ProgramCounter = (ULONG64)(LONG64)(LONG_PTR)PcMemory;

    RtlZeroMemory(&WaitStateChange->AnyControlReport,
                  sizeof(WaitStateChange->AnyControlReport));
    
    //
    // Copy instruction stream immediately following location of event.
    //

    InstrStream = WaitStateChange->ControlReport.InstructionStream;
    InstrCount = (USHORT)
        BdMoveMemory(InstrStream, PcMemory, DBGKD_MAXSTREAM);
    WaitStateChange->ControlReport.InstructionCount = InstrCount;

    //
    // Clear breakpoints in copied area.
    // If there were any breakpoints cleared, recopy the instruction area
    // without them.
    //

    if (BdDeleteBreakpointRange((ULONG_PTR)PcMemory,
                                (ULONG_PTR)PcMemory + InstrCount - 1)) {
        BdMoveMemory(InstrStream, PcMemory, InstrCount);
    }
}

LOGICAL
BdReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends an exception state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        BdpSetCommonState(DbgKdExceptionStateChange, ContextRecord,
                          &WaitStateChange);
        
        if (sizeof(EXCEPTION_RECORD) ==
            sizeof(WaitStateChange.u.Exception.ExceptionRecord)) {
            BdCopyMemory((PCHAR)&WaitStateChange.u.Exception.ExceptionRecord,
                         (PCHAR)ExceptionRecord,
                         sizeof(EXCEPTION_RECORD));
        } else {
            ExceptionRecord32To64((PEXCEPTION_RECORD32)ExceptionRecord,
                                  &WaitStateChange.u.Exception.ExceptionRecord);
        }

        WaitStateChange.u.Exception.FirstChance = TRUE;
        
        BdSetStateChange(&WaitStateChange,
                         ExceptionRecord,
                         ContextRecord);

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;
        MessageData.Length = 0;

        //
        // Send packet to the kernel debugger on the host machine,
        // wait for answer.
        //

        Status = BdSendWaitContinue(PACKET_TYPE_KD_STATE_CHANGE64,
                                    &MessageHeader,
                                    &MessageData,
                                    ContextRecord);

    } while (Status == ContinueProcessorReselected) ;

    return (BOOLEAN) Status;
}

LOGICAL
BdReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN LOGICAL UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a load symbols state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    PathName - Supplies a pointer to the pathname of the image whose
        symbols are to be loaded.

    BaseOfDll - Supplies the base address where the image was loaded.

    ProcessId - Unique 32-bit identifier for process that is using
        the symbols.  -1 for system process.

    CheckSum - Unique 32-bit identifier from image header.

    UnloadSymbol - TRUE if the symbols that were previously loaded for
        the named image are to be unloaded from the debugger.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    PSTRING AdditionalData;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        BdpSetCommonState(DbgKdLoadSymbolsStateChange, ContextRecord,
                          &WaitStateChange);
        BdSetContextState(&WaitStateChange, ContextRecord);

        WaitStateChange.u.LoadSymbols.UnloadSymbols = (BOOLEAN)UnloadSymbols;
        WaitStateChange.u.LoadSymbols.BaseOfDll = (ULONG64)SymbolInfo->BaseOfDll;
        WaitStateChange.u.LoadSymbols.ProcessId = SymbolInfo->ProcessId;
        WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo->CheckSum;
        WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo->SizeOfImage;
        if (ARGUMENT_PRESENT(PathName)) {
            WaitStateChange.u.LoadSymbols.PathNameLength =
                BdMoveMemory((PCHAR)BdMessageBuffer,
                             (PCHAR)PathName->Buffer,
                             PathName->Length) + 1;

            MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);
            MessageData.Length = (USHORT)WaitStateChange.u.LoadSymbols.PathNameLength;
            MessageData.Buffer[MessageData.Length-1] = '\0';
            AdditionalData = &MessageData;

        } else {
            WaitStateChange.u.LoadSymbols.PathNameLength = 0;
            AdditionalData = NULL;
        }

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = BdSendWaitContinue(PACKET_TYPE_KD_STATE_CHANGE64,
                                     &MessageHeader,
                                     AdditionalData,
                                     ContextRecord);

    } while (Status == ContinueProcessorReselected);

    return (BOOLEAN) Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

TARGETNAME=bd
TARGETPATH=obj
TARGETTYPE=LIBRARY

!IF "$(BUILD_DEBUG_LOADER)" != ""
!include $(PROJECT_ROOT)\boot\loader_dbg.inc
!ELSE
!include $(PROJECT_ROOT)\boot\loader.inc
!ENDIF

INCLUDES=\
    ..;\
    ..\..\inc;\
    ..\..\lib;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\ntos\ke;\
    ..\$(TARGET_DIRECTORY);\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\cdfs;\
    $(PROJECT_ROOT)\fs\udfs;\
    $(PROJECT_ROOT)\fs\ntfs;\
    $(SDKTOOLS_INC_PATH)

SOURCES=..\break.c   \
        ..\comio.c   \
        ..\data.c    \
        ..\dbgio.c   \
        ..\file.c    \
        ..\init.c    \
        ..\message.c \
        ..\move.c    \
        ..\poll.c    \
        ..\xxapi.c
        
!IF $(IA64)
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DEFI
!endif


PRECOMPILED_INCLUDE=..\bd.h
PRECOMPILED_PCH=bd.pch
PRECOMPILED_OBJ=bd.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\xxapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module implements the boot bebugger platform independent remote APIs.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

VOID
BdGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{

    STRING messageHeader;

    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;
    RtlZeroMemory(&m->u.GetVersion64, sizeof(m->u.GetVersion64));

    //
    // the current build number
    //
    // - 4 - tells the debugger this is a "special" OS - the boot loader.
    // The boot loader has a lot of special cases associated with it, like
    // the lack of the DebuggerDataBlock, lack of ntoskrnl, etc ...
    //

    m->u.GetVersion64.MinorVersion = (short)NtBuildNumber;
    m->u.GetVersion64.MajorVersion = 0x400 |
                                     (short)((NtBuildNumber >> 28) & 0xFFFFFFF);

    //
    // Kd protocol version number.
    //

    m->u.GetVersion64.ProtocolVersion = DBGKD_64BIT_PROTOCOL_VERSION2;
    m->u.GetVersion64.Flags = DBGKD_VERS_FLAG_DATA;

#if defined(_M_IX86)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_I386;

#elif defined(_M_MRX000)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_R4000;

#elif defined(_M_ALPHA)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_ALPHA;

#elif defined(_M_PPC)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_POWERPC;

#elif defined(_IA64_)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_IA64;
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;

#else

#error( "unknown target machine" );

#endif

    m->u.GetVersion64.MaxPacketType = (UCHAR)(PACKET_TYPE_KD_FILE_IO + 1);;
    m->u.GetVersion64.MaxStateChange = (UCHAR)(DbgKdLoadSymbolsStateChange + 1);;
    m->u.GetVersion64.MaxManipulate = (UCHAR)(DbgKdSetBusDataApi + 1);


    //
    // address of the loader table
    //

    m->u.GetVersion64.PsLoadedModuleList = 0;
    m->u.GetVersion64.KernBase = 0;
    //m->u.GetVersion64.ThCallbackStack = 0;
    //m->u.GetVersion64.KiCallUserMode = 0;
    //m->u.GetVersion64.KeUserCallbackDispatcher = 0;
    //m->u.GetVersion64.NextCallback = 0;

#if defined(_X86_)

    //m->u.GetVersion64.FramePointer = 0;

#endif

    //m->u.GetVersion64.BreakpointWithStatus = 0;
    m->u.GetVersion64.DebuggerDataList = 0;

    //
    // the usual stuff
    //

    m->ReturnStatus = STATUS_SUCCESS;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &messageHeader,
                 NULL);

    return;
}

VOID
BdGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a get context state
    manipulation message.  Its function is to return the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_GET_CONTEXT a = &m->u.GetContext;
    STRING MessageHeader;

    m->ReturnStatus = STATUS_SUCCESS;
    AdditionalData->Length = sizeof(CONTEXT);
    BdCopyMemory(AdditionalData->Buffer, (PCHAR)Context, sizeof(CONTEXT));

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a set context state
    manipulation message.  Its function is set the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_SET_CONTEXT a = &m->u.SetContext;
    STRING MessageHeader;

    m->ReturnStatus = STATUS_SUCCESS;
    BdCopyMemory((PCHAR)Context, AdditionalData->Buffer, sizeof(CONTEXT));

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);
}

VOID
BdReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read virtual memory 32-bit
    state manipulation message. Its function is to read virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to read.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{

    ULONG Length;
    STRING MessageHeader;

    //
    // Trim the transfer count to fit in a single message.
    //

    Length = min(m->u.ReadMemory.TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    //
    // Move the data to the destination buffer.
    //

    AdditionalData->Length = (USHORT)BdMoveMemory((PCHAR)AdditionalData->Buffer,
                                                  (PCHAR)m->u.ReadMemory.TargetBaseAddress,
                                                  Length);

    //
    // If all the data is read, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes read, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.ReadMemory.ActualBytesRead = AdditionalData->Length;
    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData);

    return;
}

VOID
BdWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write virtual memory 32-bit
    state manipulation message. Its function is to write virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to write.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{

    ULONG Length;
    STRING MessageHeader;

    //
    // Move the data to the destination buffer.
    //

    Length = BdMoveMemory((PCHAR)m->u.WriteMemory.TargetBaseAddress,
                          (PCHAR)AdditionalData->Buffer,
                          AdditionalData->Length);

    //
    // If all the data is written, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes written, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.WriteMemory.ActualBytesWritten = Length;
    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state
    manipulation message.  Its function is to write a breakpoint
    and return a handle to the breakpoint.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_BREAKPOINT64 a = &m->u.WriteBreakPoint;
    STRING MessageHeader;


    a->BreakPointHandle = BdAddBreakpoint(a->BreakPointAddress);
    if (a->BreakPointHandle != 0) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state
    manipulation message.  Its function is to restore a breakpoint
    using the specified handle.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_RESTORE_BREAKPOINT a = &m->u.RestoreBreakPoint;
    STRING MessageHeader;

    if (BdDeleteBreakpoint(a->BreakPointHandle)) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);
}

VOID
BdReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read physical memory
    state manipulation message. Its function is to read physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID VirtualAddress;
    PHYSICAL_ADDRESS Source;
    PUCHAR Destination;
    USHORT NumberBytes;
    USHORT BytesLeft;

    //
    // Trim transfer count to fit in a single message.
    //

    Length = min(a->TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    //
    // Since the BdTranslatePhysicalAddress only maps in one physical
    // page at a time, we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  There are two cases we
    // need to deal with.  The area to be moved may start and end on the
    // same page, or it may start and end on different pages (with an
    // arbitrary number of pages in between)
    //

    Source.QuadPart = (ULONG_PTR)a->TargetBaseAddress;
    Destination = AdditionalData->Buffer;
    BytesLeft = (USHORT)Length;
    if(PAGE_ALIGN((PUCHAR)a->TargetBaseAddress) ==
       PAGE_ALIGN((PUCHAR)(a->TargetBaseAddress)+Length)) {

        //
        // Memory move starts and ends on the same page.
        //

        VirtualAddress=BdTranslatePhysicalAddress(Source);
        if (VirtualAddress == NULL) {
            AdditionalData->Length = 0;

        } else {
            AdditionalData->Length = (USHORT)BdMoveMemory(Destination,
                                                          VirtualAddress,
                                                          BytesLeft);

            BytesLeft -= AdditionalData->Length;
        }

    } else {

        //
        // Memory move spans page boundaries
        //

        VirtualAddress=BdTranslatePhysicalAddress(Source);
        if (VirtualAddress == NULL) {
            AdditionalData->Length = 0;

        } else {
            NumberBytes = (USHORT)(PAGE_SIZE - BYTE_OFFSET(VirtualAddress));
            AdditionalData->Length = (USHORT)BdMoveMemory(Destination,
                                                          VirtualAddress,
                                                          NumberBytes);

            Source.LowPart += NumberBytes;
            Destination += NumberBytes;
            BytesLeft -= NumberBytes;
            while(BytesLeft > 0) {

                //
                // Transfer a full page or the last bit,
                // whichever is smaller.
                //

                VirtualAddress = BdTranslatePhysicalAddress(Source);
                if (VirtualAddress == NULL) {
                    break;

                } else {
                    NumberBytes = (USHORT) ((PAGE_SIZE < BytesLeft) ? PAGE_SIZE : BytesLeft);
                    AdditionalData->Length += (USHORT)BdMoveMemory(
                                                    Destination,
                                                    VirtualAddress,
                                                    NumberBytes);

                    Source.LowPart += NumberBytes;
                    Destination += NumberBytes;
                    BytesLeft -= NumberBytes;
                }
            }
        }
    }

    if (Length == AdditionalData->Length) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    a->ActualBytesRead = AdditionalData->Length;

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a write physical memory
    state manipulation message. Its function is to write physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID VirtualAddress;
    PHYSICAL_ADDRESS Destination;
    PUCHAR Source;
    USHORT NumberBytes;
    USHORT BytesLeft;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // Since the BdTranslatePhysicalAddress only maps in one physical
    // page at a time, we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  There are two cases we
    // need to deal with.  The area to be moved may start and end on the
    // same page, or it may start and end on different pages (with an
    // arbitrary number of pages in between)
    //

    Destination.QuadPart = (ULONG_PTR)a->TargetBaseAddress;
    Source = AdditionalData->Buffer;
    BytesLeft = (USHORT) a->TransferCount;
    if(PAGE_ALIGN(Destination.QuadPart) ==
       PAGE_ALIGN(Destination.QuadPart+BytesLeft)) {

        //
        // Memory move starts and ends on the same page.
        //

        VirtualAddress=BdTranslatePhysicalAddress(Destination);
        Length = (USHORT)BdMoveMemory(VirtualAddress,
                                      Source,
                                      BytesLeft);

        BytesLeft -= (USHORT) Length;

    } else {

        //
        // Memory move spans page boundaries
        //

        VirtualAddress=BdTranslatePhysicalAddress(Destination);
        NumberBytes = (USHORT) (PAGE_SIZE - BYTE_OFFSET(VirtualAddress));
        Length = (USHORT)BdMoveMemory(VirtualAddress,
                                      Source,
                                      NumberBytes);

        Source += NumberBytes;
        Destination.LowPart += NumberBytes;
        BytesLeft -= NumberBytes;
        while(BytesLeft > 0) {

            //
            // Transfer a full page or the last bit, whichever is smaller.
            //

            VirtualAddress = BdTranslatePhysicalAddress(Destination);
            NumberBytes = (USHORT) ((PAGE_SIZE < BytesLeft) ? PAGE_SIZE : BytesLeft);
            Length += (USHORT)BdMoveMemory(VirtualAddress,
                                           Source,
                                           NumberBytes);

            Source += NumberBytes;
            Destination.LowPart += NumberBytes;
            BytesLeft -= NumberBytes;
        }
    }


    if (Length == AdditionalData->Length) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    a->ActualBytesWritten = Length;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

NTSTATUS
BdWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state 'ex'
    manipulation message.  Its function is to clear breakpoints, write
    new breakpoints, and continue the target system.  The clearing of
    breakpoints is conditional based on the presence of breakpoint handles.
    The setting of breakpoints is conditional based on the presence of
    valid, non-zero, addresses.  The continueing of the target system
    is conditional based on a non-zero continuestatus.

    This api allows a debugger to clear breakpoints, add new breakpoint,
    and continue the target system all in one api packet.  This reduces the
    amount of traffic across the wire and greatly improves source stepping.


Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_BREAKPOINTEX         a = &m->u.BreakPointEx;
    PDBGKD_WRITE_BREAKPOINT64   b;
    STRING                      MessageHeader;
    ULONG                       i;
    DBGKD_WRITE_BREAKPOINT64    BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //

    if (AdditionalData->Length !=
                         a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        BdSendPacket(
                      PACKET_TYPE_KD_STATE_MANIPULATE,
                      &MessageHeader,
                      AdditionalData
                      );
        return m->ReturnStatus;
    }

    BdMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    //
    // assume success
    //
    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //

    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointHandle) {
            if (!BdDeleteBreakpoint(b->BreakPointHandle)) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }

            b->BreakPointHandle = 0;
        }
    }

    //
    // loop thru the breakpoint addesses passed in from the debugger and
    // add any new breakpoints that have a non-zero address
    //

    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointAddress) {
            b->BreakPointHandle = BdAddBreakpoint( b->BreakPointAddress );
            if (!b->BreakPointHandle) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    //
    // send back our response
    //

    BdMoveMemory(AdditionalData->Buffer,
                 (PUCHAR)BpBuf,
                 a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //

    return a->ContinueStatus;
}

VOID
BdRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state 'ex'
    manipulation message.  Its function is to clear a list of breakpoints.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_BREAKPOINTEX       a = &m->u.BreakPointEx;
    PDBGKD_RESTORE_BREAKPOINT b;
    STRING                    MessageHeader;
    ULONG                     i;
    DBGKD_RESTORE_BREAKPOINT  BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //

    if (AdditionalData->Length !=
                       a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                     &MessageHeader,
                     AdditionalData);

        return;
    }

    BdMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT));

    //
    // assume success
    //

    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //

    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (!BdDeleteBreakpoint(b->BreakPointHandle)) {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }

    //
    // send back our response
    //

    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\cpu.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpu.h

Abstract:

    Machine specific kernel debugger data types and constants.

Author:

    Mark Lucovsky (markl) 29-Aug-1990

Revision History:

--*/

#ifndef _BDCPU_
#define _BDCPU_
#include "bldrx86.h"

//
// Define debug routine prototypes.
//

typedef
LOGICAL
(*PBD_DEBUG_ROUTINE) (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

#define BD_BREAKPOINT_TYPE  UCHAR
#define BD_BREAKPOINT_ALIGN 0
#define BD_BREAKPOINT_VALUE 0xcc

#endif // _BDCPU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\check.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements memory check routine for the boot debugger.

Author:

    David N. Cutler (davec) 3-Dec-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bd.h"

extern BOOLEAN PaeEnabled;



BOOLEAN
BdCheckPdeValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PDE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PDE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    PHARDWARE_PTE_X86PAE PdePae;
    PHARDWARE_PTE_X86 PdeX86;

    if (PaeEnabled) {

        //
        // Physical address extenions are enabled.
        // 

        PdePae = (PHARDWARE_PTE_X86PAE)PDE_BASE_X86PAE;
        PdePae = &PdePae[ (ULONG)Address >> PDI_SHIFT_X86PAE ];

        if (PdePae->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }

    } else {

        //
        // Physical address extensions are not enabled.
        //

        PdeX86 = (PHARDWARE_PTE_X86)PDE_BASE;
        PdeX86 = &PdeX86[ (ULONG)Address >> PDI_SHIFT_X86 ];

        if (PdeX86->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }
}

BOOLEAN
BdCheckPteValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PTE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PTE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    PHARDWARE_PTE_X86PAE PtePae;
    PHARDWARE_PTE_X86 PteX86;

    if (PaeEnabled) {

        //
        // Physical address extenions are enabled.
        // 

        PtePae = (PHARDWARE_PTE_X86PAE)PTE_BASE;
        PtePae = &PtePae[ (ULONG)Address >> PTI_SHIFT ];

        if (PtePae->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }

    } else {

        //
        // Physical address extensions are not enabled.
        //

        PteX86 = (PHARDWARE_PTE_X86)PTE_BASE;
        PteX86 = &PteX86[ (ULONG)Address >> PTI_SHIFT ];

        if (PteX86->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }
}


PVOID
BdReadCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be read.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or readable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    //
    // Check if the page containing the specified address is valid.
    //
    // N.B. If the address is valid, it is readable.
    //

    if (BdCheckPdeValid( Address ) == FALSE) {

        //
        // The PDE is not valid.
        //

        return NULL;
    }

    if (BdCheckPteValid( Address ) == FALSE) {

        //
        // The PDE was valid but the PTE is not.
        //

        return NULL;
    }

    return Address;
}

PVOID
BdWriteCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be written.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or writeable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    //
    // Check if the page containing the specified address is valid.
    //
    // N.B. If the address is valid, it is writeable since the WP bit
    //      is not set in cr0.
    //

    if (BdCheckPdeValid( Address ) == FALSE) {

        //
        // The PDE is not valid.
        //

        return NULL;
    }

    if (BdCheckPteValid( Address ) == FALSE) {

        //
        // The PDE was valid but the PTE is not.
        //

        return NULL;
    }

    return Address;
}

PVOID
BdTranslatePhysicalAddress (
    IN PHYSICAL_ADDRESS Address
    )

/*++

Routine Description:

    This routine returns the phyiscal address for a physical address
    which is valid (mapped).

Arguments:

    Address - Supplies the physical address to check.

Return Value:

    Returns NULL if the address is not valid or readable. Otherwise,
    returns the physical address of the corresponding virtual address.

--*/

{

    return (PVOID)Address.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\cpuapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Mark Lucovsky (markl) 04-Sep-1990

Revision History:

--*/

#include "bd.h"

//
// Define end of control space.
//

#define END_OF_CONTROL_SPACE ((PCHAR)(sizeof(KPROCESSOR_STATE)))

VOID
BdSetContextState(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function fills in the processor-specific portions of
    the wait state change message record.

Arguments:

    WaitStateChange - Supplies a pointer to record to fill in.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    //
    // Special registers for the x86.
    //

    WaitStateChange->ControlReport.Dr6 = BdPrcb.ProcessorState.SpecialRegisters.KernelDr6;
    WaitStateChange->ControlReport.Dr7 = BdPrcb.ProcessorState.SpecialRegisters.KernelDr7;
    WaitStateChange->ControlReport.SegCs = (USHORT)(ContextRecord->SegCs);
    WaitStateChange->ControlReport.SegDs = (USHORT)(ContextRecord->SegDs);
    WaitStateChange->ControlReport.SegEs = (USHORT)(ContextRecord->SegEs);
    WaitStateChange->ControlReport.SegFs = (USHORT)(ContextRecord->SegFs);
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;
    WaitStateChange->ControlReport.ReportFlags = X86_REPORT_INCLUDES_SEGS;
    return;
}

VOID
BdGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function extracts continuation control data from a manipulate state
    message.

Arguments:

    ManipulateState - Supplies a pointer to the manipulate state packet.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    //
    // If the continuation status is success, then set control space value.
    //

    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) != FALSE) {

        //
        // Set trace flag.
        //

        if (ManipulateState->u.Continue2.ControlSet.TraceFlag == TRUE) {
            ContextRecord->EFlags |= 0x100L;

        } else {
            ContextRecord->EFlags &= ~0x100L;

        }

        //
        // Set debug registers in processor control block.
        //

        BdPrcb.ProcessorState.SpecialRegisters.KernelDr6 = 0L;
        BdPrcb.ProcessorState.SpecialRegisters.KernelDr7 =
                                     ManipulateState->u.Continue2.ControlSet.Dr7;
    }
}

VOID
BdSetStateChange(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Fill in the wait state change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    BdSetContextState(WaitStateChange, ContextRecord);
}

VOID
BdReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // read the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    Length = min(a->TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    if (((PCHAR)a->TargetBaseAddress + Length) <= END_OF_CONTROL_SPACE) {
        BdCopyMemory(AdditionalData->Buffer,
                     (PCHAR)&BdPrcb.ProcessorState + (ULONG)a->TargetBaseAddress,
                     Length);

        m->ReturnStatus = STATUS_SUCCESS;
        a->ActualBytesRead = Length;
        AdditionalData->Length = (USHORT)Length;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesRead = 0;
        AdditionalData->Length = 0;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function writes control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // write the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    Length = min(a->TransferCount, AdditionalData->Length);
    if (((PCHAR)a->TargetBaseAddress + Length) <= END_OF_CONTROL_SPACE) {
        BdCopyMemory((PCHAR)&BdPrcb.ProcessorState + (ULONG)a->TargetBaseAddress,
                     AdditionalData->Buffer,
                     Length);

        m->ReturnStatus = STATUS_SUCCESS;
        a->ActualBytesWritten = Length;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesWritten = 0;
    }

    //
    // Send reply message.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case of data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            a->DataValue = (ULONG)READ_PORT_UCHAR((PUCHAR)a->IoAddress);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = (ULONG)READ_PORT_USHORT((PUSHORT)a->IoAddress);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = READ_PORT_ULONG((PULONG)a->IoAddress);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function wrties I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case on data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)a->IoAddress, (UCHAR)a->DataValue);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_USHORT((PUSHORT)a->IoAddress, (USHORT)a->DataValue);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_ULONG((PULONG)a->IoAddress, a->DataValue);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support the boot debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "bd.h"

_TUCHAR DebugMessage[80];

LOGICAL
BdPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    OUT PULONG BdFileId
    )

/*++

Routine Description:

    This functions initializes the boot debugger com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.

Returned Value:

    TRUE - If a debug port is found.

--*/

{
    //
    // Initialize the specified port.
    //
    if (!BlPortInitialize(BaudRate, PortNumber, NULL, FALSE, BdFileId)) {
        return FALSE;
    }
    _stprintf(DebugMessage,
            TEXT("\nBoot Debugger Using: COM%d (Baud Rate %d)\n"),
            PortNumber,
            BaudRate);

    //
    // We cannot use BlPrint() at this time because BlInitStdIo() has not been called, which is
    // required to use the Arc emulator code.
    //    
    TextStringOut(DebugMessage);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\reboot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bdreboot.c

Abstract:

    System reboot function.  Currently part of the debugger because
    that's the only place it's used.

Author:

    Bryan M. Willman (bryanwi) 4-Dec-90

Revision History:

--*/

#include "bd.h"

VOID
FwStallExecution(
    IN ULONG Microseconds
    );


#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64


VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
    UCHAR   Scratch;
    PUSHORT   Magic;

    //
    // Turn off interrupts
    //

    _asm {
        cli
    }

    //
    // Reset the cmos clock to a standard value
    // (We are setting the periodic interrupt control on the MC147818)
    //

    //
    // Disable periodic interrupt
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0b);      // Set up for control reg B.
    FwStallExecution(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    FwStallExecution(1);

    Scratch &= 0xbf;                        // Clear periodic interrupt enable

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    FwStallExecution(1);

    //
    // Set "standard" divider rate
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0a);      // Set up for control reg A.
    FwStallExecution(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    FwStallExecution(1);

    Scratch &= 0xf0;                        // Clear rate setting
    Scratch |= 6;                           // Set default rate and divider

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    FwStallExecution(1);

    //
    // Set a "neutral" cmos address to prevent weirdness
    // (Why is this needed? Source this was copied from doesn't say)
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x15);
    FwStallExecution(1);

    //
    // If we return, send the reset command to the keyboard controller
    //

    WRITE_PORT_UCHAR(KEYBPORT, RESET);

    _asm {
        hlt
    }
}


VOID
BdReboot (
    VOID
    )

/*++

Routine Description:

    Just calls the HalReturnToFirmware function.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    //
    // Never returns from HAL
    //

    HalpReboot();

    while (TRUE) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This modules implements debug prints.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"

VOID
BdPrintf(
    IN PCHAR Format,
    ...
    )

/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    Format - Supplies a pointer to a format string.

Return Value:

    None

--*/

{

    CHAR Buffer[100];
    va_list mark;
    STRING String;

    va_start(mark, Format);
    _vsnprintf(&Buffer[0], 100, Format, mark);
    va_end(mark);

    BlPrint(TEXT("%s"), &Buffer[0]);
    String.Buffer = &Buffer[0];
    String.Length = (USHORT) strlen(&Buffer[0]);
    BdPrintString(&String);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdtrap.c

Abstract:

    This module contains code to implement the target side of the boot debugger.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"

//
// Define forward referenced function prototypes.
//

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextRecord
    );

VOID
BdSaveKframe(
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextRecord
    );

LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the boot
    debugger is active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    LOGICAL Completion;
    PCONTEXT ContextRecord;
    ULONG OldEip;
    STRING Input;
    STRING Output;
    PKD_SYMBOLS_INFO SymbolInfo;
    LOGICAL UnloadSymbols;

    //
    // Set address of context record and set context flags.
    //

    ContextRecord = &BdPrcb.ProcessorState.ContextFrame;
    ContextRecord->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;

    //
    // Print, prompt, load symbols, and unload symbols are all special cases
    // of STATUS_BREAKPOINT.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        //
        // Switch on the request type.
        //

        UnloadSymbols = FALSE;
        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print:
            //
            //  ExceptionInformation[1] is a PSTRING which describes the string
            //  to print.
            //

            case BREAKPOINT_PRINT:
                Output.Buffer = (PCHAR)ExceptionRecord->ExceptionInformation[1];
                Output.Length = (USHORT)ExceptionRecord->ExceptionInformation[2];
                if (BdDebuggerNotPresent == FALSE) {
                    if (BdPrintString(&Output)) {
                        TrapFrame->Eax = (ULONG)(STATUS_BREAKPOINT);

                    } else {
                        TrapFrame->Eax = STATUS_SUCCESS;
                    }

                } else {
                    TrapFrame->Eax = (ULONG)STATUS_DEVICE_NOT_CONNECTED;
                }

                TrapFrame->Eip += 1;
                return TRUE;

            //
            // Prompt:
            //
            //  ExceptionInformation[1] is a PSTRING which describes the prompt
            //      string,
            //
            //  ExceptionInformation[2] is a PSTRING that describes the return
            //      string.
            //

            case BREAKPOINT_PROMPT:
                Output.Buffer = (PCHAR)ExceptionRecord->ExceptionInformation[1];
                Output.Length = (USHORT)ExceptionRecord->ExceptionInformation[2];
                Input.Buffer = (PCHAR)TrapFrame->Ebx;;
                Input.MaximumLength = (USHORT)TrapFrame->Edi;

                //
                // Prompt and keep prompting until no breakin seen.
                //

                do {
                } while (BdPromptString(&Output, &Input) != FALSE);

                TrapFrame->Eax = Input.Length;
                TrapFrame->Eip += 1;
                return TRUE;

            //
            // Unload symbols:
            //
            //  ExceptionInformation[1] is file name of a module.
            //  ExceptionInformaiton[2] is the base of the dll.
            //

            case BREAKPOINT_UNLOAD_SYMBOLS:
                UnloadSymbols = TRUE;

                //
                // Fall through to load symbols case.
                //

            case BREAKPOINT_LOAD_SYMBOLS:
                BdSaveKframe(TrapFrame, ContextRecord);
                OldEip = ContextRecord->Eip;
                SymbolInfo = (PKD_SYMBOLS_INFO)ExceptionRecord->ExceptionInformation[2];
                if (BdDebuggerNotPresent == FALSE) {
                    BdReportLoadSymbolsStateChange((PSTRING)ExceptionRecord->ExceptionInformation[1],
                                                   SymbolInfo,
                                                   UnloadSymbols,
                                                   ContextRecord);
                }

                //
                // If the kernel debugger did not update EIP, then increment
                // past the breakpoint instruction.
                //

                if (ContextRecord->Eip == OldEip) {
                    ContextRecord->Eip += 1;
                }

                BdRestoreKframe(TrapFrame, ContextRecord);
                return TRUE;

            //
            //  Unknown command
            //

            default:
                return FALSE;
        }

    } else {

        //
        // Report state change to kernel debugger on host.
        //

        BdSaveKframe(TrapFrame, ContextRecord);
        Completion =
            BdReportExceptionStateChange(ExceptionRecord,
                                         &BdPrcb.ProcessorState.ContextFrame);

        BdRestoreKframe(TrapFrame, ContextRecord);
        BdControlCPressed = FALSE;
        return TRUE;
    }
}

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints when the boot debugger is not active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    //
    // If the exception is a breakpoint and the function is a load symbols,
    // unload symbols, or a print, then return TRUE. Otherwise, return FALSE.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {
        TrapFrame->Eip += 1;
        return TRUE;

    } else {
        return FALSE;

    }
}

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This functions copie the processor state from a context record and
    the processor control block into the trap frame.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    //
    // Copy information from context record to trap frame.
    //
    // Copy control information.
    //

    TrapFrame->Ebp = ContextRecord->Ebp;
    TrapFrame->Eip = ContextRecord->Eip;
    TrapFrame->SegCs = ContextRecord->SegCs;
    TrapFrame->EFlags = ContextRecord->EFlags;

    //
    // Copy segment register contents.
    //

    TrapFrame->SegDs = ContextRecord->SegDs;
    TrapFrame->SegEs = ContextRecord->SegEs;
    TrapFrame->SegFs = ContextRecord->SegFs;
    TrapFrame->SegGs = ContextRecord->SegGs;

    //
    // Copy integer registers contents.
    //

    TrapFrame->Edi = ContextRecord->Edi;
    TrapFrame->Esi = ContextRecord->Esi;
    TrapFrame->Ebx = ContextRecord->Ebx;
    TrapFrame->Ecx = ContextRecord->Ecx;
    TrapFrame->Edx = ContextRecord->Edx;
    TrapFrame->Eax = ContextRecord->Eax;

    //
    // Restore processor state.
    //

    KiRestoreProcessorControlState(&BdPrcb.ProcessorState);
    return;
}

VOID
BdSaveKframe(
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This functions copis the processor state from a trap frame and the
    processor control block into a context record.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    //
    // Copy information from trap frame to context record.
    //
    // Copy control information.
    //

    ContextRecord->Ebp = TrapFrame->Ebp;
    ContextRecord->Eip = TrapFrame->Eip;
    ContextRecord->SegCs = TrapFrame->SegCs & SEGMENT_MASK;
    ContextRecord->EFlags = TrapFrame->EFlags;
    ContextRecord->Esp = TrapFrame->TempEsp;
    ContextRecord->SegSs = TrapFrame->TempSegCs;

    //
    // Copy segment register contents.
    //

    ContextRecord->SegDs = TrapFrame->SegDs & SEGMENT_MASK;
    ContextRecord->SegEs = TrapFrame->SegEs & SEGMENT_MASK;
    ContextRecord->SegFs = TrapFrame->SegFs & SEGMENT_MASK;
    ContextRecord->SegGs = TrapFrame->SegGs & SEGMENT_MASK;

    //
    // Copy the integer register contents.
    //

    ContextRecord->Eax = TrapFrame->Eax;
    ContextRecord->Ebx = TrapFrame->Ebx;
    ContextRecord->Ecx = TrapFrame->Ecx;
    ContextRecord->Edx = TrapFrame->Edx;
    ContextRecord->Edi = TrapFrame->Edi;
    ContextRecord->Esi = TrapFrame->Esi;

    //
    // Copy debug register contents.
    //

    ContextRecord->Dr0 = TrapFrame->Dr0;
    ContextRecord->Dr1 = TrapFrame->Dr1;
    ContextRecord->Dr2 = TrapFrame->Dr2;
    ContextRecord->Dr3 = TrapFrame->Dr3;
    ContextRecord->Dr6 = TrapFrame->Dr6;
    ContextRecord->Dr7 = TrapFrame->Dr7;

    //
    // Save processor control state.
    //

    KiSaveProcessorControlState(&BdPrcb.ProcessorState);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\state.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    procstat.asm
;
; Abstract:
;
;    This module implements procedures for saving and restoring
;    processor control state.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 30-Aug-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.486p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        page ,132
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page    ,132
        subttl  "Save Processor Control State"
;++
;
; KiSaveProcessorControlState(
;    PKPROCESSOR_STATE ProcessorState
;    );
;
; Routine Description:
;
;    This routine saves the control subset of the processor state.
;    (Saves the same information as KiSaveProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT saved.)
;    Called by the debug subsystem, and KiSaveProcessorState()
;
;   N.B.  This procedure will save Dr7, and then 0 it.  This prevents
;         recursive hardware trace breakpoints and allows debuggers
;         to work.
;
; Arguments:
;
;    ProcessorState - Supplies the address of the processor state.

; Return Value:
;
;    None.
;
;--

cPublicProc _KiSaveProcessorControlState   ,1

        mov     edx, [esp+4]            ; get processor state address

;
; Save special registers for debugger
;
        xor     ecx,ecx

        mov     eax, cr0
        mov     [edx].PsSpecialRegisters.SrCr0, eax
        mov     eax, cr2
        mov     [edx].PsSpecialRegisters.SrCr2, eax
        mov     eax, cr3
        mov     [edx].PsSpecialRegisters.SrCr3, eax

        mov     [edx].PsSpecialRegisters.SrCr4, ecx

        mov     eax,dr0
        mov     [edx].PsSpecialRegisters.SrKernelDr0,eax
        mov     eax,dr1
        mov     [edx].PsSpecialRegisters.SrKernelDr1,eax
        mov     eax,dr2
        mov     [edx].PsSpecialRegisters.SrKernelDr2,eax
        mov     eax,dr3
        mov     [edx].PsSpecialRegisters.SrKernelDr3,eax
        mov     eax,dr6
        mov     [edx].PsSpecialRegisters.SrKernelDr6,eax

        mov     eax,dr7
        mov     dr7,ecx
        mov     [edx].PsSpecialRegisters.SrKernelDr7,eax

        sgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        sidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

        str     word ptr [edx].PsSpecialRegisters.SrTr
        sldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiSaveProcessorControlState

stdENDP _KiSaveProcessorControlState

        page    ,132
        subttl  "Restore Processor Control State"
;++
;
; KiRestoreProcessorControlState(
;    PKPROCESSOR_STATE ProcessorState
;    );
;
; Routine Description:
;
;    This routine restores the control subset of the processor state.
;    (Restores the same information as KiRestoreProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT restored.)
;    Called by the debug subsystem, and KiRestoreProcessorState()
;
; Arguments:
;
;    ProcessorState - Supplies the address of the processor state.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiRestoreProcessorControlState,1

        mov     edx, [esp+4]                    ; (edx)->ProcessorState

;
; Restore special registers for debugger
;

        mov     eax, [edx].PsSpecialRegisters.SrCr0
        mov     cr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr2
        mov     cr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr3
        mov     cr3, eax

        mov     eax, [edx].PsSpecialRegisters.SrKernelDr0
        mov     dr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr1
        mov     dr1, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr2
        mov     dr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr3
        mov     dr3, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr6
        mov     dr6, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr7
        mov     dr7, eax

        lgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        lidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

        lldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiRestoreProcessorControlState

stdENDP _KiRestoreProcessorControlState

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\check.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements memory check routine for the boot debugger.

Author:

    David N. Cutler (davec) 3-Dec-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bd.h"

extern BOOLEAN PaeEnabled;



BOOLEAN
BdCheckPdeValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PDE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PDE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    return FALSE;
}

BOOLEAN
BdCheckPteValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PTE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PTE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    return FALSE;
}


PVOID
BdReadCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be read.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or readable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    return Address;
}

PVOID
BdWriteCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be written.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or writeable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    return Address;
}

PVOID
BdTranslatePhysicalAddress (
    IN PHYSICAL_ADDRESS Address
    )

/*++

Routine Description:

    This routine returns the phyiscal address for a physical address
    which is valid (mapped).

Arguments:

    Address - Supplies the physical address to check.

Return Value:

    Returns NULL if the address is not valid or readable. Otherwise,
    returns the physical address of the corresponding virtual address.

--*/

{
    return (PVOID)UlongToPtr(Address.LowPart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\i386\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    trap.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    trap conditions.
;
; Author:
;
;    David N. Cutler (davec) 1-Dec-96
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc
include i386\kimacro.inc
include mac386.inc
        .list

        extrn   _BdDebugRoutine:DWORD

        page ,132
        subttl "Equated Values"
;
; Debug register 6 (dr6) BS (single step) bit mask
;

DR6_BS_MASK                     EQU     4000H

;
; EFLAGS single step bit
;

EFLAGS_TF_BIT                   EQU     100h
EFLAGS_OF_BIT                   EQU     4000H

_TEXT$00   SEGMENT PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl "Macros"
;++
;
; GENERATE_TRAP_FRAME
;
; Macro Dexcription:
;
;    This macro generates a trap frame and saves the current register state.
;
; Arguments:
;
;    None.
;
;--

GENERATE_TRAP_FRAME macro

;
; Build trap frame minus the V86 and privilege level transition arguments.
;
; N.B. It is assumed that the error code has already been pushed on the stack.
;

        push    ebp                     ; save nonvolatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;
        push    fs                      ; save FS segment register
        push    -1                      ; push dummy exception list
        push    -1                      ; dummy previous mode
        push    eax                     ; save the volatile registers
        push    ecx                     ;
        push    edx                     ;
        push    ds                      ; save segment registers
        push    es                      ;
        push    gs                      ;
        sub     esp, TsSegGs            ; allocate remainder of trap frame
        mov     ebp, esp                ; set ebp to base of trap frame
        cld                             ; clear direction bit

        endm

        page ,132
        subttl "Debug Exception"
;++
;
; Routine Description:
;
;    Handle debug exceptions.
;
;    This exception is generated for the following reasons:
;
;    Instruction breakpoint fault.
;    Data address breakpoint trap.
;    General detect fault.
;    Single-step trap.
;    Task-switch breadkpoint trap.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    None
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap01@0
_BdTrap01@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        push    0                       ; push dummy error code

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

        and     dword ptr [ebp] + TsEflags, not EFLAGS_TF_BIT ; clear TF flag
        mov     eax, STATUS_SINGLE_STEP ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        xor     ecx, ecx                ; set number of parameters
        call    _BdDispatch             ; dispatch exception
        jmp     _BdExit                 ; dummy

_BdTrap01@0 endp

        page ,132
        subttl "Int 3 Breakpoint"
;++
;
; Routine Description:
;
;    Handle int 3 (breakpoint).
;
;    This trap is caused by the int 3 instruction.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    None
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap03@0
_BdTrap03@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        push    0                       ; push dummy error code

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

        dec     dword ptr [ebp] + TsEip ; back up to int 3 instruction
        mov     eax, STATUS_BREAKPOINT  ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 1                  ; set number of parameters
        mov     edx, BREAKPOINT_BREAK   ; set service name
        call    _BdDispatch             ; dispatch exception
        jmp     _BdExit                 ; dummy

_BdTrap03@0 endp

        page ,132
        subttl "General Protect"
;++
;
; Routine Description:
;
;    General protect violation.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;       error code
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    N.B. There is no return from this fault.
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap0d@0
_BdTrap0d@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

_BdTrap0d10:                            ;
        mov     eax, STATUS_ACCESS_VIOLATION ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 1                  ; set number of parameters
        mov     edx, [ebp] + TsErrCode  ; set error code
        and     edx, 0FFFFH             ;
        call    _BdDispatch             ; dispatch exception
        jmp     _BdTrap0d10             ; repeat

_BdTrap0d@0 endp

        page ,132
        subttl "Page Fault"
;++
;
; Routine Description:
;
;    Page fault.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;       error code
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    N.B. There is no return from this fault.
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap0e@0
_BdTrap0e@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

_BdTrap0e10:                            ;
        mov     eax, STATUS_ACCESS_VIOLATION ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 3                  ; set number of parameters
        mov     edx, [ebp] + TsErrCode  ; set read/write code
        and     edx, 2                  ;
        mov     edi, cr2                ; set fault address
        xor     esi, esi                ; set previous mode
        call    _BdDispatch             ; dispatch exception
        jmp     _BdTrap0e10             ; repeat

_BdTrap0e@0 endp

        page ,132
        subttl "Debug Service"
;++
;
; Routine Description:
;
;    Handle int 2d (debug service).
;
;    The trap is caused by an int 2d instruction. This instruction is used
;    instead of an int 3 instruction so parameters can be passed to the
;    requested debug service.
;
;    N.B. An int 3 instruction must immediately follow the int 2d instruction.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
;     Service (eax) - Supplies the service to perform.
;     Argument1 (ecx) - Supplies the first argument.
;     Argument2 (edx) - Supplies the second argument.
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap2d@0
_BdTrap2d@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

;
; Build trap frame minus the V86 and privilege level transition arguments.
;

        push    0                       ; push dummy error code

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

        mov     eax, STATUS_BREAKPOINT  ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 3                  ; set number of parameters
        mov     edx, [ebp] + TsEax      ; set service name
        mov     edi, [ebp] + TsEcx      ; set first argument value
        mov     esi, [ebp] + TsEdx      ; set second argument value
        call    _BdDispatch             ; dispatch exception
        jmp     _BdExit                 ; dummy

_BdTrap2d@0 endp

        page , 132
        subttl "Exception Dispatch"
;++
;
; Dispatch
;
; Routine Description:
;
;    This functions allocates an exception record, initializes the exception
;    record, and calls the general exception dispatch routine.
;
; Arguments:
;
;    Code (eax) - Suppplies the exception code.
;    Address (ebx) = Supplies the address of the exception.
;    Number (ecx) = Supplies the number of parameters.
;    Parameter1 (edx) - Supplies exception parameter 1;
;    Parameter2 (edi) - Supplies exception parameter 2;
;    Parameter3 (esi) - Supplies exception parameter 3.
;
; Return Value:
;
;    None.
;
;--

      align     16
      public _BdDispatch
_BdDispatch proc
.FPO (ExceptionRecordLength / 4, 0, 0, 0, 0, FPO_TRAPFRAME)

;
; Allocate and initialize exception record.
;

        sub     esp, ExceptionRecordLength ; allocate exception record
        mov     [esp] + ErExceptionCode, eax ; set exception code
        xor     eax, eax                ; zero register
        mov     [esp] + ErExceptionFlags, eax ; zero exception flags
        mov     [esp] + ErExceptionRecord, eax ; zero associated exception record
        mov     [esp] + ErExceptionAddress, ebx ; set exception address
        mov     [esp] + ErNumberParameters, ecx ; set number of parameters
        mov     [esp] + ErExceptionInformation + 0, edx ; set parameter 1
        mov     [esp] + ErExceptionInformation + 4, edi ; set parameter 2
        mov     [esp] + ErExceptionInformation + 8, esi ; set parameter 3

;
; Save debug registers in trap frame.
;

        mov     eax, dr0                ; save dr0
        mov     [ebp] + TsDr0, eax      ;
        mov     eax, dr1                ; save dr1
        mov     [ebp] + TsDr1, eax      ;
        mov     eax, dr2                ; save dr2
        mov     [ebp] + TsDr2, eax      ;
        mov     eax, dr3                ; save dr3
        mov     [ebp] + TsDr3, eax      ;
        mov     eax, dr6                ; save dr6
        mov     [ebp] + TsDr6, eax      ;
        mov     eax, dr7                ; save dr7
        mov     [ebp] + TsDr7, eax      ;

;
; Save previous stack address and segment selector.
;

        mov     eax, ss                 ; save stack segment register
        mov     [ebp] + TsTempSegCs, eax ;
        mov     [ebp] + TsTempEsp, ebp  ; compute previous stack address
        add     [ebp] + TsTempEsp, TsEFlags + 4 ;

;
; Call the general exception dispatcher.
;

        mov     ecx, esp                ; set address of exception record
        push    ebp                     ; push address of trap frame
        push    0                       ; push address of exception frame
        push    ecx                     ; push address of exception record
        call    [_BdDebugRoutine]       ; call dispatch routine
        add     esp, ExceptionRecordLength ; deallocate exception record
        ret                             ;

_BdDispatch endp

        page ,132
        subttl  "Common Trap Exit"
;++
;
; Exit
;
; Routine Description:
;
;    This code is transfered to at the end of the processing for an exception.
;    Its function is to restore machine state and continue execution.
;
; Arguments:
;
;    ebp - Supplies the address of the trap frame.
;
;   Return Value:
;
;    None.
;
;--

        align   16
        public  _BdExit
_BdExit proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        lea     esp, [ebp] + TsSegGs    ; get address of save area
        pop     gs                      ; restore segment registers
        pop     es                      ;
        pop     ds                      ;
        pop     edx                     ; restore volatile registers
        pop     ecx                     ;
        pop     eax                     ;
        add     esp, 8                  ; remove mode and exception list
        pop     fs                      ; restore FS segment register
        pop     edi                     ; restore nonvolatile registers
        pop     esi                     ;
        pop     ebx                     ;
        pop     ebp                     ;
        add     esp, 4                  ; remove error code
        iretd                           ; return

_BdExit endp

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\cpu.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpu.h

Abstract:

    Machine specific kernel debugger data types and constants.

Author:

    Scott Brenden (v-sbrend) 28 October, 1997

Revision History:

--*/

#ifndef _BDCPU_
#define _BDCPU_
#include "bldria64.h"

//
// Define debug routine prototypes.
//

typedef
LOGICAL
(*PBD_DEBUG_ROUTINE) (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

#define BD_BREAKPOINT_TYPE  ULONGLONG
#define BD_BREAKPOINT_ALIGN 0x3
#define BD_BREAKPOINT_VALUE (BREAK_INSTR | (BREAKPOINT_STOP << 6))
#define BD_BREAKPOINT_STATE_MASK    0x0000000f
#define BD_BREAKPOINT_IA64_MASK     0x000f0000
#define BD_BREAKPOINT_IA64_MODE     0x00010000   // IA64 mode
#define BD_BREAKPOINT_IA64_MOVL     0x00020000   // MOVL instruction displaced

VOID
BdIa64Init(
    );

BOOLEAN
BdSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

BOOLEAN
BdRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

LOGICAL
BdLowRestoreBreakpoint (
    IN ULONG Index
    );

#endif // _BDCPU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\miscc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module contains utility functions used by IA-64 Boot Debugger.

Author:

    Allen Kay 11-Nov-99    allen.m.kay@intel.com

Environment:


Revision History:

--*/

#include "bd.h"

extern ULONGLONG BdPcr;
extern VOID BdInstallVectors();



typedef struct _MOVL_INST {
    union {
        struct {
            ULONGLONG qp:          6;
            ULONGLONG r1:          7;
            ULONGLONG Imm7b:       7;
            ULONGLONG Vc:          1;
            ULONGLONG Ic:          1;
            ULONGLONG Imm5c:       5;
            ULONGLONG Imm9d:       9;
            ULONGLONG I:           1; 
            ULONGLONG OpCode:      4; 
            ULONGLONG Rsv:        23; 
        } i_field;
        ULONGLONG Ulong64;
    } u;
} MOVL_INST, *PMOVL_INST;

ULONGLONG
BdSetMovlImmediate (
    IN OUT PULONGLONG Ip,
    IN ULONGLONG VectorAddr
    )

/*++

Routine Description:

    Extract immediate operand from break instruction.

Arguments:

    Ip - Bundle address of instruction
    
Return Value:

    Value of immediate operand.

--*/

{
    PULONGLONG BundleAddress;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    IN MOVL_INST MovlInst, Slot0, Slot1, Slot2;
    IN ULONGLONG Imm64;

    BundleAddress = (PULONGLONG)Ip;
    BundleLow = *BundleAddress;
    BundleHigh = *(BundleAddress+1);
    
    //
    // Extract Slot0
    //
    Slot0.u.Ulong64 = BundleLow & 0x3FFFFFFFFFFF;

    //
    // Now set immediate address from slot1
    //

    Slot1.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
    Slot1.u.Ulong64 = (VectorAddr >> 22) & 0x1FFFFFFFFFF;

    //
    // First set immediate address from slot2
    //

    Slot2.u.Ulong64 = (BundleHigh >> 23);

    Slot2.u.i_field.I = (VectorAddr >> 63) & 0x1;
    Slot2.u.i_field.Ic = (VectorAddr >> 21) & 0x1;
    Slot2.u.i_field.Imm5c = (VectorAddr >> 16) & 0x1F;
    Slot2.u.i_field.Imm9d = (VectorAddr >> 7) & 0x1FF;
    Slot2.u.i_field.Imm7b = VectorAddr & 0x7F;

    //
    // Change the bundle
    //

    *BundleAddress = (BundleLow & 0x3FFFFFFFFFFF) |
                     Slot1.u.Ulong64 << 46;

    *(BundleAddress+1) = Slot2.u.Ulong64 << 23 |
                         (Slot1.u.Ulong64 & 0x1FFFFFC0000) >> 18;

    //
    // Now get the address.
    //
    BundleAddress = (PULONGLONG)Ip;
    BundleLow = *BundleAddress;
    BundleHigh = *(BundleAddress+1);

    //
    // First get immediate address from slot2
    //

    MovlInst.u.Ulong64 = (BundleHigh >> 23);
    Imm64 = MovlInst.u.i_field.I     << 63 |
            MovlInst.u.i_field.Ic    << 21 |
            MovlInst.u.i_field.Imm5c << 16 |
            MovlInst.u.i_field.Imm9d <<  7 |
            MovlInst.u.i_field.Imm7b;

    //
    // Now get immediate address from slot1
    //

    MovlInst.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
    Imm64 = Imm64 | ( (MovlInst.u.Ulong64 & 0x1FFFFFFFFFF) << 22);

    return Imm64;

}

VOID
BdIa64Init()
{
    BdInstallVectors();
    BdPrcb.PcrPage = BdPcr >> PAGE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdtrap.c

Abstract:

    This module contains code to implement the target side of the boot debugger.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"


#define ALIGN_NATS(Result, Source, Start, AddressOffset, Mask)    \
    if (AddressOffset == Start) {                                       \
        Result = (ULONGLONG)Source;                                     \
    } else if (AddressOffset < Start) {                                 \
        Result = (ULONGLONG)(Source << (Start - AddressOffset));        \
    } else {                                                            \
        Result = (ULONGLONG)((Source >> (AddressOffset - Start)) |      \
                             (Source << (64 + Start - AddressOffset))); \
    }                                                                   \
    Result = Result & (ULONGLONG)Mask

#define EXTRACT_NATS(Result, Source, Start, AddressOffset, Mask)        \
    Result = (ULONGLONG)(Source & (ULONGLONG)Mask);                     \
    if (AddressOffset < Start) {                                        \
        Result = Result >> (Start - AddressOffset);                     \
    } else if (AddressOffset > Start) {                                 \
        Result = ((Result << (AddressOffset - Start)) |                 \
                  (Result >> (64 + Start - AddressOffset)));            \
    }

//
// Define forward referenced function prototypes.
//

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextRecord
    );

VOID
BdSaveKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    OUT PCONTEXT ContextRecord
    );

LOGICAL
BdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )
{
    return FALSE;
}

VOID
BdExitDebugger(
    IN LOGICAL Enable
    )
{
}


VOID
BdGetDebugContext (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the user mode h/w debug registers from the debug register
    save area in the kernel stack to the context record.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context.

Return Value:

    None.

Note:
    
    PSR.db must be set to activate the debug registers.

    This is used for getting user mode debug registers.

--*/

{
    PKDEBUG_REGISTERS DebugRegistersSaveArea;

    if (TrapFrame->PreviousMode == UserMode) {
        DebugRegistersSaveArea = GET_DEBUG_REGISTER_SAVEAREA();

        BdCopyMemory((PVOID)&ContextFrame->DbI0, 
                     (PVOID)DebugRegistersSaveArea,
                     sizeof(KDEBUG_REGISTERS));
    }
}

VOID
BdSetDebugContext (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    This routine moves the debug context from the specified context frame into
    the debug registers save area in the kernel stack.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied.

    PreviousMode - Supplies the processor mode for the target context.

Return Value:

    None.

Notes:

   PSR.db must be set to activate the debug registers.
   
   This is used for setting up debug registers for user mode.

--*/

{
    PKDEBUG_REGISTERS DebugRegistersSaveArea;  // User mode h/w debug registers

    if (PreviousMode == UserMode) {

        DebugRegistersSaveArea = GET_DEBUG_REGISTER_SAVEAREA();

        //
        // Sanitize the debug control regs. Leave the addresses unchanged.
        //

        DebugRegistersSaveArea->DbI0 = ContextFrame->DbI0;
        DebugRegistersSaveArea->DbI1 = SANITIZE_DR(ContextFrame->DbI1,UserMode);
        DebugRegistersSaveArea->DbI2 = ContextFrame->DbI2;
        DebugRegistersSaveArea->DbI3 = SANITIZE_DR(ContextFrame->DbI3,UserMode);
        DebugRegistersSaveArea->DbI4 = ContextFrame->DbI4;
        DebugRegistersSaveArea->DbI5 = SANITIZE_DR(ContextFrame->DbI5,UserMode);
        DebugRegistersSaveArea->DbI6 = ContextFrame->DbI6;
        DebugRegistersSaveArea->DbI7 = SANITIZE_DR(ContextFrame->DbI7,UserMode);

        DebugRegistersSaveArea->DbD0 = ContextFrame->DbD0;
        DebugRegistersSaveArea->DbD1 = SANITIZE_DR(ContextFrame->DbD1,UserMode);
        DebugRegistersSaveArea->DbD2 = ContextFrame->DbD2;
        DebugRegistersSaveArea->DbD3 = SANITIZE_DR(ContextFrame->DbD3,UserMode);
        DebugRegistersSaveArea->DbD4 = ContextFrame->DbD4;
        DebugRegistersSaveArea->DbD5 = SANITIZE_DR(ContextFrame->DbD5,UserMode);
        DebugRegistersSaveArea->DbD6 = ContextFrame->DbD6;
        DebugRegistersSaveArea->DbD7 = SANITIZE_DR(ContextFrame->DbD7,UserMode);

    }
}


LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the boot
    debugger is active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    LOGICAL Completion;
    PCONTEXT ContextRecord;
    ULONG OldEip;
    STRING Reply;
    STRING String;
    PKD_SYMBOLS_INFO SymbolInfo;
    LOGICAL UnloadSymbols;

    LOGICAL Enable;
    ULONGLONG OldStIIP, OldStIPSR;
    STRING Input;
    STRING Output;

    //
    // Set address of context record and set context flags.
    //

    ContextRecord = &BdPrcb.ProcessorState.ContextFrame;
    ContextRecord->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG;

    BdSaveKframe(TrapFrame, ExceptionFrame, ContextRecord);

    //
    // Print, prompt, load symbols, and unload symbols are all special cases
    // of STATUS_BREAKPOINT.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != KERNEL_BREAKPOINT)) {

        //
        // Switch on the breakpoint code.
        //

        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print a debug string.
            //
            // Arguments: IA64 passes arguments via RSE not GR's. Since arguments are not
            //            part of CONTEXT struct, they need to be copies Temp registers.
            //            (see NTOS/RTL/IA64/DEBUGSTB.S)
            //
            //   T0 - Supplies a pointer to an output string buffer.
            //   T1 - Supplies the length of the output string buffer.
            //

        case BREAKPOINT_PRINT:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);

            Output.Buffer = (PCHAR)ContextRecord->IntT0;
            Output.Length = (USHORT)ContextRecord->IntT1;

            // KdLogDbgPrint(&Output);

            if (BdDebuggerNotPresent == FALSE) {

                Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);
                if (BdPrintString(&Output)) {
                    ContextRecord->IntV0 = (ULONG)STATUS_BREAKPOINT;

                } else {
                    ContextRecord->IntV0 = (ULONG)STATUS_SUCCESS;
                }
                BdExitDebugger(Enable);

            } else {
                ContextRecord->IntV0 = (ULONG)STATUS_DEVICE_NOT_CONNECTED;
            }

            BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
            return TRUE;

            //
            // Print a debug prompt string, then input a string.
            //
            //   T0 - Supplies a pointer to an output string buffer.
            //   T1 - Supplies the length of the output string buffer..
            //   T2 - supplies a pointer to an input string buffer.
            //   T3 - Supplies the length of the input string bufffer.
            //

        case BREAKPOINT_PROMPT:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);

            Output.Buffer = (PCHAR)ContextRecord->IntT0;
            Output.Length = (USHORT)ContextRecord->IntT1;
            Input.Buffer = (PCHAR)ContextRecord->IntT2;
            Input.MaximumLength = (USHORT)ContextRecord->IntT3;

            // BdPrintString(&Output);

            Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);

            BdPromptString(&Output, &Input);

            ContextRecord->IntV0 = Input.Length;

            BdExitDebugger(Enable);
            BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
            return TRUE;

            //
            // Load the symbolic information for an image.
            //
            // Arguments:
            //
            //    T0 - Supplies a pointer to an output string descriptor.
            //    T1 - Supplies a the base address of the image.
            //

        case BREAKPOINT_UNLOAD_SYMBOLS:
            UnloadSymbols = TRUE;

            //
            // Fall through
            //

        case BREAKPOINT_LOAD_SYMBOLS:
    
            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);
            OldStIPSR = ContextRecord->StIPSR;
            OldStIIP = ContextRecord->StIIP;

            if (BdDebuggerNotPresent == FALSE) {
                BdReportLoadSymbolsStateChange((PSTRING)ContextRecord->IntT0,
                                                (PKD_SYMBOLS_INFO) ContextRecord->IntT1,
                                                UnloadSymbols,
                                                ContextRecord);

            }

            BdExitDebugger(Enable);

            //
            // If the kernel debugger did not update the IP, then increment
            // past the breakpoint instruction.
            //

            if ((ContextRecord->StIIP == OldStIIP) &&
                ((ContextRecord->StIPSR & IPSR_RI_MASK) == (OldStIPSR & IPSR_RI_MASK))) { 
            	RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);
            }

            BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
            return TRUE;

            //
            // Kernel breakin break
            //

        case BREAKPOINT_BREAKIN:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);
            break;

            //
            // Unknown internal command.
            //

        default:
            break;
        }

    }

    //
    // Get here if single step or BREAKIN breakpoint
    //

    if  ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) ||
          (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) ) {

         //
         // Report state change to kernel debugger on host
         //

         Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);
          
         Completion = BdReportExceptionStateChange(
                          ExceptionRecord,
                          &BdPrcb.ProcessorState.ContextFrame);
      
         BdExitDebugger(Enable);
      
         BdControlCPressed = FALSE;
     
    } else {

         //
         // This is real exception that user doesn't want to see,
         // so do NOT report it to debugger.
         //

         // return FALSE;
    }

    BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
    return TRUE;
}

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints when the boot debugger is not active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{
    ULONG_PTR BreakpointCode;

    //
    // Isolate the breakpoint code from the breakpoint instruction which
    // is stored by the exception dispatch code in the information field
    // of the exception record.
    //

    BreakpointCode = (ULONG) ExceptionRecord->ExceptionInformation[0];


    //
    // If the breakpoint is a debug print, debug load symbols, or debug
    // unload symbols, then return TRUE. Otherwise, return FALSE;
    //

    if ((BreakpointCode == BREAKPOINT_PRINT) ||
        (BreakpointCode == BREAKPOINT_LOAD_SYMBOLS) ||
        (BreakpointCode == BREAKPOINT_UNLOAD_SYMBOLS)) {

        //
        // Advance to next instruction slot so that the BREAK instruction
        // does not get re-executed
        //

        RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                          TrapFrame->StIPSR,
                          TrapFrame->StIIP);
        return TRUE;

    } else {
        return FALSE;
    }
}

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

Return Value:

    None.

--*/

{
    USHORT R1Offset, R4Offset;
    USHORT RNatSaveIndex; 
    SHORT BsFrameSize;
    SHORT TempFrameSize;
    ULONG ContextFlags=CONTEXT_FULL;

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        TrapFrame->IntGp = ContextFrame->IntGp;
        TrapFrame->IntSp = ContextFrame->IntSp;
        TrapFrame->ApUNAT = ContextFrame->ApUNAT;
        TrapFrame->BrRp = ContextFrame->BrRp;
        TrapFrame->ApCCV = ContextFrame->ApCCV;
        TrapFrame->SegCSD = ContextFrame->SegCSD;

        //
        // Set preserved applicaton registers in exception frame.
        //

        ExceptionFrame->ApLC = ContextFrame->ApLC;
        ExceptionFrame->ApEC &= ~(PFS_EC_MASK << PFS_EC_MASK);
        ExceptionFrame->ApEC |= ((ContextFrame->ApEC & PFS_EC_MASK) << PFS_EC_SHIFT);

        //
        // Set RSE control states in the trap frame.
        //

        TrapFrame->RsPFS = ContextFrame->RsPFS;

        BsFrameSize = (SHORT)(ContextFrame->StIFS & PFS_SIZE_MASK);
        RNatSaveIndex = (USHORT)((ContextFrame->RsBSP >> 3) & NAT_BITS_PER_RNAT_REG);

        TempFrameSize = RNatSaveIndex + BsFrameSize - NAT_BITS_PER_RNAT_REG;
        while (TempFrameSize >= 0) {
            BsFrameSize++;
            TempFrameSize -= NAT_BITS_PER_RNAT_REG;
        }

        TrapFrame->RsBSPSTORE = ContextFrame->RsBSPSTORE + BsFrameSize * 8;
        TrapFrame->RsBSP = TrapFrame->RsBSPSTORE;
        TrapFrame->RsRSC = ContextFrame->RsRSC;
        TrapFrame->RsRNAT = ContextFrame->RsRNAT;

#if DEBUG
        DbgPrint("KeContextToKFrames: RsRNAT = 0x%I64x\n", TrapFrame->RsRNAT);
#endif // DEBUG

        //
        // Set FPSR, IPSR, IIP, and IFS in the trap frame.
        //

        TrapFrame->StFPSR = ContextFrame->StFPSR;
        TrapFrame->StIPSR = ContextFrame->StIPSR;
        TrapFrame->StIFS  = ContextFrame->StIFS;
        TrapFrame->StIIP  = ContextFrame->StIIP;

#if 0
        //
        // DebugActive controls h/w debug registers. Set if new psr.db = 1
        //

        KeGetCurrentThread()->DebugActive = ((TrapFrame->StIPSR & (1I64 << PSR_DB)) != 0);

        //
        // Set application registers directly
        // *** TBD SANATIZE??
        //

        if (PreviousMode == UserMode ) {
            __setReg(CV_IA64_AR21, ContextFrame->StFCR);
            __setReg(CV_IA64_AR24, ContextFrame->Eflag);
            __setReg(CV_IA64_AR26, ContextFrame->SegSSD);
            __setReg(CV_IA64_AR27, ContextFrame->Cflag);
            __setReg(CV_IA64_AR28, ContextFrame->StFSR);
            __setReg(CV_IA64_AR29, ContextFrame->StFIR);
            __setReg(CV_IA64_AR30, ContextFrame->StFDR);
        }
#endif

        __setReg(CV_IA64_ApDCR, ContextFrame->ApDCR);

    }

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        TrapFrame->IntT0 = ContextFrame->IntT0;
        TrapFrame->IntT1 = ContextFrame->IntT1;
        TrapFrame->IntT2 = ContextFrame->IntT2;
        TrapFrame->IntT3 = ContextFrame->IntT3;
        TrapFrame->IntT4 = ContextFrame->IntT4;
        TrapFrame->IntV0 = ContextFrame->IntV0;
        TrapFrame->IntTeb = ContextFrame->IntTeb;
        TrapFrame->Preds = ContextFrame->Preds;

        //
        // t5 - t22
        //

        memcpy(&TrapFrame->IntT5, &ContextFrame->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set integer registers s0 - s3 in exception frame.
        //

        ExceptionFrame->IntS0 = ContextFrame->IntS0;
        ExceptionFrame->IntS1 = ContextFrame->IntS1;
        ExceptionFrame->IntS2 = ContextFrame->IntS2;
        ExceptionFrame->IntS3 = ContextFrame->IntS3;

        //
        // Set the integer nats field in the trap & exception frames
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        R4Offset = (USHORT)((ULONG_PTR)(&ExceptionFrame->IntS0) >> 3) & 0x3f;

        EXTRACT_NATS(TrapFrame->IntNats, ContextFrame->IntNats,
                     1, R1Offset, 0xFFFFFF0E);
        EXTRACT_NATS(ExceptionFrame->IntNats, ContextFrame->IntNats,
                     4, R4Offset, 0xF0);

#if DEBUG
        DbgPrint("KeContextToKFrames: TF->IntNats = 0x%I64x, ContestFrame->IntNats = 0x%I64x, R1OffSet = 0x%x\n",
                 TrapFrame->IntNats, ContextFrame->IntNats, R1Offset);
        DbgPrint("KeContextToKFrames: EF->IntNats = 0x%I64x, R4OffSet = 0x%x\n",
                 ExceptionFrame->IntNats, R4Offset);
#endif // DEBUG

        //
        // Set other branch registers in trap and exception frames
        //

        TrapFrame->BrT0 = ContextFrame->BrT0;
        TrapFrame->BrT1 = ContextFrame->BrT1;

        memcpy(&ExceptionFrame->BrS0, &ContextFrame->BrS0, 5*sizeof(ULONGLONG));

    }

    //
    // Set lower floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        TrapFrame->StFPSR = ContextFrame->StFPSR;

        //
        // Set floating registers fs0 - fs19 in exception frame.
        //

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS0, 
                                        &ContextFrame->FltS0,
                                        sizeof(FLOAT128) * (4));

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS4, 
                                        &ContextFrame->FltS4,
                                        16*sizeof(FLOAT128));

        //
        // Set floating registers ft0 - ft9 in trap frame.
        //

        RtlCopyIa64FloatRegisterContext(&TrapFrame->FltT0, 
                                        &ContextFrame->FltT0,
                                        sizeof(FLOAT128) * (10));

    }

    //
    // Set higher floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        TrapFrame->StFPSR = ContextFrame->StFPSR;

#if 0
        if (PreviousMode == UserMode) {

            //
            // Update the higher floating point save area (f32-f127) and 
            // set the corresponding modified bit in the PSR to 1.
            //

            RtlCopyIa64FloatRegisterContext(
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(),
                &ContextFrame->FltF32,
                96*sizeof(FLOAT128)
                );

            //
            // set the dfh bit to force a reload of the high fp register
            // set on the next user access
            //

            TrapFrame->StIPSR |= (1i64 << PSR_DFH);
        }
#endif

    }

#if 0
    //
    // Set debug registers.
    //

    if ((ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        BdSetDebugContext (TrapFrame, ContextFrame, 0);
    }
#endif

    return;
}

VOID
BdSaveKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{
    ULONGLONG IntNats1, IntNats2;
    USHORT R1Offset, R4Offset;
    USHORT RNatSaveIndex;
    SHORT BsFrameSize;
    SHORT TempFrameSize;
    ULONG ContextFlags=CONTEXT_FULL;

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        ContextFrame->IntGp = TrapFrame->IntGp;
        ContextFrame->IntSp = TrapFrame->IntSp;
        ContextFrame->ApUNAT = TrapFrame->ApUNAT;
        ContextFrame->BrRp = TrapFrame->BrRp;
        ContextFrame->ApCCV = TrapFrame->ApCCV;
        ContextFrame->SegCSD = TrapFrame->SegCSD;

        ContextFrame->StFPSR = TrapFrame->StFPSR;
        ContextFrame->StIPSR = TrapFrame->StIPSR;
        ContextFrame->StIIP = TrapFrame->StIIP;
        ContextFrame->StIFS = TrapFrame->StIFS;


        //
        // Set RSE control states from the trap frame.
        //

        ContextFrame->RsPFS = TrapFrame->RsPFS;

        BsFrameSize = (SHORT)(TrapFrame->StIFS & PFS_SIZE_MASK);
        RNatSaveIndex = (USHORT) (TrapFrame->RsBSP >> 3) & NAT_BITS_PER_RNAT_REG;
        TempFrameSize = BsFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= NAT_BITS_PER_RNAT_REG;
        }

        ContextFrame->RsBSP = TrapFrame->RsBSP - BsFrameSize * 8;
        ContextFrame->RsBSPSTORE = ContextFrame->RsBSP;
        ContextFrame->RsRSC = TrapFrame->RsRSC;
        ContextFrame->RsRNAT = TrapFrame->RsRNAT;

#if DEBUG
        DbgPrint("KeContextFromKFrames: RsRNAT = 0x%I64x\n",
                 ContextFrame->RsRNAT);
#endif // DEBUG

        //
        // Set preserved applicaton registers from exception frame.
        //

        ContextFrame->ApLC = ExceptionFrame->ApLC;
        ContextFrame->ApEC = (ExceptionFrame->ApEC >> PFS_EC_SHIFT) & PFS_EC_MASK;

        //
        // Get iA status from the application registers
        //

        ContextFrame->StFCR = __getReg(CV_IA64_AR21);
        ContextFrame->Eflag = __getReg(CV_IA64_AR24);
        ContextFrame->SegSSD = __getReg(CV_IA64_AR26);
        ContextFrame->Cflag = __getReg(CV_IA64_AR27);
        ContextFrame->StFSR = __getReg(CV_IA64_AR28);
        ContextFrame->StFIR = __getReg(CV_IA64_AR29);
        ContextFrame->StFDR = __getReg(CV_IA64_AR30);
        ContextFrame->ApDCR = __getReg(CV_IA64_ApDCR);
    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        ContextFrame->IntT0 = TrapFrame->IntT0;
        ContextFrame->IntT1 = TrapFrame->IntT1;
        ContextFrame->IntT2 = TrapFrame->IntT2;
        ContextFrame->IntT3 = TrapFrame->IntT3;
        ContextFrame->IntT4 = TrapFrame->IntT4;
        ContextFrame->IntV0 = TrapFrame->IntV0;
        ContextFrame->IntTeb = TrapFrame->IntTeb;
        ContextFrame->Preds = TrapFrame->Preds;

        //
        // t5 - t22
        // 

        memcpy(&ContextFrame->IntT5, &TrapFrame->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set branch registers from trap frame & exception frame
        //

        ContextFrame->BrT0 = TrapFrame->BrT0;
        ContextFrame->BrT1 = TrapFrame->BrT1;

        memcpy(&ContextFrame->BrS0, &ExceptionFrame->BrS0, 5*sizeof(ULONGLONG));

        //
        // Set integer registers s0 - s3 from exception frame.
        //

        ContextFrame->IntS0 = ExceptionFrame->IntS0;
        ContextFrame->IntS1 = ExceptionFrame->IntS1;
        ContextFrame->IntS2 = ExceptionFrame->IntS2;
        ContextFrame->IntS3 = ExceptionFrame->IntS3;

        //
        // Set the integer nats field in the context
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        R4Offset = (USHORT)((ULONG_PTR)(&ExceptionFrame->IntS0) >> 3) & 0x3f;

        ALIGN_NATS(IntNats1, TrapFrame->IntNats, 1, R1Offset, 0xFFFFFF0E);
        ALIGN_NATS(IntNats2, ExceptionFrame->IntNats, 4, R4Offset, 0xF0);
        ContextFrame->IntNats = IntNats1 | IntNats2;

#if DEBUG
        DbgPrint("KeContextFromKFrames: TF->IntNats = 0x%I64x, R1OffSet = 0x%x, R4Offset = 0x%x\n",
                 TrapFrame->IntNats, R1Offset, R4Offset);
        DbgPrint("KeContextFromKFrames: CF->IntNats = 0x%I64x, IntNats1 = 0x%I64x, IntNats2 = 0x%I64x\n",
                 ContextFrame->IntNats, IntNats1, IntNats2);
#endif // DEBUG

    }

    //
    // Set lower floating register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        //
        // Set EM + ia32 FP status
        //
        
        ContextFrame->StFPSR = TrapFrame->StFPSR;

        //
        // Set floating registers fs0 - fs19 from exception frame.
        //

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltS0,
                                        &ExceptionFrame->FltS0,
                                        sizeof(FLOAT128) * (4));

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltS4, 
                                        &ExceptionFrame->FltS4,
                                        16*sizeof(FLOAT128));

        //
        // Set floating registers ft0 - ft9 from trap frame.
        //

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltT0,
                                        &TrapFrame->FltT0,
                                        sizeof(FLOAT128) * (10));

    }

#if 0
    if ((ContextFrame->ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        ContextFrame->StFPSR = TrapFrame->StFPSR;

        //
        // Set floating regs f32 - f127 from higher floating point save area
        //

        if (TrapFrame->PreviousMode == UserMode) {

            RtlCopyIa64FloatRegisterContext(
                &ContextFrame->FltF32, 
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(),
                96*sizeof(FLOAT128)
                );
        }

    }

    //
    // Get user debug registers from save area in kernel stack.
    // Note: PSR.db must be set to activate the debug registers.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        BdGetDebugContext(TrapFrame, ContextFrame);
    }
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This modules implements debug prints.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"

VOID
BdPrintf(
    IN PCHAR Format,
    ...
    )

/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    Format - Supplies a pointer to a format string.

Return Value:

    None

--*/

{

    CHAR Buffer[100];
    va_list mark;
    STRING String;

    va_start(mark, Format);
    _vsnprintf(&Buffer[0], 100, Format, mark);
    va_end(mark);

    //bugbug UNICODE
    //BlPrint("%s", &Buffer[0]);

    String.Buffer = &Buffer[0];
    String.Length = strlen(&Buffer[0]);
    BdPrintString(&String);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\cpuapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Mark Lucovsky (markl) 04-Sep-1990

Revision History:

--*/

#include "bd.h"

//
// Define end of control space.
//

#define END_OF_CONTROL_SPACE ((PCHAR)(sizeof(KPROCESSOR_STATE)))

VOID
BdSetContextState(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function fills in the process-specific portion of the
    wait state change message record.

Arguments:

    WaitStateChange - Supplies a pointer to record to fill in.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    // Nothing to do for IA64.
    return;
}

VOID
BdGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function extracts continuation control data from a manipulate state
    message.

Arguments:

    ManipulateState - Supplies a pointer to the manipulate state packet.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
}

VOID
BdSetStateChange(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Fill in the wait state change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    BdSetContextState(WaitStateChange, ContextRecord);
    return;
}

VOID
BdReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // read the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    Length = min(a->TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    ASSERT(sizeof(PVOID) == sizeof(ULONG_PTR));

    //
    // Case on address to determine what part of Control space is being read.
    //

    switch ( (ULONG_PTR)a->TargetBaseAddress ) {

        //
        // Return the pcr address for the current processor.
        //

    case DEBUG_CONTROL_SPACE_PCR:

        *(PKPCR *)(AdditionalData->Buffer) = (PKPCR)(BdPrcb.PcrPage << PAGE_SHIFT);
        AdditionalData->Length = sizeof( PKPCR );
        a->ActualBytesRead = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

        //
        // Return the prcb address for the current processor.
        //

    case DEBUG_CONTROL_SPACE_PRCB:

        *(PKPRCB *)(AdditionalData->Buffer) = &BdPrcb;
        AdditionalData->Length = sizeof( PKPRCB );
        a->ActualBytesRead = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        BdMoveMemory (AdditionalData->Buffer, 
                      (PVOID)&(BdPrcb.ProcessorState.SpecialRegisters),
                      sizeof( KSPECIAL_REGISTERS )
                     );
        AdditionalData->Length = sizeof( KSPECIAL_REGISTERS );
        a->ActualBytesRead = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

    default:

        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesRead = 0;

    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function writes control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // write the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    switch ( (ULONG_PTR)a->TargetBaseAddress ) {

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        BdMoveMemory ( (PVOID)&(BdPrcb.ProcessorState.SpecialRegisters),
                       AdditionalData->Buffer,
                       sizeof( KSPECIAL_REGISTERS )
                      );
        AdditionalData->Length = sizeof( KSPECIAL_REGISTERS );
        a->ActualBytesWritten = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

    default:

        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesWritten = 0;

    }

    //
    // Send reply message.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case of data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            a->DataValue = (ULONG)READ_PORT_UCHAR((PUCHAR)a->IoAddress);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = (ULONG)READ_PORT_USHORT((PUSHORT)a->IoAddress);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = READ_PORT_ULONG((PULONG)a->IoAddress);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function wrties I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case on data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)a->IoAddress, (UCHAR)a->DataValue);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_USHORT((PUSHORT)a->IoAddress, (USHORT)a->DataValue);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_ULONG((PULONG)a->IoAddress, a->DataValue);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}


BOOLEAN
BdSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine suspend all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to suspend BPs.

    Upper - include upper address of range from which to suspend BPs.

Return Value:

    TRUE if any breakpoints suspended, FALSE otherwise.

Notes:
    The order of suspending breakpoints is opposite that of setting
    them in BdAddBreakpoint() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //DPRINT(("\nKD: entering BdSuspendBreakpointRange() at 0x%08x 0x%08x\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = BREAKPOINT_TABLE_SIZE - 1; Index != -1; Index--) {

        if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
             ((BdBreakpointTable[Index].Address >= (ULONG64) Lower) &&
              (BdBreakpointTable[Index].Address <= (ULONG64) Upper))
           ) {

            //
            // Breakpoint is in use and falls in range, suspend it.
            //

            BdSuspendBreakpoint(Index+1);
            ReturnStatus = TRUE;
        }
    }
    //DPRINT(("KD: exiting BdSuspendBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // BdSuspendBreakpointRange



BOOLEAN
BdRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine writes back breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to rewrite BPs.

    Upper - include upper address of range from which to rewrite BPs.

Return Value:

    TRUE if any breakpoints written, FALSE otherwise.

Notes:
    The order of writing breakpoints is opposite that of removing
    them in BdSuspendBreakpointRange() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //DPRINT(("\nKD: entering BdRestoreBreakpointRange() at 0x%08x 0x%08x\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++) {

        if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
             ((BdBreakpointTable[Index].Address >= (ULONG64) Lower) &&
              (BdBreakpointTable[Index].Address <= (ULONG64) Upper))
           ) {

            //
            // suspended breakpoint that falls in range, unsuspend it.
            //

            if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) {

                BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_SUSPENDED;
                ReturnStatus = ReturnStatus || BdLowRestoreBreakpoint(Index);
            }
        }
    }

    //DPRINT(("KD: exiting BdRestoreBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // BdRestoreBreakpointRange
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support the boot debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "bd.h"

extern BdInstallVectors();

_TUCHAR DebugMessage[80];

LOGICAL
BdPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    OUT PULONG BdFileId
    )

/*++

Routine Description:

    This functions initializes the boot debugger com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.

Returned Value:

    TRUE - If a debug port is found.

--*/

{
    //
    // Initialize the specified port.
    //
    if (!BlPortInitialize(BaudRate, PortNumber, NULL, FALSE, BdFileId)) {
        return FALSE;
    }
    _stprintf(DebugMessage,
            TEXT("\r\nBoot Debugger Using: COM%d (Baud Rate %d)\r\n"),
            PortNumber,
            BaudRate);

    //
    // Install exception vectors used by BD.
    //
    BdIa64Init();

#if 0
    //
    // We cannot use BlPrint() at this time because BlInitStdIo() has not been called, which is
    // required to use the Arc emulator code.
    //
    TextStringOut(DebugMessage);
#else  
    //
    // there's no reason not to use BlPrint since we're not using ARC calls to print
    // 
    BlPrint( DebugMessage );
#endif    

    return TRUE;
}

ULONG
BdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    This routine gets a byte from the serial port used by the kernel
    debugger.

Arguments:

    Input - Supplies a pointer to a variable that receives the input
        data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if an error is encountered during reading.

    CP_GET_NODATA is returned if timeout occurs.

--*/

{

    return BlPortGetByte(BdFileId, Input);
}

VOID
BdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    This routine puts a byte to the serial port used by the kernel debugger.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{

    BlPortPutByte(BdFileId, Output);
    return;
}

ULONG
BdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    This routine gets a byte from the serial port used by the kernel
    debugger iff a byte is available.

Arguments:

    Input - Supplies a pointer to a variable that receives the input
        data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if an error encountered during reading.

    CP_GET_NODATA is returned if timeout occurs.

--*/

{

    return BlPortPollByte(BdFileId, Input);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\dcmpstub.c ===
#include "bldr.h"

VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    )
{
    UNREFERENCED_PARAMETER(Enable);

    return;
}


BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(CompressedName);

    //
    // Indicate that the caller shouldn't bother trying to locate
    // the compressed filename.
    //
    return(FALSE);
}


ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(FileId);

    //
    // No processing in osloader, only in setupldr.
    // Special return code of -1 takes care of this.
    //
    return((ULONG)(-1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\bldrint.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bldrint.h

Abstract:

    This module is the internal header file for the NT boot loader.

Author:

    Andrew Ritz (andrewr) 12-Dec-2000

Revision History:

--*/

#ifndef _BLDRINT_
#define _BLDRINT_

                  
#define ASCI_CSI_OUT    TEXT("\033[")     // escape-leftbracket

#define ATT_FG_BLUE     4
#define ATT_FG_WHITE    7
#define ATT_BG_BLUE     (ATT_FG_BLUE    << 4)
#define ATT_BG_WHITE    (ATT_FG_WHITE   << 4)
#define DEFATT          (ATT_FG_WHITE | ATT_BG_BLUE)
#define INVATT          (ATT_FG_BLUE |  ATT_BG_WHITE)


#endif // _BLDRINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\reboot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bdreboot.c

Abstract:

    System reboot function.  Currently part of the debugger because
    that's the only place it's used.

Author:

    Bryan M. Willman (bryanwi) 4-Dec-90

Revision History:

--*/

#include "bd.h"

VOID
FwStallExecution(
    IN ULONG Microseconds
    );


#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64


VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
}


VOID
BdReboot (
    VOID
    )

/*++

Routine Description:

    Just calls the HalReturnToFirmware function.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    //
    // Never returns from HAL
    //

    HalpReboot();

    while (TRUE) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\advboot.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    advboot.c

Abstract:

    Handles the advanced options boot menu screen.

Author:

    Wesley Wittt (wesw) 12-Dec-1997

Revision History:

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include <netboot.h>
#include "msg.h"
#include "ntdddisk.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "bldrint.h"

#if 0
ULONG VerboseDebugging = 0;

#define dbg(x)              \
    if(VerboseDebugging) {  \
        DbgPrint x;         \
    }

#define dbgbrk()            \
    if(VerboseDebugging) {  \
        DbgBreakPoint();    \
    }
#else
#define dbg(x) /* x */
#define dbgbrk() /* */ 
#endif

//
// used to force the boot loader into
// using LKG even though the LKG menu
// wasn't used.
//
extern BOOLEAN ForceLastKnownGood;


#define ATTR_TEXT           0x07
#define ATTR_TEXT_REVERSE   0x70
#define HEADER_START_Y      0x01

//
// menu data structures and defines
//

#define MENU_ITEM           1
#define MENU_BLANK_LINE     2

#define BL_INVALID_ADVANCED_BOOT_OPTION (ULONG)-1
#define BL_INVALID_TIME (ULONG)-1

typedef void (*PADVANCED_BOOT_PROCESSING)(void);
typedef int  (*PADVANCED_BOOT_ISVALID)(void);

typedef struct _ADVANCEDBOOT_OPTIONS {
    ULONG                       MenuType;
    ULONG                       MsgId;
    PTSTR                       DisplayStr;
    PSTR                        LoadOptions;
    LONG                        RemoveIfPresent;
    ULONG                       UseEntry;
    ULONG                       AutoAdvancedBootOption;
    PADVANCED_BOOT_PROCESSING   ProcessFunc;
    PADVANCED_BOOT_ISVALID      IsValid;
    BOOLEAN                     IsDefault;
} ADVANCEDBOOT_OPTIONS, PADVANCEDBOOT_OPTIONS;


//
// some prototypes that are needed for
// the menu definitions.
//

void
BlProcessLastKnownGoodOption(
    void
    );

int
BlIsReturnToOSChoicesValid(
    VOID
    );

#if defined(REMOTE_BOOT)
void
BlProcessOschooserOption(
    void
    );

void
BlProcessRepinOption(
    void
    );

void
BlDisableCSC(
    void
    );

void 
BlBootNormally(
    void
    );

void
BlReturnToOSChoiceMenu(
    void
    );

int
BlIsRemoteBootValid(
    void
    );
    
#endif // defined(REMOTE_BOOT)

//
// this table drives the advanced boot menu screen.
// of you need to add something to the screen then
// this is what you need to modify.
//

ADVANCEDBOOT_OPTIONS AdvancedBootOptions[] =
{
    { MENU_ITEM,       BL_SAFEBOOT_OPTION1,      NULL, "SAFEBOOT:MINIMAL SOS BOOTLOG NOGUIBOOT", -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_SAFEBOOT_OPTION2,      NULL, "SAFEBOOT:NETWORK SOS BOOTLOG NOGUIBOOT", -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_SAFEBOOT_OPTION4,      NULL, "SAFEBOOT:MINIMAL(ALTERNATESHELL) SOS BOOTLOG NOGUIBOOT", -1, 0, 1, NULL, NULL, FALSE},
//  { MENU_ITEM,       BL_SAFEBOOT_OPTION3,      NULL, "SAFEBOOT:STEPBYSTEP SOS BOOTLOG",        -1, 0, 1, NULL, NULL, FALSE},
    { MENU_BLANK_LINE, 0,                        NULL, NULL,                         -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_BOOTLOG,               NULL, "BOOTLOG",                    -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_BASEVIDEO,             NULL, "BASEVIDEO",                  -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_LASTKNOWNGOOD_OPTION,  NULL, NULL,                         -1, 0, 1, BlProcessLastKnownGoodOption, NULL, FALSE},
    { MENU_ITEM,       BL_SAFEBOOT_OPTION6,      NULL, "SAFEBOOT:DSREPAIR SOS",      -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_DEBUG_OPTION,          NULL, "DEBUG",                      -1, 0, 0, NULL, NULL, FALSE},
    
#if defined(REMOTE_BOOT)
    { MENU_BLANK_LINE, 0,                        NULL, NULL,                         -1, 0, 0, NULL, BlIsRemoteBootValid, FALSE},
    { MENU_ITEM,       BL_REMOTEBOOT_OPTION1,    NULL, NULL,                         -1, 0, 0, BlProcessOschooserOption, BlIsRemoteBootValid, FALSE},
    { MENU_ITEM,       BL_REMOTEBOOT_OPTION2,    NULL, NULL,                         -1, 0, 0, BlProcessRepinOption, BlIsRemoteBootValid, FALSE},
    { MENU_ITEM,       BL_REMOTEBOOT_OPTION3,    NULL, NULL,                         -1, 0, 0, BlDisableCSC, BlIsRemoteBootValid, FALSE},   
#endif // defined(REMOTE_BOOT)

    { MENU_BLANK_LINE, 0,                        NULL, NULL,                         -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_MSG_BOOT_NORMALLY,     NULL, NULL,                         -1, 0, 1, NULL, NULL, TRUE},
    { MENU_ITEM,       BL_MSG_REBOOT,            NULL, NULL,                         -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_MSG_OSCHOICES_MENU,   NULL, NULL,                          -1, 0, 0, NULL, BlIsReturnToOSChoicesValid, FALSE}
};

#define MaxAdvancedBootOptions  (sizeof(AdvancedBootOptions)/sizeof(ADVANCEDBOOT_OPTIONS))


PTSTR
BlGetAdvancedBootDisplayString(
    LONG BootOption
    )

/*++

Routine Description:

    Returns a pointer to the display string for a specific
    boot option.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:

    PSTR    - Pointer to the display string for the specified boot option.

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1) {
        return TEXT("");
    }

    return AdvancedBootOptions[BootOption].DisplayStr;
}

ULONG
BlGetAdvancedBootID(
    LONG BootOption
    )

/*++

Routine Description:

    Returns a ULONG indicating the string ID for a specific
    boot option.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:
    MessageID for the string which is displayed for the
    the advanced boot option in the menu (unique ID).

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1) {
        return BL_INVALID_ADVANCED_BOOT_OPTION;
    }

    return AdvancedBootOptions[BootOption].MsgId;
}

PSTR
BlGetAdvancedBootLoadOptions(
    LONG BootOption
    )

/*++

Routine Description:

    Returns a pointer to the load options string for a specific
    boot option.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:

    PSTR    - Pointer to the load options string for the specified boot option.

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1) {
        return "";
    }

    return AdvancedBootOptions[BootOption].LoadOptions;
}


void
BlDoAdvancedBootLoadProcessing(
    LONG BootOption
    )

/*++

Routine Description:

    Performs any processing necessary for a
    boot option.  This is used if the necessary action
    needed for a specific boot option cannot be
    expressed in terms of a load option string.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:

    Nothing.

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1 || AdvancedBootOptions[BootOption].ProcessFunc == NULL) {
        return;
    }

    AdvancedBootOptions[BootOption].ProcessFunc();
}


void
BlProcessLastKnownGoodOption(
    void
    )

/*++

Routine Description:

    Performs LKG processing by simply setting a
    global boolean to TRUE.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    ForceLastKnownGood = TRUE;
}


#if defined(REMOTE_BOOT)
void
BlProcessOschooserOption(
    void
    )

/*++

Routine Description:

    Brings up OSchooser so user can do remote boot maintenance.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    return; // not yet implemented
}


void
BlProcessRepinOption(
    void
    )

/*++

Routine Description:

    Sets NetBootRepin to cause the CSC to be repinned.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    NetBootRepin = TRUE;
    NetBootCSC = FALSE;
}

void
BlDisableCSC(
    void
    )

/*++

Routine Description:

    Clears NetBootCSC to cause the CSC to be disabled so that the local CSC
    can be inspected.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    NetBootCSC = FALSE;
}

int
BlIsRemoteBootValid(
    void
    )

/*++

Routine Description:

    Used for the remote boot options so that they
    can be displayed dynamically.

Arguments:

    None.

Return Value:

    TRUE or FALSE.

--*/

{
    return BlBootingFromNet;
}
#endif // defined(REMOTE_BOOT)


LONG
BlDoAdvancedBoot(
    IN ULONG MenuTitleId,
    IN LONG DefaultBootOption,
    IN BOOLEAN AutoAdvancedBoot,
    IN UCHAR Timeout
    )

/*++

Routine Description:

    Displays the menu of boot options and allows the user to select one
    by using the arrow keys.

Arguments:

    MenuTitleId         - the message ID of the title for the menu.  The title
                          will be different depending on whether the user 
                          selected advanced boot or whether the loader has 
                          determined that the system didn't boot or shutdown
                          correctly (auto advanced boot)
    
    DefaultBootOption   - menu selection to set the highligh on
                          when the menu is drawn the first time.

    AutoAdvancedBoot    - the menu is being displayed by the auto-advanced boot 
                          code.  In this case a simplified menu is displayed 
                          containing the options relevant to recovering from a 
                          detected crash.

    Timeout             - the number of seconds to wait for input before
                          simply returning the default boot option.
                          A timeout value of 0 means no timeout (the menu will
                          stay up until an option is chosen)

Return Value:

    LONG - The index of the advanced boot option that was selected
           or -1 to reset the selection to "nothing".

--*/

{
    PTCHAR Title;
    PTCHAR MoveHighlight;
    ULONG i,j;
    ULONG MaxLength;
    ULONG CurrentLength;
    ULONG Selection;
    ULONG Key;
    ULONG NumValidEntries = 0;
    BOOLEAN DisplayMenu;

    PTCHAR TimeoutMessage;
    ULONG LastTime;
    ULONG TicksRemaining = BL_INVALID_TIME;
    ULONG SecondsRemaining = BL_INVALID_TIME;

    ULONG OptionStartY;
    ULONG CurrentX;
    ULONG CurrentY;

    ULONG MenuDefault = 0;

    //
    // load any resource strings
    //

    Title = BlFindMessage(MenuTitleId);

    MoveHighlight = BlFindMessage(BL_MOVE_HIGHLIGHT);

    TimeoutMessage = BlFindMessage(BL_ADVANCEDBOOT_TIMEOUT);

    if (Title == NULL || MoveHighlight == NULL || TimeoutMessage == NULL) {
        return BL_INVALID_TIME;
    }

    //
    // Remove the newline at the end of the timeout message.
    //

    {
        PTCHAR p;
        p=_tcschr(TimeoutMessage,TEXT('\r'));
        if (p!=NULL) {
            *p=TEXT('\0');
        }
    }

    //
    // print the screen header, etc.
    //
#ifdef EFI
    BlEfiSetAttribute( DEFATT );    
    BlClearScreen();
    BlEfiPositionCursor(0, HEADER_START_Y);
#else
    ARC_DISPLAY_CLEAR();
    ARC_DISPLAY_ATTRIBUTES_OFF();
    ARC_DISPLAY_POSITION_CURSOR(0, HEADER_START_Y);
#endif
    BlPrint(Title);

#ifdef EFI
    BlEfiGetCursorPosition(&CurrentX, &CurrentY);
#else
    TextGetCursorPosition(&CurrentX, &CurrentY);
#endif

    OptionStartY = CurrentY;

    //
    // check to see which boot options are valid.  While we're scanning save
    // the index of the default option.
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AutoAdvancedBoot && !AdvancedBootOptions[i].AutoAdvancedBootOption) {
            AdvancedBootOptions[i].UseEntry = FALSE;
        } else if (AdvancedBootOptions[i].IsValid) {
            AdvancedBootOptions[i].UseEntry = AdvancedBootOptions[i].IsValid();
        } else {
            AdvancedBootOptions[i].UseEntry = TRUE;
        }
        
        if(AdvancedBootOptions[i].IsDefault) {
            MenuDefault = i;
        }
    }

    //
    // check to see which boot options are invalid based
    // on the presence of other boot options
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AdvancedBootOptions[i].RemoveIfPresent != -1) {
            if (AdvancedBootOptions[AdvancedBootOptions[i].RemoveIfPresent].UseEntry) {
                AdvancedBootOptions[i].UseEntry = FALSE;
            }
        }
    }

    //
    // count the number of valid entries
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AdvancedBootOptions[i].UseEntry) {
            NumValidEntries += 1;
        }
    }

    //
    // load all the string for the various boot options
    // Find the longest string in the selections, so we know how long to
    // make the highlight bar.
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AdvancedBootOptions[i].MenuType == MENU_ITEM && AdvancedBootOptions[i].UseEntry) {
            if (AdvancedBootOptions[i].DisplayStr == NULL) {
                AdvancedBootOptions[i].DisplayStr = BlFindMessage(AdvancedBootOptions[i].MsgId);
                if (AdvancedBootOptions[i].DisplayStr == NULL) {
                    return -1;
                }
            }
            CurrentLength = (ULONG)_tcslen(AdvancedBootOptions[i].DisplayStr);
            if (CurrentLength > MaxLength) {
                MaxLength = CurrentLength;
            }
        }
    }

    //
    // print the trailer message
    //
#ifdef EFI
    BlEfiPositionCursor(0, OptionStartY + NumValidEntries);
#else
    ARC_DISPLAY_POSITION_CURSOR(0, OptionStartY + NumValidEntries);
#endif
    BlPrint(MoveHighlight);

    //
    // process the menu
    //

    Selection = ((DefaultBootOption == BL_INVALID_ADVANCED_BOOT_OPTION) ? 
                    MenuDefault : 
                    DefaultBootOption);

    while (AdvancedBootOptions[Selection].UseEntry == FALSE) {
        Selection += 1;
    }

    DisplayMenu = TRUE;

    if(Timeout) {
        
        //
        // according to the code in the boot loader there are roughly 18.2 
        // ticks per second from the counter.
        //

        TicksRemaining = Timeout * 182 / 10;

        //
        // Now that we've rounded, compute the number of seconds remaining as 
        // well.  We'll use this to determine if the menu needs updated.
        //

        SecondsRemaining = (TicksRemaining * 10) / 182;

        dbg(("Timeout = %#x, Ticks = %#x, Seconds = %#x\n", Timeout, TicksRemaining, SecondsRemaining));
    }

    //
    // Save the current time as the last time.
    //

    LastTime = GET_COUNTER();

#ifdef EFI
    // 
    // diable the EFI watchdog while waiting for user response
    //
    DisableEFIWatchDog();
#endif
    do {
        ULONG CurrentTime = 0;

        dbg(("*****"));

        //
        // Decrement the number of ticks remaining.  Compare the current time 
        // to the last time and subtract that many ticks.
        //

        if (Timeout) {
            ULONG s;
            ULONG Delta;

            CurrentTime = GET_COUNTER();

            dbg(("%x - %x", CurrentTime, LastTime));

            //
            // The counter wraps at midnight.  However if current time is 
            // less than or equal to last time we'll just ignore this 
            // iteration.
            //

            if (CurrentTime >= LastTime) {
                Delta = CurrentTime - LastTime;
            } else {
                Delta = 1;
            }

            dbg(("= %x. %x - %x = ", Delta, TicksRemaining, Delta));

            TicksRemaining -= min(TicksRemaining, Delta);

            LastTime = CurrentTime;

            dbg(("%x. ", TicksRemaining));

            //
            // If there are no ticks left then terminate the loop.
            //

            if(TicksRemaining == 0) {
                dbg(("timeout\n"));
                dbgbrk();
                Selection = BL_INVALID_ADVANCED_BOOT_OPTION;
                break;
            }

            //
            // Compute the current number of seconds remaining.  If it's not
            // equal to what it was before then we'll need to update the 
            // menu.
            //

            s = (TicksRemaining * 10) / 182;

            dbg(("-> s %x/%x ", SecondsRemaining, s));

            if(SecondsRemaining > s) {
                SecondsRemaining = s;
                DisplayMenu = TRUE;
                dbg(("update "));
            }

            dbg(("\n"));
        }

        //
        // print the menu
        //
        if (DisplayMenu) {

            dbg(("Printing Menu: ticks = %#08lx.  Sec = %d.  Last = %#08lx  Current = %08lx\n", 
                 TicksRemaining, 
                 SecondsRemaining,
                 LastTime,
                 CurrentTime
                 ));

            for (i=0,j=1; i<MaxAdvancedBootOptions; i++) {
                if (AdvancedBootOptions[i].UseEntry) {
#ifdef EFI
                    BlEfiPositionCursor(0, OptionStartY + j);
#else
                    ARC_DISPLAY_POSITION_CURSOR(0, OptionStartY + j);
#endif
                    if (i==Selection) {
#ifdef EFI
                        //BlEfiSetInverseMode( TRUE );
                        BlEfiSetAttribute( INVATT );    
#else
                        ARC_DISPLAY_INVERSE_VIDEO();
#endif
                    } else {
#ifdef EFI
                        //BlEfiSetInverseMode( FALSE );
                        BlEfiSetAttribute( DEFATT );
#else
                        ARC_DISPLAY_ATTRIBUTES_OFF();
#endif
                    }

                    if (AdvancedBootOptions[i].MenuType == MENU_ITEM) {
                        BlPrint( TEXT("    %s"), AdvancedBootOptions[i].DisplayStr);
                    }

#ifdef EFI
                    if (i == Selection) {
                        //BlEfiSetInverseMode( FALSE );
                        BlEfiSetAttribute( DEFATT );
                    }
#else
                    ARC_DISPLAY_ATTRIBUTES_OFF();
#endif
                    j += 1;
                }
            }

#ifdef EFI
            BlEfiPositionCursor(0, OptionStartY + NumValidEntries + 3);
#else
            ARC_DISPLAY_POSITION_CURSOR(0, OptionStartY + NumValidEntries + 3);
#endif

            if(Timeout) {
                BlPrint( TEXT("%s"), TimeoutMessage);
                BlPrint(TEXT(" %d \n"),SecondsRemaining);
            } else {
#ifdef EFI
                BlEfiClearToEndOfLine();
#else
                ARC_DISPLAY_CLEAR_TO_EOL();
#endif
            }

            DisplayMenu = FALSE;
        }

        //
        // Poll for a key.
        //
        Key = BlGetKey();

        //
        // Any input cancels the timeout.
        //

        if(Key) {
            Timeout = 0;
        }

        //
        // Check for selection.
        //

        //
        // The ESCAPE_KEY does nothing if this is an auto advanced boot.
        //

        if ((AutoAdvancedBoot == FALSE) && (Key == ESCAPE_KEY)) {
            //
            // reset the selection to "nothing"
            //
#ifdef EFI
            //
            // reset EFI watchdog before exiting
            //
            SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif
            return -1;
        }        

        if ( (Key==UP_ARROW) || (Key==DOWN_ARROW) || (Key==HOME_KEY) || (Key==END_KEY)) {

            DisplayMenu = TRUE;

            if (Key==DOWN_ARROW) {
                Selection = (Selection+1) % MaxAdvancedBootOptions;
            } else if (Key==UP_ARROW) {
                Selection = (Selection == 0) ? (MaxAdvancedBootOptions-1) : (Selection - 1);
            } else if (Key==HOME_KEY) {
                Selection = 0;
            } else if (Key==END_KEY) {
                Selection = MaxAdvancedBootOptions-1;
                //
                // search for the last valid entry
                //
                i = Selection;
                while (AdvancedBootOptions[i].UseEntry == FALSE) {
                    i -= 1;
                }
                Selection = i;
            }

            //
            // don't let the highlight line rest on a blank line
            //

            while((AdvancedBootOptions[Selection].UseEntry == FALSE) ||
                  (AdvancedBootOptions[Selection].MenuType == MENU_BLANK_LINE)) {

                if(Key == DOWN_ARROW) {
                    Selection = (Selection + 1) % MaxAdvancedBootOptions;
                } else if (Key == UP_ARROW) {
                    Selection = (Selection == 0) ? (MaxAdvancedBootOptions - 1) : (Selection - 1);
                }
            }
        }

    } while ( ((Key&(ULONG)0xff) != ENTER_KEY) );

#ifdef EFI
    //
    // reset EFI watchdog before exiting
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

    //
    // If Return to OS Choices selected, go back to main menu
    //
    if ((Selection != BL_INVALID_ADVANCED_BOOT_OPTION) && 
            (AdvancedBootOptions[Selection].MsgId == BL_MSG_OSCHOICES_MENU)) {
        Selection = BL_INVALID_ADVANCED_BOOT_OPTION;                
    }        
    
    return Selection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\trapc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module implements the specific exception handlers for EM
    exceptions. Called by the BdGenericExceptionHandler.

Author:

    Bernard Lint 4-Apr-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bd.h"


typedef struct _BREAK_INST {
    union {
        struct {
            ULONGLONG qp:    6;
            ULONGLONG imm20: 20;
            ULONGLONG x:     1;
            ULONGLONG x6:    6;
            ULONGLONG x3:    3;
            ULONGLONG i:     1;
            ULONGLONG Op:    4;
            ULONGLONG Rsv:   23; 
        } i_field;
        ULONGLONG Ulong64;
    } u;
} BREAK_INST;

ULONG
BdExtractImmediate (
    IN ULONGLONG Iip,
    IN ULONG SlotNumber
    )

/*++

Routine Description:

    Extract immediate operand from break instruction.

Arguments:

    Iip - Bundle address of instruction
    
    SlotNumber - Slot of break instruction within bundle

Return Value:

    Value of immediate operand.

--*/

{
    PULONGLONG BundleAddress;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    BREAK_INST BreakInst;
    ULONG Imm21;

    BundleAddress = (PULONGLONG)Iip;

    BundleLow = *BundleAddress;
    BundleHigh = *(BundleAddress+1);
    
    //
    // Align instruction
    //
    
    switch (SlotNumber) {
        case 0:
            BreakInst.u.Ulong64 = BundleLow >> 5;
            break;

        case 1:
            BreakInst.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
            break;

        case 2:
            BreakInst.u.Ulong64 = (BundleHigh >> 23);
            break;
    }
    
    //
    // Extract immediate value
    //

    Imm21 = (ULONG)(BreakInst.u.i_field.i<<20) | (ULONG)(BreakInst.u.i_field.imm20);

    return Imm21;
}


BOOLEAN
BdOtherBreakException (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for break exception other than the ones for fast and
    normal system calls. This includes debug break points.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    NT status code.

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG BreakImmediate;
    ISR Isr;

    BreakImmediate = (ULONG)(TrapFrame->StIIM);

    //
    // Handle break.b case
    //
    if (BreakImmediate == 0) {
       Isr.ull = TrapFrame->StISR;
       BreakImmediate = BdExtractImmediate(TrapFrame->StIIP,
                                           (ULONG)Isr.sb.isr_ei);
       TrapFrame->StIIM = BreakImmediate;
    }

    //
    // Initialize exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress = 
        (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));
 
    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;
 
    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;
 
    switch (BreakImmediate) {

    case KERNEL_BREAKPOINT:
    case USER_BREAKPOINT:
    case BREAKPOINT_PRINT:
    case BREAKPOINT_PROMPT:
    case BREAKPOINT_STOP:
    case BREAKPOINT_LOAD_SYMBOLS:
    case BREAKPOINT_UNLOAD_SYMBOLS:
    case BREAKPOINT_BREAKIN:
        ExceptionRecord->ExceptionCode = STATUS_BREAKPOINT;
        ExceptionRecord->ExceptionInformation[0] = BreakImmediate;
        break;

    case INTEGER_DIVIDE_BY_ZERO_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_INTEGER_DIVIDE_BY_ZERO;
        break;

    case INTEGER_OVERFLOW_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_INTEGER_OVERFLOW;
        break;

    case MISALIGNED_DATA_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_DATATYPE_MISALIGNMENT;
        break;

    case RANGE_CHECK_BREAK:
    case NULL_POINTER_DEFERENCE_BREAK:
    case DECIMAL_OVERFLOW_BREAK:
    case DECIMAL_DIVIDE_BY_ZERO_BREAK:
    case PACKED_DECIMAL_ERROR_BREAK:
    case INVALID_ASCII_DIGIT_BREAK:
    case INVALID_DECIMAL_DIGIT_BREAK:
    case PARAGRAPH_STACK_OVERFLOW_BREAK:

    default:
#if 0
#if DBG
        InbvDisplayString ("BdOtherBreakException: Unknown break code.\n");
#endif // DBG
#endif
        ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
        break;
    }

    return TRUE;
}


BOOLEAN
BdSingleStep (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for single step trap. An instruction was successfully
    executed and the PSR.ss bit is 1.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    ISR.ei bits indicate which instruction caused the exception.

    ISR.code{3:0} = 1000

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG IpsrRi;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;

    //
    // We only want the low order 2 bits so typecast to ULONG
    //
    IpsrRi = (ULONG)(TrapFrame->StIPSR >> PSR_RI) & 0x3;

    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP, IpsrRi);

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0; // 0 for traps
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    ExceptionRecord->ExceptionCode = STATUS_SINGLE_STEP;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\diagload.h ===
//
//      Diagnostic loader messages.
//
//
// Defines for Class, Detail and Action are used to lookup
// text from DiagLoadClass, DiagLoadDetail and DiagLoadAction
// respectively.  One must change LOAD_CL_END, DIAG_BL_END
// and LOAD_ACT_END to reflect any change in the content of
// the tables.  They are used for bounds checking to avoid
// access violations.

//
// Class Definitions
//

#define LOAD_SW_INT_ERR_CLASS          0x00000000L
#define LOAD_SW_MISRQD_FILE_CLASS      0x00000001L
#define LOAD_SW_BAD_FILE_CLASS         0x00000002L
#define LOAD_SW_MIS_FILE_CLASS         0x00000003L
#define LOAD_HW_MEM_CLASS              0x00000004L
#define LOAD_HW_DISK_CLASS             0x00000005L
#define LOAD_HW_GEN_ERR_CLASS          0x00000006L
#define LOAD_HW_FW_CFG_CLASS           0x00000007L
#define LAOD_SW_MISMATCHED_KERNEL      0x00000008L
#define LOAD_CL_END                    0x00000009L


//
// Class Declarations
//

static PCHAR DiagLoadClass[] = {

"Windows 2000 could not start because of an error in the software.\r\nPlease report this problem as :\r\n\0",
"Windows 2000 could not start because the following file was not found\r\nand is required :\r\n\0",
"Windows 2000 could not start because of a bad copy of the following file :\r\n\0",
"Windows 2000 could not start because the following file is missing or corrupt:\r\n\0",
"Windows 2000 could not start because of a hardware memory configuration\r\nproblem.\r\n\0",
"Windows 2000 could not start because of a computer disk hardware\r\nconfiguration problem.\r\n\0",
"Windows 2000 could not start because of a general computer hardware\r\nconfiguration problem.\r\n\0",
"Windows 2000 could not start because of the following ARC firmware\r\nboot configuration problem :\r\n\0",
"Windows 2000 could not start because the specified kernel does not exist or\r\nis not compatible with this processor.\r\n\0"
};

//
// Detail Definitions
//

#define DIAG_BL_MEMORY_INIT            0L
#define DIAG_BL_CONFIG_INIT            1L
#define DIAG_BL_IO_INIT                2L
#define DIAG_BL_FW_GET_BOOT_DEVICE     3L
#define DIAG_BL_OPEN_BOOT_DEVICE       4L
#define DIAG_BL_FW_GET_SYSTEM_DEVICE   5L
#define DIAG_BL_FW_OPEN_SYSTEM_DEVICE  6L
#define DIAG_BL_GET_SYSTEM_PATH        7L
#define DIAG_BL_LOAD_SYSTEM_IMAGE      8L
#define DIAG_BL_FIND_HAL_IMAGE         9L
#define DIAG_BL_LOAD_HAL_IMAGE         10L
#define DIAG_BL_LOAD_SYSTEM_IMAGE_DATA 11L
#define DIAG_BL_LOAD_HAL_IMAGE_DATA    12L
#define DIAG_BL_LOAD_SYSTEM_DLLS       13L
#define DIAG_BL_LOAD_HAL_DLLS          14L
#define DIAG_BL_READ_SYSTEM_REGISTRY   15L
#define DIAG_BL_LOAD_SYSTEM_REGISTRY   16L
#define DIAG_BL_FIND_SYSTEM_DRIVERS    17L
#define DIAG_BL_READ_SYSTEM_DRIVERS    18L
#define DIAG_BL_LOAD_DEVICE_DRIVER     19L
#define DIAG_BL_LOAD_SYSTEM_HIVE       20L
#define DIAG_BL_SYSTEM_PART_DEV_NAME   21L
#define DIAG_BL_BOOT_PART_DEV_NAME     22L
#define DIAG_BL_ARC_BOOT_DEV_NAME      23L
#define DIAG_BL_ARC_HAL_NAME           24L
#define DIAG_BL_SETUP_FOR_NT           25L
#define DIAG_BL_KERNEL_INIT_XFER       26L
#define DIAG_BL_END                    27L

//
// Detail Declarations
//

static PCHAR DiagLoadDetail[] = {

// DIAG_BL_MEMORY_INIT            0L
"Check hardware memory configuration and amount of RAM.\r\n\0",

// DIAG_BL_CONFIG_INIT            1L
"Too many configuration entries.\r\n\0",

// DIAG_BL_IO_INIT                2L
"Could not access disk partition tables \r\n\0",

// DIAG_BL_FW_GET_BOOT_DEVICE     3L
"The 'osloadpartition' parameter setting is invalid.\r\n\0",

// DIAG_BL_OPEN_BOOT_DEVICE       4L
"Could not read from the selected boot disk.  Check boot path\r\nand disk hardware.\r\n\0",

// DIAG_BL_FW_GET_SYSTEM_DEVICE   5L
"The 'systempartition' parameter setting is invalid.\r\n\0",

// DIAG_BL_FW_OPEN_SYSTEM_DEVICE  6L
"Could not read from the selected system boot disk.\r\nCheck 'systempartition' path.\r\n\0",

// DIAG_BL_GET_SYSTEM_PATH        7L
"The 'osloadfilename' parameter does not point to a valid file.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_IMAGE      8L
"<windows 2000 root>\\system32\\ntoskrnl.exe.\r\n\0",

// DIAG_BL_FIND_HAL_IMAGE         9L
"The 'osloader' parameter does not point to a valid file.\r\n\0",

// DIAG_BL_LOAD_HAL_IMAGE         10L
#if defined(i386)
"<windows 2000 root>\\system32\\hal.dll.\r\n\0",
#endif

#if defined(MIPS)
"'osloader'\\hal.dll\r\n\0",
#endif

// DIAG_BL_LOAD_SYSTEM_IMAGE_DATA 11L
"Loader error 1.\r\n\0",

// DIAG_BL_LOAD_HAL_IMAGE_DATA    12L
"Loader error 2.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_DLLS       13L
"load needed DLLs for kernel.\r\n\0",

// DIAG_BL_LOAD_HAL_DLLS          14L
"load needed DLLs for HAL.\r\n\0",

// DIAG_BL_READ_SYSTEM_REGISTRY   15L
"<windows 2000 root>\\system32\\config\\system. \r\n\0",

// DIAG_BL_LOAD_SYSTEM_REGISTRY   16L
"<windows 2000 root>\\system32\\config\\system. \r\n\0",

// DIAG_BL_FIND_SYSTEM_DRIVERS    17L
"find system drivers.\r\n\0",

// DIAG_BL_READ_SYSTEM_DRIVERS    18L
"read system drivers.\r\n\0",

// DIAG_BL_LOAD_DEVICE_DRIVER     19L
"did not load system boot device driver.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_HIVE       20L
"load system hardware configuration file.\r\n\0",

// DIAG_BL_SYSTEM_PART_DEV_NAME   21L
"find system partition name device name.\r\n\0",

// DIAG_BL_BOOT_PART_DEV_NAME     22L
"find boot partition name.\r\n\0",

// DIAG_BL_ARC_BOOT_DEV_NAME      23L
"did not properly generate ARC name for HAL and system paths.\r\n\0",

// DIAG_BL_ARC_HAL_NAME           24L
"did not properly generate ARC name for HAL and system paths.\r\n\0",

// DIAG_BL_SETUP_FOR_NT           25L
"Loader error 3.\r\n\0",

// DIAG_BL_KERNEL_INIT_XFER       26L
"<windows 2000 root>\\system32\\ntoskrnl.exe\r\n\0"

};


//
// Action Definitions
//

#define LOAD_SW_INT_ERR_ACT            0x00000000L
#define LOAD_SW_FILE_REST_ACT          0x00000001L
#define LOAD_SW_FILE_REINST_ACT        0x00000002L
#define LOAD_HW_MEM_ACT                0x00000003L
#define LOAD_HW_DISK_ACT               0x00000004L
#define LOAD_HW_GEN_ACT                0x00000005L
#define LOAD_HW_FW_CFG_ACT             0x00000006L
#define LOAD_ACT_END                   0x00000007L


//
// Action Declarations
//

static PCHAR DiagLoadAction[] = {

"Please contact your support person to report this problem.\r\n\0",
"You can attempt to repair this file by starting Windows 2000\r\n"
"Setup using the original Setup floppy disk or CD-ROM.\r\n"
"Select 'r' at the first screen to start repair.\r\n\0",
"Please re-install a copy of the above file.\r\n\0",
"Please check the Windows 2000(TM) documentation about hardware\r\nmemory requirements and your hardware reference manuals for\r\nadditional information.\r\n\0",
"Please check the Windows 2000(TM) documentation about hardware\r\ndisk configuration and your hardware reference manuals for\r\nadditional information.\r\n\0",
"Please check the Windows 2000(TM) documentation about hardware\r\nconfiguration and your hardware reference manuals for additional\r\ninformation.\r\n\0",
"Please check the Windows 2000(TM) documentation about ARC configuration\r\noptions and your hardware reference manuals for additional\r\ninformation.\r\n\0"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bd\ia64\trap.s ===
//++
//
// Module Name:
//       trap.s
//
// Abstract:
//       Low level interruption handlers
//
// Author:
//       Bernard Lint      12-Jun-1995
//
// Environment:
//       Kernel mode only
//
// Revision History:
//
//
// Open Design Issues:
//
//       1. Optimizations for more than 2-way parallelism when 
//          regsiters available.
//--

#include "ksia64.h"

         .file "trap.s"

//
// Globals imported:
//

        .global BdPcr

        PublicFunction(BdSetMovlImmediate)
        PublicFunction(BdInstallVectors)
        PublicFunction(BdTrap)
        PublicFunction(BdOtherBreakException)
        PublicFunction(BdSingleStep)
        PublicFunction(BdIvtStart)
        PublicFunction(BdIvtEnd)
        PublicFunction(memcpy)

//
// Register aliases used throughout the entire module
//

//
// Banked general registers
// 

//
// Register aliases used throughout the entire module
//

//
// Banked general registers
// 

//
// Register aliases used throughout the entire module
//

//
// Banked general registers
// 
// h16-h23 can only be used when psr.ic=1.
//
// h24-h31 can only be used when psr.ic=0 (these are reserved for tlb
// and pal/machine check handlers when psr.ic=1).
//

//
// Shown below are aliases of bank 0 registers used in the low level handlers
// by macros ALLOCATE_TRAP_FRAME, SAVE_INTERRUPTION_RESOURCES, and 
// NORMAL_KERNEL_EXIT.  When the code in the macros are changes, these
// register aliases must be reviewed.
//

        rHIPSR      = h16
        rHpT2       = h16

        rHIIPA      = h17
        rHRSC       = h17
        rHDfhPFS    = h17  // used to preserve pfs in BdDisabledFpRegisterVector

        rHIIP       = h18
        rHFPSR      = h18

        rHOldPreds  = h19
        rHBrp       = h19
        rHCSD       = h19

        rHIFS       = h20
        rHPFS       = h20
        rHBSP       = h20

        rHISR       = h21
        rHUNAT      = h21
        rHpT3       = h21
        
        rHSp        = h22
        rHDfhBrp    = h22  // used to preserve brp in BdDisabledFpRegisterVector
        rHpT4       = h22

        rHpT1       = h23
        
        rHIFA       = h24
        rTH3        = h24

        rHHandler   = h25
        rTH1        = h26
        rTH2        = h27
        rHIIM       = h28
        rHEPCVa     = h29

        rHEPCVa2    = h30
        rPanicCode  = h30

//
// General registers used through out module
//

        pApc      = ps0                         // User Apc Pending
        pUser     = ps1                         // mode on entry was user
        pKrnl     = ps2                         // mode on entry was kernel
        pUstk     = ps3
        pKstk     = ps4
        pEM       = ps5                         // EM ISA on kernel entry
        pIA       = ps6                         // X86 ISA on kernel entry

//
// Kernel registers used through out module
//
        rkHandler = k6                          // specific exception handler




//
// Macro definitions for this module only
//

//
// Define vector/exception entry/exit macros.
// N.B. All HANDLER_ENTRY functions go into .nsc section with
//      BdNormalSystemCall being the first.
//

#define HANDLER_ENTRY(Name)                     \
        .##global Name;                         \
        .##proc   Name;                         \
Name::

#define HANDLER_ENTRY_EX(Name, Handler)         \
        .##global Name;                         \
        .##proc   Name;                         \
        .##type   Handler, @function;           \
        .##personality Handler;                 \
Name::

#define  VECTOR_ENTRY(Offset, Name, Extra0)     \
        .##org Offset;                          \
        .##global Name;                         \
        .##proc   Name;                         \
Name::

#define VECTOR_EXIT(Name)                       \
        .##endp Name

#define HANDLER_EXIT(Name)                      \
        .##endp Name


//++
// Routine:
//
//       IO_END_OF_INTERRUPT(rVector,rT1,rT2,pEOI)
//
// Routine Description:
//
//       HalEOITable Entry corresponding to the vectorNo is tested.
//       If the entry is nonzero, then vectorNo is stored to the location
//       specified in the entry. If the entry is zero, return.
//
// Arguements:
//
//
// Notes:
//
//       MS preprocessor requires /*   */ style comments
//
//--

#define IO_END_OF_INTERRUPT(rVector,rT1,rT2,pEOI)                             ;\
        add         rT1 = @gprel(__imp_HalEOITable),gp                        ;\
        ;;                                                                    ;\
        ld8         rT1 = [rT1]                                               ;\
        ;;                                                                    ;\
        shladd      rT2 = rVector,3,rT1                                       ;\
        ;;                                                                    ;\
        ld8         rT1 = [rT2]                                               ;\
        ;;                                                                    ;\
        cmp.ne      pEOI = zero, rT1                                          ;\
        ;;                                                                    ;\
(pEOI)  st4.rel     [rT1] = rVector


//++
// Routine:
//
//       VECTOR_CALL_HANDLER(Handler, SpecificHandler)
//
// Routine Description:
//
//       Common code for transfer to heavyweight handlers from
//       interruption vectors. Put RSE in store intensive mode,
//       cover current frame and call handler.
//
// Arguments:
//
//       Handler: First level handler for this vector
//       SpecificHandler: Specific handler to be called by the generic
//                        exception handler.
//
// Return Value:
//
//       None
//
// Notes: 
//      Uses just the kernel banked registers (h16-h31)
//
//      MS preprocessor requires /* */ style comments
//--


#define VECTOR_CALL_HANDLER(Handler,SpecificHandler)                          ;\
        mov         rHIFA = cr##.##ifa                                        ;\
        movl        rTH1 = BdPcr+PcSavedIFA                                   ;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rTH1] = rHIFA                                            ;\
        movl        rHHandler = SpecificHandler                               ;\
        br##.##sptk Handler                                                   ;\
        ;;

//++
// Routine:
//
//       ALLOCATE_TRAP_FRAME
//
// Routine Description:
//
//       Common code for allocating trap frame on kernel entry for heavyweight
//       handler.
//
// On entry:
//
// On exit: sp -> trap frame; any instruction that depends on sp must be
//          placed in the new instruction group.  Interruption resources
//          ipsr, iipa, iip, predicates, isr, sp, ifs are captured in
//          seven of the banked registers h16-23.  The last one is used
//          by SAVE_INTERRUPTION_STATE as a pointer to save these resources
//          in the trap frame.
//
// Return Value:
//
//       None
//
// Notes: 
//      Uses just the kernel banked registers (h16-h31)
//
//      MS preprocessor requires /* */ style comments below
//--

#define ALLOCATE_TRAP_FRAME                                                   ;\
                                                                              ;\
        pOverflow   = pt2                                                     ;\
                                                                              ;\
        mov         rHIPSR = cr##.##ipsr                                      ;\
        mov         rHIIP = cr##.##iip                                        ;\
        cover                                   /* cover and save IFS       */;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHIIPA = cr##.##iipa                                      ;\
        movl        rTH2 = MM_EPC_VA                                          ;\
                                                                              ;\
        mov         rTH3 = ar##.##bsp                                         ;\
        mov         rHOldPreds = pr                                           ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHIFS = cr##.##ifs                                        ;\
        add         rHEPCVa = 0x30, rTH2                                      ;\
                                                                              ;\
        mov         rHISR = cr##.##isr                                        ;\
        movl        rTH2 = BdPcr+PcInitialStack                               ;\
                                                                              ;\
        tbit##.##z  pEM, pIA = rHIPSR, PSR_IS           /* set instr set    */;\
        extr##.##u  rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN /* get mode         */;\
        mov         rHSp = sp                                                 ;\
        ;;                                                                    ;\
                                                                              ;\
        ssm         (1 << PSR_IC) | (1 << PSR_DFH) | (1 << PSR_AC)            ;\
        cmp4##.##eq pKrnl, pUser = PL_KERNEL, rTH1   /* set mode pred       */;\
        cmp4##.##eq pKstk, pUstk = PL_KERNEL, rTH1   /* set stack pred      */;\
        ;;                                                                    ;\
                                                                              ;\
.pred.rel "mutex",pUstk,pKstk                                                 ;\
        add         sp = -TrapFrameLength, sp           /* allocate TF      */;\
        ;;                                                                    ;\
        add         rHpT1 = TrStIPSR, sp                                      ;\
        ;;


//++
// Routine:
//
//       SAVE_INTERRUPTION_STATE(Label)
//
// Routine Description:
//
//       Common code for saving interruption state on entry to a heavyweight
//       handler.
//
// Arguments:
//
//       Label: label for branching around BSP switch
//
// On entry:
//
//       sp -> trap frame
//
// On exit:
//
//       Static registers gp, teb, sp, fpsr spilled into the trap frame.
//       Registers gp, teb, fpsr are set up for kernel mode execution.
//
// Return Value:
//
//       None
//
// Notes: 
//
//      Interruption resources already captured in bank 0 registers h16-h23.
//      It's safe to take data TLB fault when saving them into the trap
//      frame because kernel stack is always resident in memory.  This macro
//      is carefully constructed to save the bank registers' contents in
//      the trap frame and reuse them to capture other register states as
//      soon as they are available.  Until we have a virtual register
//      allocation scheme in place, the bank 0 register aliases defined at
//      the beginning of the file must be updated when this macro is modified.
//      
//      MS preprocessor requires /* */ style comments below
//--


#define SAVE_INTERRUPTION_STATE(Label)                                        ;\
                                                                              ;\
/* Save interruption resources in trap frame */                               ;\
                                                                              ;\
                                                                              ;\
        srlz##.##i                            /* I serialize required       */;\
        st8         [rHpT1] = rHIPSR, TrStISR-TrStIPSR /* save IPSR         */;\
        add         rHpT2 = TrPreds, sp               /* -> Preds           */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHISR, TrStIIP-TrStISR  /* save ISR           */;\
        st8         [rHpT2] = rHOldPreds, TrBrRp-TrPreds                      ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHUNAT = ar##.##unat                                      ;\
        st8         [rHpT1] = rHIIP, TrStIFS-TrStIIP  /* save IIP           */;\
        mov         rHBrp = brp                                               ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHFPSR = ar##.##fpsr                                      ;\
        st8         [rHpT1] = rHIFS, TrStIIPA-TrStIFS /* save IFS           */;\
        mov         rHPFS = ar##.##pfs                                        ;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHIIPA, TrStFPSR-TrStIIPA /* save IIPA        */;\
        st8         [rHpT2] = rHBrp, TrRsPFS-TrBrRp                           ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHRSC = ar##.##rsc                                        ;\
        st8         [rHpT2] = rHPFS                   /* save PFS           */;\
        add         rHpT2 = TrApUNAT, sp                                      ;\
                                                                              ;\
        mov         rHBSP = ar##.##bsp                                        ;\
        mov         rHCSD = ar##.##csd                                        ;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHFPSR, TrRsRSC-TrStFPSR /* save FPSR         */;\
        st8         [rHpT2] = rHUNAT, TrIntGp-TrApUNAT /* save UNAT         */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHRSC, TrRsBSP-TrRsRSC  /* save RSC           */;\
        st8##.##spill [rHpT2] = gp, TrIntTeb-TrIntGp  /* spill GP           */;\
        ;;                                                                    ;\
                                                                              ;\
        st8##.##spill [rHpT2] = teb, TrIntSp-TrIntTeb /* spill TEB (r13)    */;\
        mov         teb = kteb                        /* sanitize teb       */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHBSP                   /* save BSP           */;\
        movl        rHpT1 = BdPcr + PcKernelGP                                ;\
                                                                              ;\
(pUstk) mov         ar##.##rsc = RSC_KERNEL_DISABLED  /* turn off RSE       */;\
        st8##.##spill [rHpT2] = rHSp, TrSegCSD-TrIntSp /* spill SP          */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT2] = rHCSD                   /* save CSD           */;\
(pKstk) br##.##dpnt Label                       /* br if on kernel stack    */;\
                                                                              ;\
                                                                              ;\
/*                                                                          */;\
/* Local register aliases for back store switch                             */;\
/* N.B. These must be below h24 since PSR.ic = 1 at this point              */;\
/*      h16-h23 are available                                               */;\
/*                                                                          */;\
                                                                              ;\
        rpRNAT    = h16                                                       ;\
        rpBSPStore= h17                                                       ;\
        rBSPStore = h18                                                       ;\
        rKBSPStore= h19                                                       ;\
        rRNAT     = h20                                                       ;\
        rKrnlFPSR = h21                                                       ;\
        rEFLAG    = h22                                                       ;\
                                                                              ;\
/*                                                                          */;\
/* If previous mode is user, switch to kernel backing store                 */;\
/* -- uses the "loadrs" approach. Note that we do not save the              */;\
/* BSP/BSPSTORE in the trap frame if prvious mode was kernel                */;\
/*                                                                          */;\
                                                                              ;\
                                                                              ;\
        mov       rBSPStore = ar##.##bspstore   /* get user bsp store point */;\
        mov       rRNAT = ar##.##rnat           /* get RNAT                 */;\
        add       rpRNAT = TrRsRNAT, sp         /* -> RNAT                  */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8       rKBSPStore = [rHpT1]          /* load kernel bstore       */;\
        movl      rKrnlFPSR = FPSR_FOR_KERNEL   /* initial fpsr value       */;\
        ;;                                                                    ;\
                                                                              ;\
        mov       ar##.##fpsr = rKrnlFPSR       /* set fpsr                 */;\
        add       rpBSPStore = TrRsBSPSTORE, sp /* -> User BSPStore         */;\
        ;;                                                                    ;\
                                                                              ;\
        st8       [rpRNAT] = rRNAT              /* save user RNAT           */;\
        st8       [rpBSPStore] = rBSPStore      /* save user BSP Store      */;\
        ;;                                                                    ;\
        dep       rKBSPStore = rBSPStore, rKBSPStore, 0, 9                    ;\
                                                /* adjust kernel BSPSTORE   */;\
                                                /* for NAT collection       */;\
                                                                              ;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Now running on kernel backing store                                      */;\
/*                                                                          */;\
                                                                              ;\
Label:                                                                        ;\
(pUstk) mov       ar##.##bspstore = rKBSPStore  /* switch to kernel BSP     */;\
(pUstk) mov       ar##.##rsc = RSC_KERNEL       /* turn rse on, kernel mode */;\
        bsw##.##1                               /* switch back to user bank */;\
        ;;                                      /* stop bit required        */



//++
// Routine:
//
//       RETURN_FROM_INTERRUPTION
//
// Routine Description:
//
//       Common handler code to restore trap frame and resume execution
//       at the interruption address.
//
// Arguments:
//
//       Label
//
// Return Value:
//
//       None
//
// Note: 
//
//       On entry: interrrupts disabled, sp -> trap frame
//       On exit:
//       MS preprocessor requires /* */ style comments below
//--

#define RETURN_FROM_INTERRUPTION(Label)                                       ;\
                                                                              ;\
        .##regstk 0,3,2,0       /* must match the alloc instruction below */  ;\
                                                                              ;\
        rBSP      = loc0                                                      ;\
        rBSPStore = loc1                                                      ;\
        rRnat     = loc2                                                      ;\
                                                                              ;\
        rpT1      = t1                                                        ;\
        rpT2      = t2                                                        ;\
        rpT3      = t3                                                        ;\
        rpT4      = t4                                                        ;\
        rThread   = t6                                                        ;\
        rApcFlag  = t7                                                        ;\
        rT1       = t8                                                        ;\
        rT2       = t9                                                        ;\
                                                                              ;\
        alloc       rT1 = 0,4,2,0                                             ;\
        movl        rpT1 = BdPcr + PcCurrentThread     /* ->PcCurrentThread */;\
        ;;                                                                    ;\
                                                                              ;\
(pUstk) ld8         rThread = [rpT1]                   /* load thread ptr   */;\
        add         rBSP = TrRsBSP, sp                 /* -> user BSP       */;\
(pKstk) br##.##call##.##spnt brp = BdRestoreTrapFrame                         ;\
        ;;                                                                    ;\
                                                                              ;\
        add         rBSPStore = TrRsBSPSTORE, sp       /* -> user BSP Store */;\
        add         rRnat = TrRsRNAT, sp               /* -> user RNAT      */;\
(pKstk) br##.##spnt Label##ReturnToKernel                                     ;\
        ;;                                                                    ;\
                                                                              ;\
        add         rpT1 = ThApcState+AsUserApcPending, rThread               ;\
        ;;                                                                    ;\
        ld1         rApcFlag = [rpT1], ThAlerted-ThApcState-AsUserApcPending  ;\
        ;;                                                                    ;\
        st1.nta     [rpT1] = zero                                             ;\
        cmp##.##ne  pApc = zero, rApcFlag                                     ;\
        ;;                                                                    ;\
                                                                              ;\
        PSET_IRQL   (pApc, APC_LEVEL)                                         ;\
 (pApc) mov         out1 = sp                                                 ;\
        ;;                                                                    ;\
                                                                              ;\
 (pApc) FAST_DISABLE_INTERRUPTS                                               ;\
        PSET_IRQL   (pApc, zero)                                              ;\
                                                                              ;\
        ld8         rBSP = [rBSP]                      /* user BSP          */;\
        ld8         rBSPStore = [rBSPStore]            /* user BSP Store    */;\
        ld8         rRnat = [rRnat]                    /* user RNAT         */;\
        br##.##call##.##sptk brp = BdRestoreDebugRegisters                    ;\
        ;;                                                                    ;\
                                                                              ;\
        invala                                                                ;\
        br##.##call##.##sptk brp = BdRestoreTrapFrame                         ;\
        ;;                                                                    ;\
                                                                              ;\
                                                                              ;\
Label##CriticalExitCode:                                                      ;\
                                                                              ;\
        rHRscE = h17                                                          ;\
        rHRnat = h18                                                          ;\
        rHBSPStore = h19                                                      ;\
        rHRscD = h20                                                          ;\
        rHRscDelta = h24                                                      ;\
                                                                              ;\
        bsw##.##0                                                             ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHRscE = ar##.##rsc                /* save user RSC     */;\
        mov         rHBSPStore = rBSPStore                                    ;\
        mov         rHRscD = RSC_KERNEL_DISABLED                              ;\
                                                                              ;\
        sub         rHRscDelta = rBSP, rBSPStore /* delta = BSP - BSP Store */;\
        ;;                                                                    ;\
        mov         rHRnat  = rRnat                                           ;\
        dep         rHRscD = rHRscDelta, rHRscD, 16, 14  /* set RSC.loadrs  */;\
        ;;                                                                    ;\
                                                                              ;\
        alloc       rTH1 = 0,0,0,0                                            ;\
        mov         ar##.##rsc = rHRscD                /* RSE off       */    ;\
        ;;                                                                    ;\
        loadrs                                         /* pull in user regs */;\
                                                       /* up to tear point */ ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##bspstore = rHBSPStore       /* restore user BSP */ ;\
        ;;                                                                    ;\
        mov         ar##.##rnat = rHRnat               /* restore user RNAT */;\
                                                                              ;\
Label##ReturnToKernel:                                                        ;\
                                                                              ;\
(pUstk) mov         ar.rsc = rHRscE                 /* restore user RSC     */;\
        bsw##.##0                                                             ;\
        ;;                                                                    ;\
                                                                              ;\
        add         rHpT2 = TrApUNAT, sp            /* -> previous UNAT     */;\
        add         rHpT1 = TrStFPSR, sp            /* -> previous Preds    */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHUNAT = [rHpT2],TrPreds-TrApUNAT                         ;\
        ld8         rHFPSR = [rHpT1],TrRsPFS-TrStFPSR                         ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHOldPreds = [rHpT2], TrIntSp-TrPreds                     ;\
        ld8         rHPFS = [rHpT1],TrStIIPA-TrRsPFS                          ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8##.##fill rHSp = [rHpT2], TrBrRp-TrIntSp                           ;\
        ld8         rHIIPA = [rHpT1], TrStIIP-TrStIIPA                        ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##fpsr = rHFPSR            /* restore FPSR         */;\
        ld8         rHIIP = [rHpT1], TrStIPSR-TrStIIP  /* load IIP          */;\
        mov         pr = rHOldPreds, -1             /* restore preds        */;\
                                                                              ;\
        mov         ar##.##unat = rHUNAT            /* restore UNAT         */;\
        ld8         rHBrp = [rHpT2], TrStIFS-TrBrRp                           ;\
        mov         ar##.##pfs = rHPFS              /* restore PFS          */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHIFS = [rHpT2]                 /* load IFS             */;\
        ld8         rHIPSR = [rHpT1]                /* load IPSR            */;\
                                                                              ;\
        rsm         1 << PSR_IC                     /* reset ic bit         */;\
        ;;                                                                    ;\
        srlz##.##d                                  /* must serialize       */;\
        mov         brp = rHBrp                     /* restore brp          */;\
                                                                              ;\
/*                                                                          */;\
/* Restore status registers                                                 */;\
/*                                                                          */;\
                                                                              ;\
        mov         cr##.##ipsr = rHIPSR        /* restore previous IPSR    */;\
        mov         cr##.##iip = rHIIP          /* restore previous IIP     */;\
                                                                              ;\
        mov         cr##.##ifs = rHIFS          /* restore previous IFS     */;\
        mov         cr##.##iipa = rHIIPA        /* restore previous IIPA    */;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Resume at point of interruption (rfi must be at end of instruction group)*/;\
/*                                                                          */;\
        mov         sp = rHSp                   /* restore sp               */;\
        mov         h17 = r0                    /* clear TB loop count      */;\
        rfi                                                                   ;\
        ;;


//++
// Routine:
//
//       USER_APC_CHECK
//
// Routine Description:
//
//       Common handler code for requesting
//       pending APC if returning to user mode.
//
// Arguments:
//
// Return Value:
//
//       None
//
// Note: 
//
//       On entry: interrrupts disabled, sp -> trap frame
//       On exit:
//       MS preprocessor requires /* */ style comments below
//--


#define USER_APC_CHECK                                                        ;\
                                                                              ;\
/*                                                                          */;\
/* Check for pending APC's                                                  */;\
/*                                                                          */;\
                                                                              ;\
        movl        t22=BdPcr + PcCurrentThread        /* ->PcCurrentThread */;\
        ;;                                                                    ;\
                                                                              ;\
        LDPTR       (t22,t22)                                                 ;\
        ;;                                                                    ;\
        add         t22=ThApcState+AsUserApcPending, t22 /* -> pending flag */;\
        ;;                                                                    ;\
                                                                              ;\
        ld1         t8 = [t22], ThAlerted-ThApcState-AsUserApcPending         ;\
        ;;                                                                    ;\
        st1         [t22] = zero                                              ;\
        cmp##.##ne  pApc = zero, t8                  /* pApc = 1 if pending */;\
        ;;                                                                    ;\
                                                                              ;\
        PSET_IRQL   (pApc, APC_LEVEL)                                         ;\
(pApc)  mov         out1 = sp                                                 ;\
        ;;                                                                    ;\
(pApc)  FAST_DISABLE_INTERRUPTS                                               ;\
        PSET_IRQL   (pApc, zero)


//++
// Routine:
//
//       BSTORE_SWITCH
//
// Routine Description:
//
//       Common handler code for switching to user backing store, if
//       returning to user mode.
//
// On entry:
//
//      sp: pointer to trap frame
//
// On exit:
//
//      on user backing store, can't afford another alloc of any frame size
//      other than zero.  otherwise, the kernel may panic.
//
// Return Value:
//
//       None
//
// Note: 
//
//       MS preprocessor requires /* */ style comments below
//--


#define BSTORE_SWITCH                                                         ;\
/*                                                                          */;\
/* Set sp to trap frame and switch to kernel banked registers               */;\
/*                                                                          */;\
        rRscD     = t11                                                       ;\
        rpT2      = t12                                                       ;\
        rRNAT     = t13                                                       ;\
        rBSPStore = t14                                                       ;\
        rRscDelta = t15                                                       ;\
        rpT1      = t16                                                       ;\
                                                                              ;\
                                                                              ;\
        add       rpT1 = TrRsRNAT, sp                  /* -> user RNAT      */;\
        add       rpT2 = TrRsBSPSTORE, sp              /* -> user BSP Store */;\
        mov       rRscD = RSC_KERNEL_DISABLED                                 ;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Switch to user BSP -- put in load intensive mode to overlap RS restore   */;\
/* with volatile state restore.                                             */;\
/*                                                                          */;\
                                                                              ;\
        ld8       rRNAT = [rpT1], TrRsBSP-TrRsRNAT     /* user RNAT     */    ;\
        ld8       rBSPStore = [rpT2]                   /* user BSP Store*/    ;\
        ;;                                                                    ;\
                                                                              ;\
        alloc     t22 = 0,0,0,0                                               ;\
        ld8       rRscDelta = [rpT1]                   /* user BSP      */    ;\
        ;;                                                                    ;\
        sub       rRscDelta = rRscDelta, rBSPStore     /* delta = BSP - BSP Store */;\
        ;;                                                                    ;\
                                                                              ;\
        invala                                                                ;\
        dep       rRscD = rRscDelta, rRscD, 16, 14     /* set RSC.loadrs    */;\
        ;;                                                                    ;\
                                                                              ;\
        mov       ar##.##rsc = rRscD                   /* RSE off       */    ;\
        ;;                                                                    ;\
        loadrs                                         /* pull in user regs */;\
                                                       /* up to tear point */ ;\
        ;;                                                                    ;\
                                                                              ;\
        mov       ar##.##bspstore = rBSPStore          /* restore user BSP */ ;\
        ;;                                                                    ;\
        mov       ar##.##rnat = rRNAT                  /* restore user RNAT */


//++
// Routine:
//
//       NORMAL_KERNEL_EXIT
//
// Routine Description:
//
//       Common handler code for restoring previous state and rfi.
//
// On entry:
//
//      sp: pointer to trap frame
//      ar.unat: contains Nat for previous sp (restored by ld8.fill)
//
// Return Value:
//
//       None
//
// Note: 
//
//      Uses just the kernel banked registers (h16-h31)
//
//       MS preprocessor requires /* */ style comments below
//--

#define NORMAL_KERNEL_EXIT                                                    ;\
                                                                              ;\
        add         rHpT2 = TrApUNAT, sp            /* -> previous UNAT     */;\
        add         rHpT1 = TrStFPSR, sp            /* -> previous Preds    */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHUNAT = [rHpT2],TrPreds-TrApUNAT                         ;\
        ld8         rHFPSR = [rHpT1],TrRsPFS-TrStFPSR                         ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHOldPreds = [rHpT2], TrIntSp-TrPreds                     ;\
        ld8         rHPFS = [rHpT1],TrStIIPA-TrRsPFS                          ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8##.##fill rHSp = [rHpT2], TrBrRp-TrIntSp                           ;\
        ld8         rHIIPA = [rHpT1], TrStIIP-TrStIIPA                        ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##fpsr = rHFPSR            /* restore FPSR         */;\
        ld8         rHIIP = [rHpT1], TrStIPSR-TrStIIP  /* load IIP          */;\
        mov         pr = rHOldPreds, -1             /* restore preds        */;\
                                                                              ;\
        mov         ar##.##unat = rHUNAT            /* restore UNAT         */;\
        ld8         rHBrp = [rHpT2], TrStIFS-TrBrRp                           ;\
        mov         ar##.##pfs = rHPFS              /* restore PFS          */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHIFS = [rHpT2]                 /* load IFS             */;\
        ld8         rHIPSR = [rHpT1]                /* load IPSR            */;\
                                                                              ;\
        rsm         1 << PSR_IC                     /* reset ic bit         */;\
        ;;                                                                    ;\
        srlz##.##d                                  /* must serialize       */;\
        mov         brp = rHBrp                     /* restore brp          */;\
                                                                              ;\
/*                                                                          */;\
/* Restore status registers                                                 */;\
/*                                                                          */;\
                                                                              ;\
        mov         cr##.##ipsr = rHIPSR        /* restore previous IPSR    */;\
        mov         cr##.##iip = rHIIP          /* restore previous IIP     */;\
                                                                              ;\
        mov         cr##.##ifs = rHIFS          /* restore previous IFS     */;\
        mov         cr##.##iipa = rHIIPA        /* restore previous IIPA    */;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Resume at point of interruption (rfi must be at end of instruction group)*/;\
/*                                                                          */;\
        mov         sp = rHSp                   /* restore sp               */;\
        mov         h17 = r0                    /* clear TB loop count      */;\
        rfi                                                                   ;\
        ;;

//++
// Routine:
//
//       GET_INTERRUPT_VECTOR(pGet, rVector)
//
// Routine Description:
//
//       Hook to get the vector for an interrupt. Currently just
//       reads the Interrupt Vector Control Register.
//
// Agruments:
//
//       pGet:    Predicate: if true then get, else skip.
//       rVector: Register for the vector number.
//
// Return Value:
//
//       The vector number of the highest priority pending interrupt.
//       Vectors number is an 8-bit value. All other bits 0.
//
//--

#define GET_INTERRUPT_VECTOR(pGet,rVector)                         \
        srlz##.##d                                                ;\
(pGet)  mov         rVector = cr##.##ivr

       
//--------------------------------------------------------------------
// Routine:
//
//       BdBreakVector
//
// Description:
//
//       Interruption vector for break instruction.
//
// On entry:
//
//       IIM contains break immediate value:
//                 -- BREAK_SYSCALL -> standard system call
//       interrupts disabled
//       r16-r31 switched to kernel bank
//       r16-r31 all available since no TLB faults at this point
//
// Return value:
//
//       if system call, sys call return value in v0.
//
// Process:
//--------------------------------------------------------------------

        VECTOR_ENTRY(0x2C00, BdBreakVector, cr.iim)

        mov       b7 = h30                     // restore the original value of b7
        mov       rHIIM = cr.iim               // get break value
        movl      rTH1 = BdPcr+PcSavedIIM
        ;;
        st8       [rTH1] = rHIIM

        VECTOR_CALL_HANDLER(BdGenericExceptionHandler, BdOtherBreakException)

//
// Do not return from handler
//

        VECTOR_EXIT(BdBreakVector)

//++
//
// BdTakenBranchVector
//
// Cause:       A taken branch was successfully execcuted and the PSR.tb
//              bit is 1. This trap is higher priority than single step trap.
//
// Parameters:  cr.iip  - address of bundle containing the instruction to
//                        be executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. The ISR.code
//                        contains a bit vector for all traps which
//                        occurred in the trapping bundle. 
//              
//--
        
        VECTOR_ENTRY(0x5f00, BdTakenBranchVector, cr.iipa)
        
        mov       rHIIP = cr.iip
        movl      rHEPCVa = MM_EPC_VA+0x20     // user system call entry point

        mov       rHIPSR = cr.ipsr
        movl      rHpT1 = BdPcr+PcInitialStack
        ;;

        ld8       rHpT1 = [rHpT1]
        mov       rHOldPreds = pr
        mov       rPanicCode = UNEXPECTED_KERNEL_MODE_TRAP
        ;;

        cmp.eq    pt0 = rHEPCVa, rHIIP
        extr.u    rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN
        ;;

        cmp4.eq   pKrnl, pUser = PL_KERNEL, rTH1
(pKrnl) br.spnt.few BdPanicHandler
        ;;

 (pt0)  ssm       1 << PSR_IC
 (pt0)  movl      rTH1 = 1 << PSR_LP
        ;;

 (pt0)  or        rHpT3 = rHIPSR, rTH1
        movl      rHHandler = BdSingleStep

 (pt0)  srlz.d
        add       rHpT1=-ThreadStateSaveAreaLength-TrapFrameLength+TrStIPSR,rHpT1
 (pt0)  br.spnt.few Ktbv10

        mov       pr = rHOldPreds, -2
        br.sptk   BdGenericExceptionHandler
        ;;


Ktbv10:

        st8       [rHpT1] = rHpT3
        movl      rTH1 = 1 << PSR_SS | 1 << PSR_TB | 1 << PSR_DB
        ;;

        rsm       1 << PSR_IC
        mov       pr = rHOldPreds, -2
        andcm     rHIPSR = rHIPSR, rTH1   // clear ss, tb, db bits
        ;;

        srlz.d
        mov       cr.ipsr = rHIPSR
        ;;
        rfi
        ;;

        VECTOR_EXIT(BdTakenBranchVector)

//++
//
// BdSingleStepVector
//
// Cause:       An instruction was successfully execcuted and the PSR.ss
//              bit is 1. 
//
// Parameters:  cr.iip  - address of bundle containing the instruction to
//                        be executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. The ISR.code
//                        contains a bit vector for all traps which
//                        occurred in the trapping bundle. 
//              
//--
        
        VECTOR_ENTRY(0x6000, BdSingleStepVector, cr.iipa)
        
        mov       rHIIP = cr.iip
        movl      rHEPCVa = MM_EPC_VA+0x20     // user system call entry point

        mov       rHIPSR = cr.ipsr
        movl      rHpT1 = BdPcr+PcInitialStack
        ;;

        ld8       rHpT1 = [rHpT1]
        mov       rHOldPreds = pr
        mov       rPanicCode = UNEXPECTED_KERNEL_MODE_TRAP
        ;;

        cmp.eq    pt0 = rHEPCVa, rHIIP
        extr.u    rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN
        ;;

        cmp4.eq   pKrnl, pUser = PL_KERNEL, rTH1
(pKrnl) br.spnt.few BdPanicHandler
        ;;

 (pt0)  ssm       1 << PSR_IC
 (pt0)  movl      rTH1 = 1 << PSR_LP
        ;;

 (pt0)  or        rHpT3 = rHIPSR, rTH1
        movl      rHHandler = BdSingleStep

 (pt0)  srlz.d
        add       rHpT1=-ThreadStateSaveAreaLength-TrapFrameLength+TrStIPSR,rHpT1
 (pt0)  br.spnt.few Kssv10

        mov       pr = rHOldPreds, -2
        br.sptk   BdGenericExceptionHandler
        ;;


Kssv10:

        st8       [rHpT1] = rHpT3
        movl      rTH1 = 1 << PSR_SS | 1 << PSR_DB
        ;;

        rsm       1 << PSR_IC
        mov       pr = rHOldPreds, -2
        andcm     rHIPSR = rHIPSR, rTH1   // clear ss, db bits
        ;;

        srlz.d
        mov       cr.ipsr = rHIPSR
        ;;
        rfi
        ;;

        VECTOR_EXIT(BdSingleStepVector)

        .text
//++
//--------------------------------------------------------------------
// Routine:
//
//       BdGenericExceptionHandler
//
// Description:
//
//       First level handler for heavyweight exceptions.
//
// On entry:
//
//       ic off
//       interrupts disabled
//       current frame covered
//
// Process:
//
// Notes:
//
//       PCR page mapped with TR
//--------------------------------------------------------------------

        HANDLER_ENTRY(BdGenericExceptionHandler)

        .prologue
        .unwabi     @nt,  EXCEPTION_FRAME

        ALLOCATE_TRAP_FRAME

//
// sp points to trap frame
//
// Save exception handler routine in kernel register
//

        mov       rkHandler = rHHandler
        ;;

//
// Save interruption state in trap frame and switch to user bank registers
// and switch to kernel backing store.
//

        SAVE_INTERRUPTION_STATE(Kgeh_SaveTrapFrame)

//
// Now running with user banked registers and on kernel stack.
//
// Can now take TLB faults
//
// sp -> trap frame
//

        br.call.sptk brp = BdSaveTrapFrame
        ;;

//
// setup debug registers if previous mode is user
//

(pUser) br.call.spnt brp = BdSetupDebugRegisters

//
// Register aliases
//

        rpT1        = t0
        rpT2        = t1
        rpT3        = t2
        rT1         = t3
        rT2         = t4
        rT3         = t5
        rPreviousMode = t6                      // previous mode
        rT4         = t7


        movl      gp = _gp                      // make sure we are using loader's GP
        mov       rT1 = rkHandler               // restore address of interruption routine
        movl      rpT1 = BdPcr+PcSavedIIM
        ;;

        ld8       rT2 = [rpT1], PcSavedIFA-PcSavedIIM  // load saved IIM
        add       rpT2 = TrEOFMarker, sp
        add       rpT3 = TrStIIM, sp
        ;;

        ld8       rT4 = [rpT1]                  // load saved IFA
        movl      rT3 = KTRAP_FRAME_EOF | EXCEPTION_FRAME
        ;;

        st8       [rpT2] = rT3, TrNewBSP-TrEOFMarker
        st8       [rpT3] = rT2, TrStIFA-TrStIIM // save IIM in trap frame
        mov       bt0 = rT1                     // set destination address
        ;;

        st8       [rpT3] = rT4                  // save IFA in trap frame
#if DBG
        st8       [rpT2] = rT1                  // save debug info in TrFrame
#endif // DBG
        ;;

        PROLOGUE_END

        .regstk     0, 1, 2, 0                  // must be in sync with BdExceptionExit
        alloc       out1 = 0,1,2,0              // alloc 0 in, 1 locals, 2 outs

//
// Dispatch the exception via call to address in rkHandler
//
.pred.rel "mutex",pUser,pKrnl
        add       rpT1 = TrPreviousMode, sp     // -> previous mode
(pUser) mov       rPreviousMode = UserMode      // set previous mode
(pKrnl) mov       rPreviousMode = KernelMode
        ;;

        st4       [rpT1] = rPreviousMode        // **** TBD 1 byte -- save in trap frame
        mov       out0 = sp                     // trap frame pointer
        br.call.sptk brp = bt0                  // call handler(tf) (C code)
        ;;

.pred.rel "mutex",pUser,pKrnl
        cmp.ne    pt0, pt1 = v0, zero
(pUser) mov       out1 = UserMode
(pKrnl) mov       out1 = KernelMode

        //
        // does not return
        //

        mov       out0 = sp
(pt1)   br.cond.sptk BdAlternateExit
(pt0)   br.call.spnt brp = BdExceptionDispatch

        nop.m     0
        nop.m     0
        nop.i     0
        ;;

        HANDLER_EXIT(BdGenericExceptionHandler)


//--------------------------------------------------------------------
// Routine:
//
//       BdPanicHandler
//
// Description:
//
//       Handler for panic. Call the bug check routine. A place
//       holder for now.
//
// On entry:
//
//       running on kernel memory stack and kernel backing store
//       sp: top of stack -- points to trap frame
//       interrupts enabled
//
//       IIP: address of bundle causing fault
//
//       IPSR: copy of PSR at time of interruption
//
// Output:
//
//       sp: top of stack -- points to trap frame
//
// Return value:
//
//       none
//
// Notes:
//
//       If ISR code out of bounds, this code will inovke the panic handler
//
//--------------------------------------------------------------------

        HANDLER_ENTRY(BdPanicHandler)

        movl      rTH1 = BdPcr+PcPanicStack
        ;;

        ld8       sp = [rTH1]
        movl      rTH2 = BdPcr+PcSystemReserved
        ;;

        st4       [rTH2] = rPanicCode
        add       sp = -TrapFrameLength, sp
        ;;

        SAVE_INTERRUPTION_STATE(Kph_SaveTrapFrame)

        rpRNAT    = t16
        rpBSPStore= t17
        rBSPStore = t18
        rKBSPStore= t19
        rRNAT     = t20
        rKrnlFPSR = t21

        mov       ar.rsc = RSC_KERNEL_DISABLED
        add       rpRNAT = TrRsRNAT, sp
        add       rpBSPStore = TrRsBSPSTORE, sp
        ;;

        mov       rBSPStore = ar.bspstore
        mov       rRNAT = ar.rnat
        ;;

        st8       [rpRNAT] = rRNAT
        st8       [rpBSPStore] = rBSPStore
        dep       rKBSPStore = rBSPStore, sp, 0, 9
        ;;

        mov       ar.bspstore = rKBSPStore
        mov       ar.rsc = RSC_KERNEL
        ;;

        alloc     t22 = ar.pfs, 0, 0, 5, 0
        movl      out0 = BdPcr+PcSystemReserved
        ;;

        ld4       out0 = [out0]                // 1st argument: panic code
        mov       out1 = sp                    // 2nd argument: trap frame
        //br.call.sptk.many brp = KeBugCheckEx
        ;;

        HANDLER_EXIT(BdPanicHandler)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdSaveTrapFrame(PKTRAP_FRAME)
//
// Description:
//
//       Save volatile application state in trap frame.
//       Note: sp, brp, UNAT, RSC, predicates, BSP, BSP Store,
//       PFS, CSD, and FPSR saved elsewhere.
//
// Input:
//
//       sp: points to trap frame
//       ar.unat: contains the Nats of sp, gp, teb, which have already
//                been spilled into the trap frame.
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSaveTrapFrame)

        .regstk    0, 3, 0, 0

//
// Local register aliases
//

        rpTF1     = loc0
        rpTF2     = loc1
        rL1       = t0
        rL2       = t1
        rL3       = t2
        rL4       = t3
        rL5       = t4


//
// (ar.unat unchanged from point of save)
// Spill temporary (volatile) integer registers
//
         
        alloc       loc2 = 0,3,0,0              // don't destroy static register
        add         rpTF1 = TrIntT0, sp         // -> t0 save area
        add         rpTF2 = TrIntT1, sp         // -> t1 save area
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t0, TrIntT2-TrIntT0 // spill t0 - t22
        .mem.offset 8,0
        st8.spill [rpTF2] = t1, TrIntT3-TrIntT1
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t2, TrIntT4-TrIntT2
        .mem.offset 8,0
        st8.spill [rpTF2] = t3, TrIntT5-TrIntT3
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t4, TrIntT6-TrIntT4
        .mem.offset 8,0
        st8.spill [rpTF2] = t5, TrIntT7-TrIntT5
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t6, TrIntT8-TrIntT6
        .mem.offset 8,0
        st8.spill [rpTF2] = t7, TrIntT9-TrIntT7
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t8, TrIntT10-TrIntT8
        .mem.offset 8,0
        st8.spill [rpTF2] = t9, TrIntT11-TrIntT9
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t10, TrIntT12-TrIntT10
        .mem.offset 8,0
        st8.spill [rpTF2] = t11, TrIntT13-TrIntT11
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t12, TrIntT14-TrIntT12
        .mem.offset 8,0
        st8.spill [rpTF2] = t13, TrIntT15-TrIntT13
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t14, TrIntT16-TrIntT14
        .mem.offset 8,0
        st8.spill [rpTF2] = t15, TrIntT17-TrIntT15
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t16, TrIntT18-TrIntT16
        .mem.offset 8,0
        st8.spill [rpTF2] = t17, TrIntT19-TrIntT17
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t18, TrIntT20-TrIntT18
        .mem.offset 8,0
        st8.spill [rpTF2] = t19, TrIntT21-TrIntT19
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t20, TrIntT22-TrIntT20
        .mem.offset 8,0
        st8.spill [rpTF2] = t21, TrIntV0-TrIntT21
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t22, TrBrT0-TrIntT22
        .mem.offset 8,0
        st8.spill [rpTF2] = v0, TrIntNats-TrIntV0       // spill old V0
        ;;

//
// Now save the Nats interger regsisters saved so far (includes Nat for sp)
//

        mov       rL1 = ar.unat
        mov       rL2 = bt0
        mov       rL3 = bt1
        ;;

        st8       [rpTF2] = rL1, TrBrT1-TrIntNats       // save Nats of volatile regs
        mov       rL4 = ar.ccv
        ;;

//
// Save temporary (volatile) branch registers
//

        st8       [rpTF1] = rL2, TrApCCV-TrBrT0         // save old bt0 - bt1
        st8       [rpTF2] = rL3
        ;;

        st8       [rpTF1] = rL4                         // save ar.ccv
        add       rpTF1 = TrFltT0, sp                   // point to FltT0
        add       rpTF2 = TrFltT1, sp                   // point to FltT1
        ;;

//
// Spill temporary (volatile) floating point registers
//

        stf.spill [rpTF1] = ft0, TrFltT2-TrFltT0        // spill float tmp 0 - 9
        stf.spill [rpTF2] = ft1, TrFltT3-TrFltT1
        ;;
        stf.spill [rpTF1] = ft2, TrFltT4-TrFltT2
        stf.spill [rpTF2] = ft3, TrFltT5-TrFltT3
        ;;
        stf.spill [rpTF1] = ft4, TrFltT6-TrFltT4
        stf.spill [rpTF2] = ft5, TrFltT7-TrFltT5
        ;;
        stf.spill [rpTF1] = ft6, TrFltT8-TrFltT6
        stf.spill [rpTF2] = ft7, TrFltT9-TrFltT7
        ;;
        stf.spill [rpTF1] = ft8
        stf.spill [rpTF2] = ft9
        ;;

        rum       1 << PSR_MFL                          // clear mfl bit

//
// TBD **** Debug/performance regs ** ?
// **** Performance regs not needed (either user or system wide)
// No performance regs switched on kernel entry
// **** Debug regs saved if in use
//

        LEAF_RETURN
        ;;
        LEAF_EXIT(BdSaveTrapFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdRestoreTrapFrame(PKTRAP_FRAME)
//
// Description:
//
//       Restore volatile application state from trap frame. Restore CSD
//       Note: sp, brp, RSC, UNAT, predicates, BSP, BSP Store, PFS,
//       CSD and FPSR not restored here.
//
// Input:
//
//      sp: points to trap frame
//      RSE frame size is zero
//
// Output:
//
//      None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreTrapFrame)

        LEAF_SETUP(0,2,0,0)

        rpTF1     = loc0
        rpTF2     = loc1

//
// **** TBD **** Restore debug/performance registers??
// **** Performance regs not needed (either user or system wide)
// No performance regs switched on kernel entry
// **** Debug regs saved if in use
//

//
// Restore RSC, CCV, CSD, and volatile branch, floating point, integer register
//

        mov       t21 = psr
        add       rpTF1 = TrRsRSC, sp
        add       rpTF2 = TrApCCV, sp
        ;;

        ld8       t5 = [rpTF1], TrIntNats-TrRsRSC
        ld8       t1 = [rpTF2], TrSegCSD-TrApCCV
        ;;

        ld8       t0 = [rpTF1], TrBrT0-TrIntNats
        ld8       t3 = [rpTF2], TrBrT1-TrSegCSD
        ;;

        ld8       t2 = [rpTF1]
        ld8       t4 = [rpTF2]

        mov       ar.rsc = t5
        mov       ar.ccv = t1
        add       rpTF1 = TrIntGp, sp

        mov       ar.unat = t0
        mov       ar.csd = t3
        add       rpTF2 = TrIntT0, sp
        ;;

        ld8.fill  gp = [rpTF1], TrIntT1-TrIntGp
        ld8.fill  t0 = [rpTF2], TrIntT2-TrIntT0 
        mov       bt0 = t2
        ;;

        ld8.fill  t1 = [rpTF1], TrIntT3-TrIntT1
        ld8.fill  t2 = [rpTF2], TrIntT4-TrIntT2
        mov       bt1 = t4
        ;;

        ld8.fill  t3 = [rpTF1], TrIntT5-TrIntT3
        ld8.fill  t4 = [rpTF2], TrIntT6-TrIntT4
        tbit.z    pt1 = t21, PSR_MFL
        ;;

        ld8.fill  t5 = [rpTF1], TrIntT7-TrIntT5
        ld8.fill  t6 = [rpTF2], TrIntT8-TrIntT6
        ;;

        ld8.fill  t7 = [rpTF1], TrIntT9-TrIntT7
        ld8.fill  t8 = [rpTF2], TrIntT10-TrIntT8
        ;;

        ld8.fill  t9 = [rpTF1], TrIntT11-TrIntT9
        ld8.fill  t10 = [rpTF2], TrIntT12-TrIntT10
        ;;

        ld8.fill  t11 = [rpTF1], TrIntT13-TrIntT11
        ld8.fill  t12 = [rpTF2], TrIntT14-TrIntT12
        ;;

        ld8.fill  t13 = [rpTF1], TrIntT15-TrIntT13
        ld8.fill  t14 = [rpTF2], TrIntT16-TrIntT14
        ;;

        ld8.fill  t15 = [rpTF1], TrIntT17-TrIntT15
        ld8.fill  t16 = [rpTF2], TrIntT18-TrIntT16
        ;;

        ld8.fill  t17 = [rpTF1], TrIntT19-TrIntT17
        ld8.fill  t18 = [rpTF2], TrIntT20-TrIntT18
        ;;

        ld8.fill  t19 = [rpTF1], TrIntT21-TrIntT19
        ld8.fill  t20 = [rpTF2], TrIntT22-TrIntT20
        ;;

        ld8.fill  t21 = [rpTF1], TrIntTeb-TrIntT21
        ld8.fill  t22 = [rpTF2], TrIntV0-TrIntT22
        ;;

        ld8.fill  teb = [rpTF1], TrFltT1-TrIntTeb
        ld8.fill  v0 = [rpTF2], TrFltT0-TrIntV0
        ;;

        ldf.fill  ft0 = [rpTF2], TrFltT2-TrFltT0
        ldf.fill  ft1 = [rpTF1], TrFltT3-TrFltT1
        ;;
        
        ldf.fill  ft2 = [rpTF2], TrFltT4-TrFltT2
        ldf.fill  ft3 = [rpTF1], TrFltT5-TrFltT3
        ;;
        
        ldf.fill  ft4 = [rpTF2], TrFltT6-TrFltT4
        ldf.fill  ft5 = [rpTF1], TrFltT7-TrFltT5
        ;;
        
        ldf.fill  ft6 = [rpTF2], TrFltT8-TrFltT6
        ldf.fill  ft7 = [rpTF1], TrFltT9-TrFltT7
        ;;
        
        ldf.fill  ft8 = [rpTF2]
        ldf.fill  ft9 = [rpTF1]
        br.ret.sptk.many brp
        ;;
        
        LEAF_EXIT(BdRestoreTrapFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdSetupDebugRegisters
//
// Description:
//
//      We maintain two debug register flags:
//         1. Thread DebugActive: Debug registers active for current thread
//         2. PCR KernelDebugActive: Debug registers active in kernel mode
//            (setup by kernel debugger)
//
//      On user -> kernel transitions there are four possibilities:
//
//               Thread        Kernel 
//               DebugActive   DebugActive   Action
//
//      1.       0             0             None
//
//      2.       1             0             None (kernel PSR.db = 0 by default)
//
//      3.       0             1             Set PSR.db = 1 for kernel
//
//      4.       1             1             Set PSR.db = 1 for kernel and
//                                           load kernel debug registers
//
//      Note we never save the user debug registers: 
//      the user cannot change the DRs so the values in the DR save area are 
//      always up-to-date (set by SetContext).
//
// Input:
//
//       None (Previous mode is USER)
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSetupDebugRegisters)

//
// *** TBD -- no support for kernel debug registers (KernelDebugActive = 0)
// All the calls to this function are removed and have to be reinstated
// when hardware debug support is implemented in the kernel debugger.
//

        LEAF_RETURN
        LEAF_EXIT(BdSetupDebugRegisters)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdRestoreDebugRegisters
//
// Description:
//
//      If debug active, restore user debug registers from DR save area in
//      kernel stack.
//
// Input:
//
//       None
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
// Note:
//      We find the DR save are from the the StackBase not PCR->InitialStack,
//      which can be changed in BdCallUserMode().
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreDebugRegisters)

//
// Local register aliases
//

        rpSA0       = t0
        rpSA1       = t1
        rDebugActive = t2
        rpT1        = t3
        rPrcb       = t4
        rDr0        = t5
        rDr1        = t6
        rDrIndex0   = t7
        rDrIndex1   = t8
        rSaveLC     = t9
        rpCurrentThread = t10
        rStackBase  = t11

        pNoRestore  = pt0

//
// Restore debug registers, if debug active
//
         
        movl        rpT1 = BdPcr+PcCurrentThread
        ;;
        mov         rSaveLC = ar.lc             // save
        ld8         rpCurrentThread = [rpT1]    // get Current thread pointer
        ;;
        add         rpT1 = ThDebugActive, rpCurrentThread
        add         rStackBase = ThStackBase, rpCurrentThread
        ;;
        ld1         rDebugActive = [rpT1]       // get thread debug active flag
        ;;
        cmp.eq      pNoRestore = zero, rDebugActive
(pNoRestore) br.sptk Krdr_Exit                   // skip if not active
        ;;
        mov         rDrIndex0 = 0               
        mov         rDrIndex1 = 1
        ;;
        add         rpSA0 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbI0,rStackBase
        add         rpSA1 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbI1,rStackBase
        mov         ar.lc = 3                   // 4 pair of ibr
        ;;
Krdr_ILoop:
        ld8         rDr0 = [rpSA0], 16          // get ibr pair
        ld8         rDr1 = [rpSA1], 16          // step by 16 = 1 pair of DRs
        ;;
        .auto
        mov         ibr[rDrIndex0] = rDr0       // restore ibr pair
        mov         ibr[rDrIndex1] = rDr1
        ;;
        add         rDrIndex0 = 1, rDrIndex0    // next pair
        add         rDrIndex1 = 1, rDrIndex1
        br.cloop.sptk Krdr_ILoop
        ;;
        mov         ar.lc = 3                   // 4 pair of dbr
        mov         rDrIndex0 = 0
        mov         rDrIndex1 = 1
        ;;
Krdr_DLoop:
        ld8         rDr0 = [rpSA0], 16          // get dbr pair
        ld8         rDr1 = [rpSA1], 16          // step by 16 = 1 pair of DRs
        ;;
        mov         dbr[rDrIndex0] = rDr0       // restore dbr pair
        mov         dbr[rDrIndex1] = rDr1
        ;;
        .default
        add         rDrIndex0 = 1, rDrIndex0    // next pair
        add         rDrIndex1 = 1, rDrIndex1
        br.cloop.sptk Krdr_DLoop
        ;;
        mov         ar.lc = rSaveLC             // restore
Krdr_Exit:
        LEAF_RETURN
        LEAF_EXIT(BdRestoreDebugRegisters)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdSaveExceptionFrame(PKEXCEPTION_FRAME)
//
// Description:
//
//      Save preserved context in exception frame.
//
// Input:
//
//      a0: points to exception frame
//
// Output:
//
//      None
//
// Return value:
//
//      none
//
// Note: t0 may contain the trap frame address; don't touch it.
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSaveExceptionFrame)

//
// Local register aliases
//

        rpEF1     = t10
        rpEF2     = t11

        add       rpEF1 = ExIntS0, a0            // -> ExIntS0
        add       rpEF2 = ExIntS1, a0            // -> ExIntS1
        mov       t3 = ar.ec
        ;;

        .mem.offset 0,0
        st8.spill [rpEF1] = s0, ExIntS2-ExIntS0
        .mem.offset 8,0
        st8.spill [rpEF2] = s1, ExIntS3-ExIntS1
        mov       t4 = ar.lc
        ;;

        .mem.offset 0,0
        st8.spill [rpEF1] = s2, ExApEC-ExIntS2
        .mem.offset 8,0
        st8.spill [rpEF2] = s3, ExApLC-ExIntS3
        mov       t5 = bs0
        ;;

        st8       [rpEF1] = t3, ExBrS0-ExApEC
        st8       [rpEF2] = t4, ExBrS1-ExApLC
        mov       t6 = bs1
        ;;

        mov       t2 = ar.unat                   // save user nat register for
        mov       t7 = bs2
        mov       t8 = bs3

        st8       [rpEF1] = t5, ExBrS2-ExBrS0
        st8       [rpEF2] = t6, ExBrS3-ExBrS1
        mov       t9 = bs4
        ;;

        st8       [rpEF1] = t7, ExBrS4-ExBrS2
        st8       [rpEF2] = t8, ExIntNats-ExBrS3
        ;;

        st8       [rpEF1] = t9, ExFltS0-ExBrS4
        st8       [rpEF2] = t2, ExFltS1-ExIntNats
        ;;

        stf.spill [rpEF1] = fs0, ExFltS2-ExFltS0
        stf.spill [rpEF2] = fs1, ExFltS3-ExFltS1
        ;;

        stf.spill [rpEF1] = fs2, ExFltS4-ExFltS2
        stf.spill [rpEF2] = fs3, ExFltS5-ExFltS3
        ;;

        stf.spill [rpEF1] = fs4, ExFltS6-ExFltS4
        stf.spill [rpEF2] = fs5, ExFltS7-ExFltS5
        ;;

        stf.spill [rpEF1] = fs6, ExFltS8-ExFltS6
        stf.spill [rpEF2] = fs7, ExFltS9-ExFltS7
        ;;

        stf.spill [rpEF1] = fs8, ExFltS10-ExFltS8
        stf.spill [rpEF2] = fs9, ExFltS11-ExFltS9
        ;;

        stf.spill [rpEF1] = fs10, ExFltS12-ExFltS10
        stf.spill [rpEF2] = fs11, ExFltS13-ExFltS11
        ;;

        stf.spill [rpEF1] = fs12, ExFltS14-ExFltS12
        stf.spill [rpEF2] = fs13, ExFltS15-ExFltS13
        ;;

        stf.spill [rpEF1] = fs14, ExFltS16-ExFltS14
        stf.spill [rpEF2] = fs15, ExFltS17-ExFltS15
        ;;

        stf.spill [rpEF1] = fs16, ExFltS18-ExFltS16
        stf.spill [rpEF2] = fs17, ExFltS19-ExFltS17
        ;;

        stf.spill [rpEF1] = fs18
        stf.spill [rpEF2] = fs19
        LEAF_RETURN
        ;;

        LEAF_EXIT(BdSaveExceptionFrame)

//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdRestoreExceptionFrame(PKEXCEPTION_FRAME)
//
// Description:
//
//       Restores preserved context from the exception frame. Also
//       restore volatile part of floating point context not restored with
//       rest of volatile context.
//
// Input:
//
//      a0: points to exception frame
//
// Output:
//
//      None
//
// Return value:
//
//      none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreExceptionFrame)

//
// Local register aliases
//

        rpEF1     = t10
        rpEF2     = t11

        add       rpEF1 = ExIntNats, a0
        add       rpEF2 = ExApEC, a0
        ;;

        ld8       t2 = [rpEF1], ExBrS0-ExIntNats
        ld8       t3 = [rpEF2], ExApLC-ExApEC
        ;;

        ld8       t5 = [rpEF1], ExBrS1-ExBrS0
        ld8       t4 = [rpEF2], ExBrS2-ExApLC
        ;;

        mov       ar.unat = t2
        mov       ar.ec = t3
        ;;

        ld8       t6 = [rpEF1], ExBrS3-ExBrS1
        ld8       t7 = [rpEF2], ExBrS4-ExBrS2
        mov       ar.lc = t4
        ;;

        ld8       t8 = [rpEF1], ExIntS0-ExBrS3
        ld8       t9 = [rpEF2], ExIntS1-ExBrS4
        mov       bs0 = t5
        ;;

        ld8.fill  s0 = [rpEF1], ExIntS2-ExIntS0
        ld8.fill  s1 = [rpEF2], ExIntS3-ExIntS1
        mov       bs1 = t6
        ;;

        ld8.fill  s2 = [rpEF1], ExFltS0-ExIntS2
        ld8.fill  s3 = [rpEF2], ExFltS1-ExIntS3
        mov       bs2 = t7
        ;;

        ldf.fill  fs0 = [rpEF1], ExFltS2-ExFltS0
        ldf.fill  fs1 = [rpEF2], ExFltS3-ExFltS1
        mov       bs3 = t8
        ;;

        ldf.fill  fs2 = [rpEF1], ExFltS4-ExFltS2
        ldf.fill  fs3 = [rpEF2], ExFltS5-ExFltS3
        mov       bs4 = t9
        ;;

        ldf.fill  fs4 = [rpEF1], ExFltS6-ExFltS4
        ldf.fill  fs5 = [rpEF2], ExFltS7-ExFltS5
        ;;

        ldf.fill  fs6 = [rpEF1], ExFltS8-ExFltS6
        ldf.fill  fs7 = [rpEF2], ExFltS9-ExFltS7
        ;;

        ldf.fill  fs8 = [rpEF1], ExFltS10-ExFltS8
        ldf.fill  fs9 = [rpEF2], ExFltS11-ExFltS9
        ;;

        ldf.fill  fs10 = [rpEF1], ExFltS12-ExFltS10
        ldf.fill  fs11 = [rpEF2], ExFltS13-ExFltS11
        ;;

        ldf.fill  fs12 = [rpEF1], ExFltS14-ExFltS12
        ldf.fill  fs13 = [rpEF2], ExFltS15-ExFltS13
        ;;

        ldf.fill  fs14 = [rpEF1], ExFltS16-ExFltS14
        ldf.fill  fs15 = [rpEF2], ExFltS17-ExFltS15
        ;;

        ldf.fill  fs16 = [rpEF1], ExFltS18-ExFltS16
        ldf.fill  fs17 = [rpEF2], ExFltS19-ExFltS17
        ;;

        ldf.fill  fs18 = [rpEF1]
        ldf.fill  fs19 = [rpEF2]
        LEAF_RETURN
        ;;
        LEAF_EXIT(BdRestoreExceptionFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      BdSaveHigherFPVolatile(PKHIGHER_FP_SAVEAREA)
//
// Description:
//
//       Save higher FP volatile context in higher FP save area
//
// Input:
//
//       a0: pointer to higher FP save area
//       brp: return address
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSaveHigherFPVolatile)

//
// Local register aliases
//

        rpSA1     = t0
        rpSA2     = t1

//
// Spill higher floating point volatile registers f32-f127.
// Must add length of preserved area within FP save area to
// point to volatile save area.
//

//
// Clear DFH bit so the high floating point set may be saved by the kernel
// Disable interrupts so that save is atomic
//

        rsm       1 << PSR_DFH
        add       rpSA1 = HiFltF32, a0      // -> HiFltF32
        add       rpSA2 = HiFltF33, a0      // -> HiFltF33
        ;;

        srlz.d

        stf.spill [rpSA1] = f32, HiFltF34-HiFltF32
        stf.spill [rpSA2] = f33, HiFltF35-HiFltF33
        ;;
        stf.spill [rpSA1] = f34, HiFltF36-HiFltF34
        stf.spill [rpSA2] = f35, HiFltF37-HiFltF35
        ;;
        stf.spill [rpSA1] = f36, HiFltF38-HiFltF36
        stf.spill [rpSA2] = f37, HiFltF39-HiFltF37
        ;;
        stf.spill [rpSA1] = f38, HiFltF40-HiFltF38
        stf.spill [rpSA2] = f39, HiFltF41-HiFltF39
        ;;

        stf.spill [rpSA1] = f40, HiFltF42-HiFltF40
        stf.spill [rpSA2] = f41, HiFltF43-HiFltF41
        ;;
        stf.spill [rpSA1] = f42, HiFltF44-HiFltF42
        stf.spill [rpSA2] = f43, HiFltF45-HiFltF43
        ;;
        stf.spill [rpSA1] = f44, HiFltF46-HiFltF44
        stf.spill [rpSA2] = f45, HiFltF47-HiFltF45
        ;;
        stf.spill [rpSA1] = f46, HiFltF48-HiFltF46
        stf.spill [rpSA2] = f47, HiFltF49-HiFltF47
        ;;
        stf.spill [rpSA1] = f48, HiFltF50-HiFltF48
        stf.spill [rpSA2] = f49, HiFltF51-HiFltF49
        ;;

        stf.spill [rpSA1] = f50, HiFltF52-HiFltF50
        stf.spill [rpSA2] = f51, HiFltF53-HiFltF51
        ;;
        stf.spill [rpSA1] = f52, HiFltF54-HiFltF52
        stf.spill [rpSA2] = f53, HiFltF55-HiFltF53
        ;;
        stf.spill [rpSA1] = f54, HiFltF56-HiFltF54
        stf.spill [rpSA2] = f55, HiFltF57-HiFltF55
        ;;
        stf.spill [rpSA1] = f56, HiFltF58-HiFltF56
        stf.spill [rpSA2] = f57, HiFltF59-HiFltF57
        ;;
        stf.spill [rpSA1] = f58, HiFltF60-HiFltF58
        stf.spill [rpSA2] = f59, HiFltF61-HiFltF59
        ;;

        stf.spill [rpSA1] = f60, HiFltF62-HiFltF60
        stf.spill [rpSA2] = f61, HiFltF63-HiFltF61
        ;;
        stf.spill [rpSA1] = f62, HiFltF64-HiFltF62
        stf.spill [rpSA2] = f63, HiFltF65-HiFltF63
        ;;
        stf.spill [rpSA1] = f64, HiFltF66-HiFltF64
        stf.spill [rpSA2] = f65, HiFltF67-HiFltF65
        ;;
        stf.spill [rpSA1] = f66, HiFltF68-HiFltF66
        stf.spill [rpSA2] = f67, HiFltF69-HiFltF67
        ;;
        stf.spill [rpSA1] = f68, HiFltF70-HiFltF68
        stf.spill [rpSA2] = f69, HiFltF71-HiFltF69
        ;;

        stf.spill [rpSA1] = f70, HiFltF72-HiFltF70
        stf.spill [rpSA2] = f71, HiFltF73-HiFltF71
        ;;
        stf.spill [rpSA1] = f72, HiFltF74-HiFltF72
        stf.spill [rpSA2] = f73, HiFltF75-HiFltF73
        ;;
        stf.spill [rpSA1] = f74, HiFltF76-HiFltF74
        stf.spill [rpSA2] = f75, HiFltF77-HiFltF75
        ;;
        stf.spill [rpSA1] = f76, HiFltF78-HiFltF76
        stf.spill [rpSA2] = f77, HiFltF79-HiFltF77
        ;;
        stf.spill [rpSA1] = f78, HiFltF80-HiFltF78
        stf.spill [rpSA2] = f79, HiFltF81-HiFltF79
        ;;

        stf.spill [rpSA1] = f80, HiFltF82-HiFltF80
        stf.spill [rpSA2] = f81, HiFltF83-HiFltF81
        ;;
        stf.spill [rpSA1] = f82, HiFltF84-HiFltF82
        stf.spill [rpSA2] = f83, HiFltF85-HiFltF83
        ;;
        stf.spill [rpSA1] = f84, HiFltF86-HiFltF84
        stf.spill [rpSA2] = f85, HiFltF87-HiFltF85
        ;;
        stf.spill [rpSA1] = f86, HiFltF88-HiFltF86
        stf.spill [rpSA2] = f87, HiFltF89-HiFltF87
        ;;
        stf.spill [rpSA1] = f88, HiFltF90-HiFltF88
        stf.spill [rpSA2] = f89, HiFltF91-HiFltF89
        ;;

        stf.spill [rpSA1] = f90, HiFltF92-HiFltF90
        stf.spill [rpSA2] = f91, HiFltF93-HiFltF91
        ;;
        stf.spill [rpSA1] = f92, HiFltF94-HiFltF92
        stf.spill [rpSA2] = f93, HiFltF95-HiFltF93
        ;;
        stf.spill [rpSA1] = f94, HiFltF96-HiFltF94
        stf.spill [rpSA2] = f95, HiFltF97-HiFltF95
        ;;
        stf.spill [rpSA1] = f96, HiFltF98-HiFltF96
        stf.spill [rpSA2] = f97, HiFltF99-HiFltF97
        ;;
        stf.spill [rpSA1] = f98, HiFltF100-HiFltF98
        stf.spill [rpSA2] = f99, HiFltF101-HiFltF99
        ;;

        stf.spill [rpSA1] = f100, HiFltF102-HiFltF100
        stf.spill [rpSA2] = f101, HiFltF103-HiFltF101
        ;;
        stf.spill [rpSA1] = f102, HiFltF104-HiFltF102
        stf.spill [rpSA2] = f103, HiFltF105-HiFltF103
        ;;
        stf.spill [rpSA1] = f104, HiFltF106-HiFltF104
        stf.spill [rpSA2] = f105, HiFltF107-HiFltF105
        ;;
        stf.spill [rpSA1] = f106, HiFltF108-HiFltF106
        stf.spill [rpSA2] = f107, HiFltF109-HiFltF107
        ;;
        stf.spill [rpSA1] = f108, HiFltF110-HiFltF108
        stf.spill [rpSA2] = f109, HiFltF111-HiFltF109
        ;;

        stf.spill [rpSA1] = f110, HiFltF112-HiFltF110
        stf.spill [rpSA2] = f111, HiFltF113-HiFltF111
        ;;
        stf.spill [rpSA1] = f112, HiFltF114-HiFltF112
        stf.spill [rpSA2] = f113, HiFltF115-HiFltF113
        ;;
        stf.spill [rpSA1] = f114, HiFltF116-HiFltF114
        stf.spill [rpSA2] = f115, HiFltF117-HiFltF115
        ;;
        stf.spill [rpSA1] = f116, HiFltF118-HiFltF116
        stf.spill [rpSA2] = f117, HiFltF119-HiFltF117
        ;;
        stf.spill [rpSA1] = f118, HiFltF120-HiFltF118
        stf.spill [rpSA2] = f119, HiFltF121-HiFltF119
        ;;

        stf.spill [rpSA1] = f120, HiFltF122-HiFltF120
        stf.spill [rpSA2] = f121, HiFltF123-HiFltF121
        ;;
        stf.spill [rpSA1] = f122, HiFltF124-HiFltF122
        stf.spill [rpSA2] = f123, HiFltF125-HiFltF123
        ;;
        stf.spill [rpSA1] = f124, HiFltF126-HiFltF124
        stf.spill [rpSA2] = f125, HiFltF127-HiFltF125
        ;;
        stf.spill [rpSA1] = f126
        stf.spill [rpSA2] = f127

//
// Set DFH bit so the high floating point set may not be used by the kernel
// Must clear mfh after fp registers saved
//

        rsm       1 << PSR_MFH
        ssm       1 << PSR_DFH
        ;;
        srlz.d
        LEAF_RETURN

        LEAF_EXIT(BdSaveHigherFPVolatile)

//++
//--------------------------------------------------------------------
// Routine:
//
//      BdRestoreHigherFPVolatile()
//
// Description:
//
//       Restore higher FP volatile context from higher FP save area
//
//       N.B. This function is carefully constructed to use only scratch 
//            registers rHpT1, rHpT3, and rTH2.  This function may be
//            called by C code and the disabled fp vector when user
//            and kernel bank is used respectively.
//       N.B. Caller must ensure higher fp enabled (psr.dfh=0)
//       N.B. Caller must ensure no interrupt during restore
//
// Input:
//
//       None.
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreHigherFPVolatile)

//
// rHpT1 & rHpT3 are 2 registers that are available as 
// scratch registers in this function.
//

        srlz.d
        movl      rHpT1 = BdPcr+PcInitialStack
        ;;

        ld8       rTH2 = [rHpT1]
        ;;
        add       rHpT1 = -ThreadStateSaveAreaLength+TsHigherFPVolatile+HiFltF32, rTH2
        add       rHpT3 = -ThreadStateSaveAreaLength+TsHigherFPVolatile+HiFltF33, rTH2
        ;;

        ldf.fill  f32 = [rHpT1], HiFltF34-HiFltF32
        ldf.fill  f33 = [rHpT3], HiFltF35-HiFltF33
        ;;

        ldf.fill  f34 = [rHpT1], HiFltF36-HiFltF34
        ldf.fill  f35 = [rHpT3], HiFltF37-HiFltF35
        ;;
        ldf.fill  f36 = [rHpT1], HiFltF38-HiFltF36
        ldf.fill  f37 = [rHpT3], HiFltF39-HiFltF37
        ;;
        ldf.fill  f38 = [rHpT1], HiFltF40-HiFltF38
        ldf.fill  f39 = [rHpT3], HiFltF41-HiFltF39
        ;;

        ldf.fill  f40 = [rHpT1], HiFltF42-HiFltF40
        ldf.fill  f41 = [rHpT3], HiFltF43-HiFltF41
        ;;
        ldf.fill  f42 = [rHpT1], HiFltF44-HiFltF42
        ldf.fill  f43 = [rHpT3], HiFltF45-HiFltF43
        ;;
        ldf.fill  f44 = [rHpT1], HiFltF46-HiFltF44
        ldf.fill  f45 = [rHpT3], HiFltF47-HiFltF45
        ;;
        ldf.fill  f46 = [rHpT1], HiFltF48-HiFltF46
        ldf.fill  f47 = [rHpT3], HiFltF49-HiFltF47
        ;;
        ldf.fill  f48 = [rHpT1], HiFltF50-HiFltF48
        ldf.fill  f49 = [rHpT3], HiFltF51-HiFltF49
        ;;

        ldf.fill  f50 = [rHpT1], HiFltF52-HiFltF50
        ldf.fill  f51 = [rHpT3], HiFltF53-HiFltF51
        ;;
        ldf.fill  f52 = [rHpT1], HiFltF54-HiFltF52
        ldf.fill  f53 = [rHpT3], HiFltF55-HiFltF53
        ;;
        ldf.fill  f54 = [rHpT1], HiFltF56-HiFltF54
        ldf.fill  f55 = [rHpT3], HiFltF57-HiFltF55
        ;;
        ldf.fill  f56 = [rHpT1], HiFltF58-HiFltF56
        ldf.fill  f57 = [rHpT3], HiFltF59-HiFltF57
        ;;
        ldf.fill  f58 = [rHpT1], HiFltF60-HiFltF58
        ldf.fill  f59 = [rHpT3], HiFltF61-HiFltF59
        ;;

        ldf.fill  f60 = [rHpT1], HiFltF62-HiFltF60
        ldf.fill  f61 = [rHpT3], HiFltF63-HiFltF61
        ;;
        ldf.fill  f62 = [rHpT1], HiFltF64-HiFltF62
        ldf.fill  f63 = [rHpT3], HiFltF65-HiFltF63
        ;;
        ldf.fill  f64 = [rHpT1], HiFltF66-HiFltF64
        ldf.fill  f65 = [rHpT3], HiFltF67-HiFltF65
        ;;
        ldf.fill  f66 = [rHpT1], HiFltF68-HiFltF66
        ldf.fill  f67 = [rHpT3], HiFltF69-HiFltF67
        ;;
        ldf.fill  f68 = [rHpT1], HiFltF70-HiFltF68
        ldf.fill  f69 = [rHpT3], HiFltF71-HiFltF69
        ;;

        ldf.fill  f70 = [rHpT1], HiFltF72-HiFltF70
        ldf.fill  f71 = [rHpT3], HiFltF73-HiFltF71
        ;;
        ldf.fill  f72 = [rHpT1], HiFltF74-HiFltF72
        ldf.fill  f73 = [rHpT3], HiFltF75-HiFltF73
        ;;
        ldf.fill  f74 = [rHpT1], HiFltF76-HiFltF74
        ldf.fill  f75 = [rHpT3], HiFltF77-HiFltF75
        ;;
        ldf.fill  f76 = [rHpT1], HiFltF78-HiFltF76
        ldf.fill  f77 = [rHpT3], HiFltF79-HiFltF77
        ;;
        ldf.fill  f78 = [rHpT1], HiFltF80-HiFltF78
        ldf.fill  f79 = [rHpT3], HiFltF81-HiFltF79
        ;;

        ldf.fill  f80 = [rHpT1], HiFltF82-HiFltF80
        ldf.fill  f81 = [rHpT3], HiFltF83-HiFltF81
        ;;
        ldf.fill  f82 = [rHpT1], HiFltF84-HiFltF82
        ldf.fill  f83 = [rHpT3], HiFltF85-HiFltF83
        ;;
        ldf.fill  f84 = [rHpT1], HiFltF86-HiFltF84
        ldf.fill  f85 = [rHpT3], HiFltF87-HiFltF85
        ;;
        ldf.fill  f86 = [rHpT1], HiFltF88-HiFltF86
        ldf.fill  f87 = [rHpT3], HiFltF89-HiFltF87
        ;;
        ldf.fill  f88 = [rHpT1], HiFltF90-HiFltF88
        ldf.fill  f89 = [rHpT3], HiFltF91-HiFltF89
        ;;

        ldf.fill  f90 = [rHpT1], HiFltF92-HiFltF90
        ldf.fill  f91 = [rHpT3], HiFltF93-HiFltF91
        ;;
        ldf.fill  f92 = [rHpT1], HiFltF94-HiFltF92
        ldf.fill  f93 = [rHpT3], HiFltF95-HiFltF93
        ;;
        ldf.fill  f94 = [rHpT1], HiFltF96-HiFltF94
        ldf.fill  f95 = [rHpT3], HiFltF97-HiFltF95
        ;;
        ldf.fill  f96 = [rHpT1], HiFltF98-HiFltF96
        ldf.fill  f97 = [rHpT3], HiFltF99-HiFltF97
        ;;
        ldf.fill  f98 = [rHpT1], HiFltF100-HiFltF98
        ldf.fill  f99 = [rHpT3], HiFltF101-HiFltF99
        ;;

        ldf.fill  f100 = [rHpT1], HiFltF102-HiFltF100
        ldf.fill  f101 = [rHpT3], HiFltF103-HiFltF101
        ;;
        ldf.fill  f102 = [rHpT1], HiFltF104-HiFltF102
        ldf.fill  f103 = [rHpT3], HiFltF105-HiFltF103
        ;;
        ldf.fill  f104 = [rHpT1], HiFltF106-HiFltF104
        ldf.fill  f105 = [rHpT3], HiFltF107-HiFltF105
        ;;
        ldf.fill  f106 = [rHpT1], HiFltF108-HiFltF106
        ldf.fill  f107 = [rHpT3], HiFltF109-HiFltF107
        ;;
        ldf.fill  f108 = [rHpT1], HiFltF110-HiFltF108
        ldf.fill  f109 = [rHpT3], HiFltF111-HiFltF109
        ;;

        ldf.fill  f110 = [rHpT1], HiFltF112-HiFltF110
        ldf.fill  f111 = [rHpT3], HiFltF113-HiFltF111
        ;;
        ldf.fill  f112 = [rHpT1], HiFltF114-HiFltF112
        ldf.fill  f113 = [rHpT3], HiFltF115-HiFltF113
        ;;
        ldf.fill  f114 = [rHpT1], HiFltF116-HiFltF114
        ldf.fill  f115 = [rHpT3], HiFltF117-HiFltF115
        ;;
        ldf.fill  f116 = [rHpT1], HiFltF118-HiFltF116
        ldf.fill  f117 = [rHpT3], HiFltF119-HiFltF117
        ;;
        ldf.fill  f118 = [rHpT1], HiFltF120-HiFltF118
        ldf.fill  f119 = [rHpT3], HiFltF121-HiFltF119
        ;;

        ldf.fill  f120 = [rHpT1], HiFltF122-HiFltF120
        ldf.fill  f121 = [rHpT3], HiFltF123-HiFltF121
        ;;
        ldf.fill  f122 = [rHpT1], HiFltF124-HiFltF122
        ldf.fill  f123 = [rHpT3], HiFltF125-HiFltF123
        ;;
        ldf.fill  f124 = [rHpT1], HiFltF126-HiFltF124
        ldf.fill  f125 = [rHpT3], HiFltF127-HiFltF125
        ;;
        ldf.fill  f126 = [rHpT1]
        ldf.fill  f127 = [rHpT3]
        ;;

        rsm       1 << PSR_MFH                 // clear psr.mfh bit
        br.ret.sptk brp
        ;;

        LEAF_EXIT(BdRestoreHigherFPVolatile)


//++
//
// Routine Description:
//
//     This routine begins the common code for raising an exception.
//     The routine saves the non-volatile state and dispatches to the
//     next level exception dispatcher.
//
// Arguments:
//
//      a0 - pointer to trap frame
//      a1 - previous mode
//
// Return Value:
//
//      None.
//
//--

        NESTED_ENTRY(BdExceptionDispatch)

//
// Build exception frame
//

        .regstk   2, 3, 5, 0
        .prologue 0xA, loc0
        alloc     t16 = ar.pfs, 2, 3, 5, 0
        mov       loc0 = sp
        cmp4.eq   pt0 = UserMode, a1                  // previous mode is user?

        mov       loc1 = brp 
        add       sp = -ExceptionFrameLength, sp
        ;;

        .save     ar.unat, loc2
        mov       loc2 = ar.unat
        add       t0 = ExFltS19+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
 (pt0)  add       out0 = TrapFrameLength+TsHigherFPVolatile, a0
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3
 (pt0)  br.call.sptk brp = BdSaveHigherFPVolatile
        ;;


        PROLOGUE_END

        add       out0 = TrExceptionRecord, a0        // -> exception record
        add       out1 = STACK_SCRATCH_AREA, sp       // -> exception frame
        mov       out2 = a0                           // -> trap frame

        br.call.sptk.many brp = BdTrap

        add       t1 = ExApEC+STACK_SCRATCH_AREA, sp
        movl      t0 = BdExceptionExit
        ;;

        ld8       t1 = [t1]
        mov       brp = t0
        ;;

        mov       ar.unat = loc2
        mov       ar.pfs = t1

        add       s1 = STACK_SCRATCH_AREA, sp         // s1 -> exception frame
        mov       s0 = a0                             // s0 -> trap frame
        br.ret.sptk brp
        ;;

        ALTERNATE_ENTRY(BdExceptionExit)

//++
//
// Routine Description:
//
//     This routine is called to exit from an exception.
//
//     N.B. This transfer of control occurs from:
//
//         1. fall-through from above
//         2. exit from continue system service
//         3. exit from raise exception system service
//         4. exit into user mode from thread startup
//
// Arguments:
//
//     loc0 - pointer to trap frame
//     sp - pointer to high preserved float save area + STACK_SCRATCH_AREA
//
// Return Value:
//
//      Does not return.
//
//--

//
// upon entry of this block, s0 and s1 must be set to the address of
// the trap and the exception frames respectively.
//
// preserved state is restored here because they may have been modified
// by SetContext
//

     
        LEAF_SETUP(0, 1, 2, 0)                        // must be in sync with
                                                  // BdGenericExceptionHandler
        mov       loc0 = s0                       // -> trap frame
        mov       out0 = s1                       // -> exception frame
        ;;

        br.call.sptk brp = BdRestoreExceptionFrame
        ;;

        mov       sp = loc0                       // deallocate exception
                                                  // frame by restoring sp

        ALTERNATE_ENTRY(BdAlternateExit)

//
// sp -> trap frame addres
//
// Interrupts disabled from here to rfi
//

        FAST_DISABLE_INTERRUPTS
        ;;

        RETURN_FROM_INTERRUPTION(Ked)

        NESTED_EXIT(BdExceptionDispatch)



        NESTED_ENTRY(BdInstallVectors)
        NESTED_SETUP  (3,17,8,0)          

IpValue:
        mov         loc4 = ip
        movl        loc5 = IpValue
        ;;

        sub         loc6 = loc4, loc5           // relocation = runtime add - link addr
        mov         loc8 = cr.iva
        ;;

//
// Set Break Instrution Vector
//
        movl        loc7 = 0x2C00
        ;;

        add         out0 = loc7, loc8           // out0 = address of IVT vector
        movl        out1 = BdBreakVector        // out2 = address of exception handler 
                                                // (static value) to be plugged into IVT 
        mov         out2 = loc6                 // adjustment to go from static to runtime
        br.call.dpnt.few  brp = BdUpdateIvt     // Fill in the address of routine into IVT

//
// Set Taken Branch Vector
//
        movl        loc7 = 0x5F00
        ;;

        add         out0 = loc7, loc8           // out0 = address of IVT vector
        movl        out1 = BdTakenBranchVector  // out2 = address of exception handler 
                                                // (static value) to be plugged into IVT 
        mov         out2 = loc6                 // adjustment to go from static to runtime
        br.call.dpnt.few  brp = BdUpdateIvt     // Fill in the address of routine into IVT

//
// Set Single Step Vector
//
        movl        loc7 = 0x6000
        ;;

        add         out0 = loc7, loc8           // out0 = address of IVT vector
        movl        out1 = BdSingleStepVector   // out2 = address of exception handler 
                                                // (static value) to be plugged into IVT 
        mov         out2 = loc6                 // adjustment to go from static to runtime
        br.call.dpnt.few  brp = BdUpdateIvt     // Fill in the address of routine into IVT

        NESTED_RETURN
        NESTED_EXIT(BdInstallVectors)               // Return to caller using B0


//-------------------------------------------------
//
//  BdUpdateIvt : Routine to fill in an entry into the IVT. 
//  This is a leaf routine. 
//
//   in0 = address of IVT vector
//   in1 = address of exception handler (static value) to be plugged into IVT 
//   in2 = adjustment to go from static to runtime
//
//-------------------------------------------------
        NESTED_ENTRY(BdUpdateIvt)
        NESTED_SETUP  (8,16,4,0)          

        mov         out0 = in0
        movl        out1 = BdIvtStart
        movl        out2 = BdIvtEnd - BdIvtStart
        ;;

        br.call.sptk brp = memcpy
        ;;

        mov         out0 = in0
        mov         out1 = in1
        ;;
        br.call.sptk brp = BdSetMovlImmediate

        NESTED_RETURN
        NESTED_EXIT(BdUpdateIvt)                  // Return to caller using B0


BdIvtStart:
{
        .mlx
        nop.m 0
        movl        h31 = BdIvtStart
        ;;
}
{
        .mii
        nop.m  0
        nop.i  0
        mov         h30 = b7
        ;;
}
{
        .mii
        nop.m  0
        nop.i  0
        mov         b7 = h31
        ;;
}
{
        .mib
        nop.m  0
        nop.i  0
(p0)    br.sptk.few b7   
        ;;
}
BdIvtEnd:

//
// All non-VECTOR_ENTRY functions must follow KiNormalSystemCall.
//
// N.B. KiNormalSystemCall must be the first function body in the .nsc
//      section.
//


//--------------------------------------------------------------------
// Routine:
//
//       KiNormalSystemCall
//
// Description:
//
//       Handler for normal (not fast) system calls
//
// On entry:
//
//       ic off
//       interrupts disabled
//       v0: contains sys call #
//       cover done by call
//       r32-r39: sys call arguments
//       CFM: sof = # args, ins = 0, outs = # args
//
// Return value:
//
//       v0: system call return value
//
// Process:
//
//--------------------------------------------------------------------

#if 0
        .section .drectve, "MI", "progbits"
         string " -section:.nsc,,align=0x4000"

        .section .nsc = "ax", "progbits"
#endif

        HANDLER_ENTRY_EX(KiNormalSystemCall, BdRestoreTrapFrame)

        .prologue
        .unwabi     @nt,  SYSCALL_FRAME

        rThread     = t1                  // current thread
        rIFS        = t1
        rIIP        = t2
        rPreds      = t3
        rIPSR       = t4
        rUNAT       = t5

        rSp         = t6

        rpT1        = t7
        rpT2        = t8
        rpT3        = t9
        rpT4        = t10
        rT0         = t11
        rT1         = t12
        rT2         = t13
        rT3         = t14
        rT4         = t15

        rIntNats    = t17

        rpSd        = t16                  /* -> service descriptor entry   */
        rSdOffset   = t17                  /* service descriptor offset     */
        rArgTable   = t18                  /* pointer to argument table     */
        rArgNum     = t20                  /* number of arguments     */
        rArgBytes   = t21

        rpBSPStore  = t16
        rRscD       = t16
        rRNAT       = t17
        rRscE       = t18
        rKBSPStore  = t18
        rBSPStore   = t19
        rpBSP       = t20
        rRscDelta   = t20

        rBSP        = t21
        rPreviousMode = t22

        pInvl       = pt0                  /* pInvl = not GUI service       */
        pVal        = pt1
        pGui        = pt2                  /* true if GUI call              */
        pNoGui      = pt3                  /* true if no GUI call           */
        pNatedArg   = pt4                  /* true if any input argument    */
                                           /* register is Nat'ed            */
        pNoCopy     = pt5                  /* no in-memory arguments to copy */
        pCopy       = pt6


        mov       rUNAT = ar.unat
        tnat.nz   pt0 = sp
        mov       rPreviousMode = KernelMode

        mov       rIPSR = psr
        rsm       1 << PSR_I | 1 << PSR_MFH
        br.sptk   BdRestoreTrapFrame

        HANDLER_EXIT(KiNormalSystemCall)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\bootstat.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bootstat.c

Abstract:

    Manipulates the boot status data file.

Author:

    Peter Wieland (peterwie)    01-18-01

Revision History:

--*/

#include "bldr.h"
#include "bootstatus.h"

#include <stdio.h>

#define FIELD_SIZE(type, field)  sizeof(((type *)0)->field)
#define FIELD_OFFSET_AND_SIZE(n)   {FIELD_OFFSET(BSD_BOOT_STATUS_DATA, n), FIELD_SIZE(BSD_BOOT_STATUS_DATA, n)}

VOID
BlAutoAdvancedBoot(
    IN OUT PCHAR *LoadOptions, 
    IN BSD_LAST_BOOT_STATUS LastBootStatus,
    IN ULONG AdvancedBootMode
    )
{
    CHAR bootStatusString[32];
    PCHAR advancedBootString = NULL;

    ULONG newLoadOptionsLength;
    PCHAR newLoadOptions;

    //
    // Write the last boot status into a string.
    //

    sprintf(bootStatusString, "LastBootStatus=%d", LastBootStatus);

    //
    // Based on the advanced boot mode indicated by the caller, adjust the 
    // boot options.
    //

    if (AdvancedBootMode != -1) {
        advancedBootString = BlGetAdvancedBootLoadOptions(AdvancedBootMode);
    }

    //
    // Determine the length of the new load options string.
    //

    newLoadOptionsLength = (ULONG)strlen(bootStatusString) + 1;

    if(*LoadOptions != NULL) {
        newLoadOptionsLength += (ULONG)strlen(*LoadOptions) + 1;
    }

    if(advancedBootString) {
        newLoadOptionsLength += (ULONG)strlen(advancedBootString) + 1;
    }

    newLoadOptions = BlAllocateHeap(newLoadOptionsLength * sizeof(UCHAR));

    if(newLoadOptions == NULL) {
        return;
    }

    //
    // Concatenate all the strings together.
    //

    sprintf(newLoadOptions, "%s %s %s",
            ((*LoadOptions != NULL) ? *LoadOptions : ""),
            ((advancedBootString != NULL) ? advancedBootString : ""),
            bootStatusString);

    if(AdvancedBootMode != -1) {
        BlDoAdvancedBootLoadProcessing(AdvancedBootMode);
    }

    *LoadOptions = newLoadOptions;

    return;
}

ARC_STATUS
BlGetSetBootStatusData(
    IN PVOID DataHandle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned OPTIONAL
    )
{
    ULONG fileId = (ULONG) ((ULONG_PTR) DataHandle);

    struct {
        ULONG FieldOffset;
        ULONG FieldLength;
    } bootStatusFields[] = {
        FIELD_OFFSET_AND_SIZE(Version),
        FIELD_OFFSET_AND_SIZE(ProductType),
        FIELD_OFFSET_AND_SIZE(AutoAdvancedBoot),
        FIELD_OFFSET_AND_SIZE(AdvancedBootMenuTimeout),
        FIELD_OFFSET_AND_SIZE(LastBootSucceeded),
        FIELD_OFFSET_AND_SIZE(LastBootShutdown)
    };

    ULONG dataFileVersion;

    LARGE_INTEGER fileOffset;
    ULONG itemLength;

    ULONG bytesRead;

    ARC_STATUS status;

    ASSERT(RtlBsdItemMax == (sizeof(bootStatusFields) / sizeof(bootStatusFields[0])));

    //
    // Read the version number out of the data file.
    //

    fileOffset.QuadPart = 0;

    status = BlSeek(fileId, &fileOffset, SeekAbsolute);

    if(status != ESUCCESS) {
        return status;
    }

    status = BlRead(fileId,
                    &dataFileVersion,
                    sizeof(ULONG),
                    &bytesRead);

    if(status != ESUCCESS) {
        return status;
    }

    //
    // If the data item requsted isn't one we have code to handle then 
    // return invalid parameter.
    //

    if(DataItem >= (sizeof(bootStatusFields) / sizeof(bootStatusFields[0]))) {
        return EINVAL;
    }

    fileOffset.QuadPart = bootStatusFields[DataItem].FieldOffset;
    itemLength = bootStatusFields[DataItem].FieldLength;

    //
    // If the data item offset is beyond the end of the file then return a 
    // versioning error.
    //

    if((fileOffset.QuadPart + itemLength) > dataFileVersion) {
        return EINVAL;
    }

    if(DataBufferLength < itemLength) { 
        DataBufferLength = itemLength;
        return EINVAL;
    }

    status = BlSeek(fileId, &fileOffset, SeekAbsolute);

    if(status != ESUCCESS) {
        return status;
    }

    if(Get) {
        status = BlRead(fileId, 
                        DataBuffer,
                        itemLength,
                        &bytesRead);

    } else {
        status = BlWrite(fileId,
                         DataBuffer,
                         itemLength,
                         &bytesRead);
    }

    if((status == ESUCCESS) && ARGUMENT_PRESENT(BytesReturned)) {
        *BytesReturned = bytesRead;
    }

    return status;
}

ARC_STATUS
BlLockBootStatusData(
    IN ULONG SystemPartitionId,
    IN PCHAR SystemPartition,
    IN PCHAR SystemDirectory,
    OUT PVOID *DataHandle
    )
/*++

Routine Description:

    This routine opens the boot status data file.
    
Arguments:

    SystemPartitionId - if non-zero this is the arc file id of the system 
                        partition.  This will be used to locate the system 
                        directory instead of the system partition name (below).
    
    SystemPartition - the arc name of the system partition.  Ignored if 
                      SystemPartitionId is non-zero.
    
    SystemDirectory - the name of the system directory.

    DataHandle - returns a handle to the boot status data.
    
Return Value:

    ESUCCESS if the status data could be locked, or error indicating why not.
    
--*/
{
    ULONG driveId;

    CHAR filePath[100];
    ULONG fileId;

    ARC_STATUS status;

    if(SystemPartitionId == 0) {

        //
        // Attempt to open the system partition
        //
    
        status = ArcOpen(SystemPartition, ArcOpenReadWrite, &driveId);
        
        if(status != ESUCCESS) {
            return status;
        }
    } else {
        driveId = SystemPartitionId;
    }

    //
    // Now attempt to open the file <SystemDirectory>\bootstat.dat
    //
    if (sizeof(filePath) < strlen(SystemDirectory) + strlen(BSD_FILE_NAME) + 1) {
        return ENOMEM;
    }
    strcpy(filePath, SystemDirectory);
    strcat(filePath, BSD_FILE_NAME);

    status = BlOpen(driveId, filePath, ArcOpenReadWrite, &fileId);

    if(SystemPartitionId == 0) {
        //
        // Close the drive.
        //
    
        ArcClose(driveId);
    }

    //
    // The file doesn't exist so we don't know the state of the last boot.
    //

    if(status != ESUCCESS) {
        return status;
    }

    *DataHandle = (PVOID) ((ULONG_PTR) fileId);

    return ESUCCESS;
}


VOID
BlUnlockBootStatusData(
    IN PVOID DataHandle
    )
{
    ULONG fileId = (ULONG) ((ULONG_PTR) DataHandle);

    BlClose(fileId);
    return;
}

ULONG
BlGetLastBootStatus(
    IN PVOID DataHandle, 
    OUT BSD_LAST_BOOT_STATUS *LastBootStatus
    )
{
    UCHAR lastBootGood;
    UCHAR lastShutdownGood;
    UCHAR aabEnabled;

    ULONG advancedBootMode = (ULONG)-1;

    ARC_STATUS status;

    *LastBootStatus = BsdLastBootGood;

    //
    // The file contains a simple data structure so i can avoid parsing an 
    // INI file.  If this proves to be insufficient for policy management then 
    // we'll change it into an ini file.
    // 

    //
    // Read the last boot status.
    //

    status = BlGetSetBootStatusData(DataHandle,
                                    TRUE,
                                    RtlBsdItemBootGood,
                                    &lastBootGood,
                                    sizeof(UCHAR),
                                    NULL);

    if(status != ESUCCESS) {
        *LastBootStatus = BsdLastBootUnknown;
        return advancedBootMode;
    }

    status = BlGetSetBootStatusData(DataHandle,
                                    TRUE,
                                    RtlBsdItemBootShutdown,
                                    &lastShutdownGood,
                                    sizeof(UCHAR),
                                    NULL);

    if(status != ESUCCESS) {
        *LastBootStatus = BsdLastBootUnknown;
        return advancedBootMode;
    }

    status = BlGetSetBootStatusData(DataHandle,
                                    TRUE,
                                    RtlBsdItemAabEnabled,
                                    &aabEnabled,
                                    sizeof(UCHAR),
                                    NULL);

    if(status != ESUCCESS) {
        *LastBootStatus = BsdLastBootUnknown;
        return advancedBootMode;
    }

    //
    // If the system was shutdown cleanly then don't bother to check if the
    // boot was good.
    //

    if(lastShutdownGood) {
        return advancedBootMode;
    }

    //
    // Determine the last boot status & what action to take.
    //

    if(lastBootGood == FALSE) {

        //
        // Enable last known good.
        //

        advancedBootMode = 6;
        *LastBootStatus = BsdLastBootFailed;
    } else if(lastShutdownGood == FALSE) {

        //
        // Enable safe mode without networking.
        //

        advancedBootMode = 0;
        *LastBootStatus = BsdLastBootNotShutdown;
    }

    //
    // Now disable auto safemode actions if requested.
    //

    if(aabEnabled == FALSE) {
        advancedBootMode = (ULONG)-1;
    }

    return advancedBootMode;
}

VOID
BlWriteBootStatusFlags(
    IN ULONG SystemPartitionId,
    IN PUCHAR SystemDirectory,
    IN BOOLEAN LastBootSucceeded, 
    IN BOOLEAN LastBootShutdown
    )
{
    PVOID dataHandle;

    ARC_STATUS status;

    status = BlLockBootStatusData(SystemPartitionId,
                                  NULL,
                                  (PCHAR)SystemDirectory,
                                  &dataHandle);

    if(status == ESUCCESS) {

        BlGetSetBootStatusData(dataHandle,
                               FALSE,
                               RtlBsdItemBootGood,
                               &LastBootSucceeded,
                               sizeof(UCHAR),
                               NULL);
    
        BlGetSetBootStatusData(dataHandle,
                               FALSE,
                               RtlBsdItemBootShutdown,
                               &LastBootShutdown,
                               sizeof(UCHAR),
                               NULL);

        BlUnlockBootStatusData(dataHandle);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\regboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regboot.c

Abstract:

    Provides a minimal registry implementation designed to be used by the
    osloader at boot time.  This includes loading the system hive
    ( <SystemRoot>\config\SYSTEM ) into memory, and computing the driver
    load list from it.

Author:

    John Vert  (jvert)  10-Mar-1992

Revision History:

    Doug Fritz (dFritz) 07-Oct-1997 & KenRay Feb 98

      - Filter hardware profiles based on detected hardware
        configuration (docking station) information

--*/
#include "bldr.h"
#include "msg.h"
#include "cmp.h"
#include "stdio.h"
#include "string.h"
#include <dockinfo.h>
#include <netboot.h>

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#ifdef _WANT_MACHINE_IDENTIFICATION
#include <stdlib.h>
#include <ntverp.h>
#endif

#include "bldrint.h"
#include "vmode.h"


#define MAX_DRIVER_NAME_LENGTH 64

CMHIVE BootHive;
ULONG CmLogLevel=100;
ULONG CmLogSelect=0;

ULONG ScreenWidth=80;
#ifdef EFI 
ULONG ScreenHeight=24;
#else
ULONG ScreenHeight=25;
#endif

ULONG LkgStartTime;

//
// used by the advanced boot screen to force a LKG boot
//
BOOLEAN ForceLastKnownGood;

//
// Variable used to check whether to display
// "Return to OS Choices Menu" or not in adv. boot
//
BOOLEAN BlShowReturnToOSChoices = TRUE;


VOID
BlRedrawProgressBar(
    VOID
    );

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    );

ULONG
BlGetAdvancedBootID(
    LONG BootOption
    );

//
// Private function prototypes
//

BOOLEAN
BlInitializeHive(
    IN PVOID HiveImage,
    IN PCMHIVE Hive,
    IN BOOLEAN IsAlternate
    );

BOOLEAN
BlpCheckRestartSetup(
    VOID
    );

PVOID
BlpHiveAllocate(
    IN ULONG Length,
    IN BOOLEAN UseForIo,
    ULONG   Tag
    );

VOID
BlDockInfoFilterProfileList(
    IN OUT PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ALIAS_LIST  AliasList
);


VOID
BlStartConfigPrompt(
    VOID
    )

/*++

Routine Description:

    This routine displays the LKG prompt, records the current time,
    and returns. The prompt is displayed before the kernel and HAL
    are loaded, and then removed afterwards.

Arguments:

    None.

Return Value:

    None.

--*/

{
    // ULONG Count;
    PTCHAR LkgPrompt;

    LkgPrompt = BlFindMessage(BL_LKG_MENU_PROMPT);
    if (LkgPrompt==NULL) {
        return;
    }
    //
    // display LKG prompt
    //
#if 0
    BlPositionCursor(1,3);
    ArcWrite(BlConsoleOutDeviceId,
             LkgPrompt,
             _tcslen(LkgPrompt)*sizeof(TCHAR),
             &Count);
    BlPositionCursor(1,2);
#endif
    LkgStartTime = ArcGetRelativeTime();

#if defined(REMOTE_BOOT) && defined(i386)
    //
    //  Wait to allow the user to type space or F8. If anything is typed then behave
    //  conservatively and load the kernel, etc., from the server just in case CSC or
    //  the local filesystem is broken.
    //
    if (BlBootingFromNet) {

        ULONG EndTime;
        ULONG Status;
        ULONG CurrentTime;

        EndTime = LkgStartTime + 3;
        if (EndTime <= ArcGetRelativeTime()) {
            EndTime = ArcGetRelativeTime()+1;
        }

        do {
            if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {

                //
                //  There is a key pending, assume it is CSC related. If it isn't
                //  CSC then it just means we laod a few extra files from the
                //  server. 
                //

                NetBootCSC = FALSE;
                break;

            }

            CurrentTime = ArcGetRelativeTime();

            //
            // Terminate the loop if the EndTime has been reached, or
            // if the CurrentTime has wrapped at midnight.
            //
        } while ((CurrentTime < EndTime) &&
                 (CurrentTime >= LkgStartTime));
    }
#endif // defined(REMOTE_BOOT) && defined(i386)

}


BOOLEAN
BlEndConfigPrompt(
    VOID
    )

/*++

Routine Description:

    This routine waits until the LKG timeout has expired or the
    user presses a key and then removes the LKG prompt.

Arguments:

    None.

Return Value:

    TRUE - Space bar pressed.

    FALSE - Space bar was not pressed.

--*/
{
    ULONG   EndTime;
    ULONG   Key;
    ULONG   CurrentTime;
#if defined(EFI)
    ULONGLONG OriginalInputTimeout;
#endif

    //
    // We do not wait for a keypress if there is not already one.
    //
    EndTime = 0;

    if( BlIsTerminalConnected() ) {
        //
        // If we're booting headless, give the user lots of time
        // to press any of the advanced options keys.
        //
        EndTime = ArcGetRelativeTime() + 5;
    }

#if defined(EFI)
    //
    // on certain machines the boot manager will
    // reset ConIn and the usb keyboard is still
    // reinitialize when we get here.  add a short
    // timeout period to BlGetKey() that will 
    // give the necessary time required for 
    // for interface to behave properly.
    //
    OriginalInputTimeout = BlGetInputTimeout();
    if (EndTime) {
        BlSetInputTimeout(50000000); // 5 seconds
    }
    else {
        BlSetInputTimeout(10000000); // 1 second
    }
#endif

#if defined(REMOTE_BOOT) && defined(i386)
    //
    //  If a key was detected and CSC turned off then re-enable CSC until
    //  we find out if it should be disabled for this whole boot.
    //

    NetBootCSC = TRUE;
#endif // defined(REMOTE_BOOT) && defined(i386)

    do {
        LONG        AdvancedBoot = -1;
        BOOLEAN     bOldState = BlShowReturnToOSChoices;
        
        if ((Key = BlGetKey()) != 0) {
            
            //
            // return if the pending key was the spacebar.
            //
            if (Key == ' ') {
#if defined(EFI)
                BlSetInputTimeout(OriginalInputTimeout); 
#endif
                return(TRUE);
            }
            
            //
            // look to see if the user pressed the F5 or F8 keys,
            // these keys trigger the advanced boot menu.  the advanced
            // boot menu can also be entered from the main boot menu by
            // pressing the same keys.
            //
            if (Key == F5_KEY || Key == F8_KEY) {
                //
                // present the menu and get the user's request
                //
                BlShowReturnToOSChoices = FALSE;

                if (DisplayLogoOnBoot) {
                    if (!DbcsLangId)
                        HW_CURSOR(0x80000000,0x3);
                    else
                        HW_CURSOR(0x80000000,0x12);
                }
                
                AdvancedBoot = BlDoAdvancedBoot( BL_ADVANCEDBOOT_TITLE, 0, FALSE, 0 );

                if (DisplayLogoOnBoot) {

                    PSTR BootOption;

                    if ((AdvancedBoot != -1) &&
                        ((BootOption = BlGetAdvancedBootLoadOptions(AdvancedBoot)) != NULL ) &&
                        (!strncmp("SAFEBOOT",BootOption,8))) {
                            DisplayLogoOnBoot = FALSE;    // on safe boot let the "Checking file system" message
                                                          // appear as it appears today (in graphics mode)
                    } else {
#ifndef EFI
                        HW_CURSOR(0x80000000,0x12);
                        if (DbcsLangId)

                            TextClearDisplay();
                        VgaEnableVideo();
                        PaletteOn();
                        DrawBitmap ();
                        BlUpdateBootStatus();
#endif
                    }
                }

                BlShowReturnToOSChoices = bOldState;

                if (AdvancedBoot != -1) {
                    //
                    // they chose a valid boot option so append
                    // any os load options and perform any necessary
                    // option processing.
                    //
                    PSTR NewOptions = BlGetAdvancedBootLoadOptions(AdvancedBoot);

                    if( BlGetAdvancedBootID(AdvancedBoot) == BL_MSG_REBOOT ) {
                        BlClearScreen(); 
                        ArcReboot();
                    }


                    if (NewOptions != NULL && strstr(BlLoaderBlock->LoadOptions,NewOptions) == NULL) {
                        ULONG len = (ULONG)strlen(NewOptions) +                 // new options
                                    1 +                                         // seperated by a space                 
                                    (ULONG)strlen(BlLoaderBlock->LoadOptions) + // old options
                                    1;                                          // null terminator
                        NewOptions = BlAllocateHeap(len * sizeof(UCHAR));
                        strcpy(NewOptions,BlLoaderBlock->LoadOptions);
                        strcat(NewOptions," ");
                        strcat(NewOptions,BlGetAdvancedBootLoadOptions(AdvancedBoot));
                        BlLoaderBlock->LoadOptions = NewOptions;

                        DBGTRACE(TEXT("Load Options = %S"), BlLoaderBlock->LoadOptions);
                    }

                    BlDoAdvancedBootLoadProcessing(AdvancedBoot);
                }
            }                            
        }

        CurrentTime = ArcGetRelativeTime();

        //
        // Terminate the loop if the EndTime has been reached, or
        // if the CurrentTime has wrapped at midnight.
        //
    } while ((CurrentTime < EndTime) &&
             (CurrentTime >= LkgStartTime));

#if defined(EFI)
    BlSetInputTimeout(OriginalInputTimeout); 
#endif

    //
    // make LKG prompt go away, so as not to startle the user.
    // remote the trailer & update progress bar
    //
#if defined(_IA64_)
    BlOutputStartupMsg(BL_MSG_STARTING_WINDOWS);
#endif
    BlRedrawProgressBar();

    return(FALSE);
}


VOID
BlpSwitchControlSet(
    OUT PCM_HARDWARE_PROFILE_LIST *ProfileList,
    OUT PCM_HARDWARE_PROFILE_ALIAS_LIST *AliasList,
    IN BOOLEAN UseLastKnownGood,
    OUT PHCELL_INDEX ControlSet
    )

/*++

Routine Description:

    Switches the current control set to the specified control
    set and rebuilds the hardware profile list.

Arguments:

    ProfileList - Returns the new hardware profile list

    UseLastKnownGood - Supplies whether the LKG control set is to be used.

    ControlSet - Returns the HCELL_INDEX of the new control set.

Return Value:

    None.

--*/

{
    UNICODE_STRING ControlName;
    HCELL_INDEX NewControlSet;
    BOOLEAN AutoSelect;         // ignored

    //
    // Find the new control set.
    //
    if (UseLastKnownGood) {
        RtlInitUnicodeString(&ControlName, L"LastKnownGood");
    } else {
        RtlInitUnicodeString(&ControlName, L"Default");
    }
    NewControlSet = CmpFindControlSet(&BootHive.Hive,
                                      BootHive.Hive.BaseBlock->RootCell,
                                      &ControlName,
                                      &AutoSelect);
    if (NewControlSet == HCELL_NIL) {
        return;
    }

    CmpFindProfileOption(&BootHive.Hive,
                         NewControlSet,
                         ProfileList,
                         AliasList,
                         NULL);
    *ControlSet = NewControlSet;
}


ULONG
BlCountLines(
    IN PTCHAR Lines
    )

/*++

Routine Description:

    Counts the number of lines in the given string.

Arguments:

    Lines - Supplies a pointer to the start of the string

Return Value:

    The number of lines in the string.

--*/

{
    PTCHAR p;
    ULONG NumLines = 0;

    p=Lines;
    while (*p != TEXT('\0')) {
        if ((*p == TEXT('\r')) && (*(p+1) == TEXT('\n'))) {
            ++NumLines;
            ++p;            // move forward to \n
        }
        ++p;
    }
    return(NumLines);
}


BOOLEAN
BlConfigMenuPrompt(
    IN ULONG Timeout,
    IN OUT PBOOLEAN UseLastKnownGood,
    IN OUT PHCELL_INDEX ControlSet,
    OUT PCM_HARDWARE_PROFILE_LIST *ProfileList,
    OUT PCM_HARDWARE_PROFILE_ALIAS_LIST *AliasList,
    OUT PCM_HARDWARE_PROFILE *HardwareProfile
    )

/*++

Routine Description:

    This routine provides the user-interface for the configuration menu.
    The prompt is given if the user hits the break-in key, or if the
    LastKnownGood environment variable is TRUE and AutoSelect is FALSE, or
    if the timeout value on the hardware profile configuration is non-zero

Arguments:

    Timeout - Supplies the timeout value for the menu. -1 or 0 implies the menu
              will never timeout.

    UseLastKnownGood - Returns the LastKnownGood setting that should be
        used for the boot.

    ControlSet - Returns the control set (either Default or LKG)

    ProfileList - Supplies the default list of profiles.
                  Returns the current list of profiles.
                  (may change due to switching to/from the LKG controlset)

    HardwareProfile - Returns the hardware profile that should be used.

Return Value:

    TRUE - Boot should proceed.

    FALSE - The user has chosen to return to the firmware menu/flexboot menu.

--*/

{
    ULONG HeaderLines;
    ULONG TrailerLines;
    ULONG i;
    ULONG Count;
    ULONG flags;
    ULONG Key;
    PTCHAR MenuHeader;
    PTCHAR MenuTrailer1;
    PTCHAR MenuTrailer2;
    PTCHAR p;
#ifndef UNICODE
    ULONG OptionLength;
#endif
    TCHAR MenuOption[80];
    PCM_HARDWARE_PROFILE Profile;
    ULONG ProfileCount;
    _TUCHAR LkgMnemonic;
    _TUCHAR DefaultMnemonic;
    PTCHAR Temp;
    ULONG DisplayLines;
    ULONG TopProfileLine=0;
    ULONG CurrentSelection = 0;
    ULONG CurrentProfile;
    ULONG EndTime = 0;
    ULONG CurrentTime = 0;
    PTCHAR TimeoutPrompt;

    UNREFERENCED_PARAMETER( HardwareProfile );

    if ((Timeout != (ULONG)-1) && (Timeout != 0)) {
        CurrentTime = ArcGetRelativeTime();
        EndTime = CurrentTime + Timeout;
        TimeoutPrompt = BlFindMessage(BL_LKG_TIMEOUT);

        if (TimeoutPrompt != NULL) {

            p=_tcschr(TimeoutPrompt, TEXT('\n'));
            if (p) {
                *p = TEXT('\0');
            }
            p=_tcschr(TimeoutPrompt, TEXT('\r'));
            if (p) {
                *p = TEXT('\0');
            }

        }

    } else {

        TimeoutPrompt = NULL;

    }

    MenuHeader = BlFindMessage(BL_LKG_MENU_HEADER);
    Temp = BlFindMessage(BL_LKG_SELECT_MNEMONIC);
    if (Temp == NULL) {
        return(TRUE);
    }
    LkgMnemonic = (_TUCHAR)_totupper(Temp[0]);
    Temp = BlFindMessage(BL_DEFAULT_SELECT_MNEMONIC);
    if (Temp == NULL) {
        return(TRUE);
    }
    DefaultMnemonic = (_TUCHAR)_totupper(Temp[0]);

    if ((*UseLastKnownGood) &&
        (*ProfileList) && ((*ProfileList)->CurrentProfileCount == 1)) {

        //
        // The user selected last known good via boot.ini/nvram/etc. Since this
        // was a concious decision, and we don't have more than one profile to
        // choose, just skip this UI altogether.
        //
        ASSERT(CurrentSelection == 0);
        return TRUE;
    }

Restart:

    if (*ProfileList == NULL) {
        ProfileCount = 0;
    } else {
        ProfileCount = (*ProfileList)->CurrentProfileCount;
    }
    if (ProfileCount == 0) {
        MenuTrailer1 = BlFindMessage(BL_LKG_MENU_TRAILER_NO_PROFILES);
    } else {
        MenuTrailer1 = BlFindMessage(BL_LKG_MENU_TRAILER);
    }
    if (*UseLastKnownGood) {
        MenuTrailer2 = BlFindMessage(BL_SWITCH_DEFAULT_TRAILER);
    } else {
        MenuTrailer2 = BlFindMessage(BL_SWITCH_LKG_TRAILER);
    }
    if ((MenuHeader==NULL) || (MenuTrailer1==NULL) || (MenuTrailer2==NULL)) {
        return(TRUE);
    }

    //
    // strip trailing /r/n from MenuTrailer2 to prevent it from scrolling
    // the screen when we output it.
    //
#if 0
    p=MenuTrailer2 + strlen(MenuTrailer2) - 1;
    while ((*p == TEXT('\r')) || (*p == TEXT('\n'))) {
        *p = TEXT('\0');
        --p;
    }
#endif
    BlClearScreen();
#ifdef EFI
    BlEfiSetAttribute( DEFATT );
#else
    BlSetInverseMode(FALSE);
#endif

    //
    // Count the number of lines in the header.
    //
    HeaderLines=BlCountLines(MenuHeader);

    //
    // Display the menu header.
    //

    ArcWrite(BlConsoleOutDeviceId,
             MenuHeader,
             (ULONG)_tcslen(MenuHeader)*sizeof(TCHAR),
             &Count);

    //
    // Count the number of lines in the trailer.
    //
    TrailerLines=BlCountLines(MenuTrailer1) + BlCountLines(MenuTrailer2);

    //
    // Display the trailing prompt.
    //
    if (TimeoutPrompt) {
        TrailerLines += 1;
    }

    BlPositionCursor(1, ScreenHeight-TrailerLines);
    ArcWrite(BlConsoleOutDeviceId,
             MenuTrailer1,
             (ULONG)_tcslen(MenuTrailer1)*sizeof(TCHAR),
             &Count);
    ArcWrite(BlConsoleOutDeviceId,
             MenuTrailer2,
             (ULONG)_tcslen(MenuTrailer2)*sizeof(TCHAR),
             &Count);

    //
    // Compute number of selections that can be displayed
    //
    DisplayLines = ScreenHeight-HeaderLines-TrailerLines-3;
    if (ProfileCount < DisplayLines) {
        DisplayLines = ProfileCount;
    }

    //
    // Start menu selection loop.
    //

    do {
        if (ProfileCount > 0) {
            //
            // Display options with current selection highlighted
            //
            for (i=0; i < DisplayLines; i++) {
                CurrentProfile = i+TopProfileLine;
                Profile = &(*ProfileList)->Profile[CurrentProfile];
                BlPositionCursor(5, HeaderLines+i+2);
#ifdef EFI
                BlEfiSetAttribute( (CurrentProfile == CurrentSelection) ? INVATT : DEFATT );
#else
                BlSetInverseMode((BOOLEAN)(CurrentProfile == CurrentSelection));
#endif
#ifdef UNICODE
                ArcWrite(BlConsoleOutDeviceId,
                         Profile->FriendlyName,
                         Profile->NameLength,
                         &Count );                                
#else
                RtlUnicodeToMultiByteN(MenuOption,
                                 sizeof(MenuOption),
                                 &OptionLength,
                                 Profile->FriendlyName,
                                 Profile->NameLength);                
                ArcWrite(BlConsoleOutDeviceId,
                         MenuOption,
                         OptionLength,
                         &Count);
#endif
#ifdef EFI
                BlEfiSetAttribute( DEFATT );
#else
                BlSetInverseMode(FALSE);
#endif
                BlClearToEndOfLine();
            }

        } else {
            //
            // No profile options available, just display the default
            // highlighted to indicate that ENTER will start the system.
            //
            Temp = BlFindMessage(BL_BOOT_DEFAULT_PROMPT);
            if (Temp != NULL) {
                BlPositionCursor(5, HeaderLines+3);
#ifdef EFI
                BlEfiSetAttribute( INVATT );
#else
                BlSetInverseMode(TRUE);
#endif                
                ArcWrite(BlConsoleOutDeviceId,
                         Temp,
                         (ULONG)_tcslen(Temp)*sizeof(TCHAR),
                         &Count);
#ifdef EFI
                BlEfiSetAttribute( INVATT );
#else
                BlSetInverseMode(TRUE);
#endif                
            }
        }
        if (TimeoutPrompt) {
            CurrentTime = ArcGetRelativeTime();
            _stprintf(MenuOption, TimeoutPrompt, EndTime-CurrentTime);
            BlPositionCursor(1, ScreenHeight);
            ArcWrite(BlConsoleOutDeviceId,
                     MenuOption,
                     (ULONG)_tcslen(MenuOption)*sizeof(TCHAR),
                     &Count);
            BlClearToEndOfLine();
        }

        //
        // Loop waiting for keypress or time change.
        //
        do {
            if ((Key = BlGetKey()) != 0) {
                TimeoutPrompt = NULL;               // turn off timeout prompt
                BlPositionCursor(1,ScreenHeight);
                BlClearToEndOfLine();
                break;            
            }

            if (TimeoutPrompt) {
                if (ArcGetRelativeTime() != CurrentTime) {
                    //
                    // Time has changed, update the countdown and check for timeout
                    //

                    CurrentTime = ArcGetRelativeTime();
                    _stprintf(MenuOption, TimeoutPrompt, EndTime-CurrentTime);
                    BlPositionCursor(1, ScreenHeight);
                    ArcWrite(BlConsoleOutDeviceId,
                             MenuOption,
                             (ULONG)_tcslen(MenuOption)*sizeof(TCHAR),
                             &Count);
                    BlClearToEndOfLine();
                    if (EndTime == CurrentTime) {
                        goto ProcessSelection;
                    }
                }
            }

        } while ( TRUE );        

        switch (Key) {
        case UP_ARROW:
            //
            // Cursor up
            //
            if (ProfileCount > 0) {
                if (CurrentSelection==0) {
                    CurrentSelection = ProfileCount - 1;
                    if (TopProfileLine + DisplayLines <= CurrentSelection) {
                        TopProfileLine = CurrentSelection - DisplayLines + 1;
                    }
                } else {
                    if (--CurrentSelection < TopProfileLine) {
                        //
                        // Scroll up
                        //
                        TopProfileLine = CurrentSelection;
                    }
                }

            }

            break;

        case DOWN_ARROW:
            //
            // Cursor down
            //
            if (ProfileCount > 0) {
                CurrentSelection = (CurrentSelection+1) % ProfileCount;
                if (CurrentSelection == 0) {
                    TopProfileLine = 0;
                } else if (TopProfileLine + DisplayLines <= CurrentSelection) {
                    TopProfileLine = CurrentSelection - DisplayLines + 1;
                }
            }
            break;

        case F3_KEY:
            //
            // F3
            //
            *ControlSet = HCELL_NIL;                                
            return(FALSE);


        default:
            //
            // Check to see if the Key indicates the user selection LKG
            //  first, we have to make sure we are looking at an alpha char.
            //
            if ( ((Key >> 8) == 0) && _istalpha((TCHAR)Key) ) {
            
                if ((_totupper((TCHAR)Key) == LkgMnemonic) && (*UseLastKnownGood == FALSE)) {
                    *UseLastKnownGood = TRUE;
                    BlpSwitchControlSet(ProfileList,
                                        AliasList,
                                        TRUE,
                                        ControlSet);

                    if (NULL != *ProfileList) {
                        if ((*ProfileList)->CurrentProfileCount > 0) {
                            BlDockInfoFilterProfileList (*ProfileList, *AliasList);
                        }
                    }

                    goto Restart;
                    //
                    // regenerate profile list here
                    //
                } else if ((_totupper((TCHAR)Key) == DefaultMnemonic) && (*UseLastKnownGood)) {
                    *UseLastKnownGood = FALSE;
                    BlpSwitchControlSet(ProfileList,
                                        AliasList,
                                        FALSE,
                                        ControlSet);

                    if (NULL != *ProfileList) {
                        if ((*ProfileList)->CurrentProfileCount > 0) {
                            BlDockInfoFilterProfileList (*ProfileList, *AliasList);
                        }
                    }

                    goto Restart;
                }
            
            }
            break;
        
        } // switch

    } while ( (Key != ASCII_CR) && (Key != ASCII_LF) );

ProcessSelection:

    if (ProfileCount > 0) {

        if (HW_PROFILE_STATUS_SUCCESS == BlLoaderBlock->Extension->Profile.Status) {

            flags = ((*ProfileList)->Profile[CurrentSelection].Flags);

            if (flags & CM_HP_FLAGS_PRISTINE) {
                BlLoaderBlock->Extension->Profile.Status =
                    HW_PROFILE_STATUS_PRISTINE_MATCH;

            } else if (flags & CM_HP_FLAGS_TRUE_MATCH) {
                BlLoaderBlock->Extension->Profile.Status =
                    HW_PROFILE_STATUS_TRUE_MATCH;

            } else if (flags & CM_HP_FLAGS_ALIASABLE) {
                BlLoaderBlock->Extension->Profile.Status =
                    HW_PROFILE_STATUS_ALIAS_MATCH;
            }
        }

        CmpSetCurrentProfile(&BootHive.Hive,
                             *ControlSet,
                             &(*ProfileList)->Profile[CurrentSelection]);
    }

    return(TRUE);
}


ARC_STATUS
BlLoadBootDrivers(
    IN  PPATH_SET   DefaultPathSet,
    IN  PLIST_ENTRY BootDriverListHead,
    OUT PCHAR       BadFileName
    )

/*++

Routine Description:

    Walks the boot driver list and loads all the drivers

Arguments:

    DefaultPathSet - Describes the possible locations drivers could be loaded
        from.

    BootDriverListHead - Supplies the head of the boot driver list

    BadFileName - Returns the filename of the critical driver that
        did not load.  Not valid if ESUCCESS is returned.

Return Value:

    ESUCCESS is returned if all the boot drivers were successfully loaded.
        Otherwise, an unsuccessful status is returned.
--*/

{
    ULONG DeviceId = 0;
    PBOOT_DRIVER_NODE DriverNode;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    PLIST_ENTRY NextEntry;
    CHAR DriverName[MAX_DRIVER_NAME_LENGTH];
    PCHAR NameStart;
    CHAR DriverDevice[128];
    CHAR DriverPath[128];
    ARC_STATUS Status;
    UNICODE_STRING DeviceName;
    UNICODE_STRING FileName;
    WCHAR SystemRootBuffer[] = L"\\SystemRoot\\";
    ULONG SystemRootLength;
    PWSTR p;
    ULONG Index;
    BOOLEAN AbsolutePath;
    FULL_PATH_SET LocalPathSet;
    PPATH_SOURCE PathSource;

    SystemRootLength = (ULONG)wcslen(SystemRootBuffer);

    NextEntry = BootDriverListHead->Flink;
    while (NextEntry != BootDriverListHead) {
        DriverNode = CONTAINING_RECORD(NextEntry,
                                       BOOT_DRIVER_NODE,
                                       ListEntry.Link);

        Status = ESUCCESS;

        DriverEntry = &DriverNode->ListEntry;

        if (DriverEntry->FilePath.Buffer[0] != L'\\') {

            //
            // This is a relative pathname, so generate the full pathname
            // relative to the boot partition.
            //
            sprintf(DriverPath, "%wZ", &DriverEntry->FilePath);
            AbsolutePath = FALSE;

        } else if (memcmp(DriverEntry->FilePath.Buffer,
                          SystemRootBuffer,
                          (SystemRootLength * sizeof(WCHAR))) == 0) {

            //
            // This is a pathname starting with "\SystemRoot\", so just ignore
            // that part and treat like the previous case.
            //
            FileName.Buffer = DriverEntry->FilePath.Buffer + SystemRootLength;
            FileName.Length = (USHORT)(DriverEntry->FilePath.Length - (SystemRootLength * sizeof(WCHAR)));

            sprintf(DriverPath, "%wZ", &FileName);
            AbsolutePath = FALSE;

        } else {

            //
            // This is an absolute pathname, of the form
            //    "\ArcDeviceName\dir\subdir\filename"
            //
            // We need to open the specified ARC device and pass that
            // to BlLoadDeviceDriver.
            //

            p = DeviceName.Buffer = DriverEntry->FilePath.Buffer+1;
            DeviceName.Length = 0;
            DeviceName.MaximumLength = DriverEntry->FilePath.MaximumLength-sizeof(WCHAR);

            while ((*p != L'\\') &&
                   (DeviceName.Length < DeviceName.MaximumLength)) {

                ++p;
                DeviceName.Length += sizeof(WCHAR);

            }

            DeviceName.MaximumLength = DeviceName.Length;
            sprintf(DriverDevice, "%wZ", &DeviceName);

            Status = ArcOpen(DriverDevice,ArcOpenReadOnly,&DeviceId);

            FileName.Buffer = p+1;
            FileName.Length = DriverEntry->FilePath.Length - DeviceName.Length - 2*sizeof(WCHAR);
            FileName.MaximumLength = FileName.Length;

            //
            // Device successfully opened, parse out the path and filename.
            //
            sprintf(DriverPath, "%wZ", &FileName);
            AbsolutePath = TRUE;
        }

        //
        // Parse out the driver name from the driver path
        //
        NameStart = strrchr(DriverPath, '\\');
        if (NameStart != NULL) {
            strncpy(DriverName, NameStart+1, MAX_DRIVER_NAME_LENGTH - 1);
            DriverName[MAX_DRIVER_NAME_LENGTH - 1] = '\0';
            *NameStart = '\0';

        } else if (DriverPath[0]) {

            strncpy(DriverName, DriverPath, MAX_DRIVER_NAME_LENGTH - 1);
            DriverName[MAX_DRIVER_NAME_LENGTH - 1] = '\0';
            *DriverPath = '\0';

        } else {

            NextEntry = DriverEntry->Link.Flink;
            continue;
        }

        //
        // Ensure DriverPath is terminated with a '\\' if it's filled out.
        //
        if (DriverPath[0]) {

            strcat(DriverPath, "\\");
        }

        if (AbsolutePath) {

            //
            // There is only one entry if an absolute path is specified (in
            // this case we cannot do last known good).
            //
            PathSource = &LocalPathSet.Source[0];
            PathSource->DeviceId = DeviceId;
            PathSource->DeviceName = DriverDevice;
            PathSource->DirectoryPath = "\\";

            LocalPathSet.PathCount = 1;
            LocalPathSet.AliasName = NULL;
            strcpy(LocalPathSet.PathOffset, DriverPath);

        } else {

            //
            // It's relative. Copy over the DefaultPathSet array so we can
            // edit our own local copy.
            //
            *((PSPARSE_PATH_SET) &LocalPathSet) = *((PSPARSE_PATH_SET) DefaultPathSet);

            for(Index=0; Index < DefaultPathSet->PathCount; Index++) {

                LocalPathSet.Source[Index] = DefaultPathSet->Source[Index];
            }

            //
            // Now append our relative path to the PathOffset already present
            // in our local copy.
            //
            strcat(LocalPathSet.PathOffset, DriverPath);
        }

        if (Status == ESUCCESS) {
            Status = BlLoadDeviceDriver(&LocalPathSet,
                                        DriverName,
                                        NULL,
                                        LDRP_ENTRY_PROCESSED,
                                        &DriverEntry->LdrEntry);
        }

        NextEntry = DriverEntry->Link.Flink;

        if (Status != ESUCCESS) {

            //
            // Attempt to load driver failed, remove it from the list.
            //
            RemoveEntryList(&DriverEntry->Link);

            //
            // Check the Error Control of the failed driver.  If it
            // was critical, fail the boot.  If the driver
            // wasn't critical, keep going.
            //
            if (DriverNode->ErrorControl == CriticalError) {

                strcpy(BadFileName, DriverPath);
                strcat(BadFileName, DriverName);
                return(Status);
            }

        }
    }

    return(ESUCCESS);

}

BOOLEAN
BlRecoverHive(
              PVOID         RegistryBase,
              ULONG_PTR     LogBase
              )
/*++

Routine Description:

    Applies log from LogBase over the RegistryBase

Arguments:


Return Value:

    ESUCCESS is returned if the system hive was successfully loaded.
        Otherwise, an unsuccessful status is returned.

--*/
{
    PHBASE_BLOCK    BaseBlockHive;
    PHBASE_BLOCK    BaseBlockLog;
    ULONG           FileOffset = HSECTOR_SIZE;
    ULONG           DirtyVectorSignature = 0;
    PUCHAR          FlatLog;
    PUCHAR          FlatReg;
    ULONG           VectorSize;
    ULONG           Length;
    ULONG           ClusterSize;
    ULONG           HeaderLength;
    RTL_BITMAP      BitMap;
    PULONG          Vector;
    ULONG           Current;
    ULONG           Start;
    ULONG           End;
    PUCHAR          MemoryBlock;
    PUCHAR          Dest;
    ULONG           i;


    BaseBlockHive = (PHBASE_BLOCK)RegistryBase;
    BaseBlockLog = (PHBASE_BLOCK)LogBase;

    FlatLog = (PUCHAR)LogBase;
    FlatReg = (PUCHAR)RegistryBase;
    ClusterSize = BaseBlockLog->Cluster * HSECTOR_SIZE;
    HeaderLength = ROUND_UP(HLOG_HEADER_SIZE, ClusterSize);
    FileOffset = ClusterSize;
    FileOffset = ROUND_UP(FileOffset, HeaderLength);

    if(HvpHeaderCheckSum(BaseBlockHive) != BaseBlockHive->CheckSum ) {
        //
        // recover header case
        //
        RtlCopyMemory((PVOID)BaseBlockHive,(PVOID)BaseBlockLog,ClusterSize);
        BaseBlockHive->Type = HFILE_TYPE_PRIMARY;
    } else {
        //
        // if not recoverheader (which implies recoverdata)
        //
        ASSERT( BaseBlockHive->Sequence1 != BaseBlockHive->Sequence2 );
    }

    DirtyVectorSignature = *((PULONG)(FlatLog + FileOffset));
    FileOffset += sizeof(DirtyVectorSignature);

    if (DirtyVectorSignature != HLOG_DV_SIGNATURE) {
        return FALSE;
    }

    Length = BaseBlockHive->Length;
    VectorSize = Length / HSECTOR_SIZE;
    Vector = (PULONG)(FlatLog + FileOffset);

    RtlInitializeBitMap(&BitMap, Vector, VectorSize);

    FileOffset += VectorSize / 8;
    FileOffset = ROUND_UP(FileOffset, ClusterSize);

    //
    // step through the diry map, and copy from the log to the flat hive
    //
    Current = 0;

    while (Current < VectorSize) {

        //
        // find next contiguous block of entries to read in
        //
        for (i = Current; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 1) {
                break;
            }
        }
        Start = i;

        for ( ; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 0) {
                break;
            }
        }
        End = i;
        Current = End;

        //
        // Start == number of 1st sector, End == number of Last sector + 1
        //
        Length = (End - Start) * HSECTOR_SIZE;

        if( 0 == Length ) {
            // no more dirty blocks.
            break;
        }
        MemoryBlock = (PUCHAR)(FlatLog + FileOffset);
        FileOffset += Length;

        ASSERT((FileOffset % ClusterSize) == 0);

        Dest = (PUCHAR)(FlatReg + HBLOCK_SIZE + Start * HSECTOR_SIZE);

        //
        // copy recovered data in the right locations inside the flat hive image
        //
        RtlCopyMemory(Dest,MemoryBlock, Length);
    }

    BaseBlockHive->Sequence2 = BaseBlockHive->Sequence1;
    BaseBlockHive->CheckSum = HvpHeaderCheckSum(BaseBlockHive);
    return TRUE;
}

ARC_STATUS
BlLoadAndInitSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName,
    IN BOOLEAN IsAlternate,
    OUT PBOOLEAN RestartSetup,
    OUT PBOOLEAN LogPresent
    )

/*++

Routine Description:

    Loads the registry SYSTEM hive, verifies it is a valid hive file,
    and inits the relevant registry structures.  (particularly the HHIVE)

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT tree.

    HiveName - Supplies the name of the system hive (ie, "SYSTEM",
        "SYSTEM.ALT", or "SYSTEM.SAV").

    IsAlternate - Supplies whether or not the hive to be loaded is the
        alternate hive.

    RestartSetup - if the hive to be loaded is not the alternate, then
        this routine will check for a value of RestartSetup in the Setup
        key. If present and non-0, then this variable receives TRUE.
        Otherwise it receives FALSE.

Return Value:

    ESUCCESS is returned if the system hive was successfully loaded.
        Otherwise, an unsuccessful status is returned.

--*/

{
    ARC_STATUS  Status;
    ULONG_PTR   LogData;

    *RestartSetup = FALSE;
    *LogPresent = FALSE;

    BlClearToEndOfLine();

    Status = BlLoadSystemHive(DeviceId,
                              DeviceName,
                              DirectoryPath,
                              HiveName);
    if (Status!=ESUCCESS) {
        return(Status);
    }

    if (!BlInitializeHive(BlLoaderBlock->RegistryBase,
                          &BootHive,
                          IsAlternate)) {
        if( !IsAlternate ) {
            //
            // try to recover the hive
            //
            Status = BlLoadSystemHiveLog(DeviceId,
                                    DeviceName,
                                    DirectoryPath,
                                    "system.log",
                                    &LogData );
            if (Status!=ESUCCESS) {
                return(Status);
            }

            *LogPresent = TRUE;

            if( !BlRecoverHive( BlLoaderBlock->RegistryBase,
                                LogData ) ) {
                BlFreeDescriptor( (ULONG)((ULONG_PTR)LogData & (~KSEG0_BASE)) >> PAGE_SHIFT );
                return(EINVAL);
            }
            BlFreeDescriptor( (ULONG)((ULONG_PTR)LogData & (~KSEG0_BASE)) >> PAGE_SHIFT );

            //
            // we successfully recovered. Try setting up the hive again
            //
            if (!BlInitializeHive(BlLoaderBlock->RegistryBase,
                                  &BootHive,
                                  IsAlternate)) {
                return(EINVAL);
            }
            //
            // mark the hive as "recovered"
            //
            BootHive.Hive.BaseBlock->BootRecover = 1;
        } else {
            return(EINVAL);
        }
    } else {
        //
        // mark the hive as "no-recovered"
        //
        BootHive.Hive.BaseBlock->BootRecover = 0;
    }
    //
    // See whether we need to switch to the backup setup hive.
    //
    *RestartSetup = BlpCheckRestartSetup();

    return(ESUCCESS);
}

HCELL_INDEX
BlpDetermineControlSet(
    IN OUT BOOLEAN *LastKnownGoodBoot
    )

/*++

Routine Description:

    Determines the appropriate control set and static hardware profile.
    This routine ends the configuration prompt. If the user has hit a
    key, the configuration menu is displayed. If the user has not hit
    a key, but the default controlset specifies a non-zero timeout for
    the configuration menu, the configuration menu is displayed.

    If the configuration menu is displayed, further modifications to the
    control set and hardware profile can be made by the user. If not,
    the default hardware profile is selected.

Arguments:

    LastKnownGoodBoot - On input, LastKnownGood indicates whether LKG has been
                        selected. This value is updated to TRUE if the user
                        chooses LKG via the profile configuration menu.

Return Value:

    On success, HCELL_INDEX is control the set to boot from.
    On error, HCELL_NIL is returned and LastKnownGoodBoot is unchanged.

--*/

{
    BOOLEAN UseLastKnownGood;
    BOOLEAN ConfigMenu = FALSE;
    HCELL_INDEX ControlSet;
    HCELL_INDEX ProfileControl;
    UNICODE_STRING DefaultControlName;
    UNICODE_STRING LkgControlName;
    PUNICODE_STRING ControlName;
    BOOLEAN AutoSelect;
    ULONG ProfileTimeout = (ULONG)0;
    PCM_HARDWARE_PROFILE_LIST ProfileList;
    PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList;
    PCM_HARDWARE_PROFILE SelectedProfile;
    DOCKING_STATION_INFO dockInfo = { 0, 0, 0, FW_DOCKINFO_DOCK_STATE_UNKNOWN };
    PCONFIGURATION_COMPONENT_DATA dockInfoData;
    ULONG flags;
    
#if DOCKINFO_VERBOSE
    _TUCHAR Buffer[1024];
    ULONG count;
    USHORT dkState;
    PTCHAR stateTxt;
#endif

    //
    // Preinit for failure
    //
    RtlInitUnicodeString(&DefaultControlName, L"Default");
    RtlInitUnicodeString(&LkgControlName, L"LastKnownGood");

    UseLastKnownGood = (*LastKnownGoodBoot);

    if (ForceLastKnownGood) {
        //
        // last known good was selected from the
        // advanced boot menu.
        // this code path is entered when the user
        // enters the advanced boot menu via the
        // main boot menu.
        //
        UseLastKnownGood = TRUE;
    }

    if( !CmpValidateSelect(&BootHive.Hive,
                            BootHive.Hive.BaseBlock->RootCell) ) {
        //
        // some of the essential values (Current,Default,Failed,LastKnownGood)
        // does not exist under \SYSTEM\Select key
        //
        return HCELL_NIL;
    }

do_it_again:
    //
    // Get the appropriate control set
    // and check the hardware profile timeout value.
    //
    if (UseLastKnownGood) {
        ControlName = &LkgControlName;
    } else {
        ControlName = &DefaultControlName;
    }
    ControlSet = CmpFindControlSet(&BootHive.Hive,
                                   BootHive.Hive.BaseBlock->RootCell,
                                   ControlName,
                                   &AutoSelect);
    if (ControlSet == HCELL_NIL) {
        return(HCELL_NIL);
    }

    //
    // Check the hardware profile configuration options to
    // determine the timeout value for the config menu.
    //
    ProfileList = NULL;
    AliasList = NULL;
    ProfileControl = CmpFindProfileOption(&BootHive.Hive,
                                          ControlSet,
                                          &ProfileList,
                                          &AliasList,
                                          &ProfileTimeout);

    //
    // Pull the Docking information from the hardware tree.
    //

    dockInfoData = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                            PeripheralClass,
                                            DockingInformation,
                                            NULL);

    if (NULL == dockInfoData) {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;

    } else if (sizeof (dockInfo) <=
               dockInfoData->ComponentEntry.ConfigurationDataLength) {

        RtlCopyMemory (
            &dockInfo,
            (PUCHAR) (dockInfoData->ConfigurationData) + sizeof(CM_PARTIAL_RESOURCE_LIST),
            sizeof (dockInfo));

        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_FAILURE;

        switch (dockInfo.ReturnCode) {
        case FW_DOCKINFO_SUCCESS:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_DOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_SYSTEM_NOT_DOCKED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_DOCK_STATE_UNKNOWN:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_FUNCTION_NOT_SUPPORTED:
        case FW_DOCKINFO_BIOS_NOT_CALLED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        default:
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNSUPPORTED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;
        }

    } else {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;
    }

#ifdef DOCKINFO_VERBOSE

    dkState = BlLoaderBlock->Extension->Profile.DockingState;

    if ((dkState & HW_PROFILE_DOCKSTATE_UNKNOWN) == HW_PROFILE_DOCKSTATE_UNKNOWN) {
        stateTxt = TEXT("Unknown");
    } else if (dkState & HW_PROFILE_DOCKSTATE_DOCKED) {
        stateTxt = TEXT("Docked");
    } else if (dkState & HW_PROFILE_DOCKSTATE_UNDOCKED) {
        stateTxt = TEXT("Undocked");
    } else {
        stateTxt = TEXT("Truely unknown");
    }

    _stprintf(Buffer,
            TEXT("Profile Docking: <%x, %s> := %x [%x, %x] \r\n\0"),
            BlLoaderBlock->Extension->Profile.Status,
            stateTxt,
            BlLoaderBlock->Extension->Profile.Capabilities,
            BlLoaderBlock->Extension->Profile.DockID,
            BlLoaderBlock->Extension->Profile.SerialNumber);

    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &count);

    _stprintf(Buffer, TEXT("press 'y' (lowercase) to continue...\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &count);
#ifdef EFI
    //
    // disable efi watchdog when waiting for user input
    //
    DisableEFIWatchDog();
#endif
    while (BlGetKey() != 'y') {
        //
        // Nothing
        //
    }
#ifdef EFI
    //
    // reset EFI watchdog
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif

#endif

    //
    // Filter the list of Hardware Profiles to
    // eliminate profiles that should not be considered
    //
    if (NULL != ProfileList) {
        if (ProfileList->CurrentProfileCount > 0) {
            BlDockInfoFilterProfileList (ProfileList, AliasList);
        }
    }

    //
    // Now check to see whether the config menu should be displayed.
    // Display the menu if:
    //  - user has pressed a key OR
    //  - we are booting from LKG and AutoSelect is FALSE. OR
    //  - ProfileTimeout != 0
    //
    if (!BlEndConfigPrompt()) {
        if (!UseLastKnownGood && ForceLastKnownGood) {
            //
            // last known good was selected from the
            // advanced boot menu.
            // this code path is entered when the user
            // enters the advanced boot menu by pressing
            // F8 while the cinfiguration hives are preparing to load.
            //
            // the currentcontrolset has already been set to the
            // "default" control set, so go back and try this again to
            // load the "lastknowngood" controlset.
            //
            UseLastKnownGood = TRUE;
            
            goto do_it_again;
        }

        ConfigMenu = FALSE;
         
    } else {
        ConfigMenu = TRUE;
    }

    if  (ConfigMenu || ForceLastKnownGood ||
         (UseLastKnownGood && !AutoSelect) ||
         ((ProfileTimeout != 0) &&
         (ProfileList != NULL) &&
         (ProfileList->CurrentProfileCount > 1))) {
        //
        // Display the configuration menu.
        //
        BlRebootSystem = !BlConfigMenuPrompt(ProfileTimeout,
                                             &UseLastKnownGood,
                                             &ControlSet,
                                             &ProfileList,
                                             &AliasList,
                                             &SelectedProfile);

        if (BlRebootSystem) {
            ArcReboot();
        }
        BlClearScreen();
    } else {    
        if ((ProfileControl != HCELL_NIL) &&
            (ProfileList != NULL)) {
            //
            // The system is configured to boot the default
            // profile directly. Since the returned profile
            // list is sorted by priority, the first entry in
            // the list is our default.
            //
            if (HW_PROFILE_STATUS_SUCCESS ==
                BlLoaderBlock->Extension->Profile.Status) {

                flags = (ProfileList->Profile[0].Flags);

                if (flags & CM_HP_FLAGS_PRISTINE) {
                    BlLoaderBlock->Extension->Profile.Status =
                        HW_PROFILE_STATUS_PRISTINE_MATCH;

                } else if (flags & CM_HP_FLAGS_TRUE_MATCH) {
                    BlLoaderBlock->Extension->Profile.Status =
                        HW_PROFILE_STATUS_TRUE_MATCH;

                } else if (flags & CM_HP_FLAGS_ALIASABLE) {
                    BlLoaderBlock->Extension->Profile.Status =
                        HW_PROFILE_STATUS_ALIAS_MATCH;
                }
            }

            CmpSetCurrentProfile(&BootHive.Hive,
                                 ControlSet,
                                 &ProfileList->Profile[0]);

        }
    } 

    //
    // Update the passed in parameter. We should only be doing this if we have
    // something real to return.
    //
    //ASSERT(ControlSet != HCELL_NIL);
    *LastKnownGoodBoot = UseLastKnownGood;

    return(ControlSet);
}


BOOLEAN
BlpCheckRestartSetup(
    VOID
    )

/*++

Routine Description:

    Examine the system hive loaded and described by BootHive, to see
    whether it contains a Setup key, and if so, whether that key has
    a "RestartSetup" value that is non-0.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the above condition is satisfied.

--*/

{
    HCELL_INDEX KeyCell;
    HCELL_INDEX ValueCell;
    UNICODE_STRING UnicodeString;
    PCM_KEY_VALUE Value;
    PULONG Data;
    ULONG DataSize;

    //
    // Address the Setup key
    //
    RtlInitUnicodeString(&UnicodeString,L"Setup");
    KeyCell = CmpFindSubKeyByName(
                &BootHive.Hive,
                (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,BootHive.Hive.BaseBlock->RootCell),
                &UnicodeString
                );

    if(KeyCell == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find RestartSetup value in Setup key
    //
    RtlInitUnicodeString(&UnicodeString,L"RestartSetup");
    ValueCell = CmpFindValueByName(
                    &BootHive.Hive,
                    (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,KeyCell),
                    &UnicodeString
                    );

    if(ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Validate value and check.
    //
    Value = (PCM_KEY_VALUE)HvGetCell(&BootHive.Hive,ValueCell);
    if(Value->Type != REG_DWORD) {
        return(FALSE);
    }

    Data = (PULONG)(CmpIsHKeyValueSmall(DataSize,Value->DataLength)
                  ? (struct _CELL_DATA *)&Value->Data
                  : HvGetCell(&BootHive.Hive,Value->Data));

    if(DataSize != sizeof(ULONG)) {
        return(FALSE);
    }

    return((BOOLEAN)(*Data != 0));
}


#if defined(REMOTE_BOOT)
BOOLEAN
BlpQueryRemoteBootParameter(
    IN HCELL_INDEX ControlSet,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    OUT PVOID ValueBuffer,
    IN ULONG ValueBufferLength
    )

/*++

Routine Description:

    Query a parameter from under Control\RemoteBoot.

Arguments:

    ControlSet - The index of the current control set.

    ValueName - The name of the value to query.

    ValueType - The expected type of the value.

    ValueBuffer - The location to return the data.

    ValueBufferLength - The length of the buffer.

Return Value:

    Boolean value indicating whether the data was read successfully.

--*/

{

    UNICODE_STRING Name;
    HCELL_INDEX Control;
    HCELL_INDEX RemoteBoot;
    HCELL_INDEX ValueCell;
    PCM_KEY_VALUE Value;
    ULONG RealSize;
    BOOLEAN ValueSmall;

    //
    // Find Services node
    //
    RtlInitUnicodeString(&Name, L"Control");
    Control = CmpFindSubKeyByName(
                  &BootHive.Hive,
                  (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,ControlSet),
                  &Name);
    if (Control == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find RemoteBoot node
    //
    RtlInitUnicodeString(&Name, L"RemoteBoot");
    RemoteBoot = CmpFindSubKeyByName(
                     &BootHive.Hive,
                     (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,Control),
                     &Name);
    if (RemoteBoot == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find value
    //
    RtlInitUnicodeString(&Name, ValueName);
    ValueCell = CmpFindValueByName(
                    &BootHive.Hive,
                    (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,RemoteBoot),
                    &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(&BootHive.Hive, ValueCell);

    if (Value->Type != ValueType) {
        return(FALSE);
    }

    //
    // This determines if the value is small (stored right in Value)
    // or not, and also returns the real size of it.
    //

    ValueSmall = CmpIsHKeyValueSmall(RealSize,Value->DataLength);

    if (RealSize > ValueBufferLength) {
        return(FALSE);
    }

    RtlMoveMemory(
        ValueBuffer,
        (ValueSmall ?
          (struct _CELL_DATA *)&Value->Data :
          HvGetCell(&BootHive.Hive,Value->Data)),
        RealSize);

    return(TRUE);
}
#endif // defined(REMOTE_BOOT)


PTCHAR
BlScanRegistry(
    IN PWSTR BootFileSystemPath,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT PLIST_ENTRY BootDriverListHead,
    OUT PUNICODE_STRING AnsiCodepage,
    OUT PUNICODE_STRING OemCodepage,
    OUT PUNICODE_STRING LanguageTable,
    OUT PUNICODE_STRING OemHalFont,
#ifdef _WANT_MACHINE_IDENTIFICATION
    OUT PUNICODE_STRING Biosinfo,
#endif
    OUT PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT BOOLEAN *ServerHive
    )

/*++

Routine Description:

    Scans the SYSTEM hive, determines the control set and static hardware
    profile (with appropriate input from the user) and finally
    computes the list of boot drivers to be loaded.

Arguments:

    BootFileSystemPath - Supplies the name of the image the filesystem
        for the boot volume was read from.  The last entry in
        BootDriverListHead will refer to this file, and to the registry
        key entry that controls it.

    LastKnownGoodBoot - On input, LastKnownGood indicates whether LKG has been
                        selected. This value is updated to TRUE if the user
                        chooses LKG via the profile configuration menu.

    BootDriverListHead - Receives a pointer to the first element of the
        list of boot drivers.  Each element in this singly linked list will
        provide the loader with two paths.  The first is the path of the
        file that contains the driver to load, the second is the path of
        the registry key that controls that driver.  Both will be passed
        to the system via the loader heap.

    AnsiCodepage - Receives the name of the ANSI codepage data file

    OemCodepage - Receives the name of the OEM codepage data file

    Language - Receives the name of the language case table data file

    OemHalfont - receives the name of the OEM font to be used by the HAL.

    SetupLoaderBlock - if non-NULL, used to return information about the
        net boot card.

    ServerHive - Returns TRUE if this is a server hive, else FALSE.

Return Value:

    NULL    if all is well.
    NON-NULL if the hive is corrupt or inconsistent.  Return value is a
        pointer to a string that describes what is wrong. On error LastKnownGood
        is unchanged.

--*/

{
    HCELL_INDEX     ControlSet;
    UNICODE_STRING  TmpName;
    HCELL_INDEX     Control;
    HCELL_INDEX     ProductOptions;
    HCELL_INDEX     ValueCell;
    PCM_KEY_VALUE   Value;
    ULONG           RealSize;
    PWCHAR          CellString;
    BOOLEAN         UsingLastKnownGood;
#ifdef _WANT_MACHINE_IDENTIFICATION
    UNICODE_STRING  regDate;
    CHAR            date[9];
    ANSI_STRING     ansiString;
    UNICODE_STRING  biosDate;
    WCHAR           buffer[9];
    BOOLEAN         biosDateChanged;
#endif

#if !defined(REMOTE_BOOT)
    UNREFERENCED_PARAMETER(SetupLoaderBlock);
#endif

    //
    // Preinit.
    //
    UsingLastKnownGood = *LastKnownGoodBoot;

    //
    // Get the appropriate control set.
    //
    ControlSet = BlpDetermineControlSet(&UsingLastKnownGood);

    if (ControlSet == HCELL_NIL) {
        return(TEXT("CmpFindControlSet"));
    }

    if (!CmpFindNLSData(&BootHive.Hive,
                        ControlSet,
                        AnsiCodepage,
                        OemCodepage,
                        LanguageTable,
                        OemHalFont)) {
        return(TEXT("CmpFindNLSData"));
    }

    InitializeListHead(BootDriverListHead);
    if (!CmpFindDrivers(&BootHive.Hive,
                        ControlSet,
                        BootLoad,
                        BootFileSystemPath,
                        BootDriverListHead)) {
        return(TEXT("CmpFindDriver"));
    }

    if (!CmpSortDriverList(&BootHive.Hive,
                           ControlSet,
                           BootDriverListHead)) {
        return(TEXT("Missing or invalid Control\\ServiceGroupOrder\\List registry value"));
    }

    if (!CmpResolveDriverDependencies(BootDriverListHead)) {
        return(TEXT("CmpResolveDriverDependencies"));
    }

    if (ServerHive != NULL) {

        *ServerHive = FALSE;

        //
        // Find Control node
        //
        RtlInitUnicodeString(&TmpName, L"Control");

        Control = CmpFindSubKeyByName(&BootHive.Hive,
                                      (PCM_KEY_NODE)HvGetCell(&BootHive.Hive, ControlSet),
                                      &TmpName
                                     );
        if (Control == HCELL_NIL) {
            return(TEXT("Missing Control key"));
        }

        //
        // Find ProductOptions node
        //
        RtlInitUnicodeString(&TmpName, L"ProductOptions");
        ProductOptions = CmpFindSubKeyByName(&BootHive.Hive,
                                             (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,Control),
                                             &TmpName
                                            );
        if (ProductOptions == HCELL_NIL) {
            return(TEXT("Missing ProductOptions key"));
        }

        //
        // Find value
        //
        RtlInitUnicodeString(&TmpName, L"ProductType");
        ValueCell = CmpFindValueByName(&BootHive.Hive,
                                       (PCM_KEY_NODE)HvGetCell(&BootHive.Hive, ProductOptions),
                                       &TmpName
                                      );

        if (ValueCell == HCELL_NIL) {
            return(TEXT("Missing ProductType value"));
        }

        Value = (PCM_KEY_VALUE)HvGetCell(&BootHive.Hive, ValueCell);

        if (Value->Type != REG_SZ) {
            return(TEXT("Bad ProductType value"));
        }

        //
        // This determines if the value is small (stored right in Value)
        // or not, and also returns the real size of it.
        //
        CellString = (PWCHAR)(CmpIsHKeyValueSmall(RealSize, Value->DataLength) ?
                                 (struct _CELL_DATA *)&Value->Data :
                                 HvGetCell(&BootHive.Hive, Value->Data)
                             );

        //
        // Now compare if this is a server hive or not.
        // The proper way to check this is to check the string against
        // the "professional" type 'WinNT'.  If it's not professional,
        // it must be a server.  (There are multiple strings for different
        // server flavours.)
        //
        *ServerHive = (BOOLEAN)(_wcsicmp(L"WinNT", CellString) != 0);
    }

#if defined(REMOTE_BOOT)
    if (SetupLoaderBlock != NULL) {

        ULONG EnableIpSecurity;

        if (BlpQueryRemoteBootParameter(
                ControlSet,
                L"EnableIpSecurity",
                REG_DWORD,
                &EnableIpSecurity,
                sizeof(EnableIpSecurity))) {
            if (EnableIpSecurity != 0) {
                SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_IPSEC_ENABLED;
            }
        }

        if (BlpQueryRemoteBootParameter(
                ControlSet,
                L"NetCardInfo",
                REG_BINARY,
                SetupLoaderBlock->NetbootCardInfo,
                SetupLoaderBlock->NetbootCardInfoLength)) {

            if (!BlpQueryRemoteBootParameter(
                     ControlSet,
                     L"HardwareId",
                     REG_SZ,
                     SetupLoaderBlock->NetbootCardHardwareId,
                     sizeof(SetupLoaderBlock->NetbootCardHardwareId))) {
                SetupLoaderBlock->NetbootCardHardwareId[0] = L'\0';
            }

            if (!BlpQueryRemoteBootParameter(
                     ControlSet,
                     L"DriverName",
                     REG_SZ,
                     SetupLoaderBlock->NetbootCardDriverName,
                     sizeof(SetupLoaderBlock->NetbootCardDriverName))) {
                SetupLoaderBlock->NetbootCardDriverName[0] = L'\0';
            }

            if (!BlpQueryRemoteBootParameter(
                     ControlSet,
                     L"ServiceName",
                     REG_SZ,
                     SetupLoaderBlock->NetbootCardServiceName,
                     sizeof(SetupLoaderBlock->NetbootCardServiceName))) {
                SetupLoaderBlock->NetbootCardServiceName[0] = L'\0';
            }
        }
    }
#endif // defined(REMOTE_BOOT)

#ifdef _WANT_MACHINE_IDENTIFICATION

    biosDateChanged = TRUE;
    if (CmpGetBiosDateFromRegistry(&BootHive.Hive, ControlSet, &regDate)) {

        //
        // Read the date from the BIOS ROM.
        //        
        memcpy(date, (PVOID)0xffff5, 8);
        date[8] = '\0';

        //
        // Convert the date into unicode string.
        //

        ansiString.Buffer = date;
        ansiString.Length = (USHORT) strlen(date);
        ansiString.MaximumLength = ansiString.Length + 1;
        biosDate.Buffer = buffer;
        biosDate.MaximumLength = (ansiString.Length << 1) + sizeof(UNICODE_NULL);
        RtlAnsiStringToUnicodeString(&biosDate, &ansiString, FALSE);

        //
        // Check if the dates are different.
        //

        if (RtlCompareUnicodeString(&biosDate, &regDate, FALSE) == 0) {

            biosDateChanged = FALSE;
        }
    }

    Biosinfo->Length = 0;
    if (biosDateChanged) {

        CmpGetBiosinfoFileNameFromRegistry(&BootHive.Hive, ControlSet, Biosinfo);
    }

#endif // defined(_WANT_MACHINE_IDENTIFICATION)

    *LastKnownGoodBoot = UsingLastKnownGood;
    return( NULL );
}


ARC_STATUS
BlAddToBootDriverList(
    IN PLIST_ENTRY BootDriverListHead,
    IN PWSTR DriverName,
    IN PWSTR Name,
    IN PWSTR Group,
    IN ULONG Tag,
    IN ULONG ErrorControl,
    IN BOOLEAN InsertAtHead
    )

/*++

Routine Description:

    Adds a single driver to the boot driver list. The list
    is NOT re-sorted.

Arguments:

    BootDriverListHead - Receives a pointer to the first element of the
        list of boot drivers.  Each element in this singly linked list will
        provide the loader with two paths.  The first is the path of the
        file that contains the driver to load, the second is the path of
        the registry key that controls that driver.  Both will be passed
        to the system via the loader heap.

    DriverName - The name of the driver. This will be stored with
        \system32\drivers on the front.

    Name - The service name of the driver. Typically will be DriverName
        without the ".sys".

    Group - The group this driver is in.

    Tag - The tag value within the group for this driver.

    ErrorControl - The error control value for this driver.

    InsertAtHead - Should this driver be inserted at the head of the list, otw tail.

Return Value:

    ESUCCESS if the driver is successfully inserted.
    ENOMEM if there is an allocation failure.

--*/

{
    PBOOT_DRIVER_NODE DriverNode;
    PBOOT_DRIVER_LIST_ENTRY DriverListEntry;
    USHORT Length;

    DriverNode = BlpHiveAllocate(sizeof(BOOT_DRIVER_NODE),FALSE,0);
    if (DriverNode == FALSE) {
        return ENOMEM;
    }

    DriverListEntry = &DriverNode->ListEntry;

    //
    // FilePath
    //

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1
    //
    Length = RESET_SIZE_AT_USHORT_MAX(sizeof(L"System32\\Drivers\\") + (wcslen(DriverName) * sizeof(WCHAR)));
    DriverListEntry->FilePath.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverListEntry->FilePath.Buffer == NULL) {
        return ENOMEM;
    }
    DriverListEntry->FilePath.Length = 0;
    DriverListEntry->FilePath.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverListEntry->FilePath, L"System32\\Drivers\\");
    RtlAppendUnicodeToString(&DriverListEntry->FilePath, DriverName);

    //
    // Registry Path
    //

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1
    //
    Length = RESET_SIZE_AT_USHORT_MAX(sizeof(L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\") + 
                                      (wcslen(Name) * sizeof(WCHAR)));
    DriverListEntry->RegistryPath.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverListEntry->RegistryPath.Buffer == NULL) {
        return ENOMEM;
    }
    DriverListEntry->RegistryPath.Length = 0;
    DriverListEntry->RegistryPath.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverListEntry->RegistryPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
    RtlAppendUnicodeToString(&DriverListEntry->RegistryPath, Name);

    //
    // Group
    //

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1
    //
    Length = RESET_SIZE_AT_USHORT_MAX((wcslen(Group) + 1) * sizeof(WCHAR));
    DriverNode->Group.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverNode->Group.Buffer == NULL) {
        return ENOMEM;
    }
    DriverNode->Group.Length = 0;
    DriverNode->Group.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverNode->Group, Group);

    //
    // Name
    //

    // 
    // when assigning the length, do some checking to make sure we don't 
    // overflow.  if we do overflow, assign the length value to 0
    // make sure we don't overflow (USHORT)-1
    //
    Length = RESET_SIZE_AT_USHORT_MAX((wcslen(Name) + 1) * sizeof(WCHAR));
    DriverNode->Name.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverNode->Name.Buffer == NULL) {
        return ENOMEM;
    }
    DriverNode->Name.Length = 0;
    DriverNode->Name.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverNode->Name, Name);

    //
    // Tag/ErrorControl
    //

    DriverNode->Tag = Tag;
    DriverNode->ErrorControl = ErrorControl;

    if (InsertAtHead) {
        InsertHeadList(BootDriverListHead, &DriverListEntry->Link);
    } else {
        InsertTailList(BootDriverListHead, &DriverListEntry->Link);
    }

    return ESUCCESS;

}

#define HFILE_TYPE_ALTERNATE     1   // alternate, in order for boot to be able to boot downlevel OSes

BOOLEAN
BlInitializeHive(
    IN PVOID HiveImage,
    IN PCMHIVE Hive,
    IN BOOLEAN IsAlternate
    )

/*++

Routine Description:

    Initializes the hive data structure based on the in-memory hive image.

Arguments:

    HiveImage - Supplies a pointer to the in-memory hive image.

    Hive - Supplies the CMHIVE structure to be filled in.

    IsAlternate - Supplies whether or not the hive is the alternate hive,
        which indicates that the primary hive is corrupt and should be
        rewritten by the system.

Return Value:

    TRUE - Hive successfully initialized.

    FALSE - Hive is corrupt.

--*/
{
    NTSTATUS    status;
    ULONG       HiveCheckCode;

    status = HvInitializeHive(
                &Hive->Hive,
                HINIT_MEMORY_INPLACE,
                FALSE,
                IsAlternate ? HFILE_TYPE_ALTERNATE : HFILE_TYPE_PRIMARY,
                HiveImage,
                (PALLOCATE_ROUTINE)BlpHiveAllocate,     // allocate
                NULL,                                   // free
                NULL,                                   // setsize
                NULL,                                   // write
                NULL,                                   // read
                NULL,                                   // flush
                1,                                      // cluster
                NULL
                );

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    HiveCheckCode = CmCheckRegistry(Hive,CM_CHECK_REGISTRY_LOADER_CLEAN|CM_CHECK_REGISTRY_HIVE_CHECK);
    if (HiveCheckCode != 0) {
        return(FALSE);
    } else {
        return TRUE;
    }

}


PVOID
BlpHiveAllocate(
    IN ULONG    Length,
    IN BOOLEAN  UseForIo,
    IN ULONG    Tag
    )

/*++

Routine Description:

    Wrapper for hive allocation calls.  It just calls BlAllocateHeap.

Arguments:

    Length - Supplies the size of block required in bytes.

    UseForIo - Supplies whether or not the memory is to be used for I/O
               (this is currently ignored)

Return Value:

    address of the block of memory
        or
    NULL if no memory available

--*/

{
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( UseForIo );
    UNREFERENCED_PARAMETER( Tag );

    return(BlAllocateHeap(Length));

}


NTSTATUS
HvLoadHive(
    PHHIVE  Hive
    )
{
    UNREFERENCED_PARAMETER(Hive);
    return(STATUS_SUCCESS);
}

NTSTATUS
HvMapHive(
    PHHIVE  Hive
    )
{
    UNREFERENCED_PARAMETER(Hive);
    return(STATUS_SUCCESS);
}

NTSTATUS
HvpAdjustHiveFreeDisplay(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN HSTORAGE_TYPE    Type
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(HiveLength);
    UNREFERENCED_PARAMETER(Type);
    return(STATUS_SUCCESS);
}

VOID
HvpAddFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Cell);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Type);
}

VOID
HvpRemoveFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Cell);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Type);
}

HCELL_INDEX
HvpFindFreeCell(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(NewSize);
    UNREFERENCED_PARAMETER(Vicinity);
    return HCELL_NIL;
}

VOID
CmpTouchView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN ULONG                Cell
            )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(CmView);
    UNREFERENCED_PARAMETER(Cell);
}

NTSTATUS
CmpMapThisBin(
                PCMHIVE         CmHive,
                HCELL_INDEX     Cell,
                BOOLEAN         Touch
              )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(Cell);
    UNREFERENCED_PARAMETER(Touch);
    return(STATUS_SUCCESS);
}

/*
NTSTATUS
CmpMapCmView(
    IN  PCMHIVE             CmHive,
    IN  ULONG               FileOffset,
    OUT PCM_VIEW_OF_FILE    *CmView
    )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(FileOffset);
    UNREFERENCED_PARAMETER(CmView);
    return(STATUS_SUCCESS);
}

VOID
CmpPinCmView (
        IN  PCMHIVE             CmHive,
        PCM_VIEW_OF_FILE        CmView
                             )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(CmView);
}

VOID
CmpUnPinCmView (
        IN  PCMHIVE             CmHive,
        IN  PCM_VIEW_OF_FILE    CmView,
        IN  BOOLEAN             SetClean
                             )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(CmView);
    UNREFERENCED_PARAMETER(SetClean);
}

VOID
CmpLazyFlush(
    VOID
    )
{
}
*/

/*
NTSTATUS
CmpDoFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(FileType);
    UNREFERENCED_PARAMETER(FileSize);
    return(STATUS_SUCCESS);
}
*/

BOOLEAN
HvMarkCellDirty(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Cell);
    return(TRUE);
}

BOOLEAN
HvMarkDirty(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length,
    BOOLEAN     DirtyAndPin
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Start);
    UNREFERENCED_PARAMETER(Length);
    UNREFERENCED_PARAMETER(DirtyAndPin);
    return(TRUE);
}


BOOLEAN
HvpDoWriteHive(
    PHHIVE          Hive,
    ULONG           FileType
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(FileType);
    return(TRUE);
}

BOOLEAN
HvpGrowLog1(
    PHHIVE  Hive,
    ULONG   Count
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Count);
    return(TRUE);
}

BOOLEAN
HvpGrowLog2(
    PHHIVE  Hive,
    ULONG   Size
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Size);
    return(TRUE);
}

BOOLEAN
CmpValidateHiveSecurityDescriptors(
    IN PHHIVE Hive,
    OUT PBOOLEAN ResetSD
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER( ResetSD );
    return(TRUE);
}


BOOLEAN
CmpTestRegistryLock()
{
    return TRUE;
}

BOOLEAN
CmpTestRegistryLockExclusive()
{
    return TRUE;
}


BOOLEAN
HvIsBinDirty(
IN PHHIVE Hive,
IN HCELL_INDEX Cell
)
{
    UNREFERENCED_PARAMETER( Hive );
    UNREFERENCED_PARAMETER( Cell );

    return(FALSE);
}
PHBIN
HvpAddBin(
    IN PHHIVE  Hive,
    IN ULONG   NewSize,
    IN HSTORAGE_TYPE   Type
    )
{
    UNREFERENCED_PARAMETER( Hive );
    UNREFERENCED_PARAMETER( NewSize );
    UNREFERENCED_PARAMETER( Type );

    return(NULL);
}
VOID
CmpReleaseGlobalQuota(
    IN ULONG    Size
    )
{
    UNREFERENCED_PARAMETER( Size );

    return;
}


#if DOCKINFO_VERBOSE
VOID
BlDiagDisplayProfileList(
    IN PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList,
    IN BOOLEAN WaitForUserInput
)
/*++

Routine Description:

    This is a diagnostic function only!

    Display hardware profile list on console, optionally wait for user
    input before proceeding.

Arguments:

    ProfileList - Supplies a list of hardware profiles to display

    WaitForUserInput - Prompt user to hit a key ('y') to continue, and wait
                       for user's input if TRUE. Don't wait if FALSE.

Return Value:

    None.

--*/
{
    TCHAR  Buffer[200];
    TCHAR  StrFriendlyName[30];
    PTCHAR AliasType [] = {
        TEXT("NotAliasable"), // 0
        TEXT("Aliasable   "), // 1
        TEXT("True Match  "), // 2
        TEXT("True & Alias"), // 3
        TEXT("Pristine    "), // 4
        TEXT("Pris & Alias"), // 5
        TEXT("Pris & True "), // 6
        TEXT("P & A & T   ")  // 7
    };

    ULONG Count;
    ULONG i;

    // display header
    _stprintf(Buffer, TEXT("Profiles: <PrefOrd, Id - Aliased FriendlyName>\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);


    // for each hardware profile
    for (i = 0; i < ProfileList->CurrentProfileCount; ++i) {
#ifdef UNICODE
        wcsncpy( 
            StrFriendlyName, 
            ProfileList->Profile[i].FriendlyName, 
            ProfileList->Profile[i].NameLength, 
            );
        StrFriendlyName[29] = L'\0';
        StrFriendlyName[ProfileList->Profile[i].NameLength] = L'\0';
#else

        // copy and convert unicode fields to ascii for output
        RtlUnicodeToMultiByteN(StrFriendlyName,
                         sizeof(StrFriendlyName),
                         &Count,
                         ProfileList->Profile[i].FriendlyName,
                         ProfileList->Profile[i].NameLength);
        StrFriendlyName[Count] = '\0';
#endif

        // display info for current profile
        _stprintf(Buffer, 
                TEXT("          <%2ld> %2ld - %s \"%s\"\r\n\0"),
                ProfileList->Profile[i].PreferenceOrder,
                ProfileList->Profile[i].Id,
                AliasType[ ProfileList->Profile[i].Flags ],
                StrFriendlyName);
        ArcWrite(
            BlConsoleOutDeviceId, 
            Buffer, 
            _tcslen(Buffer)*sizeof(TCHAR), 
            &Count );
    }

    // display header
    _stprintf(Buffer, TEXT("Aliases: <Profile #> DockState [DockID, SerialNumber]\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);

    if (AliasList) {
        for (i = 0; i < AliasList->CurrentAliasCount; i++) {
            _stprintf(Buffer, TEXT("         <%2ld> %x [%x, %x]\r\n\0"),
                    AliasList->Alias[i].ProfileNumber,
                    AliasList->Alias[i].DockState,
                    AliasList->Alias[i].DockID,
                    AliasList->Alias[i].SerialNumber);
            ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);
        }
    }

    if(WaitForUserInput) {
#ifdef EFI
        //
        // disable efi watchdog when waiting for user input
        //
        DisableEFIWatchDog();
#endif
        // display prompt and wait for user input to continue
        _stprintf(Buffer, TEXT("press 'y' (lowercase) to continue...\r\n\0"));
        ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);
        while (BlGetKey() != 'y') {
            //
            // nothing
            //
        }
#ifdef EFI
        // 
        // reset efi watchdog
        //
        SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);
#endif
    }
}
#endif


VOID
BlDockInfoFilterDockingState(
    IN OUT PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList,
    IN ULONG DockingState,
    IN ULONG DockID,
    IN ULONG SerialNumber
)

/*++

Routine Description:

    Discard all hardware profiles that do not have the
    DOCKINFO_UNDOCKED bit set in the DockState field

Arguments:

    ProfileList - Supplies a list of hardware profiles.
                  Returns a list containing a subset of the supplied
                  hardware profiles.

Return Value:

    None.

--*/
{
    ULONG i = 0;
    ULONG j;
    ULONG len;
    ULONG mask = HW_PROFILE_DOCKSTATE_UNDOCKED | HW_PROFILE_DOCKSTATE_DOCKED;
    BOOLEAN trueMatch = FALSE;
#if DOCKINFO_VERBOSE
    TCHAR   buffer[200];
    ULONG   count;
#endif

    if (AliasList) {
        while (i < AliasList->CurrentAliasCount) {
            if (((AliasList->Alias[i].DockState & mask) != 0) &&
                ((AliasList->Alias[i].DockState & mask) != DockingState)) {

                //
                // This alias claims to be docked or undocked, but does not
                // match the current state.  Therefore skip it.
                //
                ;

            } else if ((AliasList->Alias[i].DockID == DockID) &&
                       (AliasList->Alias[i].SerialNumber == SerialNumber)) {

                //
                // This alias matches so mark the profile.
                //
                for (j = 0; j < ProfileList->CurrentProfileCount; j++) {
                    if (ProfileList->Profile[j].Id ==
                        AliasList->Alias[i].ProfileNumber) {

                        ProfileList->Profile[j].Flags =
                            CM_HP_FLAGS_TRUE_MATCH;

                        trueMatch = TRUE;
                    }
                }
            }
            i++;
        }
    }

#if DOCKINFO_VERBOSE
    _stprintf(buffer, TEXT("Filtering Profiles ...\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, buffer, _tcslen(buffer)*sizeof(TCHAR), &count);
#endif

    i = 0;
    while (i < ProfileList->CurrentProfileCount) {

        if ((ProfileList->Profile[i].Flags & CM_HP_FLAGS_PRISTINE) &&
            !trueMatch &&
            AliasList) {
            //
            // Leave this one in the list
            //
            i++;
            continue;

        } else if (ProfileList->Profile[i].Flags & CM_HP_FLAGS_ALIASABLE) {
            //
            // Leave this one in the list
            //
            i++;
            continue;

        } else if (ProfileList->Profile[i].Flags & CM_HP_FLAGS_TRUE_MATCH) {
            //
            // Leave this one in the list
            //
            i++;
            continue;
        }

        //
        // discard this profile by (1) shifting remaining profiles in
        //   array to fill in the space of this discarded profile
        //   and (2) decrementing profile count
        //
        len = ProfileList->CurrentProfileCount - i - 1;
        if (0 < len) {
            RtlMoveMemory(&ProfileList->Profile[i],
                          &ProfileList->Profile[i+1],
                          sizeof(CM_HARDWARE_PROFILE) * len);
        }

        --ProfileList->CurrentProfileCount;
    }
}


VOID
BlDockInfoFilterProfileList(
    IN OUT PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList
)

/*++

Routine Description:

    Filters hardware profile list by discarding hardware profiles that
    do not match the docking station information returned by NTDETECT.


Arguments:

    ProfileList - Supplies a list of hardware profiles.
                - Returns a list containing a subset of the supplied
                    hardware profiles.

Return Value:

    None.

--*/

{
#if DOCKINFO_VERBOSE
     // display ProfileList prior to filtering
    BlDiagDisplayProfileList(ProfileList, AliasList, TRUE);
#endif

    if (1 == ProfileList->CurrentProfileCount) {
        if (ProfileList->Profile[0].Flags & CM_HP_FLAGS_PRISTINE) {
            //
            // Nothing to filter.
            //
            return;
        }
    }
    BlDockInfoFilterDockingState (
                ProfileList,
                AliasList,
                BlLoaderBlock->Extension->Profile.DockingState,
                BlLoaderBlock->Extension->Profile.DockID,
                BlLoaderBlock->Extension->Profile.SerialNumber);

#if DOCKINFO_VERBOSE
     // display ProfileList prior to filtering
    BlDiagDisplayProfileList(ProfileList, AliasList, TRUE);
#endif

}

int
BlIsReturnToOSChoicesValid(
    VOID
    )
/*++

Routine Description:

    Indicates whether the "Return to OS Choices Menu" should
    be shown as advanced boot option or not.

Arguments:

    None


Return Value:

    1 if yes otherwise 0.

--*/
{
    return BlShowReturnToOSChoices;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\hiber.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hiber.c

Abstract:


Author:


Revision History:

   8/7/1998   Elliot Shmukler (t-ellios)    Added Hiber file compression

--*/

#include "bldr.h"
#include "msg.h"
#include "stdio.h"
#include "stdlib.h"
#include "xpress.h"

extern UCHAR WakeDispatcherStart;
extern UCHAR WakeDispatcherEnd;

#if defined(_X86_) 
extern UCHAR WakeDispatcherAmd64Start;
extern UCHAR WakeDispatcherAmd64End;
#endif

//
//
// Hiber globals
//
// HiberFile    - File handle
// HiberBuffer  - PAGE of ram
// HiberIoError - Set to true to indicate an IO read error occured during restore
//

ULONG       HiberFile;
PUCHAR      HiberBuffer;
ULONG       HiberBufferPage;
BOOLEAN     HiberIoError;
BOOLEAN     HiberOutOfRemap;
BOOLEAN     HiberAbort;
LARGE_INTEGER HiberStartTime;
LARGE_INTEGER HiberEndTime;
ULONG       HiberNoExecute = 0;

//
// HiberImageFeatureFlags - Feature flags from hiber image header
// HiberBreakOnWake - BreakOnWake flag from hiber image header
//

BOOLEAN HiberBreakOnWake;
ULONG HiberImageFeatureFlags;

#if defined(_ALPHA_) || defined(_IA64_)

//
// On Alpha, the address of the KPROCESSOR_STATE read from the hiber file
// must be saved where WakeDispatch can find it (it's at a fixed offset
// relative to HiberVa on x86).
//

PKPROCESSOR_STATE HiberWakeState;

#else   // x86

//
// HiberPtes - Virtual address of ptes to use for restoriation.  There
// are at least HIBER_PTES consecutive ptes for use, and are for the
// address of HiberVa
//
// HiberVa - The virtual address the HiberPtes map
//
// HiberIdentityVa - The restoration images HiberVa
//
// HiberPageFrames - Page frames of the hiber ptes (does not include dest pte)
//

PVOID HiberPtes = NULL;
PUCHAR HiberVa = NULL;
PVOID HiberIdentityVa = NULL;
ULONG64 HiberIdentityVaAmd64 = 0;
ULONG HiberNoHiberPtes;
ULONG HiberPageFrames[HIBER_PTES];

#endif  // Alpha/x86

PFN_NUMBER HiberImagePageSelf;
ULONG HiberNoMappings;
ULONG HiberFirstRemap;
ULONG HiberLastRemap;

extern
ULONG
BlGetKey(
    VOID
    );

extern
ULONG
BlDetermineOSVisibleMemory(
    VOID
    );


VOID
BlUpdateProgressBar(
    ULONG fPercentage
    );

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    );

VOID
BlOutputTrailerMsg(
    ULONG   uMsgID
    );

//
// Defines for Hiber restore UI
//

ULONG   HbCurrentScreen;

#define BAR_X                       7
#define BAR_Y                      10
#define PERCENT_BAR_WIDTH          66

#define PAUSE_X                     7
#define PAUSE_Y                     7

#define FAULT_X                     7
#define FAULT_Y                     7

UCHAR szHiberDebug[] = "debug";
UCHAR szHiberFileName[] = "\\hiberfil.sys";

//
// HiberFile Compression Related definnes
//

#define PAGE_MASK   (PAGE_SIZE - 1)
#define PAGE_PAGES(n)   (((n) + PAGE_MASK) >> PAGE_SHIFT)

//
// The size of the buffer for compressed data

#define COMPRESSION_BUFFER_SIZE     64 << PAGE_SHIFT

//

#define MAX_COMPRESSION_BUFFER_EXTRA_PAGES \
    PAGE_PAGES (PAGE_MASK + 2*XPRESS_HEADER_SIZE)
#define MAX_COMPRESSION_BUFFER_EXTRA_SIZE \
    (MAX_COMPRESSION_BUFFER_EXTRA_PAGES << PAGE_SHIFT)

#define LZNT1_COMPRESSION_BUFFER_PAGES  16
#define LZNT1_COMPRESSION_BUFFER_SIZE \
    (LZNT1_COMPRESSION_BUFFER_PAGES << PAGE_SHIFT)

#define XPRESS_COMPRESSION_BUFFER_PAGES \
    PAGE_PAGES (XPRESS_MAX_SIZE + MAX_COMPRESSION_BUFFER_EXTRA_SIZE)
#define XPRESS_COMPRESSION_BUFFER_SIZE \
    (XPRESS_COMPRESSION_BUFFER_PAGES << PAGE_SHIFT)

#define MAX_COMPRESSION_BUFFER_PAGES \
    max (LZNT1_COMPRESSION_BUFFER_PAGES, XPRESS_COMPRESSION_BUFFER_PAGES)
#define MAX_COMPRESSION_BUFFER_SIZE \
    (MAX_COMPRESSION_BUFFER_PAGES << PAGE_SHIFT)


// Buffer to store decoded data
typedef struct {
    PUCHAR DataPtr, PreallocatedDataBuffer;
    LONG   DataSize;

    struct {
        struct {
            LONG Size;
            ULONG Checksum;
        } Compressed, Uncompressed;

        LONG XpressEncoded;
    } Header;

    LONG DelayedCnt;      // # of delayed pages
    ULONG DelayedChecksum;    // last checksum value
    ULONG DelayedBadChecksum;

    struct {
        PUCHAR DestVa;  // delayed DestVa
        PFN_NUMBER DestPage;// delayed page number
        ULONG  RangeCheck;  // last range checksum
        LONG   Flags;   // 1 = clear checksum, 2 = compare checksum
    } Delayed[XPRESS_MAX_PAGES];
} DECOMPRESSED_BLOCK, *PDECOMPRESSED_BLOCK;

typedef struct {
    struct {
        PUCHAR Beg;
        PUCHAR End;
    } Current, Buffer, Aligned;
    PFN_NUMBER FilePage;
    BOOLEAN    NeedSeek;
} COMPRESSED_BUFFER, *PCOMPRESSED_BUFFER;

#define HIBER_PERF_STATS 0

//
// Internal prototypes
//

#if !defined (HIBER_DEBUG)
#define CHECK_ERROR(a,b)    if(a) { *Information = __LINE__; return b; }
#define DBGOUT(_x_)
#else
#define CHECK_ERROR(a,b) if(a) {HbPrintMsg(b);HbPrint(TEXT("\r\n")); *Information = __LINE__; HbPause(); return b; }
#define DBGOUT(_x_) BlPrint _x_
#endif

ULONG
HbRestoreFile (
    IN PULONG       Information,
    OUT OPTIONAL PCHAR       *BadLinkName
    );

VOID
HbPrint (
    IN PTCHAR   str
    );

BOOLEAN
HbReadNextCompressedPageLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedChunkLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedPages (
    LONG BytesNeeded,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedBlock (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadDelayedBlock (
    BOOLEAN ForceDecoding,
    PFN_NUMBER DestPage,
    ULONG RangeCheck,
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedBlockHeader (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

ULONG
BlHiberRestore (
    IN ULONG DriveId,
    OUT PCHAR *BadLinkName
    );

BOOLEAN
HbReadNextCompressedChunk (
    PUCHAR DestVa,
    PPFN_NUMBER FilePage,
    PUCHAR CompressBuffer,
    PULONG DataOffset,
    PULONG BufferOffset,
    ULONG MaxOffset
    );


#if defined (HIBER_DEBUG) || HIBER_PERF_STATS

// HIBER_DEBUG bit mask:
//  2 - general bogosity
//  4 - remap trace


VOID HbFlowControl(VOID)
{
    UCHAR c;
    ULONG count;

    if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
        if (c == 'S' - 0x40) {
            ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
        }
    }
}

VOID HbPause(VOID)
{
    UCHAR c;
    ULONG count;

#if defined(ENABLE_LOADER_DEBUG)
    DbgBreakPoint();
#else
    HbPrint(TEXT("Press any key to continue . . ."));
    ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
    HbPrint(TEXT("\r\n"));
#endif
}

VOID HbPrintNum(ULONG n)
{
    TCHAR buf[9];

    _stprintf(buf, TEXT("%ld"), n);
    HbPrint(buf);
    HbFlowControl();
}

VOID HbPrintHex(ULONG n)
{
    TCHAR buf[11];

    _stprintf(buf, TEXT("0x%08lX"), n);
    HbPrint(buf);
    HbFlowControl();
}

#define SHOWNUM(x) ((void) (HbPrint(#x TEXT(" = ")), HbPrintNum((ULONG) (x)), HbPrint(TEXT("\r\n"))))
#define SHOWHEX(x) ((void) (HbPrint(#x TEXT(" = ")), HbPrintHex((ULONG) (x)), HbPrint(TEXT("\r\n"))))

#endif // HIBER_DEBUG

#if !defined(i386) && !defined(_ALPHA_)
ULONG
HbSimpleCheck (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    );
#else

// Use the TCP/IP Check Sum routine if available

ULONG
tcpxsum(
   IN ULONG cksum,
   IN PUCHAR buf,
   IN ULONG len
   );

#define HbSimpleCheck(a,b,c) tcpxsum(a,(PUCHAR)b,c)
#endif

//
// The macros below helps to access 64-bit structures of Amd64 from
// their 32-bit definitions in loader. If the hiber image is not
// for Amd64, these macros simply reference structure fields directly. 
//

//
// Define macros to read a field in a structure. 
// 
// READ_FIELD (struct_type, struct_ptr, field, field_type)
//
// Areguments:
//
//     struct_type - type of the structure
//
//     struct_ptr  - base address of the structure
//
//     field       - field name 
//
//     field_type  - data type of the field
//

#if defined(_X86_) 

#define READ_FIELD(struct_type, struct_ptr, field, field_type) \
           (BlAmd64UseLongMode ? \
           *((field_type *)((ULONG_PTR)struct_ptr + \
           BlAmd64FieldOffset_##struct_type(FIELD_OFFSET(struct_type, field)))) : \
           (field_type)(((struct_type *)(struct_ptr))->field))

#else 

#define READ_FIELD(struct_type, struct_ptr, field, field_type) \
           (field_type)(((struct_type *)(struct_ptr))->field)

#define WRITE_FIELD(struct_type, struct_ptr, field, field_type, data) \
               (((struct_type *)(struct_ptr))->field) = (field_type)data;
#endif

#define READ_FIELD_UCHAR(struct_type, struct_ptr, field)  \
             READ_FIELD(struct_type, struct_ptr, field, UCHAR)

#define READ_FIELD_ULONG(struct_type, struct_ptr, field)  \
             READ_FIELD(struct_type, struct_ptr, field, ULONG) \

#define READ_FIELD_ULONG64(struct_type, struct_ptr, field)  \
             READ_FIELD(struct_type, struct_ptr, field, ULONG64)

//
// Here we assume the high dword of a 64-bit pfn on Amd64 is zero. 
// Otherwise hibernation should be disabled.
//

#define READ_FIELD_PFN_NUMBER(struct_type, struct_ptr, field)  \
             READ_FIELD(struct_type, struct_ptr, field, PFN_NUMBER) \

//
// Define macros to write a field in a structure. 
// 
// WRITE_FIELD (struct_type, struct_ptr, field, field_type, data)
//
// Areguments:
//
//     struct_type - type of the structure
//
//     struct_ptr  - base address of the structure
//
//     field       - field name 
//
//     field_type  - data type of the field
//
//     data        - value to be set to the field
//

#if defined(_X86_) 

#define WRITE_FIELD(struct_type, struct_ptr, field, field_type, data) \
           if(BlAmd64UseLongMode) {  \
               *((field_type *)((ULONG_PTR)struct_ptr + \
                BlAmd64FieldOffset_##struct_type(FIELD_OFFSET(struct_type, field)))) = (field_type)data; \
           } else { \
               (((struct_type *)(struct_ptr))->field) = (field_type)data; \
           }

#else 

#define WRITE_FIELD(struct_type, struct_ptr, field, field_type, data) \
               (((struct_type *)(struct_ptr))->field) = (field_type)data;
#endif


#define WRITE_FIELD_ULONG(struct_type, struct_ptr, field, data)  \
             WRITE_FIELD(struct_type, struct_ptr, field, ULONG, data)


//
// Define macros to read a field of a element in a structure array.
// 
// READ_ELEMENT_FIELD(struct_type, array, index, field, field_type)
//
// Areguments:
//
//     struct_type - type of the structure
//
//     array       - base address of the array
//
//     index       - index of the element
//
//     field       - field name 
//
//     field_type  - data type of the field
//


#if defined(_X86_) 

#define ELEMENT_OFFSET(type, index) \
           (BlAmd64UseLongMode ? BlAmd64ElementOffset_##type(index): \
           (ULONG)(&(((type *)0)[index])))

#define READ_ELEMENT_FIELD(struct_type, array, index, field, field_type) \
             READ_FIELD(struct_type, ((PUCHAR)array + ELEMENT_OFFSET(struct_type, index)), field, field_type)  

#else 

#define READ_ELEMENT_FIELD(struct_type, array, index, field, field_type) \
             (field_type)(((struct_type *)array)[index].field)

#endif

#define READ_ELEMENT_FIELD_ULONG(struct_type, array, index, field) \
              READ_ELEMENT_FIELD(struct_type, array, index, field, ULONG)

//
// Here we assume the high dword of a 64-bit pfn on Amd64 is zero. 
// Otherwise hibernation should be disabled.
//

#define READ_ELEMENT_FIELD_PFN_NUMBER(struct_type, array, index, field) \
              READ_ELEMENT_FIELD(struct_type, array, index, field, PFN_NUMBER)

VOID
HbReadPage (
    IN PFN_NUMBER PageNo,
    IN PUCHAR Buffer
    );

VOID
HbSetImageSignature (
    IN ULONG    NewSignature
    );

VOID
HbPrint (
    IN PTCHAR   str
    )
{
    ULONG   Junk;

    ArcWrite (
        BlConsoleOutDeviceId,
        str,
        (ULONG)_tcslen(str)*sizeof(TCHAR),
        &Junk
        );
}

VOID HbPrintChar (_TUCHAR chr)
{
      ULONG Junk;

      ArcWrite(
               BlConsoleOutDeviceId,
               &chr,
               sizeof(_TUCHAR),
               &Junk
               );
}

VOID
HbPrintMsg (
    IN ULONG  MsgNo
    )
{
    PTCHAR  Str;

    Str = BlFindMessage(MsgNo);
    if (Str) {
        HbPrint (Str);
    }
}

VOID
HbScreen (
    IN ULONG Screen
    )
{
#if defined(HIBER_DEBUG)
    HbPrint(TEXT("\r\n"));
    HbPause();
#endif

    HbCurrentScreen = Screen;
    BlSetInverseMode (FALSE);
    BlPositionCursor (1, 1);
    BlClearToEndOfScreen();
    BlPositionCursor (1, 3);
    HbPrintMsg(Screen);
}

ULONG
HbSelection (
    ULONG   x,
    ULONG   y,
    PULONG  Sel,
    ULONG   Debug
    )
{
    ULONG   CurSel, MaxSel;
    ULONG   i;
    UCHAR   Key;
    PUCHAR  pDebug;

    for (MaxSel=0; Sel[MaxSel]; MaxSel++) ;
    MaxSel -= Debug;
    pDebug = szHiberDebug;

#if DBG
    MaxSel += Debug;
    Debug = 0;
#endif

    CurSel = 0;
    for (; ;) {
        //
        // Draw selections
        //

        for (i=0; i < MaxSel; i++) {
            BlPositionCursor (x, y+i);
            BlSetInverseMode ((BOOLEAN) (CurSel == i) );
            HbPrintMsg(Sel[i]);
        }

        //
        // Get a key
        //

        ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &i);
        if (Key == ASCI_CSI_IN) {
            ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &i);
            switch (Key) {
                case 'A':
                    //
                    // Cursor up
                    //
                    CurSel -= 1;
                    if (CurSel >= MaxSel) {
                        CurSel = MaxSel-1;
                    }
                    break;

                case 'B':
                    //
                    // Cursor down
                    //
                    CurSel += 1;
                    if (CurSel >= MaxSel) {
                        CurSel = 0;
                    }
                    break;
            }
        } else {
            if (Key == *pDebug) {
                pDebug++;
                if (!*pDebug) {
                    MaxSel += Debug;
                    Debug = 0;
                }
            } else {
                pDebug = szHiberDebug;
            }

            switch (Key) {
                case ASCII_LF:
                case ASCII_CR:
                    BlSetInverseMode (FALSE);
                    BlPositionCursor (1, 2);
                    BlClearToEndOfScreen ();
                    if (Sel[CurSel] == HIBER_DEBUG_BREAK_ON_WAKE) {
                        HiberBreakOnWake = TRUE;
                    }

                    return CurSel;
            }
        }
    }
}


VOID
HbCheckForPause (
    VOID
    )
{
    ULONG       uSel = 0;
    UCHAR       Key;
    ULONG       Sel[4];
    BOOLEAN     bPaused = FALSE;

    //
    // Check for space bar
    //

    if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &uSel);

        switch (Key) {
            // space bar pressed
            case ' ':
                bPaused = TRUE;
                break;

            // user pressed F5/F8 key
            case ASCI_CSI_IN:
                ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &uSel);

                if(Key == 'O') {
                    ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &uSel);
                    bPaused = (Key == 'r' || Key == 't');
                }

                break;

            default:
                bPaused = FALSE;
                break;
        }

        if (bPaused) {
            Sel[0] = HIBER_CONTINUE;
            Sel[1] = HIBER_CANCEL;
            Sel[2] = HIBER_DEBUG_BREAK_ON_WAKE;
            Sel[3] = 0;

            HbScreen(HIBER_PAUSE);

            uSel = HbSelection (PAUSE_X, PAUSE_Y, Sel, 1);

            if (uSel == 1) {
                HiberIoError = TRUE;
                HiberAbort = TRUE;
                return ;
            } else {
                BlSetInverseMode(FALSE);

                //
                // restore hiber progress screen
                //
                BlOutputStartupMsg(BL_MSG_RESUMING_WINDOWS);
                BlOutputTrailerMsg(BL_ADVANCED_BOOT_MESSAGE);
            }
        }
    }
}


ULONG
BlHiberRestore (
    IN ULONG DriveId,
    OUT PCHAR *BadLinkName
    )
/*++

Routine Description:

    Checks DriveId for a valid hiberfile.sys and if found start the
    restoration procedure

--*/
{
    extern BOOLEAN  BlOutputDots;
    NTSTATUS        Status;
    ULONG           Msg = 0;
    ULONG           Information;
    ULONG           Sel[2];
    BOOLEAN         bDots = BlOutputDots;

    //
    // If restore was aborted once, don't bother
    //

#if defined (HIBER_DEBUG)
    HbPrint(TEXT("BlHiberRestore\r\n"));
#endif


    if (HiberAbort) {
        return ESUCCESS;
    }

    //
    // Get the hiber image. If not present, done.
    //

    Status = BlOpen (DriveId, (PCHAR)szHiberFileName, ArcOpenReadWrite, &HiberFile);
    if (Status != ESUCCESS) {
#if defined (HIBER_DEBUG)
        HbPrint(TEXT("No hiber image file.\r\n"));
#endif
        return ESUCCESS;
    }

    //
    // Restore the hiber image
    //
    BlOutputDots = TRUE;
    //
    // Set the global flag to allow blmemory.c to grab from the right
    // part of the buffer
    //
    BlRestoring=TRUE;

    Msg = HbRestoreFile (&Information, BadLinkName);

    BlOutputDots = bDots;

    if (Msg) {
        BlSetInverseMode (FALSE);

        if (!HiberAbort) {
            HbScreen(HIBER_ERROR);
            HbPrintMsg(Msg);
            Sel[0] = HIBER_CANCEL;
            Sel[1] = 0;
            HbSelection (FAULT_X, FAULT_Y, Sel, 0);
        }
        HbSetImageSignature (0);
    }

    BlClose (HiberFile);
    BlRestoring=FALSE;
    return Msg ? EAGAIN : ESUCCESS;
}


#if !defined(i386) && !defined(_ALPHA_)
ULONG
HbSimpleCheck (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    )
/*++

Routine Description:

    Computes a checksum for the supplied virtual address and length

    This function comes from Dr. Dobbs Journal, May 1992

--*/
{

    PUSHORT     Source;

    Source = (PUSHORT) SourceVa;
    Length = Length / 2;

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF);
    }

    return PartialSum;
}
#endif // i386


VOID
HbReadPage (
    IN PFN_NUMBER PageNo,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This function reads the specified page from the hibernation file

Arguments:

    PageNo      - Page number to read

    Buffer      - Buffer to read the data

Return Value:

    On success Buffer, else HbIoError set to TRUE

--*/
{
    ULONG           Status;
    ULONG           Count;
    LARGE_INTEGER   li;

    li.QuadPart = (ULONGLONG) PageNo << PAGE_SHIFT;
    Status = BlSeek (HiberFile, &li, SeekAbsolute);
    if (Status != ESUCCESS) {
        HiberIoError = TRUE;
    }

    Status = BlRead (HiberFile, Buffer, PAGE_SIZE, &Count);
    if (Status != ESUCCESS) {
        HiberIoError = TRUE;
    }
}


BOOLEAN
HbReadNextCompressedPages (
    LONG BytesNeeded,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

    This routine makes sure that BytesNeeded bytes are available
    in CompressedBuffer and brings in more pages from Hiber file
    if necessary.

    All reads from the Hiber file occurr at the file's
    current offset forcing compressed pages to be read
    in a continuous fashion without extraneous file seeks.

Arguments:

   BytesNeeded      - Number of bytes that must be present in CompressedBuffer
   CompressedBuffer - Descriptor of data already brought in

Return Value:

   TRUE if the operation is successful, FALSE otherwise.

--*/
{
    LONG BytesLeft;
    LONG BytesRequested;
    ULONG Status;
    LONG MaxBytes;

    // Obtain number of bytes left in buffer
    BytesLeft = (LONG) (CompressedBuffer->Current.End - CompressedBuffer->Current.Beg);

    // Obtain number of bytes that are needed but not available
    BytesNeeded -= BytesLeft;

    // Preserve amount of bytes caller needs (BytesNeeded may be changed later)
    BytesRequested = BytesNeeded;

    // Do we need to read more?
    if (BytesNeeded <= 0) {
        // No, do nothing
        return(TRUE);
    }

    // Align BytesNeeded on page boundary
    BytesNeeded = (BytesNeeded + PAGE_MASK) & ~PAGE_MASK;

    // Copy left bytes to the beginning of aligned buffer retaining page alignment
    if (BytesLeft == 0) {
        CompressedBuffer->Current.Beg = CompressedBuffer->Current.End = CompressedBuffer->Aligned.Beg;
    } else {
        LONG BytesBeforeBuffer = (LONG)(CompressedBuffer->Aligned.Beg - CompressedBuffer->Buffer.Beg) & ~PAGE_MASK;
        LONG BytesLeftAligned = (BytesLeft + PAGE_MASK) & ~PAGE_MASK;
        LONG BytesToCopy;
        PUCHAR Dst, Src;

        // Find out how many pages we may keep before aligned buffer
        if (BytesBeforeBuffer >= BytesLeftAligned) {
            BytesBeforeBuffer = BytesLeftAligned;
        }

        // Avoid misaligned data accesses during copy
        BytesToCopy = (BytesLeft + 63) & ~63;

        Dst = CompressedBuffer->Aligned.Beg + BytesLeftAligned - BytesBeforeBuffer - BytesToCopy;
        Src = CompressedBuffer->Current.End - BytesToCopy;

        if (Dst != Src) {
            RtlMoveMemory (Dst, Src, BytesToCopy);
            BytesLeftAligned = (LONG) (Dst - Src);
            CompressedBuffer->Current.Beg += BytesLeftAligned;
            CompressedBuffer->Current.End += BytesLeftAligned;
        }
    }

    //
    // Increase the number of bytes read to fill our buffer up to the next
    // 64K boundary.
    //
    MaxBytes = (LONG)((((ULONG_PTR)CompressedBuffer->Current.End + 0x10000) & 0xffff) - (ULONG_PTR)CompressedBuffer->Current.End);
    if (MaxBytes > CompressedBuffer->Buffer.End - CompressedBuffer->Current.End) {
        MaxBytes = (LONG)(CompressedBuffer->Buffer.End - CompressedBuffer->Current.End);
    }
    if (MaxBytes > BytesNeeded) {
        BytesNeeded = MaxBytes;
    }


#if 0
    // for debugging only
    if (0x10000 - (((LONG) CompressedBuffer->Current.End) & 0xffff) < BytesNeeded) {
        BlPrint (("Current.Beg = %p, Current.End = %p, Current.End2 = %p\n",
                  CompressedBuffer->Current.Beg,
                  CompressedBuffer->Current.End,
                  CompressedBuffer->Current.End + BytesNeeded
                 ));
    }
#endif

    // Make sure we have enough space
    if (BytesNeeded > CompressedBuffer->Buffer.End - CompressedBuffer->Current.End) {
        // Too many bytes to read -- should never happen, but just in case...
        DBGOUT (("Too many bytes to read -- corrupted data?\n"));
        return(FALSE);
    }

    // Issue seek if necessary
    if (CompressedBuffer->NeedSeek) {
        LARGE_INTEGER li;
        li.QuadPart = (ULONGLONG) CompressedBuffer->FilePage << PAGE_SHIFT;
        Status = BlSeek (HiberFile, &li, SeekAbsolute);
        if (Status != ESUCCESS) {
            DBGOUT (("Seek to 0x%x error 0x%x\n", CompressedBuffer->FilePage, Status));
            HiberIoError = TRUE;
            return(FALSE);
        }
        CompressedBuffer->NeedSeek = FALSE;
    }

    // Read in stuff from the Hiber file into the available buffer space
    Status = BlRead (HiberFile, CompressedBuffer->Current.End, BytesNeeded, (PULONG)&BytesNeeded);

    // Check for I/O errors...
    if (Status != ESUCCESS || ((ULONG)BytesNeeded & PAGE_MASK) != 0 || (BytesNeeded < BytesRequested)) {
        // I/O Error - FAIL.
        DBGOUT (("Read error: Status = 0x%x, ReadBytes = 0x%x, Requested = 0x%x\n", Status, BytesNeeded, BytesRequested));
        HiberIoError = TRUE;
        return(FALSE);
    }

    // I/O was good - recalculate buffer offsets based on how much
    // stuff was actually read in

    CompressedBuffer->Current.End += (ULONG)BytesNeeded;
    CompressedBuffer->FilePage += ((ULONG)BytesNeeded >> PAGE_SHIFT);

    return(TRUE);
}


BOOLEAN
HbReadNextCompressedBlockHeader (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

   Read next compressed block header if it's Xpress compression.

Arguments:
   Block            - Descriptor of compressed data block

   CompressedBuffer - Descriptor of data already brought in


Return Value:

   TRUE if block is not Xpress block at all or valid Xpress block, FALSE otherwise

--*/
{
    PUCHAR Buffer;
    LONG CompressedSize;         // they all must be signed -- do not change to ULONG
    LONG UncompressedSize;
    ULONG PackedSizes;

    // First make sure next compressed data block header is available
    if (!HbReadNextCompressedPages (XPRESS_HEADER_SIZE, CompressedBuffer)) {
        // I/O error or bad header -- FAIL
        return(FALSE);
    }


    // Set pointer to the beginning of buffer
    Buffer = CompressedBuffer->Current.Beg;

    // Check header magic
    Block->Header.XpressEncoded = (RtlCompareMemory (Buffer, XPRESS_HEADER_STRING, XPRESS_HEADER_STRING_SIZE) == XPRESS_HEADER_STRING_SIZE);

    if (!Block->Header.XpressEncoded) {
        // Not Xpress -- return OK
        return(TRUE);
    }

    // Skip magic string -- we will not need it anymore
    Buffer += XPRESS_HEADER_STRING_SIZE;

    // Read sizes of compressed and uncompressed data
    PackedSizes = Buffer[0] + (Buffer[1] << 8) + (Buffer[2] << 16) + (Buffer[3] << 24);
    CompressedSize = (LONG) (PackedSizes >> 10) + 1;
    UncompressedSize = ((LONG) (PackedSizes & 1023) + 1) << PAGE_SHIFT;

    Block->Header.Compressed.Size = CompressedSize;
    Block->Header.Uncompressed.Size = UncompressedSize;

    // Read checksums
    Block->Header.Uncompressed.Checksum = Buffer[4] + (Buffer[5] << 8);
    Block->Header.Compressed.Checksum = Buffer[6] + (Buffer[7] << 8);

    // Clear space occupied by compressed checksum
    Buffer[6] = Buffer[7] = 0;

    // Make sure sizes are in correct range
    if (UncompressedSize > XPRESS_MAX_SIZE ||
        CompressedSize > UncompressedSize ||
        CompressedSize == 0 ||
        UncompressedSize == 0) {
        // broken input data -- do not even try to decompress

        DBGOUT (("Corrupted header: %02x %02x %02x %02x %02x %02x %02x %02x\n",
                 Buffer[0], Buffer[1], Buffer[2], Buffer[3], Buffer[4], Buffer[5], Buffer[6], Buffer[7]));
        DBGOUT (("CompressedSize = %d, UncompressedSize = %d\n", CompressedSize, UncompressedSize));

        return(FALSE);
    }

    // Xpress header and it looks OK so far
    return(TRUE);
}


BOOLEAN
HbReadNextCompressedBlock (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

   Reads and decompresses the next compressed chunk from the Hiber file
   and stores it in a designated region of virtual memory.

   Since no master data structure exists within the Hiber file to identify
   the location of all of the compression chunks, this routine operates
   by reading sections of the Hiber file into a compression buffer
   and extracting chunks from that buffer.

   Chunks are extracted by determining if a chunk is completely present in the buffer
   using the RtlDescribeChunk API. If the chunk is not completely present,
   more of the Hiber file is read into the buffer until the chunk can
   be extracted.

   All reads from the Hiber file occurr at its current offset, forcing
   compressed chunks to be read in a continous fashion with no extraneous
   seeks.

Arguments:

   Block            - Descriptor of compressed data block
   CompressedBuffer - Descriptor of data already brought in

Return Value:

   TRUE if a chunk has been succesfully extracted and decompressed, FALSE otherwise.

--*/
{
    PUCHAR Buffer;
    LONG CompressedSize;         // they all must be signed -- do not change to ULONG
    LONG AlignedCompressedSize;
    LONG UncompressedSize;


    // First make sure next compressed data block header is available
    if (!HbReadNextCompressedBlockHeader (Block, CompressedBuffer)) {
        // I/O error -- FAIL
        return(FALSE);
    }

    // It must be Xpress
    if (!Block->Header.XpressEncoded) {
#ifdef HIBER_DEBUG
        // Set pointer to the beginning of buffer
        Buffer = CompressedBuffer->Current.Beg;

        // wrong magic -- corrupted data
        DBGOUT (("Corrupted header: %02x %02x %02x %02x %02x %02x %02x %02x\n",
                 Buffer[0], Buffer[1], Buffer[2], Buffer[3], Buffer[4], Buffer[5], Buffer[6], Buffer[7]));
#endif /* HIBER_DEBUG */

        return(FALSE);
    }

    // Read sizes
    UncompressedSize = Block->Header.Uncompressed.Size;
    CompressedSize = Block->Header.Compressed.Size;

    // If not enough space supplied use preallocated buffer
    if (UncompressedSize != Block->DataSize) {
        Block->DataSize = UncompressedSize;
        Block->DataPtr = Block->PreallocatedDataBuffer;
    }

    // Evaluate aligned size of compressed data
    AlignedCompressedSize = (CompressedSize + (XPRESS_ALIGNMENT - 1)) & ~(XPRESS_ALIGNMENT - 1);

    // Make sure we have all compressed data and the header in buffer
    if (!HbReadNextCompressedPages (AlignedCompressedSize + XPRESS_HEADER_SIZE, CompressedBuffer)) {
        // I/O error -- FAIL
        return(FALSE);
    }

    // Set pointer to the beginning of buffer
    Buffer = CompressedBuffer->Current.Beg;

    // We will use some bytes out of buffer now -- reflect this fact
    CompressedBuffer->Current.Beg += AlignedCompressedSize + XPRESS_HEADER_SIZE;

    // evaluate and compare checksum of compressed data and header with written value
    if (Block->Header.Compressed.Checksum != 0) {
        ULONG Checksum;
        Checksum = HbSimpleCheck (0, Buffer, AlignedCompressedSize + XPRESS_HEADER_SIZE);
        if (((Checksum ^ Block->Header.Compressed.Checksum) & 0xffff) != 0) {
            DBGOUT (("Compressed data checksum mismatch (got %08lx, written %08lx)\n", Checksum, Block->Header.Compressed.Checksum));
            return(FALSE);
        }
    }

    // Was this buffer compressed at all?
    if (CompressedSize == UncompressedSize) {
        // Nope, do not decompress it -- set bounds and return OK
        Block->DataPtr = Buffer + XPRESS_HEADER_SIZE;
    } else {
        LONG DecodedSize;

        // Decompress the buffer
        DecodedSize = XpressDecode (NULL,
                                    Block->DataPtr,
                                    UncompressedSize,
                                    UncompressedSize,
                                    Buffer + XPRESS_HEADER_SIZE,
                                    CompressedSize);

        if (DecodedSize != UncompressedSize) {
            DBGOUT (("Decode error: DecodedSize = %d, UncompressedSize = %d\n", DecodedSize, UncompressedSize));
            return(FALSE);
        }
    }

#ifdef HIBER_DEBUG
    // evaluate and compare uncompressed data checksums (just to be sure)
    if (Block->Header.Uncompressed.Checksum != 0) {
        ULONG Checksum;
        Checksum = HbSimpleCheck (0, Block->DataPtr, UncompressedSize);
        if (((Checksum ^ Block->Header.Uncompressed.Checksum) & 0xffff) != 0) {
            DBGOUT (("Decoded data checksum mismatch (got %08lx, written %08lx)\n", Checksum, Block->Header.Uncompressed.Checksum));
            return(FALSE);
        }
    }
#endif /* HIBER_DEBUG */

    return(TRUE);
}


BOOLEAN
HbReadNextCompressedPageLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

    This routine reads in the next compressed page from the
    Hiber file and decompresses it into a designated region
    of virtual memory.

    The page is recreated by assembling it from a series
    a compressed chunks that are assumed to be contiguously
    stored in the Hiber file.

    All reads from the Hiber file occurr at the file's
    current offset forcing compressed pages to be read
    in a continuous fashion without extraneous file seeks.

Arguments:

   DestVa         - The Virtual Address where the decompressed page should
                    be written.
   CompressedBuffer - Descriptor of data already brought in

Return Value:

   TRUE if the operation is successful, FALSE otherwise.

--*/
{
    ULONG ReadTotal;

    // Loop while page is incomplete

    for (ReadTotal = 0; ReadTotal < PAGE_SIZE; ReadTotal += PO_COMPRESS_CHUNK_SIZE) {

        // Get a chunk

        if (!HbReadNextCompressedChunkLZNT1(DestVa, CompressedBuffer)) {
            return FALSE;
        }

        // Move on to the next chunk of the page

        DestVa += PO_COMPRESS_CHUNK_SIZE;
    }

    return TRUE;
}

BOOLEAN
HbReadNextCompressedChunkLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

   Reads and decompresses the next compressed chunk from the Hiber file
   and stores it in a designated region of virtual memory.

   Since no master data structure exists within the Hiber file to identify
   the location of all of the compression chunks, this routine operates
   by reading sections of the Hiber file into a compression buffer
   and extracting chunks from that buffer.

   Chunks are extracted by determining if a chunk is completely present in the buffer
   using the RtlDescribeChunk API. If the chunk is not completely present,
   more of the Hiber file is read into the buffer until the chunk can
   be extracted.

   All reads from the Hiber file occurr at its current offset, forcing
   compressed chunks to be read in a continous fashion with no extraneous
   seeks.

Arguments:

   DestVa            - The virtual address where the decompressed chunk
                       should be written.

   CompressedBuffer  - Descriptor of data already brought in


Return Value:

   TRUE if a chunk has been succesfully extracted and decompressed, FALSE otherwise.

--*/
{
    PUCHAR Buffer;
    NTSTATUS Status;
    ULONG ChunkSize;
    PUCHAR ChunkBuffer;
    ULONG SpaceLeft;

    // Loop until we have accomplished our goal since we may need
    // several operations before a chunk is extracted

    while (1) {

        Buffer = CompressedBuffer->Current.Beg;

        // Check the first unextracted chunk in the buffer

        Status = RtlDescribeChunk(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD,
                                  &Buffer,
                                  CompressedBuffer->Current.End,
                                  &ChunkBuffer,
                                  &ChunkSize);

        switch (Status) {
            case STATUS_SUCCESS:

                // A complete and valid chunk is present in the buffer

                // Decompress the chunk into the proper region of virtual memory

                Status = RtlDecompressBuffer (COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD,
                                              DestVa,
                                              PO_COMPRESS_CHUNK_SIZE,
                                              CompressedBuffer->Current.Beg,
                                              (LONG) (CompressedBuffer->Current.End - CompressedBuffer->Current.Beg),
                                              &ChunkSize);

                if ((!NT_SUCCESS(Status)) || (ChunkSize != PO_COMPRESS_CHUNK_SIZE)) {
                    // Decompression failed

                    return(FALSE);
                } else {
                    // Decompression succeeded, indicate that the chunk following
                    // this one is the next unextracted chunk in the buffer

                    CompressedBuffer->Current.Beg = Buffer;
                    return(TRUE);
                }


            case STATUS_BAD_COMPRESSION_BUFFER:
            case STATUS_NO_MORE_ENTRIES:

                //
                // Buffer does not contain a complete and valid chunk
                //

                //
                // Check how much space remains in the buffer since
                // we will need to read some stuff from the Hiber file
                //

                SpaceLeft = (LONG) (CompressedBuffer->Aligned.End - CompressedBuffer->Aligned.Beg);
                if (SpaceLeft > LZNT1_COMPRESSION_BUFFER_SIZE) {
                    SpaceLeft = LZNT1_COMPRESSION_BUFFER_SIZE;
                }

                SpaceLeft -= (((LONG) (CompressedBuffer->Current.End - CompressedBuffer->Current.Beg)) + PAGE_MASK) & ~PAGE_MASK;
                if (SpaceLeft <= 0) {
                    // Should never happen
                    DBGOUT (("SpaceLeft = %d\n", SpaceLeft));
                    return(FALSE);
                }

                if (!HbReadNextCompressedPages (SpaceLeft, CompressedBuffer)) {
                    // IO error
                    return(FALSE);
                }
                break;

            default:

                //
                // Unhandled RtlDescribeChunk return code - have they changed the function on us?
                //

                return(FALSE);
        }

        //
        // try again with the bigger buffer
        //

    }

    return FALSE;
}


VOID
HexDump (
    IN ULONG    indent,
    IN ULONG    va,
    IN ULONG    len,
    IN ULONG    width,
    IN PUCHAR   buf
    )
{
    TCHAR   s[80], t[80], lstr[200];
    PTCHAR  ps, pt;
    ULONG   i;
    UCHAR   Key;
    static  UCHAR rgHexDigit[] = "0123456789abcdef";

    UNREFERENCED_PARAMETER( width );

    if (HiberIoError) {
        HbPrint (TEXT("*** HiberIoError\n"));
        return ;
    }
    if (HiberOutOfRemap) {
        HbPrint (TEXT("*** HiberOutOfRemap\n"));
        return ;
    }


    i = 0;
    while (len) {
        ps = s;
        pt = t;

        ps[0] = TEXT('\0');
        pt[0] = TEXT('*');
        pt++;

        for (i=0; i < 16; i++) {
            ps[0] = TEXT(' ');
            ps[1] = TEXT(' ');
            ps[2] = TEXT(' ');

            if (len) {
                ps[0] = rgHexDigit[buf[0] >> 4];
                ps[1] = rgHexDigit[buf[0] & 0xf];
                pt[0] = ((TCHAR)buf[0] < TEXT(' ')) || ((TCHAR)buf[0] > TEXT('z')) ? TEXT('.') : buf[0];

                len -= 1;
                buf += 1;
                pt  += 1;
            }
            ps += 3;
        }

        ps[0] = 0;
        pt[0] = TEXT('*');
        pt[1] = 0;
        s[23] = TEXT('-');

        if (s[0]) {
            _stprintf (lstr, TEXT("%*s%08lx: %s  %s\r\n"), indent, TEXT(""), va, s, t);
            HbPrint (lstr);
            va += 16;
        }
    }

    ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &i);
}



BOOLEAN
HbReadDelayedBlock (
    BOOLEAN ForceDecoding,
    PFN_NUMBER DestPage,
    ULONG RangeCheck,
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
{
    LONG i, j;
    BOOLEAN Contig;
    BOOLEAN Ret;

    if (ForceDecoding) {
        if (Block->DelayedCnt == 0) {
            return TRUE;
        }
    } else {
        // If first page to delay read next block info
        if (Block->DelayedCnt <= 0) {
            Ret = HbReadNextCompressedBlockHeader (Block, CompressedBuffer);

            if (HiberIoError || !Ret || !Block->Header.XpressEncoded) {
                // Something is wrong
                return FALSE;
            }
        }

        // remember page info
        Block->Delayed[Block->DelayedCnt].DestPage = DestPage;
        Block->Delayed[Block->DelayedCnt].RangeCheck = RangeCheck;

        // Update counter
        Block->DelayedCnt += 1;

        // Last page that may be delayed?
        if (Block->DelayedCnt != sizeof (Block->Delayed) / sizeof (Block->Delayed[0]) &&
            (Block->DelayedCnt << PAGE_SHIFT) < Block->Header.Uncompressed.Size) {
            // Nope, nothing to do
            return TRUE;
        }
    }

    // Make sure that size of encoded block and # of delayed pages are the same
    if ((Block->DelayedCnt << PAGE_SHIFT) != Block->Header.Uncompressed.Size) {
        DBGOUT (("DelayedCnt = %d, UncompressedSize = %d\n", Block->DelayedCnt, Block->Header.Uncompressed.Size));
        return FALSE;
    }

    // Prepare for mapping. Hopefully mapping will be contiguous
    Contig = TRUE;

    // Map new pages
    for (j = 0; j < Block->DelayedCnt; ++j) {
        i = HbPageDisposition (Block->Delayed[j].DestPage);
        if (i == HbPageInvalid) {
            // Should never happen
            return(FALSE);
        }
        if (i == HbPageNotInUse) {
            Block->Delayed[j].DestVa = HbMapPte(PTE_XPRESS_DEST_FIRST + j, Block->Delayed[j].DestPage);
        } else {
            Block->Delayed[j].DestVa = HbNextSharedPage(PTE_XPRESS_DEST_FIRST + j, Block->Delayed[j].DestPage);
        }
        if (j > 0 && Block->Delayed[j].DestVa != Block->Delayed[j-1].DestVa + PAGE_SIZE) {
            Contig = FALSE;
        }
    }

    // Set pointer to data. Try mapped pages if possible
    if (Contig) {
        Block->DataSize = Block->DelayedCnt << PAGE_SHIFT;
        Block->DataPtr = Block->Delayed[0].DestVa;
    } else {
        // Will have to used preallocated data buffer
        Block->DataSize = Block->Header.Uncompressed.Size;
        Block->DataPtr = Block->PreallocatedDataBuffer;
    }

    // Decode next block
    Ret = HbReadNextCompressedBlock (Block, CompressedBuffer);

    // Check for errors
    if (HiberIoError || !Ret) {
        // Something's seriousely wrong
        return FALSE;
    }

    for (j = 0; j < Block->DelayedCnt; ++j) {

        // Copy block to target address if necessary
        if (Block->Delayed[j].DestVa != Block->DataPtr) {
            RtlCopyMemory (Block->Delayed[j].DestVa, Block->DataPtr, PAGE_SIZE);
        }

        Block->DataPtr += PAGE_SIZE;
        Block->DataSize -= PAGE_SIZE;
    }

    // No more delayed blocks
    Block->DelayedCnt = 0;

    return TRUE;
}


// Allocate data aligned on page boundary
PVOID
HbAllocateAlignedHeap (
    ULONG Size
    )
{
    PCHAR Va;
    Va = BlAllocateHeap (Size + PAGE_MASK);
    if (Va != NULL) {
        Va += ((PAGE_SIZE - (((ULONG_PTR) Va) & PAGE_MASK)) & PAGE_MASK);
    }
    return (Va);
}

//
// structure used to get typecast to 
// function pointer from data pointer 
// to compile w4
// (WakeDispatch)
//
typedef struct {
    PHIBER_WAKE_DISPATCH Dispatch;
} _WAKE_DISPATCH, * _PWAKE_DISPATCH;

ULONG
HbRestoreFile (
    IN PULONG       Information,
    OUT PCHAR       *BadLinkName
    )
{
    PPO_MEMORY_IMAGE        MemImage;
    PPO_IMAGE_LINK          ImageLink;
    PPO_MEMORY_RANGE_ARRAY  Table;
    PHIBER_WAKE_DISPATCH    WakeDispatch = 0;
    ULONG                   Length;
    ULONG                   Check, CheckSum;
    PUCHAR                  p1;
    PUCHAR                  DestVa;
    ULONG                   Index, i;
    PFN_NUMBER              TablePage;
    PFN_NUMBER              DestPage;
    PFN_NUMBER              Scale;
    ULONG                   TotalPages;
    ULONG                   LastBar;
    ULONG                   Sel[4];
    ULONG                   LinkedDrive;
    COMPRESSED_BUFFER       CompressedBufferData;
    PCOMPRESSED_BUFFER      CompressedBuffer = &CompressedBufferData;
    BOOLEAN                 Ret;
    LONG                    XpressEncoded;
    PDECOMPRESSED_BLOCK     Block;
    ULONG                   fPercentage = 0;
    ULONG                   LastPercentage = (ULONG)-1;
    PUCHAR                  Ptr;
    ARC_STATUS              Status;
    ULONG                   ActualBase;
    FILE_INFORMATION        FileInfo;

#if HIBER_PERF_STATS

    ULONG StartTime, EndTime;
    StartTime = ArcGetRelativeTime();

#endif


#if defined (HIBER_DEBUG)
    HbPrint(TEXT("HbRestoreFile\r\n"));
#endif

    *Information = 0;
    HiberBufferPage = 0;
    BlAllocateAlignedDescriptor (LoaderFirmwareTemporary,
                                 0,
                                 1,
                                 1,
                                 &HiberBufferPage);

    CHECK_ERROR (!HiberBufferPage, HIBER_ERROR_NO_MEMORY);
    HiberBuffer = (PUCHAR) (KSEG0_BASE | (((ULONG)HiberBufferPage) << PAGE_SHIFT));

    //
    // Read image header
    //

    HbReadPage (PO_IMAGE_HEADER_PAGE, HiberBuffer);
    MemImage = (PPO_MEMORY_IMAGE) HiberBuffer;

    //
    // If the signature is a link, then follow it
    //

    if (MemImage->Signature == PO_IMAGE_SIGNATURE_LINK) {

        ImageLink = (PPO_IMAGE_LINK) HiberBuffer;

        //
        // Open target partition, and then the hiberfile image on that
        // partition.  If not found, then we're done
        //

        Status = ArcOpen ((char*)ImageLink->Name, ArcOpenReadOnly, &LinkedDrive);
        if (Status != ESUCCESS) {
            if (ARGUMENT_PRESENT(BadLinkName)) {
                *BadLinkName = (char *)(&ImageLink->Name);

                //
                // At this point we want to blast the link signature. The caller
                // may need to load NTBOOTDD to access the real hiberfile. Once
                // this happens there is no turning back as we cannot go back to
                // the BIOS to reread BOOT.INI. By zeroing the signature we ensure
                // that if the restore fails, the next boot will not try to restore
                // it again.
                //
                HbSetImageSignature(0);
            }
            return 0;
        }

        Status = BlOpen (LinkedDrive, (PCHAR)szHiberFileName, ArcOpenReadWrite, &i);
        if (Status != ESUCCESS) {
            ArcClose(LinkedDrive);
            return 0;
        }

        //
        // Switch to linked HiberFile image and continue
        //

        BlClose (HiberFile);
        HiberFile = i;
        HbReadPage (PO_IMAGE_HEADER_PAGE, HiberBuffer);
    }

    //
    // If the image has the wake signature, then we've already attempted
    // to restart this image once.  Check if it should be attempted again
    //

    if (MemImage->Signature == PO_IMAGE_SIGNATURE_WAKE) {

        Sel[0] = HIBER_CANCEL;
        Sel[1] = HIBER_CONTINUE;
        Sel[2] = HIBER_DEBUG_BREAK_ON_WAKE;
        Sel[3] = 0;
        HbScreen(HIBER_RESTART_AGAIN);
        i = HbSelection(PAUSE_X, PAUSE_Y, Sel, 1);
        if (i == 0) {
            HiberAbort = TRUE;
            HbSetImageSignature (0);
            return 0;
        }

        MemImage->Signature = PO_IMAGE_SIGNATURE;
    }

    //
    // If the signature is not valid, then behave as if there's no
    // hibernated context
    //

    if (MemImage->Signature != PO_IMAGE_SIGNATURE) {
        return 0;
    }

#if defined(_X86_)

    //
    // If hiber image is for Amd64, the following call will set 
    // BlAmd64UseLongMode to TRUE. 
    //

    BlCheckForAmd64Image(MemImage);

#endif

    CHECK_ERROR (READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, LengthSelf) > PAGE_SIZE, 
                 HIBER_ERROR_BAD_IMAGE);

    //
    // Copy the image out of the HiberBuffer
    //

    Length = READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, LengthSelf);
    MemImage = BlAllocateHeap(Length);
    CHECK_ERROR (!MemImage, HIBER_ERROR_NO_MEMORY);
    memcpy (MemImage, HiberBuffer, Length);

    HiberImageFeatureFlags = READ_FIELD_ULONG(PO_MEMORY_IMAGE, 
                                              MemImage, 
                                              FeatureFlags);

    //
    // Verify the checksum on the image header
    //

    Check = READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, CheckSum);

    WRITE_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, CheckSum, 0);
    Check = Check - HbSimpleCheck(0, MemImage, Length);
    CHECK_ERROR(Check, HIBER_ERROR_BAD_IMAGE);
    CHECK_ERROR(READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, Version)  != 0, 
                HIBER_IMAGE_INCOMPATIBLE);

    CHECK_ERROR(READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, PageSize) != PAGE_SIZE, 
                HIBER_IMAGE_INCOMPATIBLE);

    //
    // Check to make sure the hiberfil matches with the
    // amount of memory we think we have.  We want to guard
    // against folks who hibernate, then add/remove memory,
    // then try to resume.
    //
    Status = BlGetFileInformation( HiberFile, &FileInfo );

    if( Status == ESUCCESS ) {

        ULONG FileSize;
        ULONG MemorySize;


        //
        // Get the size of the file (in pages).
        // 
        FileSize = (ULONG)(FileInfo.EndingAddress.QuadPart >> PAGE_SHIFT);

        //
        // Get the size of memory (in pages).
        //
        MemorySize = BlDetermineOSVisibleMemory();

        //
        // See if the file size matches the amount of memory we've got
        // in the machine.   Allow for 32MB of slop for hidden memory.
        //
        if( abs(FileSize - MemorySize) > (_24MB) ) {
#if 0
            BlPrint( "Original FileSize: %d pages\n\r", FileSize );
            BlPrint( "Original MemorySize: %d pages\n\r", MemorySize );
            BlPrint( "Press any key to continue\n\r" );
            while( !BlGetKey() );
#endif

            //
            // Put up an error message telling the user
            // the memory configuration doesn't match
            // the hiber file.  If we return from telling
            // the user, then mark the hiber file as
            // invalid so we won't try it again, then
            // proceed.
            //
            HbScreen(HIBER_ERROR);
            HbPrintMsg(HIBER_MEMORY_INCOMPATIBLE);
            Sel[0] = HIBER_CANCEL;
            Sel[1] = 0;
            HbSelection (FAULT_X, FAULT_Y+2, Sel, 0);
            HiberAbort = TRUE;
            HbSetImageSignature (0);
            return 0;
        }
    }

    //
    // Setup mapping information for restore
    //

#if !defined (_ALPHA_) && !defined(_IA64_)
    HiberNoHiberPtes = READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, NoHiberPtes);
    CHECK_ERROR (HiberNoHiberPtes > HIBER_PTES, HIBER_IMAGE_INCOMPATIBLE);
#endif

    HiberNoMappings = READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, NoFreePages);

#if defined (_ALPHA_) || defined(_IA64_)

    HiberImagePageSelf = MemImage->PageSelf;    // used in WakeDispatch to enable break-on-wake

#else


    if(BlAmd64UseLongMode) {
        HiberIdentityVaAmd64 = READ_FIELD_ULONG64 (PO_MEMORY_IMAGE, 
                                                   MemImage, 
                                                   HiberVa);
    } else {
        HiberIdentityVa = (PVOID) MemImage->HiberVa;
    }

    HiberImagePageSelf = READ_FIELD_PFN_NUMBER (PO_MEMORY_IMAGE, 
                                                MemImage, 
                                                PageSelf);

    //
    // Allocate a block of PTEs for restoration work which
    // do not overlap the same addresses needed for the
    // restoration
    //

    //
    // p1 is always initialized to NULL here as HiberVa is NULL at this point.
    //
    p1 = (HiberVa) ? HiberVa + (HIBER_PTES << PAGE_SHIFT) : 0; 

    if(BlAmd64UseLongMode) {
        while (!HiberVa || (HiberIdentityVaAmd64 >= (ULONG64) HiberVa && HiberIdentityVaAmd64 <= (ULONG64) p1)) {
            HbAllocatePtes (HIBER_PTES, &HiberPtes, &HiberVa);
            p1 = HiberVa + (HIBER_PTES << PAGE_SHIFT);
        }
    } else {
        while (!HiberVa || (MemImage->HiberVa >= (ULONG_PTR) HiberVa && MemImage->HiberVa <= (ULONG_PTR) p1)) {
            HbAllocatePtes (HIBER_PTES, &HiberPtes, &HiberVa);
            p1 = HiberVa + (HIBER_PTES << PAGE_SHIFT);
        }
    }

#endif

    //
    // Read in the free page map
    //

    HbReadPage (PO_FREE_MAP_PAGE, HiberBuffer);
    Check = HbSimpleCheck(0, HiberBuffer, PAGE_SIZE);
    CHECK_ERROR (READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, FreeMapCheck) != Check, 
                 HIBER_ERROR_BAD_IMAGE);

    // Set us up to decompress the contents of the hiber file


    // Allocate a buffer for compression work

    //
    // N.B. The compression buffer size must be at least the maximum
    //      compressed size of a single compression chunk.
    //

    // Initialize decompressed data buffer
    Ptr = HbAllocateAlignedHeap (sizeof (*Block) + XPRESS_MAX_SIZE);
    CHECK_ERROR(!Ptr, HIBER_ERROR_NO_MEMORY);
    Block = (PVOID) (Ptr + XPRESS_MAX_SIZE);
    Block->DataSize = 0;
    Block->PreallocatedDataBuffer = Ptr;

    //
    // Allocate compressed data buffer. Change the allocation policy
    // to lowest first in order to get a buffer under 1MB. This saves
    // us from double-buffering all the BIOS transfers.
    //
    Status = BlAllocateAlignedDescriptor(LoaderFirmwareTemporary,
                                         0,
                                         MAX_COMPRESSION_BUFFER_PAGES + MAX_COMPRESSION_BUFFER_EXTRA_PAGES,
                                         0x10000 >> PAGE_SHIFT,
                                         &ActualBase);
    if (Status == ESUCCESS) {
        Ptr = (PVOID)(KSEG0_BASE | (ActualBase  << PAGE_SHIFT));
    } else {
        Ptr = HbAllocateAlignedHeap (MAX_COMPRESSION_BUFFER_SIZE + MAX_COMPRESSION_BUFFER_EXTRA_SIZE);
    }
    CHECK_ERROR(!Ptr, HIBER_ERROR_NO_MEMORY);

    // Initialize compressed data buffer
    CompressedBuffer->Buffer.Beg = Ptr;
    CompressedBuffer->Buffer.End = Ptr + MAX_COMPRESSION_BUFFER_SIZE + MAX_COMPRESSION_BUFFER_EXTRA_SIZE;

    CompressedBuffer->Aligned.Beg = CompressedBuffer->Buffer.Beg;
    CompressedBuffer->Aligned.End = CompressedBuffer->Buffer.End;

    CompressedBuffer->FilePage = 0;
    CompressedBuffer->NeedSeek = TRUE;
    CompressedBuffer->Current.Beg = CompressedBuffer->Current.End = CompressedBuffer->Aligned.Beg;


    // ***************************************************************
    //
    // From here on, there's no memory allocation from the loaders
    // heap.  This is to simplify the booking of whom owns which
    // page.  If the hibernation process is aborted, then the
    // pages used here are simply forgoten and the loader continues.
    // If the hiberation processor completes, we forget about
    // the pages in use by the loader
    //
    // ***************************************************************

#if defined(_ALPHA_) || defined(_IA64_)

    //
    // Initialize the hibernation memory allocation and remap table,
    // using the free page map just read from the hibernation file.
    //

    HbInitRemap((PPFN_NUMBER) HiberBuffer);  // why can't HiberBuffer be a PVOID?

#else   // original (x86) code

    //
    // Set the loader map pointer to the tempory buffer, and get
    // a physical shared page to copy the map to.
    //

    HbMapPte(PTE_MAP_PAGE, HiberBufferPage);
    HbMapPte(PTE_REMAP_PAGE, HiberBufferPage);
    DestVa = HbNextSharedPage(PTE_MAP_PAGE, 0);
    memcpy (DestVa, HiberBuffer, PAGE_SIZE);
    DestVa = HbNextSharedPage(PTE_REMAP_PAGE, 0);

#endif  // Alpha/x86

    //
    // Map in and copy relocatable hiber wake dispatcher
    //

    Length = (ULONG) (&WakeDispatcherEnd - &WakeDispatcherStart);
    p1 = (PUCHAR) &WakeDispatcherStart;

#if defined(_X86_) 
    if(BlAmd64UseLongMode) {
        Length = (ULONG) (&WakeDispatcherAmd64End - &WakeDispatcherAmd64Start);
        p1 = (PUCHAR) &WakeDispatcherAmd64Start;
    }
#endif

    Index = 0;
    while (Length) {
        CHECK_ERROR(PTE_DISPATCHER_START+Index > PTE_DISPATCHER_END, HIBER_INTERNAL_ERROR);
        DestVa = HbNextSharedPage(PTE_DISPATCHER_START+Index, 0);
        if (Index == 0) {
            WakeDispatch = ((_PWAKE_DISPATCH) &DestVa)->Dispatch;
        }

        i = Length > PAGE_SIZE ? PAGE_SIZE : Length;
        memcpy (DestVa, p1, i);
        Length -= i;
        p1 += i;
        Index += 1;
    }

    //
    // Read the hibernated processors context
    //
    // Note we read into the hiber buffer and then copy in order to
    // ensure that the destination of the I/O is legal to transfer into.
    // Busmaster ISA SCSI cards can only access the low 16MB of RAM.
    //

    DestVa = HbNextSharedPage(PTE_HIBER_CONTEXT, 0);
    HbReadPage (PO_PROCESSOR_CONTEXT_PAGE, HiberBuffer);
    memcpy(DestVa, HiberBuffer, PAGE_SIZE);
    Check = HbSimpleCheck(0, DestVa, PAGE_SIZE);
    CHECK_ERROR(READ_FIELD_ULONG(PO_MEMORY_IMAGE, MemImage, WakeCheck) != Check, 
                HIBER_ERROR_BAD_IMAGE);

#if defined(_ALPHA_)
    HiberWakeState = (PKPROCESSOR_STATE)DestVa;
#endif

#if defined(_X86_)

    //
    // Check if OS was in PAE mode
    //

    if (!BlAmd64UseLongMode &&
        ((PKPROCESSOR_STATE)(DestVa))->SpecialRegisters.Cr4 & CR4_PAE) {
        BlUsePae = TRUE;
    }

#endif

    //
    // Perform architecture specific setup for dispatcher, then set
    // the location of first remap past the pages mapped so far
    //
   
    HiberSetupForWakeDispatch ();

    HiberFirstRemap = HiberLastRemap;

    //
    // Restore memory from hibernation image
    //

    TablePage = READ_FIELD_PFN_NUMBER(PO_MEMORY_IMAGE, MemImage, FirstTablePage);
    Table = (PPO_MEMORY_RANGE_ARRAY) HiberBuffer;

    Scale = READ_FIELD_PFN_NUMBER(PO_MEMORY_IMAGE, MemImage, TotalPages) / 
            PERCENT_BAR_WIDTH;
    LastBar = 0;
    TotalPages = 3;

    //
    // Popup "Resuming Windows 2000..." message
    //
    BlSetProgBarCharacteristics(HIBER_UI_BAR_ELEMENT, BLDR_UI_BAR_BACKGROUND);
    BlOutputStartupMsg(BL_MSG_RESUMING_WINDOWS);
    BlOutputTrailerMsg(BL_ADVANCED_BOOT_MESSAGE);

    XpressEncoded = -1;     // unknown encoding (either Xpress or LZNT1)
    Block->DataSize = 0;    // no data left in buffer
    Block->DelayedCnt = 0;  // no delayed blocks
    Block->DelayedChecksum = 0; // delayed checksum = 0;
    Block->DelayedBadChecksum = FALSE;

    while (TablePage) {

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
        SHOWNUM(TablePage);
#endif
        //
        // Do not use HbReadPage if possible -- it issues extra seek
        // (usually 5-6 ms penalty) -- use sequential read if possible
        //
        if (CompressedBuffer->FilePage == 0 ||
            TablePage > CompressedBuffer->FilePage ||
            TablePage < CompressedBuffer->FilePage - (PFN_NUMBER) ((CompressedBuffer->Current.End - CompressedBuffer->Current.Beg) >> PAGE_SHIFT)) {
            //
            // Cannot read table page from current buffer -- need to seek
            // and reset the buffer (should happen on very first entry only)
            //

            CompressedBuffer->FilePage = TablePage;
            CompressedBuffer->Current.Beg = CompressedBuffer->Current.End = CompressedBuffer->Aligned.Beg;
            CompressedBuffer->NeedSeek = TRUE;
        }


        //
        // Shift current pointer to the page we need
        //
        CompressedBuffer->Current.Beg = CompressedBuffer->Current.End - ((CompressedBuffer->FilePage - TablePage) << PAGE_SHIFT);

        //
        // Make sure the page is in
        //
        Ret = HbReadNextCompressedPages (PAGE_SIZE, CompressedBuffer);

        CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
        CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);

        //
        // Copy table page to target location and adjust input pointer
        //
        RtlCopyMemory (Table, CompressedBuffer->Current.Beg, PAGE_SIZE);
        CompressedBuffer->Current.Beg += PAGE_SIZE;

        Check = READ_FIELD_ULONG(PO_MEMORY_RANGE_ARRAY_LINK, 
                                 Table, 
                                 CheckSum);
        if (Check) {
            WRITE_FIELD_ULONG(PO_MEMORY_RANGE_ARRAY_LINK, 
                              Table, 
                              CheckSum,
                              0);

            Check = Check - HbSimpleCheck(0, Table, PAGE_SIZE);
            CHECK_ERROR(Check, HIBER_ERROR_BAD_IMAGE);
        }

        // Check the first block magic to see whether it LZNT1 or Xpress
        if (XpressEncoded < 0) {
            Ret = HbReadNextCompressedBlockHeader (Block, CompressedBuffer);

            CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
            CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);

            // Remember the mode
            XpressEncoded = (BOOLEAN) (Block->Header.XpressEncoded);
        }


        for(Index=1; 
            Index <= READ_FIELD_ULONG(PO_MEMORY_RANGE_ARRAY_LINK, Table, EntryCount);
            Index++) {

            Check = 0;
            DestPage = READ_ELEMENT_FIELD_PFN_NUMBER(
                           PO_MEMORY_RANGE_ARRAY_RANGE, 
                           Table, 
                           Index, 
                           StartPage
                           );
 
            while (DestPage < READ_ELEMENT_FIELD_PFN_NUMBER(
                                  PO_MEMORY_RANGE_ARRAY_RANGE, 
                                  Table, 
                                  Index, 
                                  EndPage)) {

                if (!XpressEncoded) {
                    // LZNT1 encoding -- do one page at a time

                    //
                    // If this page conflicts with something in the
                    // loader, then use the next mapping
                    //

                    i = HbPageDisposition (DestPage);
                    CHECK_ERROR(i == HbPageInvalid, HIBER_ERROR_BAD_IMAGE);
                    if (i == HbPageNotInUse) {
                        DestVa = HbMapPte(PTE_DEST, DestPage);
                    } else {
                        DestVa = HbNextSharedPage(PTE_DEST, DestPage);
                    }

                    Ret = HbReadNextCompressedPageLZNT1 (DestVa, CompressedBuffer);

                    CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
                    CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);
                    Check = HbSimpleCheck(Check, DestVa, PAGE_SIZE);
                } else {

                    CheckSum = READ_ELEMENT_FIELD_ULONG(
                                   PO_MEMORY_RANGE_ARRAY_RANGE, 
                                   Table, 
                                   Index, 
                                   CheckSum
                                   );

                    Ret = HbReadDelayedBlock (FALSE,
                                              DestPage,
                                              CheckSum,
                                              Block,
                                              CompressedBuffer);

                    CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
                    CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);
                }

                // Update counters
                DestPage += 1;
                TotalPages += 1;

                fPercentage = (ULONG)((TotalPages * 100) / 
                              READ_FIELD_PFN_NUMBER (PO_MEMORY_IMAGE, MemImage, TotalPages));

                if (fPercentage != LastPercentage) {
                    BlUpdateProgressBar(fPercentage);
                    HbCheckForPause();
                    LastPercentage = fPercentage;
                }
            }

            CHECK_ERROR(HiberOutOfRemap, HIBER_ERROR_OUT_OF_REMAP);

            //
            // Verify checksum on range, but allow continuation with debug flag
            //

            CheckSum = READ_ELEMENT_FIELD_ULONG (PO_MEMORY_RANGE_ARRAY_RANGE, 
                                                 Table,  
                                                 Index, 
                                                 CheckSum);

            if (!XpressEncoded && Check != CheckSum) {
                Block->DelayedBadChecksum = TRUE;
            }

            if (Block->DelayedBadChecksum && !HiberBreakOnWake) {
                ChecksumError:

                Block->DelayedBadChecksum = FALSE;

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)

                {
                    TCHAR lstr[80];

                    HbPrint (TEXT("\r\n"));
                    _stprintf (lstr, 
                             TEXT("TP:%x  IDX:%x  FP:%x  SP:%x  EP:%x  CHK:%x-%x\r\n"),
                             TablePage,
                             Index,
                             READ_ELEMENT_FIELD_PFN_NUMBER(PO_MEMORY_RANGE_ARRAY_RANGE, Table, Index, PageNo),
                             READ_ELEMENT_FIELD_PFN_NUMBER(PO_MEMORY_RANGE_ARRAY_RANGE, Table, Index, StartPage),
                             READ_ELEMENT_FIELD_PFN_NUMBER(PO_MEMORY_RANGE_ARRAY_RANGE, Table, Index, EndPage),
                             READ_ELEMENT_FIELD_ULONG(PO_MEMORY_RANGE_ARRAY_RANGE, Table, Index, CheckSum),
                             Check );
                    HbPrint(lstr);
                    HexDump (2, (DestPage-1) << PAGE_SHIFT, 0x100, 4, DestVa);
                }
#endif

#ifdef HIBER_DEBUG
                DBGOUT ((TEXT("Checksum error\n")));
                HbPause ();
#endif

                HbScreen(HIBER_ERROR);
                HbPrintMsg(HIBER_ERROR_BAD_IMAGE);
                Sel[0] = HIBER_CANCEL;
                Sel[1] = HIBER_DEBUG_BREAK_ON_WAKE;
                Sel[2] = 0;
                i = HbSelection (FAULT_X, FAULT_Y, Sel, 1);
                if (i == 0) {
                    HiberAbort = TRUE;
                    HbSetImageSignature (0);
                    return 0;
                }
            }
        }

        TablePage = READ_FIELD_PFN_NUMBER (PO_MEMORY_RANGE_ARRAY_LINK, 
                                           Table, 
                                           NextTable);
    }

    // Process the rest of delayed pages if necessary
    if (XpressEncoded > 0) {
        Ret = HbReadDelayedBlock (TRUE,
                                  0,
                                  0,
                                  Block,
                                  CompressedBuffer);

        CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
        CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);

        if (Block->DelayedBadChecksum) {
            goto ChecksumError;
        }
    }

    //
    // Set the image signature to wake
    //

    HbSetImageSignature (PO_IMAGE_SIGNATURE_WAKE);

#if HIBER_PERF_STATS

    EndTime = ArcGetRelativeTime();
    BlPositionCursor(BAR_X, BAR_Y + 5);
    HbPrint(TEXT("HIBER: Restore File took "));
    HbPrintNum(EndTime - StartTime);
    HbPrint(TEXT("\r\n"));
    HbPause();

#endif

    //
    // Check hiber flags to see if it is necessary to reconnect APM 
    // or enable no-execute feature
    //

    if (READ_FIELD_UCHAR(PO_MEMORY_IMAGE, MemImage, HiberFlags) & 
        PO_HIBER_NO_EXECUTE) {
	
        HiberNoExecute = TRUE;
    }

    if (READ_FIELD_UCHAR(PO_MEMORY_IMAGE, MemImage, HiberFlags) & 
        PO_HIBER_APM_RECONNECT) {

        //
        // attempt apm restart
        //

        DoApmAttemptReconnect();
    }

    //
    // Use architecture specific relocatable code to perform the final wake dispatcher
    //

    if (WakeDispatch) {
        WakeDispatch();
    }
    CHECK_ERROR (TRUE, HIBER_INTERNAL_ERROR);
}

VOID
HbSetImageSignature (
    IN ULONG    NewSignature
    )
{
    LARGE_INTEGER   li;
    ULONG           Count, Status;

    li.QuadPart = 0;
    Status = BlSeek (HiberFile, &li, SeekAbsolute);
    if (Status == ESUCCESS) {
        BlWrite (HiberFile, &NewSignature, sizeof(ULONG), &Count);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\osloader.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    osloader.c

Abstract:

    This module contains the code that implements the NT operating system
    loader.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bldr.h"
#include "bldrint.h"
#include "ctype.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "msg.h"
#include "cmp.h"
#include "ramdisk.h"

#include "cpyuchr.h"
#include "fat.h"

#include <netboot.h>
#include <ntverp.h>
#include <ntiodump.h>

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif
#include "blcache.h"

#include "vmode.h"
#include "ximagdef.h"


#define PAGEFILE_SYS    ("\\pagefile.sys")
typedef PUCHAR PBYTE;

#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
__declspec(allocate(".base"))
extern
PVOID __ImageBase;
#else
extern
PVOID __ImageBase;
#endif


#if DBG
#define NtBuildNumber   (VER_PRODUCTBUILD | 0xC0000000)
#else
#define NtBuildNumber (VER_PRODUCTBUILD | 0xF0000000)
#endif

//
// These are the paths we will search through during a LastKnownGood boot.
// Note that each LastKnownGood path must be of 8.3 form as the FastFat
// boot code currently doesn't support long file names (bletch).
//
// The temporary path exists only between SMSS's start and login. It contains
// everything that was saved as part of the last good boot. The working path
// contains all the backups from this boot, and is the path SetupApi saves
// things to.
//
#define LAST_KNOWN_GOOD_TEMPORARY_PATH  "LastGood.Tmp"
#define LAST_KNOWN_GOOD_WORKING_PATH    "LastGood"

//
// Long term work-item, make "system64" work on Win64.
//
#define SYSTEM_DIRECTORY_PATH "system32"


#ifdef ARCI386
TCHAR OutputBuffer[256];
char BreakInKey;
ULONG Count;
UCHAR OsLoaderVersion[] = "ARCx86 OS Loader V5.20\r\n";
WCHAR OsLoaderVersionW[] = L"ARCx86 OS Loader V5.20\r\n";
#else
UCHAR OsLoaderVersion[] = "OS Loader V5.20\r\n";
WCHAR OsLoaderVersionW[] = L"OS Loader V5.20\r\n";
#endif
#if defined(_IA64_)
UCHAR OsLoaderName[] = "ia64ldr.efi";
#else
UCHAR OsLoaderName[] = "osloader.exe";
#endif

CHAR KernelFileName[8+1+3+1]="ntoskrnl.exe";
CHAR HalFileName[8+1+3+1]="hal.dll";

CHAR KdFileName[8+1+3+1]="KDCOM.DLL";
BOOLEAN UseAlternateKdDll = FALSE;
#define KD_ALT_DLL_PREFIX_CHARS 2
#define KD_ALT_DLL_REPLACE_CHARS 6

//
// progress bar variables  (defined in blload.c)
//
extern int      BlNumFilesLoaded;
extern int      BlMaxFilesToLoad;
extern BOOLEAN  BlOutputDots;
extern BOOLEAN  BlShowProgressBar;
extern ULONG    BlStartTime;

BOOLEAN isOSCHOICE = FALSE;

#if defined(_X86_)

//
// XIP variables
//
BOOLEAN   XIPEnabled;
BOOLEAN   XIPBootFlag;
BOOLEAN   XIPReadOnlyFlag;
PCHAR     XIPLoadPath;

PFN_COUNT XIPPageCount;
PFN_COUNT XIPBasePage;

ARC_STATUS
Blx86CheckForPaeKernel(
    IN BOOLEAN UserSpecifiedPae,
    IN BOOLEAN UserSpecifiedNoPae,
    IN PCHAR UserSpecifiedKernelImage,
    IN PCHAR HalImagePath,
    IN ULONG LoadDeviceId,
    IN ULONG SystemDeviceId,
    OUT PULONG HighestSystemPage,
    OUT PBOOLEAN UsePaeMode,
    IN OUT PCHAR KernelPath
    );

ARC_STATUS
BlpCheckVersion(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath
    );

#endif


//
// Define transfer entry of loaded image.
//

typedef
VOID
(*PTRANSFER_ROUTINE) (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );


PVOID
BlLoadDataFile(
    IN ULONG DeviceId,
    IN PCHAR LoadDevice,
    IN PCHAR SystemPath,
    IN PUNICODE_STRING Filename,
    IN MEMORY_TYPE MemoryType,
    OUT PULONG FileSize
    );

ARC_STATUS
BlLoadTriageDump(
    IN ULONG DriveId,
    OUT PVOID * DumpHeader
    );

VOID
putwS(
    PUNICODE_STRING String
    );

#if defined(_X86_)

BOOLEAN
BlAmd64RemapDram (
    IN PCHAR LoaderOptions
    );

#endif

#if defined(_IA64_)

VOID
BuildArcTree();

#endif // defined(_IA64_)

//
// Define local static data.
//


PCHAR ArcStatusCodeMessages[] = {
    "operation was success",
    "E2BIG",
    "EACCES",
    "EAGAIN",
    "EBADF",
    "EBUSY",
    "EFAULT",
    "EINVAL",
    "EIO",
    "EISDIR",
    "EMFILE",
    "EMLINK",
    "ENAMETOOLONG",
    "ENODEV",
    "ENOENT",
    "ENOEXEC",
    "ENOMEM",
    "ENOSPC",
    "ENOTDIR",
    "ENOTTY",
    "ENXIO",
    "EROFS",
};

//
// Diagnostic load messages
//

VOID
BlFatalError(
    IN ULONG ClassMessage,
    IN ULONG DetailMessage,
    IN ULONG ActionMessage
    );

VOID
BlBadFileMessage(
    IN PCHAR BadFileName
    );

//
// Define external static data.
//

BOOLEAN BlConsoleInitialized = FALSE;
ULONG BlConsoleOutDeviceId = ARC_CONSOLE_OUTPUT;
ULONG BlConsoleInDeviceId = ARC_CONSOLE_INPUT;
ULONG BlDcacheFillSize = 32;

BOOLEAN BlRebootSystem = FALSE;
ULONG BlVirtualBias = 0;
BOOLEAN BlUsePae = FALSE;

//++
//
// PULONG
// IndexByUlong(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index ULONGs into Pointer. That is,
//     Index * sizeof (ULONG) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of ULONGs to index into.
//
// Return Value:
//
//     PULONG representing the pointer described above.
//
//--

#define IndexByUlong(Pointer,Index) (&(((ULONG*) (Pointer)) [Index]))


//++
//
// PBYTE
// IndexByByte(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index BYTEs into Pointer. That is,
//     Index * sizeof (BYTE) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of BYTEs to index into.
//
// Return Value:
//
//     PBYTE representing the pointer described above.
//
//--

#define IndexByByte(Pointer, Index) (&(((UCHAR*) (Pointer)) [Index]))


ARC_STATUS
BlLoadTriageDump(
    IN ULONG DriveId,
    OUT PVOID * TriageDumpOut
    )

/*++

Routine Description:

    Load the triage dump, if it exists; return an error value otherwise.

Arguments:

    DriveId - The device where we should check for the triage dump.

    TriageDumpOut - Where the triage dump pointer is copied to on success.

Return Value:

    ESUCCESS - If there was a triage dump and the dump information was
            successfully copied into pTriageDump.

    ARC_STATUS - Otherwise.

--*/


{
    ARC_STATUS Status;
    PMEMORY_DUMP MemoryDump = NULL;
    ULONG PageFile = BL_INVALID_FILE_ID;
    ULONG Count, actualBase;
    PBYTE Buffer = NULL, NewBuffer = NULL;

    //
    // Fill in the TriageDump structure
    //

    Status = BlOpen (DriveId, PAGEFILE_SYS, ArcOpenReadOnly, &PageFile);

    if (Status != ESUCCESS) {
        goto _return;
    }

    //
    // Allocate the buffer for the triage dump.
    //

    Buffer = (PBYTE) BlAllocateHeap (SECTOR_SIZE);

    if (!Buffer) {
        Status = ENOMEM;
        goto _return;
    }

    //
    // Read the first SECTOR_SIZE of the pagefile.
    //

    Status = BlRead (PageFile, Buffer, SECTOR_SIZE, &Count);

    if (Status != ESUCCESS || Count != SECTOR_SIZE) {
        Status = EINVAL;
        goto _return;
    }

    MemoryDump = (PMEMORY_DUMP) Buffer;

    if (MemoryDump->Header.ValidDump != DUMP_VALID_DUMP ||
        MemoryDump->Header.Signature != DUMP_SIGNATURE ||
        MemoryDump->Header.DumpType != DUMP_TYPE_TRIAGE) {

        //
        // Not a valid dump file.
        //

        Status = EINVAL;
        goto _return;
    }

    Status = BlAllocateDescriptor (LoaderOsloaderHeap,0,BYTES_TO_PAGES(TRIAGE_DUMP_SIZE) ,&actualBase);

    if (!actualBase || (Status != STATUS_SUCCESS)) {
        Status = ENOMEM;
        goto _return;
    }

    NewBuffer = (PBYTE)(KSEG0_BASE | (actualBase << PAGE_SHIFT));

    //
    // Read the first TRIAGE_DUMP_SIZE of the pagefile.
    //

    Status = BlReadAtOffset (PageFile, 0,TRIAGE_DUMP_SIZE,NewBuffer);

    if (Status != ESUCCESS) {
        Status = EINVAL;
        goto _return;
    }

    MemoryDump = (PMEMORY_DUMP) NewBuffer;


    //
    // Does the dump have a valid signature.
    //

    if (MemoryDump->Triage.ValidOffset > (TRIAGE_DUMP_SIZE - sizeof (ULONG)) ||
        *(ULONG *)IndexByByte (Buffer, MemoryDump->Triage.ValidOffset) != TRIAGE_DUMP_VALID) {

        Status = EINVAL;
        goto _return;
    }


    Status = ESUCCESS;

_return:

    if (PageFile != BL_INVALID_FILE_ID) {
        BlClose (PageFile);
        PageFile = BL_INVALID_FILE_ID;
    }


    if (Status != ESUCCESS && Buffer) {

        Buffer = NULL;
        MemoryDump = NULL;
    }

    *TriageDumpOut = MemoryDump;

    return Status;
}


ARC_STATUS
BlInitStdio (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv
    )

{

    PCHAR ConsoleOutDevice;
    PCHAR ConsoleInDevice;
    ULONG Status;

    if (BlConsoleInitialized) {
        return ESUCCESS;
    }

    //
    // initialize the progress bar
    //
    // BlShowProgressBar = TRUE;
    if( BlIsTerminalConnected() ) {
        BlShowProgressBar = TRUE;
        DisplayLogoOnBoot = FALSE;
    }

    //
    // Get the name of the console output device and open the device for
    // write access.
    //
    ConsoleOutDevice = BlGetArgumentValue(Argc, Argv, "consoleout");
    if ((ConsoleOutDevice == NULL) && !BlIsTerminalConnected()) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleOutDevice, ArcOpenWriteOnly, &BlConsoleOutDeviceId);
    if ((Status != ESUCCESS) && !BlIsTerminalConnected()) {
        return Status;
    }

    //
    // Get the name of the console input device and open the device for
    // read access.
    //
    ConsoleInDevice = BlGetArgumentValue(Argc, Argv, "consolein");
    if ((ConsoleInDevice == NULL) && !BlIsTerminalConnected()) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleInDevice, ArcOpenReadOnly, &BlConsoleInDeviceId);
    if ((Status != ESUCCESS) && !BlIsTerminalConnected()) {
        return Status;
    }

    BlConsoleInitialized = TRUE;

    return ESUCCESS;
}

int
Blatoi(
    char *s
    )
{
    int digval = 0;
    int num = 0;
    char *n;

    num = 0;
    for (n=s; *n; n++) {
        if (isdigit((int)(unsigned char)*n)) {
            digval = *n - '0';
        } else if (isxdigit((int)(unsigned char)*n)) {
            digval = toupper(*n) - 'A' + 10;
        } else {
            digval = 0;
        }
        num = num * 16 + digval;
    }

    return num;
}


PCHAR
BlTranslateSignatureArcName(
    IN PCHAR ArcNameIn
    )

/*++

Routine Description:

    This function's purpose is to translate a signature based arc
    name to a scsi based arc name.  The 2 different arc name syntaxes
    are as follows:

        scsi(28111684)disk(0)rdisk(0)partition(1)
        scsi(1)disk(0)rdisk(0)partition(1)

    Both of these arc names are really the same disk, the first uses
    the disk's signature and the second uses the scsi bus number.  This
    function translates the signature arc name by interating thru all
    of the scsi buses that the loaded scsi miniport supports.  If it
    finds a signature match then the arc name is changed to use the
    correct scsi bus number.  This problem occurs because the boot loader
    only loads one scsi miniport and therefore only sees the buses
    attached to it's devices.  If you have a system with multiple
    scsi adapters of differing type, like an adaptec and a symbios logic,
    then there is a high probability that the boot loader will see the
    buses in a different order than the nt executive will and the
    system will not boot.

Arguments:

    ArcNameIn - Supplies the signature based arc name

Return Value:

    Success - Valid pointer to a scsi based arcname.
    Failure - NULL pointer

--*/

{
#if defined(_X86_)
    extern ULONG ScsiPortCount;
    PCHAR s,p;
    ULONG sigval;
    ULONG Signature;
    int found = -1;
    ULONG i;
    ARC_STATUS Status;
    ULONG DriveId;
    CHAR Buffer[2048+256];
    CHAR ArcName[128];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    PCONFIGURATION_COMPONENT target;
    PCONFIGURATION_COMPONENT lun;
    CHAR devicePath[117];
    BOOLEAN gotPath;
    USHORT mbrSig;


    if (_strnicmp( ArcNameIn, "signature(", 10 ) != 0) {
        //
        // not a signature based name so leave
        //
        return NULL;
    }

    s = strchr( ArcNameIn, '(' );
    p = strchr( ArcNameIn, ')' );

    if (s == NULL || p == NULL) {
        return NULL;
    }

    *p = 0;
    sigval = Blatoi( s+1 );
    *p = ')';

    if (sigval == 0) {
        return NULL;
    }

    Sector = ALIGN_BUFFER(Buffer);

    for (i=0; i < ScsiPortCount; i++) {
        target = ScsiGetFirstConfiguredTargetComponent(i);
        while (target != NULL) {
            lun = ScsiGetFirstConfiguredLunComponent(target);
            while (lun != NULL) {
                gotPath = ScsiGetDevicePath(i, target, lun, devicePath);
                if (gotPath == FALSE) {
                    break;
                }
                sprintf(ArcName, "%spartition(0)", devicePath);
                Status = ArcOpen( ArcName, ArcOpenReadOnly, &DriveId );
                if (Status == ESUCCESS) {
                    SeekValue.QuadPart = 0;
                    Status = ArcSeek(DriveId, &SeekValue, SeekAbsolute);
                    if (Status == ESUCCESS) {
                        Status = ArcRead( DriveId, Sector, 512, &Count );
                        if (Status == ESUCCESS && Count == 512) {
                            mbrSig =
                               ((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET];
                            Signature =
                               ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1];
                            if (mbrSig == BOOT_RECORD_SIGNATURE &&
                                Signature == sigval) {
                                found = i;
                                ArcClose(DriveId);
                                goto SigFound;
                            }
                        }
                    }
                    ArcClose(DriveId);
                }
                lun = ScsiGetNextConfiguredLunComponent(lun);
            }
            target = ScsiGetNextConfiguredTargetComponent(target);
        }
    }

SigFound:

    if (found == -1) {
        //
        // the signature in the arcname is bogus
        //
        return NULL;
    }

    //
    // if we get here then we have an arc name with a
    // good signature in it, so now we can generate
    // a good arc name
    //

    p = strstr(ArcNameIn, "partition(");
    if (p == NULL) {
        ASSERT(FALSE);
        return NULL;
    }

    if ( sizeof(Buffer) < strlen(devicePath) + strlen(p) + 1 ) {
        return NULL;
    }
    strcpy(Buffer, devicePath);
    strcat(Buffer, p);

    p = (PCHAR)BlAllocateHeap( strlen(Buffer) + 1 );
    if (p) {
        strcpy( p, Buffer );
    }

    return p;
#else
    UNREFERENCED_PARAMETER(ArcNameIn);

    return NULL;
#endif
}


#if defined(_X86_)
VOID FLUSH_TB();
VOID ENABLE_PSE();

#define _8kb         ( 8*1024)
#define _32kb        (32*1024)
#define _4mb         (4*1024*1024)
#define _4mb_pages   (_4mb >> PAGE_SHIFT)


ARC_STATUS
XipLargeRead(
    ULONG     FileId,
    PFN_COUNT BasePage,
    PFN_COUNT PageCount
    )
/*++

Routine Description:

    Initialize the XIP 'ROM' by reading from disk.

Arguments:

    FileId - The file used to initialize for XIP.

    BasePage - PFN of the first XIP Rom page.

    PageCount - Number of XIP Rom pages.

Return Value:

    ESUCCESS returned if all goes well.

--*/
{
    PHARDWARE_PTE PDE_VA = (PHARDWARE_PTE)PDE_BASE;

    ARC_STATUS    status = ESUCCESS;
    PHARDWARE_PTE pde;
    HARDWARE_PTE  zproto, proto;

    PBYTE         baseaddr, curraddr, copybuffer;
    ULONG         fileoffset;
    ULONG         count;

    ULONG         tcount;
    ULONG         paddingbytes;
    int           i, n;

    copybuffer = NULL;

    //
    // Look for a zero PDE entry starting at entry 128 (address 512MB).
    //

    pde = PDE_VA + 128;
    baseaddr = (PUCHAR)(128*_4mb);

    for (i = 0;  i < 32;  i++) {
        if (*(PULONG)pde == 0) {
            break;
        }
        pde++;
        baseaddr += _4mb;
    }

    if (i == 32) {
        return ENOMEM;
    }

    //
    // Have to enable 4MB pages in cr4 in order to use them in the PDE
    //
    ENABLE_PSE();

    //
    // Initialize the pte prototypes.
    //
    *(PULONG)&zproto = 0;
    proto = zproto;

    proto.Write = 1;
    proto.LargePage = 1;
    proto.Valid = 1;

    //
    //Use intermediate 8KB buffer and read in smaller chunks.
    //
    copybuffer = (PBYTE) BlAllocateHeap (TRIAGE_DUMP_SIZE);
    if (!copybuffer) {
        return ENOMEM;
    }

    //
    // Map the XIP memory 4MB at a time.
    // Read in the file 8KB at a time.
    // Don't exceed the PageCount.
    //
    fileoffset = 0;
    do {
        //
        // Reset the curraddr to the beginning of the buffer.
        // Set the PFN in the 4MB pte and flush the TLB
        //
        curraddr = baseaddr;

        proto.PageFrameNumber = BasePage;
        *pde = proto;
        FLUSH_TB();

        //
        // Adjust the BasePage and PageCount values for the next iteration
        //
        BasePage += _4mb_pages;

        if (PageCount < _4mb_pages) {
            PageCount = 0;
        } else {
            PageCount -= _4mb_pages;
        }

        //
        // Read in the next 4MB in 8KB chunks.
        //
        n = _4mb / _8kb;
        while (n--) {
            status = BlRead(FileId, (PVOID)copybuffer, _8kb, &count);

            //
            // Just give up on an error.
            //
            if (status != ESUCCESS) {
                goto done;
            }

            //
            // If not the first read (or a short read)
            // the copy is simple.
            //
            if (fileoffset > 0 || count < _8kb) {
                RtlCopyMemory( (PVOID)curraddr, (PVOID)copybuffer, count );
                curraddr += count;
                fileoffset += count;

                if (count < _8kb) {
                    goto done;
                }

            } else {
                //
                // Process boot sector.  Need to pad out ReservedSectors
                // to align clusters on a page boundary.
                //
                PPACKED_BOOT_SECTOR  pboot;
                BIOS_PARAMETER_BLOCK bios;
                ULONG                newReservedSectors;

                pboot = (PPACKED_BOOT_SECTOR)copybuffer;
                FatUnpackBios(&bios, &pboot->PackedBpb);

                if (bios.BytesPerSector != SECTOR_SIZE
                 || FatBytesPerCluster(&bios) != PAGE_SIZE) {
                    goto done;
                }

                //
                // Compute how much paddint is required and update the ReservedSectors field.
                //
                paddingbytes = PAGE_SIZE - (FatFileAreaLbo(&bios) & (PAGE_SIZE-1));
                if (paddingbytes < PAGE_SIZE) {
                    newReservedSectors = (FatReservedBytes(&bios) + paddingbytes) / SECTOR_SIZE;
                    pboot->PackedBpb.ReservedSectors[0] = (UCHAR) (newReservedSectors & 0xff);
                    pboot->PackedBpb.ReservedSectors[1] = (UCHAR) (newReservedSectors >> 8);
                }

                //
                // Copy the boot block.
                // Add padding.
                // Copy the rest of the read buffer.
                // Read in a short page to get us back on track.
                //
                RtlCopyMemory( (PVOID)curraddr, (PVOID)copybuffer, SECTOR_SIZE );
                curraddr += SECTOR_SIZE;

                RtlZeroMemory( (PVOID)curraddr, paddingbytes );
                curraddr += paddingbytes;

                RtlCopyMemory( (PVOID)curraddr, (PVOID) (copybuffer + SECTOR_SIZE), count - SECTOR_SIZE );
                curraddr += (count - SECTOR_SIZE);

                status = BlRead(FileId, (PVOID)copybuffer, count - paddingbytes, &tcount);
                if (status != ESUCCESS || tcount != count - paddingbytes) {
                    goto done;
                }

                RtlCopyMemory( (PVOID)curraddr, (PVOID)copybuffer, count - paddingbytes );
                curraddr += (count - paddingbytes);

                fileoffset += (2*count - paddingbytes);;

                //
                // We decrement n again, since we have eaten up another 8KB of the 4MB mapping.
                //
                n--;
            }
        }
    } while (PageCount);

done:
    //
    // Unmap the current 4MB chunk and flush the TB
    //
    *pde = zproto;
    FLUSH_TB();

    //
    // Free the temporary copy buffer
    //
    if (copybuffer) {
        ;
    }

    return status;
}
#endif //_X86_




ARC_STATUS
BlOsLoader (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Envp
    )

/*++

Routine Description:

    This is the main routine that controls the loading of the NT operating
    system on an ARC compliant system. It opens the system partition,
    the boot partition, the console input device, and the console output
    device. The NT operating system and all its DLLs are loaded and bound
    together. Control is then transfered to the loaded system.

Arguments:

    Argc - Supplies the number of arguments that were provided on the
        command that invoked this program.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    Envp - Supplies a pointer to a vector of pointers to null terminated
        environment variables.

Return Value:

    EBADF is returned if the specified OS image cannot be loaded.

--*/

{

    ULONG CacheLineSize;
    PCONFIGURATION_COMPONENT_DATA DataCache;
    CHAR DeviceName[256];
    CHAR DevicePrefix[256];
    PCHAR DirectoryEnd;
    CHAR KdDllName[256];
    PCHAR FileName;
    ULONG FileSize;
    BOOLEAN KdDllLoadFailed;
    PKLDR_DATA_TABLE_ENTRY KdDataTableEntry = NULL;
    PKLDR_DATA_TABLE_ENTRY HalDataTableEntry;
    PCHAR LoadDevice;
    ULONG LoadDeviceId;
    CHAR LoadDevicePath[256];
    CHAR LoadDeviceLKG1Path[256];
    CHAR LoadDeviceLKG2Path[256];
    FULL_PATH_SET LoadDevicePathSet;
    PCHAR SystemDevice;
    ULONG SystemDeviceId;
    CHAR SystemDevicePath[256];
    FULL_PATH_SET SystemDevicePathSet;
    CHAR KernelDirectoryPath[256];
    FULL_PATH_SET KernelPathSet;
    CHAR KernelPathName[256];
    CHAR HalPathName[256];
    PVOID HalBase;
    PVOID KdDllBase;
#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)
    PVOID LoaderBase;
    PMEMORY_DESCRIPTOR ProgramDescriptor;
#endif
    PVOID SystemBase;
    ULONG Index;
    ULONG Limit;
    ULONG LinesPerBlock;
    PCHAR LoadFileName;
    PCHAR LoadOptions;
    PCHAR OsLoader;
#if defined(_X86_)
    PCHAR x86SystemPartition;
    PCHAR userSpecifiedKernelName = NULL;
    ULONG highestSystemPage;
    BOOLEAN userSpecifiedPae;
    BOOLEAN userSpecifiedNoPae;
#endif
#if defined(REMOTE_BOOT)
    PCHAR SavedOsLoader;
    PCHAR SavedLoadFileName;
#endif
    ULONG i;
    ARC_STATUS Status;
    NTSTATUS NtStatus;
    PKLDR_DATA_TABLE_ENTRY SystemDataTableEntry;
    PTRANSFER_ROUTINE SystemEntry;
    PIMAGE_NT_HEADERS NtHeaders;
    PWSTR BootFileSystem;
    CHAR BadFileName[128];
    PBOOTFS_INFO FsInfo;
    PCHAR TmpPchar;
    BOOLEAN bDiskCacheInitialized = FALSE;
    BOOLEAN ServerHive = FALSE;
#if defined(REMOTE_BOOT)
    ULONGLONG NetRebootParameter;
    CHAR OutputBuffer[256];
#endif // defined(REMOTE_BOOT)
    BOOLEAN bLastKnownGood, bLastKnownGoodChosenLate;
#if defined(_X86_)
    BOOLEAN safeBoot = FALSE;
#endif
    PBOOT_DRIVER_NODE       DriverNode = 0;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry = 0;
    PLIST_ENTRY             NextEntry = 0;
    PLIST_ENTRY             BootDriverListHead = 0;
    UNICODE_STRING          unicodeString;
    CHAR                    Directory[256];

    UNREFERENCED_PARAMETER( Envp );

#ifdef EFI
    //
    // set the EFI watchdog to 20 minutes.
    // by default, it is set to 5 minutes by the efi boot manager
    //
    SetEFIWatchDog(EFI_WATCHDOG_TIMEOUT);

#elif defined(_X86_)
    //
    // set the x86 watchdog timer if it exists
    //
    SetX86WatchDog(X86_WATCHDOG_TIMEOUT);

#endif

//    BlShowProgressBar = TRUE;
    BlShowProgressBar = FALSE;
    BlStartTime = ArcGetRelativeTime();

    //
    // Initialize the OS loader console input and output.
    //
    Status = BlInitStdio(Argc, Argv);
    if (Status != ESUCCESS) {
        return Status;
    }


    //
    // Initialize the boot debugger for platforms that directly load the
    // OS Loader.
    //
    // N.B. This must occur after the console input and output have been
    //      initialized so debug messages can be printed on the console
    //      output device.
    //

#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)
    //
    // Locate the memory descriptor for the OS Loader.
    //

    ProgramDescriptor = NULL;
    while ((ProgramDescriptor = ArcGetMemoryDescriptor(ProgramDescriptor)) != NULL) {
        if (ProgramDescriptor->MemoryType == MemoryLoadedProgram) {
            break;
        }
    }

    //
    // If the program memory descriptor was found, then compute the base
    // address of the OS Loader for use by the debugger.
    //

    LoaderBase = &__ImageBase;

    //
    // Initialize traps and the boot debugger.
    //
#if defined(ENABLE_LOADER_DEBUG)

#if defined(_ALPHA_)
    BdInitializeTraps();
#endif

    DBGTRACE( TEXT("About to BdInitDebugger. Base = %x\r\n"), LoaderBase );

    BdInitDebugger((PCHAR)OsLoaderName, LoaderBase, ENABLE_LOADER_DEBUG);

    DBGTRACE( TEXT("Back From BdInitDebugger.\r\n") );

#else

    BdInitDebugger((PCHAR)OsLoaderName, 0, NULL);

#endif

#endif

#if defined(REMOTE_BOOT)
    //
    // Get any parameters from a reboot on a Net PC.
    //

    if (BlBootingFromNet) {
        NetGetRebootParameters(&NetRebootParameter, NULL, NULL, NULL, NULL, NULL, TRUE);
    }
#endif // defined(REMOTE_BOOT)

#if 0 && !defined(_IA64_)
//
// AJR bugbug -- do we really need to do this twice? we already call in SuMain()
//
// ChuckL -- Turned this code off because it screws up remote boot, which
//           does some allocations before we get here.
//
    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //

    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_MEM_CLASS,
                     DIAG_BL_MEMORY_INIT,
                     LOAD_HW_MEM_ACT);

        goto LoadFailed;
    }
#endif


#if defined(_IA64_)
    //
    // Build required portion of ARC tree since we are not doing NTDETECT
    // anymore for IA-64.
    //
    BuildArcTree();
#endif

#ifdef EFI
    //
    // Establish SMBIOS information in the loader block
    //
    SetupSMBiosInLoaderBlock();
#endif

    //
    // Compute the data cache fill size. This value is used to align
    // I/O buffers in case the host system does not support coherent
    // caches.
    //
    // If a combined secondary cache is present, then use the fill size
    // for that cache. Otherwise, if a secondary data cache is present,
    // then use the fill size for that cache. Otherwise, if a primary
    // data cache is present, then use the fill size for that cache.
    // Otherwise, use the default fill size.
    //

    DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                         CacheClass,
                                         SecondaryCache,
                                         NULL);

    if (DataCache == NULL) {
        DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                             CacheClass,
                                             SecondaryDcache,
                                             NULL);

        if (DataCache == NULL) {
            DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                                 CacheClass,
                                                 PrimaryDcache,
                                                 NULL);
        }
    }

    if (DataCache != NULL) {
        LinesPerBlock = DataCache->ComponentEntry.Key >> 24;
        CacheLineSize = 1 << ((DataCache->ComponentEntry.Key >> 16) & 0xff);
        BlDcacheFillSize = LinesPerBlock * CacheLineSize;
    }


    //
    // Initialize the OS loader I/O system.
    //

    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_DISK_CLASS,
                     DIAG_BL_IO_INIT,
                     LOAD_HW_DISK_ACT);

        goto LoadFailed;
    }

    //
    // Initialize the resource section.
    //

    Status = BlInitResources(Argv[0]);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_DISK_CLASS,
                     DIAG_BL_IO_INIT,
                     LOAD_HW_DISK_ACT);

        goto LoadFailed;
    }

    //
    // Initialize the progress bar
    //
    BlSetProgBarCharacteristics(HIBER_UI_BAR_ELEMENT, BLDR_UI_BAR_BACKGROUND);


    //
    // Initialize the NT configuration tree.
    //

    BlLoaderBlock->ConfigurationRoot = NULL;
    Status = BlConfigurationInitialize(NULL, NULL);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_CONFIG_INIT,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Copy the osloadoptions argument into the LoaderBlock.
    //
    LoadOptions = BlGetArgumentValue(Argc, Argv, "osloadoptions");

#if defined(_X86_)

    userSpecifiedPae = FALSE;
    userSpecifiedNoPae = FALSE;
    safeBoot = FALSE;

#endif

    if (LoadOptions != NULL) {

        FileSize = (ULONG)strlen(LoadOptions) + 1;
        FileName = (PCHAR)BlAllocateHeap(FileSize);
        strcpy(FileName, LoadOptions);
        BlLoaderBlock->LoadOptions = FileName;

        //
        // Check for the SOS switch that forces the output of filenames during
        // the boot instead of the progress dots.
        //

        if ((strstr(FileName, "SOS") != NULL) ||
            (strstr(FileName, "sos") != NULL)) {
            BlOutputDots = FALSE;
        }

#ifdef EFI
        GraphicsMode = FALSE;
#else
        GraphicsMode = (BOOLEAN)(strstr(FileName, "BOOTLOGO") != NULL); // to display boot logo go to graphics mode
#endif


        //
        // Check for the 3gb user address space switch which causes the system
        // to load at the alternate base address if it is relocatable.
        //

#if defined(_X86_)

        if (strstr(FileName, "SAFEBOOT") != NULL) {
            safeBoot = TRUE;
        }

        if ((strstr(FileName, "3GB") != NULL) ||
            (strstr(FileName, "3gb") != NULL)) {
            BlVirtualBias = ALTERNATE_BASE - KSEG0_BASE;
        }

        if ((strstr(FileName, "PAE") != NULL) ||
            (strstr(FileName, "pae") != NULL)) {
            userSpecifiedPae = TRUE;
        }

        if ((strstr(FileName, "NOPAE") != NULL) ||
            (strstr(FileName, "nopae") != NULL)) {
            userSpecifiedNoPae = TRUE;
        }

        if (safeBoot != FALSE) {

            //
            // We're in safeboot mode.  Override the user's desire to boot
            // into PAE mode.
            //

            userSpecifiedPae = FALSE;
        }

#endif

        //
        // Check for an alternate HAL specification.
        //

        FileName = strstr(BlLoaderBlock->LoadOptions, "HAL=");
        if (FileName != NULL) {
            FileName += strlen("HAL=");
            for (i = 0; i < sizeof(HalFileName); i++) {
                if (FileName[i] == ' ') {
                    HalFileName[i] = '\0';
                    break;
                }

                HalFileName[i] = FileName[i];
            }
        }

        HalFileName[sizeof(HalFileName) - 1] = '\0';

        //
        // Check for an alternate kernel specification.
        //

        FileName = strstr(BlLoaderBlock->LoadOptions, "KERNEL=");
        if (FileName != NULL) {
            FileName += strlen("KERNEL=");
            for (i = 0; i < sizeof(KernelFileName); i++) {
                if (FileName[i] == ' ') {
                    KernelFileName[i] = '\0';
                    break;
                }

                KernelFileName[i] = FileName[i];
            }
#if defined(_X86_)
            userSpecifiedKernelName = KernelFileName;
#endif

        }
#if defined(_X86_)
        else {
            userSpecifiedKernelName = NULL;
        }
#endif

        KernelFileName[sizeof(KernelFileName) - 1] = '\0';

        //
        // Check for an alternate Kernel Debugger DLL, i.e.,
        // /debugport=1394 (kd1394.dll), /debugport=usb (kdusb.dll), etc...
        //

        FileName = strstr(BlLoaderBlock->LoadOptions, "DEBUGPORT=");
        if (FileName == NULL) {
            FileName = strstr(BlLoaderBlock->LoadOptions, "debugport=");
        }
        if (FileName != NULL) {
            _strupr(FileName);
            if (strstr(FileName, "COM") == NULL) {
                UseAlternateKdDll = TRUE;
                FileName += strlen("DEBUGPORT=");
                for (i = 0; i < KD_ALT_DLL_REPLACE_CHARS; i++) {
                    if (FileName[i] == ' ') {
                        break;
                    }

                    KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = FileName[i];
                }
                KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = '\0';
                strcat(KdFileName, ".DLL");
            }
        }
    } else {
        BlLoaderBlock->LoadOptions = NULL;
    }

#if defined(_X86_)
    if (LoadOptions != NULL) {
        //
        // Process XIP options
        //
        {
            PCHAR XIPBootOption, XIPRomOption, XIPRamOption, XIPSizeOption;
            PCHAR path, sizestr;
            ULONG nmegs = 0;
            PCHAR p, opts;
            ULONG n;

            opts = BlLoaderBlock->LoadOptions;

            (XIPBootOption = strstr(opts, "XIPBOOT"))  || (XIPBootOption = strstr(opts, "xipboot"));
            (XIPRomOption  = strstr(opts, "XIPROM="))  || (XIPRomOption  = strstr(opts, "xiprom="));
            (XIPRamOption  = strstr(opts, "XIPRAM="))  || (XIPRamOption  = strstr(opts, "xipram="));
            (XIPSizeOption = strstr(opts, "XIPMEGS=")) || (XIPSizeOption = strstr(opts, "xipmegs="));

            XIPEnabled = FALSE;

            if (XIPRomOption || XIPRamOption) {
                if (XIPRomOption && XIPRamOption) {
                    ;
                } else {
                    sizestr = XIPSizeOption? strchr(XIPSizeOption, '=') : NULL;
                    if (sizestr) {
                        sizestr++;
                        nmegs = 0;
                        while ('0' <= *sizestr && *sizestr <= '9') {
                            nmegs = 10*nmegs + (*sizestr - '0');
                            sizestr++;
                        }
                    }

                    path = strchr(XIPRomOption? XIPRomOption : XIPRamOption, '=');

                    if (nmegs && path) {
                        path++;

                        XIPBootFlag = XIPBootOption? TRUE : FALSE;
                        XIPPageCount = (1024*1024*nmegs) >> PAGE_SHIFT;

                        //
                        // strdup XIPLoadPath
                        //
                        for (p = path;  *p;  p++) {
                            if (*p == ' ') break;
                            if (*p == '/') break;
                            if (*p == '\n') break;
                            if (*p == '\r') break;
                            if (*p == '\t') break;
                        }

                        n = (p - path);
                        if (n > 1) {
                            XIPLoadPath = BlAllocateHeap(n+1);
                            if (XIPLoadPath) {
                                for (i = 0;  i < n;  i++) {
                                    XIPLoadPath[i] = path[i];
                                }
                                XIPLoadPath[i] = '\0';

                                XIPEnabled = TRUE;
                            }
                        }
                    }
                }
            }
        }
    }

    //
    // Allocate the XIP pages.
    //

    if (XIPEnabled) {

        ULONG OldBase;
        ULONG OldLimit;

        OldBase = BlUsableBase;
        OldLimit = BlUsableLimit;
        BlUsableBase = BL_XIPROM_RANGE_LOW;
        BlUsableLimit = BL_XIPROM_RANGE_HIGH;

        Status = BlAllocateAlignedDescriptor (LoaderXIPRom, 0, XIPPageCount, _4mb_pages, &XIPBasePage);
        if (Status != ESUCCESS) {
            XIPEnabled = FALSE;
        }

        BlUsableBase = OldBase;
        BlUsableLimit = OldLimit;
    }

#endif //_X86_

    //
    // Get the name of the OS loader (on i386 it's system32\NTLDR) and get
    // the OS path (on i386 it's <SystemRoot> such as "\winnt").
    //
    OsLoader = BlGetArgumentValue(Argc, Argv, "osloader");
    LoadFileName = BlGetArgumentValue(Argc, Argv, "osloadfilename");

    //
    // Check the load path to make sure it's valid.
    //
    if (LoadFileName == NULL) {
        Status = ENOENT;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FW_GET_BOOT_DEVICE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Check the loader path to see if it's valid.
    //
    if (OsLoader == NULL) {
        Status = ENOENT;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FIND_HAL_IMAGE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

#if defined(REMOTE_BOOT)
    //
    // If we're booting from the net, temporarily remove the server\share
    // from the front of the OsLoader and LoadFileName strings so that TFTP
    // works.
    //

    if (BlBootingFromNet) {

        NetServerShare = OsLoader; // Required for Client Side Cache.

        SavedOsLoader = OsLoader;               // save OsLoader pointer
        OsLoader++;                             // skip leading "\"
        OsLoader = strchr(OsLoader,'\\');       // find server\share separator
        if (OsLoader != NULL) {
            OsLoader++;                         // skip server\share separator
            OsLoader = strchr(OsLoader,'\\');   // find share\path separator
        }
        if (OsLoader == NULL) {                 // very bad if no \ found
            OsLoader = SavedOsLoader;
            goto LoadFailed;
        }
        SavedLoadFileName = LoadFileName;       // save LoadFileName pointer
        LoadFileName++;                         // skip leading "\"
        LoadFileName = strchr(LoadFileName,'\\'); // find server\share separator
        if (LoadFileName != NULL) {
            LoadFileName++;                     // skip server\share separator
            LoadFileName = strchr(LoadFileName,'\\'); // find share\path separator
        }
        if (LoadFileName == NULL) {             // very bad if no \ found
            LoadFileName = SavedLoadFileName;
            OsLoader = SavedOsLoader;
            goto LoadFailed;
        }
    }
#endif // defined(REMOTE_BOOT)

    //
    // Try to make sure disk caching is initialized. Failure in
    // initializing the disk cache should not keep us from booting, so
    // Status is not set.
    //
    if (BlDiskCacheInitialize() == ESUCCESS) {
        bDiskCacheInitialized = TRUE;
    }

    //
    // Get the NTFT drive signatures to allow the kernel to create the
    // correct ARC name <=> NT name mappings.
    //

    BlGetArcDiskInformation(FALSE);

    //
    // Display the Configuration prompt for breakin at this point, but don't
    // check for key downstrokes. This gives the user a little more reaction
    // time.
    //
    BlStartConfigPrompt();

    //
    // Determine if we are going to do a last known good boot.
    //
    // ISSUE-2000/03/29-ADRIAO: LastKnownGood enhancements
    //     Note that last known kernel/hal support requires that we know we're
    // going into a lkg boot prior to initializing the loader. On an x86 system
    // with only one boot.ini option we will not present the user the lkg option
    // until *after* we've loaded the kernel, hal, registry, and kd-dlls. If we
    // decide to support last known kernel/hal, we'd probably have to do
    // something similar to what 9x does (ie look for a depressed CTRL key at
    // the earliest point in boot.)
    //
    bLastKnownGood = (BOOLEAN)(LoadOptions && (strstr(LoadOptions, "LASTKNOWNGOOD") != NULL));

    //
    // Put together everything we need to describe the loader device. This is
    // where the OS is loaded from (ie some \winnt installation). The alias
    // for this path is \SystemRoot.
    //
    LoadDevice = BlGetArgumentValue(Argc, Argv, "osloadpartition");

    if (LoadDevice == NULL) {
        Status = ENODEV;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FW_GET_BOOT_DEVICE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Initialize the Ramdisk if it is specified in LoadOptions
    //

    Status = RamdiskInitialize( LoadOptions, FALSE );
    if (Status != ESUCCESS) {
        // BlFatalError called inside RamdiskInitialize
        goto LoadFailed;
    }

    //
    // Translate it's signature based arc name
    //
    TmpPchar = BlTranslateSignatureArcName( LoadDevice );
    if (TmpPchar) {
        LoadDevice = TmpPchar;
    }

    //
    // Open the load device
    //
    Status = ArcOpen(LoadDevice, ArcOpenReadWrite, &LoadDeviceId);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_DISK_CLASS,
                     DIAG_BL_OPEN_BOOT_DEVICE,
                     LOAD_HW_DISK_ACT);

        goto LoadFailed;
    }

#if defined(_X86_)
    //
    // Check for the special SDIBOOT flag, which tells us to boot from an
    // SDI image in the root of the boot partition.
    //
    if ( BlLoaderBlock->LoadOptions != NULL ) {
        TmpPchar = strstr( BlLoaderBlock->LoadOptions, "SDIBOOT=" );
        if ( TmpPchar != NULL ) {
            TmpPchar = strchr( TmpPchar, '=' ) + 1;
            RamdiskSdiBoot( TmpPchar );
        }
    }
#endif

    if (GraphicsMode) {

        HW_CURSOR(0x80000000,0x12);
        VgaEnableVideo();

        LoadBootLogoBitmap (LoadDeviceId, LoadFileName);
        if (DisplayLogoOnBoot) {
            PrepareGfxProgressBar();
            BlUpdateBootStatus();
        }
    }

    //
    // Initiate filesystem metadata caching on the load device.
    //
    // NOTE: From here on access the LoadDevice only through the LoadDeviceId.
    // This way, your access will be faster because it is cached. Otherwise if
    // you make writes, you will have cache consistency issues.
    //
    if (bDiskCacheInitialized) {
        BlDiskCacheStartCachingOnDevice(LoadDeviceId);
    }

    //
    // Build the load device path set. We keep multiple paths so that we can
    // fall back to a last known driver set during a last known good boot.
    //
    strcpy(LoadDevicePath, LoadFileName);
    strcat(LoadDevicePath, "\\");
    strcpy(LoadDeviceLKG1Path, LoadDevicePath);
    strcat(LoadDeviceLKG1Path, LAST_KNOWN_GOOD_TEMPORARY_PATH "\\" );
    strcpy(LoadDeviceLKG2Path, LoadDevicePath);
    strcat(LoadDeviceLKG2Path, LAST_KNOWN_GOOD_WORKING_PATH "\\" );

#if defined(_X86_)
    //
    // Read in the XIP image
    //
    if (XIPEnabled) {
        ULONG FileId;

        //
        // Read in the imagefile
        //
        Status = BlOpen(LoadDeviceId, XIPLoadPath, ArcOpenReadOnly, &FileId);
        if (Status == ESUCCESS) {
            Status = XipLargeRead(FileId, XIPBasePage, XIPPageCount);
            (void) BlClose(FileId);
        }

        if (Status != ESUCCESS) {
            XIPEnabled = FALSE;
        }
    }
#endif //_X86_

    i = 0;

    if (bLastKnownGood) {

        //
        // Add the last known good paths as if we are in a LastKnownGood boot.
        //
        LoadDevicePathSet.Source[i].DeviceId = LoadDeviceId;
        LoadDevicePathSet.Source[i].DeviceName = LoadDevice;
        LoadDevicePathSet.Source[i].DirectoryPath = LoadDeviceLKG1Path;
        i++;

        LoadDevicePathSet.Source[i].DeviceId = LoadDeviceId;
        LoadDevicePathSet.Source[i].DeviceName = LoadDevice;
        LoadDevicePathSet.Source[i].DirectoryPath = LoadDeviceLKG2Path;
        i++;
    }

    LoadDevicePathSet.Source[i].DeviceId = LoadDeviceId;
    LoadDevicePathSet.Source[i].DeviceName = LoadDevice;
    LoadDevicePathSet.Source[i].DirectoryPath = LoadDevicePath;

    //
    // The load path sources are all relative to \SystemRoot.
    //
    LoadDevicePathSet.AliasName = "\\SystemRoot";
    LoadDevicePathSet.PathOffset[0] = '\0';
    LoadDevicePathSet.PathCount = ++i;

    //
    // While here, form the kernel path set. This is the same as the boot path
    // set except that it's off of system32/64. Note also that we don't add in
    // the LKG path today.
    //
    KernelPathSet.PathCount = 1;
    KernelPathSet.AliasName = "\\SystemRoot";
    strcpy(KernelPathSet.PathOffset, SYSTEM_DIRECTORY_PATH "\\" );
    KernelPathSet.Source[0].DeviceId = LoadDeviceId;
    KernelPathSet.Source[0].DeviceName = LoadDevice;
    KernelPathSet.Source[0].DirectoryPath = LoadDevicePath;

    //
    // While here, form the fully qualified kernel path.
    //
    strcpy(KernelDirectoryPath, LoadFileName);
    strcat(KernelDirectoryPath, "\\" SYSTEM_DIRECTORY_PATH "\\" );

    //
    // Now put together everything we need to describe the system device. This
    // is where we get the hal and pal from. There is no alias for this path
    // (ie no equivalent to \SystemRoot.)
    //
    SystemDevice = BlGetArgumentValue(Argc, Argv, "systempartition");

    if (SystemDevice == NULL) {
        Status = ENODEV;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FW_GET_SYSTEM_DEVICE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Translate it's signature based arc name
    //
    TmpPchar = BlTranslateSignatureArcName( SystemDevice );
    if (TmpPchar) {
        SystemDevice = TmpPchar;
    }

    //
    // Open the system device. If SystemDevice path and LoadDevice
    // path are the same [as on all x86 I have seen so far], do not
    // open the device under another device id so we can use disk
    // caching. Otherwise there may be a cache consistency issue.
    //
    if (!_stricmp(LoadDevice, SystemDevice))  {

        SystemDeviceId = LoadDeviceId;

    } else {

        Status = ArcOpen(SystemDevice, ArcOpenReadWrite, &SystemDeviceId);
        if (Status != ESUCCESS) {

            BlFatalError(LOAD_HW_FW_CFG_CLASS,
                         DIAG_BL_FW_OPEN_SYSTEM_DEVICE,
                         LOAD_HW_FW_CFG_ACT);

            goto LoadFailed;
        }
    }

    //
    // Initiate filesystem metadata caching on the system device.
    //
    // NOTE: From here on access the SystemDevice only through the
    // SystemDeviceId. This way, your access will be faster because it is
    // cached. Otherwise if you make writes, you will have cache consistency
    // issues.
    //
    if (bDiskCacheInitialized) {
        if (SystemDeviceId != LoadDeviceId) {
            BlDiskCacheStartCachingOnDevice(SystemDeviceId);
        }
    }

    //
    // Get the path name of the OS loader file and isolate the directory
    // path so it can be used to load the HAL DLL.
    //
    // Note well: We actually don't use this path to load the hal anymore
    // -- we rely on the kernel path to load the hal as they are at the same
    //    location
    // -- we do use this path for identifying the system partition, so do not
    //    remove code related to systemdevicepath unless you know what you're
    //    doing.
    //

    FileName = OsLoader;

    DirectoryEnd = strrchr(FileName, '\\');
    FileName = strchr(FileName, '\\');
    SystemDevicePath[0] = 0;
    if (DirectoryEnd != NULL) {
        Limit = (ULONG)((ULONG_PTR)DirectoryEnd - (ULONG_PTR)FileName + 1);
        for (Index = 0; Index < Limit; Index += 1) {
            SystemDevicePath[Index] = *FileName++;
        }

        SystemDevicePath[Index] = 0;
    }


    //
    // Describe our hal paths.
    //
    // ISSUE-2000/03/29-ADRIAO: LastKnownGood enhancements
    //     On x86 we'd like to support LKG for hals way into the future. Ideally
    // we'd get them from \Winnt\LastGood\System32. Unfortunately, we get back
    // \Winnt\System32 from the Arc, making it kinda hard to splice in our
    // LKG path.
    //
    // ISSUE-2000/03/29-ADRIAO: Existant namespace polution
    //     We need to come up with an Alias for the Hal path so that it can
    // properly be inserted into the image namespace. Either that or we should
    // consider lying and saying it comes from \SystemRoot. Note that on x86
    // we probably *would* want it to say it was from \SystemRoot in case it
    // brings in its own DLL's!
    //

    SystemDevicePathSet.PathCount = 1;
    SystemDevicePathSet.AliasName = NULL;
    SystemDevicePathSet.PathOffset[0] = '\0';
    SystemDevicePathSet.Source[0].DeviceId = SystemDeviceId;
    SystemDevicePathSet.Source[0].DeviceName = SystemDevice;
    SystemDevicePathSet.Source[0].DirectoryPath = SystemDevicePath;
    //
    // Handle triage dump (if present).
    //

    Status = BlLoadTriageDump (LoadDeviceId,
                               &BlLoaderBlock->Extension->TriageDumpBlock);

    if (Status != ESUCCESS) {
        BlLoaderBlock->Extension->TriageDumpBlock = NULL;
    }

    //
    // Handle hibernation image (if present)
    //

#if defined(i386) || defined(_IA64_)

    Status = BlHiberRestore(LoadDeviceId, NULL);
    if (Status != ESUCCESS) {
        Status = ESUCCESS;
        // proceed with the boot.
        // goto LoadFailed;
    }

#endif

    //
    // Initialize the logging system. Note that we dump to the system device
    // and not the load device.
    //

    BlLogInitialize(SystemDeviceId);

#if defined(REMOTE_BOOT)
    //
    // If booting from the net, check for any of the following:
    //    - The client-side disk is incorrect for this NetPC.
    //    - The client-side cache is stale.
    //

    if (BlBootingFromNet) {

        BlLoaderBlock->SetupLoaderBlock = BlAllocateHeap(sizeof(SETUP_LOADER_BLOCK));
        if (BlLoaderBlock->SetupLoaderBlock == NULL) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        //
        // ISSUE-1998/07/13-JVert (John Vert)
        //      Code below is ifdef'd out because net boot is no longer
        //      in the product. BlCheckMachineReplacement ends up calling
        //      SlDetectHAL, which now requires access to txtsetup.sif
        //      in order to see if an ACPI machine has a known "good" BIOS.
        //      Since there is no txtsetup.sif during a normal boot there
        //      is no point in getting all the INF processing logic into
        //      NTLDR.
        // ISSUE-1998/07/16-ChuckL (Chuck Lenzmeier)
        //      This means that if we ever reenable full remote boot, as
        //      opposed to just remote install, and we want to be able to
        //      do machine replacement, we're going to have to figure out
        //      how to make SlDetectHAL work outside of textmode setup.
        //

        strncpy(OutputBuffer, LoadFileName + 1, 256);
        TmpPchar = strchr(OutputBuffer, '\\');
        TmpPchar++;
        TmpPchar = strchr(TmpPchar, '\\');
        TmpPchar++;
        strcpy(TmpPchar, "startrom.com");

        BlCheckMachineReplacement(SystemDevice, SystemDeviceId, NetRebootParameter, OutputBuffer);

    } else
#endif // defined(REMOTE_BOOT)
    {
        BlLoaderBlock->SetupLoaderBlock = NULL;
    }



    //
    // See if we're redirecting.
    //
    if( LoaderRedirectionInformation.PortAddress ) {

        //
        // Yes, we are redirecting right now.  Use these settings.
        //
        BlLoaderBlock->Extension->HeadlessLoaderBlock = BlAllocateHeap(sizeof(HEADLESS_LOADER_BLOCK));

        RtlCopyMemory( BlLoaderBlock->Extension->HeadlessLoaderBlock,
                       &LoaderRedirectionInformation,
                       sizeof(HEADLESS_LOADER_BLOCK) );

    } else {

        BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;

    }


    //
    // Generate the full path name for the HAL DLL image and load it into
    // memory.
    //

    strcpy(HalPathName, KernelDirectoryPath);
    strcat(HalPathName, HalFileName);

    //
    // Prepare for building the full path name of the kernel
    //

    strcpy(KernelPathName, KernelDirectoryPath);

#if defined(_X86_)

    BlAmd64RemapDram( LoadOptions );

    //
    // If Amd64 long mode is detected, the following call will set
    // the global BlAmd64UseLongMode to TRUE, AND will append
    // KernelFileName to KernelPathName.
    //

    Status = BlAmd64CheckForLongMode( LoadDeviceId,
                                      KernelPathName,
                                      KernelFileName );

    if (Status != ESUCCESS) {

        Status = ENODEV;
        BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                     DIAG_BL_LOAD_SYSTEM_IMAGE,
                     LOAD_SW_FILE_REINST_ACT);
        goto LoadFailed;
    }

    if (BlAmd64UseLongMode == FALSE) {
    
        //
        // On X86, there are two kernel images: one compiled for PAE mode,
        // and one not.  Call a routine that decides what to load.
        //
        // Upon successful return, KernelPathName contains the full path of
        // the kernel image.
        //
    
        Status = Blx86CheckForPaeKernel( userSpecifiedPae,
                                         userSpecifiedNoPae,
                                         userSpecifiedKernelName,
                                         HalPathName,
                                         LoadDeviceId,
                                         SystemDeviceId,
                                         &highestSystemPage,
                                         &BlUsePae,
                                         KernelPathName
                                         );

        if (Status != ESUCCESS) {
    
            //
            // A valid kernel compatible with this processor could not be
            // located.  This is fatal.
            //

            BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                         (Status == EBADF)
                          ? DIAG_BL_LOAD_HAL_IMAGE
                          : DIAG_BL_LOAD_SYSTEM_IMAGE,
                         LOAD_SW_FILE_REINST_ACT);
            goto LoadFailed;
        }
    }

#else

    //
    // Generate the full pathname of ntoskrnl.exe
    //
    //      "\winnt\system32\ntoskrnl.exe"
    //
    strcat(KernelPathName, KernelFileName);

#endif

    //
    // Set allocatable range to the kernel-specific range
    //
    BlUsableBase  = BL_KERNEL_RANGE_LOW;
    BlUsableLimit = BL_KERNEL_RANGE_HIGH;

    //
    // Initialize the progress bar
    //
    if( BlIsTerminalConnected() ) {
        BlOutputStartupMsg(BL_MSG_STARTING_WINDOWS);
        BlOutputTrailerMsg(BL_ADVANCED_BOOT_MESSAGE);

    }



#if defined (_X86_)

    if (BlAmd64UseLongMode == FALSE) {
        BlpCheckVersion(LoadDeviceId,KernelPathName);
    }


#endif


    //
    // Load the kernel image into memory.
    //
    BlOutputLoadMessage(LoadDevice, KernelPathName, NULL);

#ifdef i386
retrykernel:
#endif
    Status = BlLoadImage(LoadDeviceId,
                         LoaderSystemCode,
                         KernelPathName,
                         TARGET_IMAGE,
                         &SystemBase);
#ifdef i386
    //
    // If the kernel didn't fit in the preferred range, reset the range to
    // all of memory and try again.
    //
    if ((Status == ENOMEM) &&
        ((BlUsableBase != BL_DRIVER_RANGE_LOW) ||
         (BlUsableLimit != BL_DRIVER_RANGE_HIGH))) {
        BlUsableBase = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;

        goto retrykernel;
    }
#endif


    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                     DIAG_BL_LOAD_SYSTEM_IMAGE,
                     LOAD_SW_FILE_REINST_ACT);

        goto LoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Whatever filesystem was used to load the kernel image is the
    // one that needs to be loaded along with the boot drivers.
    //

#if defined(REMOTE_BOOT)
    if (BlBootingFromNet) {

        //
        // For a remote boot, the boot file system is always NTFS.
        //

        BootFileSystem = L"ntfs";

    } else
#endif // defined(REMOTE_BOOT)

    {
        FsInfo = BlGetFsInfo(LoadDeviceId);
        if (FsInfo != NULL) {
            BootFileSystem = FsInfo->DriverName;

        } else {
            BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                         DIAG_BL_LOAD_SYSTEM_IMAGE,
                         LOAD_SW_FILE_REINST_ACT);

            goto LoadFailed;
        }
    }

    //
    // Load the HAL DLL image into memory.
    //

    BlOutputLoadMessage(LoadDevice, HalPathName, NULL);

#ifdef i386
retryhal:
#endif
    Status = BlLoadImage(LoadDeviceId,
                         LoaderHalCode,
                         HalPathName,
                         TARGET_IMAGE,
                         &HalBase);
#ifdef i386
    //
    // If the HAL didn't fit in the preferred range, reset the range to
    // all of memory and try again.
    //
    if ((Status == ENOMEM) &&
        ((BlUsableBase != BL_DRIVER_RANGE_LOW) ||
         (BlUsableLimit != BL_DRIVER_RANGE_HIGH))) {
        BlUsableBase = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;

        goto retryhal;
    }
#endif

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                     DIAG_BL_LOAD_HAL_IMAGE,
                     LOAD_SW_FILE_REINST_ACT);

        goto LoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Load the Kernel Debugger DLL image into memory.
    //
    KdDllLoadFailed = FALSE;
    strcpy(&KdDllName[0], KernelDirectoryPath);
    strcat(&KdDllName[0], KdFileName);

    BlOutputLoadMessage(LoadDevice, &KdDllName[0], NULL);

    Status = BlLoadImage(LoadDeviceId,
                         LoaderSystemCode,
                         &KdDllName[0],
                         TARGET_IMAGE,
                         &KdDllBase);

    if ((Status != ESUCCESS) && (UseAlternateKdDll == TRUE)) {
        UseAlternateKdDll = FALSE;

        strcpy(&KdDllName[0], KernelDirectoryPath);
        strcat(&KdDllName[0], "kdcom.dll");

        BlOutputLoadMessage(LoadDevice, &KdDllName[0], NULL);

        Status = BlLoadImage(LoadDeviceId,
                             LoaderSystemCode,
                             &KdDllName[0],
                             TARGET_IMAGE,
                             &KdDllBase);
    }

    //
    // Don't bugcheck if KDCOM.DLL is not present, we may be trying to dual-
    // boot an older OS.  If we really do require KDCOM.DLL, we will fail to
    // scan the import table for the system image, and bugcheck with kernel
    // needed DLLs to load
    //
    if (Status != ESUCCESS) {
        KdDllLoadFailed = TRUE;
    }

    BlUpdateBootStatus();

    //
    // Set allocatable range to the driver-specific range
    //
    BlUsableBase  = BL_DRIVER_RANGE_LOW;
    BlUsableLimit = BL_DRIVER_RANGE_HIGH;

    //
    // Generate a loader data entry for the system image.
    //

    Status = BlAllocateDataTableEntry("ntoskrnl.exe",
                                      KernelPathName,
                                      SystemBase,
                                      &SystemDataTableEntry);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_SYSTEM_IMAGE,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the HAL DLL.
    //

    Status = BlAllocateDataTableEntry("hal.dll",
                                      HalPathName,
                                      HalBase,
                                      &HalDataTableEntry);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_HAL_IMAGE,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the Kernel Debugger DLL.
    //

    if (!KdDllLoadFailed) {
        Status = BlAllocateDataTableEntry("kdcom.dll",
                                          KdDllName,
                                          KdDllBase,
                                          &KdDataTableEntry);

        if (Status != ESUCCESS) {
            BlFatalError(LOAD_SW_INT_ERR_CLASS,
                         DIAG_BL_LOAD_SYSTEM_DLLS,
                         LOAD_SW_INT_ERR_ACT);

            goto LoadFailed;
        }
    }

    //
    // Scan the import table for the system image and load all referenced
    // DLLs.
    //

    Status = BlScanImportDescriptorTable(&KernelPathSet,
                                         SystemDataTableEntry,
                                         LoaderSystemCode);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_SYSTEM_DLLS,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Scan the import table for the HAL DLL and load all referenced DLLs.
    //

    Status = BlScanImportDescriptorTable(&KernelPathSet,
                                         HalDataTableEntry,
                                         LoaderHalCode);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_HAL_DLLS,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Scan the import table for the Kernel Debugger DLL and load all
    // referenced DLLs.
    //

    if (!KdDllLoadFailed) {
        Status = BlScanImportDescriptorTable(&KernelPathSet,
                                             KdDataTableEntry,
                                             LoaderSystemCode);


        if (Status != ESUCCESS) {
            BlFatalError(LOAD_SW_INT_ERR_CLASS,
                         DIAG_BL_LOAD_SYSTEM_DLLS,
                         LOAD_SW_INT_ERR_ACT);

            goto LoadFailed;
        }
    }

    //
    // Relocate the system entry point and set system specific information.
    //

    NtHeaders = RtlImageNtHeader(SystemBase);
    SystemEntry = (PTRANSFER_ROUTINE)((ULONG_PTR)SystemBase +
                                NtHeaders->OptionalHeader.AddressOfEntryPoint);


#if defined(_IA64_)

    BlLoaderBlock->u.Ia64.KernelVirtualBase = (ULONG_PTR)SystemBase;
    BlLoaderBlock->u.Ia64.KernelPhysicalBase = (ULONG_PTR)SystemBase & 0x7fffffff;

#endif

    //
    // Allocate a structure for NLS data which will be loaded and filled
    // by BlLoadAndScanSystemHive.
    //

    BlLoaderBlock->NlsData = BlAllocateHeap(sizeof(NLS_DATA_BLOCK));
    if (BlLoaderBlock->NlsData == NULL) {
        Status = ENOMEM;
        BlFatalError(LOAD_HW_MEM_CLASS,
                     DIAG_BL_LOAD_SYSTEM_HIVE,
                     LOAD_HW_MEM_ACT);

        goto LoadFailed;
    }

#if defined(REMOTE_BOOT)
    //
    // If booting from the net, we use the SetupLoaderBlock to pass
    // information. BlLoadAndScanSystemHive fills in the netboot card
    // fields if present in the registry.
    //

    if (BlBootingFromNet) {

        BlLoaderBlock->SetupLoaderBlock->NetbootCardInfo = BlAllocateHeap(sizeof(NET_CARD_INFO));
        if ( BlLoaderBlock->SetupLoaderBlock->NetbootCardInfo == NULL ) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }
        BlLoaderBlock->SetupLoaderBlock->NetbootCardInfoLength = sizeof(NET_CARD_INFO);
    }
#endif // defined(REMOTE_BOOT)

    //
    // Load the SYSTEM hive.
    //
    //
    bLastKnownGoodChosenLate = bLastKnownGood;
    Status = BlLoadAndScanSystemHive(LoadDeviceId,
                                     LoadDevice,
                                     LoadFileName,
                                     BootFileSystem,
                                     &bLastKnownGoodChosenLate,
                                     &ServerHive,
                                     BadFileName);

    if (Status != ESUCCESS) {
        if (BlRebootSystem != FALSE) {
            Status = ESUCCESS;

        } else {
            BlBadFileMessage(BadFileName);
        }

        goto LoadFailed;
    }

    if (bLastKnownGoodChosenLate) {

        //
        // The user may have selected last known good boot after the kernel and
        // friends were loaded. Update the boot path list here as neccessary.
        //
        if (!bLastKnownGood) {

            ASSERT((LoadDevicePathSet.PathCount < MAX_PATH_SOURCES) &&
                   (LoadDevicePathSet.PathCount == 1));

            //
            // Move the current boot path to the end of our last good array.
            //
            LoadDevicePathSet.Source[2] = LoadDevicePathSet.Source[0];

            //
            // Add the last known good paths as if we are in a LastKnownGood boot.
            //
            LoadDevicePathSet.Source[0].DeviceId = LoadDeviceId;
            LoadDevicePathSet.Source[0].DeviceName = LoadDevice;
            LoadDevicePathSet.Source[0].DirectoryPath = LoadDeviceLKG1Path;

            LoadDevicePathSet.Source[1].DeviceId = LoadDeviceId;
            LoadDevicePathSet.Source[1].DeviceName = LoadDevice;
            LoadDevicePathSet.Source[1].DirectoryPath = LoadDeviceLKG2Path;

            LoadDevicePathSet.PathCount = 3;

            bLastKnownGood = TRUE;
        }

    } else {

        //
        // The user might have changed his mind and deselected LKG. If so undo
        // the path work here.
        //
        if (bLastKnownGood) {

            ASSERT((LoadDevicePathSet.PathCount < MAX_PATH_SOURCES) &&
                   (LoadDevicePathSet.PathCount == 3));

            //
            // Move the current boot path to the end of our last good array.
            //
            LoadDevicePathSet.Source[0] = LoadDevicePathSet.Source[2];

            LoadDevicePathSet.PathCount = 1;

            bLastKnownGood = FALSE;
        }
    }

    //
    // Count the number of drivers we need to load
    //
    BlMaxFilesToLoad = BlNumFilesLoaded;

    BootDriverListHead = &(BlLoaderBlock->BootDriverListHead);
    NextEntry = BootDriverListHead->Flink ;

    while (NextEntry != BootDriverListHead) {
        DriverNode = CONTAINING_RECORD(NextEntry,
                                       BOOT_DRIVER_NODE,
                                       ListEntry.Link);

        DriverEntry = &DriverNode->ListEntry;
        NextEntry = DriverEntry->Link.Flink;
        BlMaxFilesToLoad++;
    }

    //
    // Rescale the progress bar
    //
    BlRedrawProgressBar();

    //
    // Insert the headless driver onto the boot driver list if this is supposed to be a
    // headless boot.
    //
    // The SAC is only availabe on server products, so we need to check the
    // product type.
    //

    if ((BlLoaderBlock->Extension->HeadlessLoaderBlock != NULL) && ServerHive) {

        BlAddToBootDriverList(
            &BlLoaderBlock->BootDriverListHead,
            L"sacdrv.sys",  // Driver name
            L"sacdrv",      // Service
            L"SAC",         // Group
            1,              // Tag
            NormalError,    // ErrorControl
            TRUE            // Insert at head of list
            );

    }


#if defined(REMOTE_BOOT)
    //
    // If booting from the net, then save the IP address and subnet mask,
    // and determine which net card driver we need to load. This may involve
    // doing an exchange with the server if the registry is not set up
    // correctly.
    //

    if (BlBootingFromNet && NetworkBootRom) {

        NET_CARD_INFO tempNetCardInfo;
        PSETUP_LOADER_BLOCK setupLoaderBlock = BlLoaderBlock->SetupLoaderBlock;

        //
        //  Pass DHCP information to OS for use by TCP/IP
        //

        setupLoaderBlock->IpAddress = NetLocalIpAddress;
        setupLoaderBlock->SubnetMask = NetLocalSubnetMask;
        setupLoaderBlock->DefaultRouter = NetGatewayIpAddress;
        setupLoaderBlock->ServerIpAddress = NetServerIpAddress;

        //
        // Get information about the net card from the ROM.
        //

        NtStatus = NetQueryCardInfo(
                     &tempNetCardInfo
                     );

        if (NtStatus != STATUS_SUCCESS) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        //
        // If the net card info is the same as the one that BlLoadAndScanSystemHive
        // stored in the setup loader block, and it also read something into
        // the hardware ID and driver name parameters, then we are fine,
        // otherwise we need to do an exchange with the server to get
        // the information.
        //
        // If we don't do an exchange with the server, then NetbootCardRegistry
        // will stay NULL, which will be OK because even if the card has
        // moved to a different slot, the registry params still go in the
        // same place.
        //

        if ((memcmp(
                 &tempNetCardInfo,
                 setupLoaderBlock->NetbootCardInfo,
                 sizeof(NET_CARD_INFO)) != 0) ||
            (setupLoaderBlock->NetbootCardHardwareId[0] == L'\0') ||
            (setupLoaderBlock->NetbootCardDriverName[0] == L'\0') ||
            (setupLoaderBlock->NetbootCardServiceName[0] == L'\0')) {

            //
            // This call may allocate setupLoaderBlock->NetbootCardRegistry
            //

            //
            // If we ever do go back to remote boot land, we'll have
            // to fill the second parameter with the server setup path of the
            // flat NT image.  It doesn't look like we conveniently have it
            // here so we might have to store it in the setup loader block
            // so that we can pass it in here.  We'll postpone this work
            // until we do the full remote install work.  The path should be
            // set to \srv\reminst\setup\english\images\cd1911.
            //

            NtStatus = NetQueryDriverInfo(
                         &tempNetCardInfo,
                         NULL,
                         SavedLoadFileName,
                         setupLoaderBlock->NetbootCardHardwareId,
                         sizeof(setupLoaderBlock->NetbootCardHardwareId),
                         setupLoaderBlock->NetbootCardDriverName,
                         NULL,       // don't need NetbootCardDriverName in ANSI
                         sizeof(setupLoaderBlock->NetbootCardDriverName),
                         setupLoaderBlock->NetbootCardServiceName,
                         sizeof(setupLoaderBlock->NetbootCardServiceName),
                         &setupLoaderBlock->NetbootCardRegistry,
                         &setupLoaderBlock->NetbootCardRegistryLength);

            if (NtStatus != STATUS_SUCCESS) {
                Status = ENOMEM;
                BlFatalError(LOAD_HW_MEM_CLASS,
                             DIAG_BL_MEMORY_INIT,
                             LOAD_HW_MEM_ACT);
                goto LoadFailed;
            }

            //
            //  if we detected a new card, then remember to pin it later.
            //

            if (setupLoaderBlock->NetbootCardRegistry != NULL) {

                setupLoaderBlock->Flags |= SETUPBLK_FLAGS_PIN_NET_DRIVER;
            }
        }

        //
        // Add an entry to the BootDriverList for the netboot card,
        // because it will either not have a registry entry or else
        // will have one with Start set to 3.
        //
        // NOTE: This routine does NOT resort the list.
        //

        BlAddToBootDriverList(
            &BlLoaderBlock->BootDriverListHead,
            setupLoaderBlock->NetbootCardDriverName,
            setupLoaderBlock->NetbootCardServiceName,
            L"NDIS",        // Group
            1,              // Tag
            NormalError,    // ErrorControl
            FALSE           // Insert at Tail of list
            );

        RtlMoveMemory(
            setupLoaderBlock->NetbootCardInfo,
            &tempNetCardInfo,
            sizeof(NET_CARD_INFO)
            );

    }
#endif // defined(REMOTE_BOOT)

    //
    // Load boot drivers
    //
    Status = BlLoadBootDrivers(&LoadDevicePathSet,
                               &BlLoaderBlock->BootDriverListHead,
                               BadFileName);

    if (Status != ESUCCESS) {
        if (BlRebootSystem != FALSE) {
            Status = ESUCCESS;

        } else {
            BlBadFileMessage(BadFileName);
        }

        goto LoadFailed;
    }

    //
    // Load the blocked driver database.
    //

    RtlInitUnicodeString(&unicodeString, L"drvmain.sdb");
    strcpy(Directory, LoadFileName);
    strcat(Directory, "\\AppPatch\\");

    //
    // Let the kernel deal with failure to load this driver database.
    //

    BlLoaderBlock->Extension->DrvDBImage = NULL;
    BlLoaderBlock->Extension->DrvDBSize = 0;
    BlLoadDrvDB(    LoadDeviceId,
                    LoadDevice,
                    Directory,
                    &unicodeString,
                    &BlLoaderBlock->Extension->DrvDBImage,
                    &BlLoaderBlock->Extension->DrvDBSize,
                    BadFileName);

#if defined(REMOTE_BOOT)
    if (BlBootingFromNet) {

        ARC_STATUS ArcStatus;
        ULONG FileId;

        //
        // Exchange with the server to set up for the future IPSEC conversation
        // we will have. Whether IPSEC is enabled is determined in BlLoadAndScanSystemHives.
        //

        if ((BlLoaderBlock->SetupLoaderBlock->Flags & SETUPBLK_FLAGS_IPSEC_ENABLED) != 0) {

            BlLoaderBlock->SetupLoaderBlock->IpsecInboundSpi = 0x11111111;

            NetPrepareIpsec(
                BlLoaderBlock->SetupLoaderBlock->IpsecInboundSpi,
                &BlLoaderBlock->SetupLoaderBlock->IpsecSessionKey,
                &BlLoaderBlock->SetupLoaderBlock->IpsecOutboundSpi
                );
        }

        //
        // Indicate whether the CSC needs to be repinned or disabled.
        //

        if ( NetBootRepin ) {
            BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_REPIN;
        }
        if ( !NetBootCSC ) {
            BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_DISABLE_CSC;
        }

        //
        // Restore the server\share at the front of the OsLoader and
        // LoadFileName strings.
        //

        OsLoader = SavedOsLoader;
        LoadFileName = SavedLoadFileName;

        //
        // Read the secret off the disk, if there is one, and store it
        // in the loader block.
        //

        ArcStatus = BlOpenRawDisk(&FileId);

        if (ArcStatus == ESUCCESS) {

            BlLoaderBlock->SetupLoaderBlock->NetBootSecret = BlAllocateHeap(sizeof(RI_SECRET));
            if (BlLoaderBlock->SetupLoaderBlock->NetBootSecret == NULL) {
                Status = ENOMEM;
                BlFatalError(LOAD_HW_MEM_CLASS,
                             DIAG_BL_MEMORY_INIT,
                             LOAD_HW_MEM_ACT);
                goto LoadFailed;
            }

            ArcStatus = BlReadSecret(
                            FileId,
                            (PRI_SECRET)(BlLoaderBlock->SetupLoaderBlock->NetBootSecret));
            if (Status != ESUCCESS) {
                BlFatalError(LOAD_HW_MEM_CLASS,
                             DIAG_BL_MEMORY_INIT,
                             LOAD_HW_MEM_ACT);
                goto LoadFailed;
            }

            ArcStatus = BlCloseRawDisk(FileId);

            //
            // By now we have TFTPed some files so this will be TRUE if it
            // is ever going to be.
            //

            BlLoaderBlock->SetupLoaderBlock->NetBootUsePassword2 = NetBootTftpUsedPassword2;
        }

    }
#endif // defined(REMOTE_BOOT)

    //
    // Generate the ARC boot device name and NT path name.
    //

    Status = BlGenerateDeviceNames(LoadDevice, DeviceName, &DevicePrefix[0]);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_ARC_BOOT_DEV_NAME,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    FileSize = (ULONG)strlen(DeviceName) + 1;
    FileName = (PCHAR)BlAllocateHeap(FileSize);
    strcpy(FileName, DeviceName);
    BlLoaderBlock->ArcBootDeviceName = FileName;

    FileSize = (ULONG)strlen(LoadFileName) + 2;
    FileName = (PCHAR)BlAllocateHeap( FileSize);
    strcpy(FileName, LoadFileName);
    strcat(FileName, "\\");
    BlLoaderBlock->NtBootPathName = FileName;

    //
    // Generate the ARC HAL device name and NT path name.
    //
    // On the x86, the systempartition variable lies, and instead points to
    // the location of the hal. Therefore, the variable, 'X86SystemPartition'
    // is defined for the real system partition.
    //

#if defined(_X86_)

    x86SystemPartition = BlGetArgumentValue(Argc, Argv, "x86systempartition");
    strcpy(&DeviceName[0], x86SystemPartition);

#else

    Status = BlGenerateDeviceNames(SystemDevice, &DeviceName[0], &DevicePrefix[0]);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_ARC_BOOT_DEV_NAME,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

#endif

    FileSize = (ULONG)strlen(DeviceName) + 1;
    FileName = (PCHAR)BlAllocateHeap(FileSize);
    strcpy(FileName, DeviceName);
    BlLoaderBlock->ArcHalDeviceName = FileName;

    //
    // On the x86, this structure is unfortunately named. What we really need
    // here is the osloader path. What we actually have is a path to the HAL.
    // Since this path is always at the root of the partition, hardcode it here.
    //

#if defined(_X86_)

    FileName = (PCHAR)BlAllocateHeap(2);
    FileName[0] = '\\';
    FileName[1] = '\0';

#else

    FileSize = (ULONG)strlen(&SystemDevicePath[0]) + 1;
    FileName = (PCHAR)BlAllocateHeap(FileSize);
    strcpy(FileName, &SystemDevicePath[0]);

#endif

    BlLoaderBlock->NtHalPathName = FileName;

    //
    // Close the open handles & stop caching on closed devices.
    //

    ArcClose(LoadDeviceId);
    if (bDiskCacheInitialized) {
        BlDiskCacheStopCachingOnDevice(LoadDeviceId);
    }

    //
    // Close the system device only if it is different from the
    // LoadDevice.
    //

    if (SystemDeviceId != LoadDeviceId) {
        ArcClose(SystemDeviceId);
        if (bDiskCacheInitialized) {
            BlDiskCacheStopCachingOnDevice(SystemDeviceId);
        }
    }

    //
    // Bump the progress bar all the way to 100% as this is our last chance
    // before we jump into the kernel.
    //
    BlUpdateProgressBar(100);

    if ( BlBootingFromNet ) {

        //
        // If booting from Network, we should save the network information
        // in the network loader block for use by the kernel.
        //

        BlLoaderBlock->Extension->NetworkLoaderBlock = BlAllocateHeap(sizeof(NETWORK_LOADER_BLOCK));
        if (BlLoaderBlock->Extension->NetworkLoaderBlock == NULL) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        memset( BlLoaderBlock->Extension->NetworkLoaderBlock, 0, sizeof(NETWORK_LOADER_BLOCK) );

        //
        //  Pass DHCP information to OS for use by TCP/IP
        //

        NtStatus = NetFillNetworkLoaderBlock(BlLoaderBlock->Extension->NetworkLoaderBlock);
        if (NtStatus != STATUS_SUCCESS) {
            Status = NtStatus;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        //
        // Close down the remote boot network file system.
        //
        // NOTE: If BlBootingFromNet, don't do anything after this point
        // that would cause access to the boot ROM.
        //

        NetTerminate();
    }

#if defined(_X86_)

    //
    // Write out the boot status flags to disk so we can determine if the
    // OS fails to boot.
    //

    BlWriteBootStatusFlags(LoadDeviceId, (PUCHAR)LoadFileName, FALSE, FALSE);

#endif

#if defined(_X86_)

    //
    // Close down the arc emulator's i/o system if we initialized it.
    // This cannot be done after BlSetupForNt becase that routine will
    // unmap the miniport code the arc emulator may need to shutdown.
    //

    AETerminateIo();
#endif

    //
    // Execute the architecture specific setup code.
    //

    Status = BlSetupForNt(BlLoaderBlock);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_SETUP_FOR_NT,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Transfer control to loaded image.
    //

    BlTransferToKernel(SystemEntry, BlLoaderBlock);

    //
    // Any return from the system is an error.
    //

    Status = EBADF;
    BlFatalError(LOAD_SW_BAD_FILE_CLASS,
                 DIAG_BL_KERNEL_INIT_XFER,
                 LOAD_SW_FILE_REINST_ACT);

    //
    // The load failed.
    //

LoadFailed:

    //
    // We do not know if the devices we are caching will be
    // closed/reopened etc beyond this function. To be safe,
    // uninitialize the disk caching.
    //

    if (bDiskCacheInitialized) {
        BlDiskCacheUninitialize();
    }

    return Status;
}


VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    )

/*++

Routine Description:

    This routine outputs a loading message to the console output device.

Arguments:

    DeviceName - Supplies a pointer to a zero terminated device name.

    FileName - Supplies a pointer to a zero terminated file name.

    FileDescription - Friendly name of the file in question.

Return Value:

    None.

--*/

{

    ULONG Count;
    CHAR OutputBuffer[256];
#ifdef UNICODE
    TCHAR OutputBufferUnicode[256];
    ANSI_STRING aString;
    UNICODE_STRING uString;
#endif
    PTCHAR p;

    UNREFERENCED_PARAMETER(FileDescription);

    if(!DisplayLogoOnBoot) {

        //
        // Proceed only if no logo is displayed.

        ///////////////////////////////////////////////

        //
        // Construct and output loading file message.
        //

        if (!BlOutputDots) {
            strcpy(&OutputBuffer[0], "  ");

            if (DeviceName)
                strcat(&OutputBuffer[0], DeviceName);

            if (FileName)
                strcat(&OutputBuffer[0], FileName);

            strcat(&OutputBuffer[0], "\r\n");

            BlLog((LOG_LOGFILE,OutputBuffer));
#ifdef UNICODE
            p = OutputBufferUnicode;
            uString.Buffer = OutputBufferUnicode;
            uString.MaximumLength = sizeof(OutputBufferUnicode);
            RtlInitAnsiString(&aString, OutputBuffer );
            RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#else
            p = OutputBuffer;
#endif
            ArcWrite(BlConsoleOutDeviceId,
                      p,
                      (ULONG)_tcslen(p)*sizeof(TCHAR),
                      &Count);
        }

    }

    return;
}

ARC_STATUS
BlLoadAndScanSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PWSTR BootFileSystem,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT BOOLEAN *ServerHive,
    OUT PCHAR BadFileName
    )

/*++

Routine Description:

    This function loads the system hive into memory, verifies its
    consistency, scans it for the list of boot drivers, and loads
    the resulting list of drivers.

    If the system hive cannot be loaded or is not a valid hive, it
    is rejected and the system.alt hive is used. If this is invalid,
    the boot must fail.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT system32 directory.

    HiveName - Supplies the name of the SYSTEM hive

    LastKnownGoodBoot - On input, LastKnownGood indicates whether LKG has been
                        selected. This value is updated to TRUE if the user
                        chooses LKG via the profile configuration menu.

    ServerHive - Return TRUE if this is a server hive, else FALSE.

    BadFileName - Returns the file required for booting that was corrupt
        or missing.  This will not be filled in if ESUCCESS is returned.

Return Value:

    ESUCCESS  - System hive valid and all necessary boot drivers successfully
           loaded.

    !ESUCCESS - System hive corrupt or critical boot drivers not present.
                LastKnownGoodBoot receives FALSE, BadFileName contains name
                of corrupted/missing file.

--*/

{

    ARC_STATUS Status;
    PTCHAR FailReason;
    CHAR Directory[256];
    CHAR FontDirectory[256];
    UNICODE_STRING AnsiCodepage;
    UNICODE_STRING OemCodepage;
    UNICODE_STRING OemHalFont;
    UNICODE_STRING LanguageTable;
    BOOLEAN RestartSetup;
    BOOLEAN LogPresent;
#ifdef _WANT_MACHINE_IDENTIFICATION
    UNICODE_STRING unicodeString;
#endif


    if (sizeof(Directory) < strlen(DirectoryPath) + sizeof("\\system32\\config\\")) {
        return ENOMEM;
    }

    strcpy(Directory,DirectoryPath);
    strcat(Directory,"\\system32\\config\\");

    Status = BlLoadAndInitSystemHive(DeviceId,
                                     DeviceName,
                                     Directory,
                                     "system",
                                     FALSE,
                                     &RestartSetup,
                                     &LogPresent);

    if(Status != ESUCCESS) {

        if( !LogPresent ) {
            //
            // Bogus hive, try system.alt only if no log is present.
            //
            Status = BlLoadAndInitSystemHive(DeviceId,
                                             DeviceName,
                                             Directory,
                                             "system.alt",
                                             TRUE,
                                             &RestartSetup,
                                             &LogPresent);
        }

        if(Status != ESUCCESS) {
            strcpy(BadFileName,DirectoryPath);
            strcat(BadFileName,"\\SYSTEM32\\CONFIG\\SYSTEM");
            goto HiveScanFailed;
        }
    }

    if(RestartSetup) {

        //
        // Need to restart setup.
        //

        Status = BlLoadAndInitSystemHive(DeviceId,
                                         DeviceName,
                                         Directory,
                                         "system.sav",
                                         TRUE,
                                         &RestartSetup,
                                         &LogPresent);

        if(Status != ESUCCESS) {
            strcpy(BadFileName,DirectoryPath);
            strcat(BadFileName,"\\SYSTEM32\\CONFIG\\SYSTEM.SAV");
            goto HiveScanFailed;
        }
    }

    //
    // Hive is there, it's valid, go compute the driver list and NLS
    // filenames.  Note that if this fails, there is no point in switching
    // to system.alt, since it will always be the same as system.
    //

    FailReason = BlScanRegistry(BootFileSystem,
                                LastKnownGoodBoot,
                                &BlLoaderBlock->BootDriverListHead,
                                &AnsiCodepage,
                                &OemCodepage,
                                &LanguageTable,
                                &OemHalFont,
#ifdef _WANT_MACHINE_IDENTIFICATION
                                &unicodeString,
#endif
                                BlLoaderBlock->SetupLoaderBlock,
                                ServerHive);

    if (FailReason != NULL) {
        Status = EBADF;
        strcpy(BadFileName,Directory);
        strcat(BadFileName,"SYSTEM");
        goto HiveScanFailed;
    }

    strcpy(Directory,DirectoryPath);
    strcat(Directory,"\\system32\\");

    //
    // Load NLS data tables.
    //

    Status = BlLoadNLSData(DeviceId,
                           DeviceName,
                           Directory,
                           &AnsiCodepage,
                           &OemCodepage,
                           &LanguageTable,
                           BadFileName);

    if (Status != ESUCCESS) {
        goto HiveScanFailed;
    }

    //
    // Load the OEM font file to be used by the HAL for possible frame
    // buffer displays.
    //

#ifdef i386

    if (OemHalFont.Buffer == NULL) {
        goto oktoskipfont;
    }

#endif

    //
    // On newer systems fonts are in the FONTS directory.
    // On older systems fonts are in the SYSTEM directory.
    //

    strcpy(FontDirectory, DirectoryPath);
    strcat(FontDirectory, "\\FONTS\\");
    Status = BlLoadOemHalFont(DeviceId,
                              DeviceName,
                              FontDirectory,
                              &OemHalFont,
                              BadFileName);

    if(Status != ESUCCESS) {
        strcpy(FontDirectory, DirectoryPath);
        strcat(FontDirectory, "\\SYSTEM\\");
        Status = BlLoadOemHalFont(DeviceId,
                                  DeviceName,
                                  FontDirectory,
                                  &OemHalFont,
                                  BadFileName);
    }

    if (Status != ESUCCESS) {
#ifndef i386
        goto HiveScanFailed;
#endif

    }

#ifdef i386
oktoskipfont:
#endif
    if (BlLoaderBlock->Extension && BlLoaderBlock->Extension->Size >= sizeof(LOADER_PARAMETER_EXTENSION)) {

        ULONG   majorVersion;
        ULONG   minorVersion;
        CHAR    versionBuffer[64];
        PCHAR   major;
        PCHAR   minor;

        major = strcpy(versionBuffer, VER_PRODUCTVERSION_STR);
        minor = strchr(major, '.');
        *minor++ = '\0';
        majorVersion = atoi(major);
        minorVersion = atoi(minor);
        if (    BlLoaderBlock->Extension->MajorVersion > majorVersion ||
                (BlLoaderBlock->Extension->MajorVersion == majorVersion &&
                    BlLoaderBlock->Extension->MinorVersion >= minorVersion)) {

#ifdef i386
#ifdef _WANT_MACHINE_IDENTIFICATION

            if (unicodeString.Length) {

                //
                // For x86 machines, read in the inf into memory for processing
                // by the kernel.
                //

                strcpy(Directory,DirectoryPath);
                strcat(Directory,"\\inf\\");

                //
                // Fail to boot if there is any error in loading this
                // critical inf.
                //

                Status = BlLoadBiosinfoInf( DeviceId,
                                            DeviceName,
                                            Directory,
                                            &unicodeString,
                                            &BlLoaderBlock->Extension->InfFileImage,
                                            &BlLoaderBlock->Extension->InfFileSize,
                                            BadFileName);
                if (Status != ESUCCESS) {

                    goto HiveScanFailed;
                }
            }
#endif
#endif
        }
    }

HiveScanFailed:

    if (Status != ESUCCESS) {

        *LastKnownGoodBoot = FALSE;
    }

    return(Status);
}

VOID
BlBadFileMessage(
    IN PCHAR BadFileName
    )

/*++

Routine Description:

    This function displays the error message for a missing or incorrect
    critical file.

Arguments:

    BadFileName - Supplies the name of the file that is missing or
                  corrupt.

Return Value:

    None.

--*/

{

    ULONG Count;
    PTCHAR Text;
    PTSTR  pBadFileName;
#ifdef UNICODE
    WCHAR BadFileNameW[128];
    ANSI_STRING aString;
    UNICODE_STRING uString;

    pBadFileName = BadFileNameW;
    uString.Buffer = BadFileNameW;
    uString.MaximumLength = sizeof(BadFileNameW);
    RtlInitAnsiString(&aString, BadFileName);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#else
    pBadFileName = BadFileName;
#endif

    ArcWrite(BlConsoleOutDeviceId,
             TEXT("\r\n"),
             (ULONG)_tcslen(TEXT("\r\n"))*sizeof(TCHAR),
             &Count);


    //
    // Remove any remains from the last known good message.
    //

    BlClearToEndOfScreen();
    Text = BlFindMessage(LOAD_SW_MIS_FILE_CLASS);
    if (Text != NULL) {
        ArcWrite(BlConsoleOutDeviceId,
                 Text,
                 (ULONG)_tcslen(Text)*sizeof(TCHAR),
                 &Count);
    }

    ArcWrite(BlConsoleOutDeviceId,
             pBadFileName,
             (ULONG)_tcslen(pBadFileName)*sizeof(TCHAR),
             &Count);

    ArcWrite(BlConsoleOutDeviceId,
             TEXT("\r\n\r\n"),
             (ULONG)_tcslen(TEXT("\r\n\r\n"))*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(LOAD_SW_FILE_REST_ACT);
    if (Text != NULL) {
        ArcWrite(BlConsoleOutDeviceId,
                 Text,
                 (ULONG)_tcslen(Text)*sizeof(TCHAR),
                 &Count);
    }
}


VOID
BlClearToEndOfScreen(
    VOID
    );

VOID
BlFatalError(
    IN ULONG ClassMessage,
    IN ULONG DetailMessage,
    IN ULONG ActionMessage
    )

/*++

Routine Description:

    This function looks up messages to display at a error condition.
    It attempts to locate the string in the resource section of the
    osloader.  If that fails, it prints a numerical error code.

    The only time it should print a numerical error code is if the
    resource section could not be located.  This will only happen
    on ARC machines where boot fails before the osloader.exe file
    can be opened.

Arguments:

    ClassMessage - General message that describes the class of
                   problem.

    DetailMessage - Detailed description of what caused problem

    ActionMessage - Message that describes a course of action
                    for user to take.

Return Value:

    none

--*/


{

    PTCHAR Text;
    TCHAR Buffer[40];
    ULONG Count;

    ArcWrite(BlConsoleOutDeviceId,
             TEXT("\r\n"),
             (ULONG)_tcslen(TEXT("\r\n"))*sizeof(TCHAR),
             &Count);

    //
    // Remove any remains from the last known good message.
    //

    BlClearToEndOfScreen();
    Text = BlFindMessage(ClassMessage);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),ClassMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             (ULONG)_tcslen(Text)*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(DetailMessage);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),DetailMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             (ULONG)_tcslen(Text)*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(ActionMessage);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),ActionMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             (ULONG)_tcslen(Text)*sizeof(TCHAR),
             &Count);

#if defined(ENABLE_LOADER_DEBUG) || DBG
#if (defined(_X86_) || defined(_ALPHA_) || defined(_IA64_)) && !defined(ARCI386) // everything but ARCI386
    if(BdDebuggerEnabled) {
        DbgBreakPoint();
    }
#endif
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF

#
# BOOT_LIB_DIR is the relative path to boot.lib.
#
!IFNDEF BOOT_LIB_DIR
BOOT_LIB_DIR=daytona$(DBG_LDR)
!ENDIF

#
# RSP_DIR is the relative path to the linker response files.
#
!IFNDEF RSP_DIR
RSP_DIR=daytona
!ENDIF

$(O)\msg.mc : ..\msg.$(LANGUAGE)
    copy $** $@

!IF $(386)

OSLOADER_LIBS=\
    $(O)\bldr.lib \
    $(O)\osloader.res \
    $(O)\osloader.exp \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

$(O)\osloader.res: $(O)\msg.mc

$(O)\osloader.lib $(O)\osloader.exp: ..\daytona\i386\osloader.def
    $(LIB_NAME) -machine:i386 -out:$(O)\osloader.lib -def:..\daytona\i386\osloader.def ..\..\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib $(O)\bldr.lib -ignore:4001

$(O)\link.rsp : ..\makefile.inc
    type << > $@
-machine:i386
-debug
-entry:NtProcessStartup@4
-fixed
-force:multiple
-ignore:4049,4001
-incremental:no
-map
-opt:ref
-opt:icf
-subsystem:native
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

LDR_ROOT=osloader$(DBG_LDR)
LDR_NAME=$(LDR_ROOT).exe

$(O)\$(LDR_NAME): $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp

#
# Inject ntdetect.com as a PE data section into osloader.ntd. This
# is used on a remote boot to avoid downloading ntdetect.com
# over the network.
#
$(O)\$(LDR_ROOT).ntd: $(O)\$(LDR_NAME) $(PROJECT_ROOT)\boot\detect\fre\$(O)\ntdetect.com
    addsect /o:$(O)\$(LDR_ROOT).ntd /i:$(O)\$(LDR_NAME) /d:$(PROJECT_ROOT)\boot\detect\fre\$(O)\ntdetect.com /s:.detect

!if "$(LDR_NAME)" == "osloader$(DBG_LDR).exe"

#
# STARTUP_DIR is the relative path to startup.com.
# All languages and NEC_98 use their own startup.com,
# except FE langauges which use the US version when
# creating NTLDR.
#
!IFNDEF STARTUP_DIR
STARTUP_DIR=$(ALT_PROJECT)
!ENDIF

$(O)\NTLDR$(DBG_LDR): $(OSLOADER_LIBS) $(O)\$(LDR_NAME) ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com makefile.inc
    -copy $(O)\osloader$(DBG_LDR).exe $(O)\osloader.spl
    splitsym -a $(O)\osloader.spl
    -copy /b ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com+$(O)\osloader.spl $@
    -del /q $(O)\osloader.dbg
    -del /q $(O)\osloader.spl
!endif

!ELSE IF $(IA64)

OSLOADER_LIBS=\
    $(O)\bldr.lib \
    $(O)\osloader.res \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
#    $(SDK_LIB_PATH)\libssc.lib

!IFNDEF STARTUP_DIR
STARTROM_DIR=$(ALT_PROJECT)
!ENDIF

$(O)\link.rsp : ..\makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:IA64
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
!IF "$(BUILD_DEBUG_LOADER)" != ""
-fixed
!ENDIF
-entry:main
-ignore:4049,4001
-nodefaultlib
-opt:icf
-opt:ref
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\osloader.res: $(O)\msg.mc

OSLOADER_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(O)\bldr.lib

$(O)\osloader.lib $(O)\osloader.exp: ..\ia64\osloader.def
    $(LIB_NAME) -machine:ia64 -out:$(O)\osloader.lib -def:..\ia64\osloader.def $(OSLOADER_LIB_COMPONENTS) -ignore:4001

$(O)\ia64ldr$(DBG_LDR).efi: $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp
        
!ELSE

OSLOADER_LIBS=\
    $(O)\bldr.lib \
    $(O)\osloader.res \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

$(O)\link.rsp : ..\makefile.inc 
    type << > $@
-rom
-debug:full
-fixed
-map
-align:0x200
!if $(AXP64)
-base:0xFFFFFFFF80600000
!else
-base:0x80600000
!endif
-entry:BlOsLoader
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\osloader.res: $(O)\msg.mc

$(O)\osloader$(DBG_LDR).exe: $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
        -$(LINK_NAME) -out:$@ @$(O)\link.rsp
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\daytona_dbg\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\netboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    osloader.c

Abstract:

    This module contains the code that implements the NT operating system
    loader.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bldr.h"
#include "haldtect.h"
#include "parseini.h"
#include "setupbat.h"
#include "ctype.h"
#include "stdio.h"
#include "string.h"
#include "msg.h"
#include <netboot.h>


#if defined(REMOTE_BOOT)


extern BOOLEAN NetFS_Cache;

UCHAR szRemoteBootCfgFile[] = "RemoteBoot.cfg";
CHAR KernelFileName[8+1+3+1]="ntoskrnl.exe";
CHAR HalFileName[8+1+3+1]="hal.dll";

VOID
BlWarnAboutFormat(
    IN BOOLEAN SecretValid,
    IN PUCHAR OsLoader
    );


ARC_STATUS
BlCheckMachineReplacement (
    IN PCHAR SystemDevice,
    IN ULONG SystemDeviceId,
    IN ULONGLONG NetRebootParameter,
    IN PUCHAR OsLoader
    )

/*++

Routine Description:

    This routine checks to see if a part of the machine has been replaced.  Specifically,
    it checks if:
        - Hal is different.
        - Physical Disk is different.

    If it finds either case, then it creates at SETUP_LOADER_BLOCK and sets the flags
    to pass to the kernel.

    Note: NetFS_Cache is a boolean which is used to turn on/off client side caching in the loader.
    When set to FALSE, the cache is turned off.

Arguments:

    SystemDevice - Character string of the ARC name of the system.

    SystemDeviceId - Handle to the server share where this machine account exists.

    NetRebootParameter - Any parameter that may have been passed during a soft reboot of the PC.

    OsLoader - TFTP path to osloader.exe

Return Value:

    Success or not.  Failure means to quit loading.

--*/

{
    ARC_DISK_SIGNATURE Signature;
    ARC_STATUS Status;
    BOOLEAN NetBootRequiresFormat = FALSE;
    BOOLEAN NetBootClientCacheStale = FALSE;
    BOOLEAN NetBootDisconnected = FALSE;
    BOOLEAN SkipHalCheck;
    ULONG FileId;
    ULONG CacheBootSerialNumber;
    ULONG CacheDiskSignature;
    ULONG ServerBootSerialNumber;
    ULONG ServerDiskSignature;
    UCHAR NetBootHalName[MAX_HAL_NAME_LENGTH + 1];
    PUCHAR NetBootDetectedHalName;
    UCHAR OutputBuffer[256];
    UCHAR DiskName[80];
    PUCHAR p;
    PUCHAR Guid;
    ULONG GuidLength;


    //
    // Detect which HAL we want to use.
    //
    NetBootDetectedHalName = SlDetectHal();
    SkipHalCheck = (NetBootDetectedHalName == NULL);

    if (!NetworkBootRom) {
        NetBootDisconnected = TRUE;
        goto EndTesting;
    }

    strcpy(OutputBuffer, NetBootPath);
    strcat(OutputBuffer, szRemoteBootCfgFile);

    if (BlOpen(SystemDeviceId, OutputBuffer, ArcOpenReadOnly, &FileId) == ESUCCESS) {

        Status = BlReadAtOffset(FileId, 0, sizeof(ULONG), &CacheBootSerialNumber);

        BlClose(FileId);

        if (Status != ESUCCESS) {
            NetBootClientCacheStale = TRUE;
            NetBootRequiresFormat = TRUE;
            NetFS_Cache = FALSE;
            goto EndTesting;
        }

        NetFS_Cache = FALSE;

        if (BlOpen(SystemDeviceId, OutputBuffer, ArcOpenReadOnly, &FileId) == ESUCCESS) {

            // Get parameters from each file
            Status = BlReadAtOffset(FileId, 0, sizeof(ULONG), &ServerBootSerialNumber);
            if (Status != ESUCCESS) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }
            Status = BlReadAtOffset(FileId, sizeof(ULONG), sizeof(ULONG), &ServerDiskSignature);
            if (Status != ESUCCESS) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }

            Signature.ArcName = OutputBuffer;

            strcpy(DiskName, NetBootActivePartitionName);
            p = strstr(DiskName, "partition");
            ASSERT( p != NULL );
            *p = '\0';

            if (!BlGetDiskSignature(DiskName,
                                    FALSE,
                                    &Signature
                                   )) {
                // Assume diskless PC
                BlClose(FileId);
                goto EndTesting;
            }

            CacheDiskSignature = Signature.Signature;
            if (CacheBootSerialNumber < ServerBootSerialNumber) {
                NetBootClientCacheStale = TRUE;
            }

            if (CacheDiskSignature != ServerDiskSignature) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }

            Status = BlReadAtOffset(FileId,
                                    sizeof(ULONG) + sizeof(ULONG),
                                    sizeof(char) * (MAX_HAL_NAME_LENGTH+1),
                                    NetBootHalName
                                   );
            if (Status != ESUCCESS) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }

            GetGuid(&Guid, &GuidLength);

            if (!SkipHalCheck && strncmp(NetBootHalName, NetBootDetectedHalName, MAX_HAL_NAME_LENGTH)) {
                if (!NT_SUCCESS(NetCopyHalAndKernel(NetBootDetectedHalName,
                                                    Guid,
                                                    GuidLength))) {
                    Status = EMFILE;
                    goto CleanUp;
                }
                NetBootClientCacheStale = TRUE;
            }

            BlClose(FileId);

        } else {
            // Running disconnected.  Assume everything is ok.
            NetBootDisconnected = TRUE;
        }

        if (!NetBootClientCacheStale) {
            NetFS_Cache = TRUE;
        }

    } else {

        NetFS_Cache = FALSE;
        NetBootClientCacheStale = TRUE;
        NetBootRequiresFormat = TRUE;

    }

EndTesting:

    Status = ESUCCESS;

    if (NetBootRequiresFormat) {
        BlWarnAboutFormat((BOOLEAN)(NetRebootParameter == NET_REBOOT_SECRET_VALID), OsLoader);
    }

    BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_IS_REMOTE_BOOT;
    if (NetBootClientCacheStale) {
        NetBootRepin = TRUE;
    }
    if ( NetBootDisconnected ) {
        BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_DISCONNECTED;
    }
    if ( NetBootRequiresFormat ) {
        BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_FORMAT_NEEDED;
    }

    memcpy(BlLoaderBlock->SetupLoaderBlock->NetBootHalName,
           NetBootDetectedHalName,
           sizeof(BlLoaderBlock->SetupLoaderBlock->NetBootHalName)
          );
    BlLoaderBlock->SetupLoaderBlock->NetBootHalName[MAX_HAL_NAME_LENGTH] = '\0';

CleanUp:

    return Status;
}

VOID
BlWarnAboutFormat(
    IN BOOLEAN SecretValid,
    IN PUCHAR OsLoader
    )

/*++

Routine Description:

    This routine provides the user-interface for warning the user that
    a new harddisk has been detected and will be formatted.

Arguments:

    SecretValid - If TRUE, then return because there is no message for the user,
        otherwise display a message that the user must logon and the disk will be wiped out.

    OsLoader - Path for TFTP to the osloader.exe image.

Return Value:

    None.

--*/

{
    ULONG HeaderLines;
    ULONG TrailerLines;
    ULONG Count;
    UCHAR Key;
    PCHAR MenuHeader;
    PCHAR MenuTrailer;
    PCHAR Temp;
    ULONG DisplayLines;
    ULONG CurrentSelection = 0;
    UCHAR Buffer[16];

    if (SecretValid) {
        // We don't present the user with a screen in this case because we have already forced
        // a logon and a rewrite of the secret.
        return;
    } else {
        MenuHeader = BlFindMessage(BL_FORCELOGON_HEADER);
    }
    MenuTrailer = BlFindMessage(BL_WARNFORMAT_TRAILER);


    sprintf(Buffer, "%s%s", ASCI_CSI_OUT, ";44;37m"); // White on Blue
    ArcWrite(BlConsoleOutDeviceId, Buffer, strlen(Buffer), &Count);

    BlClearScreen();

    sprintf(Buffer, "%s%s", ASCI_CSI_OUT, ";37;44m"); // Blue on white
    ArcWrite(BlConsoleOutDeviceId, Buffer, strlen(Buffer), &Count);

    //
    // Count the number of lines in the header.
    //
    HeaderLines=BlCountLines(MenuHeader);

    //
    // Display the menu header.
    //

    ArcWrite(BlConsoleOutDeviceId,
             MenuHeader,
             strlen(MenuHeader),
             &Count);

    //
    // Count the number of lines in the trailer.
    //
    TrailerLines=BlCountLines(MenuTrailer);

    BlPositionCursor(1, ScreenHeight-TrailerLines);
    ArcWrite(BlConsoleOutDeviceId,
             MenuTrailer,
             strlen(MenuTrailer),
             &Count);

    //
    // Compute number of selections that can be displayed
    //
    DisplayLines = ScreenHeight-HeaderLines-TrailerLines-3;

    //
    // Start menu selection loop.
    //

    do {
        Temp = BlFindMessage(BL_WARNFORMAT_CONTINUE);
        if (Temp != NULL) {
            BlPositionCursor(5, HeaderLines+3);
            BlSetInverseMode(TRUE);
            ArcWrite(BlConsoleOutDeviceId,
                     Temp,
                     strlen(Temp),
                     &Count);
            BlSetInverseMode(FALSE);
        }

        //
        // Loop waiting for keypress or time change.
        //
        do {
            if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
                BlPositionCursor(1,ScreenHeight);
                BlClearToEndOfLine();
                ArcRead(ARC_CONSOLE_INPUT,
                        &Key,
                        sizeof(Key),
                        &Count);
                break;
            }

        } while ( TRUE );

        switch (Key) {
            case ASCI_CSI_IN:
                ArcRead(ARC_CONSOLE_INPUT,
                        &Key,
                        sizeof(Key),
                        &Count);
                break;

            default:
                break;
        }

    } while ( (Key != ASCII_CR) && (Key != ASCII_LF) );

    BlClearScreen();

    if (!SecretValid) {
        while ( TRUE ) {
            NetSoftReboot(
#if defined(_ALPHA_)
#if defined(_AXP64_)
                "OSChooser\\axp64\\startrom.com",
#else
                "OSChooser\\alpha\\startrom.com",
#endif
#endif
#if defined(_MIPS_)
                "OSChooser\\mips\\startrom.com",
#endif
#if defined(_PPC_)
                "OSChooser\\ppc\\startrom.com",
#endif
#if defined(_IA64_)
                "OSChooser\\ia64\\startrom.com",
#endif
#if defined(_X86_)
                "OSChooser\\i386\\startrom.com",
#endif
                NET_REBOOT_WRITE_SECRET_ONLY,
                OsLoader,
                NULL,    // SIF file
                NULL,    // user
                NULL,    // domain
                NULL    // password
            );
        }
    }
}


#endif // defined(REMOTE_BOOT)


//
// NOTE: [bassamt] Stubs for TextMode setup funtions. These 
// are needed so that we can call SlDetectHal during regular boot.
//

PVOID InfFile = NULL;
PVOID WinntSifHandle = NULL;
BOOLEAN DisableACPI = FALSE;


VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Line - Line number of the error.

    File - Name of the file with the error.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( Line );
    UNREFERENCED_PARAMETER( File );

    return;
}

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    )
/*++

Routine Description:

    This routine does nothing.

Arguments:

    Line - Line number of the error.

    INFFile - Supplies a pointer to the INF filename.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( Line );
    UNREFERENCED_PARAMETER( INFFile );

    return;
}

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    )
/*++

Routine Description:

    This routine does nothing.

Arguments:

    MessageId - Id of the text to display.

    Line - Line number of the of the warning.

    File - Name of the file where warning is coming from.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( MessageId );
    UNREFERENCED_PARAMETER( Line );
    UNREFERENCED_PARAMETER( File );

    return;
}

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    uStatus     - ARC error code

    pchBadFile  - Name of file causing error (Must be given for handled
                  ARC codes.  Optional for unhandled codes.)

    uLine       - Line # in source code file where error occurred (only
                  used for unhandled codes.)

    pchCodeFile - Name of souce code file where error occurred (only
                  used for unhandled codes.)

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( uStatus );
    UNREFERENCED_PARAMETER( pchBadFile );
    UNREFERENCED_PARAMETER( uLine );
    UNREFERENCED_PARAMETER( pchCodeFile );

    return;
}


VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    This routine does nothing.  In the context of dynamic HAL detection, we just ignore the
    error and hope everything is ok.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( MessageId );

    return;
}


ULONG
SlGetChar(
    VOID
    )
{
    return 0;
}



VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    )
{
    UNREFERENCED_PARAMETER( FormatString );

    return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

TARGETNAME=bldr
TARGETPATH=obj
TARGETTYPE=LIBRARY

BUILD_CONSUMES=BOOTLIB$(BUILD_DEBUG_LOADER) 

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF


!include $(PROJECT_ROOT)\boot\loader$(DBG_LDR).inc


INCLUDES=\
    $(PROJECT_ROOT)\boot\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\ntos\config;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(SDKTOOLS_INC_PATH);\
    $(O)

MSC_WARNING_LEVEL=/W4 /WX

!IF $(IA64)
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DEFI
!ELSE
C_DEFINES=$(C_DEFINES) -D_WANT_MACHINE_IDENTIFICATION
!endif



SOURCES=..\osloader.c \
        ..\dcmpstub.c \
        ..\regboot.c  \
        ..\hiber.c    \
        ..\advboot.c  \
        ..\bootstat.c \
        ..\netboot.c \
        $(O)\msg.mc   \
        ..\osloader.rc

PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
NTTARGETFILE0=$(O)\msg.mc

!IF $(386)
MC_FLAGS=-A
!ENDIF

!IF "$(NOLINK)" != "1"

!IF $(ALPHA) || $(AXP64)

NTTARGETFILES=$(O)\osloader$(DBG_LDR).exe

!ELSEIF $(386)

NTTARGETFILES=$(O)\osloader$(DBG_LDR)$(NTD_LDR).exe $(O)\ntldr$(DBG_LDR) $(O)\osloader$(DBG_LDR).ntd

!elseif $(IA64)

NTTARGETFILES=$(O)\ia64ldr$(DBG_LDR).efi

!endif

MISCFILES=$(NTTARGETFILES)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\cht\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\chs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\jpn\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\kor\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\msg.cs ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    msg.h
;
;Abstract:
;
;    This file contains the message definitions for osloader
;
;Author:
;
;    John Vert (jvert) 12-Nov-1993
;
;Revision History:
;
;Notes:
;
;    This file is generated from msg.mc
;
;--*/
;
;#ifndef _BLDR_MSG_
;#define _BLDR_MSG_
;
;

MessageID=9000 SymbolicName=BL_MSG_FIRST
Language=English
.

MessageID=9001 SymbolicName=LOAD_SW_INT_ERR_CLASS
Language=English
Systm Windows se nepodailo spustit z dvodu chyby softwaru.
Oznamte uveden pote:
.

MessageID=9002 SymbolicName=LOAD_SW_MISRQD_FILE_CLASS
Language=English
Systm Windows se nepodailo spustit, nebyl nalezen uveden
soubor, kter potebuje:
.

MessageID=9003 SymbolicName=LOAD_SW_BAD_FILE_CLASS
Language=English
Systm Windows nelze spustit z dvodu pokozenho souboru,
viz dle:
.

MessageID=9004 SymbolicName=LOAD_SW_MIS_FILE_CLASS
Language=English
Systm Windows nelze spustit. Uveden soubor je pokozen 
nebo nebyl nalezen:
.

MessageID=9005 SymbolicName=LOAD_HW_MEM_CLASS
Language=English
Systm Windows nelze spustit z dvodu pot 
s hardwarovou konfigurac pamti.
.

MessageID=9006 SymbolicName=LOAD_HW_DISK_CLASS
Language=English
Systm Windows nelze spustit z dvodu pot s hardwarovou 
konfigurac potaovho disku.
.

MessageID=9007 SymbolicName=LOAD_HW_GEN_ERR_CLASS
Language=English
Systm Windows nelze spustit z dvodu obecnch pot s hardwarovou
konfigurac potae.
.

MessageID=9008 SymbolicName=LOAD_HW_FW_CFG_CLASS
Language=English
Systm Windows nelze spustit z dvodu pot
s konfigurac startovacho firmwaru ARC:
.

MessageID=9009 SymbolicName=DIAG_BL_MEMORY_INIT
Language=English
Zkontrolujte hardwarovou konfiguraci pamti a velikost RAM.
.

MessageID=9010 SymbolicName=DIAG_BL_CONFIG_INIT
Language=English
Pli mnoho konfiguranch poloek
.

MessageID=9011 SymbolicName=DIAG_BL_IO_INIT
Language=English
Tabulky diskovch oddl nebyly pstupn
.

MessageID=9012 SymbolicName=DIAG_BL_FW_GET_BOOT_DEVICE
Language=English
Nastaven parametru 'osloadpartition' je neplatn.
.

MessageID=9013 SymbolicName=DIAG_BL_OPEN_BOOT_DEVICE
Language=English
Ze zadanho spoutcho disku nelze st. Zkontrolujte spoutc
cestu a hardware disku.
.

MessageID=9014 SymbolicName=DIAG_BL_FW_GET_SYSTEM_DEVICE
Language=English
Nastaven parametru 'systempartition' je neplatn.
.

MessageID=9015 SymbolicName=DIAG_BL_FW_OPEN_SYSTEM_DEVICE
Language=English
Ze zadanho spoutcho disku systmu nelze st.
Zkontrolujte cestu 'systempartition'.
.

MessageID=9016 SymbolicName=DIAG_BL_GET_SYSTEM_PATH
Language=English
Parametr 'osloadfilename' se neodkazuje na platn soubor.
.

MessageID=9017 SymbolicName=DIAG_BL_LOAD_SYSTEM_IMAGE
Language=English
<Windows root>\system32\ntoskrnl.exe.
.

MessageID=9018 SymbolicName=DIAG_BL_FIND_HAL_IMAGE
Language=English
Parametr 'osloader' neodkazuje na platn soubor.
.

MessageID=9019 SymbolicName=DIAG_BL_LOAD_HAL_IMAGE_X86
Language=English
<Windows root>\system32\hal.dll.
.

MessageID=9020 SymbolicName=DIAG_BL_LOAD_HAL_IMAGE_ARC
Language=English
'osloader'\hal.dll
.
;#ifdef _X86_
;#define DIAG_BL_LOAD_HAL_IMAGE DIAG_BL_LOAD_HAL_IMAGE_X86
;#else
;#define DIAG_BL_LOAD_HAL_IMAGE DIAG_BL_LOAD_HAL_IMAGE_ARC
;#endif

MessageID=9021 SymbolicName=DIAG_BL_LOAD_SYSTEM_IMAGE_DATA
Language=English
Zavad؟, chyba 1.
.

MessageID=9022 SymbolicName=DIAG_BL_LOAD_HAL_IMAGE_DATA
Language=English
Zavad؟, chyba 2.
.

MessageID=9023 SymbolicName=DIAG_BL_LOAD_SYSTEM_DLLS
Language=English
Zavad؟ poteboval knihovny DLL pro jdro systmu.
.

MessageID=9024 SymbolicName=DIAG_BL_LOAD_HAL_DLLS
Language=English
Zavad؟ poteboval knihovny DLL pro vrstvu HAL.
.

MessageID=9026 SymbolicName=DIAG_BL_FIND_SYSTEM_DRIVERS
Language=English
najt ovladae systmu.
.

MessageID=9027 SymbolicName=DIAG_BL_READ_SYSTEM_DRIVERS
Language=English
st ovladae systmu.
.

MessageID=9028 SymbolicName=DIAG_BL_LOAD_DEVICE_DRIVER
Language=English
nezavedl ovlada zazen spoutcho systmu.
.

MessageID=9029 SymbolicName=DIAG_BL_LOAD_SYSTEM_HIVE
Language=English
zavdt konfiguran soubor systmovho hardwaru.
.

MessageID=9030 SymbolicName=DIAG_BL_SYSTEM_PART_DEV_NAME
Language=English
najt nzev zazen systmovho oddlu.
.

MessageID=9031 SymbolicName=DIAG_BL_BOOT_PART_DEV_NAME
Language=English
najt nzev spoutcho oddlu.
.

MessageID=9032 SymbolicName=DIAG_BL_ARC_BOOT_DEV_NAME
Language=English
nevygeneroval sprvn nzev ARC pro HAL a systmov cesty.
.

MessageID=9034 SymbolicName=DIAG_BL_SETUP_FOR_NT
Language=English
Zavad؟, chyba 3.
.

MessageID=9035 SymbolicName=DIAG_BL_KERNEL_INIT_XFER
Language=English
<Windows root>\system32\ntoskrnl.exe
.

MessageID=9036 SymbolicName=LOAD_SW_INT_ERR_ACT
Language=English
Kontaktujte technickou podporu a nahlaste problm.
.

MessageID=9037 SymbolicName=LOAD_SW_FILE_REST_ACT
Language=English
Tento soubor mete zkusit opravit sputnm instalace systmu
Windows pomoc originln instalan diskety nebo disku CD-ROM.
Opravu spustte stisknutm klvesy R na prvn obrazovce.
.

MessageID=9038 SymbolicName=LOAD_SW_FILE_REINST_ACT
Language=English
Nainstalujte znovu uveden soubor.
.

MessageID=9039 SymbolicName=LOAD_HW_MEM_ACT
Language=English
Hardwarov poadavky na pam؜ naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9040 SymbolicName=LOAD_HW_DISK_ACT
Language=English
Poadavky na konfiguraci disku naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9041 SymbolicName=LOAD_HW_GEN_ACT
Language=English
Poadavky na hardwarovou konfiguraci naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9042 SymbolicName=LOAD_HW_FW_CFG_ACT
Language=English
Monosti konfigurace ARC naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9043 SymbolicName=BL_LKG_MENU_HEADER
Language=English
     Nabdka Profil hardwaru/Obnoven konfigurace

Nabdka umouje vybrat hardwarov profil,
kter se m pout pi sputn systmu Windows.

Pokud systm nen sputn sprvn, pak lze zvolit pedchoz
konfiguraci systmu, kter me pote pi spoutc odstranit.
Dleit: Zmny konfigurace systmu, kter byly provedeny
          po poslednm spnm sputn, budou odstranny.
.

MessageID=9044 SymbolicName=BL_LKG_MENU_TRAILER
Language=English
ipkami na klvesnici zvraznte poloku, kterou chcete vybrat.
Pak stisknte klvesu ENTER.
.

MessageID=9045 SymbolicName=BL_LKG_MENU_TRAILER_NO_PROFILES
Language=English
Zatm nejsou definovny dn hardwarov profily.
Hardwarov profily mete vytvoit pomoc ovldacho panelu Systm.
.

MessageID=9046 SymbolicName=BL_SWITCH_LKG_TRAILER
Language=English
Stisknutm klvesy P pepnete do posledn znm funkn konfigurace.
Stisknutm klvesy F3 tuto nabdku ukonte a restartujete pota.
.

MessageID=9047 SymbolicName=BL_SWITCH_DEFAULT_TRAILER
Language=English
Stisknutm klvesy V pepnete do vchoz konfigurace.
Stisknutm klvesy F3 tuto nabdku ukonte a restartujete pota.
.

;//
;// The following two messages are used to provide the mnemonic keypress
;// that toggles between the Last Known Good control set and the default
;// control set. (see BL_SWITCH_LKG_TRAILER and BL_SWITCH_DEFAULT_TRAILER)
;//
MessageID=9048 SymbolicName=BL_LKG_SELECT_MNEMONIC
Language=English
P
.

MessageID=9049 SymbolicName=BL_DEFAULT_SELECT_MNEMONIC
Language=English
V
.

MessageID=9050 SymbolicName=BL_LKG_TIMEOUT
Language=English
Doba, za kterou se zvraznn volba automaticky spust (sek.): %d
.

MessageID=9051 SymbolicName=BL_LKG_MENU_PROMPT
Language=English

Nabdku Profil hardwaru/Posledn funkn konfiguraci zskte 
stisknutm mezernku TE
.

MessageID=9052 SymbolicName=BL_BOOT_DEFAULT_PROMPT
Language=English
Sputn vchoz hardwarov konfigurace
.

;//
;// The following messages are used during hibernation restoration
;//
MessageID=9053 SymbolicName=HIBER_BEING_RESTARTED
Language=English
Systm je restartovn z pedchozho umstn.
Chcete-li proces peruit, stisknte mezernk.
.
MessageID=9054 SymbolicName=HIBER_ERROR
Language=English
Systm nemohl bt restartovn z pedchozho umstn
.
MessageID=9055 SymbolicName=HIBER_ERROR_NO_MEMORY
Language=English
kvli nedostatku pamti.
.
MessageID=9056 SymbolicName=HIBER_ERROR_BAD_IMAGE
Language=English
, protoe je obraz obnoven pokozen.
.
MessageID=9057 SymbolicName=HIBER_IMAGE_INCOMPATIBLE
Language=English
, protoe obraz obnoven nen kompatibiln s aktuln konfigurac.
.
MessageID=9058 SymbolicName=HIBER_ERROR_OUT_OF_REMAP
Language=English
kvli vnitn chyb.
.
MessageID=9059 SymbolicName=HIBER_INTERNAL_ERROR
Language=English
kvli vnitn chyb.
.
MessageID=9060 SymbolicName=HIBER_READ_ERROR
Language=English
kvli chyb pi ten.
.
MessageID=9061 SymbolicName=HIBER_PAUSE
Language=English
Restartovn systmu bylo pozastaveno:
.
MessageID=9062 SymbolicName=HIBER_CANCEL
Language=English
Odstrate obnovovac data a postupte k nabdce sputn systmu
.
MessageID=9063 SymbolicName=HIBER_CONTINUE
Language=English
Pokraovat v restartovn systmu
.
MessageID=9064 SymbolicName=HIBER_RESTART_AGAIN
Language=English
Posledn pokus o restartovn systmu z pedchozho umstn 
se nezdail. Chcete se o restartovn pokusit znovu?
.
MessageID=9065 SymbolicName=HIBER_DEBUG_BREAK_ON_WAKE
Language=English
Pokraovat s ladicmi zarkami v systmu
.
MessageID=9066 SymbolicName=LOAD_SW_MISMATCHED_KERNEL
Language=English
Systm Windows nelze spustit, protoe uren jdro
neexistuje nebo nen kompatibiln s tmto procesorem.
.
MessageID=9067 SymbolicName=BL_MSG_STARTING_WINDOWS
Language=English
Spoutn systmu Windows...
.
MessageID=9068 SymbolicName=BL_MSG_RESUMING_WINDOWS
Language=English
Obnoven innosti systmu Windows...
.

MessageID=9069 SymbolicName=BL_EFI_OPTION_FAILURE
Language=English
Systm Windows nebyl sputn z dvodu chyby pi ten nastaven
spoutn z pamti NVRAM.

Zkontrolujte nastaven firmwaru. Pravdpodobn budete muset obnovit
nastaven pamti NVRAM ze zlohy.
.
MessageID=9070 SymbolicName=HIBER_MEMORY_INCOMPATIBLE
Language=English
protoe se zmnila konfigurace pamti. Budete-li pokraovat,
me dojt ke ztrt kontextu uloenho pi pechodu do reimu spnku. Sprvnho obnoven
doshnete tm, e nyn vypnete pota, obnovte pvodn
konfiguraci pamti a restartujete systm.

.

;
; //
; // Following messages are for the x86-specific
; // boot menu.
; //
;
MessageID=10001 SymbolicName=BL_ENABLED_KD_TITLE
Language=English
 [ladic program byl aktivovn]
.

MessageID=10002 SymbolicName=BL_DEFAULT_TITLE
Language=English
Windows (vchoz)
.

MessageID=10003 SymbolicName=BL_MISSING_BOOT_INI
Language=English
NTLDR: Soubor BOOT.INI nebyl nalezen.
.

MessageID=10004 SymbolicName=BL_MISSING_OS_SECTION
Language=English
NTLDR: Chyb oddl [operating systems] v souboru boot.txt.
.

MessageID=10005 SymbolicName=BL_BOOTING_DEFAULT
Language=English
Spoutn vchozho jdra z %s.
.

MessageID=10006 SymbolicName=BL_SELECT_OS
Language=English
Vyberte operan systm, kter chcete spustit:
.

MessageID=10007 SymbolicName=BL_MOVE_HIGHLIGHT
Language=English


ipkami nahoru nebo dol zvraznte poadovanou monost.
Stisknutm klvesy Enter ji potvrte.

.

MessageID=10008 SymbolicName=BL_TIMEOUT_COUNTDOWN
Language=English
Doba, za kterou se zvraznn volba automaticky spust (s):
.

MessageID=10009 SymbolicName=BL_INVALID_BOOT_INI
Language=English
Soubor BOOT.INI je neplatn
Probh sputn z %s
.

MessageID=10010 SymbolicName=BL_REBOOT_IO_ERROR
Language=English

Vstupn-vstupn chyba pstupu k souboru spoutcho sektoru
%s\BOOTSECT.DOS
.

MessageID=10011 SymbolicName=BL_DRIVE_ERROR
Language=English
NTLDR: Nelze otevt jednotku %s
.

MessageID=10012 SymbolicName=BL_READ_ERROR
Language=English
NTLDR: Kritick chyba %d pi ten souboru BOOT.INI
.

MessageID=10013 SymbolicName=BL_NTDETECT_MSG
Language=English

NTDETECT v5.2 kontroluje hardware...

.

MessageID=10014 SymbolicName=BL_NTDETECT_FAILURE
Language=English
Dolo k chyb v modulu NTDETECT.
.

MessageID=10015 SymbolicName=BL_DEBUG_SELECT_OS
Language=English
Aktuln vbr:
  Nzev...: %s
  Cesta...: %s
  Monosti: %s
.

MessageID=10016 SymbolicName=BL_DEBUG_NEW_OPTIONS
Language=English
Zadejte nov monosti zavdn:
.

MessageID=10017 SymbolicName=BL_HEADLESS_REDIRECT_TITLE
Language=English
 [EMS enabled]
.

MessageID=10018 SymbolicName=BL_INVALID_BOOT_INI_FATAL
Language=English
Neplatn soubor BOOT.INI
.


;
; //
; // Following messages are for the advanced boot menu
; //
;

MessageID=11001 SymbolicName=BL_ADVANCEDBOOT_TITLE
Language=English
Upesnit monosti sputn systmu Windows
Zvolte jednu z monost:
.

MessageID=11002 SymbolicName=BL_SAFEBOOT_OPTION1
Language=English
Stav nouze
.

MessageID=11003 SymbolicName=BL_SAFEBOOT_OPTION2
Language=English
Stav nouze s prac v sti
.

MessageID=11004 SymbolicName=BL_SAFEBOOT_OPTION3
Language=English
Potvrzovat krok za krokem
.

MessageID=11005 SymbolicName=BL_SAFEBOOT_OPTION4
Language=English
Stav nouze se systmem MS-DOS
.

MessageID=11006 SymbolicName=BL_SAFEBOOT_OPTION5
Language=English
Reim VGA
.

MessageID=11007 SymbolicName=BL_SAFEBOOT_OPTION6
Language=English
Obnoven adresov sluby (pouze pro adie domny Windows)
.

MessageID=11008 SymbolicName=BL_LASTKNOWNGOOD_OPTION
Language=English
Posledn znm funkn konfigurace
.

MessageID=11009 SymbolicName=BL_DEBUG_OPTION
Language=English
Reim ladn
.

;#if defined(REMOTE_BOOT)
;MessageID=11010 SymbolicName=BL_REMOTEBOOT_OPTION1
;Language=English
;Remote Boot Maintenance and Troubleshooting
;.
;
;MessageID=11011 SymbolicName=BL_REMOTEBOOT_OPTION2
;Language=English
;Clear Offline Cache
;.
;
;MessageID=11012 SymbolicName=BL_REMOTEBOOT_OPTION3
;Language=English
;Load using files from server only
;.
;#endif // defined(REMOTE_BOOT)

MessageID=11013 SymbolicName=BL_BOOTLOG
Language=English
Pi zaveden povolit pihlen
.

MessageID=11014 SymbolicName=BL_ADVANCED_BOOT_MESSAGE
Language=English
een pot nebo upesnn monost sputn - stisknte klvesu F8.
.

MessageID=11015 SymbolicName=BL_BASEVIDEO
Language=English
Zapnout reim VGA
.

MessageID=11016 SymbolicName=BL_DISABLE_SAFEBOOT
Language=English

Vypnut bezpenho zavdn systmu a normln zaveden systmu - klvesa ESC
.

MessageID=11017 SymbolicName=BL_MSG_BOOT_NORMALLY
Language=English
Spustit systm bاnm zpsobem
.
MessageID=11018 SymbolicName=BL_MSG_OSCHOICES_MENU
Language=English
Zpt k vbru operanho systmu
.

MessageID=11019 SymbolicName=BL_MSG_REBOOT
Language=English
Restartovat
.

MessageID=11020 SymbolicName=BL_ADVANCEDBOOT_AUTOLKG_TITLE
Language=English
Omlouvme se za nepjemnosti, ale systm Windows nebyl spn sputn 
pravdpodobn z dvodu zmny hardwaru nebo softwaru.

Pokud pota neodpovd, byl neekan restartovn nebo byl automaticky
vypnut, aby chrnil soubory a sloky, mete se vrtit k funknmu 
nastaven volbou Posledn znm funkn konfigurace.

Pokud bylo pedchoz sputn perueno z dvodu vpadku napjen nebo
vypnaem napjen nebo tlatkem Reset, nebo pokud je pina neznm,
zvolte poloku Spustit systm bاnm zpsobem.
.

MessageID=11021 SymbolicName=BL_ADVANCEDBOOT_AUTOSAFE_TITLE
Language=English
Systm nebyl spn vypnut. Jestlie se tak stalo, protoe systm
neodpovdal nebo byl vypnut, aby chrnil data, je mon jej obnovit
jednou z konfigurac Nouzovho reimu:
.

MessageID=11022 SymbolicName=BL_ADVANCEDBOOT_TIMEOUT
Language=English
Systm Windows se spust za (sekundy):
.

;
;//
;// Following messages are the symbols used
;// in the Hibernation Restore percent completed UI. 
;//
;// These symbols are here because they employ high-ASCII
;// line drawing characters, which need to be localized
;// for fonts that may not have such characters (or have
;// them in a different ASCII location). 
;//  
;// This primarily affects FE character sets. 
;//
;// Note that only the FIRST character of any of these
;// messages is ever looked at by the code.  
;//
;
; // Just a base message, contains nothing.
;
;

; //
; // NOTE : donot change the Message ID values for HIBER_UI_BAR_ELEMENT
; // and BLDR_UI_BAR_BACKGROUND from 11513 & 11514
;

;
; // The character used to draw the percent-complete bar
;
;
MessageID=11513 SymbolicName=HIBER_UI_BAR_ELEMENT
Language=English

.

;
; // The character used to draw the percent-complete bar
;
;
MessageID=11514 SymbolicName=BLDR_UI_BAR_BACKGROUND
Language=English

.

;#if defined(REMOTE_BOOT)
;;
;; //
;; // Following messages are for warning the user about
;; // an impending autoformat of the hard disk.
;; //
;;
;
;MessageID=12002 SymbolicName=BL_WARNFORMAT_TRAILER
;Language=English
;Press ENTER to continue booting Windows, otherwise turn off
;your remote boot machine.
;.
;
;MessageID=12003 SymbolicName=BL_WARNFORMAT_CONTINUE
;Language=English
;Continue
;.
;MessageID=12004 SymbolicName=BL_FORCELOGON_HEADER
;Language=English
;          Auto-Format
;
;Windows has detected a new hard disk in your remote boot
;machine.  Before Windows can use this disk, you must logon and
;validate that you have access to this disk.
;
;WARNING:  Windows will automatically repartition and format
;this disk to accept the new operating system.  All data on the
;hard disk will be lost if you choose to continue.  If you do
;not want to continue, power off the computer now and contact
;your administrator.
;.
;#endif // defined(REMOTE_BOOT)

;
; //
; // Ramdisk related messages. DO NOT CHANGE the message numbers
; // as they are kept in sync with \base\boot\inc\ramdisk.h.
; //
;

MessageID=15000 SymbolicName=BL_RAMDISK_GENERAL_FAILURE
Language=English
Systm Windows nemohl bt sputn z dvodu chyby pi sputn z disku RAMDISK.
.

MessageID=15001 SymbolicName=BL_RAMDISK_INVALID_OPTIONS
Language=English
Parametry disku RAMDISK v souboru boot.ini jsou neplatn.
.

MessageID=15002 SymbolicName=BL_RAMDISK_BUILD_FAILURE
Language=English
Systmu Windows se nepodailo sestavit spustitelnou bitovou kopii disku RAMDISK.
.

MessageID=15003 SymbolicName=BL_RAMDISK_BOOT_FAILURE
Language=English
Systmu Windows se nepodailo otevt bitovou kopii disku RAMDISK.
.

MessageID=15004 SymbolicName=BL_RAMDISK_BUILD_DISCOVER
Language=English
Hledn serveru sestaven...
.

MessageID=15005 SymbolicName=BL_RAMDISK_BUILD_REQUEST
Language=English
Vydn spustiteln bitov kopie ze serveru sestaven...
.

MessageID=15006 SymbolicName=BL_RAMDISK_BUILD_PROGRESS_TIMEOUT
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d. Vyprel asov limit poslednho poadavku.     
.

MessageID=15007 SymbolicName=BL_RAMDISK_BUILD_PROGRESS_PENDING
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d. Posledn poadavek ek na zpracovn.     
.

MessageID=15008 SymbolicName=BL_RAMDISK_BUILD_PROGRESS_ERROR
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d. Posledn poadavek se nezdail.     
.

MessageID=15009 SymbolicName=BL_RAMDISK_BUILD_PROGRESS
Language=English
Adresa IP serveru sestaven = %d.%d.%d.%d.
.

MessageID=15010 SymbolicName=BL_RAMDISK_DOWNLOAD
Language=English
Natn bitov kopie disku RAMDISK...
.

MessageID=15011 SymbolicName=BL_RAMDISK_DOWNLOAD_NETWORK
Language=English
Stahovn protokolem TFTP z %d.%d.%d.%d
.

MessageID=15012 SymbolicName=BL_RAMDISK_DOWNLOAD_NETWORK_MCAST
Language=English
Vcesmrov stahovn protokolem TFTP z %d.%d.%d.%d:%d.
.

;#endif // _BLDR_MSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\psu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\spcrtest\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\tst\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\ia64\initia64.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Does any ia64-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldria64.h"
#include "msg.h"
#include <netboot.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <efi.h>

UCHAR Argv0String[100];

UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR ConsoleOutputName[50];
UCHAR FullKernelPath[200];

extern ULONGLONG    BootFlags;

ARC_STATUS
BlGetEfiBootOptions(
    OUT PUCHAR Argv0String OPTIONAL,
    OUT PUCHAR SystemPartition OPTIONAL,
    OUT PUCHAR OsLoaderFilename OPTIONAL,
    OUT PUCHAR OsLoadPartition OPTIONAL,
    OUT PUCHAR OsLoadFilename OPTIONAL,
    OUT PUCHAR FullKernelPath OPTIONAL,
    OUT PUCHAR OsLoadOptions OPTIONAL
    );

VOID
BlPreProcessLoadOptions(
    PCHAR szOsLoadOptions
    );

#define MAXBOOTVARSIZE      1024

#if defined(_MERCED_A0_)
VOID
KiProcessorWorkAround(
    );
#endif

VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does Intel-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG  Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
#if !defined(NO_LEGACY_DRIVERS)
    PCHAR p;
    ULONG DriveId;
#endif
#ifdef FW_HEAP
    extern BOOLEAN FwDescriptorsValid;
#endif

    UNREFERENCED_PARAMETER( PartitionName );

    //
    // Initialize ARC StdIo functionality
    //

    strcpy((PCHAR)ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy((PCHAR)ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, (PCHAR *)Argv);

    //
    // Check ntldr partition for hiberation image
    //

    do {

        BlClearScreen();
        
        Status = BlGetEfiBootOptions(
                    Argv0String,
                    SystemPartition,
                    OsLoaderFilename,
                    OsLoadPartition,
                    OsLoadFilename,
                    FullKernelPath,
                    OsLoadOptions
                    );
        if ( Status != ESUCCESS ) {
            BlPrint(BlFindMessage(BL_EFI_OPTION_FAILURE));            
            goto BootFailed;
        }        
        
        BlClearScreen();
        
#if !defined(NO_LEGACY_DRIVERS)
        p = FullKernelPath;

        //
        // Initialize SCSI boot driver, if necessary.
        //
        if(!_strnicmp(p,"scsi(",5)) {
            AEInitializeIo(DriveId);
        }

#endif // NO_LEGACY_DRIVERS

#if  FW_HEAP
        //
        // Indicate that fw memory descriptors cannot be changed from
        // now on.
        //

        FwDescriptorsValid = FALSE;
#endif
        
        //
        // convert it to all one case
        //
        if (OsLoadOptions[0]) {
            _strupr((PCHAR)OsLoadOptions);
        }

        Argv[Argc++]=Argv0String;
        Argv[Argc++]=OsLoaderFilename;
        Argv[Argc++]=SystemPartition;
        Argv[Argc++]=OsLoadFilename;
        Argv[Argc++]=OsLoadPartition;
        Argv[Argc++]=OsLoadOptions;

        BlPreProcessLoadOptions( (PCHAR)OsLoadOptions );

        //
        // In the x86 case, we would have already initialized the
        // headless port so that the user could actually make his
        // boot selection over the headless port.  However, on ia64,
        // that selection is happening during firmware.
        //
        // If the user wants us to redirect (via the OsLoadOptions), then
        // we should try to do it here.
        //
        if( strstr((PCHAR)OsLoadOptions, "/REDIRECT")) {

            //
            // Yep, then want us to redirect.  Try and initialize the
            // port.
            //
            BlInitializeHeadlessPort();

#if 0
            if( LoaderRedirectionInformation.PortNumber == 0 ) {

                //
                // We couldn't get any redirection information
                // from the firmware.  But the user really wants
                // us to redirect.  Better guess.
                //
                LoaderRedirectionInformation.PortNumber = 1;
                LoaderRedirectionInformation.BaudRate = 9600;

                //
                // Now try again, this time with feeling...
                //
                BlInitializeHeadlessPort();

            }
#endif

        }

        Status = BlOsLoader( Argc, (PCHAR *)Argv, NULL );

    BootFailed:

        if (Status != ESUCCESS) {

            if (BootFlags & BOOTFLAG_REBOOT_ON_FAILURE) {
                ULONG StartTime = ArcGetRelativeTime();
                BlPrint(TEXT("\nRebooting in 5 seconds...\n"));
                while ( ArcGetRelativeTime() - StartTime < 5) {}
                ArcRestart();      
            }

            //
            // Boot failed, wait for reboot
            //
            if (!BlIsTerminalConnected()) {
                //
                // typical case.  wait for user to press a key and then 
                // restart
                //
                while(!BlGetKey());
            }
            else {
                // 
                // headless case.  present user with mini sac
                //
                while(!BlTerminalHandleLoaderFailure());
            }
            ArcRestart();
        
        }
    } while (TRUE);

}

VOID
BlPreProcessLoadOptions(
    PCHAR szOsLoadOptions
    )
{
    CHAR szTemp[MAXBOOTVARSIZE];
    PCHAR p;
    ULONG MaxMemory = 0;
    ULONG MaxPage = 0;
    ULONG ConfigFlagValue=0;


    strcpy( szTemp, szOsLoadOptions );
    _strupr( szTemp );

#if 0
    if( p = strstr( szTemp, ";" ) ) {
        *p = '\0';
    }
#endif

    //
    // Process MAXMEM
    //
    if( (p = strstr( szTemp, "/MAXMEM=" )) != NULL ) {
        MaxMemory = atoi( p + sizeof("/MAXMEM=") - 1 );
        MaxPage = MaxMemory * ((1024 * 1024) / PAGE_SIZE) - 1;
        BlTruncateDescriptors( MaxPage );
    }

#if defined(_MERCED_A0_)
    //
    // Process CONFIGFLAG
    //
    if ( (p = strstr(szTemp, "CONFIGFLAG")) != NULL ) {
        if ( (p = strstr(p, "=")) != NULL ) {
            ConfigFlagValue = atol(p+1);
            KiProcessorWorkAround(ConfigFlagValue);
        }
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\i386\initx86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldrx86.h"
#include "acpitabl.h"
#include "msg.h"
#include "bootstatus.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <netboot.h>
#include <ramdisk.h>

BOOLEAN
BlpPaeSupported(
    VOID
    );

BOOLEAN
BlpChipsetPaeSupported(
    VOID
    );

ARC_STATUS
Blx86GetImageProperties(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae,
    OUT PBOOLEAN SupportsHotPlugMemory
    );

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    IN OUT PBOOLEAN UsePae
    );

BOOLEAN
Blx86NeedPaeForHotPlugMemory(
    VOID
    );

UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];

extern BOOLEAN ForceLastKnownGood;
extern ULONG    BlHighestPage;
extern PHARDWARE_PTE PDE;

extern ULONG    BootFlags;

extern PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );



VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BootFileId= 0;
    PCHAR BootFile = NULL;
    ULONG Read;
    PCHAR p;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    PUCHAR LoadOptionsArg = OsLoadOptions;
    ULONG LoadOptionsSize;
    ULONG LoadOptionsMax = sizeof(OsLoadOptions);
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;
    PCHAR BadLinkName = NULL;

    //
    // If this is an SDI boot, initialize the ramdisk "driver" now.
    //
    // NB. PartitionName is the name of the device from which the loader
    // was loaded. It is NOT the name of the device from which the OS will
    // be loaded. If we're doing a straight ramdisk boot, this will NOT be
    // ramdisk(0) -- it will be net(0) or a physical disk name. Only if
    // we're doing a real SDI boot will this be ramdisk(0). (See
    // NtProcessStartup() in boot\lib\i386\entry.c.)
    //

    if ( strcmp(PartitionName,"ramdisk(0)") == 0 ) {
        RamdiskInitialize( NULL, TRUE );
    }

    //
    // Open the boot partition so we can load boot drivers off it.
    //
    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);
    if (Status != ESUCCESS) {
        BlPrint(TEXT("Couldn't open drive %s\n"),PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    //
    // Initialize dbcs font and display support.
    //
    TextGrInitialize(DriveId, NULL);

    //
    // Initialize ARC StdIo functionality
    //

    strncpy((PCHAR)ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)",
            sizeof(ConsoleInputName));
    ConsoleInputName[sizeof(ConsoleInputName)-1] = '\0'; // null terminate

    strncpy((PCHAR)ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)",
            sizeof(ConsoleOutputName));
    ConsoleOutputName[sizeof(ConsoleOutputName)-1] = '\0';
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, (PCHAR *)Argv);

    //
    // Announce the loader
    //
    //BlPrint(OsLoaderVersion);

    //
    // Check ntldr partition for hiberation image
    //

    BlHiberRestore(DriveId, &BadLinkName);

    //
    // Re-open the boot partition as a temporary work around
    // for NTFS caching bug.
    //
    ArcClose(DriveId);

    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);

    if (Status != ESUCCESS) {
        BlPrint(TEXT("Couldn't open drive %s\n"),PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    //
    // It is possible that the link file points to the hiber file on a scsi
    // disk. In that case, we need to load NTBOOTDD.SYS in order to access the
    // hiber file and try again.
    //
    if ((BadLinkName != NULL) &&
        ((_strnicmp(BadLinkName,"scsi(",5)==0) || (_strnicmp(BadLinkName,"signature(",10)==0))) {
        ULONG HiberDrive;

        //
        // Before loading NTBOOTDD we must load NTDETECT as that figures
        // out the PCI buses
        //
        if (BlDetectHardware(DriveId, "/fastdetect")) {
            if (AEInitializeIo(DriveId) == ESUCCESS) {
                AlreadyInitialized = TRUE;

                //
                // Now that NTBOOTDD.SYS is loaded, we can try again.
                //
                Status = ArcOpen(BadLinkName, ArcOpenReadWrite, &HiberDrive);
                if (Status == ESUCCESS) {
                    BlHiberRestore(HiberDrive, NULL);
                    ArcClose(HiberDrive);
                }
            }

        }

    }

    do {

        if (BlBootingFromNet) {
            PCHAR BootIniPath;

            //
            // If we are booting from the network and
            // NetBootIniContents has been specified, we
            // will just its contents for boot.ini
            //
            if (NetBootIniContents[0] != '\0') {
                BootFile = (PCHAR)NetBootIniContents;
            } else {
                //
                // NetBootIniContents is empty, therefore
                // we need to open the boot.ini file from the
                // network. The acutal file to open is either
                // specificied in NetBootIniPath or is the
                // default of NetBootPath\boot.ini
                //
                if (NetBootIniPath[0] != '\0') {
                    BootIniPath = (PCHAR)NetBootIniPath;
                } else {
                    _snprintf((PCHAR)MyBuffer, sizeof(MyBuffer),
                              "%sboot.ini",
                              NetBootPath);
                    MyBuffer[sizeof(MyBuffer)-1] = '\0'; // null terminate
                    BootIniPath = (PCHAR)MyBuffer;
                }
                Status = BlOpen( DriveId,
                                 BootIniPath,
                                 ArcOpenReadOnly,
                                 &BootFileId );
            }

        } else {
            Status = BlOpen( DriveId,
                             "\\boot.ini",
                             ArcOpenReadOnly,
                             &BootFileId );
        }

        if (BootFile == NULL) {

            BootFile = (PCHAR)MyBuffer;
            RtlZeroMemory(MyBuffer, SECTOR_SIZE+32);

            if (Status != ESUCCESS) {
                BootFile[0]='\0';
            } else {
                //
                // Determine the length of the boot.ini file by reading to the end of
                // file.
                //

                FileSize = 0;
                do {
                    Status = BlRead(BootFileId, BootFile, SECTOR_SIZE, &Count);
                    if (Status != ESUCCESS) {
                        BlClose(BootFileId);
                        BlPrint(BlFindMessage(BL_READ_ERROR),Status);
                        BootFile[0] = '\0';
                        FileSize = 0;
                        Count = 0;
                        goto BootFailed;
                    }

                    FileSize += Count;
                } while (Count != 0);

                if (FileSize >= SECTOR_SIZE) {

                    //
                    // We need to allocate a bigger buffer, since the boot.ini file
                    // is bigger than one sector.
                    //

                    BootFile=FwAllocateHeap(FileSize);
                }

                if (BootFile == NULL) {
                    BlPrint(BlFindMessage(BL_READ_ERROR),ENOMEM);
                    BootFile = (PCHAR)MyBuffer;
                    BootFile[0] = '\0';
                    goto BootFailed;
                } else {

                    SeekPosition.QuadPart = 0;
                    Status = BlSeek(BootFileId,
                                    &SeekPosition,
                                    SeekAbsolute);
                    if (Status != ESUCCESS) {
                        BlPrint(BlFindMessage(BL_READ_ERROR),Status);
                        BootFile = (PCHAR)MyBuffer;
                        BootFile[0] = '\0';
                        goto BootFailed;
                    } else {
                        Status = BlRead( BootFileId,
                                         BootFile,
                                         FileSize,
                                         &Read );

                        SeekPosition.QuadPart = 0;
                        Status = BlSeek(BootFileId,
                                        &SeekPosition,
                                        SeekAbsolute);
                        if (Status != ESUCCESS) {
                            BlPrint(BlFindMessage(BL_READ_ERROR),Status);
                            BootFile = (PCHAR)MyBuffer;
                            BootFile[0] = '\0';
                            goto BootFailed;
                        } else {
                            BootFile[Read]='\0';
                        }
                    }
                }

                //
                // Find Ctrl-Z, if it exists
                //

                p=BootFile;
                while ((*p!='\0') && (*p!=26)) {
                    ++p;
                }
                if (*p != '\0') {
                    *p='\0';
                }
                BlClose(BootFileId);
            }
        }

        MdShutoffFloppy();

        ARC_DISPLAY_CLEAR();

        // We require a boot.ini file when booting from the network
        if (BlBootingFromNet && *BootFile == '\0') {
            BlPrint(BlFindMessage(BL_READ_ERROR),Status);
            goto BootFailed;
        }

        p=BlSelectKernel(DriveId,BootFile, &LoadOptions, UseTimeOut);
        if ( p == NULL ) {
            BlPrint(BlFindMessage(BL_INVALID_BOOT_INI_FATAL));
            goto BootFailed;
        }

#if defined(REMOTE_BOOT)
        //
        //  We may have loaded boot.ini from the hard drive but if the selection was
        //  for a remote boot installation then we need to load the rest from the net.
        //

        if((DriveId != NET_DEVICE_ID) &&
            (!_strnicmp(p,"net(",4))) {
            BlPrint("\nWarning:Booting from CSC without access to server\n");
            strcpy(BootPartitionName,"net(0)");
            BlBootingFromNet = TRUE;
            NetworkBootRom = FALSE;

            //
            //  p points to something like: "net(0)\COLINW3\IMirror\Clients\cwintel\BootDrive\WINNT"
            //  NetBootPath needs to contain "\Clients\cwintel\"
            //  ServerShare is used inside lib\netboot.c to find the correct file if CSC
            //  is used.
            //

            q = strchr(p+sizeof("net(0)"), '\\');
            q = strchr(q+1, '\\');
            strcpy(NetBootPath,q);
            q = strrchr( NetBootPath, '\\' );
            q[1] = '\0';
        }
#endif // defined(REMOTE_BOOT)

        if (!AlreadyInitialized) {

//          BlPrint(BlFindMessage(BL_NTDETECT_MSG));
            if (!BlDetectHardware(DriveId, LoadOptions)) {
                BlPrint(BlFindMessage(BL_NTDETECT_FAILURE));
                return;
            }

            ARC_DISPLAY_CLEAR();

            //
            // Initialize SCSI boot driver, if necessary.
            //
            if (_strnicmp(p,"scsi(",5)==0 || _strnicmp(p,"signature(",10)==0) {
                AEInitializeIo(DriveId);
            }

            ArcClose(DriveId);
            //
            // Indicate that fw memory descriptors cannot be changed from
            // now on.
            //
            FwDescriptorsValid = FALSE;
        } else {
            ARC_DISPLAY_CLEAR();
        }

        //
        // Set AlreadyInitialized Flag to TRUE to indicate that ntdetect
        // routines have been run.
        //

        AlreadyInitialized = TRUE;

        //
        // Only time out the boot menu the first time through the boot.
        // For all subsequent reboots, the menu will stay up.
        //
        UseTimeOut=FALSE;

        i=0;
        while (*p !='\\') {
            KernelBootDevice[i] = *p;
            i++;
            p++;
        }
        KernelBootDevice[i] = '\0';

        //
        // If the user hasn't chosen an advanced boot mode then we will present
        // them with the menu and select our default.
        //

        if(BlGetAdvancedBootOption() == -1) {
            PVOID dataHandle;
            ULONG abmDefault;
            BSD_LAST_BOOT_STATUS LastBootStatus = BsdLastBootGood;

            //
            // Open the boot status data.
            //

            Status = BlLockBootStatusData(0, (PCHAR)KernelBootDevice, p, &dataHandle);

            if(Status == ESUCCESS) {

                //
                // Check the status of the last boot.  This will return both the
                // status and the advanced boot mode we should enter (based on the
                // status and the "enable auto advanced boot" flag.
                //

                abmDefault = BlGetLastBootStatus(dataHandle, &LastBootStatus);

                if(LastBootStatus == BsdLastBootFailed) {

                    //
                    // If we should attempt an ABM mode then present the user with
                    // the menu.
                    //

                    if(abmDefault != -1) {
                        ULONG menuTitle;
                        UCHAR timeout;

                        if(LastBootStatus == BsdLastBootFailed) {
                            menuTitle = BL_ADVANCEDBOOT_AUTOLKG_TITLE;
                        } else if(LastBootStatus == BsdLastBootNotShutdown) {
                            menuTitle = BL_ADVANCEDBOOT_AUTOSAFE_TITLE;
                        }
                        else {
                            //
                            // give a default value to menu title
                            //
                            menuTitle = 0;
                        }

                        //
                        // Read the timeout value.
                        //

                        Status = BlGetSetBootStatusData(dataHandle,
                                                        TRUE,
                                                        RtlBsdItemAabTimeout,
                                                        &timeout,
                                                        sizeof(UCHAR),
                                                        NULL);

                        if(Status != ESUCCESS) {
                            timeout = 30;
                        }

                        abmDefault = BlDoAdvancedBoot(menuTitle,
                                                      -1,
                                                      TRUE,
                                                      timeout);
                    }

                    BlAutoAdvancedBoot(&LoadOptions,
                                       LastBootStatus,
                                       abmDefault);
                }

                BlUnlockBootStatusData(dataHandle);
            }
        }

        //
        // We are fooling the OS Loader here.  It only uses the osloader= variable
        // to determine where to load HAL.DLL from.  Since x86 systems have no
        // "system partition" we want to load HAL.DLL from \nt\system\HAL.DLL.
        // So we pass that it as the osloader path.
        //

        _snprintf((PCHAR)OsLoaderFilename,
                 sizeof(OsLoaderFilename),
                 "osloader=%s\\System32\\NTLDR",
                 p);
        OsLoaderFilename[sizeof(OsLoaderFilename) - 1] = '\0'; // null terminate

        _snprintf((PCHAR)SystemPartition,
                 sizeof(SystemPartition),
                 "systempartition=%s",
                 (PCHAR)KernelBootDevice);
        SystemPartition[sizeof(SystemPartition) - 1] = '\0'; // null terminate

        _snprintf((PCHAR)OsLoadPartition,
                 sizeof(OsLoadPartition),
                 "osloadpartition=%s",
                 (PCHAR)KernelBootDevice);
        OsLoadPartition[sizeof(OsLoadPartition) - 1] = '\0'; // null terminate

        _snprintf((PCHAR)OsLoadFilename,
                 sizeof(OsLoadFilename),
                 "osloadfilename=%s",
                 p);
        OsLoadFilename[sizeof(OsLoadFilename) - 1] = '\0';   // null terminate

        //
        // Need to make sure we have enough room for any loader options
        //
        if (LoadOptions) {
            LoadOptionsSize = strlen(LoadOptions) + sizeof("osloadoptions=");
            if (LoadOptionsSize > LoadOptionsMax) {
                LoadOptionsArg = (PUCHAR) BlAllocateHeap(LoadOptionsSize);
                if (LoadOptionsArg == NULL) {
                    BlPrint(BlFindMessage(BL_READ_ERROR), ENOMEM);
                    goto BootFailed;
                }
                LoadOptionsMax = LoadOptionsSize;
            }
        } else {
            LoadOptions = "";
        }
        _snprintf((PCHAR)LoadOptionsArg,
                 LoadOptionsMax,
                 "osloadoptions=%s",
                 LoadOptions);
        OsLoadOptions[LoadOptionsMax - 1] = '\0';     // null terminate

        strncpy((PCHAR)ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)",
                sizeof(ConsoleInputName));
        ConsoleInputName[sizeof(ConsoleInputName) - 1] = '\0'; // null terminate

        strncpy((PCHAR)ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)",
                sizeof(ConsoleOutputName));
        ConsoleOutputName[sizeof(ConsoleOutputName) - 1] = '\0'; // null terminate

        _snprintf((PCHAR)X86SystemPartition,
                 sizeof(X86SystemPartition),
                 "x86systempartition=%s",
                 PartitionName);
        X86SystemPartition[sizeof(X86SystemPartition) - 1] = '\0'; // null terminate

        Argv[Argc++]=(PUCHAR)"load";

        Argv[Argc++]=OsLoaderFilename;
        Argv[Argc++]=SystemPartition;
        Argv[Argc++]=OsLoadFilename;
        Argv[Argc++]=OsLoadPartition;
        Argv[Argc++]=LoadOptionsArg;
        Argv[Argc++]=X86SystemPartition;

        Status = BlOsLoader( Argc, (PCHAR *)Argv, NULL );

    BootFailed:
        ForceLastKnownGood = FALSE;
        if (Status != ESUCCESS) {

#if defined(ENABLE_LOADER_DEBUG)
            DbgBreakPoint();
#endif

            if (BootFlags & BOOTFLAG_REBOOT_ON_FAILURE) {
                ULONG StartTime = ArcGetRelativeTime();
                BlPrint(TEXT("\nRebooting in 5 seconds...\n"));
                while ( ArcGetRelativeTime() - StartTime < 5) {}
                ArcRestart();
            }

            //
            // Boot failed, wait for reboot
            //
            if (!BlIsTerminalConnected()) {
                //
                // typical case.  wait for user to press a key and then
                // restart
                //
                while(!BlGetKey());
            }
            else {
                //
                // headless case.  present user with mini sac
                //
                while(!BlTerminalHandleLoaderFailure());
            }
            ArcRestart();

        } else {
            //
            // Need to reopen the drive
            //
            Status = ArcOpen((PCHAR)BootPartitionName, ArcOpenReadOnly, &DriveId);
            if (Status != ESUCCESS) {
                BlPrint(BlFindMessage(BL_DRIVE_ERROR),BootPartitionName);
                goto BootFailed;
            }
        }
    } while (TRUE);

}

VOID
DoApmAttemptReconnect(
    VOID
    )
{
    APM_ATTEMPT_RECONNECT();
}


BOOLEAN
Blx86NeedPaeForHotPlugMemory(
    VOID
    )
/*++

Routine Description:

    Determine whether any hot plug memory described in the SRAT table
    extends beyond the 4gb mark and thus implies a need for PAE.

Arguments:

    None

Return Value:

    TRUE: Machine supports hot plug memory beyond the 4gb mark, PAE should be
          turned on if possible.

    FALSE: Machine doesn't support hot plug memory beyond the 4gb mark.

--*/
{
    PACPI_SRAT SratTable;
    PACPI_SRAT_ENTRY SratEntry;
    PACPI_SRAT_ENTRY SratEnd;

    SratTable = (PACPI_SRAT) BlFindACPITable("SRAT", sizeof(ACPI_SRAT));
    if (SratTable == NULL) {
        return FALSE;
    }

    SratTable = (PACPI_SRAT) BlFindACPITable("SRAT", SratTable->Header.Length);
    if (SratTable == NULL) {
        return FALSE;
    }

    SratEnd = (PACPI_SRAT_ENTRY)(((PUCHAR)SratTable) +
                                 SratTable->Header.Length);
    for (SratEntry = (PACPI_SRAT_ENTRY)(SratTable + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)(((PUCHAR) SratEntry) + SratEntry->Length)) {
        if (SratEntry->Type != SratMemory) {
            continue;
        }

        if (SratEntry->MemoryAffinity.Flags.HotPlug &&
            SratEntry->MemoryAffinity.Flags.Enabled) {
            ULONGLONG Extent;

            //
            // Check if hot plug region ends beyond the 4gb mark.
            //

            Extent = SratEntry->MemoryAffinity.Base.QuadPart +
                SratEntry->MemoryAffinity.Length;
            if (Extent > 0x100000000) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

ARC_STATUS
Blx86CheckForPaeKernel(
    IN BOOLEAN UserSpecifiedPae,
    IN BOOLEAN UserSpecifiedNoPae,
    IN PCHAR UserSpecifiedKernelImage,
    IN PCHAR HalImagePath,
    IN ULONG LoadDeviceId,
    IN ULONG SystemDeviceId,
    OUT PULONG HighestSystemPage,
    OUT PBOOLEAN UsePaeMode,
    IN OUT PCHAR KernelPath
    )

/*++

Routine Description:

    There are two kernels: one, ntkrnlpa.exe, is compiled for PAE mode.
    The other, ntoskrnl.exe, is not.

    This routine is responsible for deciding which one to load.

Arguments:

    UserSpecifiedPae - Indicates whether the user requested PAE mode
        via the /PAE loader switch.

    UserSpecifiedNoPae - Indicates whether the user requrested non-PAE mode
        via the /NOPAE loader switch.

    UserSpecifiedKernelImage - Points to the user-specified kernel image name,
        indicated via the /KERNEL= switch, or NULL if none was specified.

    HalImagePath - Points to the hal image that will be used.

    LoadDeviceId - The ARC device handle of the kernel load device.

    SystemDeviceId - The ARC device handle of the system device.

    HighestSystemPage - Out parameter returning the highest physical
        page found in the system.

    UsePaeMode - Indicates whether the kernel should be loaded in PAE mode.

    KernelPath - On input, the directory path of the kernel images.  Upon
        successful return, this will contain the full kernel image path.

Return Value:

    ESUCCESS : A compatible kernel has been located, and its path resides in
        the output buffer pointed to by KernelPath.

    EINVAL: A compatible kernel could not be located.  This will be a fatal
        condition.

    EBADF: hal is corrupt or missing.  This will be a fatal condition.

--*/

{
    BOOLEAN foundMemoryAbove4G;
    BOOLEAN usePae;
    BOOLEAN processorSupportsPae;
    BOOLEAN halSupportsPae;
    BOOLEAN osSupportsHotPlugMemory;
    BOOLEAN compatibleKernel;
    ULONG lastPage;
    PLIST_ENTRY link;
    PLIST_ENTRY listHead;
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    PCHAR kernelImageNamePae;
    PCHAR kernelImageNameNoPae;
    PCHAR kernelImageName;
    PCHAR kernelImageNameTarget;
    ARC_STATUS status;
    ULONG highestSystemPage;
    ULONG pagesAbove4Gig;

    kernelImageNameNoPae = "ntoskrnl.exe";
    kernelImageNamePae = "ntkrnlpa.exe";
    kernelImageNameTarget = KernelPath + strlen( KernelPath );

    //
    // Determine the highest physical page.  Also, count the number of pages
    // at or above the 4G mark.
    //

    highestSystemPage = 0;
    pagesAbove4Gig = 0;
    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    link = listHead->Flink;
    while (link != listHead) {

        descriptor = CONTAINING_RECORD(link,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        lastPage = descriptor->BasePage + descriptor->PageCount - 1;
        if (lastPage > highestSystemPage) {

            //
            // We have a new highest system page, record it.
            //

            highestSystemPage = lastPage;
        }

        if (lastPage >= (1024 * 1024)) {

            //
            // This descriptor includes one or more pages at or above
            // the 4G mark.
            //

            if (descriptor->BasePage >= (1024 * 1024)) {

                //
                // All of the pages in this descriptor lie at or above 4G.
                //

                pagesAbove4Gig += descriptor->PageCount;

            } else {

                //
                // Only some of the pages in this descriptor lie at or above
                // 4G.
                //

                pagesAbove4Gig += lastPage - (1024 * 1024) + 1;
            }
        }

        link = link->Flink;
    }
    *HighestSystemPage = highestSystemPage;

    //
    // Record whether there is a non-trivial amount of memory above 4G on this
    // machine.  Note that most machines with "exactly" 4G of ram actually move
    // a small amount of ram to above the 4G mark.
    //
    // Because running a PAE kernel inflicts a performance hit, we would rather
    // ignore some amount of memory x rather than move into PAE mode to use it.
    //
    // Right now, x is set to 64MB, or 16384 pages.
    //

    if (pagesAbove4Gig > 16384) {
        foundMemoryAbove4G = TRUE;
    } else {
        foundMemoryAbove4G = FALSE;
    }

    //
    // Find out if this processor can handle PAE mode.
    //

    processorSupportsPae = BlpPaeSupported();

    //
    // Find out whether this chipset supports PAE
    //
    if (!BlpChipsetPaeSupported()) {
        processorSupportsPae = FALSE;
    }

    //
    // Start out with a pae flag based on whether memory above 4G was located
    // or whether a /PAE switch was passed on the command line.
    //

    //
    // It used to be the case that we would default to PAE mode if memory
    // above 4G physical was found in the machine.  The decision was made
    // to NEVER default to PAE mode, rather to use PAE only when the
    // user specifically asks for it.
    //
    // If we revert back to the previous way of doing things, uncomment the
    // following line and remove the subsequent one.
    //
    // if (foundMemoryAbove4G || UserSpecifiedPae) {
    //

    if (UserSpecifiedPae) {
        usePae = TRUE;
    } else {
        usePae = FALSE;
    }

    //
    // Determine whether the HAL image can support PAE mode and
    // whether the underlying OS supports hot plug memory.
    //

    status = Blx86GetImageProperties( SystemDeviceId,
                                      HalImagePath,
                                      &halSupportsPae,
                                      &osSupportsHotPlugMemory );
    if (status != ESUCCESS) {

        //
        // Apparently the HAL image supplied is invalid.
        //
        return(EBADF);
    }

    //
    // If machine has the ability for memory to be hot plugged over
    // the 4gb mark, then this is interpreted as a user request for
    // PAE support.  This request will be ignored if not supported by
    // the underlying hardware or operating system.
    //

    if (osSupportsHotPlugMemory && Blx86NeedPaeForHotPlugMemory()) {
        usePae = TRUE;
    }


    if (halSupportsPae == FALSE) {

        //
        // The HAL cannot support operation in PAE mode.  Override
        // processorSupportsPae to FALSE in this case, meaning that we must
        // not under any circumstances try to use PAE mode.
        //

        processorSupportsPae = FALSE;
    }

    //
    // If the processor doesn't handle PAE mode or if the user specified
    // a /NOPAE switch on the loader command line, then disable PAE mode.
    //

    if (processorSupportsPae == FALSE || UserSpecifiedNoPae) {

        usePae = FALSE;
    }

    //
    // Choose the image name based on the data accumulated thus far.
    //

    if (UserSpecifiedKernelImage != NULL) {
        kernelImageName = UserSpecifiedKernelImage;
    } else if (usePae != FALSE) {
        kernelImageName = kernelImageNamePae;
    } else {
        kernelImageName = kernelImageNameNoPae;
    }

    //
    // Build the path for this kernel and determine its suitability.
    //

    strcpy( kernelImageNameTarget, kernelImageName );
    compatibleKernel = Blx86IsKernelCompatible( LoadDeviceId,
                                                KernelPath,
                                                processorSupportsPae,
                                                &usePae );
    if (compatibleKernel == FALSE) {

        //
        // This kernel is not compatible or does not exist.  If the failed
        // kernel was user-specified, fall back to the default, non-PAE
        // kernel and see if that is compatible.
        //

        if (UserSpecifiedKernelImage != NULL) {

            kernelImageName = kernelImageNameNoPae;
            strcpy( kernelImageNameTarget, kernelImageName );
            compatibleKernel = Blx86IsKernelCompatible( LoadDeviceId,
                                                        KernelPath,
                                                        processorSupportsPae,
                                                        &usePae );

        }
    }

    if (compatibleKernel == FALSE) {

        //
        // At this point we have tried one of the default kernel image names,
        // as well as any user-specified kernel image name.  There remains
        // one final default image name that hasn't been tried.  Determine
        // which one that is and try it.
        //

        if (kernelImageName == kernelImageNameNoPae) {
            kernelImageName = kernelImageNamePae;
        } else {
            kernelImageName = kernelImageNameNoPae;
        }

        strcpy( kernelImageNameTarget, kernelImageName );
        compatibleKernel = Blx86IsKernelCompatible( LoadDeviceId,
                                                    KernelPath,
                                                    processorSupportsPae,
                                                    &usePae );
    }

    if (compatibleKernel != FALSE) {

        *UsePaeMode = usePae;
        status = ESUCCESS;
    } else {
        status = EINVAL;
    }

    return status;
}

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    OUT PBOOLEAN UsePae
    )

/*++

Routine Description:

    This routine examines the supplied kernel image and determines whether
    it is valid and compatible with the current processor and, if so, whether
    PAE mode should be enabled.

Arguments:

    LoadDeviceId - The ARC device handle of the kernel load device.

    ImagePath - Pointer to a buffer containing the full path of the
        kernel to check.

    ProcessorSupportsPae - TRUE if the current processor supports PAE
        mode, FALSE otherwise.

    UsePae - Upon successful return, indicates whether the kernel is PAE
        enabled.

Return Value:

    TRUE: The supplied kernel image is compatible with the current processor,
        and *UsePae has been updated as appropriate.

    FALSE: The supplied kernel image is invalid or is not compatible with the
        current processor.

--*/

{
    BOOLEAN isPaeKernel;
    BOOLEAN supportsHotPlugMemory;
    ARC_STATUS status;

    status = Blx86GetImageProperties( LoadDeviceId,
                                      ImagePath,
                                      &isPaeKernel,
                                      &supportsHotPlugMemory );
    if (status != ESUCCESS) {

        //
        // This kernel is invalid or does not exist.  Therefore, it is
        // not compatible.
        //

        return FALSE;
    }

    if (isPaeKernel == FALSE) {

        //
        // This is a non-PAE kernel.  All supported processors can run in
        // non-PAE mode.  Indicate that PAE mode should not be used and that
        // this kernel is compatible.
        //

        *UsePae = FALSE;
        return TRUE;

    } else {

        //
        // This is a PAE kernel.
        //

        if (ProcessorSupportsPae == FALSE) {

            //
            // This is a PAE kernel but the processor will not run in that
            // mode.  Indicate that this kernel is not compatible.
            //

            return FALSE;

        } else {

            //
            // This is a PAE kernel and a PAE processor.  Indicate that PAE
            // mode should be used and that this kernel is compatible.
            //

            *UsePae = TRUE;
            return TRUE;
        }
    }
}

ARC_STATUS
Blx86GetImageProperties(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae,
    OUT PBOOLEAN SupportsHotPlugMemory
    )

/*++

Routine Description:

    This routine examines the supplied image and determines whether
    it is valid and, if so, whether it is PAE compatible by examining
    the IMAGE_FILE_LARGE_ADDRESS_AWARE bit.

Arguments:

    LoadDeviceId - The ARC device handle of the image device.

    ImagePath - Pointer to a buffer containing the full path of the
        kernel to check.

    IsPae - Upon successful return, indicates whether the image is PAE
        compatible.

    SupportsHotPlugMemory - Upon successful return, indicates whether the
        image indicates an OS that supports hot plug memory.


Return Value:

    ESUCCESS - The supplied kernel image is valid, and *IsPae has been updated
        according to the image header.

    Otherwise, the Arc status of the failed operation is returned.

--*/

{
    CHAR localBufferSpace[ SECTOR_SIZE * 2 + SECTOR_SIZE - 1 ];
    PCHAR localBuffer;
    ARC_STATUS status;
    ULONG fileId;
    PIMAGE_NT_HEADERS ntHeaders;
    USHORT imageCharacteristics;
    ULONG bytesRead;

    //
    // File I/O here must be sector-aligned.
    //

    localBuffer = (PCHAR)
        (((ULONG)localBufferSpace + SECTOR_SIZE - 1) & ~(SECTOR_SIZE - 1));

    //
    // Read in the PE image header.
    //

    status = BlOpen( LoadDeviceId, ImagePath, ArcOpenReadOnly, &fileId );
    if (status != ESUCCESS) {
        return status;
    }

    status = BlRead( fileId, localBuffer, SECTOR_SIZE * 2, &bytesRead );
    BlClose( fileId );

    if (bytesRead != SECTOR_SIZE * 2) {
        status = EBADF;
    }

    if (status != ESUCCESS) {
        return status;
    }

    //
    // If the file header has the IMAGE_FILE_LARGE_ADDRESS_AWARE
    // characteristic set then this is a PAE image.
    //

    ntHeaders = RtlImageNtHeader( localBuffer );
    if (ntHeaders == NULL) {
        return EBADF;
    }

    imageCharacteristics = ntHeaders->FileHeader.Characteristics;
    if ((imageCharacteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) != 0) {

        //
        // This is a PAE image.
        //

        *IsPae = TRUE;

    } else {

        //
        // This is not a PAE image.
        //

        *IsPae = FALSE;
    }

    //
    // Hot Plug Memory is only supported post 5.0
    //
    if (ntHeaders->OptionalHeader.MajorOperatingSystemVersion > 5 ||
        ((ntHeaders->OptionalHeader.MajorOperatingSystemVersion == 5) &&
         (ntHeaders->OptionalHeader.MinorOperatingSystemVersion > 0 ))) {
        *SupportsHotPlugMemory = TRUE;
    } else {
        *SupportsHotPlugMemory = FALSE;
    }

    return ESUCCESS;
}


BOOLEAN
BlpChipsetPaeSupported(
    VOID
    )
/*++

Routine Description:

    Scans PCI space to see if the current chipset is supported for PAE mode.

Arguments:

    None

Return Value:

    TRUE - PAE is supported

    FALSE - PAE is not supported

--*/

{
    ULONG DevVenId=0;
    ULONG i;

    typedef struct _PCIDEVICE {
        ULONG Bus;
        ULONG Device;
        ULONG DevVen;
    } PCIDEVICE, *PPCIDEVICE;

    PCIDEVICE BadChipsets[] = {
        {0, 0, 0x1a208086},     // MCH
        {0, 0, 0x1a218086},     // MCH
        {0, 0, 0x1a228086},     // MCH
        {0, 30, 0x24188086},    // ICH
        {0, 30, 0x24288086}     // ICH
    };


    for (i=0; i<sizeof(BadChipsets)/sizeof(PCIDEVICE); i++) {
        HalGetBusData(PCIConfiguration,
                      BadChipsets[i].Bus,
                      BadChipsets[i].Device,
                      &DevVenId,
                      sizeof(DevVenId));
        if (DevVenId == BadChipsets[i].DevVen) {
            return(FALSE);
        }
    }

    return(TRUE);
}

ARC_STATUS
BlpCheckVersion(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath
    )
{
    CHAR localBufferSpace[ SECTOR_SIZE * 2 + SECTOR_SIZE - 1 ];
    PCHAR localBuffer;
    ARC_STATUS status;
    ULONG fileId;
    PIMAGE_NT_HEADERS ntHeaders;
    ULONG bytesRead;
    ULONG i,j,Count;
    HARDWARE_PTE_X86 nullpte;


    //
    // File I/O here must be sector-aligned.
    //

    localBuffer = (PCHAR)
        (((ULONG)localBufferSpace + SECTOR_SIZE - 1) & ~(SECTOR_SIZE - 1));

    //
    // Read in the PE image header.
    //

    status = BlOpen( LoadDeviceId, ImagePath, ArcOpenReadOnly, &fileId );
    if (status != ESUCCESS) {
        return status;
    }

    status = BlRead( fileId, localBuffer, SECTOR_SIZE * 2, &bytesRead );
    BlClose( fileId );

    if (bytesRead != SECTOR_SIZE * 2) {
        status = EBADF;
    }

    if (status != ESUCCESS) {
        return status;
    }
    ntHeaders = RtlImageNtHeader( localBuffer );
    if (ntHeaders == NULL) {
        return EBADF;
    }
    //
    // Setup the mm remapping checks for post 5.0 or pre 5.0
    //
    if (ntHeaders->OptionalHeader.MajorOperatingSystemVersion < 5 ||
        ((ntHeaders->OptionalHeader.MajorOperatingSystemVersion == 5) &&
          (ntHeaders->OptionalHeader.MinorOperatingSystemVersion == 0 ))) {


            BlOldKernel=TRUE;
            BlKernelChecked=TRUE;
            BlHighestPage = ((16*1024*1024) >> PAGE_SHIFT) - 40;

            //
            // Virtual was moved up for the dynamic load case. It was 64MB off
            // in 5.0 and prior
            //
            RtlZeroMemory (&nullpte,sizeof (HARDWARE_PTE_X86));

            if (BlVirtualBias != 0 ) {

                BlVirtualBias = OLD_ALTERNATE-KSEG0_BASE;

                //
                // PDE entries represent 4MB. Zap the new ones.
                //
                i=(OLD_ALTERNATE) >> 22L;
                j=(ALTERNATE_BASE)>> 22L;

                for (Count = 0; Count < 4;Count++){
                    PDE[i++]= PDE[j++];
                }
                for (Count = 0; Count < 12; Count++) {
                    PDE[i++]= nullpte;
                }
            }
    }

    return (ESUCCESS);
}


VOID
SetX86WatchDog(
    ULONG TimeOut
    )
{
    static PULONG CountRegister = NULL;
    PWATCHDOG_TIMER_RESOURCE_TABLE WdTable = NULL;

    if (CountRegister == NULL) {
        WdTable = (PWATCHDOG_TIMER_RESOURCE_TABLE) BlFindACPITable( "WDRT", sizeof(WATCHDOG_TIMER_RESOURCE_TABLE) );
        if (WdTable == NULL) {
            return;
        }
        CountRegister = MmMapIoSpace(
            WdTable->CountRegisterAddress.Address,
            WdTable->CountRegisterAddress.BitWidth>>3,
            TRUE
            );
        if (CountRegister == NULL) {
            return;
        }
    }

    WRITE_REGISTER_ULONG( CountRegister, TimeOut );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\i386\parsboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parsboot.c

Abstract:

    Parses the boot.ini file, displays a menu, and provides a kernel
    path and name to be passed to osloader.

Author:

    John Vert (jvert) 22-Jul-1991

Revision History:

--*/
#include "bldrx86.h"
#include "msg.h"
#include "ntdddisk.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#define MAX_SELECTIONS 10
#define MAX_TITLE_LENGTH 71

#define WIN95_DOS  1
#define DOS_WIN95  2

typedef struct _MENU_OPTION {
    PCHAR Title;
    PCHAR Path;
    BOOLEAN EnableDebug;
    ULONG MaxMemory;
    PCHAR LoadOptions;
    int ForcedScsiOrdinal;
    int Win95;
    BOOLEAN HeadlessRedirect;
} MENU_OPTION, *PMENU_OPTION;

PCHAR  pDefSwitches = NULL;

int ForcedScsiOrdinal = -1;
CHAR szDebug[] = "unsupporteddebug";
CHAR BlankLine[] = "                                                                      \r";

//
// global to hold the user's last
// selection from the advanced boot menu.
//
LONG AdvancedBoot = -1;

#define DEBUG_LOAD_OPTION_LENGTH    60
CHAR DebugLoadOptions[DEBUG_LOAD_OPTION_LENGTH];


//
// Defines for options for redirecting to a headless terminal
//
#define COM1_19_2 "com1at19200"
#define COM2_19_2 "com2at19200"


//
// Private function prototypes
//
VOID
BlpRebootDOS(
    IN PCHAR BootSectorImage OPTIONAL,
    IN PCHAR LoadOptions OPTIONAL
    );

PCHAR
BlpNextLine(
    IN PCHAR String
    );

VOID
BlpTranslateDosToArc(
    IN PCHAR DosName,
    OUT PCHAR ArcName
    );

ULONG
BlpPresentMenu(
    IN PMENU_OPTION MenuOptions,
    IN ULONG NumberSelections,
    IN ULONG Default,
    IN LONG Timeout
    );

PCHAR *
BlpFileToLines(
    IN PCHAR File,
    OUT PULONG LineCount
    );

PCHAR *
BlpFindSection(
    IN PCHAR SectionName,
    IN PCHAR *BootFile,
    IN ULONG BootFileLines,
    OUT PULONG NumberLines
    );

VOID
BlpRenameWin95Files(
    IN ULONG DriveId,
    IN ULONG Type
    );

VOID
BlParseOsOptions (
    IN PMENU_OPTION MenuOption,
    IN PCHAR pCurrent
    );

ULONG
BlGetAdvancedBootID(
    LONG BootOption
    );


PCHAR
BlSelectKernel(
    IN ULONG DriveId,
    IN PCHAR BootFile,
    OUT PCHAR *LoadOptions,
    IN BOOLEAN UseTimeOut
    )
/*++

Routine Description:

    Parses the boot.txt file and determines the fully-qualified name of
    the kernel to be booted.

Arguments:

    BootFile - Pointer to the beginning of the loaded boot.txt file

    Debugger - Returns the enable/disable state of the kernel debugger

    UseTimeOut - Supplies whether the boot menu should time out or not.

Return Value:

    Pointer to the name of a kernel to boot.

--*/

{
    PCHAR *MbLines = NULL;
    PCHAR *OsLines = NULL;
    PCHAR *FileLines;
#if DBG
    PCHAR *DebugLines = NULL;
    ULONG DebugLineCount = 0;
#endif
    ULONG FileLineCount;
    ULONG OsLineCount = 0;
    ULONG MbLineCount = 0;
    PCHAR pCurrent;
    MENU_OPTION MenuOption[MAX_SELECTIONS+1];
    ULONG NumberSystems=0;
    ULONG i;
    LONG Timeout;
    ULONG Selection;
    ULONG DefaultSelection=0;
    static CHAR Kernel[128];
    CHAR DosName[3];
    PCHAR DefaultOldPath="C:\\winnt";
    PCHAR WinntDir = DefaultOldPath + 2;
    PCHAR DefaultNewPath="C:\\windows\\";
    CHAR  DefaultPathBuffer[128] = {0};
    PCHAR DefaultPath = DefaultPathBuffer;
    PCHAR DefaultTitle=BlFindMessage(BL_DEFAULT_TITLE);
    ULONG DirId;

    //
    // Check to see if "winnt" directory exists on the boot
    // device. If it does not exist then make the default path point
    // to "windows" directory
    //
    if (BlOpen(DriveId, WinntDir, ArcOpenDirectory, &DirId) != ESUCCESS) {
        strcpy(DefaultPath, DefaultNewPath);
    } else {
        BlClose(DirId);
        strcpy(DefaultPath, DefaultOldPath);
        strcat(DefaultPath, "\\");
    }

    *LoadOptions = NULL;

    if (*BootFile == '\0') {
        //
        // No boot.ini file, so we boot the default.
        //
        BlPrint(BlFindMessage(BL_INVALID_BOOT_INI),DefaultPath);
        MenuOption[0].Path = DefaultPath;
        MenuOption[0].Title = DefaultTitle;
        MenuOption[0].MaxMemory = 0;
        MenuOption[0].LoadOptions = NULL;
        MenuOption[0].Win95 = 0;
        NumberSystems = 1;
        DefaultSelection = 0;
        MbLineCount = 0;
        OsLineCount = 0;
        MenuOption[0].EnableDebug = FALSE;
#if DBG
        DebugLineCount = 0;
#endif
    } else {
        FileLines = BlpFileToLines(BootFile, &FileLineCount);
        MbLines = BlpFindSection("[boot loader]",
                                 FileLines,
                                 FileLineCount,
                                 &MbLineCount);
        if (MbLines==NULL) {
            MbLines = BlpFindSection("[flexboot]",
                                     FileLines,
                                     FileLineCount,
                                     &MbLineCount);
            if (MbLines==NULL) {
                MbLines = BlpFindSection("[multiboot]",
                                         FileLines,
                                         FileLineCount,
                                         &MbLineCount);
            }
        }

        OsLines = BlpFindSection("[operating systems]",
                                 FileLines,
                                 FileLineCount,
                                 &OsLineCount);

        if (OsLineCount == 0) {

            if (BlBootingFromNet) {
                return NULL;
            }

            BlPrint(BlFindMessage(BL_INVALID_BOOT_INI),DefaultPath);
            MenuOption[0].Path = DefaultPath;
            MenuOption[0].Title = DefaultTitle;
            MenuOption[0].MaxMemory = 0;
            MenuOption[0].LoadOptions = NULL;
            MenuOption[0].Win95 = 0;
            MenuOption[0].HeadlessRedirect = FALSE;
            NumberSystems = 1;
            DefaultSelection = 0;
        }

#if DBG
        DebugLines = BlpFindSection("[debug]",
                                    FileLines,
                                    FileLineCount,
                                    &DebugLineCount);
#endif
    }

    //
    // Set default timeout value
    //
    if (UseTimeOut) {
        Timeout = 0;
    } else {
        Timeout = -1;
    }



    //
    // Before we look through the [boot loader] section, initialize
    // our headless redirection information so that the default is
    // to not redirect.
    //
    RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );
    BlTerminalConnected = FALSE;



    //
    // Parse the [boot loader] section
    //
    for (i=0; i<MbLineCount; i++) {

        pCurrent = MbLines[i];

        //
        // Throw away any leading whitespace
        //
        pCurrent += strspn(pCurrent, " \t");
        if (*pCurrent == '\0') {
            //
            // This is a blank line, so we just throw it away.
            //
            continue;
        }

        //
        // Check for "DefSwitches" line
        //
        if (_strnicmp(pCurrent,"DefSwitches",sizeof("DefSwitches")-1) == 0) {
            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                pDefSwitches = pCurrent + 1;
            }
            continue;
        }

        //
        // Check for "timeout" line
        //
        if (_strnicmp(pCurrent,"timeout",7) == 0) {

            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                if (UseTimeOut) {
                    Timeout = atoi(++pCurrent);
                }
            }
        }


        //
        // Check for "redirectbaudrate" line
        //
        if (_strnicmp(pCurrent,"redirectbaudrate",16) == 0) {

            pCurrent = strchr(pCurrent,'=');

            if (pCurrent != NULL) {

                //
                // Skip whitespace
                //
                ++pCurrent;
                pCurrent += strspn(pCurrent, " \t");

                if (*pCurrent != '\0') {

                    //
                    // Fill in our global structure with the information.
                    //
                    if( _strnicmp(pCurrent,"115200",6) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_115200;
                    } else if( _strnicmp(pCurrent,"57600",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_57600;
                    } else if( _strnicmp(pCurrent,"19200",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_19200;
                    } else {
                        LoaderRedirectionInformation.BaudRate = BD_9600;
                    }
                }
            }

        } else if (_strnicmp(pCurrent,"redirect",8) == 0) {

            //
            // Check for "redirect" line
            //

            pCurrent = strchr(pCurrent,'=');

            if (pCurrent != NULL) {

                //
                // Skip whitespace
                //
                ++pCurrent;
                pCurrent += strspn(pCurrent, " \t");

                if (*pCurrent != '\0') {

                    //
                    // Fill in our global structure with the information.
                    //
#if 0

                    //
                    // Since we now support variable baudrates, there's no
                    // reason to support these hardcoded 19200 strings.
                    //


                    if (_strnicmp(pCurrent, COM1_19_2, sizeof(COM1_19_2)) == 0) {

                        pCurrent += sizeof(COM1_19_2);

                        LoaderRedirectionInformation.PortNumber = 1;
                        LoaderRedirectionInformation.BaudRate = 19200;

                    } else if (_strnicmp(pCurrent, COM2_19_2, sizeof(COM2_19_2)) == 0) {

                        pCurrent += sizeof(COM2_19_2);

                        LoaderRedirectionInformation.PortNumber = 2;
                        LoaderRedirectionInformation.BaudRate = 19200;

                    } else if (_strnicmp(pCurrent,"com",3) == 0) {
#else

                    if (_strnicmp(pCurrent,"com",3) == 0) {
#endif
                        pCurrent +=3;


                        LoaderRedirectionInformation.PortNumber = atoi(pCurrent);

                    } else if (_strnicmp(pCurrent, "usebiossettings", 15) == 0) {

                        BlRetrieveBIOSRedirectionInformation();

                    } else {

                        //
                        // See if they gave us a hardcoded address.
                        //
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)ULongToPtr(strtoul(pCurrent,NULL,16));

                        if( LoaderRedirectionInformation.PortAddress != (PUCHAR)NULL ) {
                            LoaderRedirectionInformation.PortNumber = 3;
                        }

                    }

                }

            }

        }


        //
        // Check for "default" line
        //
        if (_strnicmp(pCurrent,"default",7) == 0) {

            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                DefaultPath = ++pCurrent;
                DefaultPath += strspn(DefaultPath," \t");
            }

        }

    }



    //
    // If we found any headless redirection settings, go initialize
    // the port now.
    //
    if( LoaderRedirectionInformation.PortNumber ) {

        // make sure we got a baudrate.
        if( LoaderRedirectionInformation.BaudRate == 0 ) {
            LoaderRedirectionInformation.BaudRate = 9600;
        }

        BlInitializeHeadlessPort();
    }



    //
    // Parse the [operating systems] section
    //

    for (i=0; i<OsLineCount; i++) {

        if (NumberSystems == MAX_SELECTIONS) {
            break;
        }

        pCurrent = OsLines[i];

        //
        // Throw away any leading whitespace
        //

        pCurrent += strspn(pCurrent, " \t");
        if (*pCurrent == '\0') {
            //
            // This is a blank line, so we just throw it away.
            //
            continue;
        }

        MenuOption[NumberSystems].Path = pCurrent;

        //
        // The first space or '=' character indicates the end of the
        // path specifier, so we need to replace it with a '\0'
        //
        while ((*pCurrent != ' ')&&
               (*pCurrent != '=')&&
               (*pCurrent != '\0')) {
            ++pCurrent;
        }
        *pCurrent = '\0';

        //
        // The next character that is not space, equals, or double-quote
        // is the start of the title.
        //

        ++pCurrent;
        while ((*pCurrent == ' ') ||
               (*pCurrent == '=') ||
               (*pCurrent == '"')) {
            ++pCurrent;
        }

        if (pCurrent=='\0') {
            //
            // No title was found, so just use the path as the title.
            //
            MenuOption[NumberSystems].Title = MenuOption[NumberSystems].Path;
        } else {
            MenuOption[NumberSystems].Title = pCurrent;
        }

        //
        // The next character that is either a double-quote or a \0
        // indicates the end of the title.
        //
        while ((*pCurrent != '\0')&&
               (*pCurrent != '"')) {
            ++pCurrent;
        }

        //
        // Parse the os load options for this selection
        //

        BlParseOsOptions (&MenuOption[NumberSystems], pCurrent);
        *pCurrent = 0;

        ++NumberSystems;
    }


#if DBG
    //
    // Parse the [debug] section
    //
    for (i=0; i<DebugLineCount; i++) {
        extern ULONG ScsiDebug;

        pCurrent = DebugLines[i];

        //
        // Throw away leading whitespace
        //
        pCurrent += strspn(pCurrent, " \t");
        if (*pCurrent == '\0') {
            //
            // throw away blank lines
            //
            continue;
        }

        if (_strnicmp(pCurrent,"scsidebug",9) == 0) {
            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                ScsiDebug = atoi(++pCurrent);
            }
        } else if (_strnicmp(pCurrent,"/debug ",7) == 0) {

            //
            // This line contains something to do with debug,
            // pass to BdInitDebugger to handle.
            //
            // Note: very strict rules, debug keyword begins with
            // a slash and is followed by a space.  "/debugport"
            // won't match, nor will "/debug" at the end of the
            // line.
            //
            // Note: If the debugger is hard compiled on, it
            // will already be enabled and these options will
            // have no effect.  Also, the first occurence is
            // the one that takes effect.
            //

            BdInitDebugger((PCHAR)OsLoaderName, (PVOID)OsLoaderBase, pCurrent);
        }
    }

#endif

    //
    // Now look for a Title entry from the [operating systems] section
    // that matches the default entry from the [multiboot] section.  This
    // will give us a title.  If no entry matches, we will add an entry
    // at the end of the list and provide a default Title.
    //
    i=0;
    while (_stricmp(MenuOption[i].Path,DefaultPath) != 0) {
        ++i;
        if (i==NumberSystems) {
            //
            // Create a default entry in the Title and Path arrays
            //
            MenuOption[NumberSystems].Path = DefaultPath;
            MenuOption[NumberSystems].Title = DefaultTitle;
            MenuOption[NumberSystems].EnableDebug = FALSE;
            MenuOption[NumberSystems].MaxMemory = 0;
            MenuOption[NumberSystems].LoadOptions = NULL;
            MenuOption[NumberSystems].Win95 = 0;
            ++NumberSystems;
        }
    }

    DefaultSelection = i;

    //
    // Display the menu of choices
    //

    Selection = BlpPresentMenu( MenuOption,
                                NumberSystems,
                                DefaultSelection,
                                Timeout);

    pCurrent = MenuOption[Selection].LoadOptions;
    if (pCurrent != NULL) {

        //
        // Remove '/' from LoadOptions string.
        //

        *LoadOptions = pCurrent + 1;
        while (*pCurrent != '\0') {
            if (*pCurrent == '/') {
                *pCurrent = ' ';
            }
            ++pCurrent;
        }
    } else {
        *LoadOptions = NULL;
    }

    if (MenuOption[Selection].Win95) {
        BlpRenameWin95Files( DriveId, MenuOption[Selection].Win95 );
    }



    //
    // We need to take care of the following cases:
    // 1. The user has asked us to redirect via the osload
    //    option entry, but did not ask the loader to redirect.
    //    In this case, we will default to COM1.
    //
    // 2. The loader was asked to redirect via the "redirect"
    //    specifier in the [boot loader] section.  But the
    //    user did NOT have a /redirect option on the osload
    //    options.  In this case, we need to kill the
    //    LoaderRedirectionInformation variable.
    //
    if( MenuOption[Selection].HeadlessRedirect ) {

#if 0
// matth (7/25/2000) Don't do this for now.  If the user has
//                   this configuration in their boot.ini, it's
//                   an error on their part.
        //
        // he's asked us to redirect the operating system.  Make
        // sure the Loader was also asked to redirect too.
        //
        if( LoaderRedirectionInformation.PortNumber == 0 ) {

            //
            // the loader wasn't asked to redirect.  The user
            // made a mistake here, but let's guess as to what
            // he wants.
            //
            RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );
            LoaderRedirectionInformation.PortNumber = 1;
            LoaderRedirectionInformation.BaudRate = 9600;

        }
#endif

    } else {

        //
        // He's asked us to not redirect.  Make sure we don't pass
        // information to the OS so he won't be able to redirect.
        //
        RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );

        BlTerminalConnected = FALSE;
    }



    if (_strnicmp(MenuOption[Selection].Path,"C:\\",3) == 0) {

        //
        // This syntax means that we are booting a root-based os
        // from an alternate boot sector image.
        // If no file name is specified, BlpRebootDos will default to
        // \bootsect.dos.
        //
        BlpRebootDOS(MenuOption[Selection].Path[3] ? &MenuOption[Selection].Path[2] : NULL,*LoadOptions);

        //
        // If this returns, it means that the file does not exist as a bootsector.
        // This allows c:\winnt35 to work as a boot path specifier as opposed to
        // a boot sector image filename specifier.
        //
    }

    if (MenuOption[Selection].Path[1]==':') {
        //
        // We need to translate the DOS name into an ARC name
        //
        DosName[0] = MenuOption[Selection].Path[0];
        DosName[1] = MenuOption[Selection].Path[1];
        DosName[2] = '\0';

        BlpTranslateDosToArc(DosName,Kernel);
        strcat(Kernel,MenuOption[Selection].Path+2);
    } else {
        strcpy(Kernel,MenuOption[Selection].Path);
    }

    //
    // the use made a valid selection from the
    // advanced boot menu so append the advanced
    // boot load options and perform any load
    // option processing.
    //
    if (AdvancedBoot != -1) {
        PSTR s = BlGetAdvancedBootLoadOptions(AdvancedBoot);
        if (s) {
            ULONG len = strlen(s) + (*LoadOptions ? strlen(*LoadOptions) : 0);
            s = BlAllocateHeap(len * sizeof(PCHAR));
            if (s) {
                *s = 0;
                if (*LoadOptions) {
                    strcat(s,*LoadOptions);
                    strcat(s," ");
                }
                strcat(s,BlGetAdvancedBootLoadOptions(AdvancedBoot));
                *LoadOptions = s;
            }
        }
        BlDoAdvancedBootLoadProcessing(AdvancedBoot);
    }

    //
    // Make sure there is no trailing slash
    //

    if (Kernel[strlen(Kernel)-1] == '\\') {
        Kernel[strlen(Kernel)-1] = '\0';
    }

    //
    // If MaxMemory is not zero, adjust the memory descriptors to eliminate
    // memory above the boundary line
    //
    // [chuckl 12/03/2001] Note that we use BlpTruncateDescriptors, not
    // BlpTruncateMemory. BlpTruncateMemory truncates the low-level MDArray
    // descriptors, while BlTruncateDescriptors truncates the loader-level
    // memory descriptor list. Using BlpTruncateMemory worked when the loader
    // initialized its memory list twice. (BlMemoryInitialize was called twice.)
    // But this no longer happens, so we have to truncate the descriptors
    // directly here.
    //

    if (MenuOption[Selection].MaxMemory != 0) {
        ULONG MaxPage = (MenuOption[Selection].MaxMemory * ((1024 * 1024) / PAGE_SIZE)) - 1;
        BlTruncateDescriptors(MaxPage);
    }

    ForcedScsiOrdinal = MenuOption[Selection].ForcedScsiOrdinal;

    return(Kernel);
}

VOID
BlParseOsOptions (
    IN PMENU_OPTION MenuOption,
    IN PCHAR pCurrent
    )
{
    PCHAR      p;

    //
    // Clear all settings
    //

    MenuOption->ForcedScsiOrdinal = -1;
    MenuOption->MaxMemory = 0;
    MenuOption->LoadOptions = NULL;
    MenuOption->Win95 = 0;
    MenuOption->EnableDebug = FALSE;
    MenuOption->HeadlessRedirect = FALSE;

    // If there are no switches specified for this line, use the DefSwitches

    if ((strchr(pCurrent,'/') == NULL) && (pDefSwitches)) {
        pCurrent = pDefSwitches;
    }

    //
    // Convert to all one case
    //

    _strupr(pCurrent);

    //
    // Look for a scsi(x) ordinal to use for opens on scsi ARC paths.
    // This spec must immediately follow the title and is not part
    // of the load options.
    //

    p = strstr(pCurrent,"/SCSIORDINAL:");
    if(p) {
        MenuOption->ForcedScsiOrdinal = atoi(p + sizeof("/SCSIORDINAL:") - 1);
    }

    //
    // If there is a REDIRECT parameter after the description, then
    // we need to pass this to the osloader.
    //

    p = strstr(pCurrent,"/REDIRECT");
    if(p) {
        MenuOption->HeadlessRedirect = TRUE;
    }

    //
    // If there is a DEBUG parameter after the description, then
    // we need to pass the DEBUG option to the osloader.
    //

    if (strchr(pCurrent,'/') != NULL) {
        pCurrent = strchr(pCurrent+1,'/');
        MenuOption->LoadOptions = pCurrent;

        if (pCurrent != NULL) {

            p = strstr(pCurrent,"/MAXMEM");
            if (p) {
                MenuOption->MaxMemory = atoi(p+8);
            }

            if (strstr(pCurrent, "/WIN95DOS")) {
                MenuOption->Win95 = WIN95_DOS;
            } else if (strstr(pCurrent, "/WIN95")) {
                MenuOption->Win95 = DOS_WIN95;
            }

            //
            // As long as /nodebug or /crashdebug is specified, this is NO debug system
            // If /NODEBUG is not specified, and either one of the
            // DEBUG or BAUDRATE is specified, this is debug system.
            //

            if ((strstr(pCurrent, "NODEBUG") == NULL) &&
                (strstr(pCurrent, "CRASHDEBUG") == NULL)) {
                if (strstr(pCurrent, "DEBUG") || strstr(pCurrent, "BAUDRATE")) {

                    if (_stricmp(MenuOption->Path, "C:\\")) {
                        MenuOption->EnableDebug = TRUE;
                    }
                }
            }
        }
    }
}

PCHAR *
BlpFileToLines(
    IN PCHAR File,
    OUT PULONG LineCount
    )

/*++

Routine Description:

    This routine converts the loaded BOOT.INI file into an array of
    pointers to NULL-terminated ASCII strings.

Arguments:

    File - supplies a pointer to the in-memory image of the BOOT.INI file.
           This will be converted in place by turning CR/LF pairs into
           null terminators.

    LineCount - Returns the number of lines in the BOOT.INI file.

Return Value:

    A pointer to an array of pointers to ASCIIZ strings.  The array will
    have LineCount elements.

    NULL if the function did not succeed for some reason.

--*/

{
    ULONG Line;
    PCHAR *LineArray;
    PCHAR p;
    PCHAR Space;

    p = File;

    //
    // First count the number of lines in the file so we know how large
    // an array to allocate.
    //
    *LineCount=1;
    while (*p != '\0') {
        p=strchr(p, '\n');
        if (p==NULL) {
            break;
        }
        ++p;

        //
        // See if there's any text following the CR/LF.
        //
        if (*p=='\0') {
            break;
        }

        *LineCount += 1;
    }

    LineArray = BlAllocateHeap(*LineCount * sizeof(PCHAR));

    //
    // Now step through the file again, replacing CR/LF with \0\0 and
    // filling in the array of pointers.
    //
    p=File;
    for (Line=0; Line < *LineCount; Line++) {
        LineArray[Line] = p;
        p=strchr(p, '\r');
        if (p != NULL) {
            *p = '\0';
            ++p;
            if (*p=='\n') {
                *p = '\0';
                ++p;
            }
        } else {
            p=strchr(LineArray[Line], '\n');
            if (p != NULL) {
                *p = '\0';
                ++p;
            }
        }

        //
        // remove trailing white space
        //
        Space = LineArray[Line] + strlen(LineArray[Line])-1;
        while ((*Space == ' ') || (*Space == '\t')) {
            *Space = '\0';
            --Space;
        }
    }

    return(LineArray);
}


PCHAR *
BlpFindSection(
    IN PCHAR SectionName,
    IN PCHAR *BootFile,
    IN ULONG BootFileLines,
    OUT PULONG NumberLines
    )

/*++

Routine Description:

    Finds a section ([multiboot], [operating systems], etc) in the boot.ini
    file and returns a pointer to its first line.  The search will be
    case-insensitive.

Arguments:

    SectionName - Supplies the name of the section.  No brackets.

    BootFile - Supplies the array of pointers to lines of the ini file.

    BootFileLines - Supplies the number of lines in the ini file.

    NumberLines - Returns the number of lines in the section.

Return Value:

    Pointer to an array of ASCIIZ strings, one entry per line.

    NULL, if the section was not found.

--*/

{
    ULONG cnt;
    ULONG StartLine;

    for (cnt=0; cnt<BootFileLines; cnt++) {

        //
        // Check to see if this is the line we are looking for
        //
        if (_stricmp(BootFile[cnt],SectionName) == 0) {

            //
            // found it
            //
            break;
        }
    }
    if (cnt==BootFileLines) {
        //
        // We ran out of lines, never found the right section.
        //
        *NumberLines = 0;
        return(NULL);
    }

    StartLine = cnt+1;

    //
    // Find end of section
    //
    for (cnt=StartLine; cnt<BootFileLines; cnt++) {
        if (BootFile[cnt][0] == '[') {
            break;
        }
    }

    *NumberLines = cnt-StartLine;

    return(&BootFile[StartLine]);
}

PCHAR
BlpNextLine(
    IN PCHAR String
    )

/*++

Routine Description:

    Finds the beginning of the next text line

Arguments:

    String - Supplies a pointer to a null-terminated string

Return Value:

    Pointer to the character following the first CR/LF found in String

        - or -

    NULL - No CR/LF found before the end of the string.

--*/

{
    PCHAR p;

    p=strchr(String, '\n');
    if (p==NULL) {
        return(p);
    }

    ++p;

    //
    // If there is no text following the CR/LF, there is no next line
    //
    if (*p=='\0') {
        return(NULL);
    } else {
        return(p);
    }
}

VOID
BlpRebootDOS(
    IN PCHAR BootSectorImage OPTIONAL,
    IN PCHAR LoadOptions OPTIONAL
    )

/*++

Routine Description:

    Loads up the bootstrap sectors and executes them (thereby rebooting
    into DOS or OS/2)

Arguments:

    BootSectorImage - If specified, supplies name of file on the C: drive
        that contains the boot sector image. In this case, this routine
        will return if that file cannot be opened (for example, if it's
        a directory).  If not specified, then default to \bootsect.dos,
        and this routine will never return.

Return Value:

    None.

--*/

{
    ULONG SectorId;
    ARC_STATUS Status;
    ULONG Read;
    ULONG DriveId;
    ULONG BootType;
    LARGE_INTEGER SeekPosition;
    extern UCHAR BootPartitionName[];

    //
    // HACKHACK John Vert (jvert)
    //     Some SCSI drives get really confused and return zeroes when
    //     you use the BIOS to query their size after the AHA driver has
    //     initialized.  This can completely tube OS/2 or DOS.  So here
    //     we try and open both BIOS-accessible hard drives.  Our open
    //     code is smart enough to retry if it gets back zeros, so hopefully
    //     this will give the SCSI drives a chance to get their act together.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    //
    // Load the boot sector at address 0x7C00 (expected by Reboot callback)
    //
    Status = ArcOpen((PCHAR)BootPartitionName,
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status != ESUCCESS) {
        BlPrint(BlFindMessage(BL_REBOOT_IO_ERROR),BootPartitionName);
        while (1) {
            BlGetKey();
        }
    }
    Status = BlOpen( DriveId,
                     BootSectorImage ? BootSectorImage : "\\bootsect.dos",
                     ArcOpenReadOnly,
                     &SectorId );

    if (Status != ESUCCESS) {
        if(BootSectorImage) {
            //
            // The boot sector image might actually be a directory.
            // Return to the caller to attempt standard boot.
            //
            ArcClose(DriveId);
            return;
        }
        BlPrint(BlFindMessage(BL_REBOOT_IO_ERROR),BootPartitionName);
        while (1) {
        }
    }

    Status = BlRead( SectorId,
                     (PVOID)0x7c00,
                     SECTOR_SIZE,
                     &Read );

    if (Status != ESUCCESS) {
        BlPrint(BlFindMessage(BL_REBOOT_IO_ERROR),BootPartitionName);
        while (1) {
        }
    }

    //
    // The FAT boot code is only one sector long so we just want
    // to load it up and jump to it.
    //
    // For HPFS and NTFS, we can't do this because the first sector
    // loads the rest of the boot sectors -- but we want to use
    // the boot code in the boot sector image file we loaded.
    //
    // For HPFS, we load the first 20 sectors (boot code + super and
    // space blocks) into d00:200.  Fortunately this works for both
    // NT and OS/2.
    //
    // For NTFS, we load the first 16 sectors and jump to d00:256.
    // If the OEM field of the boot sector starts with NTFS, we
    // assume it's NTFS boot code.
    //

    //
    // Try to read 8K from the boot code image.
    // If this succeeds, we have either HPFS or NTFS.
    //
    SeekPosition.QuadPart = 0;
    BlSeek(SectorId,&SeekPosition,SeekAbsolute);
    BlRead(SectorId,(PVOID)0xd000,SECTOR_SIZE*16,&Read);

    if(Read == SECTOR_SIZE*16) {

        if(memcmp((PVOID)0x7c03,"NTFS",4)) {

            //
            // HPFS -- we need to load the super block.
            //
            BootType = 1;       // HPFS

            SeekPosition.QuadPart = 16*SECTOR_SIZE;
            ArcSeek(DriveId,&SeekPosition,SeekAbsolute);
            ArcRead(DriveId,(PVOID)0xf000,SECTOR_SIZE*4,&Read);

        } else {

            //
            // NTFS -- we've loaded everything we need to load.
            //
            BootType = 2;   // NTFS
        }
    } else {

        BootType = 0;       // FAT

    }

    if (LoadOptions) {
        if (strstr(LoadOptions,"CMDCONS") != NULL) {
            strcpy( (PCHAR)(0x7c03), "cmdcons" );
        } else if (strcmp(LoadOptions,"ROLLBACK") == 0) {

            //
            // By definition, when /rollback is specified, it is the only load
            // option. It eventually gets parsed, gets upper-cased, and gets
            // its slash removed. So we check for the exact text "ROLLBACK".
            //
            // When rollback is specified, we have to write a token somewhere
            // in the boot sector. This is our only way to send runtime
            // options to the setup loader.
            //
            // There is a data buffer of 8 bytes at 0000:7C03 in all boot
            // sectors today. Fortunately we can overwrite it. So we hard-code
            // this address here and in the setup loader.
            //

            strcpy( (PCHAR)(0x7c03), "undo" );
        }
    }

    //
    // DX must be the drive to boot from
    //

    _asm {
        mov dx, 0x80
    }
    REBOOT(BootType);

}


ULONG
BlpPresentMenu(
    IN PMENU_OPTION MenuOption,
    IN ULONG NumberSelections,
    IN ULONG Default,
    IN LONG Timeout
    )

/*++

Routine Description:

    Displays the menu of boot options and allows the user to select one
    by using the arrow keys.

Arguments:

    MenuOption - Supplies array of menu options

    NumberSelections - Supplies the number of entries in the MenuOption array.

    Default - Supplies the index of the default operating system choice.

    Timeout - Supplies the timeout (in seconds) before the highlighted
              operating system choice is booted.  If this value is -1,
              the menu will never timeout.

Return Value:

    ULONG - The index of the operating system choice selected.

--*/

{
    ULONG i;
    ULONG Selection;
    ULONG StartTime;
    ULONG LastTime;
    ULONG BiasTime=0;
    ULONG CurrentTime;
    LONG SecondsLeft;
    LONG LastSecondsLeft = -1;
    ULONG EndTime;
    ULONG Key;
    ULONG CurrentLength;
    PCHAR DebugSelect;
    PCHAR SelectOs;
    PCHAR MoveHighlight;
    PCHAR TimeoutCountdown;
    PCHAR EnabledKd;
    PCHAR AdvancedBootMessage;
    PCHAR HeadlessRedirect;
    PCHAR p;
    BOOLEAN Moved;
    BOOLEAN ResetDisplay;
    BOOLEAN AllowNewOptions;
    BOOLEAN BlankLineDrawn;
    PCHAR pDebug;

    //
    // Get the strings we'll need to display.
    //
    SelectOs = BlFindMessage(BL_SELECT_OS);
    MoveHighlight = BlFindMessage(BL_MOVE_HIGHLIGHT);
    TimeoutCountdown = BlFindMessage(BL_TIMEOUT_COUNTDOWN);
    EnabledKd = BlFindMessage(BL_ENABLED_KD_TITLE);
    AdvancedBootMessage = BlFindMessage(BL_ADVANCED_BOOT_MESSAGE);
    HeadlessRedirect = BlFindMessage(BL_HEADLESS_REDIRECT_TITLE);
    if ((SelectOs == NULL)      ||
        (MoveHighlight == NULL) ||
        (EnabledKd == NULL)     ||
        (TimeoutCountdown==NULL)||
        (AdvancedBootMessage == NULL)) {

        return(Default);
    }

    p=strchr(TimeoutCountdown,'\r');
    if (p!=NULL) {
        *p='\0';
    }

    p=strchr(EnabledKd,'\r');
    if (p!=NULL) {
        *p='\0';
    }

    p=strchr(HeadlessRedirect,'\r');
    if (p!=NULL) {
        *p='\0';
    }

    if (NumberSelections<=1) {
        Timeout = 0;
    }

    if (Timeout == 0) {

        //
        // Check for F5 or F8 key
        //
        switch (BlGetKey()) {
        case F5_KEY:
        case F8_KEY:
            Timeout = -1;
            break;

        default:
            // 
            // Timeout is zero, and we didn't get a f5 or f8.  
            // immediately boot the default
            //
            return(Default);
        }
    }

    //
    // By default, on a free build of the loader only allow the
    // user to specify new options if there is some selection
    // which supports debugging or selection to boot dos.  If
    // all the selections are for non-debug versions of NT then
    // do not allow the user to change any of them
    //

    AllowNewOptions = FALSE;
#if DBG
    AllowNewOptions = TRUE;
#endif

    //
    // Find the longest string in the selections, so we know how long to
    // make the highlight bar.
    //

    for (i=0; i<NumberSelections; i++) {
        if( strlen(MenuOption[i].Title)> MAX_TITLE_LENGTH ) {
            MenuOption[i].Title[MAX_TITLE_LENGTH - 1] = '\0';
        }

        if (MenuOption[i].EnableDebug == TRUE ||
            MenuOption[i].Win95 != 0 ||
            _stricmp(MenuOption[i].Path, "C:\\") == 0) {
                AllowNewOptions = TRUE;
        }

    }

    Selection = Default;
    CurrentTime = StartTime = GET_COUNTER();
    EndTime = StartTime + (Timeout * 182) / 10;
    pDebug = szDebug;
    DebugSelect = NULL;
    ResetDisplay = TRUE;
    Moved = TRUE;
    BlankLineDrawn = FALSE;
    do {

        if (ResetDisplay) {
            ARC_DISPLAY_ATTRIBUTES_OFF();
            ARC_DISPLAY_CLEAR();
//          ARC_DISPLAY_POSITION_CURSOR(0, 0);
//          BlPrint(OsLoaderVersion);
            ARC_DISPLAY_POSITION_CURSOR(0, 23);
            if (AdvancedBoot != -1) {
                ARC_DISPLAY_SET_COLOR("1;34"); // high-intensity red
                BlPrint(BlGetAdvancedBootDisplayString(AdvancedBoot));
                ARC_DISPLAY_ATTRIBUTES_OFF();
            } else {
                ARC_DISPLAY_CLEAR_TO_EOL();
            }
            ARC_DISPLAY_POSITION_CURSOR(0, 21);
            BlPrint(AdvancedBootMessage);
            ARC_DISPLAY_POSITION_CURSOR(0, 2);
            BlPrint(SelectOs);
            ResetDisplay = FALSE;
            ARC_DISPLAY_POSITION_CURSOR(0, 5+NumberSelections-1);
            BlPrint(MoveHighlight);
        }

        if(Moved) {
            for (i=0; i<NumberSelections; i++) {

                //
                // keep track of how many characters we've printed
                // on this line.
                //
                CurrentLength = 0;

                //
                // Display the title.
                //                
                ARC_DISPLAY_POSITION_CURSOR(0, 5+i);
                if (i==Selection) {
                    ARC_DISPLAY_INVERSE_VIDEO();
                }
                BlPrint( "    %s", MenuOption[i].Title);

                CurrentLength += 4; // spaces
                CurrentLength += strlen(MenuOption[i].Title);


                if (MenuOption[i].HeadlessRedirect == TRUE) {
                    if( (CurrentLength + strlen(HeadlessRedirect)) < MAX_TITLE_LENGTH ) {                    
                        BlPrint(HeadlessRedirect);
                        CurrentLength += strlen(HeadlessRedirect);
                    }
                }

                if (MenuOption[i].EnableDebug == TRUE) {
                    if( (CurrentLength + strlen(EnabledKd)) < MAX_TITLE_LENGTH ) {                    
                        BlPrint(EnabledKd);
                        CurrentLength += strlen(EnabledKd);
                    }
                }
                ARC_DISPLAY_ATTRIBUTES_OFF();
            }

            if (DebugSelect) {
                ARC_DISPLAY_POSITION_CURSOR(0, 7+NumberSelections-1);
                ARC_DISPLAY_CLEAR_TO_EOD();
                DebugLoadOptions[0] = 0;
                DebugLoadOptions[DEBUG_LOAD_OPTION_LENGTH-1] = 0;
                if (MenuOption[Selection].LoadOptions) {
                    i = strlen(MenuOption[Selection].LoadOptions) + 1;
                    if (i > DEBUG_LOAD_OPTION_LENGTH-1) {
                        i = DEBUG_LOAD_OPTION_LENGTH-1;
                    }

                    memcpy (DebugLoadOptions, MenuOption[Selection].LoadOptions, i);
                }

                BlPrint (
                    DebugSelect,
                    MenuOption[Selection].Title,
                    MenuOption[Selection].Path,
                    DebugLoadOptions
                    );

            }

            Moved = FALSE;
        }


        if (!DebugSelect) {
            if (Timeout != -1) {
                LastTime = CurrentTime;
                CurrentTime = GET_COUNTER();

                //
                // deal with wraparound at midnight
                // We can't do it the easy way because there are not exactly
                // 18.2 * 60 * 60 * 24 tics/day.  (just approximately)
                //
                if (CurrentTime < StartTime) {
                    if (BiasTime == 0) {
                        BiasTime = LastTime + 1;
                    }
                    CurrentTime += BiasTime;
                }
                SecondsLeft = ((LONG)(EndTime - CurrentTime) * 10) / 182;

                if (SecondsLeft < 0) {

                    //
                    // Note that if the user hits the PAUSE key, the counter stops
                    // and, as a result, SecondsLeft can become < 0.
                    //

                    SecondsLeft = 0;
                }

                if (SecondsLeft != LastSecondsLeft) {

                    ARC_DISPLAY_POSITION_CURSOR(0, 5+NumberSelections-1);
                    BlPrint(MoveHighlight);
                    BlPrint(TimeoutCountdown);
                    BlPrint(" %d \n",SecondsLeft);
                    LastSecondsLeft = SecondsLeft;

                }

            } else if (!BlankLineDrawn) {
                BlankLineDrawn = TRUE;
                ARC_DISPLAY_POSITION_CURSOR(0, 5+NumberSelections-1);
                BlPrint(MoveHighlight);
                BlPrint(BlankLine);
            }

        }

        //
        // Poll for a key.
        //
        Key = BlGetKey();

        if (Key) {

            //
            // Any key stops timeout
            //

            Timeout = -1;

            //
            // Check for debug string
            //

            if ((UCHAR) Key == *pDebug) {
                pDebug++;
                if (!*pDebug) {
                    Moved = TRUE;
                    DebugSelect = BlFindMessage(BL_DEBUG_SELECT_OS);
                    SelectOs = DebugSelect;
                }
            } else {
                pDebug = szDebug;
            }
        }

#if defined(ENABLE_LOADER_DEBUG) || DBG

        //
        // for debugging only.
        // lets you break into the debugger
        // with the F10 key.
        //
        if (Key == F10_KEY) {
            extern LOGICAL BdDebuggerEnabled;

            if (BdDebuggerEnabled == TRUE) {
                DbgBreakPoint();
            }
        }
#endif

        //
        // check for advanced boot options
        //

        if (Key == F8_KEY || Key == F5_KEY) {

            AdvancedBoot = BlDoAdvancedBoot( BL_ADVANCEDBOOT_TITLE, AdvancedBoot, FALSE, 0 );

#if 0
            if ((AdvancedBoot != -1) &&
                    (BlGetAdvancedBootID(AdvancedBoot) == BL_MSG_BOOT_NORMALLY)) {
                AdvancedBoot = -1;
                // break;  // the current selection need to be booted (normally)
            }
#endif

            if ((AdvancedBoot != -1) &&
                    (BlGetAdvancedBootID(AdvancedBoot) == BL_MSG_REBOOT)) {
                BlClearScreen();
                ArcReboot();
            }

            ResetDisplay = TRUE;
            Moved = TRUE;

        } else

        //
        // Check for selection
        //

        if ( (Key==UP_ARROW) ||
             (Key==DOWN_ARROW) ||
             (Key==HOME_KEY) ||
             (Key==END_KEY)
           ) {
            Moved = TRUE;
            ARC_DISPLAY_POSITION_CURSOR(0, 5+Selection);
            ARC_DISPLAY_ATTRIBUTES_OFF();
            BlPrint( "    %s", MenuOption[Selection].Title);
            if (Key==DOWN_ARROW) {
                Selection = (Selection+1) % NumberSelections;
            } else if (Key==UP_ARROW) {
                Selection = (Selection == 0) ? (NumberSelections-1)
                                             : (Selection - 1);
            } else if (Key==HOME_KEY) {
                Selection = 0;
            } else if (Key==END_KEY) {
                Selection = NumberSelections-1;
            }
        }

    } while ( ((Key&(ULONG)0xff) != ENTER_KEY) &&
              ((CurrentTime < EndTime) || (Timeout == -1)) );

    //
    // If debugging, prompt the user for new load options
    //

    if (DebugSelect  &&  AllowNewOptions) {
        ARC_DISPLAY_CLEAR();
        ARC_DISPLAY_POSITION_CURSOR(0, 2);
        ARC_DISPLAY_CLEAR_TO_EOD();

        BlPrint (
            DebugSelect,
            MenuOption[Selection].Title,
            MenuOption[Selection].Path,
            DebugLoadOptions
            );

        BlInputString (
            BL_DEBUG_NEW_OPTIONS,
            0, 7,
            (PUCHAR)DebugLoadOptions,
            DEBUG_LOAD_OPTION_LENGTH - 1
            );

        BlParseOsOptions (
            &MenuOption[Selection],
            DebugLoadOptions
            );
    }

    return(Selection);
}



ARC_STATUS
BlpRenameWin95SystemFile(
    IN ULONG DriveId,
    IN ULONG Type,
    IN PCHAR FileName,
    IN PCHAR Ext,
    IN PCHAR NewName
    )

/*++

Routine Description:

    Renames a file from one name to another.

Arguments:

    DriveId     - Open drive identifier
    Type        - WIN95_DOS or DOS_WIN95
    FileName    - Base file name
    Ext         - Base extension
    NewName     - Non-NULL value causes an override of a generated name

Return Value:

    Arc status of the failed opperation or E_SUCCESS.

--*/

{
    ARC_STATUS Status;
    ULONG FileId;
    ULONG FileIdCur;
    CHAR Fname[16];
    CHAR FnameCur[16];
    CHAR FnameNew[16];


    if (Type == WIN95_DOS) {
        sprintf( Fname, "%s.dos", FileName );
    } else {
        if (NewName) {
            strcpy( Fname, NewName );
        } else {
            sprintf( Fname, "%s.w40", FileName );
        }
    }

    Status = BlOpen(
        DriveId,
        Fname,
        ArcOpenReadOnly,
        &FileId
        );
    if (Status != ESUCCESS) {
        return Status;
    }

    sprintf( FnameCur, "%s.%s", FileName, Ext );

    Status = BlOpen(
        DriveId,
        FnameCur,
        ArcOpenReadOnly,
        &FileIdCur
        );
    if (Status != ESUCCESS) {
        BlClose( FileId );
        return Status;
    }

    if (Type == WIN95_DOS) {
        if (NewName) {
            strcpy( FnameNew, NewName );
        } else {
            sprintf( FnameNew, "%s.w40", FileName );
        }
    } else {
        sprintf( FnameNew, "%s.dos", FileName );
    }

    Status = BlRename(
        FileIdCur,
        FnameNew
        );

    BlClose( FileIdCur );

    if (Status != ESUCCESS) {
        BlClose( FileId );
        return Status;
    }

    Status = BlRename(
        FileId,
        FnameCur
        );

    BlClose( FileId );

    return Status;
}


VOID
BlpRenameWin95Files(
    IN ULONG DriveId,
    IN ULONG Type
    )

/*++

Routine Description:

    Renames all Windows 95 system files from either their
    Win95 DOS names to their Win95 name or the reverse.

Arguments:

    DriveId     - Open drive identifier
    Type        - 1=dos to win95, 2=win95 to dos

Return Value:

    None.

--*/

{
    BlpRenameWin95SystemFile( DriveId, Type, "command",  "com", NULL );
    BlpRenameWin95SystemFile( DriveId, Type, "msdos",    "sys", NULL  );
    BlpRenameWin95SystemFile( DriveId, Type, "io",       "sys", "winboot.sys" );
    BlpRenameWin95SystemFile( DriveId, Type, "autoexec", "bat", NULL  );
    BlpRenameWin95SystemFile( DriveId, Type, "config",   "sys", NULL  );
}

ULONG
BlGetAdvancedBootOption(
    VOID
    )
{
    return AdvancedBoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bldr\i386\spcrtest.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldrx86.h"
#include "msg.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#if defined(REMOTE_BOOT)
#include <netboot.h>
#endif // defined(REMOTE_BOOT)

BOOLEAN
BlpPaeSupported(
    VOID
    );

BOOLEAN
BlpChipsetPaeSupported(
    VOID
    );

ARC_STATUS
Blx86IsPaeImage(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae
    );

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    IN OUT PBOOLEAN UsePae
    );


UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];

extern BOOLEAN ForceLastKnownGood;
extern ULONG    BlHighestPage;


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BlLogFileId = (ULONG)-1;
    ULONG Read;
    PCHAR p,q;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;
    PCHAR BadLinkName = NULL;
    BOOLEAN SPCRTestSucceeded = FALSE;

    //
    // Open the boot partition so we can load boot drivers off it.
    //
    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);
    if (Status != ESUCCESS) {
        BlPrint("Couldn't open drive %s\n",PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    //
    // Initialize dbcs font and display support.
    //
    TextGrInitialize(DriveId, NULL);

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Re-open the boot partition as a temporary work around
    // for NTFS caching bug.
    //
    ArcClose(DriveId);

    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);
    
    if (Status != ESUCCESS) {
        BlPrint("Couldn't open drive %s\n",PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    RtlZeroMemory( &LoaderRedirectionInformation,
                   sizeof(HEADLESS_LOADER_BLOCK) );


    //
    // See if we get something from the BIOS.
    //
    if( BlRetrieveBIOSRedirectionInformation() ) {

        BlInitializeHeadlessPort();

        BlPrint("SPCR table detected.\r\n" );
        BlPrint("         PortAddress: %lx\r\n", LoaderRedirectionInformation.PortAddress );
        BlPrint("          PortNumber: %d\r\n", LoaderRedirectionInformation.PortNumber );
        BlPrint("            BaudRate: %d\r\n", LoaderRedirectionInformation.BaudRate );
        BlPrint("              Parity: %d\r\n", LoaderRedirectionInformation.Parity ? 1 : 0 );
        BlPrint("        AddressSpace: %s\r\n", LoaderRedirectionInformation.IsMMIODevice ? "MMIO" : "SysIO" );
        BlPrint("            StopBits: %d\r\n", LoaderRedirectionInformation.StopBits );
        BlPrint("         PciDeviceId: %lx\r\n", LoaderRedirectionInformation.PciDeviceId );
        BlPrint("         PciVendorId: %lx\r\n", LoaderRedirectionInformation.PciVendorId );
        BlPrint("        PciBusNumber: %lx\r\n", LoaderRedirectionInformation.PciBusNumber );
        BlPrint("       PciSlotNumber: %lx\r\n", LoaderRedirectionInformation.PciSlotNumber );
        BlPrint("   PciFunctionNumber: %lx\r\n", LoaderRedirectionInformation.PciFunctionNumber );
        BlPrint("            PciFlags: %lx\r\n", LoaderRedirectionInformation.PciFlags );



        if( BlIsTerminalConnected() ) {
        ULONG   RandomNumber1 = 0;
        ULONG   RandomNumber2 = 0;
        ULONG   ch = 0;

            BlPrint("\r\nUART address verified.\r\n" );

TryAgain:
            //
            // Now generate a (semi)random string.
            //
            RandomNumber1 = (ArcGetRelativeTime() & 0x7FFF) << 16;
            RandomNumber1 += (ArcGetRelativeTime() & 0xFFFF) << 1;

            RandomNumber2 = 0;


            //
            // Send the string, then ask the user to send it back.
            //
            BlPrint( "\r\nPlease enter the following test string: '%d'\r\n", RandomNumber1 );

            do {

                // Get a key.
                while( !(ch = BlGetKey()) ) {
                }

                ch &= 0xFF;
                if( (ch <= '9') && (ch >= '0') ) {
                    RandomNumber2 = (RandomNumber2 * 10) + (ch - 0x30);
                }

            } while( (ch != 0) && (ch != '\r') && (ch != '\n') );

            if( RandomNumber1 == RandomNumber2 ) {
                BlPrint( "Identical string returned. '%d'\r\n", RandomNumber2 );

                SPCRTestSucceeded = TRUE;
                
                
            } else {

                //
                // We failed the check.  Inform the user and try again.
                //
                BlPrint( "Inconsistent string returned. '%d'\r\n", RandomNumber2 );

                // clear the input buffer
                while( (ch = BlGetKey()) );
                goto TryAgain;
            }




        } else {
            BlPrint("\r\nUnable to verify UART address.\r\n" );
        }
        
    } else {

        BlPrint("No SPCR table detected.\r\n");
    }



    //
    // Log the results.
    //
    Status = BlOpen( DriveId,
                     "\\spcrtest.txt",
                     ArcSupersedeReadWrite,
                     &BlLogFileId );

    if (Status != ESUCCESS) {
        BlPrint("Couldn't open logfile on boot drive.\n");
        goto BootFailed;
    } else {

        UCHAR   Buffer[30];
        LONG    Count;

        Count = sizeof(Buffer);
        RtlFillMemory( Buffer, Count, ' ' );
        if( SPCRTestSucceeded ) {
            sprintf( Buffer, "SPCR test succeeded." );
        } else {
            sprintf( Buffer, "SPCR test failed." );
        }
        BlWrite( BlLogFileId, Buffer, Count, &Count );

        BlClose( BlLogFileId );
    }

BootFailed:
    while(1);

}

VOID
DoApmAttemptReconnect(
    VOID
    )
{
}


BOOLEAN
Blx86CheckForPaeKernel(
    IN BOOLEAN UserSpecifiedPae,
    IN BOOLEAN UserSpecifiedNoPae,
    IN PCHAR UserSpecifiedKernelImage,
    IN PCHAR HalImagePath,
    IN ULONG LoadDeviceId,
    IN ULONG SystemDeviceId,
    OUT PULONG HighestSystemPage,
    OUT PBOOLEAN UsePaeMode,
    IN OUT PCHAR KernelPath
    )
{
    return TRUE;
}

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    OUT PBOOLEAN UsePae
    )
{
    return TRUE;
}

ARC_STATUS
Blx86IsPaeImage(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae
    )
{
    return ESUCCESS;
}


BOOLEAN
BlpChipsetPaeSupported(
    VOID
    )
{
    return(TRUE);
}

ARC_STATUS
BlpCheckVersion(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath
    )
{
    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\makefile.inc ===
$(O)\bootfix.bin: ..\etfs\i386\bootfix.asm ..\etfs\i386\$(LANGUAGE)\bootfix.inc
    masm386 -I..\etfs\i386 -I..\etfs\i386\$(LANGUAGE) ..\etfs\i386\bootfix.asm,$(O)\bootfix.obj;
    link16 /tiny $(O)\bootfix.obj,$@;

$(O)\etfsboot.com: i386\etfsboot.asm i386\usa\etfsboot.inc
    masm386 -Ii386 -Ii386\usa i386\etfsboot.asm,$(O)\etfsboot.obj;
    link16 /tiny $(O)\etfsboot.obj,$@;
    
$(O)\bootefs.h: $(O)\etfsboot.com
    bin2c $(O)\etfsboot.com 2048 0 2048 $@ EtfsBootCode
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\i386\etfsboot.asm ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
; etfsboot.asm
;
;Abstract:
;
; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If an El
; Torito CD-ROM with no-emulation support is detected, it will then load
; the "image" pointed to in the Boot Catalog.  This "image" is placed at
; the physical address specified in the Boot Catalog (which should be 07C00h).
;
; The code in this "image" is responsible for locating NTLDR, loading the
; first sector of NTLDR into memory at 2000:0000, and branching to it.
;
; There are only two errors possible during execution of this code.
;       1 - NTLDR does not exist
;       2 - BIOS read error
;
; In both cases, a short message is printed, and the user is prompted to
; reboot the system.
;
;
;Author:
;
;    Steve Collins (stevec) 25-Oct-1995
;
;Environment:
;
;    Image has been loaded at 7C0:0000 by BIOS. (or 0000:7C00 to support some broken BIOSes)
;    Real mode
;    ISO 9660 El Torito no-emulation CD-ROM Boot support
;    DL = El Torito drive number we booted from
;
;Revision History:
;
;    Calin Negreanu (calinn) 25-May-1998 - added safety check at the beginning of the code
;                                        - added code for loading and executing BOOTFIX.BIN
;                                        - modified error path
;--
        page    ,132
        title   boot - NTLDR ETFS loader
        name    etfsboot

EtfsCodeSize    EQU     2048

BootSeg segment at 07c0h
BootSeg ends

DirSeg  segment at 1000h
DirSeg  ends

LoadSeg segment at 2000h
LoadSeg ends

BootCode        segment                         ;would like to use BootSeg here, but LINK flips its lid
    ASSUME  CS:BootCode,DS:NOTHING,ES:NOTHING,SS:NOTHING

        public  ETFSBOOT
ETFSBOOT proc    far

        cli

        ;WARNING!!! DO NOT CHANGE THE STACK SETUP. BOOTFIX NEEDS THIS TO BE HERE.

        xor     ax,ax                           ; Setup the stack to a known good spot
        mov     ss,ax                           ; Stack is set to 0000:7c00, which is just below this code
        mov     sp,7c00h

        sti

        mov     ax,cs                           ; Set DS to our code segment (should be 07C0h)
        mov     ds,ax
assume DS:BootCode

;
; Save the Drive Number for later use
;
        push    dx
;
; Let's do some safety checks here. We are going to check for three things:
; 1. We are loaded at 07c0:0000 or 0000:7C00
; 2. Boot Drive Number looks good (80h-FFh)
; 3. Our code was completely loaded by the BIOS
;

        call    NextInstr
NextInstr:

        pop     si                              ; Get IP from the stack
        sub     si,OFFSET NextInstr             ; See if we run with ORIGIN 0
        jz      NormalCase                      ; Yes
        cmp     si,7C00h                        ; See if, at least we run with ORIGIN 7C00H
        jne     BootErr$wof1                    ; If not, try to display some message
        mov     ax,cs                           ; If offset is 7C00H, segment should be 0
        cmp     ax,0000h
        jne     BootErr$wof2                    ; If not, try to display some message

        ; We are loaded at 0000:7C00 instead of 07C0:0000. This could mess up
        ; some stuff so we are going to fix it.

        ; hack to execute JMP 07c0:BootOK
        db      0eah
        dw      OFFSET  BootOK
        dw      BootSeg

NormalCase:
        mov     MSG_BAD_BIOS_CODE, '3'
        mov     ax,cs                           ; See if segment is 07C0H
        cmp     ax,07c0h
        jne     BootErr$wnb                     ; If not, try to display some message

BootOK:

;
; Reset ds in case we needed to change code segment
;
        mov     ax,cs
        mov     ds,ax
;
; OK so far. Let's try to see if drive letter looks good (80h-FFh)
;
        mov     MSG_BAD_BIOS_CODE, '4'
        cmp     dl,80h
        jb      BootErr$wnb

;
; OK so far. Let's try to see if all our code was loaded.
; We look for our signature at the end of the code.
;
        mov     MSG_BAD_BIOS_CODE, '5'
        mov     bx, EtfsCodeSize - 2
        mov     ax, WORD PTR DS:[bx]
        cmp     ax, 0AA55h
        jne     BootErr$wnb

;
; Finally, everything looks good.
;

;
; Save the Drive Number for later use - right now drive number is pushed on the stack
;
        pop     dx
        mov     DriveNum,dl
;
; Let's try to load and run BOOTFIX.BIN
;
.386
        push    OFFSET BOOTFIXNAME
        push    11
        push    LoadSeg
        call    LoadFile
        jc      FindSetupLdr

;
; We have BOOTFIX.BIN loaded. We call that code to see if we should boot from CD. If we shouldn't
; we'll not come back here.
;
.286
        pusha
        push    ds
        push    es

;
; BOOTFIX requires:
;   DL = INT 13 drive number we booted from
;
        mov     dl, DriveNum                    ; DL = CD drive number

        ;hack to execute CALL LoadSeg:0000
        db      9Ah
        dw      0000h
        dw      LoadSeg

        pop     es
        pop     ds
        popa

.8086

FindSetupldr:

;
; Scan for the presence of SETUPLDR.BIN
;
.386
        push    OFFSET LOADERNAME
        push    12
        push    LoadSeg
        call    LoadFile
        jc      BootErr$bnf

;
; SETUPLDR requires:
;   DL = INT 13 drive number we booted from
;
        mov     dl, DriveNum                    ; DL = CD drive number
        xor     ax,ax
.386
        push    LoadSeg
        push    ax
        retf                                    ; "return" to NTLDR (LoadSeg:0000h). Will not come back here.

ETFSBOOT endp

;
; BootErr - print error message and hang the system.
;
BootErr proc
BootErr$wof1:                                   ; we were loaded at a wrong address - Code 1
        PUSH    SI
        MOV     BX, SI
        ADD     BX, OFFSET MSG_BAD_BIOS_CODE
        MOV     BYTE PTR DS:[BX], '1'
        ADD     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$wof2:                                   ; we were loaded at a wrong address - Code 2
        PUSH    SI
        MOV     BX, SI
        ADD     BX, OFFSET MSG_BAD_BIOS_CODE
        MOV     BYTE PTR DS:[BX], '2'
        ADD     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$wnb:                                    ; some other BIOS problem
        PUSH    0
        MOV     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$bnf:                                    ; NTLDR not found
        PUSH    0
        MOV     SI, OFFSET MSG_NO_NTLDR
        JMP     BootErr2
BootErr$mof:                                    ; memory overflow
        PUSH    0
        MOV     SI, OFFSET MSG_MEM_OVERFLOW
        JMP     BootErr2
BootErr2:
        CALL    BootErrPrint
        POP     SI
        JMP     BootFromHD

BootErrPrint:

        LODSB                                   ; Get next character
        OR      AL, AL
        JZ      BEdone

        MOV     AH, 14                          ; Write teletype
        MOV     BX, 7                           ; Attribute
        INT     10H                             ; Print it
        JMP     BootErrPrint
BEdone:
        RET
BootErr endp

;
; we are trying to boot from HD. We need to move ourself out of
; this area because we are going to load MBR here
;
BootFromHD:

;
; let's wait here for two seconds, so the user gets a chance to see the message
;

;
; hook INT08
;
        MOV     [SI+TicksCount], 24H                 ; two seconds delay
        CLI
        PUSH    ES
        XOR     AX, AX
        MOV     ES, AX
        MOV     BX, 0020H
        MOV     AX, ES:[BX]
        MOV     WORD PTR [SI+OldInt08], AX
        MOV     AX, ES:[BX+2]
        MOV     WORD PTR [SI+OldInt08+2], AX
        MOV     ES:[BX], SI
        ADD     ES:[BX], OFFSET NewInt08
        MOV     ES:[BX+2], CS
        POP     ES
        STI
;
; now let's actively wait for TicksCount to become zero
;
Delay:
        CMP     [SI+TicksCount], 0
        JNE     Delay
;
; unhook INT08
;
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     bx,08h * 4
        mov     ax,WORD PTR [SI+OldInt08]
        mov     es:[bx],ax
        mov     ax,WORD PTR [SI+OldInt08+2]
        mov     es:[bx+2],ax
        pop     es
        sti
;
; now let's move ourselves away from here because we are going to load MBR here
;
MoveCode:
        push    ds
        push    es
        mov     ax, LoadSeg
        mov     es, ax
        mov     ax, cs
        mov     ds, ax
        ;si is already set
        xor     di, di
        mov     cx, EtfsCodeSize
        rep     movsb
        pop     es
        pop     ds

        ;hack to execute JMP LoadSeg:AfterMoveLabel
        db      0eah
        dw      OFFSET  AfterMoveLabel
        dw      LoadSeg

AfterMoveLabel:
;
; finally load MBR
;
        push    es
        mov     ax, BootSeg
        mov     es, ax
        mov     bx, 0000h
        mov     ax, 0201h                                           ;read function, one sector
        mov     cx, 0001h
        mov     dx, 0080h
        int     13h
        jnc     MbrOk
;
; there was an error, nothing else to do
;
        jmp     $
MbrOk:
        pop     es
;
; now let's return into MBR code
;
        mov     dl,80h
        ;hack to execute JMP 0000:7C00
        db      0eah
        dw      7c00h
        dw      0000h

;
; We rely on the fact that SI is not changed when this INT occurs
; This is a pretty good assumption since this code is active only
; within the tight loop near Delay label. The odds are that some
; other IRQ occures, enables interrupts, changes SI and then INT08
; occures. This should not happen.
;
NewInt08:
        PUSHF
        CLI
        CMP     CS:[SI+TicksCount], 0
        JE      Default08
        DEC     WORD PTR CS:[SI+TicksCount]
Default08:
        POPF
        PUSH    WORD PTR CS:[SI+OldInt08+2]
        PUSH    WORD PTR CS:[SI+OldInt08]
        RETF

include etfsboot.inc                            ; message text

;
; ScanForEntry - Scan for an entry in a directory
;
; Entry:
;     ES:0 points to the beginning of the directory to search
;     Directory length in bytes is in ExtentLen1 and Extend_Len_0
;
; Exit:
;     CF set on error, clear on success.
;     ES:BX points to record containing entry if match is found
;
ScanForEntry proc near
        mov     ScanIncCount, 0
        mov     cx,ExtentLen0                   ; CX = length of root directory in bytes (low word only)
        cld                                     ; Work up for string compares
        xor     bx,bx
        xor     dx,dx
ScanLoop:
        mov     si, EntryToFind
        mov     dl,byte ptr es:[bx]             ; directory record length -> DL
        cmp     dl,0
        jz      Skip00                          ; if the "record length" assume it is "system use" and skip it
        mov     ax,bx
        add     ax,021h                         ; file identifier is at offset 21h in directory record
        mov     di,ax                           ; ES:DI now points to file identifier
        push    cx
        xor     cx,cx
        mov     cl,EntryLen                     ; compare bytes
        repe    cmpsb
        pop     cx
        jz      ScanEnd                         ; do we have a match?

CheckCountUnderFlow:
        ; If CX is about to underflow or be 0 we need to reset CX, ES and BX if ExtentLen1 is non-0
        cmp     dx,cx
        jae     ResetCount0

        sub     cx,dx                           ; update CX to contain number of bytes left in directory
        cmp     ScanIncCount, 1
        je      ScanAdd1ToCount

AdjustScanPtr:                                  ; Adjust ES:BX to point to next record
        add     dx,bx
        mov     bx,dx
        and     bx,0fh
        push    cx
        mov     cl,4
        shr     dx,cl
        pop     cx
        mov     ax,es
        add     ax,dx
        mov     es,ax
        jmp     ScanLoop

Skip00:
        mov     dx,1                            ; Skip past this byte
        jmp     CheckCountUnderFlow

ScanAdd1ToCount:
        inc     cx
        mov     ScanIncCount,0
        jmp     AdjustScanPtr

S0:
        mov     ScanIncCount,1                  ; We'll need to increment Count next time we get a chance
        jmp     SetNewCount

ResetCount0:
        cmp     ExtentLen1,0                    ; Do we still have at least 64K bytes left to scan?
        jne     ResetContinue
        stc                                     ; We overran the end of the directory - corrupt/invalid directory
        ret
ResetContinue:
        sub     ExtentLen1,1

        add     bx,dx                           ; Adjust ES:BX to point to next record - we cross seg boundary here
        push    bx
        push    cx
        mov     cl,4
        shr     bx,cl
        pop     cx
        mov     ax,es
        add     ax,bx
        mov     es,ax
        pop     bx
        and     bx,0fh

        sub     dx,cx                           ; Get overflow amount
        je      S0                              ; If we ended right on the boundary we need to make special adjustments
        dec     dx
SetNewCount:
        mov     ax,0ffffh
        sub     ax,dx                           ;   and subtract it from 10000h
        mov     cx,ax                           ;   - this is the new count
        jmp     ScanLoop

ScanEnd:
        cmp     IsDir,1
        je      CheckDir

        test    byte ptr es:[bx][25],2          ; Is this a file?
        jnz     CheckCountUnderFlow             ;    No - go to next record
        jmp     CheckLen

CheckDir:
        test    byte ptr es:[bx][25],2          ; Is this a directory?
        jz      CheckCountUnderFlow             ;    No - go to next record

CheckLen:
        mov     al,EntryLen
        cmp     byte ptr es:[bx][32],al         ; Is the identifier length correct?
        jnz     CheckCountUnderFlow             ;    No - go to next record

        clc
        ret
ScanForEntry endp

;
; ExtRead - Do an INT 13h extended read
; NOTE: I force the offset of the Transfer buffer address to be 0
;       I force the high 2 words of the Starting absolute block number to be 0
;       - This allows for a max 4 GB medium - a safe assumption for now
;
; Entry:
;   Arg1 - word 0 (low word) of Number of 2048-byte blocks to transfer
;   Arg2 - word 1 (high word) of Number of 2048-byte blocks to transfer
;   Arg3 - segment of Transfer buffer address
;   Arg4 - word 0 (low word) of Starting absolute block number
;   Arg5 - word 1 of Starting absolute block number
;
; Exit
;   The following are modified:
;      Count0
;      Count1
;      Dest
;      Source0
;      Source1
;      PartialRead
;      NumBlocks
;      Disk Address Packet [DiskAddPack]
;
ExtRead proc near
        push    bp                              ; set up stack frame so we can get args
        mov     bp,sp

        push    bx                              ; Save registers used during this routine
        push    si
        push    dx
        push    ax

        mov     bx,offset DiskAddPack           ; Use BX as base to index into Disk Address Packet

        ; Set up constant fields
        mov     [bx][0],byte ptr 010h           ; Offset 0: Packet size = 16 bytes
        mov     [bx][1],byte ptr 0h             ; Offset 1: Reserved (must be 0)
        mov     [bx][3],byte ptr 0h             ; Offset 3: Reserved (must be 0)
        mov     [bx][4],word ptr 0h             ; Offset 4: Offset of Transfer buffer address (force 0)
        mov     [bx][12],word ptr 0h            ; Offset 12: Word 2 of Starting absolute block number (force 0)
        mov     [bx][14],word ptr 0h            ; Offset 14: Word 3 (high word) of Starting absolute block number (force 0)

;
; Initialize loop variables
;
        mov     ax,[bp][12]                     ; set COUNT to number of blocks to transfer
        mov     Count0,ax
        mov     ax,[bp][10]
        mov     Count1,ax

        mov     ax,[bp][8]                      ; set DEST to destination segment
        mov     Dest,ax

        mov     ax,[bp][6]                      ; set SOURCE to source lbn
        mov     Source0,ax
        mov     ax,[bp][4]
        mov     Source1,ax

ExtReadLoop:
;
; First check if COUNT <= 32
;
        cmp     Count1,word ptr 0h              ; Is upper word 0?
        jne     SetupPartialRead                ;   No - we're trying to read at least 64K blocks (128 MB)
        cmp     Count0,word ptr 20h             ; Is lower word greater than 32?
        jg      SetupPartialRead                ;   Yes - only read in 32-block increments

        mov     PartialRead,0                   ; Clear flag to indicate we are doing a full read

        mov     ax,Count0                       ; NUMBLOCKS = COUNT
        mov     NumBlocks,al                    ; Since Count0 < 32 we're OK just using low byte

        jmp     DoExtRead                       ; Do read

SetupPartialRead:
;
; Since COUNT > 32,
; Set flag indicating we are only doing a partial read
;
        mov     PartialRead,1

        mov     NumBlocks,20h                   ; NUMBYTES = 32

DoExtRead:
;
; Perform Extended Read
;
        mov     al,NumBlocks                    ; Offset 2: Number of 2048-byte blocks to transfer
        mov     [bx][2],al
        mov     ax,Dest                         ; Offset 6: Segment of Transfer buffer address
        mov     [bx][6],ax
        mov     ax,Source0                      ; Offset 8: Word 0 (low word) of Starting absolute block number
        mov     [bx][8],ax
        mov     ax,Source1                      ; Offset 10: Word 1 of Starting absolute block number
        mov     [bx][10],ax

        mov     si,offset DiskAddPack           ; Disk Address Packet in DS:SI
        mov     ah,042h                         ; Function = Extended Read
        mov     dl,DriveNum                     ; CD-ROM drive number
        int     13h

;
; Determine if we are done reading
;
        cmp     PartialRead,1                   ; Did we just do a partial read?
        jne     ExtReadDone                     ;   No - we're done

ReadjustValues:
;
; We're not done reading yet, so
; COUNT = COUNT - 32
;
        sub     Count0,020h                     ; Subtract low-order words
        sbb     Count1,0h                       ; Subtract high-order words

;
; Just read 32 blocks and have more to read
; Increment DEST to next 64K segment (this equates to adding 1000h to the segment)
;
        add     Dest,1000h
        jc      BootErr$mof                     ; Error if we overflowed

;
; SOURCE = SOURCE + 32 blocks
;
        add     Source0,word ptr 020h           ; Add low order words
        adc     Source1,word ptr 0h             ; Add high order words
        ; NOTE - I don't account for overflow - probably OK now since we already account for 4 GB medium

;
; jump back to top of loop to do another read
;
        jmp     ExtReadLoop

ExtReadDone:

        pop     ax                              ; Restore registers used during this routine
        pop     dx
        pop     si
        pop     bx

        mov     sp,bp                           ; restore BP and SP
        pop     bp

        ret
ExtRead endp

;
; ReadExtent - Read in an extent
;
;   Arg1 - segment to transfer extent to
;
; Entry:
;   ExtentLen0 = word 0 (low word) of extent length in bytes
;   ExtentLen1 = word 1 (high word) of extent length in bytes
;   ExtentLoc0 = word 0 (low word) of starting absolute block number of extent
;   ExtentLoc1 = word 1 of starting absolute block number of extent
;
; Exit:
;   ExtRead exit mods
;
ReadExtent proc near
        push    bp                              ; set up stack frame so we can get args
        mov     bp,sp

        push    cx                              ; Save registers used during this routine
        push    bx
        push    ax

        mov     cl,11                           ; Convert length in bytes to 2048-byte blocks
        mov     bx,ExtentLen1                   ; Directory length = BX:AX
        mov     ax,ExtentLen0

.386
        shrd    ax,bx,cl                        ; Shift AX, filling with BX
.8086
        shr     bx,cl                           ; BX:AX = number of blocks (rounded down)
        test    ExtentLen0,07ffh                ; If any of the low-order 11 bits are set we need to round up
        jz      ReadExtentNoRoundUp
        add     ax,1                            ; We need to round up by incrementing AX, and
        adc     bx,0                            ;   adding the carry to BX
ReadExtentNoRoundUp:

        push    ax                              ; Word 0 (low word) of Transfer size = AX
        push    bx                              ; Word 1 (high word) of Transfer size = BX
.286
        push    [bp][4]                         ; Segment used to transfer extent
.8086
        push    ExtentLoc0                      ; Word 0 (low word) of Starting absolute block number
        push    ExtentLoc1                      ; Word 1 of Starting absolute block number
        call    ExtRead
        add     sp,10                           ; Clean 5 arguments off the stack

        pop     ax                              ; Restore registers used during this routine
        pop     bx
        pop     cx

        mov     sp,bp                           ; restore BP and SP
        pop     bp

        ret
ReadExtent endp

;
; GetExtentInfo - Get extent location
;
; Entry:
;   ES:BX points to record
; Exit:
;   Location -> ExtentLoc1 and ExtentLoc0
;   Length -> ExtentLen1 and ExtentLen0
;
GetExtentInfo proc near
        push    ax                              ; Save registers used during this routine

        mov     ax,es:[bx][2]                   ; 32-bit LBN of extent
        mov     ExtentLoc0,ax                   ;   store low word
        mov     ax,es:[bx][4]
        mov     ExtentLoc1,ax                   ;   store high word
        mov     ax,es:[bx][10]                  ; 32-bit file length in bytes
        mov     ExtentLen0,ax                   ;   store low word
        mov     ax,es:[bx][12]
        mov     ExtentLen1,ax                   ;   store high word

        pop     ax                              ; Restore registers used during this routine

        ret
GetExtentInfo endp

LoadFile proc near
        push    bp
        mov     bp, sp
;
; First thing, we need to read in the Primary Volume Descriptor so we can locate the root directory
;
.286
        push    01h                             ; Word 0 (low word) of Transfer size = 1 block (2048 bytes)
        push    0h                              ; Word 1 (high word) of Transfer size = 0
        push    DirSeg                          ; Segment of Transfer buffer = DirSeg
        push    010h                            ; Word 0 (low word) of Starting absolute block number = 10h
        push    0h                              ; Word 1 of Starting absolute block number = 0
.8086
        call    ExtRead
        add     sp,10                           ; Clean 5 arguments off the stack

;
; Determine the root directory location LBN -> ExtentLoc1:ExtentLoc0
; determine the root directory data length in bytes -> ExtentLen1:ExtentLen0
;
        mov     ax,DirSeg                       ; ES is set to segment used for storing PVD and directories
        mov     es,ax
ASSUME  ES:DirSeg
        mov     ax,es:[09eh]                    ; 32-bit LBN of extent at offset 158 in Primary Volume Descriptor
        mov     ExtentLoc0,ax                   ;   store low word
        mov     ax,es:[0a0h]
        mov     ExtentLoc1,ax                   ;   store high word
        mov     ax,es:[0a6h]                    ; 32-bit Root directory data length in bytes at offset 166 in Primary Volume Descriptor
        mov     ExtentLen0,ax                   ;   store low word
        mov     ax,es:[0a8h]
        mov     ExtentLen1,ax                   ;   store high word

;
; Now read in the root directory
;
.286
        push    DirSeg                          ; Segment used for transfer = DirSeg
.8086
        call    ReadExtent
        add     sp,2                            ; Clean 1 argument off the stack

;
; Scan for the presence of the I386 directory
; ES points to directory segment
;
        mov     EntryToFind, offset I386DIRNAME
        mov     EntryLen,4
        mov     IsDir,1
        call    ScanForEntry
        jc      EntryNotFound
;
; We found the I386 directory entry, so now get its extent location (offset -31 from filename ID)
; ES:[BX] still points to the directory record for the I386 directory
;
        call    GetExtentInfo

;
; Now read in the I386 directory
;
.286
        push    DirSeg                          ; Segment used for transfer = DirSeg
.8086
        call    ReadExtent
        add     sp,2                            ; Clean 1 argument off the stack

;
; Scan for the presence of the file that we need
; ES points to directory segment
;

        mov     ax, DirSeg
        mov     es, ax
        mov     ax, [bp][8]
        mov     EntryToFind, ax
        mov     al, [bp][6]
        mov     EntryLen, al
        mov     IsDir,0
        call    ScanForEntry
        jc      EntryNotFound
;
; We found the needed file, so now get its extent location (offset -31 from filename ID)
; ES:[BX] still points to the directory record for that code
;
        call    GetExtentInfo

;
; Now, go read the file
;
.286
        push    [bp][4]                         ; Segment used for transfer
.8086
        call    ReadExtent
        add     sp,2                            ; Clean 1 argument off the stack

EntryNotFound:
        pop     bp
        ret

LoadFile endp


OldInt08       DD  ?                            ; Default Int08 vector
TicksCount     dw  24H                          ; two seconds
DiskAddPack    db  16 dup (?)                   ; Disk Address Packet
PartialRead    db  0                            ; Boolean indicating whether or not we are doing a partial read
LOADERNAME     db  "SETUPLDR.BIN"
BOOTFIXNAME    db  "BOOTFIX.BIN"
I386DIRNAME    db  "I386"
DriveNum       db  ?                            ; Drive number used for INT 13h extended reads
ExtentLoc0     dw  ?                            ; Loader LBN - low word
ExtentLoc1     dw  ?                            ; Loader LBN - high word
ExtentLen0     dw  ?                            ; Loader Length - low word
ExtentLen1     dw  ?                            ; Loader Length - high word
Count0         dw  ?                            ; Read Count - low word
Count1         dw  ?                            ; Read Count - high word
Dest           dw  ?                            ; Read Destination segment
Source0        dw  ?                            ; Read Source - word 0 (low word)
Source1        dw  ?                            ; Read Source - word 1
NumBlocks      db  ?                            ; Number of blocks to Read
EntryToFind    dw  ?                            ; Offset of string trying to match in ScanForEntry
EntryLen       db  ?                            ; Length in bytes of entry to match in ScanForEntry
IsDir          db  ?                            ; Boolean indicating whether or not entry to match in ScanForEntry is a directory
ScanIncCount   db  ?                            ; Boolean indicating if we need to add 1 to Count after adjustment in ScanForEntry

    .errnz  ($-ETFSBOOT) GT (EtfsCodeSize - 2)  ; FATAL PROBLEM: boot sector is too large

        org     (EtfsCodeSize - 2)
        db      55h,0aah

BootSectorEnd   label   dword

BootCode        ends


        END     ETFSBOOT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\i386\bootfix.asm ===
;++
;
;Copyright (c) 1995  Microsoft Corporation
;
;Module Name:
;
; bootfix.asm
;
;Abstract:
;
; The code in this "image" is responsible for checking if is appropriate
; for us to boot from CD. We want to boot from CD whenever we don't have
; a valid active partition or when the user pressed CTRL key during the
; boot process.
;
;Author:
;
;    Calin Negreanu (calinn) 25-May-1998
;
;Environment:
;
;    Image has been loaded at 2000:0000 by ETFS boot code.
;    Real mode
;    ISO 9660 El Torito no-emulation CD-ROM Boot support
;    DL = El Torito drive number we booted from
;
;Revision History:
;
;    Calin Negreanu (calinn) 18-Feb-1999
;
;--
        page    ,132
        title   bootfix
        name    bootfix

.8086

CODE SEGMENT
ASSUME  CS:CODE,DS:CODE,SS:NOTHING,ES:NOTHING

ORG  0000H

_BootFix                label       byte

MaxCodeSize             EQU 1024

Part_Active             EQU 0
Part_Type               EQU 4

Data_PartType           EQU 0                   ;address of partition type inside BootData structure

LoadSeg                 EQU 3000H               ;we load MBR here
SectSize                EQU 512
EntriesOnMbr            EQU 4
MbrDataOff              EQU 01BEH
VolbootOrg              EQU 7c00h

JMPFAR  MACRO   DestOfs,DestSeg
        db      0eah
        dw      OFFSET  DestOfs
        dw      DestSeg
        endm

START:

;
; we already have a valid stack set by the original ETFS boot sector
; we only need to set ds and es
;
        push    ds
        push    es
        mov     ax,cs
        mov     ds,ax
        mov     es,ax
;
; read partition table from hdd 80h at LoadSeg:0000
;
        push    es
        mov     ax,LoadSeg
        mov     es,ax
        mov     bx,0000h
        mov     ax,0201h                                            ;read function, one sector
        mov     cx,0001h
        mov     dx,0080h
        int     13h
        jnc     MbrOk

;
; there was an error, boot from CD
;
        pop     es
        jmp     CdBoot

MbrOk:
        pop     es

;
; now it's the time to loop and find the active partition table
;
        push    es

        mov     ax,LoadSeg
        mov     es,ax
        mov     cx,EntriesOnMbr                                     ;number of partitions in partition table
        mov     bp,MbrDataOff                                       ;01beh

LoopActive:
;
; 00 - inactive, 80h active, others-invalid
;
        cmp     BYTE PTR es:[bp].Part_Active,00H
        jl      CheckInactive
        jne     BadMbr
        add     bp,16
        loop    LoopActive

;
; no active partition found. boot from CD
;
        pop     es
        jmp     CdBoot

CheckInactive:
        push    bp
InactiveLoop:
        add     bp,16
        dec     cx
        jz      ActiveFound
        cmp     BYTE PTR es:[bp].Part_Active,00H
        je      InactiveLoop
        pop     bp

BadMbr:
;
; bad mbr was found. boot from CD
;
        pop     es
        jmp     CdBoot

ActiveFound:
        pop     bp
        pop     es

;
; let's see if we can display UI (that is if MsgPressKey is not empty
;
        mov     si, OFFSET MsgPressKey
        lodsb
        mov     UIAllowed, al

        push    si
        mov     si,OFFSET MsgPressKey
        call    PrintMsg
        pop     si

;
; read all available keys from the queue (prevents us from booting from CD when there
; is some garbage there
;
        mov     cx, 80h
FlushQueue:
        mov     ah, 01h
        int     16h
        jz      QueueEmpty
        mov     ah, 00h
        int     16h
        loop    FlushQueue
QueueEmpty:

;
; hook int08
;
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     bx,08h * 4
        mov     ax,es:[bx]
        mov     WORD PTR [OldInt08  ], ax
        mov     ax,es:[bx+2]
        mov     WORD PTR [OldInt08+2], ax
        mov     WORD PTR es:[bx],OFFSET NewInt08
        mov     WORD PTR es:[bx+2],cs
        pop     es
        sti

;
; loop until the delay ticks is 0. Check for a key pressed (if UI), or for CTRL pressed (if no UI)
;
CheckKey:
        cmp     UIAllowed, 0
        je      CheckCTRL
        mov     ah, 01h
        int     16h
        jnz     KeyPressed
CheckCTRL:
        mov     ah,02h
        int     16h
        and     al,00000100b
        jnz     KeyPressed
NotPressed:
        cmp     DotTicks, 0
        jg      AddDot
        push    si
        mov     si,OFFSET MsgDot
        call    PrintMsg
        pop     si
        mov     DotTicks, 18
AddDot:
        cmp     DelayTicks, 0
        jne     CheckKey
        call    UnhookInt08
        jmp     BootFromHD

UnhookInt08:
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     bx,08h * 4
        mov     ax,WORD PTR [OldInt08]
        mov     es:[bx],ax
        mov     ax,WORD PTR [OldInt08+2]
        mov     es:[bx+2],ax
        pop     es
        sti
        ret

KeyPressed:
        call    UnhookInt08
        jmp     CdBoot

BootFromHD:

;
; let's move the mbr code to 0000:7c00 and jump there
;
        mov     ax,LoadSeg
        mov     ds,ax
        xor     ax,ax
        mov     es,ax
        xor     si,si
        mov     di,VolBootOrg
        mov     cx,SectSize
        cld
        rep     movsb

        mov     dl,80h
        JMPFAR  VolbootOrg,0000H

CdBoot:
;
; return to caller code
;
        pop     es
        pop     ds
        retf

NewInt08:
        pushf
        cli
        cmp     WORD PTR cs:[DelayTicks], 0
        je      default08
        dec     WORD PTR cs:[DotTicks]
        dec     WORD PTR cs:[DelayTicks]
default08:
        popf
        push    WORD PTR cs:[OldInt08+2]
        push    WORD PTR cs:[OldInt08]
        retf

;
;EXPECTS DS:SI - MESSAGE ADDR
;
PrintMsg proc    near
        push    ax
        push    bx
        cmp     UIAllowed, 0
        je      PrintMsgEnd
PrintMsgLoop:
        lodsb
        cmp     al,0
        je      PrintMsgEnd
        mov     ah,0eh
        mov     bx,0007h
        int     10h
        jmp     PrintMsgLoop
PrintMsgEnd:
        pop     bx
        pop     ax
        ret
PrintMsg endp


include bootfix.inc                            ; message text

        UIAllowed   db      0
        MsgDot      db      "."
                    db      0
        OldInt08    dd      ?
        DelayTicks  dw      4*18+1              ; 4 seconds
        DotTicks    dw      18

.errnz  ($-_BootFix) GT (MaxCodeSize - 2)    ;FATAL: bootfix code is too large

        org     MaxCodeSize - 2
        db      55h,0aah


CODE ENDS
END  START
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\i386\cs\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Libovolnou klvesou spustte systm z disku CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\i386\es\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Presione cualquier tecla para iniciar desde el CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\i386\br\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Pressione uma tecla para iniciar do CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\i386\fr\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Appuyez sur n'importe quelle touche pour dmarrer du CD-ROM."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\bootcode\etfs\i386\etfsbootwithudf.asm ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
; etfsboot.asm
;
;Abstract:
;
; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If an El
; Torito CD-ROM with no-emulation support is detected, it will then load
; the "image" pointed to in the Boot Catalog.  This "image" is placed at
; the physical address specified in the Boot Catalog (which should be 07C00h).
;
; The code in this "image" is responsible for locating NTLDR, loading the
; first sector of NTLDR into memory at 2000:0000, and branching to it.
;
; There are only two errors possible during execution of this code.
;       1 - NTLDR does not exist
;       2 - BIOS read error
;
; In both cases, a short message is printed, and the user is prompted to
; reboot the system.
;
;
;Author:
;
;    Steve Collins (stevec) 25-Oct-1995
;
;Environment:
;
;    Image has been loaded at 7C0:0000 by BIOS. (or 0000:7C00 to support some broken BIOSes)
;    Real mode
;    ISO 9660 El Torito no-emulation CD-ROM Boot support
;    DL = El Torito drive number we booted from
;
;Revision History:
;
;    Calin Negreanu (calinn) 25-May-1998 - added safety check at the beginning of the code
;                                        - added code for loading and executing BOOTFIX.BIN
;                                        - modified error path
;
;    Tom Jolly    (tomjolly) 09-Apr-2002 - Added UDF support.
;
;                                          Limitations of the UDF support are...
;
;                                          - All structures (FSD, root dir etc) must be within
;                                            the first 128Mb (64k blocks) of the disc. CDIMAGE
;                                            always places metadata at start, so this is fine.
;                                          - Only UDF 1.02 currently supported (no XFE)
;                                          - Minimal checking due to code size requirements.  We
;                                            do checksum the AVDP though which should be good enough
;                                            to be sure we're looking at a UDF disc.
;                                          - Assumes single extent files/directories, which should be
;                                            the case on mastered discs.
;                                          - Assumes directories will fit in memory (i.e. between LoadSeg
;                                            and himem).
;                                          - No embedded files/dirs
;
;                                          How it works in outline
;
;                                          - Look for AVDP at block 256 only
;                                          - Checksum it, locate VDS and scan for Partition Descriptor
;                                            and Logical Volume Descriptor.
;                                          - Extract Root dir FE location from LVD, 
;
;                                          (If anything failed before this point, drops back to ISO code,
;                                           anything after and the boot will fail).
;
;                                          - Scan Root for I386, and I386 for target files.
;--
        page    ,132
        title   boot - NTLDR ETFS loader
        name    etfsboot

EtfsCodeSize    EQU     2048

BootSeg segment at 07c0h        ;31kb
BootSeg ends

DirSeg  segment at 1000h        ;64kb
DirSeg  ends

LoadSeg segment at 2000h        ;128kb
LoadSeg ends

;
; Few FS related constants
;

VrsStartLbn     EQU     10h
UdfAVDPLbn      EQU     100h

UdfDestagAVDP   EQU     0002h
UdfDestagPD     EQU     0005h
UdfDestagLVD    EQU     0006h
UdfDestagFSD    EQU     0100h
UdfDestagFID    EQU     0101h
UdfDestagFE     EQU     0105h
UdfDestagXFE    EQU     010Ah


BootCode        segment                         ;would like to use BootSeg here, but LINK flips its lid
    ASSUME  CS:BootCode,DS:NOTHING,ES:NOTHING,SS:NOTHING

        public  ETFSBOOT
ETFSBOOT proc    far

        cli

        ;WARNING!!! DO NOT CHANGE THE STACK SETUP. BOOTFIX NEEDS THIS TO BE HERE.

        xor     ax,ax                           ; Setup the stack to a known good spot
        mov     ss,ax                           ; Stack is set to 0000:7c00, which is just below this code
        mov     sp,7c00h

        sti

        mov     ax,cs                           ; Set DS to our code segment (should be 07C0h)
        mov     ds,ax
assume DS:BootCode

;
; Save the Drive Number for later use
;
        push    dx
;
; Let's do some safety checks here. We are going to check for three things:
; 1. We are loaded at 07c0:0000 or 0000:7C00
; 2. Boot Drive Number looks good (80h-FFh)
; 3. Our code was completely loaded by the BIOS
;

        call    NextInstr
NextInstr:
.386
        pop     si                              ; Get IP from the stack
        sub     si,OFFSET NextInstr             ; See if we run with ORIGIN 0
        jz      NormalCase                      ; Yes
        cmp     si,7C00h                        ; See if, at least we run with ORIGIN 7C00H
        jne     BootErr$wof1                    ; If not, try to display some message
        mov     ax,cs                           ; If offset is 7C00H, segment should be 0
        cmp     ax,0000h
        jne     BootErr$wof2                    ; If not, try to display some message

        ; We are loaded at 0000:7C00 instead of 07C0:0000. This could mess up
        ; some stuff so we are going to fix it.

        ; hack to execute JMP 07c0:BootOK
        db      0eah
        dw      OFFSET  BootOK
        dw      BootSeg

NormalCase:
        mov     MSG_BAD_BIOS_CODE, '3'
        mov     ax,cs                           ; See if segment is 07C0H
        cmp     ax,07c0h
        jne     BootErr$wnb                     ; If not, try to display some message
.8086

BootOK:

;
; Reset ds in case we needed to change code segment
;
        mov     ax,cs
        mov     ds,ax
;
; OK so far. Let's try to see if drive letter looks good (80h-FFh)
;
        mov     MSG_BAD_BIOS_CODE, '4'
        cmp     dl,80h
        jb      BootErr$wnb

;
; OK so far. Let's try to see if all our code was loaded.
; We look for our signature at the end of the code.
;
        mov     MSG_BAD_BIOS_CODE, '5'
        mov     bx, EtfsCodeSize - 2
        mov     ax, WORD PTR DS:[bx]
        cmp     ax, 0AA55h
        jne     BootErr$wnb

;
; Finally, everything looks good.
;

;
; Save the Drive Number for later use - right now drive number is pushed on the stack
;
        pop     dx
        mov     DriveNum,dl
;
; Look to see if there is UDF on this disc.
;
        call    IsThereUDF
;
; Let's try to load and run BOOTFIX.BIN
;
.386
        push    OFFSET BOOTFIXNAME
        push    11
        push    LoadSeg
        call    LoadFile
        jc      FindSetupLdr

;
; We have BOOTFIX.BIN loaded. We call that code to see if we should boot from CD. If we shouldn't
; we'll not come back here.
;
.286
        pusha
        push    ds
        push    es

;
; BOOTFIX requires:
;   DL = INT 13 drive number we booted from
;
        mov     dl, DriveNum                    ; DL = CD drive number

        ;hack to execute CALL LoadSeg:0000
        db      9Ah
        dw      0000h
        dw      LoadSeg

        pop     es
        pop     ds
        popa

.8086

FindSetupldr:
;
; Scan for the presence of SETUPLDR.BIN
;
.386
        push    OFFSET LOADERNAME
        push    12
        push    LoadSeg
        call    LoadFile
        jc      BootErr$bnf

;
; SETUPLDR requires:
;   DL = INT 13 drive number we booted from
;
        mov     dl, DriveNum                    ; DL = CD drive number
        xor     ax,ax
.386
        push    LoadSeg
        push    ax
        retf                                    ; "return" to NTLDR (LoadSeg:0000h). Will not come back here.

ETFSBOOT endp

;
; BootErr - print error message and hang the system.
;
BootErr proc
BootErr$wof1:                                   ; we were loaded at a wrong address - Code 1
        PUSH    SI
        MOV     BX, SI
        ADD     BX, OFFSET MSG_BAD_BIOS_CODE
        MOV     BYTE PTR DS:[BX], '1'
        ADD     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$wof2:                                   ; we were loaded at a wrong address - Code 2
        PUSH    SI
        MOV     BX, SI
        ADD     BX, OFFSET MSG_BAD_BIOS_CODE
        MOV     BYTE PTR DS:[BX], '2'
        ADD     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$wnb:                                    ; some other BIOS problem
        PUSH    0
        MOV     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$bnf:                                    ; NTLDR not found
        PUSH    0
        MOV     SI, OFFSET MSG_NO_NTLDR
        JMP     BootErr2
BootErr$mof:                                    ; memory overflow
        PUSH    0
        MOV     SI, OFFSET MSG_MEM_OVERFLOW
        JMP     BootErr2
BootErr2:
        CALL    BootErrPrint
        POP     SI
        JMP     BootFromHD
BootErrPrint:

        LODSB                                   ; Get next character
        OR      AL, AL
        JZ      BEdone

        MOV     AH, 14                          ; Write teletype
        MOV     BX, 7                           ; Attribute
        INT     10H                             ; Print it
        JMP     BootErrPrint
BEdone:
        RET

;print:                                   ; print char in AL
; push    bx
; push    es
; MOV     AH, 14                          ; Write teletype
; MOV     BX, 7                           ; Attribute
; INT     10H                             ; Print it
; pop     es
; pop     bx
; ret

BootErr endp

;
; we are trying to boot from HD. We need to move ourself out of
; this area because we are going to load MBR here
;
BootFromHD:

;
; let's wait here for two seconds, so the user gets a chance to see the message
;

;
; hook INT08
;
        MOV     [SI+TicksCount], 24H                 ; two seconds delay
        CLI
        PUSH    ES
        XOR     AX, AX
        MOV     ES, AX
        MOV     BX, 0020H
        MOV     AX, ES:[BX]
        MOV     WORD PTR [SI+OldInt08], AX
        MOV     AX, ES:[BX+2]
        MOV     WORD PTR [SI+OldInt08+2], AX
        MOV     ES:[BX], SI
        ADD     ES:[BX], OFFSET NewInt08
        MOV     ES:[BX+2], CS
        POP     ES
        STI
;
; now let's actively wait for TicksCount to become zero
;
Delay:
        CMP     [SI+TicksCount], 0
        JNE     Delay
;
; unhook INT08
;
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     bx,08h * 4
        mov     ax,WORD PTR [SI+OldInt08]
        mov     es:[bx],ax
        mov     ax,WORD PTR [SI+OldInt08+2]
        mov     es:[bx+2],ax
        pop     es
        sti
;
; now let's move ourselves away from here because we are going to load MBR here
;
MoveCode:
        push    ds
        push    es
        mov     ax, LoadSeg
        mov     es, ax
        mov     ax, cs
        mov     ds, ax
        ;si is already set
        xor     di, di
        mov     cx, EtfsCodeSize
        rep     movsb
        pop     es
        pop     ds

        ;hack to execute JMP LoadSeg:AfterMoveLabel
        db      0eah
        dw      OFFSET  AfterMoveLabel
        dw      LoadSeg

AfterMoveLabel:
;
; finally load MBR
;
        push    es
        mov     ax, BootSeg
        mov     es, ax
        mov     bx, 0000h
        mov     ax, 0201h                                           ;read function, one sector
        mov     cx, 0001h
        mov     dx, 0080h
        int     13h
        jnc     MbrOk
;
; there was an error, nothing else to do
;
        jmp     $
MbrOk:
        pop     es
;
; now let's return into MBR code
;
        mov     dl,80h
        ;hack to execute JMP 0000:7C00
        db      0eah
        dw      7c00h
        dw      0000h

;
; We rely on the fact that SI is not changed when this INT occurs
; This is a pretty good assumption since this code is active only
; within the tight loop near Delay label. The odds are that some
; other IRQ occures, enables interrupts, changes SI and then INT08
; occures. This should not happen.
;
NewInt08:
        PUSHF
        CLI
        CMP     CS:[SI+TicksCount], 0
        JE      Default08
        DEC     WORD PTR CS:[SI+TicksCount]
Default08:
        POPF
        PUSH    WORD PTR CS:[SI+OldInt08+2]
        PUSH    WORD PTR CS:[SI+OldInt08]
        RETF

include etfsboot.inc                            ; message text

;
; ScanForEntry - Scan for an entry in a directory
;
; Entry:
;     ES:0 points to the beginning of the directory to search
;     Directory length in bytes is in ExtentLen1 and Extend_Len_0
;
; Exit:
;     CF set on error, clear on success.
;     ES:BX points to record containing entry if match is found
;
ScanForEntry proc near
        mov     ScanIncCount, 0
        mov     cx,ExtentLen0                   ; CX = length of root directory in bytes (low word only)
        cld                                     ; Work up for string compares
        xor     bx,bx
        xor     dx,dx
ScanLoop:
        mov     si, EntryToFind
        mov     dl,byte ptr es:[bx]             ; directory record length -> DL
        cmp     dl,0
        jz      Skip00                          ; if the "record length" assume it is "system use" and skip it
        mov     ax,bx
        add     ax,021h                         ; file identifier is at offset 21h in directory record
        mov     di,ax                           ; ES:DI now points to file identifier
        push    cx
        xor     cx,cx
        mov     cl,EntryLen                     ; compare bytes
        repe    cmpsb
        pop     cx
        jz      ScanEnd                         ; do we have a match?

CheckCountUnderFlow:
        ; If CX is about to underflow or be 0 we need to reset CX, ES and BX if ExtentLen1 is non-0
        cmp     dx,cx
        jae     ResetCount0

        sub     cx,dx                           ; update CX to contain number of bytes left in directory
        cmp     ScanIncCount, 1
        je      ScanAdd1ToCount

AdjustScanPtr:                                  ; Adjust ES:BX to point to next record
        add     dx,bx
        mov     bx,dx
        and     bx,0fh
        push    cx
   