        reasons.

--*/
LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD      dwPermanentProviderID,
    PDWORD     pdwNumLines,
    PDWORD     pdwNumPhones,
    HPROVIDER  hProvider,
    LINEEVENT  pfnLineCreateProc,
    PHONEEVENT pfnPhoneCreateProc
    )
{
    UNREFERENCED_PARAMETER(pdwNumPhones);           // no phone support
    UNREFERENCED_PARAMETER(pfnPhoneCreateProc);     // no dynamic phones
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // legacy parameter
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerEnumDevices - Entered." ));

    // save provider handle
    g_hProvider = hProvider;
    	
    // save line create tapi callback
    g_pfnLineEventProc = pfnLineCreateProc;
    _ASSERTE(g_pfnLineEventProc);

    H323DBG(( DEBUG_LEVEL_VERBOSE, "service provider supports 1 line."));

    // report number of interfaces
    *pdwNumLines = 1;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerEnumdevices - Exited." ));

    // success
    return NOERROR;
}


static LONG H323Initialize (
	IN	DWORD	LineDeviceIDBase)
{
    WSADATA wsaData;
    WORD wVersionRequested = H323_WINSOCKVERSION;

    HRESULT		hr;

    H323DBG(( DEBUG_LEVEL_TRACE, "H323Initialize - Entered." ));
    
    // initialize winsock stack
    WSAStartup(wVersionRequested, &wsaData);

    if (!g_pH323Line -> Initialize (LineDeviceIDBase))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "init failed for h323 line." ));
        return ERROR_GEN_FAILURE;
    }

	RegistryStart();

    g_hCanUnloadDll = H323CreateEvent( NULL, TRUE, TRUE, 
        _T( "H323TSP_DLLUnloadEvent" ) );

    if( g_hCanUnloadDll == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not create unloadDLL handle." ));
        return ERROR_GEN_FAILURE;
    }

#if	H323_USE_PRIVATE_IO_THREAD

	hr = H323IoThreadStart();
	if (hr != S_OK)
		return ERROR_GEN_FAILURE;

#endif

    H323DBG(( DEBUG_LEVEL_TRACE, "H323Initialize - Exited." ));

    return ERROR_SUCCESS;
}


void ReportTSPEvent( 
    LPCTSTR wszErrorMessage )
{
    if( g_hEventLogSource )
    {
        ReportEvent(
			    g_hEventLogSource,	// handle of event source
			    EVENTLOG_ERROR_TYPE,// event type
			    0,					// event category
			    0x80000001,			// event ID
			    NULL,				// user SID
			    1,		            // string count
			    0,					// no bytes of raw data
			    &wszErrorMessage,	// array of error strings
			    NULL);				// no raw data
    }
}


static 
VOID H323Shutdown (void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "H323Shutdown entered" ));
    
    g_pH323Line -> Shutdown();

	RegistryStop();

    if( g_hCanUnloadDll != NULL )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, "waiting for i/o refcount to get 0..." ));

        //wait until all the calls have been deleted
        WaitForSingleObject( 
            g_hCanUnloadDll, 
            300 * 1000        // Wait for 5 minutes to let everything shutdown.
            );

        H323DBG ((DEBUG_LEVEL_WARNING, "i/o refcount is 0..."));

        CloseHandle( g_hCanUnloadDll );
        g_hCanUnloadDll = NULL;

        //sleep for 500 ms
        Sleep( 500 );
    }

#if	H323_USE_PRIVATE_IO_THREAD

	H323IoThreadStop();

#endif

    if( g_hEventLogSource  )
    {
		DeregisterEventSource( g_hEventLogSource  );
		g_hEventLogSource = NULL;
	}

    // shutdown
    WSACleanup();
            
    H323DBG(( DEBUG_LEVEL_TRACE, "H323Shutdown exited" ));
}


/*++

Routine Description:

    Initializes the service provider, also giving it parameters required for
    subsequent operation.

    This function is guaranteed to be called before any of the other functions
    prefixed with TSPI_line or TSPI_phone except TSPI_lineNegotiateTSPIVersion.
    It is strictly paired with a subsequent call to TSPI_providerShutdown. It
    is the caller's reponsibility to ensure proper pairing.

    Note that a service provider should perform as many consistency checks as
    is practical at the time TSPI_providerInit is called to ensure that it is
    ready to run. Some consistency or installation errors, however, may not be
    detectable until the operation is attempted. The error LINEERR_NODRIVER can
    be used to report such non-specific errors at the time they are detected.

    There is no directly corresponding function at the TAPI level. At that
    level, multiple different usage instances can be outstanding, with an
    "application handle" returned to identify the instance in subsequent
    operations. At the TSPI level, the interface architecture supports only a
    single usage instance for each distinct service provider.

    A new parameter, lpdwTSPIOptions, is added to this function. This parameter
    allows the service provider to return bits indicating optional behaviors
    desired of TAPI. TAPI sets the options DWORD to 0 before calling
    TSPI_providerInit, so if the service provider doesn't want any of these
    options, it can just leave the DWORD set to 0.

    At this time, only one bit is defined to be returned through this pointer:
    LINETSPIOPTION_NONREENTRANT. The service provider sets this bit if it is
    not designed for fully pre-emptive, multithreaded, multitasking,
    multiprocessor operation (e.g., updating of global data protected by
    mutexes). When this bit is set, TAPI will only make one call at a time to
    the service provider; it will not call any other entry point, nor that
    entry point again, until the service provider returns from the original
    function call. Without this bit set, TAPI may call into multiple service
    provider entry points, including multiple times to the same entry point,
    simultaneously (actually simultaneously in a multiprocessor system). Note:
    TAPI will not serialize access to TSPI functions that display a dialog
    (TUISPI_lineConfigDialog, TUISPI_lineConfigDialogEdit,
    TUISPI_phoneConfigDialog, TUISPI_providerConfig, TUISPI_providerInstall,
    TUISPI_providerRemove) so that they do not block other TSPI functions
    from being called; the service provider must include internal protection
    on these functions.

Arguments:

    dwTSPIVersion - Specifies the version of the TSPI definition under which
        this function must operate. The caller may use
        TSPI_lineNegotiateTSPIVersion with the special dwDeviceID
        INITIALIZE_NEGOTIATION to negotiate a version that is guaranteed to be
        acceptible to the service provider.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        initialized.

    dwLineDeviceIDBase - Specifies the lowest device ID for the line devices
        supported by this service provider.

    dwPhoneDeviceIDBase - Specifies the lowest device ID for the phone devices
        supported by this service provider.

    dwNumLines - Specifies how many line devices this service provider
        supports.

    dwNumPhones - Specifies how many line devices this service provider
        supports.

    pfnCompletionProc - Specifies the procedure the service provider calls to
        report completion of all asynchronously operating procedures on line
        and phone devices.

    pdwTSPIOptions - A pointer to a DWORD-sized memory location, into which
        the service provider may write a value specifying LINETSPIOPTIONS_
        values.

Return Values:

    Returns zero if the function is successful, or a negative error number if
    an error has occurred. Possible return values are as follows:

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot be
            supported by the Telephony API implementation and/or corresponding
            service provider.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

        LINEERR_RESOURCEUNAVAIL - Insufficient resources to complete the
            operation.

--*/


LONG
TSPIAPI
TSPI_providerInit(
    DWORD            dwTSPIVersion,
    DWORD            dwPermanentProviderID,
    DWORD            dwLineDeviceIDBase,
    DWORD            dwPhoneDeviceIDBase,
    DWORD_PTR        dwNumLines,
    DWORD_PTR        dwNumPhones,
    ASYNC_COMPLETION pfnCompletionProc,
    LPDWORD          pdwTSPIOptions
    )
{
	LONG	dwStatus;

	UNREFERENCED_PARAMETER (dwNumLines);             // legacy parameter
	UNREFERENCED_PARAMETER (dwNumPhones);            // legacy parameter
	UNREFERENCED_PARAMETER (dwPhoneDeviceIDBase);    // no phone support
	UNREFERENCED_PARAMETER (pdwTSPIOptions);         // already thread-safe

#if DBG
    // Register for trace output.
    TRACELogRegister(_T("h323tsp"));
#else
    OpenLogFile();
#endif

    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion)) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "provider init::incompatible tspi version." ));

        // incompatible api version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    dwStatus = H323Initialize (dwLineDeviceIDBase);

    if (dwStatus == ERROR_SUCCESS)
    {
	    // save global service provider info

	    // we don't store dwTSPIVersion, because our behavior does not change based
	    // on any negotiated version.
	    // if this changes in the future, then we will record the negotiated version.

	    g_pfnCompletionProc = pfnCompletionProc;
        _ASSERTE( g_pfnCompletionProc );

	    g_dwLineDeviceIDBase    = dwLineDeviceIDBase;
	    g_dwPermanentProviderID = dwPermanentProviderID;
    }
    else
    {
	    H323Shutdown();
    }
    
    return dwStatus;
}



LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD dwTSPIVersion,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    Shuts down the service provider. The service provider should terminate
    any activities it has in progress and release any resources it has
    allocated.

Arguments:

    dwTSPIVersion - Specifies the version of the TSPI definition under which
        this function must operate. The caller may use
        TSPI_lineNegotiateTSPIVersion or TSPI_phoneNegotiateTSPIVersion with
        the special dwDeviceID INITIALIZE_NEGOTIATION to negotiate a version
        that is guaranteed to be acceptible to the service provider.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        shut down.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot be
            supported by the Telephony API implementation and/or corresponding
            service provider.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // legacy parameter

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerShutdown - Entered." ));
    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "invalid tspi version." ));

        // failure
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

	H323Shutdown();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerShutdown - Exited." ));
	return ERROR_SUCCESS;
}



LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )

/*++

Routine Description:

    The TSPI_providerInstall function is obsolete. TAPI version 1.4
    or earlier service providers can implement this TSPI function.
    TAPI version 2.0 or later TSPs implement TUISPI_providerInstall.

Arguments:

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Always returns NOERROR.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerRemove(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )

/*++

Routine Description:

    The TSPI_providerRemove function is obsolete. TAPI version 1.4 or
    earlier service providers can implement this TSPI function. TAPI
    version 2.0 or later TSPs implement TUISPI_providerRemove.

Arguments:

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Always returns NOERROR.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineTSPIProviderRemove - Entered." ));
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineTSPIProviderRemove - Exited." ));
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR pwszUIDLLName
   )

/*++

Routine Description:

    The TSPI_providerUIIdentify function extracts from the service
    provider the fully qualified path to load the service provider's
    UI DLL component.

    Implementation is mandatory if the service provider implements
    any UI DLL functions.

Arguments:

    pwszUIDLLName - Pointer to a block of memory at least MAX_PATH
        in length, into which the service provider must copy a NULL-
        terminated string specifying the fully-qualified path for the
        DLL containing the service provider functions which must execute
        in the process of the calling application.

Return Values:

    Always returns NOERROR.

--*/

{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_ProviderUIIdentify - Entered." ));
    
    // copy name of our dll as ui dll
    lstrcpyW(pwszUIDLLName,H323_UIDLL);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_ProviderUIIdentify - Exited." ));

    // success
    return NOERROR;
}


/*++

Routine Description:

    Implementation of the TUISPI_providerInstall function is the
    service provider's opportunity to install any additional
    "pieces" of the provider into the right directories (or at
    least verifying that they're there) and set up registry entries
    the provider needs.

Arguments:

    pfnUIDLLCallback - Pointer to a function the UI DLL can call to
        communicate with the service provider DLL to obtain information
        needed to display the dialog box.

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        installation.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_NOMULTIPLEINSTANCE - A telephony service provider which
            does not support multiple instances is listed more than once
            in the [Providers] section in the registry. The application

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )
{
    HKEY hKey;
    HKEY hKeyTSP;
    LONG lStatus;
    LPTSTR pszKey;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerInstall - Entered." ));
    
    // check for previous instance
    if (H323IsTSPAlreadyInstalled())
    {
        // cannot be installed twice
        return LINEERR_NOMULTIPLEINSTANCE;
    }

    // set key to h323
    pszKey = H323_REGKEY_ROOT;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if( lStatus == NOERROR )
    {
        H323DBG((DEBUG_LEVEL_TRACE, 
            "successfully installed H.323 provider." ));

        // release handle
        RegCloseKey(hKey);
    
        H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerInstall - Exited." ));
        
        // success
        return NOERROR;
    }

    // set key to windows
    pszKey = REGSTR_PATH_WINDOWS_CURRENTVERSION;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_WRITE,
                &hKey
                );

    // validate status
    if( lStatus != NOERROR )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx opening windows registry key.", lStatus ));

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    // attempt to create key
    lStatus = RegCreateKey(
                hKey,
                H323_SUBKEY,
                &hKeyTSP
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx creating tsp registry key.", lStatus ));

        // release handle
        RegCloseKey(hKey);

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "successfully installed H.323 provider." ));

    // release handle
    RegCloseKey(hKeyTSP);

    // release handle
    RegCloseKey(hKey);
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerInstall - Exited." ));
    // success
    return NOERROR;
}


LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND hwndOwner,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    The TUISPI_providerRemove function asks the user to confirm
    elimination of the service provider.

    It is the responsibility of the service provider to remove any
    registry entries that the service provider added at addProvider
    time, as well as any other modules and files that are no longer
    needed.

Arguments:

    pfnUIDLLCallback - Pointer to a function the UI DLL can call to
        communicate with the service provider DLL to obtain information
        needed to display the dialog box.

    hwndOwner - The handle of the parent window in which the function
        can create any dialog box windows that are required during
        removal.

    dwPermanentProviderID - The service provider's permanent provider
        identifier.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    HKEY hKey;
    LONG lStatus;
    LPTSTR pszKey;

    UNREFERENCED_PARAMETER(pfnUIDLLCallback);
    UNREFERENCED_PARAMETER(hwndOwner);
    UNREFERENCED_PARAMETER(dwPermanentProviderID);

    // set key to h323
    pszKey = H323_REGKEY_ROOT;

    H323DBG(( DEBUG_LEVEL_FORCE, "TUISPI_providerRemove - Entered." ));
    
    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG ((DEBUG_LEVEL_TRACE, "successfully removed H.323 provider."));
        H323DBG ((DEBUG_LEVEL_TRACE, "TUISPI_providerRemove - Exited."));

        // success
        return NOERROR;
    }

    // release handle
    RegCloseKey(hKey);

    // set key to windows
    pszKey = REGSTR_PATH_WINDOWS_CURRENTVERSION;

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_WRITE,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx opening windows registry key.", lStatus ));

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    // attempt to delete key
    lStatus = RegDeleteKey(
                hKey,
                H323_SUBKEY
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "error 0x%08lx deleting tsp registry key.", lStatus ));

        // release handle
        RegCloseKey(hKey);

        // operation failed
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG(( DEBUG_LEVEL_FORCE, "successfully removed H.323 provider." ));

    // release handle
    RegCloseKey(hKey);
    H323DBG(( DEBUG_LEVEL_TRACE, "TUISPI_providerRemove - Exited." ));
    
    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\ras.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ras.cpp

Abstract:

    The RAS client functionality (Transport/session mangement)

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "ras.h"



#define OID_ELEMENT_LAST(Value) { NULL, Value }

#define OID_ELEMENT(Index,Value) { (ASN1objectidentifier_s *) &_OID_H225ProtocolIdentifierV1 [Index], Value },

// this stores an unrolled constant linked list
const ASN1objectidentifier_s    _OID_H225ProtocolIdentifierV1 [] = {
    OID_ELEMENT (1, 0)          // 0 = ITU-T
    OID_ELEMENT (2, 0)          // 0 = Recommendation
    OID_ELEMENT (3, 8)          // 8 = H Series
    OID_ELEMENT (4, 2250)       // 2250 = H.225.0
    OID_ELEMENT (5, 0)          // 0 = Version
    OID_ELEMENT_LAST (1)        // 1 = V1
};

#undef  OID_ELEMENT



#define OID_ELEMENT(Index,Value) { (ASN1objectidentifier_s *) &_OID_H225ProtocolIdentifierV2 [Index], Value },

// this stores an unrolled constant linked list
const ASN1objectidentifier_s    _OID_H225ProtocolIdentifierV2 [] = {
    OID_ELEMENT (1, 0)          // 0 = ITU-T
    OID_ELEMENT (2, 0)          // 0 = Recommendation
    OID_ELEMENT (3, 8)          // 8 = H Series
    OID_ELEMENT (4, 2250)       // 2250 = H.225.0
    OID_ELEMENT (5, 0)          // 0 = Version
    OID_ELEMENT_LAST (2)        // 2 = V2
};


RAS_CLIENT      g_RasClient;
static LONG     RasSequenceNumber;


PH323_ALIASNAMES 
RASGetRegisteredAliasList()
{
    return g_RasClient.GetRegisteredAliasList();
}

HRESULT RasStart (void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStart - entered." ));

    if( (g_RegistrySettings.saGKAddr.sin_addr.s_addr == NULL) ||
        (g_RegistrySettings.saGKAddr.sin_addr.s_addr == INADDR_NONE )
      )
    {
        return E_FAIL;
    }

    if (g_RegistrySettings.fIsGKEnabled)
    {
        if( !g_RasClient.Initialize (&g_RegistrySettings.saGKAddr) )
            return E_OUTOFMEMORY;
        //send the rrq message
        if( !g_RasClient.SendRRQ( NOT_RESEND_SEQ_NUM, NULL ) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "couldn't send rrq." ));
            //m_RegisterState = RAS_REGISTER_STATE_IDLE;
            return E_FAIL;
        }
    }
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStart - exited." ));
    return S_OK;
}

void RasStop (void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStop - entered." ));
    
    DWORD dwState = g_RasClient.GetRegState();

    if( (dwState==RAS_REGISTER_STATE_REGISTERED) ||
        (dwState==RAS_REGISTER_STATE_RRQSENT) )
    {
        //send urq
        g_RasClient.SendURQ( NOT_RESEND_SEQ_NUM, NULL );
    }
    
    g_RasClient.Shutdown();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "RasStop - exited." ));
}

BOOL RasIsRegistered (void)
{
    return g_RasClient.GetRegState() == RAS_REGISTER_STATE_REGISTERED;
}

HRESULT RasGetLocalAddress (
    OUT SOCKADDR_IN *   ReturnLocalAddress)
{
    return g_RasClient.GetLocalAddress (ReturnLocalAddress);
}

USHORT RasAllocSequenceNumber (void)
{
    USHORT  SequenceNumber;

    H323DBG(( DEBUG_LEVEL_TRACE, "RasAllocSequenceNumber - entered." ));
    
    do
    {
        SequenceNumber = (USHORT) InterlockedIncrement (&RasSequenceNumber);
    } while( SequenceNumber == 0 );

    H323DBG(( DEBUG_LEVEL_TRACE, "RasAllocSequenceNumber - exited." ));
    
    return SequenceNumber;
}


HRESULT RasEncodeSendMessage (
    IN  RasMessage * pRasMessage)
{
    return g_RasClient.IssueSend( pRasMessage ) ? S_OK : E_FAIL;
}


HRESULT RasGetEndpointID (
    OUT EndpointIdentifier *    ReturnEndpointID)
{
    return g_RasClient.GetEndpointID (ReturnEndpointID);
}


void RasHandleRegistryChange()
{
    g_RasClient.HandleRegistryChange();
}


RAS_CLIENT::RAS_CLIENT()
{
    //create the timer queue
    m_hRegTimer = NULL;
    m_hRegTTLTimer = NULL;
    m_hUnRegTimer = NULL;
    m_RegisterState = RAS_REGISTER_STATE_IDLE;
    m_IoRefCount = 0;
    m_dwState = RAS_CLIENT_STATE_NONE;
    m_pAliasList = NULL;
    m_Socket = INVALID_SOCKET;
    InitializeListHead( &m_sendPendingList );
    InitializeListHead( &m_sendFreeList );
    InitializeListHead( &m_aliasChangeRequestList );
    m_dwSendFreeLen = 0;
    m_lastRegisterSeqNum = 0;
    m_wTTLSeqNumber = 0;
    m_UnRegisterSeqNum = 0;
    m_wRASSeqNum = 0;
    m_dwRegRetryCount = 0;
    m_dwUnRegRetryCount = 0;
    m_dwCallsInProgress = 0;
    m_dwRegTimeToLive = 0;
    m_pRRQExpireContext = NULL;
    m_pURQExpireContext = NULL;

    ZeroMemory( (PVOID)&m_GKAddress, sizeof(SOCKADDR_IN) );
    ZeroMemory( (PVOID)&m_ASNCoderInfo, sizeof(ASN1_CODER_INFO) );
    ZeroMemory( (PVOID)&m_PendingURQ, sizeof(PENDINGURQ) );
    ZeroMemory( (PVOID)&m_RASEndpointID, sizeof(ENDPOINT_ID) );

    // No need to check the result of this one since this object is
    // not allocated on heap, right when the DLL is loaded.
    InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );
}


RAS_CLIENT::~RAS_CLIENT (void)
{
    //free the various lists
    FreeSendList( &m_sendFreeList );
    FreeSendList( &m_sendPendingList );
    FreeSendList( &m_aliasChangeRequestList );

    DeleteCriticalSection( &m_CriticalSection );
}


HRESULT 
RAS_CLIENT::GetEndpointID(
    OUT EndpointIdentifier * ReturnEndpointID )
{
    HRESULT hr;

    H323DBG(( DEBUG_LEVEL_TRACE, "GetEndpointID - entered." ));
    Lock();

    if (m_RegisterState == RAS_REGISTER_STATE_REGISTERED)
    {
        ReturnEndpointID->length = m_RASEndpointID.length;
        
        //m_RASEndpointID.value is an array and not a pointer. 
        //so explicit assignment of each field is required
        ReturnEndpointID->value = m_RASEndpointID.value;
        hr = S_OK;
    }
    else
    {
        hr = S_OK;
    }

    Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "GetEndpointID - exited." ));
    return hr;
}


//the addr and port are in network byte order
BOOL
RAS_CLIENT::Initialize(
    IN SOCKADDR_IN* psaGKAddr
    )
{
    DWORD   dwSize;
    int     rc;

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Initialize entered:%p.",this ));
    //set the m_GKAddress here

    dwSize = sizeof m_RASEndpointID.value;
    GetComputerNameW( m_RASEndpointID.value, &dwSize );
    m_RASEndpointID.length = (WORD)wcslen(m_RASEndpointID.value);

    m_pAliasList = new H323_ALIASNAMES;
    if( m_pAliasList == NULL )
    {
        goto error2;
    }
    
    ZeroMemory( (PVOID)m_pAliasList, sizeof(H323_ALIASNAMES) );

    if( g_RegistrySettings.fIsGKLogOnPhoneEnabled )
    {
        if(!AddAliasItem( m_pAliasList,
              g_RegistrySettings.wszGKLogOnPhone,
              e164_chosen ))
        {
           goto error3;
        }
    }
    
    if( g_RegistrySettings.fIsGKLogOnAccountEnabled )
    {
        if(!AddAliasItem( m_pAliasList,
              g_RegistrySettings.wszGKLogOnAccount,
              h323_ID_chosen ))
        {
           goto error3;
        }
    }

    if( m_pAliasList->wCount == 0 )
    {
        //add the machine name as he default alias
        if(!AddAliasItem( m_pAliasList,
                  m_RASEndpointID.value,
                  h323_ID_chosen ))
        {
            goto error3;
        }
    }

    rc = InitASNCoder();

    if( rc != ASN1_SUCCESS )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "RAS_InitCoder() returned: %d ", rc));
        goto error3;
    }

    m_GKAddress = *psaGKAddr;

    if(!InitializeIo() )
    {
        goto error4;
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "GK addr:%lx.", m_GKAddress.sin_addr.s_addr ));
    m_dwState = RAS_CLIENT_STATE_INITIALIZED;
    m_RegisterState = RAS_REGISTER_STATE_IDLE;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Initialize exited:%p.",this ));
    return TRUE;

error4:
    TermASNCoder();
error3:
    FreeAliasNames( m_pAliasList );
    m_pAliasList = NULL;
error2:
    return FALSE;

}

    
void 
RAS_CLIENT::Shutdown(void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Shutdown entered:%p.",this ));

    Lock();

    switch (m_dwState)
    {
    case RAS_CLIENT_STATE_NONE:
        // nothing to do
        break;

    case RAS_CLIENT_STATE_INITIALIZED:

        if( m_Socket != INVALID_SOCKET )
        {
            closesocket(m_Socket);
            m_Socket = INVALID_SOCKET;
        }

        //free alias list
        FreeAliasNames( m_pAliasList );
        m_pAliasList = NULL;

        TermASNCoder();
    
        m_dwState = RAS_CLIENT_STATE_NONE;

        //delete if any timers
        if( m_hRegTTLTimer )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
            m_hRegTTLTimer = NULL;
        }

        if( m_hUnRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL );
            m_hUnRegTimer = NULL;
            m_dwUnRegRetryCount = 0;
        }

        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL );
            m_hRegTimer = NULL;
        }

        if( m_pRRQExpireContext != NULL )
        {
            delete m_pRRQExpireContext;
            m_pRRQExpireContext = NULL;
        }

        if( m_pURQExpireContext != NULL )
        {
            delete m_pURQExpireContext;
            m_pURQExpireContext = NULL;
        }
        
        m_RegisterState = RAS_REGISTER_STATE_IDLE;
        m_dwSendFreeLen = 0;
        m_dwRegRetryCount = 0;
        m_dwUnRegRetryCount = 0;
        m_dwCallsInProgress = 0;
        m_lastRegisterSeqNum = 0;
        m_wTTLSeqNumber = 0;
        m_UnRegisterSeqNum = 0;
        m_wRASSeqNum = 0;
        m_dwRegTimeToLive = 0;
        ZeroMemory( (PVOID)&m_GKAddress, sizeof(SOCKADDR_IN) );
        ZeroMemory( (PVOID)&m_ASNCoderInfo, sizeof(ASN1_CODER_INFO) );
        ZeroMemory( (PVOID)&m_PendingURQ, sizeof(PENDINGURQ) );
        ZeroMemory( (PVOID)&m_RASEndpointID, sizeof(ENDPOINT_ID) );
    
        break;

    default:
        _ASSERTE(FALSE);
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS Shutdown exited:%p.",this ));
}


BOOL
RAS_CLIENT::FreeSendList(
                        PLIST_ENTRY pListHead
                        )
{
    PLIST_ENTRY         pLE;
    RAS_SEND_CONTEXT *  pSendContext;

    H323DBG(( DEBUG_LEVEL_ERROR, "FreeSendList entered." ));

    // process list until empty
    while( IsListEmpty(pListHead) == FALSE )
    {
        // retrieve first entry
        pLE = RemoveHeadList(pListHead);

        // convert list entry to structure pointer
        pSendContext = CONTAINING_RECORD( pLE, RAS_SEND_CONTEXT, ListEntry );
        
        //  release memory
        if( pSendContext != NULL )
        {
            delete pSendContext;
            pSendContext = NULL;
        }
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "FreeSendList exited:%p.", this ));
    // success
    return TRUE;
}

//!!always called from a lock
RAS_SEND_CONTEXT *
RAS_CLIENT::AllocSendBuffer(void)
{
    RAS_SEND_CONTEXT *pSendBuf;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "AllocSendBuffer entered:%p.",this ));
    
    if( m_dwSendFreeLen )
    {
        m_dwSendFreeLen--;
        _ASSERTE( IsListEmpty(&m_sendFreeList) == FALSE );

        LIST_ENTRY *pLE = RemoveHeadList( &m_sendFreeList );
        pSendBuf = CONTAINING_RECORD( pLE, RAS_SEND_CONTEXT, ListEntry );

    }
    else
    {
        pSendBuf = (RAS_SEND_CONTEXT*)new RAS_SEND_CONTEXT;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "AllocSendBuffer exited:%p.",this ));
    return pSendBuf;
}


//!!always called from a lock
void 
RAS_CLIENT::FreeSendBuffer(
                           IN RAS_SEND_CONTEXT * pBuffer
                          )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeSendBuffer entered:%p.",this ));

    if(m_dwSendFreeLen < RASIO_SEND_BUFFER_LIST_MAX )
    {
        m_dwSendFreeLen++;
        InsertHeadList( &m_sendFreeList, &pBuffer->ListEntry );
    }
    else
    {
        delete pBuffer;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeSendBuffer exited:%p.",this ));
}

    
//RAS client functions
void
NTAPI RAS_CLIENT::RegExpiredCallback ( 
    IN  PVOID       ContextParameter,       // ExpContext
    IN  BOOLEAN     TimerFired)             // not used
{
    EXPIRE_CONTEXT *    pExpireContext;
    RAS_CLIENT *        This;

    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpiredCallback - entered." ));
    
    _ASSERTE( ContextParameter );
    pExpireContext = (EXPIRE_CONTEXT *)ContextParameter;
    _ASSERTE( m_pRRQExpireContext == pExpireContext );

    _ASSERTE(pExpireContext -> RasClient);
    This = (RAS_CLIENT *) pExpireContext -> RasClient;

    This -> RegExpired (pExpireContext -> seqNumber);

    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpiredCallback - exited." ));
    delete pExpireContext;
}


void
NTAPI RAS_CLIENT::UnregExpiredCallback(
    IN  PVOID       ContextParameter,       // ExpContext
    IN  BOOLEAN     TimerFired)             // not used
{
    EXPIRE_CONTEXT *    pExpireContext;
    RAS_CLIENT *        This;

    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpiredCallback - entered." ));
    
    _ASSERTE(ContextParameter);
    pExpireContext = (EXPIRE_CONTEXT *) ContextParameter;
    _ASSERTE( m_pURQExpireContext == pExpireContext );

    _ASSERTE( pExpireContext -> RasClient );
    This = (RAS_CLIENT *) pExpireContext -> RasClient;

    This -> UnregExpired( pExpireContext -> seqNumber );

    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpiredCallback - exited." ));
    delete pExpireContext;
}


void
NTAPI RAS_CLIENT::TTLExpiredCallback(
    IN  PVOID       ContextParameter,       // ExpContext
    IN  BOOLEAN     TimerFired)             // not used
{
    RAS_CLIENT *        This;

    _ASSERTE(ContextParameter);

    This = (RAS_CLIENT*)ContextParameter;
     
    _ASSERTE(This == &g_RasClient);
    This -> TTLExpired();
}


//If we have already sent RRQ to this GK then this RRQ is supposed to rplace 
//the original alias list with the new list
BOOL
RAS_CLIENT::SendRRQ(
                    IN long seqNumber,
                    IN PALIASCHANGE_REQUEST pAliasChangeRequest
                   )
{
    RasMessage                              rasMessage;
    RegistrationRequest *                   RRQ;
    SOCKADDR_IN                             sockAddr;
    EXPIRE_CONTEXT *                        pExpireContext = NULL;
    RegistrationRequest_callSignalAddress   CallSignalAddressSequence;
    RegistrationRequest_rasAddress          RasAddressSequence;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendRRQ entered:%p.",this ));
    
    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        return FALSE;
    }

    Lock();

    // initialize the structure
    ZeroMemory (&rasMessage, sizeof rasMessage);
    rasMessage.choice = registrationRequest_chosen;
    RRQ = &rasMessage.u.registrationRequest;
    RRQ -> bit_mask = 0;
    RRQ -> protocolIdentifier = OID_H225ProtocolIdentifierV2;

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        RRQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        RRQ -> requestSeqNum = GetNextSeqNum();
        if( pAliasChangeRequest == NULL )
        {
            m_lastRegisterSeqNum = RRQ -> requestSeqNum;
        }
        else
        {
            pAliasChangeRequest->wRequestSeqNum = RRQ -> requestSeqNum;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "RRQ seqNum:%d.", RRQ -> requestSeqNum ));
    
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 
        htons(LOWORD(g_RegistrySettings.dwQ931ListenPort));
    //we are listening for Q931 conns on all local interfaces
    //so specify just one of the local IP addresses
    sockAddr.sin_addr.s_addr = m_sockAddr.sin_addr.s_addr;
    
    SetTransportAddress( &sockAddr, &CallSignalAddressSequence.value);
    CallSignalAddressSequence.next = NULL;
    RRQ -> callSignalAddress = &CallSignalAddressSequence;

    // ras address. The UDP socket for this GK
    RasAddressSequence.next = NULL;
    RasAddressSequence.value = m_transportAddress;
    RRQ -> rasAddress = &RasAddressSequence;

    // fill in endpoint type
    RRQ -> terminalType.bit_mask |= terminal_present;
    RRQ -> terminalType.terminal.bit_mask = 0;

    //fill in terminal alias list
    if( pAliasChangeRequest && pAliasChangeRequest->pAliasList )
    {
        RRQ -> terminalAlias = (RegistrationRequest_terminalAlias *)
            SetMsgAddressAlias( pAliasChangeRequest->pAliasList );
        if (NULL == RRQ -> terminalAlias)
        {
            goto cleanup;
        }
        RRQ -> bit_mask |= RegistrationRequest_terminalAlias_present;

        RRQ -> bit_mask |= RegistrationRequest_endpointIdentifier_present;
        RRQ->endpointIdentifier.length = pAliasChangeRequest->rasEndpointID.length;
        RRQ->endpointIdentifier.value = pAliasChangeRequest->rasEndpointID.value;
    }
    else if( m_pAliasList && m_pAliasList->wCount )
    {
        RRQ -> terminalAlias = (RegistrationRequest_terminalAlias *)
            SetMsgAddressAlias( m_pAliasList );
        if (NULL == RRQ -> terminalAlias)
        {
            goto cleanup;
        }
        RRQ -> bit_mask |= RegistrationRequest_terminalAlias_present;
    }
    else
    {
        _ASSERTE(0);
    }

    //endpointVendor
    CopyVendorInfo( &(RRQ -> endpointVendor) );

    //a few random booleans
    RRQ -> discoveryComplete = FALSE;
    RRQ -> keepAlive = FALSE;
    RRQ -> willSupplyUUIEs = FALSE;

    // encode and send
    if( !IssueSend(&rasMessage) )
    {
        goto cleanup;
    }

    //delete if any previous TTL timer
    if( m_hRegTTLTimer )
    {
        DeleteTimerQueueTimer(H323TimerQueue, m_hRegTTLTimer, NULL );
        m_hRegTTLTimer = NULL;
    }

    //delete if any previous RRQ sent timer
    if( m_hRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL );
        m_hRegTimer = NULL;
    }

    pExpireContext -> RasClient = this;
    pExpireContext -> seqNumber = RRQ -> requestSeqNum;

    if( !CreateTimerQueueTimer(
            &m_hRegTimer,
            H323TimerQueue,
            RAS_CLIENT::RegExpiredCallback,
            pExpireContext,
            REG_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ) )
    {
        goto cleanup;
    }
    
    if( RRQ -> bit_mask & RegistrationRequest_terminalAlias_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            RRQ -> terminalAlias);
    }

    m_dwRegRetryCount++;

    if( pAliasChangeRequest == NULL )
    {
        m_RegisterState = RAS_REGISTER_STATE_RRQSENT;
    }

    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendRRQ exited:%p.", this ));
    return TRUE;

cleanup:
    if( RRQ -> bit_mask & RegistrationRequest_terminalAlias_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
             RRQ -> terminalAlias);
    }
    
    if( pExpireContext != NULL )
    {
        delete pExpireContext;    
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "SendRRQ error:%p.",this ));
    return FALSE;
}


BOOL
RAS_CLIENT::SendURQ(
                    IN long seqNumber,
                    IN EndpointIdentifier * pEndpointID
                   )
{
    RasMessage              rasMessage;
    UnregistrationRequest * URQ;
    SOCKADDR_IN             sockAddr;
    EXPIRE_CONTEXT *            pExpireContext = NULL;
    UnregistrationRequest_callSignalAddress CallSignalAddressSequence;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendURQ entered:%p.",this ));
    Lock();

    if( m_RegisterState == RAS_REGISTER_STATE_RRQSENT )
    {
        //store the seqNumber of this RRQ and send URQ if we recv RCF
        m_PendingURQ.RRQSeqNumber = m_lastRegisterSeqNum;

        Unlock();
        H323DBG(( DEBUG_LEVEL_TRACE, "rrq sent:so pending urq." ));
        return TRUE;
    }
    else if( m_RegisterState != RAS_REGISTER_STATE_REGISTERED )
    {
        //if already unregistered or URQ sent then return success
        Unlock();
        H323DBG(( DEBUG_LEVEL_TRACE, "current state:%d.", m_RegisterState ));
        return TRUE;
    }

    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        goto cleanup;
    }

    ZeroMemory (&rasMessage, sizeof RasMessage);
    rasMessage.choice = unregistrationRequest_chosen;
    URQ = &rasMessage.u.unregistrationRequest;

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        URQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        m_UnRegisterSeqNum = GetNextSeqNum();
        URQ -> requestSeqNum = (WORD)m_UnRegisterSeqNum;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "RRQ seqNum:%d.", URQ -> requestSeqNum ));
    
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 
        htons(LOWORD(g_RegistrySettings.dwQ931ListenPort));
    //we are listening for Q931 conns on all local interfaces
    //so specify just one of the local IP addresses
    sockAddr.sin_addr.s_addr = m_sockAddr.sin_addr.s_addr;

    SetTransportAddress( &sockAddr, &CallSignalAddressSequence.value);
    CallSignalAddressSequence.next = NULL;
    URQ -> callSignalAddress = &CallSignalAddressSequence;

    //get endpointidentifier by using GetComputerNameW
    URQ -> bit_mask |= UnregistrationRequest_endpointIdentifier_present;
    if( pEndpointID != NULL )
    {
        URQ->endpointIdentifier.length = pEndpointID ->length;
        URQ->endpointIdentifier.value = pEndpointID -> value;
    }
    else
    {
        URQ->endpointIdentifier.length = m_RASEndpointID.length;
        URQ->endpointIdentifier.value = m_RASEndpointID.value;
    }

    // encode and send
    if( !IssueSend( &rasMessage ) )
    {
        goto cleanup;
    }

    pExpireContext -> RasClient = this;
    pExpireContext -> seqNumber = URQ -> requestSeqNum;

    //delete if any previous RRQ sent timer
    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL );
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }

    if( !CreateTimerQueueTimer(
            &m_hUnRegTimer,
            H323TimerQueue,
            RAS_CLIENT::UnregExpiredCallback,
            pExpireContext,
            REG_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        goto cleanup;
    }

    //delete if any TTL timer
    if( m_hRegTTLTimer )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
        m_hRegTTLTimer = NULL;
    }

    m_dwUnRegRetryCount++;        
    m_RegisterState = RAS_REGISTER_STATE_URQSENT;
        
    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendURQ exited:%p.",this ));
    return TRUE;

cleanup:
    if( pExpireContext != NULL )
    {
        delete pExpireContext;
    }
    Unlock();
    return FALSE;
}


//!!always called from a lock
BOOL
RAS_CLIENT::SendUCF(
                    IN WORD seqNumber
                   )
{
    RasMessage              rasMessage;
    UnregistrationConfirm * UCF;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendUCF entered:%p.",this ));

    // initialize the structure
    ZeroMemory (&rasMessage, sizeof rasMessage);
    rasMessage.choice = unregistrationConfirm_chosen;
    UCF = &rasMessage.u.unregistrationConfirm;
    UCF -> bit_mask = 0;
    UCF -> requestSeqNum = seqNumber;

    if( !IssueSend( &rasMessage ) )
    {
        return FALSE;
    }   

        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendUCF exited:%p.",this ));
    return TRUE;
}


//!!always called from a lock
BOOL
RAS_CLIENT::SendURJ(
                    IN WORD seqNumber,
                    IN DWORD dwReason
                   )
{
    RasMessage          rasMessage;
    UnregistrationReject *  URJ;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendURJ entered:%p.",this ));

    // initialize the structure
    ZeroMemory (&rasMessage, sizeof rasMessage);
    rasMessage.choice = unregistrationReject_chosen;
    URJ = &rasMessage.u.unregistrationReject;
    URJ -> bit_mask = 0;
    URJ -> requestSeqNum = seqNumber;
    URJ -> rejectReason.choice = (WORD)dwReason;

    if( !IssueSend( &rasMessage ) )
    {
        return FALSE;
    }   
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendURJ exited:%p.",this ));
    return TRUE;
}


//!!always called from a lock
void 
RAS_CLIENT::ProcessRasMessage(
    IN RasMessage *pRasMessage
    )
{
    PH323_CALL      pCall = NULL;
    ASN1decoding_t  pASN1decInfo;

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS: processing RasMessage" ));

    //Verify that the RCF came from the expected gatekeeper

    switch( pRasMessage -> choice )
    {
    case registrationReject_chosen:
        
        OnRegistrationReject( &pRasMessage -> u.registrationReject );
        break;

    case registrationConfirm_chosen:
        
        OnRegistrationConfirm( &pRasMessage -> u.registrationConfirm );
        break;

    case unregistrationRequest_chosen:
        
        OnUnregistrationRequest( &pRasMessage -> u.unregistrationRequest );
        break;

    case unregistrationReject_chosen:
        
        OnUnregistrationReject( &pRasMessage -> u.unregistrationReject );
        break;

    case unregistrationConfirm_chosen:
        
        OnUnregistrationConfirm( &pRasMessage -> u.unregistrationConfirm );
        break;

    case infoRequest_chosen:

       pASN1decInfo = m_ASNCoderInfo.pDecInfo;
        
        //This function should be always called in
        //a lock and it unlocks the the ras client
        OnInfoRequest( &pRasMessage -> u.infoRequest );

        ASN1_FreeDecoded( pASN1decInfo, pRasMessage, RasMessage_PDU );

        //return here since we have already unlocked and freed the buffer
        return;

    default:
        
       pASN1decInfo = m_ASNCoderInfo.pDecInfo;

        //Don't loclk the RAS client while locking the call object.
        Unlock();
        
        HandleRASCallMessage( pRasMessage );
        ASN1_FreeDecoded( pASN1decInfo, pRasMessage, RasMessage_PDU );

        //return here since we have already unlocked and freed the buffer
        return;
    }
     
    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pRasMessage, RasMessage_PDU );
    Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "ProcessRasMessage exited:%p.",this ));
}


//!!always called from a lock
void 
HandleRASCallMessage(
    IN RasMessage *pRasMessage
    )
{
    PH323_CALL pCall = NULL;
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS: processing RASCallMessage" ));

    switch( pRasMessage -> choice )
    {
    case admissionConfirm_chosen:

        pCall = g_pH323Line -> FindCallByARQSeqNumAndLock(
            pRasMessage -> u.admissionConfirm.requestSeqNum);

        if( pCall != NULL )
        {
            pCall -> OnAdmissionConfirm( &pRasMessage->u.admissionConfirm );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "acf:call not found:%d.", 
                pRasMessage -> u.admissionConfirm.requestSeqNum ));
        break;

    case admissionReject_chosen:

        pCall = g_pH323Line -> FindCallByARQSeqNumAndLock( 
            pRasMessage -> u.admissionReject.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnAdmissionReject( &pRasMessage->u.admissionReject );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "arj:call not found:%d.",
                pRasMessage -> u.admissionReject.requestSeqNum ));
        break;

    case disengageRequest_chosen:

        pCall = g_pH323Line -> FindCallByCallRefAndLock( 
            pRasMessage -> u.disengageRequest.callReferenceValue );

        if( pCall != NULL )
        {
            pCall -> OnDisengageRequest( &pRasMessage -> u.disengageRequest );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "drq:call not found:%d.", 
                pRasMessage -> u.disengageRequest.callReferenceValue ));
        break;
    
    case disengageConfirm_chosen:

        pCall = g_pH323Line -> FindCallByDRQSeqNumAndLock( 
            pRasMessage -> u.disengageConfirm.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnDisengageConfirm( &pRasMessage -> u.disengageConfirm );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "dcf:call not found:%d.", 
                pRasMessage -> u.disengageConfirm.requestSeqNum ));
        break;
        
    case disengageReject_chosen:

        pCall = g_pH323Line -> FindCallByDRQSeqNumAndLock( 
            pRasMessage -> u.disengageReject.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnDisengageReject( &pRasMessage -> u.disengageReject );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "drj:call not found:%d.", 
                pRasMessage -> u.disengageReject.requestSeqNum));
        break;

    case requestInProgress_chosen:

        pCall = g_pH323Line -> FindCallByARQSeqNumAndLock(
            pRasMessage->u.requestInProgress.requestSeqNum );

        if( pCall != NULL )
        {
            pCall -> OnRequestInProgress( &pRasMessage->u.requestInProgress );
            pCall -> Unlock();
        }
        else
            H323DBG(( DEBUG_LEVEL_ERROR, "rip:call not found:%d.", 
                pRasMessage->u.requestInProgress.requestSeqNum ));
        break;

    default:
        _ASSERTE(0);
        H323DBG(( DEBUG_LEVEL_ERROR, "ProcessRASMessage: wrong message:%d",
            pRasMessage -> choice));
        break;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleRASCallMessage exited" ));
}


void
RAS_CLIENT::RegExpired(
    IN WORD seqNumber
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpired entered:%p.", this ));
    Lock();

    m_pRRQExpireContext = NULL;
    
    if( m_hRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL );
        m_hRegTimer = NULL;
    }

    /*
    1. Registered:ignore this timeout
    2. RRQ sent: (the endpoint has initiated the process of registering but 
       hasn't heard from the GK yet) Resend the RRQ
    3. Unregistered: ignore this imeout
    4. URQ sent: (the endpoint has initiated the process of unregistering but
       hasn't heard from the GK yet) ignore this timeout
    5. Idle: The GK client object has just been initialized and hasn't done 
       anything. This should not happen.
    */

    switch( m_RegisterState )
    {
    case RAS_REGISTER_STATE_RRQSENT:

        if( m_dwRegRetryCount < REG_RETRY_MAX )
        {
            if( !SendRRQ( (long)seqNumber, NULL ) )
            {
                m_RegisterState = RAS_REGISTER_STATE_RRQEXPIRED;
            }
        }
        else
        {
            m_RegisterState = RAS_REGISTER_STATE_RRQEXPIRED;
        }
        break;

    case RAS_REGISTER_STATE_REGISTERED:
    case RAS_REGISTER_STATE_URQSENT:
    case RAS_REGISTER_STATE_UNREGISTERED:
        break;

    case RAS_REGISTER_STATE_IDLE:
        _ASSERTE(0);
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "RegExpired exited:%p.",this ));
}


void
RAS_CLIENT::TTLExpired()
{
    RasMessage                  rasMessage;
    RegistrationRequest *       RRQ;

    H323DBG(( DEBUG_LEVEL_TRACE, "TTLExpired entered:%p.",this ));
    Lock();

    if( m_RegisterState == RAS_REGISTER_STATE_REGISTERED )
    {
        //send light weight RRQ
        // initialize the structure
        ZeroMemory (&rasMessage, sizeof rasMessage);
        rasMessage.choice = registrationRequest_chosen;
        RRQ = &rasMessage.u.registrationRequest;
        RRQ -> bit_mask = 0;
        RRQ -> protocolIdentifier = OID_H225ProtocolIdentifierV2;

        RRQ -> bit_mask |= keepAlive_present;
        RRQ -> keepAlive = TRUE;

        //copy TTL
        RRQ -> bit_mask |= RegistrationRequest_timeToLive_present;
        RRQ -> timeToLive = m_dwRegTimeToLive;

        //endpoint identifier
        RRQ -> bit_mask |= RegistrationRequest_endpointIdentifier_present;
        RRQ->endpointIdentifier.length = m_RASEndpointID.length;
        RRQ->endpointIdentifier.value = m_RASEndpointID.value;

        //seqNumber
        m_wTTLSeqNumber = GetNextSeqNum();
        RRQ -> requestSeqNum = (WORD)m_wTTLSeqNumber;

        //what about gatekeeperIdentifier, tokens?

        // encode and send
        if( !IssueSend(&rasMessage) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "SendLwtRRQ error:%p.",this ));
            Unlock();
            return;
        }
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TTLExpired exited:%p.",this ));
}


void
RAS_CLIENT::UnregExpired(
    IN WORD seqNumber
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpired entered:%p.",this ));
    Lock();
    
    m_pURQExpireContext = NULL;

    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL);
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }

    switch( m_RegisterState )
    {
    case RAS_REGISTER_STATE_URQSENT:

        if( m_dwUnRegRetryCount < URQ_RETRY_MAX )
        {
            SendURQ( (long)seqNumber, NULL );
        }
        else
        {
            m_RegisterState = RAS_REGISTER_STATE_URQEXPIRED;
        }
        break;

    case RAS_REGISTER_STATE_REGISTERED:
    case RAS_REGISTER_STATE_RRQSENT:
    case RAS_REGISTER_STATE_UNREGISTERED:
        break;

    case RAS_REGISTER_STATE_IDLE:
        _ASSERTE(0);
        break;
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "UnregExpired exited:%p.",this ));
}


void
RAS_CLIENT::OnUnregistrationRequest(
                                   IN UnregistrationRequest *URQ
                                  )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationRequest entered:%p.", this ));

    _ASSERTE( m_RegisterState != RAS_REGISTER_STATE_IDLE );

    if( (m_RegisterState == RAS_REGISTER_STATE_UNREGISTERED) ||
        (m_RegisterState == RAS_REGISTER_STATE_RRJ) )
    {
        SendURJ( URQ -> requestSeqNum, notCurrentlyRegistered_chosen );
    }
    else if( m_dwCallsInProgress )
    {
        SendURJ( URQ -> requestSeqNum, callInProgress_chosen );
    }
    else
    {
        m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
        SendUCF( URQ -> requestSeqNum );
        
        //try to register again
        if( !SendRRQ( NOT_RESEND_SEQ_NUM, NULL ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "couldn't send rrq on urq request." ));
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationRequest exited:%p.",this ));
}

//!!always called from a lock
void
RAS_CLIENT::OnUnregistrationConfirm(
                                    IN UnregistrationConfirm *UCF
                                   )
{
    H323DBG((DEBUG_LEVEL_TRACE, "OnUnregistrationConfirm entered:%p.",this));

    if( UCF -> requestSeqNum != m_UnRegisterSeqNum )
        return;

    _ASSERTE( m_hUnRegTimer );
    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL);
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }
    
    if( (m_RegisterState == RAS_REGISTER_STATE_URQSENT) ||
        (m_RegisterState == RAS_REGISTER_STATE_URQEXPIRED) )
    {
        //delete if any TTL timer
        if( m_hRegTTLTimer )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
            m_hRegTTLTimer = NULL;
        }

        m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationConfirm exited:%p.",this));
}


//!!always called from a lock
void 
RAS_CLIENT::OnUnregistrationReject(
    IN UnregistrationReject *URJ
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationReject entered:%p.",this ));

    if( URJ -> requestSeqNum != m_UnRegisterSeqNum )
    {
        return;
    }

    if( m_hUnRegTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hUnRegTimer, NULL);
        m_hUnRegTimer = NULL;
        m_dwUnRegRetryCount = 0;
    }

    if( (m_RegisterState == RAS_REGISTER_STATE_URQSENT) ||
        (m_RegisterState == RAS_REGISTER_STATE_URQEXPIRED) )
    {
        m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnUnregistrationReject exited:%p.",this ));
}


//!!always called from a lock
void 
RAS_CLIENT::OnRegistrationReject(
                                IN RegistrationReject * RRJ
                                )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationReject entered:%p.",this ));

    if( RRJ -> requestSeqNum == m_wTTLSeqNumber )
    {
        //Keep alive failed. So start registration process again.
        //This will change the RAS registration state to RRQSENT from REGISTERED.
        if( !SendRRQ( NOT_RESEND_SEQ_NUM, NULL ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "couldn't send rrq on Keep alive failure." ));
            m_RegisterState = RAS_REGISTER_STATE_UNREGISTERED;
        }
    }
    else if( RRJ -> requestSeqNum == m_lastRegisterSeqNum )
    {
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }

        if( (m_RegisterState == RAS_REGISTER_STATE_RRQSENT) ||
            (m_RegisterState == RAS_REGISTER_STATE_RRQEXPIRED) )
        {
            m_RegisterState = RAS_REGISTER_STATE_RRJ;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationReject exitd:%p.",this ));
}


//!!always called in lock
void
RAS_CLIENT::OnRegistrationConfirm(
    IN RegistrationConfirm * RCF )
{
    LIST_ENTRY *pListEntry = NULL;
    PALIASCHANGE_REQUEST pAliasChangeRequest = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationConfirm entered:%p.", this ));

    if( RCF -> requestSeqNum == m_PendingURQ.RRQSeqNumber )
    {
        //The timer could have been startd with the last RRQ, 
        //irrespective of the current state of registration.
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }
        
        //send URQ with the endpointIdentifier
        SendURQ( NOT_RESEND_SEQ_NUM, &RCF->endpointIdentifier );
        H323DBG(( DEBUG_LEVEL_TRACE, "sending pending URQ for RRQ:%d",
            RCF->requestSeqNum ));
        
        return;
    }
    else if( RCF -> requestSeqNum == m_lastRegisterSeqNum )
    {
        //The timer could have been startd with the last RRQ, 
        //irrespective of the current state of registration.
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }

        switch (m_RegisterState)
        {
        case RAS_REGISTER_STATE_REGISTERED:
    
            if (RCF->requestSeqNum == m_wTTLSeqNumber)
            {
                H323DBG(( DEBUG_LEVEL_TRACE, "RCF for TTL-RRQ." ));
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_WARNING, 
                "warning: received RCF, but was already registered-ignoring"));
            }
            break;

        case RAS_REGISTER_STATE_RRQEXPIRED:
            
            H323DBG(( DEBUG_LEVEL_TRACE, 
                "received RCF, but registration already expired, send URQ" ));
            SendURQ (NOT_RESEND_SEQ_NUM, &RCF->endpointIdentifier);
            break;

        case RAS_REGISTER_STATE_RRQSENT:

            //expecting RRQ. gatekeeper has responded.

            m_RegisterState = RAS_REGISTER_STATE_REGISTERED;
            
            CopyMemory( (PVOID)m_RASEndpointID.value, 
                        (PVOID)RCF -> endpointIdentifier.value, 
                        RCF -> endpointIdentifier.length * sizeof(WCHAR) );

            m_RASEndpointID.value[RCF -> endpointIdentifier.length] = L'\0';
            m_RASEndpointID.length = (WORD)RCF -> endpointIdentifier.length;

            InitializeTTLTimer( RCF );

            break;

        default:

            H323DBG(( DEBUG_LEVEL_TRACE, 
                "RAS: received RRQ, but was in unexpected state"));
            break;
        }
    }
    else if( RCF -> requestSeqNum == m_wTTLSeqNumber )
    {
        //The timer could have been startd with the last RRQ, 
        //irrespective of the current state of registration.
        if( m_hRegTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
            m_hRegTimer = NULL;
            m_dwRegRetryCount = 0;
        }
        
        //look for the change in keepalive interval.
        InitializeTTLTimer( RCF );
    }
    else
    {
        //Try to find if this is a alias change request.
        for( pListEntry = m_aliasChangeRequestList.Flink; 
             pListEntry != &m_aliasChangeRequestList; 
             pListEntry = pListEntry -> Flink )
        {
            pAliasChangeRequest = CONTAINING_RECORD( pListEntry,
                ALIASCHANGE_REQUEST, listEntry );

            if( pAliasChangeRequest -> wRequestSeqNum == RCF -> requestSeqNum )
            {
                break;
            }
        }

        if( pListEntry != &m_aliasChangeRequestList )
        {
            //The timer could have been startd with the last RRQ, 
            //irrespective of the current state of registration.
            if( m_hRegTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, m_hRegTimer, NULL);
                m_hRegTimer = NULL;
                m_dwRegRetryCount = 0;
            }
    
            //if registration has changed since this request was made then
            //ignore the message.
            if( memcmp( (PVOID)pAliasChangeRequest -> rasEndpointID.value,
                m_RASEndpointID.value, m_RASEndpointID.length * sizeof(WCHAR) )
                    == 0 )
            {
                //update the alias list.
                FreeAliasNames( m_pAliasList );

                m_pAliasList = pAliasChangeRequest->pAliasList;
                RemoveEntryList( &pAliasChangeRequest->listEntry );
                delete pAliasChangeRequest;
            }
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRegistrationConfirm exited:%p.", this ));
}


//!!always called in a lock.
BOOL
RAS_CLIENT::InitializeTTLTimer(
    IN RegistrationConfirm * RCF )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeTTLTimer - entered." ));
    
    if( (RCF->bit_mask & RegistrationConfirm_timeToLive_present) &&
        ( (m_dwRegTimeToLive != RCF->timeToLive) || (m_hRegTTLTimer == NULL) )
      )
    {
        m_dwRegTimeToLive = RCF->timeToLive;

        H323DBG(( DEBUG_LEVEL_TRACE, "timetolive value:%d.",
            m_dwRegTimeToLive ));

        //delete if any previous TTL timer
        if( m_hRegTTLTimer )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hRegTTLTimer, NULL );
            m_hRegTTLTimer = NULL;
        }

        //start a timer to send lightweight RRQ afetr given time
        if( !CreateTimerQueueTimer(
                &m_hRegTTLTimer,
                H323TimerQueue,
                RAS_CLIENT::TTLExpiredCallback,
                this,
                (m_dwRegTimeToLive - REG_TTL_MARGIN)*1000, 
                (m_dwRegTimeToLive - REG_TTL_MARGIN)*1000,
                WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ) )
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "failed to create timer queue timer"));
            m_hRegTTLTimer = NULL;
            return FALSE;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeTTLTimer - exited." ));
    return TRUE;
}


void 
RAS_CLIENT::OnInfoRequest (
    IN  InfoRequest *   IRQ)
{
    PH323_CALL      pCall;
    SOCKADDR_IN     ReplyAddress;
    InfoRequestResponse_perCallInfo CallInfoList;
    InfoRequestResponse_perCallInfo * pCallInfoList = NULL;
    InfoRequestResponse_perCallInfo_Seq *   CallInfo;
    HRESULT         hr;
    int             iIndex, jIndex;
    int             iNumCalls = 0;
    int             iCallTableSize;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnInfoRequest - entered." ));
    
    if (m_RegisterState != RAS_REGISTER_STATE_REGISTERED)
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "RAS: received InfoRequest, but was not registered"));
        
        Unlock();
        return;
    }

    if (IRQ->bit_mask & replyAddress_present)
    {

        if (!GetTransportAddress (&IRQ -> replyAddress, &ReplyAddress))
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "RAS: received InfoRequest, but replyAddress was malformed"));
            
            Unlock();
            return;
        }
    }
    else
    {
        ReplyAddress = m_GKAddress;
    }

    //Don't loclk the RAS client while locking the call object.
    Unlock();

    if( IRQ -> callReferenceValue )
    {
        //query is for a specific call. So find the call and then send IRR

        pCall = g_pH323Line -> 
            FindCallByCallRefAndLock( IRQ -> callReferenceValue );
        
        if( pCall )
        {

            CallInfo = &CallInfoList.value;
            CallInfoList.next = NULL;

            ZeroMemory (CallInfo, sizeof (InfoRequestResponse_perCallInfo_Seq));

            CallInfo -> callIdentifier.guid.length = sizeof (GUID);
            CallInfo -> conferenceID.length = sizeof (GUID);

            hr = pCall -> GetCallInfo (
                (GUID *) &CallInfo -> callIdentifier.guid.value,
                (GUID *) &CallInfo -> conferenceID.value);

            if( hr != S_OK )
            {
                H323DBG ((DEBUG_LEVEL_ERROR, 
                    "RAS: call is disconnected for crv (%04XH).", 
                    IRQ -> callReferenceValue));
                return;
            }

            pCall -> Unlock();

            CallInfo -> callReferenceValue = IRQ -> callReferenceValue;
            CallInfo -> callType.choice = pointToPoint_chosen;
            CallInfo -> callModel.choice = direct_chosen;
        }
        else
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "RAS: received InfoRequest for nonexistent crv (%04XH).",
                IRQ -> callReferenceValue));

            return;
        }

        SendInfoRequestResponse (&ReplyAddress, IRQ -> requestSeqNum, &CallInfoList);
    }
    else
    {
        //send the info about all the active calls.
        iNumCalls = g_pH323Line->GetNoOfCalls();

        if( iNumCalls != 0 )
        {
            pCallInfoList = new InfoRequestResponse_perCallInfo[iNumCalls];
        }

        if( pCallInfoList  != NULL )
        {
            //lock the call table
            g_pH323Line -> LockCallTable();

            iCallTableSize = g_pH323Line->GetCallTableSize();

            //lock the call so that nobody else would be able to delete the call
            for(    jIndex=0, iIndex=0;
                    (iIndex < iCallTableSize) && (jIndex < iNumCalls);
                    iIndex++ )
            {
                pCall = g_pH323Line->GetCallAtIndex(iIndex);

                if( pCall != NULL )
                {
                    pCall -> Lock();

                    CallInfo = &(pCallInfoList[jIndex++].value);

                    ZeroMemory( CallInfo, sizeof (InfoRequestResponse_perCallInfo_Seq) );

                    CallInfo -> callIdentifier.guid.length = sizeof( GUID );
                    CallInfo -> conferenceID.length = sizeof( GUID );

                    pCall -> GetCallInfo(
                        (GUID *) &CallInfo -> callIdentifier.guid.value,
                        (GUID *) &CallInfo -> conferenceID.value);

                    CallInfo -> callReferenceValue = pCall->GetCallRef();

                    pCall -> Unlock();

                    CallInfo -> callType.choice = pointToPoint_chosen;
                    CallInfo -> callModel.choice = direct_chosen;
                }
            }

            for( iIndex=0; iIndex < jIndex-1; iIndex++ )
            {
                pCallInfoList[iIndex].next = &(pCallInfoList[iIndex+1]);
            }

            pCallInfoList[iIndex].next = NULL;

            //unlock the call table
            g_pH323Line -> UnlockCallTable();
        }

        SendInfoRequestResponse( &ReplyAddress, IRQ -> requestSeqNum,
            pCallInfoList );

        if( pCallInfoList != NULL )
        {
            delete pCallInfoList;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnInfoRequest - exited." ));
}


HRESULT RAS_CLIENT::SendInfoRequestResponse (
    IN  SOCKADDR_IN *           RasAddress,
    IN  USHORT                  SequenceNumber,
    IN  InfoRequestResponse_perCallInfo *   CallInfoList)
{
    RasMessage          RasMessage;
    InfoRequestResponse *                   IRR;
    SOCKADDR_IN                             SocketAddress;
    HRESULT             hr;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendInfoRequestResponse - entered." ));
    Lock();

    if( m_RegisterState == RAS_REGISTER_STATE_REGISTERED )
    {

        InfoRequestResponse_callSignalAddress   CallSignalAddressSequence;

        H323DBG(( DEBUG_LEVEL_TRACE, "SendIRR entered:%p.",this ));

        ZeroMemory (&RasMessage, sizeof RasMessage);
        RasMessage.choice = infoRequestResponse_chosen;
        IRR = &RasMessage.u.infoRequestResponse;


        IRR -> requestSeqNum = SequenceNumber;

        // we are listening for Q931 conns on all local interfaces
        // so specify just one of the local IP addresses
        // -XXX- fix for multihomed support later
        SocketAddress.sin_family = AF_INET;
        SocketAddress.sin_port = htons (LOWORD(g_RegistrySettings.dwQ931ListenPort));
        SocketAddress.sin_addr.s_addr = m_sockAddr.sin_addr.s_addr;

        // callSignalAddress
        SetTransportAddress (&SocketAddress, &CallSignalAddressSequence.value);
        CallSignalAddressSequence.next = NULL;
        IRR -> callSignalAddress = &CallSignalAddressSequence;

        // rasAddress
        IRR -> rasAddress = m_transportAddress;

        // endpointIdentifier
        IRR -> endpointIdentifier.length = m_RASEndpointID.length;
        IRR -> endpointIdentifier.value = m_RASEndpointID.value;

        // fill in endpoint type
        IRR -> endpointType.bit_mask |= terminal_present;
        IRR -> endpointType.terminal.bit_mask = 0;

        if( CallInfoList )
        {
            IRR -> bit_mask |= perCallInfo_present;
            IRR -> perCallInfo = CallInfoList;
        }

        // send the pdu
        hr = EncodeSendMessage (&RasMessage);
    }
    else
    {
        hr = E_FAIL;
    }

    Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "SendInfoRequestResponse - exited." ));
    return TRUE;
}


//!!always called from a lock
BOOL
RAS_CLIENT::InitializeIo (void)
{
    DWORD               dwFlags = 0;
    int                 AddressLength;

    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeIo entered:%p.",this ));
    m_Socket = WSASocket (AF_INET, 
        SOCK_DGRAM, 
        IPPROTO_UDP, 
        NULL, 0, 
        WSA_FLAG_OVERLAPPED);

    if( m_Socket == INVALID_SOCKET )
    {
        WSAGetLastError();
        return FALSE;
    }

    if( !H323BindIoCompletionCallback ( (HANDLE)m_Socket,
        RAS_CLIENT::IoCompletionCallback, 0))
    {
        GetLastError();
        goto cleanup;
    }
    
    m_sockAddr.sin_family = AF_INET;
    m_sockAddr.sin_port = htons (0);   
    m_sockAddr.sin_addr.s_addr = 
        GetLocalIPAddress( m_GKAddress.sin_addr.S_un.S_addr );
    
    H323DBG(( DEBUG_LEVEL_TRACE, 
        "gk sock addr:%lx.", m_sockAddr.sin_addr.s_addr ));
    
    if( bind( m_Socket, (SOCKADDR *)&m_sockAddr, sizeof(m_sockAddr) )
        == SOCKET_ERROR )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Couldn't bind the RAS socket:%d, %p", WSAGetLastError(), this ));
                
        goto cleanup;
    }

    // now that we've bound to a dynamic UDP port,
    // query that port from the stack and store it.
    AddressLength = sizeof m_sockAddr;
    if( getsockname(m_Socket, (SOCKADDR *)&m_sockAddr, &AddressLength)
        == SOCKET_ERROR )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "getsockname failed :%d, %p", WSAGetLastError(), this ));

        goto cleanup;
    }
    _ASSERTE( ntohs(m_sockAddr.sin_port) );

    // fill in the IoTransportAddress structure.
    // this structure is the ASN.1-friendly transport
    // address of this client's endpoint.
    SetTransportAddress( &m_sockAddr, &m_transportAddress );

    // initiate i/o
    ZeroMemory( (PVOID)&m_recvOverlapped, sizeof(RAS_RECV_CONTEXT) );

    if( !IssueRecv() )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "InitializeIo exited:%p.",this ));
    return TRUE;

cleanup:

    closesocket(m_Socket);
    m_Socket = INVALID_SOCKET;
    return FALSE;
}


DWORD GetLocalIPAddress(
                        IN DWORD dwRemoteAddr
                       )
{
    DWORD       dwLocalAddr = INADDR_ANY;
    SOCKADDR_IN sRemoteAddr;
    SOCKADDR_IN sLocalAddr;
    DWORD       dwNumBytesReturned = 0;
    SOCKET      querySocket;

    H323DBG(( DEBUG_LEVEL_TRACE, "GetLocalIPAddress - entered." ));
    
    ZeroMemory( (PVOID)&sRemoteAddr, sizeof(SOCKADDR_IN) );
    ZeroMemory( (PVOID)&sLocalAddr, sizeof(SOCKADDR_IN) );
    sRemoteAddr.sin_family = AF_INET;
    sRemoteAddr.sin_addr =  *(struct in_addr *) &dwRemoteAddr;

    querySocket = WSASocket(
            AF_INET,            // int af 
            SOCK_DGRAM,         // int type
            IPPROTO_UDP,        // int protocol
            NULL,               // LPWSAPROTOCOL_INFO lpProtocolInfo
            0,                  // GROUP g 
            WSA_FLAG_OVERLAPPED // DWORD dwFlags 
        );

    if( querySocket == INVALID_SOCKET )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "getlocalIP wsasocket:%d.",
                WSAGetLastError() ));
            return dwLocalAddr;
    }

    if( WSAIoctl(
            querySocket,       // SOCKET s
            SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
            &sRemoteAddr,        // LPVOID  lpvInBuffer
            sizeof(SOCKADDR_IN), // DWORD   cbInBuffer
            &sLocalAddr,         // LPVOID  lpvOUTBuffer
            sizeof(SOCKADDR_IN),  // DWORD   cbOUTBuffer
            &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
            NULL, // LPWSAOVERLAPPED lpOverlapped
            NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
        ) == SOCKET_ERROR) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "getlocalIP error wsaioctl:%d.",
            WSAGetLastError() ));
    } 
    else 
    {
        dwLocalAddr = *(DWORD *)&sLocalAddr.sin_addr; 
        
        //if the remote address is on the same machine then...
        H323DBG(( DEBUG_LEVEL_ERROR, "dwLocalAddr:%x.", dwLocalAddr ));
        
        if( dwLocalAddr == NET_LOCAL_IP_ADDR_INTERFACE )
        {
            dwLocalAddr = dwRemoteAddr;
        }

        _ASSERTE( dwLocalAddr );
    }
    
    closesocket( querySocket );
    
    H323DBG(( DEBUG_LEVEL_TRACE, "GetLocalIPAddress - exited." ));
    return dwLocalAddr;
}


//!!always called from a lock
BOOL
RAS_CLIENT::IssueRecv(void)
{
    int    iError;
    WSABUF  BufferArray     [1];

    H323DBG(( DEBUG_LEVEL_TRACE, "IssueRecv entered:%p.",this ));
    _ASSERTE(!m_recvOverlapped.IsPending);

    if(m_Socket == INVALID_SOCKET)
    {
        return FALSE;
    }

    BufferArray [0].buf = (char *)(m_recvOverlapped.arBuf);
    BufferArray [0].len = IO_BUFFER_SIZE;

    ZeroMemory (&m_recvOverlapped.Overlapped, sizeof(OVERLAPPED));

    m_recvOverlapped.Type = OVERLAPPED_TYPE_RECV;
    m_recvOverlapped.RasClient = this;
    m_recvOverlapped.AddressLength = sizeof (SOCKADDR_IN);
    m_recvOverlapped.Flags = 0;

    if( WSARecvFrom(m_Socket,
                    BufferArray, 1,
                    &m_recvOverlapped.BytesTransferred,
                    &m_recvOverlapped.Flags,
                    (SOCKADDR*)&m_recvOverlapped.Address,
                    &m_recvOverlapped.AddressLength,
                    &m_recvOverlapped.Overlapped,
                    NULL) == SOCKET_ERROR )
    {
        iError = WSAGetLastError();
        if( iError == WSA_IO_PENDING )
        {
            m_recvOverlapped.IsPending = TRUE;
            m_IoRefCount++;
        }
        else if( iError == WSAEMSGSIZE )
        {
            //We don't handle this condition right now as it should not happen
            //In future with changes in the protocol this might be invoked and 
            //should be fixed
            _ASSERTE( FALSE );
        }
        else if( iError == WSAECONNRESET )
        {
            //On a UPD-datagram socket this error would indicate that a
            //previous send operation resulted in an ICMP "Port Unreachable"
            //message. This will happen if GK is not listening on the specified
            //port. This case would need special handling.
            _ASSERTE( FALSE );
            return FALSE;
        }
        else
        {
            //fatal error on the socket. shutdown the RAS client
            return FALSE;
        }
    }
    else
    {
        //data recvd immediately. IsPending is set beacause anyway a 
        //SendComplete event will be sent which will reset this BOOL
        m_recvOverlapped.IsPending = TRUE;
        m_IoRefCount++;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "IssueRecv exited:%p.",this ));
    return TRUE;
}



HRESULT 
RAS_CLIENT::EncodeSendMessage(
    IN RasMessage * RasMessage)
{
    RAS_SEND_CONTEXT *  SendContext;
    ASN1error_e     AsnError;
    WSABUF          BufferArray [1];
    DWORD           dwStatus;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeSendMessage entered:%p.",this ));

    Lock();

    if (m_Socket == INVALID_SOCKET)
    {
        Unlock();
        return E_FAIL;
    }
    
    SendContext = AllocSendBuffer();
    if( SendContext == NULL )
    {
        Unlock();
        return E_OUTOFMEMORY;
    }

    ZeroMemory( &SendContext -> Overlapped, sizeof (OVERLAPPED) );

    AsnError = ASN1_Encode (
        m_ASNCoderInfo.pEncInfo,
        RasMessage,
        RasMessage_PDU,
        ASN1ENCODE_SETBUFFER,
        SendContext -> arBuf,
        IO_BUFFER_SIZE);

    if (ASN1_FAILED (AsnError))
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "RAS: failed to encode RAS PDU (%d).", AsnError));
        FreeSendBuffer (SendContext);
        Unlock();
        return E_FAIL;
    }

    BufferArray [0].buf = (char *) SendContext -> arBuf;
    BufferArray [0].len = m_ASNCoderInfo.pEncInfo -> len;

    SendContext -> Type = OVERLAPPED_TYPE_SEND;
    SendContext -> RasClient = this;
    SendContext -> Address = m_GKAddress;

    if( WSASendTo (m_Socket,
        BufferArray, 
        1,
        &SendContext -> BytesTransferred, 
        0,
        (SOCKADDR *)&SendContext -> Address, 
        sizeof (SOCKADDR_IN),
        &SendContext->Overlapped, 
        NULL) == SOCKET_ERROR
        && WSAGetLastError() != WSA_IO_PENDING)
    {

        dwStatus = WSAGetLastError();

        H323DBG(( DEBUG_LEVEL_ERROR, "failed to issue async send on RAS socket" ));
        DumpError (dwStatus);

        //fatal error: shut down the client
        FreeSendBuffer (SendContext);
        Unlock();

        return HRESULT_FROM_WIN32 (dwStatus);
    }

    InsertHeadList( &m_sendPendingList, &SendContext -> ListEntry );
    m_IoRefCount++;

    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeSendMessage exited:%p.",this ));
    return S_OK;
}


// static
void 
NTAPI RAS_CLIENT::IoCompletionCallback(
    IN  DWORD           dwStatus,
    IN  DWORD           BytesTransferred,
    IN  OVERLAPPED *    Overlapped
    )
{
    RAS_OVERLAPPED *    RasOverlapped;
    RAS_CLIENT *        pRASClient;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "ras-IoCompletionCallback entered." ));

    _ASSERTE( Overlapped );
    RasOverlapped = CONTAINING_RECORD( Overlapped, RAS_OVERLAPPED, Overlapped );

    pRASClient = RasOverlapped -> RasClient;

    switch (RasOverlapped -> Type)
    {
    case OVERLAPPED_TYPE_SEND:

        pRASClient -> OnSendComplete( dwStatus, 
            static_cast<RAS_SEND_CONTEXT *> (RasOverlapped));
        break;

    case OVERLAPPED_TYPE_RECV:

        RasOverlapped -> BytesTransferred = BytesTransferred;
        pRASClient -> OnRecvComplete( dwStatus, 
            static_cast<RAS_RECV_CONTEXT *> (RasOverlapped));
        break;

    default:
        _ASSERTE(FALSE);
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "ras-IoCompletionCallback exited." ));
}


void 
RAS_CLIENT::OnSendComplete(
    IN DWORD dwStatus,
    IN RAS_SEND_CONTEXT * pSendContext
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnSendComplete entered:%p.",this ));

    if( dwStatus != ERROR_SUCCESS )
    {
        return;
    }

    Lock();
            
    m_IoRefCount--;
    
    //if the RAS client is already shutdown, then reduce the I/O refcount and return.
    if( m_dwState == RAS_CLIENT_STATE_NONE )
    {
        Unlock();
        return;
    }

    //this buffer may have already been freed
    if( IsInList( &m_sendPendingList, &pSendContext->ListEntry ) )
    {
        RemoveEntryList( &pSendContext->ListEntry );
        FreeSendBuffer( pSendContext );
    }
    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnSendComplete exited:%p.",this ));
}


void
RAS_CLIENT::OnRecvComplete(
    IN  DWORD dwStatus,
    IN  RAS_RECV_CONTEXT * RecvContext )
{
    RasMessage *    RasMessage = NULL;
    ASN1error_e     AsnError;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRecvComplete enterd:%p.",this ));
    Lock();

    m_IoRefCount--;

    //if the RAS client is already shutdown, then reduce the I/O refcount and return.
    if( m_dwState == RAS_CLIENT_STATE_NONE )
    {
        Unlock();
        return;
    }

    _ASSERTE(m_recvOverlapped.IsPending);
    m_recvOverlapped.IsPending = FALSE;

    switch( dwStatus )
    {
    case ERROR_SUCCESS:

        //asn decode and process the message
        if( m_recvOverlapped.BytesTransferred != 0 )
        {
            AsnError = ASN1_Decode (
                m_ASNCoderInfo.pDecInfo,                // ptr to encoder info
                (PVOID *) &RasMessage,                  // pdu data structure
                RasMessage_PDU,                         // pdu id
                ASN1DECODE_SETBUFFER,                   // flags
                m_recvOverlapped.arBuf,                 // buffer to decode
                m_recvOverlapped.BytesTransferred);     // size of buffer to decode

            //issue another read
            IssueRecv();

            if( ASN1_SUCCEEDED(AsnError) )
            {
                _ASSERTE(RasMessage);
                //This function should be always called in
                //a lock and it unlocks the the ras client
                ProcessRasMessage( RasMessage );
                return;
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_ERROR, "RAS ASNDecode returned error:%d.",
                    AsnError ));
                H323DUMPBUFFER( (BYTE*)m_recvOverlapped.arBuf,
                    (DWORD)m_recvOverlapped.BytesTransferred);
            }
        }
        break;

    case STATUS_PORT_UNREACHABLE:
    case STATUS_CANCELLED:

        IssueRecv();
        break;

    default:
        H323DBG ((DEBUG_LEVEL_ERROR, "failed to recv data on socket"));
        DumpError (dwStatus);
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "OnRecvComplete exited:%p.",this ));
}


int
RAS_CLIENT::InitASNCoder(void)
{
    int rc;
    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder entered: %p.", this ));

    memset((PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    if( H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        _ASSERTE(m_ASNCoderInfo.pEncInfo );

        rc = ASN1_CreateDecoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        _ASSERTE(m_ASNCoderInfo.pDecInfo );
    }

    if (rc != ASN1_SUCCESS)
    {
        TermASNCoder();
    }

    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
RAS_CLIENT::TermASNCoder(void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS TermASNCoder entered:%p.",this ));

    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(m_ASNCoderInfo.pEncInfo);
    ASN1_CloseDecoder(m_ASNCoderInfo.pDecInfo);

    memset( (PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS TermASNCoder exited:%p.",this ));
    return ASN1_SUCCESS;
}


void 
RAS_CLIENT::HandleRegistryChange()
{
    PH323_ALIASNAMES        pAliasList = NULL;
    PH323_ALIASITEM         pAliasItem = NULL;
    PALIASCHANGE_REQUEST    pAliasChangeRequest = NULL;
    int                     iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "RAS HandleRegistryChange entered:%p.",this ));
    
    //If line is not in listening mode then, return
    if( g_pH323Line -> GetState() != H323_LINESTATE_LISTENING )
        return;

    Lock();

    __try
    {
    
    //If registered with a GK, and GK disabled then send URQ.
    if( g_RegistrySettings.fIsGKEnabled == FALSE )
    {
        RasStop();
    }
    else
    {
        switch( m_RegisterState )
        {
        //If not registered then send RRQ to the GK.
        case RAS_REGISTER_STATE_IDLE:

            //No need to send URQ.
            //Shutdown the object.
            g_RasClient.Shutdown();
            RasStart();
            break;

        case RAS_REGISTER_STATE_REGISTERED:
        case RAS_REGISTER_STATE_RRQSENT:

            if( g_RegistrySettings.saGKAddr.sin_addr.s_addr !=
                m_GKAddress.sin_addr.s_addr )
            {
                //change of GK address

                //send URQ to the old GK and shutdown the RASClinet object.
                RasStop();
            
                //Initialize the GK object with new settings and send RRQ to the new GK.
                RasStart();
            }
            else 
            {
                //check for change in alias list.
                for( iIndex=0; iIndex < m_pAliasList->wCount; iIndex++ )
                {
                    pAliasItem = &(m_pAliasList->pItems[iIndex]);
                    
                    if( pAliasItem->wType == e164_chosen )
                    {
                        if( g_RegistrySettings.fIsGKLogOnPhoneEnabled == FALSE )
                        {
                            break;
                        }
                        else if( memcmp(
                            (PVOID)g_RegistrySettings.wszGKLogOnPhone, 
                            pAliasItem->pData, 
                            (pAliasItem->wDataLength+1) * sizeof(WCHAR) ) != 0 )
                        {
                            break;
                        }
                    }
                    else if( pAliasItem->wType == h323_ID_chosen )
                    {
                        if( g_RegistrySettings.fIsGKLogOnAccountEnabled==FALSE )
                        {
                            break;
                        }
                        else if( memcmp(
                            (PVOID)g_RegistrySettings.wszGKLogOnAccount, 
                            pAliasItem->pData, 
                            (pAliasItem->wDataLength+1) * sizeof(WCHAR) ) != 0 )
                        {
                            break;
                        }
                    }
                }
                    
                if( (iIndex < m_pAliasList->wCount ) ||
                    ( m_pAliasList->wCount !=
                      (g_RegistrySettings.fIsGKLogOnPhoneEnabled +
                       g_RegistrySettings.fIsGKLogOnAccountEnabled
                      )
                    )
                  )
                {
                    //create the new alias list.
                    pAliasList = new H323_ALIASNAMES;
                    
                    if( pAliasList != NULL )
                    {
                        ZeroMemory( (PVOID)pAliasList, sizeof(H323_ALIASNAMES) );
                        if( g_RegistrySettings.fIsGKLogOnPhoneEnabled )
                        {
                            if( !AddAliasItem( pAliasList, 
                                    g_RegistrySettings.wszGKLogOnPhone,
                                    e164_chosen ) )
                            {
                                goto cleanup;
                            }
                        }
                        
                        if( g_RegistrySettings.fIsGKLogOnAccountEnabled )
                        {
                            if( !AddAliasItem( pAliasList,
                                    g_RegistrySettings.wszGKLogOnAccount,
                                    h323_ID_chosen ) )
                            {
                                goto cleanup;
                            }
                        }

                        //queue the alias change request in the list
                        pAliasChangeRequest = new ALIASCHANGE_REQUEST;
                        
                        if( pAliasChangeRequest == NULL )
                        {
                            goto cleanup;
                        }

                        pAliasChangeRequest->rasEndpointID.length = m_RASEndpointID.length;
                        CopyMemory( (PVOID)pAliasChangeRequest->rasEndpointID.value,
                            m_RASEndpointID.value, 
                            (pAliasChangeRequest->rasEndpointID.length+1)*sizeof(WCHAR) );

                        pAliasChangeRequest->wRequestSeqNum = 0;
                        pAliasChangeRequest->pAliasList = pAliasList;

                        //Send RRQ with the new alias list.
                        if( !SendRRQ(NOT_RESEND_SEQ_NUM, pAliasChangeRequest) )
                        {
                            goto cleanup;
                        }

                        InsertHeadList( &m_aliasChangeRequestList,
                            &pAliasChangeRequest->listEntry );
                    }
                }
            }
            break;

        default:

            //Shutdown the RASClinet object. Send RRQ to new GK.
            RasStop();
            RasStart();
            break;
        }
    }
    
    }
    __except(1)
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "except in HandleRegistryChange :%p.", this ));
        _ASSERTE(0);
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "RAS HandleRegistryChange exited:%p.", this ));
    return;

cleanup:

    if( pAliasList != NULL )
    {
        FreeAliasNames( pAliasList );
    }
    
    if( pAliasChangeRequest != NULL )
    {
        delete pAliasChangeRequest;
    }

    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\q931pdu.h ===
#ifndef _Q931PDU_H
#define _Q931PDU_H

#define TPKT_VERSION            3
#define TPKT_HEADER_SIZE        4

#define CALLED_PARTY_PLAN_E164      0x01
#define CALLED_PARTY_EXT_BIT        0x80
#define CALLED_PARTY_TYPE_UNKNOWN   0x00


typedef struct S_BUFFERDESCR
{
    DWORD dwLength;
    BYTE *pbBuffer;

}BUFFERDESCR, *PBUFFERDESCR;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;

} ASN1_CODER_INFO;


// Mask to extract a message type from a byte
#define MESSAGETYPEMASK 0x7f

typedef BYTE MESSAGEIDTYPE;

//==========================================================
// BEARER FIELD DEFINITIONS
//==========================================================
// bearer encoding bits...
#define BEAR_EXT_BIT                0x80

// bearer coding standards...
#define BEAR_CCITT                  0x00
        // ...others not needed...

// bearer information transfer capability...
#define BEAR_UNRESTRICTED_DIGITAL   0x08
        // ...others not needed...

// bearer transfer mode...
#define BEAR_CIRCUIT_MODE			0x00
#define BEAR_PACKET_MODE            0x40
        // ...others not needed...

// bearer information transfer rate...
#define BEAR_NO_CIRCUIT_RATE        0x00
#define BEAR_MULTIRATE				0x18
        // ...others not needed...

// bearer layer1 protocol...
#define BEAR_LAYER1_INDICATOR       0x20
#define BEAR_LAYER1_H221_H242       0x05
        // ...others not needed...


// Q931 defined message types
#define ALERTINGMESSAGETYPE      0x01
#define PROCEEDINGMESSAGETYPE    0x02
#define CONNECTMESSAGETYPE       0x07
#define CONNECTACKMESSAGETYPE    0x0F
#define PROGRESSMESSAGETYPE      0x03
#define SETUPMESSAGETYPE         0x05
#define SETUPACKMESSAGETYPE      0x0D

#define RESUMEMESSAGETYPE        0x26
#define RESUMEACKMESSAGETYPE     0x2E
#define RESUMEREJMESSAGETYPE     0x22
#define SUSPENDMESSAGETYPE       0x25
#define SUSPENDACKMESSAGETYPE    0x2D
#define SUSPENDREJMESSAGETYPE    0x21
#define USERINFOMESSAGETYPE      0x20

#define DISCONNECTMESSAGETYPE    0x45
#define RELEASEMESSAGETYPE       0x4D
#define RELEASECOMPLMESSAGETYPE  0x5A
#define RESTARTMESSAGETYPE       0x46
#define RESTARTACKMESSAGETYPE    0x4E

#define SEGMENTMESSAGETYPE       0x60
#define CONGCTRLMESSAGETYPE      0x79
#define INFORMATIONMESSAGETYPE   0x7B
#define NOTIFYMESSAGETYPE        0x6E
#define STATUSMESSAGETYPE        0x7D
#define STATUSENQUIRYMESSAGETYPE 0x75


// Mask to remove only the field identifier from a type 1 single octet field
#define TYPE1IDENTMASK 0xf0

// Mask to remove only the value from a type 1 single octet field
#define TYPE1VALUEMASK 0x0f

// Type of the field identitifiers
typedef BYTE FIELDIDENTTYPE;

// Field identifiers
// Single octet values
#define IDENT_RESERVED        0x80
#define IDENT_SHIFT           0x90
#define IDENT_MORE            0xA0
#define IDENT_SENDINGCOMPLETE 0xA1
#define IDENT_CONGESTION      0xB0
#define IDENT_REPEAT          0xD0

// Variable length octet values
#define IDENT_SEGMENTED       0x00
#define IDENT_BEARERCAP       0x04
#define IDENT_CAUSE           0x08
#define IDENT_CALLIDENT       0x10
#define IDENT_CALLSTATE       0x14
#define IDENT_CHANNELIDENT    0x18
#define IDENT_PROGRESS        0x1E
#define IDENT_NETWORKSPEC     0x20
#define IDENT_NOTIFICATION    0x27
#define IDENT_DISPLAY         0x28
#define IDENT_DATE            0x29
#define IDENT_KEYPAD          0x2C
#define IDENT_SIGNAL          0x34
#define IDENT_INFORMATIONRATE 0x40
#define IDENT_ENDTOENDDELAY   0x42
#define IDENT_TRANSITDELAY    0x43
#define IDENT_PLBINARYPARAMS  0x44
#define IDENT_PLWINDOWSIZE    0x45
#define IDENT_PACKETSIZE      0x46
#define IDENT_CLOSEDUG        0x47
#define IDENT_REVCHARGE       0x4A
#define IDENT_CALLINGNUMBER   0x6C
#define IDENT_CALLINGSUBADDR  0x6D
#define IDENT_CALLEDNUMBER    0x70
#define IDENT_CALLEDSUBADDR   0x71
#define IDENT_REDIRECTING     0x74
#define IDENT_TRANSITNET      0x78
#define IDENT_RESTART         0x79
#define IDENT_LLCOMPATIBILITY 0x7C
#define IDENT_HLCOMPATIBILITY 0x7D
#define IDENT_USERUSER        0x7E

#define USE_ASN1_ENCODING     5   
//-------------------------------------------------------------------
// Structures for messages and information elements
//-------------------------------------------------------------------

typedef BYTE PDTYPE;
#define Q931PDVALUE ((PDTYPE)0x08)

typedef WORD CRTYPE;

// Since right now we don't need to separate out the individual
// parts of the fields of the structures these are the base 
// types from which the fields are made.
// Single octet element type 1 (contains a value)
struct S_SINGLESTRUCT1
{
    BOOLEAN fPresent;
    BYTE Value;
};

// Single octet element type 2 (does not contain a value)
struct S_SINGLESTRUCT2
{
    BOOLEAN fPresent;
};

// Variable length element
// Maximum element size
#define MAXVARFIELDLEN 131

struct S_VARSTRUCT
{
    BOOLEAN fPresent;
    BYTE dwLength;
    BYTE pbContents[MAXVARFIELDLEN];
};

// Right now all of the fields are bound to the simplest
// structures above.  No parsing other than just 
// single octet/variable octet is done.  When the values
// in some of the subfields are important, change the 
// structures here and change the appropriate parsing
// routine to generate the right structure

// The shift element is a single type 1
typedef struct S_SINGLESTRUCT1 SHIFTIE;
typedef struct S_SINGLESTRUCT1 *PSHIFTIE;

// The more data element is a single type 2
typedef struct S_SINGLESTRUCT2 MOREDATAIE;
typedef struct S_SINGLESTRUCT2 *PMOREDATAIE;

// The congestion level element is a single type 1
typedef struct S_SINGLESTRUCT1 CONGESTIONIE;
typedef struct S_SINGLESTRUCT1 *PCONGESTIONIE;

// The bearer capability element is a variable 
typedef struct S_VARSTRUCT BEARERCAPIE;
typedef struct S_VARSTRUCT *PBEARERCAPIE;

// The cause element is a variable 
typedef struct S_VARSTRUCT CAUSEIE;
typedef struct S_VARSTRUCT *PCAUSEIE;

// The call identity element is a variable 
typedef struct S_VARSTRUCT CALLIDENTIE;
typedef struct S_VARSTRUCT *PCALLIDENTIE;

// The call state element is a variable 
typedef struct S_VARSTRUCT CALLSTATEIE;
typedef struct S_VARSTRUCT *PCALLSTATEIE;

// The channel identifier element is a variable 
typedef struct S_VARSTRUCT CHANIDENTIE;
typedef struct S_VARSTRUCT *PCHANIDENTIE;

// The progress indicator element is a variable 
typedef struct S_VARSTRUCT PROGRESSIE;
typedef struct S_VARSTRUCT *PPROGRESSIE;

// The network specific element is a variable 
typedef struct S_VARSTRUCT NETWORKIE;
typedef struct S_VARSTRUCT *PNETWORKIE;

// The notification indicator element is a variable 
typedef struct S_VARSTRUCT NOTIFICATIONINDIE;
typedef struct S_VARSTRUCT *PNOTIFICATIONINDIE;

// The display element is a variable 
typedef struct S_VARSTRUCT DISPLAYIE;
typedef struct S_VARSTRUCT *PDISPLAYIE;

// The date element is a variable 
typedef struct S_VARSTRUCT DATEIE;
typedef struct S_VARSTRUCT *PDATEIE;

// The keypad element is a variable 
typedef struct S_VARSTRUCT KEYPADIE;
typedef struct S_VARSTRUCT *PKEYPADIE;

// The signal element is a variable 
typedef struct S_VARSTRUCT SIGNALIE;
typedef struct S_VARSTRUCT *PSIGNALIE;

// The information rate element is a variable 
typedef struct S_VARSTRUCT INFORATEIE;
typedef struct S_VARSTRUCT *PINFORATEIE;

// The transit delay element is a variable 
typedef struct S_VARSTRUCT TRANSITDELAYIE;
typedef struct S_VARSTRUCT *PTRANSITDELAYIE;

// The packet layer binary parameters element is a variable 
typedef struct S_VARSTRUCT PLBINARYPARAMSIE;
typedef struct S_VARSTRUCT *PPLBINARYPARAMSIE;

// The packet layer window size element is a variable 
typedef struct S_VARSTRUCT PLWINDOWSIZEIE;
typedef struct S_VARSTRUCT *PPLWINDOWSIZEIE;

// The packet size element is a variable 
typedef struct S_VARSTRUCT PACKETSIZEIE;
typedef struct S_VARSTRUCT *PPACKETSIZEIE;

// The closed user group element is a variable 
typedef struct S_VARSTRUCT CLOSEDUGIE;
typedef struct S_VARSTRUCT *PCLOSEDUGIE;

// The calling party number element is a variable 
typedef struct S_VARSTRUCT CALLINGNUMBERIE;
typedef struct S_VARSTRUCT *PCALLINGNUMBERIE;

// The calling party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLINGSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLINGSUBADDRIE;

// The called party subaddress element is a variable 
typedef struct S_VARSTRUCT CALLEDSUBADDRIE;
typedef struct S_VARSTRUCT *PCALLEDSUBADDRIE;

// The redirecting number element is a variable 
typedef struct S_VARSTRUCT REDIRECTINGIE;
typedef struct S_VARSTRUCT *PREDIRECTINGIE;

// The restart indicator element is a variable 
typedef struct S_VARSTRUCT RESTARTIE;
typedef struct S_VARSTRUCT *PRESTARTIE;

// The low layer compatibility element is a variable 
typedef struct S_VARSTRUCT LLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PLLCOMPATIBILITYIE;

// The higher layer compatibility element is a variable 
typedef struct S_VARSTRUCT HLCOMPATIBILITYIE;
typedef struct S_VARSTRUCT *PHLCOMPATIBILITYIE;

#define Q931_PROTOCOL_X209          ((PDTYPE)0x05)
#define MAX_USER_TO_USER_INFO_LEN   0x1000

typedef struct
{
    BOOLEAN fPresent;
    BYTE    ProtocolDiscriminator;
    WORD    wUserInfoLen;
    BYTE    pbUserInfo[MAX_USER_TO_USER_INFO_LEN];   // 4k bytes should be good for now...

} USERUSERIE, *PUSERUSERIE;


typedef struct S_PARTY_NUMBER
{
    BOOLEAN fPresent;
    BYTE    NumberType;
    BYTE    NumberingPlan;
    BYTE    PartyNumberLength;
    BYTE    PartyNumbers[MAXVARFIELDLEN];

} CALLEDNUMBERIE, *PCALLEDNUMBERIE;


// Q932 defined message types
#define HOLDMESSAGETYPE				0x24
#define HOLDACKMESSAGETYPE			0x28
#define HOLDREJECTMESSAGETYPE		0x30
#define RETRIEVEMESSAGETYPE			0x31
#define RETRIEVEACKMESSAGETYPE		0x33
#define RETRIEVEREJECTMESSAGETYPE	0x37
#define FACILITYMESSAGETYPE			0x62
#define REGISTERMESSAGETYPE			0x64

#define IDENT_FACILITY        0x1C
typedef struct S_VARSTRUCT FACILITYIE;
typedef struct S_VARSTRUCT *PFACILITYIE;


// Generic structure for a Q.931 message
typedef struct S_MESSAGE
{
    PDTYPE ProtocolDiscriminator;
    CRTYPE wCallRef;
    MESSAGEIDTYPE MessageType;
    SHIFTIE Shift;
    MOREDATAIE MoreData;
    BEARERCAPIE BearerCapability;
    CAUSEIE Cause;
    CALLIDENTIE CallIdentity;
    CALLSTATEIE CallState;
    CHANIDENTIE ChannelIdentification;
    PROGRESSIE ProgressIndicator;
    NETWORKIE NetworkFacilities;
    NOTIFICATIONINDIE NotificationIndicator;
    DISPLAYIE Display;
    DATEIE Date;
    KEYPADIE Keypad;
    SIGNALIE Signal;
    INFORATEIE InformationRate;
    PLBINARYPARAMSIE PacketLayerBinaryParams;
    PLWINDOWSIZEIE PacketLayerWindowSize;
    PACKETSIZEIE PacketSize;
    CALLINGNUMBERIE CallingPartyNumber;
    CALLINGSUBADDRIE CallingPartySubaddress;
    CALLEDNUMBERIE CalledPartyNumber;
    CALLEDSUBADDRIE CalledPartySubaddress;
    REDIRECTINGIE RedirectingNumber;
    RESTARTIE RestartIndicator;
    LLCOMPATIBILITYIE LowLayerCompatibility;
    HLCOMPATIBILITYIE HighLayerCompatibility;
    FACILITYIE Facility;
    USERUSERIE UserToUser;

}Q931MESSAGE, *PQ931MESSAGE;


typedef struct _BINARY_STRING
{
    WORD length;
    BYTE *pbBuffer;

} BINARY_STRING;


typedef struct _Q931_SETUP_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    PH323_ALIASNAMES        pCallerAliasList;
    PH323_ALIASNAMES        pCalleeAliasList;
    PH323_ALIASNAMES        pExtraAliasList;
    PH323_ALIASITEM         pExtensionAliasItem;
    BOOL                    fSourceAddrPresent;
    BOOL                    fCallerAddrPresent;
    BOOL                    fCalleeAddrPresent;
    BOOL                    fCalleeDestAddrPresent;
    H323_ADDR               sourceAddr;             // originating addr
    H323_ADDR               callerAddr;             // gk addr
    H323_ADDR               calleeAddr;             // local addr
    H323_ADDR               calleeDestAddr;         // target destination addr
    WORD                    wGoal;
    WORD                    wCallType;
    BOOL                    bCallerIsMC;
    GUID                    ConferenceID;
    H323_ENDPOINTTYPE       EndpointType;
    H323_VENDORINFO         VendorInfo;
    BOOL                    fFastStartPresent;
    PH323_FASTSTART         pFastStart;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_SETUP_ASN;


typedef struct _Q931_RELEASE_COMPLETE_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    BYTE                    bReason;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_RELEASE_COMPLETE_ASN;


typedef struct _Q931_CONNECT_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    BOOL                    h245AddrPresent;
    H323_ADDR               h245Addr;
    GUID                    ConferenceID;
    H323_ENDPOINTTYPE       EndpointType;
    H323_VENDORINFO         VendorInfo;
    BOOL                    fFastStartPresent;
    PH323_FASTSTART         pFastStart;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_CONNECT_ASN;


typedef struct _Q931_ALERTING_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    BOOL                    fH245AddrPresent;
    H323_ADDR               h245Addr;
    BOOL                    fFastStartPresent;
    PH323_FASTSTART         pFastStart;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;

} Q931_ALERTING_ASN, Q931_CALL_PROCEEDING_ASN ;


typedef struct _Q931_FACILITY_ASN
{
    BOOL                    fNonStandardDataPresent;
    H323NonStandardData     nonStandardData;
    H323_ADDR               AlternativeAddr;
    BOOL                    fAlternativeAddressPresent;
    PH323_ALIASNAMES        pAlternativeAliasList;
    GUID                    ConferenceID;
    BOOL                    ConferenceIDPresent;
    WORD                    bReason;
    BOOL                    fCallIdentifierPresent;
    GUID                    callIdentifier;
    DWORD                   dwInvokeID;
    ASN1octetstring_t       pH245PDU;
    DWORD                   dwH450APDUType;
    H323_ADDR               h245Addr;
    BOOL                    fH245AddrPresent;

} Q931_FACILITY_ASN;



//-------------------------------------------------------------------
// Initialization Routines
//-------------------------------------------------------------------
HRESULT 
WritePartyNumber(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    BYTE NumberType,
    BYTE NumberingPlan,
    BYTE bPartyNumberLength,
    BYTE *pbPartyNumbers,
    DWORD *  pdwPDULen );

void WriteProtocolDiscriminator(
    PBUFFERDESCR pBuf,
       DWORD * dwPDULen );

void WriteCallReference(
    PBUFFERDESCR pBuf,
    WORD *pwCallReference,
    DWORD * dwPDULen );
void WriteMessageType(
    PBUFFERDESCR pBuf,
    MESSAGEIDTYPE *MessageType,
    DWORD* pdwPDULen );
void WriteVariableOctet(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    BYTE dwLength,
    BYTE *pbContents,
    DWORD* pdwPDULen);
void WriteUserInformation(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    WORD wUserInfoLen,
    BYTE *pbUserInfo,
    DWORD* pdwPDULen);
HRESULT 
ParseSingleOctetType1(
    PBUFFERDESCR pBuf,
    BYTE *bIdent,
    BYTE *Value);
HRESULT
ParseSingleOctetType2(
    PBUFFERDESCR pBuf,
    BYTE *bIdent);
HRESULT 
ParseVariableOctet(
    PBUFFERDESCR pBuf,
    BYTE *pdwLength,
    BYTE *pbContents);
HRESULT 
ParseVariableASN(
    PBUFFERDESCR pBuf,
    BYTE *bIdent,
    BYTE *ProtocolDiscriminator,
    WORD *pwUserInfoLen,     // Length of the User Information.
    BYTE *pbUserInfo);       // Bytes of the User Information.
BYTE
GetNextIdent(
    void *BufferPtr);
HRESULT
ParseProtocolDiscriminator(
    PBUFFERDESCR pBuf,
    PDTYPE *Discrim);
HRESULT
ParseCallReference(
    PBUFFERDESCR pBuf,
    CRTYPE *wCallRef);
HRESULT
ParseMessageType(
    PBUFFERDESCR pBuf,
    MESSAGEIDTYPE *MessageType);
HRESULT
ParseShift(
    PBUFFERDESCR pBuf,
    PSHIFTIE FieldStruct);
HRESULT
ParseFacility(
    PBUFFERDESCR pBuf,
    PFACILITYIE FieldStruct);
HRESULT
ParseBearerCapability(
    PBUFFERDESCR pBuf,
    PBEARERCAPIE FieldStruct);
HRESULT
ParseCause(
    PBUFFERDESCR pBuf,
    PCAUSEIE FieldStruct);
HRESULT
ParseCallState(
    PBUFFERDESCR pBuf,
    PCALLSTATEIE FieldStruct);
HRESULT
ParseChannelIdentification(
    PBUFFERDESCR pBuf,
    PCHANIDENTIE FieldStruct);
HRESULT
ParseProgress(
    PBUFFERDESCR pBuf,
    PPROGRESSIE FieldStruct);
HRESULT 
ParseNetworkSpec(
    PBUFFERDESCR pBuf,
    PNETWORKIE FieldStruct);
HRESULT
ParseNotificationIndicator(
    PBUFFERDESCR pBuf,
    PNOTIFICATIONINDIE FieldStruct);
HRESULT
ParseDisplay(
    PBUFFERDESCR pBuf,
    PDISPLAYIE FieldStruct);
HRESULT
ParseDate(
    PBUFFERDESCR pBuf,
    PDATEIE FieldStruct);
HRESULT
ParseKeypad(
    PBUFFERDESCR pBuf,
    PKEYPADIE FieldStruct);
HRESULT
ParseSignal(
    PBUFFERDESCR pBuf,
    PSIGNALIE FieldStruct);
HRESULT
ParseInformationRate(
    PBUFFERDESCR pBuf,
    PINFORATEIE FieldStruct);
HRESULT
ParseCallingPartyNumber(
    PBUFFERDESCR pBuf,
    PCALLINGNUMBERIE FieldStruct);
HRESULT
ParseCallingPartySubaddress(
    PBUFFERDESCR pBuf,
    PCALLINGSUBADDRIE FieldStruct);
HRESULT
ParseCalledPartyNumber(
    PBUFFERDESCR pBuf, 
    PCALLEDNUMBERIE FieldStruct);
HRESULT
ParseCalledPartySubaddress(
    PBUFFERDESCR pBuf,
    PCALLEDSUBADDRIE FieldStruct);
HRESULT
ParseRedirectingNumber(
    PBUFFERDESCR pBuf, 
    PREDIRECTINGIE FieldStruct);
HRESULT
ParseLowLayerCompatibility(
    PBUFFERDESCR pBuf,
    PLLCOMPATIBILITYIE FieldStruct);
HRESULT
ParseHighLayerCompatibility(
    PBUFFERDESCR pBuf,
    PHLCOMPATIBILITYIE FieldStruct);
HRESULT
ParseUserToUser(
    PBUFFERDESCR pBuf,
    PUSERUSERIE FieldStruct);
HRESULT
ParseQ931Field(
    PBUFFERDESCR pBuf,
    PQ931MESSAGE pMessage);
BOOL ParseVendorInfo(
                     PH323_VENDORINFO pDestVendorInfo,
                     VendorIdentifier* pVendor
                     );
BOOL ParseNonStandardData( 
        H323NonStandardData * dstNonStdData,
        H225NonStandardParameter *srcNonStdData );
BOOL AliasAddrToAliasNames( 
                        PH323_ALIASNAMES *ppTarget, 
                        Setup_UUIE_sourceAddress *pSource );
HRESULT AliasAddrToAliasItem( PH323_ALIASITEM pTarget, 
                           AliasAddress *pSource);
void FreeConnectASN( Q931_CONNECT_ASN *pConnectASN );
void FreeSetupASN( Q931_SETUP_ASN* pSetupASN );
void FreeAlertingASN( Q931_ALERTING_ASN* pAlertingASN );
void FreeFacilityASN( IN Q931_FACILITY_ASN* pFacilityASN );
void FreeProceedingASN( Q931_CALL_PROCEEDING_ASN* pProceedingASN );
void FreeVendorInfo( PH323_VENDORINFO pVendorInfo );
void FreeAliasNames( PH323_ALIASNAMES pSource );
void FreeAliasItems( PH323_ALIASNAMES pSource );
void FreeFastStart( PH323_FASTSTART pFastStart );
PH323_FASTSTART CopyFastStart( PSetup_UUIE_fastStart pSrcFastStart );
int GetTpktLength( char * pTpktHeader );
int Q931_InitModule(void);
void SetupTPKTHeader( BYTE * pbTpktHeader, DWORD dwLength);
BOOL IsInList( LIST_ENTRY * List, LIST_ENTRY * Entry );
DWORD GetLocalIPAddress( DWORD dwRemoteAddr );
BOOL CompareAliasItems( AliasAddress* pAliasAddress, 
    PH323_ALIASITEM pAliasItem );
BOOL MapAliasItem(  IN PH323_ALIASNAMES pCalleeAliasNames, 
    IN AliasAddress* pAliasAddress );

#define ISVALIDQ931MESSAGE(messageType)   ( (messageType==ALERTINGMESSAGETYPE) ||   \
                                            (messageType==PROCEEDINGMESSAGETYPE) || \
                                            (messageType==CONNECTMESSAGETYPE) ||    \
                                            (messageType==SETUPMESSAGETYPE) ||      \
                                            (messageType==RELEASEMESSAGETYPE) ||    \
                                            (messageType==RELEASECOMPLMESSAGETYPE)||\
                                            (messageType==FACILITYMESSAGETYPE) )


//-------------------------------------------------------------------
// Encoding Routines
//-------------------------------------------------------------------


// extract an IP address and UDP/TCP port from an H.323 TransportAddress PDU
static __inline BOOL GetTransportAddress (
	IN	const TransportAddress *	transport,
	OUT	SOCKADDR_IN *	sockaddr)
{
    union {
        IN_ADDR		in_addr;
        UCHAR		octet	[4];
    }	ip_addr;

    _ASSERTE (transport);
    _ASSERTE (sockaddr);

    if (transport -> choice != ipAddress_chosen)
    {
        H323DBG ((DEBUG_LEVEL_WARNING, "GetTransportAddress: not IP address"));
        return FALSE;
    }

    if (transport -> u.ipAddress.ip.length != 4)
    {
        H323DBG ((DEBUG_LEVEL_WARNING, "GetTransportAddress: bogus IP address byte length"));
        return FALSE;
    }

#define	Bx(x) ip_addr.octet [x] = transport -> u.ipAddress.ip.value [x];

    Bx (0)
    Bx (1)
    Bx (2)
    Bx (3)

#undef	Bx

    sockaddr -> sin_family = AF_INET;
    sockaddr -> sin_port = htons (transport -> u.ipAddress.port);
    sockaddr -> sin_addr = ip_addr.in_addr;

    return TRUE;
}

// construct an H.323 TransportAddress from an IP address and TCP/UDP port
static __inline void SetTransportAddress (
	IN	const SOCKADDR_IN * addr,
	OUT	TransportAddress * transport)
{
	union {
		IN_ADDR		in_addr;
		UCHAR		octet	[4];
	}	ip_addr;

	_ASSERTE( addr );
	_ASSERTE( transport );

	ip_addr.in_addr = addr -> sin_addr;

#define	Bx(x) transport -> u.ipAddress.ip.value [x] = ip_addr.octet [x];

	Bx (0)
	Bx (1)
	Bx (2)
	Bx (3)

#undef	Bx

	transport -> choice = ipAddress_chosen;
	transport -> u.ipAddress.port = ntohs (addr -> sin_port);
	transport -> u.ipAddress.ip.length = 4;
}


#endif //_Q931PDU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by h323.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\rascall.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rascall.cpp

Abstract:

    The RAS call functionality (ARQ/DRQ/ACF/DCF/IRR/ARJ/DRJ)

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "ras.h"


//!!always called from a lock
BOOL
CH323Call::SendARQ(
                    IN long seqNumber
                  )
{
    RasMessage                          rasMessage;
    AdmissionRequest *                  ARQ;
    EXPIRE_CONTEXT *                    pExpireContext;
    PH323_ALIASNAMES                    pAliasList;
    PAdmissionRequest_destinationInfo   destInfo = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendARQ entered:%p.",this ));

    //if not registered with the GK then return failure
    if (!RasIsRegistered())
        return FALSE;

    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        return FALSE;
    }

    ZeroMemory( &rasMessage, sizeof RasMessage );

    rasMessage.choice = admissionRequest_chosen;
    ARQ = &rasMessage.u.admissionRequest;

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        ARQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        m_wARQSeqNum = RasAllocSequenceNumber();
        ARQ -> requestSeqNum = m_wARQSeqNum;
    }

    ARQ -> callType.choice = pointToPoint_chosen;

    // endpointIdentifier
    RasGetEndpointID (&ARQ -> endpointIdentifier);

    // srcInfo: pass on the registered aliases
    pAliasList = RASGetRegisteredAliasList();

    ARQ -> srcInfo = (PAdmissionRequest_srcInfo)
        SetMsgAddressAlias( pAliasList );

    if( ARQ -> srcInfo == NULL )
    {
        delete pExpireContext;
        return FALSE;
    }

    // destInfo
    if( (m_dwOrigin==LINECALLORIGIN_OUTBOUND) && m_pCalleeAliasNames &&
        (m_pCalleeAliasNames -> wCount) )
    {
        ARQ -> destinationInfo = (PAdmissionRequest_destinationInfo)
            SetMsgAddressAlias( m_pCalleeAliasNames );

        if( ARQ -> destinationInfo != NULL )
        {
            ARQ -> bit_mask |= AdmissionRequest_destinationInfo_present;
        }
    }
    else if( (m_dwOrigin==LINECALLORIGIN_INBOUND) && m_pCallerAliasNames
        && (m_pCallerAliasNames -> wCount) )
    {
        ARQ -> destinationInfo = (PAdmissionRequest_destinationInfo)
            SetMsgAddressAlias( m_pCallerAliasNames );

        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    
        if( ARQ -> destinationInfo )
        {
            ARQ -> bit_mask |= AdmissionRequest_destinationInfo_present;
        }
    }

    for( destInfo = ARQ -> destinationInfo; destInfo; destInfo=destInfo->next )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "the alias:%s.", destInfo->value.u.e164 ));
    }

    ARQ -> bandWidth = 0;
    ARQ -> callReferenceValue = m_wCallReference;

    // no destExtraCallInfo
    // no srcCallSignalAddress
    // no nonStandardData
    // no callServices

    CopyConferenceID (&ARQ -> conferenceID, &m_ConferenceID);

    ARQ -> activeMC = FALSE;
    ARQ -> answerCall = ( m_dwOrigin == LINECALLORIGIN_INBOUND );
    ARQ -> canMapAlias = TRUE;

    CopyMemory( (PVOID)&ARQ -> callIdentifier.guid.value,
        (PVOID)&m_callIdentifier, sizeof(GUID) );

    ARQ -> callIdentifier.guid.length = sizeof (GUID);
    ARQ -> bit_mask |= AdmissionRequest_callIdentifier_present;

    // no srcAlternatives
    // no destAlternatives
    // no gatekeeperIdentifier
    // no tokens
    // no cryptoTokens
    // no integrityCheckValue
    // no transportQOS
    
    ARQ -> willSupplyUUIEs = FALSE;
    
    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
        m_hARQTimer = NULL;
    }

    pExpireContext -> DriverCallHandle = m_hdCall;
    pExpireContext -> seqNumber = ARQ -> requestSeqNum;

    if( !CreateTimerQueueTimer(
            &m_hARQTimer,
            H323TimerQueue,
            CH323Call::ARQExpiredCallback,
            (PVOID)pExpireContext,
            ARQ_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
    {
        goto cleanup;
    }


    if( RasEncodeSendMessage (&rasMessage) != S_OK )
    {
        goto cleanup;
    }

    if( ARQ -> bit_mask & AdmissionRequest_destinationInfo_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            ARQ -> destinationInfo );
    }
    
    FreeAddressAliases( (PSetup_UUIE_destinationAddress)ARQ -> srcInfo );
    m_dwRASCallState = RASCALL_STATE_ARQSENT;
    m_dwARQRetryCount++;

    _ASSERTE( m_pARQExpireContext == NULL );
    m_pARQExpireContext = pExpireContext;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendARQ exited:%p.",this ));
    return TRUE;

cleanup:

    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, 
            m_hARQTimer, NULL );
        m_hARQTimer = NULL;
        m_dwARQRetryCount = 0;
    }
    if( ARQ -> bit_mask & AdmissionRequest_destinationInfo_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            ARQ -> destinationInfo );
    }

    if( pExpireContext != NULL )
    {
        delete pExpireContext;
    }

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)ARQ -> srcInfo );
    return FALSE;
}


//!!always called from a lock
BOOL 
CH323Call::SendDRQ(
                    IN USHORT usDisengageReason,
                    IN long seqNumber,
                    IN BOOL fResendOnExpire
                  )
{
    RasMessage          rasMessage;
    DisengageRequest *  DRQ;
    EXPIRE_CONTEXT *        pExpireContext;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendDRQ entered:%p.",this ));

    ZeroMemory( &rasMessage, sizeof(rasMessage) );
    rasMessage.choice = disengageRequest_chosen;
    DRQ = &rasMessage.u.disengageRequest;

    //if not registered with the GK then return failure
    if (!RasIsRegistered())
    {
        return FALSE;
    }

    if( fResendOnExpire == TRUE )
    {
        pExpireContext = new EXPIRE_CONTEXT;
        if( pExpireContext == NULL )
        {
            return FALSE;
        }
    }

    // get sequence number
    if( seqNumber != NOT_RESEND_SEQ_NUM )
    {
        DRQ -> requestSeqNum = (WORD)seqNumber;
    }
    else
    {
        m_wDRQSeqNum = RasAllocSequenceNumber();
        DRQ -> requestSeqNum = m_wDRQSeqNum;
    }

    DRQ -> callReferenceValue = m_wCallReference;
    DRQ -> disengageReason.choice = usDisengageReason;

    // endpoint identifier
    RasGetEndpointID (&DRQ -> endpointIdentifier);

    // conferenceID
    CopyConferenceID (&DRQ -> conferenceID, &m_ConferenceID);

    // callIdentifier
    CopyConferenceID (&DRQ -> callIdentifier.guid, &m_callIdentifier);
    DRQ -> bit_mask |= DisengageRequest_callIdentifier_present;

    if( RasEncodeSendMessage( &rasMessage ) != S_OK )
    {
        delete pExpireContext;
        return FALSE;
    }   

    if( m_hDRQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer, NULL );
        m_hDRQTimer = NULL;
    }

    if( fResendOnExpire == TRUE )
    {
        pExpireContext -> DriverCallHandle = m_hdCall;
        pExpireContext -> seqNumber = DRQ -> requestSeqNum;

        if( !CreateTimerQueueTimer(
            &m_hDRQTimer,
            H323TimerQueue,
            CH323Call::DRQExpiredCallback,
            (PVOID)pExpireContext,
            ARQ_EXPIRE_TIME, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
        {
            delete pExpireContext;
            return FALSE;
        }
    
        _ASSERTE( m_pDRQExpireContext == NULL );
        m_pDRQExpireContext = pExpireContext;
    }

    m_dwRASCallState = RASCALL_STATE_DRQSENT;
    m_dwDRQRetryCount++;

    H323DBG(( DEBUG_LEVEL_TRACE, "SendDRQ exited:%p.",this ));
    return TRUE;
}


//!!always called from a lock    
void
CH323Call::OnDisengageRequest( 
                                IN DisengageRequest * DRQ
                             )
{
    GUID    RequestConferenceID;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageRequest entered:%p.",this ));

    if( (m_dwRASCallState == RASCALL_STATE_UNREGISTERED) ||
        (m_dwRASCallState == RASCALL_STATE_ARJRECVD) )
    {
        return;
    }

    CopyConferenceID (&RequestConferenceID, &DRQ -> conferenceID);

    if (!IsEqualGUID (m_ConferenceID, RequestConferenceID))
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "DisengageRequest conference ID does not match this call, ignoring..."));
        return;
    }

    if (SendDCF (DRQ -> requestSeqNum))
    {
        m_dwRASCallState = RASCALL_STATE_UNREGISTERED;
        CloseCall( 0 );
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageRequest exited:%p.",this ));
}


//!!always called in a lock    
BOOL
CH323Call::SendDCF(
                   IN WORD seqNumber
                  )
{
    RasMessage          rasMessage;
    DisengageConfirm *  DCF;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendDCF entered:%p.",this ));

    ZeroMemory( &rasMessage, sizeof(rasMessage) );
    rasMessage.choice = disengageConfirm_chosen;
    DCF = &rasMessage.u.disengageConfirm;

    //if not registered with the GK then return failure
    if (!RasIsRegistered())
    {
        return FALSE;
    }
        
    DCF -> requestSeqNum = seqNumber;
    if (RasEncodeSendMessage (&rasMessage) != S_OK)
    {
        return FALSE;
    }   
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendDCF exited:%p.",this ));
    return TRUE;
}

//!!always called from a lock    
void 
CH323Call::OnDisengageReject(
                            IN DisengageReject* DRJ
                            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageReject entered:%p.",this ));

    if( DRJ -> requestSeqNum != m_wDRQSeqNum )
    {
        return;
    }


    if( m_dwRASCallState != RASCALL_STATE_DRQSENT ) 
    {
        return;
    }
    
    if( DRJ->rejectReason.choice == requestToDropOther_chosen )
    {
        //
        H323DBG(( DEBUG_LEVEL_ERROR, "!!something is wrong in the way DRQ is encoded.",this ));
    }
    else //if( DRJ->rejectReason.choice == DisengageRejectReason_notRegistered_chosen )
    {
        //the call has been unregistered but is still around, so dsrop it
        m_dwRASCallState = RASCALL_STATE_UNREGISTERED;
        //CloseCall( 0 );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageReject exited:%p.",this ));
}


void
CH323Call::OnRequestInProgress( 
                               IN RequestInProgress* RIP
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnRequestInProgress entered:%p.",this ));
    EXPIRE_CONTEXT * pExpireContext;

    if( RIP -> requestSeqNum != m_wARQSeqNum )
    {
        return;
    }

    if( m_dwRASCallState != RASCALL_STATE_ARQSENT ) 
    {
        return;
    }

    //if delay is more than 30 seconds ignore it
    if( (RIP->delay > 0) && (RIP->delay > 30000) )
    {
        return;
    }

    pExpireContext = new EXPIRE_CONTEXT;
    if( pExpireContext == NULL )
    {
        return;
    }
    
    //restart the timer
    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
        m_hARQTimer = NULL;
    }

    pExpireContext -> DriverCallHandle = m_hdCall;
    pExpireContext -> seqNumber = m_wARQSeqNum;

    if( !CreateTimerQueueTimer(
            &m_hARQTimer,
            H323TimerQueue,
            CH323Call::ARQExpiredCallback,
            (PVOID)pExpireContext,
            (DWORD)RIP->delay, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
    {
        //close the call        
        CloseCall( 0 );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnRequestInProgress exited:%p.",this ));
}


//!!always called from a lock
void 
CH323Call::OnDisengageConfirm(
                                IN DisengageConfirm* DCF
                             )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageConfirm entered:%p.",this ));

    if( DCF -> requestSeqNum != m_wDRQSeqNum )
    {
        return;
    }

    if( m_dwRASCallState == RASCALL_STATE_DRQSENT )
    {
        if( m_hDRQTimer != NULL )
        {
            DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer,
                NULL );
            m_hDRQTimer = NULL;
        }

        //nikhil:if this is a replacement call/diverted call then this may lead
        //to inconsistent behaviour
        m_dwRASCallState = RASCALL_STATE_UNREGISTERED;
        //CloseCall( 0 );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnDisengageConfirm exited:%p.",this ));
}


//!!always called from a lock
void 
CH323Call::OnAdmissionConfirm(
                                IN AdmissionConfirm * ACF
                             )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionConfirm entered:%p.",this ));

    _ASSERTE( m_dwRASCallState != RASCALL_STATE_IDLE );
    
    if( ACF -> requestSeqNum != m_wARQSeqNum )
    {
        return;
    }

    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, 
            NULL );
        m_hARQTimer = NULL;
        m_dwARQRetryCount = 0;
    }

    if( m_dwRASCallState == RASCALL_STATE_ARQSENT )
    {
        m_dwRASCallState = RASCALL_STATE_REGISTERED;

        if( m_dwOrigin == LINECALLORIGIN_OUTBOUND )
        {
            if( (ACF ->destCallSignalAddress.choice != ipAddress_chosen) ||
                (ACF->destCallSignalAddress.u.ipAddress.ip.length != 4) )
            {
                DropCall( LINEDISCONNECTMODE_BADADDRESS );
                return;
            }
            
            // save converted address
            m_CalleeAddr.nAddrType = H323_IP_BINARY;
            m_CalleeAddr.Addr.IP_Binary.dwAddr = 
                ntohl(*(DWORD*)(ACF->destCallSignalAddress.u.ipAddress.ip.value) );
            m_CalleeAddr.Addr.IP_Binary.wPort =
                ACF->destCallSignalAddress.u.ipAddress.port;
            m_CalleeAddr.bMulticast =
                IN_MULTICAST(m_CalleeAddr.Addr.IP_Binary.dwAddr);

            //Replaces the first alias in the callee list (the dialableAddress
            //passed in TSPI_lineMakecall ). The GK looks at the first alias
            //only. Its assumed that only the first alias is mapped by the GK.
            if( (ACF -> bit_mask & AdmissionConfirm_destinationInfo_present) &&
                ACF->destinationInfo )
            {
                MapAliasItem( m_pCalleeAliasNames,
                    &(ACF->destinationInfo->value) );
            }

            if( !PlaceCall() )
            {
                DropCall( LINEDISCONNECTMODE_UNREACHABLE );
            }
        }
        else
        {
            if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
            {
                MSPMessageData* pMSPMessageData = new MSPMessageData;
                if( pMSPMessageData == NULL )
                {
                    CloseCall( 0 );
                    return;
                }

                pMSPMessageData->hdCall = m_hdRelatedCall;
                pMSPMessageData->messageType = SP_MSG_PrepareToAnswer;
                pMSPMessageData->pbEncodedBuf = m_prepareToAnswerMsgData.pbBuffer;
                pMSPMessageData->wLength = (WORD)m_prepareToAnswerMsgData.dwLength;
                pMSPMessageData->hReplacementCall = m_hdCall;
                m_prepareToAnswerMsgData.pbBuffer = NULL;

                QueueUserWorkItem( SendMSPMessageOnRelatedCall,
                    pMSPMessageData, WT_EXECUTEDEFAULT );
            }
            else
            {

                // signal incoming call
                _ASSERTE(!m_htCall);

                PostLineEvent (
                    LINE_NEWCALL,
                    (DWORD_PTR)m_hdCall,
                    (DWORD_PTR)&m_htCall, 0);

                _ASSERTE( m_htCall );
                if( m_htCall == NULL )
                {
                    H323DBG(( DEBUG_LEVEL_ERROR, "tapi call handle NULL!!" ));
                    CloseCall( 0 );
                    return;
                }

                if( IsListEmpty(&m_IncomingU2U) == FALSE )
                {
                    // signal incoming
                    PostLineEvent (
                        LINE_CALLINFO,
                        (DWORD_PTR)LINECALLINFOSTATE_USERUSERINFO,
                        0, 0);
                }

                ChangeCallState( LINECALLSTATE_OFFERING, 0 );

                // send the new call message to the unspecified MSP
                SendMSPMessage( SP_MSG_PrepareToAnswer, 
                    m_prepareToAnswerMsgData.pbBuffer,
                    m_prepareToAnswerMsgData.dwLength, NULL );
            }

            if( m_prepareToAnswerMsgData.pbBuffer )
                delete m_prepareToAnswerMsgData.pbBuffer;
            ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

        }
    }
    else if( m_dwRASCallState == RASCALL_STATE_ARQEXPIRED )
    {
        SendDRQ( forcedDrop_chosen, NOT_RESEND_SEQ_NUM, TRUE );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionConfirm exited:%p.",this ));
}


//!!always called from a lock
void
CH323Call::OnAdmissionReject(
                            IN AdmissionReject * ARJ
                            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionReject entered:%p.",this ));

    if( ARJ -> requestSeqNum != m_wARQSeqNum )
    {
        return;
    }
    
    m_dwRASCallState = RASCALL_STATE_ARJRECVD;
    
    //If a forward consult call then enable the forwarding anyway.
    if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
        (m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
    {
        //Success of forwarding
        EnableCallForwarding();
    }
    
    //drop the call. shutdown the call and rlease the call.
    CloseCall( LINEDISCONNECTMODE_BADADDRESS );    
    
    H323DBG(( DEBUG_LEVEL_TRACE, "OnAdmissionReject exited:%p.",this ));
}


HRESULT 
CH323Call::GetCallInfo (
    OUT GUID *  ReturnCallID,
    OUT GUID *  ReturnConferenceID )
{

    //verify call state
    if( m_dwCallState == LINECALLSTATE_DISCONNECTED )
    {
        return E_FAIL;
    }

    *ReturnCallID = m_callIdentifier;
    *ReturnConferenceID = m_ConferenceID;

    return S_OK;
}

 
void
NTAPI CH323Call::DRQExpiredCallback(
    IN  PVOID   ContextParameter,   // pExpireContext
    IN  BOOLEAN TimerFired          // not used
    )             
{
    EXPIRE_CONTEXT *    pExpireContext;
    HDRVCALL            DriverCall;
    PH323_CALL          pCall;

    _ASSERTE(ContextParameter);
    pExpireContext = (EXPIRE_CONTEXT *) ContextParameter;
    _ASSERTE( pExpireContext == m_pDRQExpireContext );

    __try
    {
        DriverCall = (HDRVCALL) pExpireContext -> DriverCallHandle;

        pCall = g_pH323Line -> FindH323CallAndLock (DriverCall);
        if (pCall)
        {
            pCall -> DRQExpired (pExpireContext -> seqNumber);
            
            delete pExpireContext;
            pCall -> Unlock();
        }
        else
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "warning: DRQExpiredCallback failed to locate call object"));
        }
    }
    __except( 1 )
    {
        // The call has already been deleted and hence the pExpireContext
        // buffer is also deleted.
        return;
    }
}


void
NTAPI CH323Call::ARQExpiredCallback(
    IN  PVOID   ContextParameter,       // pExpireContext
    IN  BOOLEAN TimerFired)             // not used
{
    EXPIRE_CONTEXT *    pExpireContext;
    HDRVCALL            DriverCall;
    PH323_CALL          pCall;

    _ASSERTE(ContextParameter);
    pExpireContext = (EXPIRE_CONTEXT *) ContextParameter;
    _ASSERTE( pExpireContext == m_pARQExpireContext );

    
    __try
    {
        DriverCall = (HDRVCALL) pExpireContext -> DriverCallHandle;

        pCall = g_pH323Line -> FindH323CallAndLock (DriverCall);
        if (pCall)
        {
            pCall -> ARQExpired (pExpireContext -> seqNumber);
        
            delete pExpireContext;
            pCall -> Unlock();
            
        }
        else
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "warning: ARQExpiredCallback failed to locate call object"));
        }
    }
    __except( 1 )
    {
        // The call has already been deleted and hence the pExpireContext
        // buffer is also deleted.
        return;
    }
}


//!!always called from a lock
void CH323Call::ARQExpired (
    IN  WORD    seqNumber)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "ARQExpired entered:%p.",this ));
    
    m_pARQExpireContext = NULL;
    
    if( m_hARQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
        m_hARQTimer = NULL;
    }

    if( m_dwRASCallState == RASCALL_STATE_ARQSENT )
    {
        if( m_dwARQRetryCount < ARQ_RETRY_MAX )
        {
            if( !SendARQ( (long)seqNumber ) )
            {
                // drop call using disconnect mode
                DropCall(0);
            }
        }
        else
        {
            m_dwRASCallState = RASCALL_STATE_ARQEXPIRED;
            //Not able to register, shutdown the RAS client object
            CloseCall( 0 );        
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "ARQExpired exited:%p.",this ));
}


//!!always called from a lock
void
CH323Call::DRQExpired(
                        IN WORD seqNumber
                     )
{    
    H323DBG(( DEBUG_LEVEL_TRACE, "DRQExpired entered:%p.", this ));
    m_pDRQExpireContext = NULL;
    
    if( m_hDRQTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer, NULL );
        m_hDRQTimer = NULL;
    }

    if( m_dwRASCallState == RASCALL_STATE_DRQSENT )
    {
        if( m_dwDRQRetryCount < DRQ_RETRY_MAX )
        {
            if( !SendDRQ( forcedDrop_chosen, (long)seqNumber, TRUE ) )
            {
                // drop call using disconnect mode
                DropCall(0);
            }
        }
        else
        {
            m_dwRASCallState = RASCALL_STATE_DRQEXPIRED;
            //Not able to register, shutdown the RAS client object
            CloseCall( 0 );
        }
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "DRQExpired exited:%p.",this ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\registry.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    Routines for reading registry configuration.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "ras.h"
#include "q931obj.h"

//
// Macro definitions
//

#define GK_PORT				            1719
#define EVENTLOG_SERVICE_APP_KEY_PATH	_T("System\\CurrentControlSet\\Services\\EventLog\\Application")
#define EVENTLOG_MESSAGE_FILE			_T("EventMessageFile")
#define EVENTLOG_TYPES_SUPPORTED		_T("TypesSupported")
#define EVENT_SOURCE_TYPES_SUPPORTED    7
#define H323_TSP_MODULE_NAME            _T("H323.TSP")

//                                                                           
// Global variables                                                          
//                                                                           

extern Q931_LISTENER		            Q931Listener;

H323_REGISTRY_SETTINGS                  g_RegistrySettings;

static	HKEY		                    g_RegistryKey = NULL;
static	HANDLE		                    g_RegistryNotifyEvent = NULL;

// RTL thread pool wait handle
static	HANDLE		                    g_RegistryNotifyWaitHandle = NULL;		


static void NTAPI RegistryNotifyCallback (
	IN	PVOID	ContextParameter,
	IN	BOOLEAN	TimerFired);

static BOOL H323GetConfigFromRegistry (void);



//                                                                           
// Public procedures                                                         
//                                                                           


/*++

Routine Description:
    
    Changes configuration settings back to defaults.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

static BOOL RegistrySetDefaultConfig(void)
{
    //initialize alerting timeout to default
    g_RegistrySettings.dwQ931AlertingTimeout = CALL_ALERTING_TIMEOUT;

    //initialize call signalling port to default
    g_RegistrySettings.dwQ931ListenPort= Q931_CALL_PORT;

    // success
    return TRUE;
}

static LONG RegistryRequestNotify(void)
{
    return RegNotifyChangeKeyValue (
        g_RegistryKey,                  // key to watch
        FALSE,                          // do not watch subtree
        REG_NOTIFY_CHANGE_LAST_SET,     // notify filter
        g_RegistryNotifyEvent,          // notification event
        TRUE);                          // is asychnronous
}


HRESULT RegistryStart(void)
{
    LONG    lStatus;
    DWORD   dwResult;
    HKEY    regKeyService;
    HKEY    hKey;
    DWORD   dwValue;
                    
    if( g_RegistryKey != NULL )
    {
        return TRUE;
    }

    RegistrySetDefaultConfig();

    lStatus = RegCreateKeyEx (
        HKEY_LOCAL_MACHINE,
        H323_REGKEY_ROOT,
        0, WIN31_CLASS, 0,
        KEY_READ, NULL,
        &g_RegistryKey, NULL);

    if( lStatus != ERROR_SUCCESS )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "configuration registry key could not be opened/created" ));
        DumpError (lStatus);

        return E_FAIL;
    }

    // load initial configuration
    H323GetConfigFromRegistry();


    g_RegistryNotifyEvent = NULL;
    g_RegistryNotifyWaitHandle = NULL;

    g_RegistryNotifyEvent = H323CreateEvent (NULL, FALSE, FALSE, 
        _T( "H323TSP_RegistryNotifyEvent" ) );

    if( g_RegistryNotifyEvent != NULL )
    {

        lStatus = RegistryRequestNotify();

        if( lStatus == ERROR_SUCCESS )
        {
            if (RegisterWaitForSingleObject (
                &g_RegistryNotifyWaitHandle,
                g_RegistryNotifyEvent,
                RegistryNotifyCallback,
                NULL, INFINITE, WT_EXECUTEDEFAULT))
            {

                _ASSERTE( g_RegistryNotifyWaitHandle );
                // ready
            }
            else
            {
                // failed to registry wait
                H323DBG(( DEBUG_LEVEL_ERROR, 
                    "failed to callback for registry notification" ));
                DumpError (lStatus);

                g_RegistryNotifyWaitHandle = NULL;
            }
        }
        else
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "failed to request notification on registry changes" ));
            DumpError (lStatus);
        }
    }
    else
    {
        // although this is an error, we continue anyway.
        // we just won't be able to receive notification of registry changes.

        H323DBG(( DEBUG_LEVEL_ERROR, 
            "failed to create event, cannot receive registry notification events" ));
    }

    //Eventlog params
    lStatus = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        EVENTLOG_SERVICE_APP_KEY_PATH,
        0,
        KEY_CREATE_SUB_KEY,
        &regKeyService );

    if( lStatus == ERROR_SUCCESS )
    {
        lStatus = RegCreateKey(
            regKeyService,
            H323TSP_EVENT_SOURCE_NAME,
            &hKey );

        RegCloseKey( regKeyService );
        regKeyService = NULL;
        
        if( lStatus == ERROR_SUCCESS )
        {
            TCHAR wszModulePath[MAX_PATH+1];

            dwResult = GetModuleFileName(
                GetModuleHandle( H323_TSP_MODULE_NAME ),
                wszModulePath, MAX_PATH );
            
            if( dwResult != 0 )
            {
                // query for registry value
                lStatus = RegSetValueEx(
                            hKey,
                            EVENTLOG_MESSAGE_FILE,
                            0,
                            REG_SZ,
                            (LPBYTE)wszModulePath,
                            H323SizeOfWSZ(wszModulePath) );

                // validate return code
                if( lStatus == ERROR_SUCCESS )
                {
                    dwValue = EVENT_SOURCE_TYPES_SUPPORTED;
                    // query for registry value
                    lStatus = RegSetValueEx(
                                hKey,
                                EVENTLOG_TYPES_SUPPORTED,
                                0,
                                REG_DWORD,
                                (LPBYTE)&dwValue,
                                sizeof(DWORD) );

                    if( lStatus == ERROR_SUCCESS )
                    {
                        // connect to event logging service
                        g_hEventLogSource = RegisterEventSource( NULL,
                            H323TSP_EVENT_SOURCE_NAME );
                    }
                }
            }
        }

        RegCloseKey( hKey );
        hKey = NULL;
    }

    return S_OK;
}


    
void RegistryStop(void)
{
    HKEY hKey;
    LONG lStatus;
    H323DBG ((DEBUG_LEVEL_TRACE, "RegistryStop Entered"));

    if (g_RegistryNotifyWaitHandle)
    {
        UnregisterWaitEx( g_RegistryNotifyWaitHandle, (HANDLE) -1 );
        g_RegistryNotifyWaitHandle = NULL;
    }

    if (g_RegistryNotifyEvent)
    {
        CloseHandle (g_RegistryNotifyEvent);
        g_RegistryNotifyEvent = NULL;
    }

    if (g_RegistryKey)
    {
        RegCloseKey (g_RegistryKey);
        g_RegistryKey = NULL;
    }

    //Eventlog params
    lStatus = RegOpenKeyEx (    
        HKEY_LOCAL_MACHINE,
        EVENTLOG_SERVICE_APP_KEY_PATH,
        0,
        KEY_CREATE_SUB_KEY,
        &hKey );

    if( lStatus==ERROR_SUCCESS )
    {
        RegDeleteKey( hKey, H323TSP_EVENT_SOURCE_NAME);
        RegCloseKey( hKey );
        hKey = NULL;
    }

    g_RegistrySettings.dwQ931ListenPort = 0;

    H323DBG ((DEBUG_LEVEL_TRACE, "RegistryStop Exited"));
}



static DWORD inet_addrW(
    IN  LPTSTR String
    )
{
    CHAR    AnsiString  [0x21];
    INT     Length;

    Length = WideCharToMultiByte (CP_ACP, 0, String, -1, AnsiString, 0x20, NULL, NULL);
    AnsiString [Length] = 0;

    return inet_addr (AnsiString);
}

static HOSTENT * gethostbynameW (LPTSTR String)
{
    CHAR    AnsiString  [0x21];
    INT     Length;

    Length = WideCharToMultiByte (CP_ACP, 0, String, -1, AnsiString, 0x20, NULL, NULL);
    AnsiString [Length] = 0;

    return gethostbyname (AnsiString);
}

static BOOL H323GetConfigFromRegistry (void)
    
/*++

Routine Description:
    
    Loads registry settings for service provider.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    LONG    lStatus = ERROR_SUCCESS;
    TCHAR    szAddr[H323_MAXDESTNAMELEN];
    DWORD   dwValue;
    DWORD   dwValueSize;
    DWORD   dwValueType;
    LPTSTR   pszValue;

    // see if key open
    if( g_RegistryKey == NULL )
    {
        return FALSE;
    }

    // initialize value name
    pszValue = H323_REGVAL_DEBUGLEVEL;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
        g_RegistryKey,
        pszValue,
        NULL,
        &dwValueType,
        (LPBYTE)&g_RegistrySettings.dwLogLevel,
        &dwValueSize
        );

    // validate return code
    if( lStatus != ERROR_SUCCESS )
    {
        // copy default value into global settings
        g_RegistrySettings.dwLogLevel = DEBUG_LEVEL_FORCE;
    }

    // initialize value name
    pszValue = H323_REGVAL_Q931LISTENPORT;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwQ931ListenPort,
                &dwValueSize
                );                    

    // validate return code
    if( (lStatus == ERROR_SUCCESS) && 
        (g_RegistrySettings.dwQ931ListenPort >=1000) &&
        (g_RegistrySettings.dwQ931ListenPort <= 32000)
      )
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
                  "using Q931 listen portof %d.",
                  g_RegistrySettings.dwQ931ListenPort ));
    } 
    else 
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "using default Q931 timeout." ));

        // copy default value into global settings
        g_RegistrySettings.dwQ931ListenPort = Q931_CALL_PORT;
    }   

    // initialize value name
    pszValue = H323_REGVAL_Q931ALERTINGTIMEOUT;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&g_RegistrySettings.dwQ931AlertingTimeout,
                &dwValueSize
                );                    

    // validate return code
    if( (lStatus == ERROR_SUCCESS) && 
        (g_RegistrySettings.dwQ931AlertingTimeout >=30000) &&
        (g_RegistrySettings.dwQ931AlertingTimeout <= CALL_ALERTING_TIMEOUT)
      )
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
                  "using Q931 timeout of %d milliseconds.",
                  g_RegistrySettings.dwQ931AlertingTimeout ));
    } 
    else 
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "using default Q931 timeout." ));

        // copy default value into global settings
        g_RegistrySettings.dwQ931AlertingTimeout = CALL_ALERTING_TIMEOUT;
    }   
    
    // initialize value name
    pszValue = H323_REGVAL_GATEWAYADDR;

    // initialize type 
    dwValueType = REG_SZ;
    dwValueSize = sizeof(szAddr);

    // initialize ip address
    dwValue = INADDR_NONE;

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (unsigned char*)szAddr,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // convert ip address
        dwValue = inet_addrW(szAddr);

        // see if address converted
        if( dwValue == INADDR_NONE )
        {
            struct hostent * pHost;

            // attempt to lookup hostname
            pHost = gethostbynameW(szAddr);

            // validate pointer
            if (pHost != NULL)
            {
                // retrieve host address from structure
                dwValue = *(unsigned long *)pHost->h_addr;
            }
        }
    }

    // see if address converted and check for null
    if ((dwValue > 0) && (dwValue != INADDR_NONE) )
    {
        // save new gateway address in registry structure
        g_RegistrySettings.gatewayAddr.nAddrType = H323_IP_BINARY;
        g_RegistrySettings.gatewayAddr.Addr.IP_Binary.dwAddr = ntohl(dwValue);
        g_RegistrySettings.gatewayAddr.Addr.IP_Binary.wPort =
            LOWORD(g_RegistrySettings.dwQ931ListenPort);
        g_RegistrySettings.gatewayAddr.bMulticast =
            IN_MULTICAST(g_RegistrySettings.gatewayAddr.Addr.IP_Binary.dwAddr);

        H323DBG((
            DEBUG_LEVEL_TRACE,
            "gateway address resolved to %s.",
            H323AddrToString(dwValue)
            ));

    } 
    else 
    {
        // clear memory used for gateway address
        memset( (PVOID) &g_RegistrySettings.gatewayAddr,0,sizeof(H323_ADDR));
    }

    // initialize value name
    pszValue = H323_REGVAL_GATEWAYENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGatewayEnabled = (dwValue != 0);

    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGatewayEnabled = FALSE;
    }

    // initialize value name
    pszValue = H323_REGVAL_PROXYADDR;

    // initialize type 
    dwValueType = REG_SZ;
    dwValueSize = sizeof(szAddr);

    // initialize ip address
    dwValue = INADDR_NONE;

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (unsigned char*)szAddr,
                &dwValueSize
                );                    
    
    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // convert ip address
        dwValue = inet_addrW(szAddr);

        // see if address converted
        if( dwValue == INADDR_NONE )
        {
            struct hostent * pHost;

            // attempt to lookup hostname
            pHost = gethostbynameW(szAddr);

            // validate pointer
            if (pHost != NULL)
            {
                // retrieve host address from structure
                dwValue = *(unsigned long *)pHost->h_addr;
            }
        }
    }

    // see if address converted
    if( (dwValue > 0) && (dwValue != INADDR_NONE) ) 
    {
        // save new gateway address in registry structure
        g_RegistrySettings.proxyAddr.nAddrType = H323_IP_BINARY;
        g_RegistrySettings.proxyAddr.Addr.IP_Binary.dwAddr = ntohl(dwValue);
        g_RegistrySettings.proxyAddr.Addr.IP_Binary.wPort =
            LOWORD(g_RegistrySettings.dwQ931ListenPort);
        g_RegistrySettings.proxyAddr.bMulticast =
            IN_MULTICAST(g_RegistrySettings.proxyAddr.Addr.IP_Binary.dwAddr);

        H323DBG(( DEBUG_LEVEL_TRACE,
                  "proxy address resolved to %s.",
                  H323AddrToString(dwValue) ));
    } 
    else 
    {
        // clear memory used for gateway address
        memset( (PVOID)&g_RegistrySettings.proxyAddr,0,sizeof(H323_ADDR));
    }

    // initialize value name
    pszValue = H323_REGVAL_PROXYENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );                    

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsProxyEnabled = (dwValue != 0);

    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsProxyEnabled = FALSE;
    }

    /////////////////////////////////////////////////////////////////////////
                    //Read the GK address
    ////////////////////////////////////////////////////////////////////////

    // initialize value name
    pszValue = H323_REGVAL_GKENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGKEnabled = (dwValue != 0);
    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGKEnabled = FALSE;
    }

    if( g_RegistrySettings.fIsGKEnabled )
    {
        // initialize value name
        pszValue = H323_REGVAL_GKADDR;

        // initialize type 
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // initialize ip address
        dwValue = INADDR_NONE;

        // query for registry value
        lStatus = RegQueryValueEx(
                    g_RegistryKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (unsigned char*)szAddr,
                    &dwValueSize
                    );
    
        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            //convert ip address
            dwValue = inet_addrW(szAddr);

            // see if address converted
            if( dwValue == INADDR_NONE )
            {
                struct hostent * pHost;

                // attempt to lookup hostname
                pHost = gethostbynameW(szAddr);

                // validate pointer
                if (pHost != NULL)
                {
                    // retrieve host address from structure
                    dwValue = *(unsigned long *)pHost->h_addr;
                }
            }
        }

        // see if address converted and check for null
        if( (dwValue > 0) && (dwValue != INADDR_NONE) )
        {
            // save new gateway address in registry structure
            g_RegistrySettings.saGKAddr.sin_family = AF_INET;
            g_RegistrySettings.saGKAddr.sin_addr.s_addr = dwValue;
            g_RegistrySettings.saGKAddr.sin_port = htons( GK_PORT );

            H323DBG(( DEBUG_LEVEL_TRACE,
                "gatekeeper address resolved to %s.", H323AddrToString(dwValue) ));
        } 
        else
        {
            // clear memory used for gateway address
            memset( (PVOID) &g_RegistrySettings.saGKAddr,0,sizeof(SOCKADDR_IN));
            g_RegistrySettings.fIsGKEnabled = FALSE;
        }
    }
    /////////////////////////////////////////////////////////////////////////
                    //Read the GK log on phone number
    ////////////////////////////////////////////////////////////////////////
    
    // initialize value name
    pszValue = H323_REGVAL_GKLOGON_PHONEENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGKLogOnPhoneEnabled = (dwValue != 0);
    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGKLogOnPhoneEnabled = FALSE;
    }

    if( g_RegistrySettings.fIsGKLogOnPhoneEnabled )
    {
        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_PHONE;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = H323_MAXDESTNAMELEN * sizeof (TCHAR);

        // query for registry value
        lStatus = RegQueryValueEx(
                    g_RegistryKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE) g_RegistrySettings.wszGKLogOnPhone,
                    &dwValueSize
                    );
    
        // validate return code
        if( (lStatus!=ERROR_SUCCESS) || 
            (dwValueSize > sizeof(szAddr)) )
        {
            memset( (PVOID) g_RegistrySettings.wszGKLogOnPhone, 0,
                sizeof(g_RegistrySettings.wszGKLogOnPhone));
            g_RegistrySettings.fIsGKLogOnPhoneEnabled = FALSE;
        }
        else
        {
           g_RegistrySettings.fIsGKLogOnPhoneEnabled = TRUE;
        }
    }

    /////////////////////////////////////////////////////////////////////////
                    //Read the GK log on acct name
    ////////////////////////////////////////////////////////////////////////
    
    // initialize value name
    pszValue = H323_REGVAL_GKLOGON_ACCOUNTENABLED;

    // initialize type 
    dwValueType = REG_DWORD;
    dwValueSize = sizeof(DWORD);

    // query for registry value
    lStatus = RegQueryValueEx(
                g_RegistryKey,
                pszValue,
                NULL,
                &dwValueType,
                (LPBYTE)&dwValue,
                &dwValueSize
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        // if value non-zero then gateway address enabled
        g_RegistrySettings.fIsGKLogOnAccountEnabled = (dwValue != 0);
    } 
    else 
    {
        // copy default value into settings
        g_RegistrySettings.fIsGKLogOnAccountEnabled = FALSE;
    }

    if( g_RegistrySettings.fIsGKLogOnAccountEnabled  )
    {
        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_ACCOUNT;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = H323_MAXDESTNAMELEN * sizeof (TCHAR);

        // initialize ip address
        dwValue = INADDR_NONE;

        // query for registry value
        lStatus = RegQueryValueEx(
                    g_RegistryKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE) g_RegistrySettings.wszGKLogOnAccount,
                    &dwValueSize
                    );
    
        // validate return code
        if( (lStatus!=ERROR_SUCCESS) || 
            (dwValueSize > sizeof(g_RegistrySettings.wszGKLogOnPhone)) )
        
        {
            memset( (PVOID) g_RegistrySettings.wszGKLogOnAccount, 0,
                sizeof(g_RegistrySettings.wszGKLogOnAccount));
            g_RegistrySettings.fIsGKLogOnAccountEnabled = FALSE;
        }
        else
        {
            g_RegistrySettings.fIsGKLogOnAccountEnabled = TRUE;
        }

    }
    
    // success
    return TRUE;
}


static void NTAPI RegistryNotifyCallback (
    IN  PVOID   ContextParameter,
    IN  BOOLEAN TimerFired
    )
{
    H323DBG ((DEBUG_LEVEL_TRACE, "registry notify event enter."));

    // refresh registry settings
    H323GetConfigFromRegistry();

    //if the gatekeeper has been enabled or disabled or changed then 
    //send RRQ and URQ as required
    //if the alias list has been changed then update the gatekeeper 
    //alias list
    RasHandleRegistryChange();

    //Listen on the new port number if changed.
    Q931Listener.HandleRegistryChange();

    RegistryRequestNotify();

    H323DBG ((DEBUG_LEVEL_TRACE, "registry notify event exit."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\ras.h ===
#ifndef _RAS_H_
#define _RAS_H_

#define  REG_RETRY_MAX                      3
#define  URQ_RETRY_MAX                      2
#define  ARQ_RETRY_MAX                      3
#define  DRQ_RETRY_MAX                      3
#define  RASIO_SEND_BUFFER_LIST_MAX         10
#define  REG_EXPIRE_TIME                    4000
#define  ARQ_EXPIRE_TIME                    4000


#define  NOT_RESEND_SEQ_NUM                 -1

//(127.0.0.1 in network byte order)
#define  NET_LOCAL_IP_ADDR_INTERFACE        0x0100007F

//(127.0.0.1 in host byte order)
#define  HOST_LOCAL_IP_ADDR_INTERFACE       0x7F000001

extern	const	ASN1objectidentifier_s	    _OID_H225ProtocolIdentifierV1 [];
extern	const	ASN1objectidentifier_s	    _OID_H225ProtocolIdentifierV2 [];

#define	OID_H225ProtocolIdentifierV1	    const_cast<ASN1objectidentifier_s *> (_OID_H225ProtocolIdentifierV1);
#define	OID_H225ProtocolIdentifierV2	    const_cast<ASN1objectidentifier_s *> (_OID_H225ProtocolIdentifierV2);

#undef	OID_ELEMENT
#define	OID_RasProtocolIdentifierV2	        (ASN1objectidentifier_s *)_OID_RasProtocolIdentifierV2


class	RAS_CLIENT;

struct EXPIRE_CONTEXT
{
    WORD			seqNumber;
	union
    {
	    HDRVCALL		DriverCallHandle;
	    RAS_CLIENT *	RasClient;
	};
};

typedef struct _ALIASCHANGE_REQUEST
{
    LIST_ENTRY          listEntry;
    ENDPOINT_ID         rasEndpointID;
    WORD                wRequestSeqNum;
    PH323_ALIASNAMES    pAliasList;

} ALIASCHANGE_REQUEST, *PALIASCHANGE_REQUEST;


#define REG_TTL_MARGIN      2

enum RAS_CLIENT_STATE
{
	RAS_CLIENT_STATE_NONE = 0,
	RAS_CLIENT_STATE_INITIALIZED
};


//If the app wants to send an URQ but the TSP ihasn't received RCF yet then we
//the information in this struct and send URQ when we get RCF.
typedef struct _PENDINGURQ
{
    WORD    RRQSeqNumber;
} PENDINGURQ;


enum RAS_REGISTER_STATE
{
	RAS_REGISTER_STATE_IDLE = 0,
	RAS_REGISTER_STATE_RRQSENT,
	RAS_REGISTER_STATE_RRQEXPIRED,
	RAS_REGISTER_STATE_REGISTERED,
	RAS_REGISTER_STATE_URQSENT,
	RAS_REGISTER_STATE_URQEXPIRED,
	RAS_REGISTER_STATE_UNREGISTERED,
	RAS_REGISTER_STATE_RRJ,
	RAS_REGISTER_STATE_URQRECVD,
};


class RAS_CLIENT
{

private:
    HANDLE              m_hRegTimer;
    HANDLE              m_hUnRegTimer;
    HANDLE              m_hRegTTLTimer;
    PH323_ALIASNAMES    m_pAliasList;//list of all the aliases registered with this list
    SOCKET              m_Socket;
    CRITICAL_SECTION    m_CriticalSection;
    RAS_REGISTER_STATE	m_RegisterState;
    DWORD               m_IoRefCount;
    RAS_CLIENT_STATE	m_dwState;
    LIST_ENTRY          m_sendFreeList;
    LIST_ENTRY          m_sendPendingList;
    DWORD               m_dwSendFreeLen;
    SOCKADDR_IN         m_GKAddress;
    SOCKADDR_IN         m_sockAddr;
    TransportAddress    m_transportAddress;
    RAS_RECV_CONTEXT    m_recvOverlapped;
    WORD                m_lastRegisterSeqNum;
    WORD                m_wTTLSeqNumber;
    WORD                m_UnRegisterSeqNum;
    WORD                m_wRASSeqNum;
    DWORD               m_dwRegRetryCount;
    DWORD               m_dwUnRegRetryCount;
    DWORD               m_dwCallsInProgress;
    ENDPOINT_ID         m_RASEndpointID;
    ASN1_CODER_INFO     m_ASNCoderInfo;
    PENDINGURQ          m_PendingURQ;
    DWORD               m_dwRegTimeToLive;
    EXPIRE_CONTEXT*     m_pRRQExpireContext;
    EXPIRE_CONTEXT*     m_pURQExpireContext;
    LIST_ENTRY          m_aliasChangeRequestList;

    
    
    RAS_SEND_CONTEXT *AllocSendBuffer();
    void FreeSendBuffer( RAS_SEND_CONTEXT * pBuffer );
    void OnInfoRequest( InfoRequest * IRQ );
    void ProcessRasMessage(IN RasMessage *rasMessage );
    void OnUnregistrationConfirm( IN UnregistrationConfirm *UCF );
    void OnUnregistrationReject( IN UnregistrationReject *URJ );
    void OnRegistrationReject( IN RegistrationReject *	RRJ );
    void OnRegistrationConfirm( IN RegistrationConfirm * RCF );
    BOOL InitializeIo();
    BOOL IssueRecv();
    int TermASNCoder(void);
    int InitASNCoder(void);
    BOOL SendUCF( WORD seqNumber );
    BOOL SendURJ( WORD seqNumber, DWORD dwReason );
    void OnUnregistrationRequest( IN UnregistrationRequest *URQ );
    BOOL FreeSendList( PLIST_ENTRY pListHead );
    BOOL InitializeTTLTimer( IN RegistrationConfirm * RCF );

	HRESULT	SendInfoRequestResponse(
		IN	SOCKADDR_IN *			RasAddress,
		IN	USHORT					SequenceNumber,
		IN	InfoRequestResponse_perCallInfo *	CallInfoList);

	HRESULT	EncodeSendMessage(
		IN	RasMessage * rasMessage );


public:
    RAS_CLIENT();
    
    ~RAS_CLIENT();

    void Lock()
    {
        H323DBG((DEBUG_LEVEL_TRACE, "wait on RAS client lock:%p.", this ));
        EnterCriticalSection( &m_CriticalSection );
        H323DBG((DEBUG_LEVEL_TRACE, "RAS client locked: %p.", this ));
    }

    void Unlock()
    {
        LeaveCriticalSection( &m_CriticalSection );
        H323DBG((DEBUG_LEVEL_TRACE, "RAS client unlocked: %p.", this ));
    }
     
    WORD GetNextSeqNum()
    {
        WORD wSeqNum;
        Lock();
        wSeqNum = ++m_wRASSeqNum;
        if( wSeqNum == 0 )
            wSeqNum = ++m_wRASSeqNum;
        Unlock();
        return wSeqNum;
    }

    RAS_REGISTER_STATE GetRegState()
    {
        return m_RegisterState;
    }

    HRESULT	GetEndpointID	(
		OUT	ASN1char16string_t *	ReturnEndpointID);

	HRESULT	GetLocalAddress	(
		OUT	SOCKADDR_IN *	ReturnSocketAddress)
	{
		HRESULT		hr;

		Lock();

		if (m_RegisterState == RAS_REGISTER_STATE_REGISTERED)
        {
			*ReturnSocketAddress = m_sockAddr;
			hr = S_OK;
		}
		else
        {
			hr = E_FAIL;
		}

		Unlock();

		return hr;
	}

    PH323_ALIASNAMES
    GetRegisteredAliasList()
    {
        return m_pAliasList;
    }
        
    BOOL Initialize( SOCKADDR_IN* psaGKAddr );
    void Shutdown();
    static void NTAPI RegExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI UnregExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI TTLExpiredCallback( IN PVOID dwParam1, IN BOOLEAN bTimer );

    BOOL SendRRQ( IN long seqNumber, IN PALIASCHANGE_REQUEST pAliasList );
    BOOL SendURQ( long seqNumber, EndpointIdentifier * pEndpointID );

    void RegExpired( WORD seqNumber );
    void UnregExpired( WORD seqNumber );
    void TTLExpired();
    static void NTAPI IoCompletionCallback(IN DWORD dwStatus, IN DWORD cbTransferred,
        IN LPOVERLAPPED pOverlapped );
    void OnSendComplete( IN DWORD dwStatus, RAS_SEND_CONTEXT *pOverlappedSend );
    void OnRecvComplete( IN DWORD dwStatus, RAS_RECV_CONTEXT * pOverlappedRecv );

    void HandleRegistryChange();

    BOOL IssueSend( RasMessage * pRasMessage )
    {
		return EncodeSendMessage (pRasMessage) == S_OK;
	}
};

void 
HandleRASCallMessage(
    IN RasMessage *pRasMessage
);


HRESULT	RasStart	(void);

void	RasStop		(void);

HRESULT	RasSetAliasList (
	IN	AliasAddress *	AliasArray,
	IN	DWORD			Count);

BOOL	RasIsRegistered	(void);

HRESULT	RasGetLocalAddress	(
	OUT	SOCKADDR_IN *	ReturnLocalAddress);

USHORT	RasAllocSequenceNumber			(void);

HRESULT	RasGetEndpointID	(
	OUT	EndpointIdentifier *	ReturnEndpointID);

HRESULT	RasEncodeSendMessage (
	IN	RasMessage *			RasMessage);

PH323_ALIASNAMES RASGetRegisteredAliasList();
void RasHandleRegistryChange();



#endif //_RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\tspicall.cpp ===
#include "globals.h"
#include "line.h"
#include "q931pdu.h"
#include "q931obj.h"
#include "ras.h"



//
// TSPI procedures
//
// This file contains all of the TSPI export functions that act directly on calls.
//


/*++
Parameters
	
	  hdCall - The handle to the call whose application-specific field is to be
			set. The call state of hdCall can be any state. 
	
	  dwAppSpecific - The new content of the dwAppSpecific member for the call's
		LINECALLINFO structure. This value is uninterpreted by the service
		provider. This parameter is not validated by TAPI when this function is called. 

  
Return Values
	Returns zero if the function succeeds, or an error number if an error
	occurs. Possible return values are as follows: 

		LINEERR_INVALCALLHANDLE, 
		LINEERR_OPERATIONFAILED, 
		LINEERR_NOMEM, 
		LINEERR_RESOURCEUNAVAIL, 
		LINEERR_OPERATIONUNAVAIL. 

Routine Description:
	The application-specific field in the LINECALLINFO data structure that 
	exists for each call is uninterpreted by the Telephony API or any of its
	service providers. Its usage is entirely defined by the applications. The
	field can be read from the LINECALLINFO record returned by 
	TSPI_lineGetCallInfo. However, TSPI_lineSetAppSpecific must be used to set
	the field so that changes become visible to other applications. When this
	field is changed, the service provider sends a LINE_CALLINFO message with
	an indication that the AppSpecific field has changed.

++*/

LONG
TSPIAPI 
TSPI_lineSetAppSpecific(
  HDRVCALL hdCall,     
  DWORD dwAppSpecific  
)
{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetAppSpecific - Entered." ));

    //this function locks the call
    pCall = g_pH323Line -> FindH323CallAndLock( hdCall );

    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    pCall -> SetAppSpecific( dwAppSpecific );

    pCall -> Unlock();    
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetAppSpecific - Exited." ));

    // success
    return ERROR_SUCCESS;
}


LONG TSPIAPI TSPI_lineSetCallData(
  DRV_REQUESTID dwRequestID,  
  HDRVCALL hdCall,            
  LPVOID lpCallData,          
  DWORD dwSize                
)
{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetCallData - Entered." ));

    //This function locks the call
    pCall = g_pH323Line -> FindH323CallAndLock( hdCall );

    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( !pCall -> SetCallData( lpCallData, dwSize ) )
    {
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }

    pCall -> PostLineEvent( LINE_CALLINFO,
        LINECALLINFOSTATE_CALLDATA,
        0,
        0 );

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetCallData - Exited." ));
    
    // success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID     dwRequestID,  
    HDRVCALL          hdCall,
    LPCSTR            pUserUserInfo,
    DWORD             dwSize
    )
    
/*++

Routine Description:

    This function answers the specified offering call.

    When a new call arrives, the Service Provider sends the TAPI DLL a 
    LINE_NEWCALL event to exchange opaque handles for the call.  The Service 
    Provider follows this with a LINE_CALLSTATE message inform the TAPI DLL 
    and its client applications of the call's call state.  The TAPI DLL 
    typically answers this call (on behalf of an application) using 
    TSPI_lineAnswer.  After the call has been successfully answered, the call 
    will typically transition to the connected state.
    
    In some telephony environments (like ISDN) where user alerting is separate 
    from call offering, the TAPI DLL and its client apps may have the option to 
    first accept a call prior to answering, or instead to reject or redirect 
    the offering call.
    
    If a call comes in (is offered) at the time another call is already active, 
    then the new call is connected to by invoking TSPI_lineAnswer. The effect 
    this has on the existing active call depends on the line's device 
    capabilities. The first call may be unaffected, it may automatically be 
    dropped, or it may automatically be placed on hold. The appropriate 
    LINE_CALLSTATE messages will report state transitions to the TAPI DLL about 
    both calls.
    
    The TAPI DLL has the option to send user-to-user information at the time of 
    the answer. Even if user-to-user information can be sent, often no 
    guarantees are made that the network will deliver this information to the 
    calling party. The TAPI DLL can consult a line's device capabilities to 
    determine whether or not sending user-to-user information on answer is 
    available.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        answered.  Valid call states: offering, accepted.

    pUserUserInfo - Specifies a far pointer to a string containing 
        user-to-user information to be sent to the remote party at the time of 
        answering the call. If this pointer is NULL, it indicates that no 
        user-to-user information is to be sent. User-to-user information is 
        only sent if supported by the underlying network (see LINEDEVCAPS).

    dwSize - Specifies the size in bytes of the user-to-user information in 
        pUserUserInfo. If pUserUserInfo is NULL, no user-to-user 
        information is sent to the calling party and dwSize is ignored.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative 
    error number if an error has occurred.  Possible error returns are:  
    
        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    PH323_CALL  pCall;
    DWORD       dwCallState;
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineAnswer - Entered." ));

    //this function locks the call
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // see if call in offering state
    dwCallState = pCall -> GetCallState();
    if( ( dwCallState & LINECALLSTATE_OFFERING) == 0 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "call 0x%08lx cannot be accepted state 0x%08lx.",
            pCall,
            pCall -> GetCallState()));

        pCall -> Unlock();
        // invalid call state
        return LINEERR_INVALCALLSTATE;
    }

    // save outgoing user user information (if specified)
    if( !pCall -> AddU2U( U2U_OUTBOUND, dwSize, (PBYTE)pUserUserInfo) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not save user user info." ));

        pCall -> Unlock();
        // no memory available
        return LINEERR_NOMEM;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_ANSWER_CALL, NULL) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not post place call message." ));

        //drop the call
        pCall -> CloseCall( 0 );
        
        pCall -> Unlock();
        // could not complete operation
        return LINEERR_OPERATIONFAILED;
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineAnswer - Exited." ));
        
    pCall -> Unlock();    
    // async success                        
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL hdCall
    )
    
/*++

Routine Description:

    This function deletes the call after completing or aborting all outstanding
    asynchronous operations on the call.

    The Service Provider has the responsibility to (eventually) report 
    completion for every operation it decides to execute asynchronously.  
    If this procedure is called for a call on which there are outstanding 
    asynchronous operations, the operations should be reported complete with an 
    appropriate result or error code before this procedure returns.  If there 
    is an active call on the line at the time of TSPI_lineCloseCall, the call 
    must be dropped.  Generally the TAPI DLL would wait for calls to be 
    finished and asynchronous operations to complete in an orderly fashion.  
    However, the Service Provider should be prepared to handle an early call to
    TSPI_lineCloseCall in "abort" or "emergency shutdown" situations.

    After this procedure returns the Service Provider must report no further 
    events on the call.  The Service Provider's opaque handle for the call 
    becomes "invalid".

    This function is presumed to complete successfully and synchronously.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        deleted.  After the call has been successfully deleted, this handle is 
        no longer valid.  Valid call states: any.

Return Values:

    None.  
    
--*/

{
    PH323_CALL pCall;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseCall - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "call already deleted." ));
        //return LINEERR_INVALCALLHANDLE;
        return NOERROR;
    }

    // drop specified call 
    pCall->CloseCall( LINEDISCONNECTMODE_CANCELLED );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseCall - Exited." ));

    pCall -> Unlock();

    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    LPCSTR        pUserUserInfo,
    DWORD         dwSize
    )
    
/*++

Routine Description:

    This functions drops or disconnects the specified call. The TAPI DLL has 
    the option to specify user-to-user information to be transmitted as part 
    of the call disconnect.

    When invoking TSPI_lineDrop related calls may sometimes be affected as 
    well. For example, dropping a conference call may drop all individual 
    participating calls. LINE_CALLSTATE messages are sent to the TAPI DLL for 
    all calls whose call state is affected. A dropped call will typically 
    transition to the idle state.

    Invoking TSPI_lineDrop on a call in the offering state rejects the call. 
    Not all telephone networks provide this capability.

    Invoking TSPI_lineDrop on a consultation call that was set up using either
    TSPI_lineSetupTransfer or TSPI_lineSetupConference, will cancel the 
    consultation call. Some switches automatically unhold the other call. 

    The TAPI DLL has the option to send user-to-user information at the time 
    of the drop. Even if user-to-user information can be sent, often no 
    guarantees are made that the network will deliver this information to the 
    remote party.

    Note that in various bridged or party line configurations when multiple 
    parties are on the call, TSPI_lineDrop by the application may not actually
    clear the call.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to 
        be dropped.  Valid call states: any.

    psUserUserInfo - Specifies a far pointer to a string containing 
        user-to-user information to be sent to the remote party as part of 
        the call disconnect.  This pointer is unused if dwUserUserInfoSize 
        is zero and no user-to-user information is to be sent. User-to-user 
        information is only sent if supported by the underlying network 
        (see LINEDEVCAPS).

    dwSize - Specifies the size in bytes of the user-to-user information in 
        psUserUserInfo. If zero, then psUserUserInfo can be left NULL, and 
        no user-to-user information will be sent to the remote party.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALPOINTER - The specified pointer parameter is invalid.

        LINEERR_INVALCALLSTATE - The current state of the call does not allow 
            the call to be dropped.
            
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDrop - Entered." ));
    
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {

        // complete the async accept operation now
        H323CompleteRequest (dwRequestID, ERROR_SUCCESS);
        return dwRequestID;

        //return LINEERR_INVALCALLHANDLE;
    }

    // save outgoing user user information (if specified)
    if( dwSize != 0 && pUserUserInfo )
    {
        if( !pCall -> AddU2U( U2U_OUTBOUND, dwSize, (PBYTE)pUserUserInfo) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "could not save user user info." ));
            pCall -> Unlock();
            // no memory available
            return LINEERR_NOMEM;
        }
    }

    // drop specified call 
    if( !pCall->QueueTAPICallRequest( TSPI_DROP_CALL, NULL ))
    {
        pCall -> Unlock();
        // could not drop call
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDrop - Exited." ));
        
    pCall -> Unlock();   
    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL hdCall,
    LPDWORD  pdwAddressID
    )
    
/*++

Routine Description:

    This operation allows the TAPI DLL to retrieve the address ID for the 
    indicated call.

    This operation must be executed synchronously by the Service Provider, 
    with presumed success.  This operation may be called from within the 
    context of the ASYNC_LINE_COMPLETION or LINEEVENT callbacks (i.e., from 
    within an interrupt context).  This function would typically be called 
    at the start of the call life cycle.

    If the Service Provider models lines as "pools" of channel resources 
    and does "inverse multiplexing" of a call over several address IDs it 
    should consistently choose one of these address IDs as the primary 
    identifier reported by this function and in the LINE_CALLINFO data 
    structure.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        whose address ID is to be retrieved.  Valid call states: any.

    pdwAddressID - Specifies a far pointer to a DWORD into which the 
        Service Provider writes the call's address ID.

Return Values:
    
    None.

--*/

{
    PH323_CALL pCall;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallAddressID - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // only one addr
    *pdwAddressID = 0;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallAddressID - Exited." ));
        
    pCall -> Unlock();
    // success
    return NOERROR;
}


/*++

Routine Description:

    This operation enables the TAPI DLL to obtain fixed information about 
    the specified call.

    A separate LINECALLINFO structure exists for every (inbound or outbound) 
    call. The structure contains primarily fixed information about the call. 
    An application would typically be interested in checking this information 
    when it receives its handle for a call via the LINE_CALLSTATE message, or 
    each time it receives notification via a LINE_CALLINFO message that parts 
    of the call information structure have changed. These messages supply the 
    handle for the call as a parameter.

    If the Service Provider models lines as "pools" of channel resources and 
    does "inverse multiplexing" of a call over several address IDs it should 
    consistently choose one of these address IDs as the primary identifier 
    reported by this function in the LINE_CALLINFO data structure.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        whose call information is to be retrieved.

    pCallInfo - Specifies a far pointer to a variable sized data structure 
        of type LINECALLINFO. Upon successful completion of the request, this 
        structure is filled with call related information.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  pCallInfo
    )
    
{
    LONG retVal;
    PH323_CALL pCall;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallInfo - Entered." ));

    if( pCallInfo == NULL )
    {
        return LINEERR_INVALPARAM;
    }

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    retVal = pCall -> CopyCallInfo( pCallInfo );

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallInfo - Exited." ));
    return retVal;
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL         hdCall,
    LPLINECALLSTATUS pCallStatus
    )
    
/*++

Routine Description:

    This operation returns the current status of the specified call.

    TSPI_lineCallStatus returns the dynamic status of a call, whereas 
    TSPI_lineGetCallInfo returns primarily static information about a call. 
    Call status information includes the current call state, detailed mode 
    information related to the call while in this state (if any), as well 
    as a list of the available TSPI functions the TAPI DLL can invoke on the 
    call while the call is in this state.  An application would typically be 
    interested in requesting this information when it receives notification 
    about a call state change via the LINE_CALLSTATE message.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be queried for its status.  Valid call states: any.

    pCallStatus - Specifies a far pointer to a variable sized data structure 
        of type LINECALLSTATUS. Upon successful completion of the request, 
        this structure is filled with call status information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallStatus - Entered." ));

    if( pCallStatus == NULL ) 
    {
        return LINEERR_INVALPARAM;
    }

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // determine number of bytes needed
    pCallStatus->dwNeededSize = sizeof(LINECALLSTATUS);

    // see if structure size is large enough
    if (pCallStatus->dwTotalSize < pCallStatus->dwNeededSize)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "linecallstatus structure too small." ));

        pCall -> Unlock();
        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    // record amount of memory used
    pCallStatus->dwUsedSize = pCallStatus->dwNeededSize;

    pCall -> CopyCallStatus( pCallStatus );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetCallStatus - Exited." ));
            
    pCall -> Unlock();
    // success
    return NOERROR;
}


    
/*++

Routine Description:

    This function places a call on the specified line to the specified 
    destination address, exchanging opaque handles for the new call 
    between the TAPI DLL and Service Provider. Optionally, call parameters 
    can be specified if anything but default call setup parameters are 
    requested.

    After dialing has completed, several LINE_CALLSTATE messages will 
    typically be sent to the TAPI DLL to notify it about the progress of the 
    call. No generally valid sequence of call state transitions is specified 
    as no single fixed sequence of transitions can be guaranteed in practice. 
    A typical sequence may cause a call to transition from dialtone, dialing, 
    proceeding, ringback, to connected. With non-dialed lines, the call may 
    typically transition directly to connected state.

    The TAPI DLL has the option to specify an originating address on the 
    specified line device. A service provider that models all stations on a 
    switch as addresses on a single line device allows the TAPI DLL to 
    originate calls from any of these stations using TSPI_lineMakeCall.

    The call parameters allow the TAPI DLL to make non voice calls or request 
    special call setup options that are not available by default.

    The TAPI DLL can partially dial using TSPI_lineMakeCall and continue 
    dialing using TSPI_lineDial. To abandon a call attempt, use TSPI_lineDrop.

    The Service Provider initially does media monitoring on the new call for 
    at least the set of media modes that were monitored for on the line.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdLine - Specifies the Service Provider's opaque handle to the line on 
        which the new call is to be originated.

    htCall - Specifies the TAPI DLL's opaque handle to the new call.  The 
        Service Provider must save this and use it in all subsequent calls to 
        the LINEEVENT procedure reporting events on the call.

    phdCall - Specifies a far pointer to an opaque HDRVCALL representing the 
        Service Provider's identifier for the call.  The Service Provider must
        fill this location with its opaque handle for the call before this 
        procedure returns, whether it decides to execute the request 
        sychronously or asynchronously.  This handle is invalid if the function
        results in an error (either synchronously or asynchronously).

    pwszDialableAddr - Specifies a far pointer to the destination address. This 
        follows the standard dialable number format. This pointer may be 
        specified as NULL for non-dialed addresses (i.e., a hot phone) or when
        all dialing will be performed using TSPI_lineDial. In the latter case,
        TSPI_lineMakeCall will allocate an available call appearance which 
        would typically remain in the dialtone state until dialing begins. 
        Service providers that have inverse multiplexing capabilities may allow
        an application to specify multiple addresses at once.

    dwCountryCode - Specifies the country code of the called party. If a value 
        of zero is specified, then a default will be used by the 
        implementation.

    pCallParams - Specifies a far pointer to a LINECALLPARAMS structure. This 
        structure allows the TAPI DLL to specify how it wants the call to be 
        set up. If NULL is specified, then a default 3.1kHz voice call is 
        established, and an arbitrary origination address on the line is 
        selected.  This structure allows the TAPI DLL to select such elements 
        as the call's bearer mode, data rate, expected media mode, origination
        address, blocking of caller ID information, dialing parameters, etc.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error 
    number if an error has occurred. Possible error returns are:
    
        LINEERR_CALLUNAVAIL - All call appearances on the specified address are 
            currently in use.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_INVALADDRESSMODE - The address mode is invalid.

        LINEERR_INVALBEARERMODE - The bearer mode is invalid.

        LINEERR_INVALCALLPARAMS - The specified call parameter structure is 
            invalid.

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALLINESTATE - The line is currently not in a state in 
            which this operation can be performed. 

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

        LINEERR_OPERATIONFAILED - The operation failed for unspecified reasons.

        LINEERR_RESOURCEUNAVAIL - The specified operation cannot be completed 
            because of resource overcommitment.

--*/

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          phdCall,
    LPCWSTR             pwszDialableAddr,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const pCallParams
    )
{
    DWORD               dwStatus = dwRequestID;
    PH323_CALL          pCall = NULL;
    H323_CONFERENCE *   pConf = NULL;
    BOOL                fDelete = FALSE;
    DWORD               dwState;

    UNREFERENCED_PARAMETER( dwCountryCode );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMakeCall - Entered." ));

    //lock the line device    
    g_pH323Line -> Lock();

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }

    // validate line state
    dwState = g_pH323Line -> GetState();
    if( ( dwState != H323_LINESTATE_OPENED) &&
        ( dwState != H323_LINESTATE_LISTENING) ) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "H323 line is not currently opened:%d.",
            dwState ));

        // release line device
        g_pH323Line ->Unlock();

        // line needs to be opened
        return LINEERR_INVALLINESTATE;
    }
    
    // see if line is available
    if( g_pH323Line -> GetNoOfCalls() == H323_MAXCALLSPERLINE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "H323 line is currently used at maximum capacity." ));
    
        // release line device
        g_pH323Line -> Unlock();

        // line is currenty maxed
        return LINEERR_RESOURCEUNAVAIL;
    }

    // allocate outgoing call
    pCall = new CH323Call();

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    // save tapi handle and specify outgoing call direction
    if( !pCall -> Initialize(   htCall, 
                                LINECALLORIGIN_OUTBOUND, 
                                CALLTYPE_NORMAL ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    //This function should be called in a lock. But here we aint calling it in
    //a lock because this call is not added to the call table yet. Before
    //calling this function from anywhere else the call should be locked first
    if (!pCall -> ValidateCallParams( pCallParams,
                                      pwszDialableAddr,
                                      &dwStatus))
    {
        dwStatus = LINEERR_INVALCALLPARAMS;

        // failure
        goto cleanup;
    }

    // transfer handle
    *phdCall = pCall -> GetCallHandle();

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not create conference." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    pCall->Lock();

    // post place call request to callback thread
    if( !pCall -> QueueTAPICallRequest( TSPI_MAKE_CALL, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not post place call message." ));

        // could not complete operation
        dwStatus = LINEERR_OPERATIONFAILED;

        pCall->Unlock();
        // failure
        goto cleanup;
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall->Unlock();


    // release line device
    g_pH323Line -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMakeCall - Exited." ));
    
    // success
    return dwStatus;

cleanup:

    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pCall;
        pCall = NULL;
    }

    *phdCall = NULL;

    // release line device
    g_pH323Line -> Unlock();

    // failure
    return dwStatus;
}


LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineReleaseUUIE - Entered." ));
    
    // retrieve call pointer from handle
    PH323_CALL pCall;

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_RELEASE_U2U, NULL))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post close event." ));
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineReleaseUUIE - Exited." ));
            
    pCall -> Unlock();
    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              pUserUserInfo,
    DWORD               dwSize
    )
{
    BYTE*                   pU2UInfo = NULL;
    PBUFFERDESCR            pBuf = NULL;
    
    // retrieve call pointer from handle
    PH323_CALL pCall;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSendUUIE - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( dwSize && pUserUserInfo )
    {
        pU2UInfo = (BYTE*)new char[dwSize];
        if( pU2UInfo == NULL )
        {
            pCall -> Unlock();
            return LINEERR_NOMEM;
        }
                
        pBuf = (PBUFFERDESCR) new BUFFERDESCR;
        if( pBuf == NULL )
        {
            delete pU2UInfo;
            pU2UInfo = NULL;
            pCall -> Unlock();
            return LINEERR_NOMEM;
        }

        CopyMemory( (PVOID)pU2UInfo, (PVOID)pUserUserInfo, dwSize );
        pBuf -> pbBuffer = pU2UInfo;
        pBuf -> dwLength = dwSize;

        if( !pCall -> QueueTAPICallRequest( TSPI_SEND_U2U, (PVOID)pBuf ))
        {
	        H323DBG(( DEBUG_LEVEL_ERROR, "could not post close event." ));
	        pCall -> Unlock();
	        return LINEERR_OPERATIONFAILED;
        }
    }

    //complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSendUUIE - Exited." ));
            
    pCall -> Unlock();
    // async success
    return dwRequestID;
}


LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL hdCall,
    DWORD    dwDigitModes
    )
{
    PH323_CALL pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMonitor - Entered." ));
    
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // see if mode empty
    if( dwDigitModes == 0 )
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "disabling dtmf detection." ));

        // disable monitoring digits
        pCall->m_fMonitoringDigits = FALSE;

        //unlock the call
        pCall -> Unlock();

        // success
        return NOERROR;
    } 
    else if( dwDigitModes != LINEDIGITMODE_DTMF )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "invalid digit modes 0x%08lx.", dwDigitModes ));

        //unlock the call
        pCall -> Unlock();

        // invalid call handle
        return LINEERR_INVALDIGITMODE;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "enabling dtmf detection." ));

    // enable monitoring digits
    pCall->m_fMonitoringDigits = TRUE;

    //unlock the call
    pCall -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMonitor - Exited." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL hdCall,
    DWORD    dwEndToEndID,
    DWORD    dwDigitMode,
    LPCWSTR  pwszDigits,
    DWORD    dwDuration
    )
{
    PH323_CALL pCall;
    DWORD dwLength;

    UNREFERENCED_PARAMETER(dwDuration);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGenerateDigits - Entered." ));
    
    // retrieve call pointer from handle
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    // verify that the call was connected
    if( pCall -> GetCallState() != LINECALLSTATE_CONNECTED )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    // verify monitor modes
    if( dwDigitMode != LINEDIGITMODE_DTMF ) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "invalid digit mode 0x%08lx.",
            dwDigitMode ));
        
        pCall -> Unlock();
        // invalid call handle
        return LINEERR_INVALDIGITMODE;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "sending user input %S.", pwszDigits ));

    if( pwszDigits == NULL )
    {
        // signal completion
        pCall->PostLineEvent (
            LINE_GENERATE,
            LINEGENERATETERM_CANCEL,
            dwEndToEndID,
            GetTickCount()
            );
        
        pCall -> Unlock();

        return NOERROR;
    }

    LPCWSTR wszDigits = pwszDigits;
    for( dwLength = 0; (*wszDigits) != L'\0'; wszDigits++ )
    {
        if( IsValidDTMFDigit(*wszDigits) == FALSE )
        {
            // signal completion
            pCall->PostLineEvent (
                LINE_GENERATE,
                LINEGENERATETERM_CANCEL,
                dwEndToEndID,
                GetTickCount()
                );

            pCall -> Unlock();
            
            // digit generation cancelled.
            return LINEERR_INVALDIGITS;
        }

        dwLength++;
    }

    if( dwLength == 0 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "no digits to passo on." ));
        
        pCall -> Unlock();
        // invalid call handle
        return LINEERR_INVALPARAM;
    }

    // send user input message
    pCall -> SendMSPMessage(
        SP_MSG_SendDTMFDigits, 
        (BYTE*)pwszDigits, 
        dwLength, 
        NULL );

    // signal completion
    pCall->PostLineEvent (
        LINE_GENERATE,
        LINEGENERATETERM_DONE,
        dwEndToEndID,
        GetTickCount()
        );

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGenerateDigits - Exited." ));
        
    pCall -> Unlock();
    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\audio.h ===
//
// Copyright (c) 1999 Microsoft Corporation
//
// HIDCOM.EXE -- exploratory USB Phone Console Application
//
// audio.h -- audio magic
//

#ifndef _HIDCOM_AUDIO_H_
#define _HIDCOM_AUDIO_H_

#ifdef __cplusplus
extern "C"
{
#endif

#include <basetyps.h>
#include <setupapi.h>


//////////////////////////////////////////////////////////////////////////////
//
// DiscoverAssociatedWaveId
//
// This function searches for a wave device to match the HID device in the
// PNP tree location specified in the passed in SP_DEVICE_INTERFACE_DATA
// structure, obtained from the SetupKi API. It returns the wave id for
// the matched device.
//
// It uses the helper function FindWaveIdFromHardwareIdString() to search for
// the wave device based on a devinst DWORD and a hardware ID string. First,
// it must obtain the devinst for the device; it does this by calling a SetupDi
// function and looking up the devinst in a resulting structure. The hardware
// ID string is then retrieved from the registry and trimmed, using the helper
// function HardwareIdFromDevinst().
//
// See FindWaveIdFromHardwareIdString() for further comments on the search
// algorithm.
//
// Arguments:
//     dwDevInst     - IN  - Device Instance of the HID device
//     fRender       - IN  - TRUE for wave out, FALSE for wave in
//     pdwWaveId     - OUT - the wave id associated with this HID device
//
// Return values:
//      S_OK    - succeeded and matched wave id
//      other from helper functions FindWaveIdFromHardwareIdString() or
//            or HardwareIdFromDevinst()
//

HRESULT DiscoverAssociatedWaveId(
    IN    DWORD                      dwDevInst,
    IN    BOOL                       fRender,
    OUT   DWORD                    * pdwWaveId
    );


//////////////////////////////////////////////////////////////////////////////
//
// ExamineWaveDevices
//
// This function is for debugging purposes only. It enumerates audio devices
// using the Wave API and prints the device path string as well as the
// device instance DWORD for each render or capture device.
//
// Arguments:
//      fRender - IN - true means examine wave out devices; false = wave in
//
// Return values:
//      E_OUTOFMEMORY
//      S_OK
//

HRESULT ExamineWaveDevices(
    IN    BOOL fRender
    );


#ifdef __cplusplus
};
#endif

#endif // _HIDCOM_AUDIO_H_

//
// eof
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\audio.cpp ===
//
// Copyright (c) 1999 Microsoft Corporation
//
// HIDCOM.EXE -- exploratory USB Phone Console Application
//
// audio.cpp -- audio magic
//
// Zoltan Szilagyi, July - August, 1999
//
// Prioritized to-do list:
//
// * Convert printfs to debug tracing, and define debug tracing to
//   printfs for HidCom.Exe use.
//
// * GetInstanceFromDeviceName should look only for audio devices.
//   This should somewhat reduce the 2 sec wave enumeration time.
//   Don't forget to remove timing debug output.
//
// * Consider changing FindWaveIdFromHardwareIdString and its helpers to take a
//   devinst only and computer the hardware ids on the fly rather than storing
//   them in arrays. This would slow it down but make the code simpler.
//
// * Small one-time memory leak: The static arrays of hardware ID
//   strings are leaked. That's a few KB per process, no increase over
//   time. If we make this a class then we'll just deallocate those
//   arrays in the destructor.
//   Also, for PNP events that cause us to recompute the mapping, we will
//   need to destroy the array at some point if the wave devices change.
//   So we need to augment the interface for this.
//




#include <wtypes.h>
#include <stdio.h>

#include "audio.h" // our own prototypes

#include <cfgmgr32.h> // CM_ functions
#include <setupapi.h> // SetupDi functions
#include <mmsystem.h> // wave functions
#include <initguid.h>
#include <devguid.h> // device guids

//
// mmddkp.h -- private winmm header file
// This is in nt\private\inc, but one must ssync and build in
// nt\private\genx\windows\inc before it will show up.
//

#include <mmddkp.h>


#include <crtdbg.h>
#define ASSERT _ASSERTE

#ifdef DBG
    #define STATIC
#else
    #define STATIC static
#endif

extern "C"
{
#include "mylog.h"
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Private helper functions
//
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// MapConfigRetToWin32
//
// This routine maps some CM error return codes to Win32 return codes, and
// maps everything else to the value specied by dwDefault. This function is
// adapted almost verbatim from the SetupAPI code.
//
// Arguments:
//     CmReturnCode - IN - specifies the ConfigMgr return code to be mapped
//     dwDefault    - IN - specifies the default value to use if no explicit
//                         mapping applies
//
// Return values:
//     Setup API (Win32) error code
//

STATIC DWORD
MapConfigRetToWin32(
    IN CONFIGRET CmReturnCode,
    IN DWORD     dwDefault
    )
{
    switch(CmReturnCode) {

        case CR_SUCCESS :
            return NO_ERROR;

        case CR_CALL_NOT_IMPLEMENTED :
            return ERROR_CALL_NOT_IMPLEMENTED;

        case CR_OUT_OF_MEMORY :
            return ERROR_NOT_ENOUGH_MEMORY;

        case CR_INVALID_POINTER :
            return ERROR_INVALID_USER_BUFFER;

        case CR_INVALID_DEVINST :
            return ERROR_NO_SUCH_DEVINST;

        case CR_INVALID_DEVICE_ID :
            return ERROR_INVALID_DEVINST_NAME;

        case CR_ALREADY_SUCH_DEVINST :
            return ERROR_DEVINST_ALREADY_EXISTS;

        case CR_INVALID_REFERENCE_STRING :
            return ERROR_INVALID_REFERENCE_STRING;

        case CR_INVALID_MACHINENAME :
            return ERROR_INVALID_MACHINENAME;

        case CR_REMOTE_COMM_FAILURE :
            return ERROR_REMOTE_COMM_FAILURE;

        case CR_MACHINE_UNAVAILABLE :
            return ERROR_MACHINE_UNAVAILABLE;

        case CR_NO_CM_SERVICES :
            return ERROR_NO_CONFIGMGR_SERVICES;

        case CR_ACCESS_DENIED :
            return ERROR_ACCESS_DENIED;

        case CR_NOT_DISABLEABLE:
            return ERROR_NOT_DISABLEABLE;

        default :
            return dwDefault;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// MapConfigRetToHResult
//
// This routine maps some CM error return codes to HRESULT return codes, and
// maps everything else to the HRESULT value E_FAIL.
//
// Arguments:
//     CmReturnCode - IN - specifies the ConfigMgr return code to be mapped
//
// Return values:
//     HRESULT error code
//

STATIC HRESULT
MapConfigRetToHResult(
    IN CONFIGRET CmReturnCode
    )
{
    DWORD   dwWin32Error;
    HRESULT hr;

    //
    // Map configret --> win32
    //

    dwWin32Error = MapConfigRetToWin32(
        CmReturnCode,
        E_FAIL
        );

    //
    // Map win32 --> HRESULT
    // but don't try to map default E_FAIL, as it is not within the range for
    // a normal win32 error code.
    //

    if ( dwWin32Error == E_FAIL )
    {
        hr = E_FAIL;
    }
    else
    {
        hr = HRESULT_FROM_WIN32( dwWin32Error );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CheckIfAncestor
//
// This function determines if one of the specified devnodes (the "proposed
// ancestor") is an ancestor of the other specified devnode (the "proposed
// descendant").
//
// The devnodes are arranged in a tree. If node A is an ancestor of node
// B, it just means that node A is either equal to node B, or has a child
// that is an ancestor of node B. This can also be stated in reverse --
// node C is a descendant of node D if C is equal to D, or if C's parent
// is a descendant of node D.
//
// The algorithm used here to determine ancestry is a straightforward
// application of the definition, although the recursion is removed.
//
// Arguments:
//     dwDevInstProposedAncestor   - IN  - the proposed ancestor (see above)
//     dwDevInstProposedDescendant - IN  - the proposed descendant (see above)
//     pfIsAncestor                - OUT - returns bool value indicating if
//                                          the pa is an ancestor of the pd
//
// Return values:
//     S_OK   - success
//     others - from CM_Get_Parent
//

STATIC HRESULT
CheckIfAncestor(
    IN   DWORD   dwDevInstProposedAnscestor,
    IN   DWORD   dwDevInstProposedDescendant,
    OUT  BOOL  * pfIsAncestor
    )
{
    ASSERT( ! IsBadWritePtr( pfIsAncestor, sizeof( BOOL ) ) );

    DWORD   dwCurrNode;
    HRESULT hr;

    //
    // Initially, the current node is the proposed descendant.
    //

    dwCurrNode = dwDevInstProposedDescendant;

    while ( TRUE )
    {
        //
        // Check if this node is the proposed ancestor.
        // If so, the proposed ancestor is an ancestor of the
        // proposed descendant.
        //

        if ( dwCurrNode == dwDevInstProposedAnscestor )
        {
            *pfIsAncestor = TRUE;

            hr = S_OK;

            break;
        }

        //
        // Replace the current node with the current node's parent.
        //

        CONFIGRET cr;
        DWORD     dwDevInstTemp;
    
        cr = CM_Get_Parent(
            & dwDevInstTemp,   // out: parent's devinst dword
            dwCurrNode,        // in:  child's devinst dword
            0                  // in:  flags: must be zero
            );

        if ( cr == CR_NO_SUCH_DEVNODE )
        {
            //
            // This means we've fallen off the top of the PNP tree -- the
            // proposed ancestor is not found in the proposed descendant's
            // parentage chain.
            //

            * pfIsAncestor = FALSE;

            hr = S_OK;

            break;
        }
        else if ( cr != CR_SUCCESS )
        {
            //
            // Some other error occured.
            //                   

            hr = MapConfigRetToHResult( cr );
            
            break;
        }

        dwCurrNode = dwDevInstTemp;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// FindClosestCommonAncestor
//
// Given a pair of devnodes identified by devinst DWORDs, this function
// finds the devinst DWORD for the closest common ancestor of the two
// devnodes.
//
// See CheckIfAncestor for a discussion of the concepts of ancestor and
// descendant. Then, devnode C is a common ancestor of devnodes A and B if C
// is an ancestor of A -AND- C is an ancestor of B. Any pair of devnodes has
// at least one common ancestor, that being the root of the PNP tree. A pair
// of devnodes may have more than one common ancestor. The set of common
// ancestors of A and B has one UNIQUE member, called the closest common
// ancestor, such that no other member of the set is a child of that node.
//
// You can compute the closest common ancestor of two nodes A and B by
// constructing a chain of nodes going from the root of the tree to A through
// all A's ancestors, and also doing the same for B. Comparing these chains
// side by side, they must be the same in at least the first node (the root).
// The closest common ancestor for A and B is the last node that is the same
// for both chains.
//
// The algorithm used here is an alternative, relatively stateless approach
// that can take more CPU time but uses less memory, doesn't involve any
// allocations, and is much easier to write (the last being the overriding
// consideration, as the PNP tree is in always shallow). The code simply walks
// up A's chain of ancestors, checking if each node is an ancestor of B. The
// first node for which this is true is the closest common ancestor of
// A and B.
//
// Arguments:
//     dwDevInstOne     - IN  - the first node ('A' above)
//     dwDevInstTwo     - IN  - the other node ('B' above)
//     pdwDevInstResult - OUT - returns the closest common ancestor
//
// Return values:
//     S_OK   - success
//     others - from CM_Get_Parent
//

STATIC HRESULT
FindClosestCommonAncestor(
    IN   DWORD   dwDevInstOne,
    IN   DWORD   dwDevInstTwo,
    OUT  DWORD * pdwDevInstResult
    )
{
    ASSERT( ! IsBadWritePtr( pdwDevInstResult, sizeof( DWORD ) ) );

    HRESULT hr;
    BOOL    fIsAncestor;
    DWORD   dwDevInstCurr;

    //
    // For each node up the chain of #1's parents, starting from #1 itself...
    //

    dwDevInstCurr = dwDevInstOne;

    while ( TRUE )
    {
        //
        // Check if this node is also in the chain of #2's parents.
        //

        hr = CheckIfAncestor(
            dwDevInstCurr,
            dwDevInstTwo,
            & fIsAncestor
            );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( fIsAncestor )
        {
            *pdwDevInstResult = dwDevInstCurr;

            return S_OK;
        }

        //
        // Get the next node in the chain of #1's parents.
        //

        CONFIGRET cr;
        DWORD     dwDevInstTemp;
    
        cr = CM_Get_Parent(
            & dwDevInstTemp,   // out: parent's devinst dword
            dwDevInstCurr,     // in:  child's devinst dword
            0                  // in:  flags: must be zero
            );

        if ( cr != CR_SUCCESS )
        {
            //
            // dwDevInst has no parent, or some other error occured.
            //
            // This is always an error, because there must always
            // be a common parent somewhere up the chain -- the root of the PNP
            // tree!
            //                   

            return MapConfigRetToHResult( cr );
        }

        dwDevInstCurr = dwDevInstTemp;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// TrimHardwareIdString
//
// This function strips off extraneous parts of the hardware ID string as
// it is expected to appear for USB devices. The remaining parts of the string
// are those that identify the vendor, product, and product revision, which
// are together used to match devices as belonging to the same composite or
// compound device.
//
// (Actually, for devices A and B, it's not just A and B that are compared,
// it's A and the closest common parent of A and B. This ensures that the case
// of multiple identical phones in the same system is handled correctly. This
// logic of course lives outside of this funtion, though.)
//
// As an example:
//          "hid\Vid_04a6&Pid_00b9&Rev_0010&Mi_04&Col01"
//  becomes     "Vid_04a6&Pid_00b9&Rev_0010"
//
// Note that this function will routinely be applied to strings for non-USB
// devices that will not be in the same format; that's ok, since those strings
// will never match USB-generated strings, be they trimmed or not.
//
// Also, note that the hardware ID string as read from the registry actually
// consists of multiple concatenated null-terminated strings, all terminated
// by two consecutive null characters. This function just ignores strings
// beyond the first, as the first contains all the info we need.
//
// Arguments:
//     wszHardwareId - IN - the string to trim (in place)
//
// Return values:
//     TRUE    - the string looked like a valid USB hardware ID
//     FALSE   - the string did not look like a valid USB hardware ID
//

STATIC BOOL
TrimHardwareIdString(
    IN   WCHAR * wszHardwareId
    )
{

    ASSERT( ! IsBadStringPtrW( wszHardwareId, (DWORD) -1 ) );

    //
    // "volatile" is needed, otherwise the compiler blatantly ignores the
    // recalculation of dwSize after the first pass.
    //

    volatile DWORD   dwSize;
    DWORD            dwCurrPos;
    BOOL             fValid = FALSE;
    DWORD            dwNumSeparators = 0;

    //
    // Strip off leading characters up to and including the first \ from the
    // front. If there is no \ in the string, it is invalid.
    //

    dwSize = lstrlenW(wszHardwareId);

    for ( dwCurrPos = 0; dwCurrPos < dwSize; dwCurrPos ++ )
    {
        if ( wszHardwareId[ dwCurrPos ] == L'\\' )
        {
            MoveMemory(
                wszHardwareId,                     // dest
                wszHardwareId + dwCurrPos + 1,     // source
                sizeof(WCHAR) * dwSize - dwCurrPos // size, in bytes
                );

            fValid = TRUE;

            break;
        }
    }

    if ( ! fValid )
    {
        return FALSE;
    }

    //
    // Strip off trailing characters starting from the third &.
    // A string with less than two & is rejected.
    //
    // Examples:
    //
    //          Vid_04a6&Pid_00b9&Rev_0010&Mi_04&Col01
    //  becomes Vid_04a6&Pid_00b9&Rev_0010
    //
    //          Vid_04a6&Pid_00b9&Rev_0010&Mi_04
    //  becomes Vid_04a6&Pid_00b9&Rev_0010
    //
    //          CSC6835_DEV
    //  is rejected
    //

    //
    // Must recompute size because we changed it above.
    // (And note that dwSize is declared as 'volatile'.)
    //

    dwSize = lstrlenW(wszHardwareId);

    for ( dwCurrPos = 0; dwCurrPos < dwSize; dwCurrPos ++ )
    {
        if ( wszHardwareId[ dwCurrPos ] == L'&' )
        {
            dwNumSeparators ++;

            if ( dwNumSeparators == 3 )
            {
                wszHardwareId[ dwCurrPos ] = L'\0';

                break;
            }
        }
    }

    if ( dwNumSeparators < 2 )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// DevInstGetIdString
//
// This function retrieves an id string or string set for a particular
// devinst dword. The value is obtained from the registry, but the
// Configuration Manager API hides the detail of where in the registry this
// info lives.
//
// Arguments:
//     dwDevInst    - IN  - the devinst dword for which we want info
//     dwProperty   - IN  - the property to retrieve
//     pwszIdString - OUT - returns "new"ed Unicode string or string set.
//
// Return values:
//     S_OK          - success
//     E_OUTOFMEMORY - out of memory during string allocation
//     E_UNEXPECTED  - data type of returned ID is not string or mutli-string
//     others        - from CM_Get_DevNode_Registry_PropertyW
//

STATIC HRESULT
DevInstGetIdString(
    IN   DWORD    dwDevInst,
    IN   DWORD    dwProperty,
    OUT  WCHAR ** pwszIdString
    )
{
    const DWORD INITIAL_STRING_SIZE = 100;

    CONFIGRET   cr;
    DWORD       dwBufferSize = INITIAL_STRING_SIZE;
    DWORD       dwDataType   = 0;

    ASSERT( ! IsBadWritePtr( pwszIdString, sizeof( WCHAR * ) ) );


    do
    {
        //
        // Allocate a buffer to store the returned string.
        //

        *pwszIdString = new WCHAR[ dwBufferSize + 1 ];

        if ( *pwszIdString == NULL )
        {
            return E_OUTOFMEMORY;
        }

        //
        // Try to get the string in the registry; we may not have enough
        // buffer space.
        //

        cr = CM_Get_DevNode_Registry_PropertyW(
             dwDevInst,              // IN  DEVINST     dnDevInst,
             dwProperty,             // IN  ULONG       ulProperty,
             & dwDataType,           // OUT PULONG      pulRegDataType, OPT
             (void *) *pwszIdString, // OUT PVOID       Buffer,         OPT
             & dwBufferSize,         // IN  OUT PULONG  pulLength,
             0                       // IN  ULONG       ulFlags -- must be zero
             );

        if ( cr == CR_SUCCESS )
        {
            if ( ( dwDataType != REG_MULTI_SZ ) && ( dwDataType != REG_SZ ) )
            {
                //
                // Value available, but it is not a string ot multi-string. Ouch!
                //

                delete ( *pwszIdString );

                return E_UNEXPECTED;
            }
            else
            {
                return S_OK;
            }
        }
        else if ( cr != CR_BUFFER_SMALL )
        {
            //
            // It's supposed to fail with this error code because we didn't pass in
            // a buffer. Failed to get registry value type and length.
            //

            delete ( *pwszIdString );

            return MapConfigRetToHResult( cr );
        }
        else // cr == CR_BUFFER_SMALL
        {
            delete ( *pwszIdString );

            //
            // the call filled in dwBufferSize with the needed value
            //
        }

    }
    while ( TRUE );

}


//////////////////////////////////////////////////////////////////////////////
//
// HardwareIdFromDevInst
//
// This function retrieves a trimmed hardware ID string for a particular
// devinst dword. The value is obtained from the helper function
// DevInstGetIdString(), and then trimmed using TrimHardwareIdString.
//
// Arguments:
//     dwDevInst      - IN  - the devinst dword for which we want info
//     pwszHardwareId - OUT - returns "new"ed Unicode string set
//
// Return values:
//     S_OK          - success
//     E_FAIL        - not a valid string in USB format
//     others        - from DevInstGetIdString()
//

STATIC HRESULT
HardwareIdFromDevInst(
    IN   DWORD    dwDevInst,
    OUT  WCHAR ** pwszHardwareId
    )
{
    ASSERT( ! IsBadWritePtr(pwszHardwareId, sizeof( WCHAR * ) ) );

    HRESULT   hr;
    BOOL      fValid;

    hr = DevInstGetIdString(
        dwDevInst,
        CM_DRP_HARDWAREID,
        pwszHardwareId
        );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //    wprintf(L"*** HardwareIdFromDevInst: devinst 0x%08x, RAW hardwareID %s\n",
    //        dwDevInst, *pwszHardwareId);

    fValid = TrimHardwareIdString( *pwszHardwareId );

    if ( ! fValid )
    {
        delete ( * pwszHardwareId );

        return E_FAIL;
    }

    // wprintf(L"HardwareIdFromDevInst: devinst 0x%08x, hardwareID %s\n",
    //    dwDevInst, *pwszHardwareId);

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// MatchHardwareIdInArray
//
// This function takes the devinst and hardware ID for a HID device and
// looks in an array of devinsts and hardware IDs for wave devices to find
// the correct wave id to use with the HID device. The correct wave id is
// the one whose hardware ID matches the HID device's hardware ID, and whose
// hardware ID matches the hardware ID for the closest common ancestor of
// itself and the HID device.
//
// Arguments:
//     dwHidDevInst     - IN  - the devinst dword for the HID device
//     wszHidHardwareId - IN  - the trimmed hardware ID string for the
//                              HID device
//     dwNumDevices     - IN  - the size of the arrays -- the number of
//                              wave ids on the system
//     pwszHardwareIds  - IN  - array of trimmed hardware id strings for
//                              the wave devices, indexed by wave ids.
//                              Some entries may be NULL to mark them as
//                              invalid.
//     pdwDevInsts      - IN  - array of devinsts for wave devices,
//                              indexed by wave ids. Some entries may be
//                              (DWORD) -1 to mark them as invalid.
//     pdwMatchedWaveId - OUT - the wave id that matches the hid device
//
// Return values:
//     S_OK   - the devinst was matched
//     E_FAIL - the devinst was not matched
//

STATIC HRESULT
MatchHardwareIdInArray(
    IN   DWORD    dwHidDevInst,
    IN   WCHAR  * wszHidHardwareId,
    IN   DWORD    dwNumDevices,
    IN   WCHAR ** pwszHardwareIds,
    IN   DWORD  * pdwDevInsts,
    OUT  DWORD  * pdwMatchedWaveId
    )
{
    ASSERT( ! IsBadStringPtrW( wszHidHardwareId, (DWORD) -1 ) );

    ASSERT( ! IsBadReadPtr( pwszHardwareIds,
                            sizeof( WCHAR * ) * dwNumDevices ) );

    ASSERT( ! IsBadReadPtr( pdwDevInsts,
                            sizeof( DWORD ) * dwNumDevices ) );

    ASSERT( ! IsBadWritePtr( pdwMatchedWaveId, sizeof(DWORD) ) );

    //
    // For each available wave id...
    //

    DWORD dwCurrWaveId;

    for ( dwCurrWaveId = 0; dwCurrWaveId < dwNumDevices; dwCurrWaveId++ )
    {
        //
        // If this particular wave device has the same stripped hardware
        // ID string as what we are searching for, then we have a match.
        // But non-USB devices have non-parsable hardware ID strings, so
        // they are stored in the array as NULLs.
        //

        if ( pwszHardwareIds[ dwCurrWaveId ] != NULL )
        {
            ASSERT( ! IsBadStringPtrW( pwszHardwareIds[ dwCurrWaveId ], (DWORD) -1 ) );

            if ( ! lstrcmpW( pwszHardwareIds[ dwCurrWaveId ], wszHidHardwareId ) )
            {
                //
                // We have a match, but we must still verify if we're on the same
                // device, not some other device that has the same hardwareID. This
                // is to differentiate between multiple identical phones on the same
                // system.
                //
                // Note: we could make the code more complex, but avoid some work in
                // most cases, by only doing this if there is more than one match based
                // on hardwareIDs alone.
                //

                DWORD     dwCommonAncestor;
                WCHAR   * wszAncestorHardwareId;
                HRESULT   hr;

                hr = FindClosestCommonAncestor(
                    dwHidDevInst,
                    pdwDevInsts[ dwCurrWaveId ],
                    & dwCommonAncestor
                    );
  
                if ( SUCCEEDED(hr) )
                {
                    //
                    // Get the hardware ID for the closest common ancestor.
                    //

                    hr = HardwareIdFromDevInst(
                        dwCommonAncestor,
                        & wszAncestorHardwareId
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Check if they are the same. The closest common ancestor
                        // will be some sort of hub if the audio device is from
                        // some other identical phone other than the one whose HID
                        // device we are looking at.
                        //

                        BOOL fSame;

                        fSame = ! lstrcmpW( wszAncestorHardwareId,
                                            wszHidHardwareId );

                        delete wszAncestorHardwareId;

                        if ( fSame )
                        {
                            *pdwMatchedWaveId = dwCurrWaveId;

                            return S_OK;
                        }
                    }
                }
            }
        }
    }

    //
    // No match.
    //

    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////
//
// GetInstanceFromDeviceName
//
// This function retrieves a device instance identifier based on a device
// name string. This works for any device.
//
// Arguments:
//      wszName      - IN  - the device name string
//      pdwInstance  - OUT - returns instance identifier
//
// Return values:
//      S_OK
//      various win32 errors from SetupDi fucntions
//

STATIC HRESULT
GetInstanceFromDeviceName(
    IN   WCHAR *   wszName,
    OUT  DWORD *   pdwInstance,
    IN   HDEVINFO  hDevInfo
    )
{
    ASSERT( ! IsBadStringPtrW( wszName, (DWORD) -1 ) );

    ASSERT( ! IsBadWritePtr( pdwInstance, sizeof(DWORD) ) );

    //
    // Get the interface data for this specific device
    // (based on wszName).
    //

    BOOL     fSuccess;
    DWORD    dwError;

    SP_DEVICE_INTERFACE_DATA interfaceData;
    interfaceData.cbSize = sizeof( SP_DEVICE_INTERFACE_DATA ); // required

    fSuccess = SetupDiOpenDeviceInterfaceW(
        hDevInfo,                          // device info set handle
        wszName,                           // name of the device
        0,                                 // flags, reserved
        & interfaceData                    // OUT: interface data
        );

    if ( ! fSuccess )
    {
        LOG((PHONESP_TRACE, "GetInstanceFromDeviceName - SetupDiOpenDeviceInterfaceW failed: %08x", GetLastError()));

        //
        // Need to clean up, but save the error code first, because
        // the cleanup function calls SetLastError().
        //

        dwError = GetLastError();        

        return HRESULT_FROM_WIN32( dwError );
    }

    //
    // Get the interface detail data from this interface data. This provides
    // more detailed information,including the device instance DWORD that
    // we seek.
    //

    SP_DEVINFO_DATA devinfoData;
    devinfoData.cbSize = sizeof( SP_DEVINFO_DATA ); // required

    fSuccess = SetupDiGetDeviceInterfaceDetail(
        hDevInfo,                           // device info set handle
        & interfaceData,                    // device interface data structure
        NULL,                               // OPT ptr to dev name struct
        0,                                  // OPT avail size of dev name st
        NULL,                               // OPT actual size of devname st
        & devinfoData
        );

    if ( ! fSuccess )
    {
        //
        // It is normal for the above function to fail with
        // ERROR_INSUFFICIENT_BUFFER because we passed in NULL for the
        // device interface detail data (device name) structure.
        //

        dwError = GetLastError();

        if ( dwError != ERROR_INSUFFICIENT_BUFFER )
        {
            LOG((PHONESP_TRACE, "GetInstanceFromDeviceName - SetupDiGetDeviceInterfaceDetail failed: %08x", GetLastError()));
            
            //
            // Can't clean this up earlier, because it does SetLastError().
            //

            return HRESULT_FROM_WIN32( dwError );
        }
    }

    *pdwInstance = devinfoData.DevInst;
    
    //
    // Can't clean this up earlier, because it does SetLastError().
    //

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// 
//
// This function constructs an array of devinst DWORDs and an array of
// hardware ID strigs, both indexed by wave id, for either wave in or wave
// out devices. The devinsts are retrieved by (1) using undocumented calls
// to winmm to retrieve device name strings for each wave device, and (2)
// using SetupDi calls to retrieve a DevInst DWORD for each device name
// string (helper function GetInstanceFromDeviceName).
//
// The values are saved in an array because this process takes the bulk of the
// time in the HID --> audio mapping process, and therefore finding the mapping
// for several HID devices can be done in not much more time than for one HID
// device, just by reusing the array.
//
// Arguments:
//     fRender          - IN  - if TRUE, look for wave out devices
//     pdwNumDevices    - OUT - returns number of wave devices found
//     ppwszHardwareIds - OUT - returns "new"ed array of trimmed hardware id
//                              strings. The array is indexed by wave id. If
//                              a hardware id string cannot be determined for
//                              a particular wave id, then the string pointer
//                              in that position is set to NULL. Each string
//                              is "new"ed separately.
//     ppdwDevInsts     - OUT - returns "new"ed array of devinst DWORDs. The
//                              array is indexed by wave id. If a devinst
//                              cannot be determined for a particular wave id,
//                              then the DWORD in that position is set to
//                              (DWORD) -1.
//
// Return values:
//     S_OK          - success
//     E_OUTOFMEMORY - not enough memory to allocate a device name string or
//                     the return array
//

STATIC HRESULT
ConstructWaveHardwareIdCache(
    IN   BOOL      fRender,
    OUT  DWORD *   pdwNumDevices,
    OUT  WCHAR *** ppwszHardwareIds,
    OUT  DWORD **  ppdwDevInsts
    )
{
    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    ASSERT( ! IsBadWritePtr( pdwNumDevices, sizeof( DWORD ) ) );

    ASSERT( ! IsBadWritePtr( ppwszHardwareIds, sizeof( WCHAR ** ) ) );

    ASSERT( ! IsBadWritePtr( ppdwDevInsts, sizeof( DWORD * ) ) );

    //
    // Get a device info list
    //

    HDEVINFO hDevInfo;
   
    /*
    hDevInfo = SetupDiGetClassDevs(
        &GUID_DEVCLASS_MEDIA,            // class GUID (which device classes?)
        NULL,                            // optional enumerator to filter
        NULL,                            // HWND (we have none)
        ( DIGCF_PRESENT    |             // only devices that are present
          DIGCF_PROFILE )                // only devices in this hw profile
        );
        */

    hDevInfo = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_MEDIA, NULL);

    if ( hDevInfo == NULL )
    {
        LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - SetupDiCreateDeviceInfoList failed: %08x", GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Find the number of available wave devices.
    //

    DWORD     dwNumDevices;
    DWORD     dwCurrDevice;

    if ( fRender )
    {
        dwNumDevices = waveOutGetNumDevs();
    }
    else
    {
        dwNumDevices = waveInGetNumDevs();
    }
    
    //
    // Allocate space for the return arrays.
    //

    *pdwNumDevices    = dwNumDevices;

    *ppwszHardwareIds = new LPWSTR [ dwNumDevices ];

    if ( (*ppwszHardwareIds) == NULL )
    {
        return E_OUTOFMEMORY;
    }

    *ppdwDevInsts = new DWORD [ dwNumDevices ];

    if ( (*ppdwDevInsts) == NULL )
    {
        delete *ppwszHardwareIds;
        *ppwszHardwareIds = NULL;

        return E_OUTOFMEMORY;
    }

    //
    // Loop over the available wave devices.
    //

    for ( dwCurrDevice = 0; dwCurrDevice < dwNumDevices; dwCurrDevice++ )
    {
        //
        // For failure cases, we will return NULL string and -1 devinst
        // for that wave id. Callers should compare against the NULL, not
        // the -1.
        //

        (*ppwszHardwareIds) [ dwCurrDevice ] = NULL;
        (*ppdwDevInsts)     [ dwCurrDevice ] = -1;

        //
        // Get the size of the device path string.
        //
        
        MMRESULT  mmresult;
        ULONG     ulSize;

        if ( fRender )
        {
            mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                       DRV_QUERYDEVICEINTERFACESIZE,
                                       (DWORD_PTR) & ulSize,
                                       0
                                     );
        }
        else
        {
            mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                      DRV_QUERYDEVICEINTERFACESIZE,
                                      (DWORD_PTR) & ulSize,
                                      0
                                    );
        }

        if ( mmresult != MMSYSERR_NOERROR )
        {
            LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Could not get device string size for device %d; "
                "error = %d", dwCurrDevice, mmresult));
        }
        else if ( ulSize == 0 )
        {
            LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Got zero device string size for device %d",
                dwCurrDevice));
        }
        else
        {
            //
            // Allocate space for the device path string.
            //

            WCHAR * wszDeviceName;

            wszDeviceName = new WCHAR[ (ulSize / 2) + 1 ];

            if ( wszDeviceName == NULL )
            {
                LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Out of memory in device string alloc for device %d;"
                    " requested size is %d\n", dwCurrDevice, ulSize));

                delete *ppwszHardwareIds;
                *ppwszHardwareIds = NULL;

                delete *ppdwDevInsts;
                *ppdwDevInsts = NULL;

                return E_OUTOFMEMORY;
            }

            //
            // Get the device path string from winmm.
            //

            if ( fRender )
            {
                mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                           DRV_QUERYDEVICEINTERFACE,
                                           (DWORD_PTR) wszDeviceName,
                                           (DWORD_PTR) ulSize
                                         );
            }
            else
            {
                mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                          DRV_QUERYDEVICEINTERFACE,
                                          (DWORD_PTR) wszDeviceName,
                                          (DWORD_PTR) ulSize
                                        );
            }

            if ( mmresult == MMSYSERR_NOERROR )
            {
                //
                // Got the string. Now retrieve a devinst dword based on the
                // string.
                //

                // wprintf(L"\tDevice name string for device %d is:\n"
                //         L"\t\t%ws\n",
                //         dwCurrDevice, wszDeviceName);

                HRESULT hr;
                DWORD   dwInstance;
                
                hr = GetInstanceFromDeviceName(
                    wszDeviceName,
                    & dwInstance,
                    hDevInfo
                    );

                delete wszDeviceName;

                if ( FAILED(hr) )
                {
                    LOG((PHONESP_TRACE, "ConstructWaveHardwareIdCache - Can't get instance DWORD for device %d; "
                        "error 0x%08x\n",
                        dwCurrDevice, hr));
                }
                else
                {
                    //
                    // Based on the devinst dword, retrieve a trimmed
                    // hardware id string.
                    //

                    // printf("\tInstance DWORD for device %d is "
                    //        "0x%08x\n",
                    //        dwCurrDevice, dwInstance);

                    WCHAR * wszHardwareId;

                    hr = HardwareIdFromDevInst(
                        dwInstance,
                        & wszHardwareId
                        );

                    if ( SUCCEEDED(hr) )
                    {
                        (*ppwszHardwareIds) [ dwCurrDevice ] = wszHardwareId;
                        (*ppdwDevInsts)     [ dwCurrDevice ] = dwInstance;
                    }
                }
            }
        }
    }

    SetupDiDestroyDeviceInfoList( hDevInfo );
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// FindWaveIdFromHardwareIdString
//
// This function finds the wave id for a device whose devinst and hardware id
// string are known.
//
// Constructing the mapping from waveid to devinst and hardwave id string
// takes some time, so the mapping is only constructed once for each
// direction (render/capture), via the helper function
// ConstructWaveHardwareIdCache().
//
// Thereafter, the helper function MatchHardwareIdInArray() is used to run
// the matching algorithm based on the already-computed arrays. See that
// function for a description of how the matching is done.
//
// Arguments:
//     dwHidDevInst     - IN  - the devinst dword to match to a wave id
//     wszHardwareId    - IN  - the hardware id string for the devinst
//     fRender          - IN  - TRUE for wave out, FALSE for wave in
//     pdwMatchedWaveId - OUT - the wave id associated with the devinst
//
// Return values:
//      S_OK - success
//      various errors from ConstructWaveHardwareIdCache() and
//         MatchHardwareIdInArray() helper functions
//

STATIC HRESULT
FindWaveIdFromHardwareIdString(
    IN   DWORD   dwHidDevInst,
    IN   WCHAR * wszHardwareId,
    IN   BOOL    fRender,
    OUT  DWORD * pdwMatchedWaveId
    )
{
    ASSERT( ! IsBadStringPtrW( wszHardwareId, (DWORD) -1 ) );

    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    ASSERT( ! IsBadWritePtr(pdwMatchedWaveId, sizeof(DWORD) ) );

    DWORD    dwNumDevices = 0;
    WCHAR ** pwszHardwareIds = NULL;
    DWORD  * pdwDevInsts = NULL;

    HRESULT hr;

    //
    // Need to construct cache of render device hardware IDs.
    //

    hr = ConstructWaveHardwareIdCache(
        fRender,
        & dwNumDevices,
        & pwszHardwareIds,
        & pdwDevInsts
        );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // The cache is ready; use it to perform the rest of the matching
    // algorithm.
    //

    hr = MatchHardwareIdInArray(
        dwHidDevInst,
        wszHardwareId,
        dwNumDevices,
        pwszHardwareIds,
        pdwDevInsts,
        pdwMatchedWaveId
        );

    //
    // Free the cache
    //

    for ( DWORD dwCurrDevice = 0; dwCurrDevice < dwNumDevices; dwCurrDevice++ )
    {
        if( pwszHardwareIds[ dwCurrDevice ] )
        {
            delete pwszHardwareIds[ dwCurrDevice ];
        }
    }

    delete pwszHardwareIds;
    delete pdwDevInsts;

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// OutputDeviceInfo
//
// This function is for diagnostic purposes only.
//
// Given a devinst DWORD, this function prints the DeviceDesc string as well
// as the entire (untrimmed) hardware ID string set for the device. Example:
//
//
//
// Arguments:
//     dwDesiredDevInst - IN  - the devinst dword for which we want info
//
// Return values:
//     none
//

STATIC void
OutputDeviceInfo(
    DWORD dwDesiredDevInst
    )
{
    //
    // Get and print the device description string.
    //

    HRESULT   hr;
    WCHAR   * wszDeviceDesc;
    WCHAR   * wszHardwareId;

    hr = DevInstGetIdString(
        dwDesiredDevInst,
        CM_DRP_DEVICEDESC,
        & wszDeviceDesc
        );

    if ( FAILED(hr) )
    {
        LOG((PHONESP_TRACE, "OutputDeviceInfo - [can't get device description string - 0x%08x]", hr));
    }
    else
    {
        LOG((PHONESP_TRACE, "OutputDeviceInfo - [DeviceDesc: %ws]", wszDeviceDesc));

        delete wszDeviceDesc;
    }

    //
    // Get and print hardware ID string set.
    //

    hr = DevInstGetIdString(
        dwDesiredDevInst,
        CM_DRP_HARDWAREID,
        & wszHardwareId
        );

    if ( FAILED(hr) )
    {
        LOG((PHONESP_TRACE, "OutputDeviceInfo - [can't get hardware id - 0x%08x]", hr));
    }
    else
    {
        //
        // Print out all the values in the mutli-string.
        //

        WCHAR * wszCurr = wszHardwareId;

        while ( wszCurr[0] != L'\0' )
        {
            LOG((PHONESP_TRACE, "OutputDeviceInfo - [HardwareId: %ws]", wszCurr));

            wszCurr += lstrlenW(wszCurr) + 1;
        }

        delete wszHardwareId;
    }

}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Externally-callable functions
//
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// ExamineWaveDevices
//
// This function is for debugging purposes only. It enumerates audio devices
// using the Wave API and prints the device path string as well as the
// device instance DWORD for each render or capture device.
//
// Arguments:
//      fRender - IN - true means examine wave out devices; false = wave in
//
// Return values:
//      E_OUTOFMEMORY
//      S_OK
//

HRESULT
ExamineWaveDevices(
    IN    BOOL fRender
    )
{
    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    DWORD     dwNumDevices;
    DWORD     dwCurrDevice;

    //
    // Get a device info list
    //

    HDEVINFO hDevInfo;
   
    /*
    hDevInfo = SetupDiGetClassDevs(
        &GUID_DEVCLASS_MEDIA,            // class GUID (which device classes?)
        NULL,                            // optional enumerator to filter
        NULL,                            // HWND (we have none)
        ( DIGCF_PRESENT    |             // only devices that are present
          DIGCF_PROFILE )                // only devices in this hw profile
        );
        */

    hDevInfo = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_MEDIA, NULL);

    if ( hDevInfo == NULL )
    {
        LOG((PHONESP_TRACE, "ExamineWaveDevices - SetupDiCreateDeviceInfoList failed: %08x", GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Loop over the available wave devices.
    //

    if ( fRender )
    {
        dwNumDevices = waveOutGetNumDevs();
    }
    else
    {
        dwNumDevices = waveInGetNumDevs();
    }

    LOG((PHONESP_TRACE, "ExamineWaveDevices - Found %d audio %s devices.",
        dwNumDevices,
        fRender ? "render" : "capture"));

    for ( dwCurrDevice = 0; dwCurrDevice < dwNumDevices; dwCurrDevice++ )
    {
        MMRESULT  mmresult;
        ULONG     ulSize;

        //
        // Get the size of the device path string.
        //

        if ( fRender )
        {
            mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                       DRV_QUERYDEVICEINTERFACESIZE,
                                       (DWORD_PTR) & ulSize,
                                       0
                                     );
        }
        else
        {
            mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                      DRV_QUERYDEVICEINTERFACESIZE,
                                      (DWORD_PTR) & ulSize,
                                      0
                                    );
        }

        if ( mmresult != MMSYSERR_NOERROR )
        {
            LOG((PHONESP_TRACE, "ExamineWaveDevices - Could not get device string size for device %d; "
                "error = %d\n", dwCurrDevice, mmresult));
        }
        else if ( ulSize == 0 )
        {
            LOG((PHONESP_TRACE, "ExamineWaveDevices - Got zero device string size for device %d\n",
                dwCurrDevice));
        }
        else
        {
            //
            // Allocate space for the device path string.
            //

            WCHAR * wszDeviceName;

            wszDeviceName = new WCHAR[ (ulSize / 2) + 1 ];

            if ( wszDeviceName == NULL )
            {
                LOG((PHONESP_TRACE, "ExamineWaveDevices - Out of memory in device string alloc for device %d;"
                    " requested size is %d\n", dwCurrDevice, ulSize));

                return E_OUTOFMEMORY;
            }

            //
            // Get the device path string from winmm.
            //

            if ( fRender )
            {
                mmresult = waveOutMessage( (HWAVEOUT) IntToPtr(dwCurrDevice),
                                           DRV_QUERYDEVICEINTERFACE,
                                           (DWORD_PTR) wszDeviceName,
                                           ulSize
                                         );
            }
            else
            {
                mmresult = waveInMessage( (HWAVEIN) IntToPtr(dwCurrDevice),
                                          DRV_QUERYDEVICEINTERFACE,
                                          (DWORD_PTR) wszDeviceName,
                                          ulSize
                                        );
            }

            if ( mmresult == MMSYSERR_NOERROR )
            {
                //
                // Got the string; print it and convert it to a
                // devinst DWORD.
                //

                LOG((PHONESP_TRACE, "ExamineWaveDevices - Device name string for device %d is: %ws",
                    dwCurrDevice, wszDeviceName));

                HRESULT hr;
                DWORD   dwInstance;
                
                hr = GetInstanceFromDeviceName(
                    wszDeviceName,
                    & dwInstance,
                    hDevInfo
                    );

                if ( FAILED(hr) )
                {
                    LOG((PHONESP_TRACE, "ExamineWaveDevices - Can't get instance DWORD for device %d; "
                        "error 0x%08x",
                        dwCurrDevice, hr));
                }
                else
                {
                    LOG((PHONESP_TRACE, "ExamineWaveDevices - Instance DWORD for device %d is "
                        "0x%08x",
                        dwCurrDevice, dwInstance));

                    //
                    // Print various other info about this device.
                    //

                    OutputDeviceInfo( dwInstance );

                    WCHAR * wszHardwareId;

                    hr = HardwareIdFromDevInst(
                        dwInstance,
                        & wszHardwareId
                        );

                    if ( FAILED(hr) )
                    {
                        LOG((PHONESP_TRACE, "ExamineWaveDevices - Can't get hardware id string for device %d; "
                            "error 0x%08x",
                            dwCurrDevice, hr));
                    }
                    else
                    {
                        LOG((PHONESP_TRACE, "ExamineWaveDevices - Hardware ID for device %d is %ws\n",
                            dwCurrDevice, wszHardwareId));

                        delete wszHardwareId;
                    }
                }

                delete wszDeviceName;
            }
        }
    }

    SetupDiDestroyDeviceInfoList( hDevInfo );
    
    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
//
// DiscoverAssociatedWaveId
//
// This function searches for a wave device to match the HID device in the
// PNP tree location specified in the passed in SP_DEVICE_INTERFACE_DATA
// structure, obtained from the SetupKi API. It returns the wave id for
// the matched device.
//
// It uses the helper function FindWaveIdFromHardwareIdString() to search for
// the wave device based on a devinst DWORD and a hardware ID string. First,
// it must obtain the devinst for the device; it does this by calling a SetupDi
// function and looking up the devinst in a resulting structure. The hardware
// ID string is then retrieved from the registry and trimmed, using the helper
// function HardwareIdFromDevinst().
//
// See FindWaveIdFromHardwareIdString() for further comments on the search
// algorithm.
//
// Arguments:
//     dwDevInst     - IN  - Device Instance of the HID device
//     fRender       - IN  - TRUE for wave out, FALSE for wave in
//     pdwWaveId     - OUT - the wave id associated with this HID device
//
// Return values:
//      S_OK    - succeeded and matched wave id
//      other from helper functions FindWaveIdFromHardwareIdString() or
//            or HardwareIdFromDevinst()
//

HRESULT
DiscoverAssociatedWaveId(
    IN    DWORD                      dwDevInst,
    IN    BOOL                       fRender,
    OUT   DWORD                    * pdwWaveId
    )
{
    ASSERT( ! IsBadWritePtr(pdwWaveId, sizeof(DWORD) ) );

    ASSERT( ( fRender == TRUE ) || ( fRender == FALSE ) );

    //
    // We've got the device instance DWORD for the HID device.
    // Use it to get the trimmed hardware ID string, which tells
    // us the vendor, product, and revision numbers.
    //

    HRESULT   hr;
    WCHAR   * wszHardwareId;

    hr = HardwareIdFromDevInst(
        dwDevInst,
        & wszHardwareId
        );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Finally, use this information to choose a wave id.
    //

    hr = FindWaveIdFromHardwareIdString(
        dwDevInst,
        wszHardwareId,
        fRender,
        pdwWaveId
        );

    delete wszHardwareId;

    if ( FAILED(hr) )
    {
        return hr;
    }

    return S_OK;
}

//
// eof
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\mylog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    myLOG.h

Abstract:

    Definitions for logging support.

Author:
    
    Mu Han (muhan) 1-April-1997

--*/

#ifndef _PHONESPLOG_H_
    #define _PHONESPLOG_H_

    #ifdef PHONESPLOG

        #include <rtutils.h>

        #define PHONESP_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
        #define PHONESP_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
        #define PHONESP_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
        #define PHONESP_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
        #define PHONESP_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

        BOOL NTAPI LogRegisterDebugger(LPCTSTR szName);
        BOOL NTAPI LogRegisterTracing(LPCTSTR szName);
        void NTAPI LogDeRegisterDebugger();
        void NTAPI LogDeRegisterTracing();
        void NTAPI LogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

        #define LOGREGISTERDEBUGGER(arg) LogRegisterDebugger(arg)
        #define LOGREGISTERTRACING(arg) LogRegisterTracing(arg)
        #define LOGDEREGISTERDEBUGGER() LogDeRegisterDebugger()
        #define LOGDEREGISTERTRACING() LogDeRegisterTracing()
        #define LOG(arg) LogPrint arg

    #else // PHONESPLOG

        #define LOGREGISTERDEBUGGER(arg)
        #define LOGREGISTERTRACING(arg)
        #define LOGDEREGISTERDEBUGGER() 
        #define LOGDEREGISTERTRACING() 
        #define LOG(arg)

    #endif // PHONESPLOG

    
    #define DECLARE_LOG_ADDREF_RELEASE(x)
    #define CMSPComObject CComObject

#endif // _PHONESPLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\hid.h ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    hid.h

Abstract:

    This module contains the declarations and definitions for use with the
    hid user mode client sample driver.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#ifndef HID_H
#define HID_H

#include "hidsdi.h"
#include "setupapi.h"

#define ASSERT(x)

//
// A structure to hold the steady state data received from the hid device.
// Each time a read packet is received we fill in this structure.
// Each time we wish to write to a hid device we fill in this structure.
// This structure is here only for convenience.  Most real applications will
// have a more efficient way of moving the hid data to the read, write, and
// feature routines.
//
typedef struct _HID_DATA {
   BOOL        IsButtonData;
   UCHAR       Reserved;
   USAGE       UsagePage;   // The usage page for which we are looking.
   ULONG       Status;      // The last status returned from the accessor function
                            // when updating this field.
   ULONG       ReportID;    // ReportID for this given data structure
   BOOL        IsDataSet;   // Variable to track whether a given data structure
                            //  has already been added to a report structure

   union {
      struct {
         ULONG       UsageMin;       // Variables to track the usage minimum and max
         ULONG       UsageMax;       // If equal, then only a single usage
         ULONG       MaxUsageLength; // Usages buffer length.
         PUSAGE      Usages;         // list of usages (buttons ``down'' on the device.

      } ButtonData;
      struct {
         USAGE       Usage; // The usage describing this value;
         USHORT      Reserved;

         ULONG       Value;
         LONG        ScaledValue;
      } ValueData;
   };
} HID_DATA, *PHID_DATA;

typedef struct _HID_DEVICE {
   HANDLE               HidDevice; // A file handle to the hid device.
   PHIDP_PREPARSED_DATA Ppd; // The opaque parser info describing this device
   HIDP_CAPS            Caps; // The Capabilities of this hid device.
   HIDD_ATTRIBUTES      Attributes;

   PCHAR                InputReportBuffer;
   PHID_DATA            InputData; // array of hid data structures
   ULONG                InputDataLength; // Num elements in this array.
   PHIDP_BUTTON_CAPS    InputButtonCaps;
   PHIDP_VALUE_CAPS     InputValueCaps;

   PCHAR                OutputReportBuffer;
   PHID_DATA            OutputData;
   ULONG                OutputDataLength;
   PHIDP_BUTTON_CAPS    OutputButtonCaps;
   PHIDP_VALUE_CAPS     OutputValueCaps;

   PCHAR                FeatureReportBuffer;
   PHID_DATA            FeatureData;
   ULONG                FeatureDataLength;
   PHIDP_BUTTON_CAPS    FeatureButtonCaps;
   PHIDP_VALUE_CAPS     FeatureValueCaps;

   DWORD                dwDevInst;  // device instance
   BOOL                 bRemoved;   // this device has been removed by pnp
   BOOL                 bNew;       // this device is a new arrival by pnp

   PSP_DEVICE_INTERFACE_DETAIL_DATA  functionClassDeviceData;  // this contains the device path

   struct _HID_DEVICE   *Next;
   struct _HID_DEVICE   *Prev;

} HID_DEVICE, *PHID_DEVICE;


// These functions are implemented in PNP.c
LONG
FindKnownHidDevices (
   OUT PHID_DEVICE   *pHidDevices,
   OUT PULONG        pNumberHidDevices
   );

LONG
FillDeviceInfo (
    IN  PHID_DEVICE HidDevice
    );

VOID
CloseHidDevices ();

VOID
CloseHidDevice (
    IN OUT PHID_DEVICE   HidDevice
    );

BOOL
OpenHidFile (
    IN  PHID_DEVICE HidDevice
    );

BOOL
CloseHidFile (
    IN  PHID_DEVICE HidDevice
    );


// These functions are implemented in Report.c
BOOL
Write (
   PHID_DEVICE    HidDevice
   );


BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );


BOOL
GetFeature (
   PHID_DEVICE    HidDevice
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\hidphone.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

     hidphone.h

Abstract:

    This module contains the definitions of all the data structures being used 
    in hidphone.c

Author: Shivani Aggarwal

--*/

#ifndef _HIDPHONE_H_
#define _HIDPHONE_H_

#include <windows.h>
#include <tspi.h>
#include <tapi.h>

#include <winbase.h>
#include <setupapi.h>
#include <TCHAR.h>
#include <mmsystem.h>

// * NOTE - initguid.h must always be defined before devguid.h 
#include <initguid.h>  
#include <hidclass.h>
#include <dbt.h>

#include "hidsdi.h"
#include "hid.h"
#include "resource.h"
#include "audio.h"
#include "mymem.h"

#define LOW_VERSION   0x00020000
#define HIGH_VERSION  0x00030001

//
// MAX_CHARS is used as an upper limit on the number of chars required
// to store the phone id as a string. The phone ids begin from 0
// to gdwNumPhones which a DWORD, hence 32-bit. Therefore the largest number
// possible is 4294967296. Hence 20 chars are enough to store the largest string 
//
#define MAX_CHARS               20

// In order to distinguish between value and button usages
#define PHONESP_BUTTON          1
#define PHONESP_VALUE           0                

// Registry strings
#define	REGSTR_PATH_WINDOWS_CURRENTVERSION		TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define TAPI_REGKEY_ROOT						REGSTR_PATH_WINDOWS_CURRENTVERSION TEXT("\\Telephony")
#define TAPI_REGKEY_PROVIDERS					TAPI_REGKEY_ROOT TEXT("\\Providers")
#define TAPI_REGVAL_NUMPROVIDERS				TEXT("NumProviders")

#define HIDPHONE_TSPDLL                         TEXT("HIDPHONE.TSP")

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Telephony HID definitions
// These are usages already defined in the Hid Telephony page. 
// Just defining the usages with User-friendly names

//
// Definitions of relevant usages on the telephony page.

#define HID_USAGE_TELEPHONY_HANDSET           ((USAGE) 0x04)
#define HID_USAGE_TELEPHONY_HEADSET           ((USAGE) 0x05)
#define HID_USAGE_TELEPHONY_HOOKSWITCH        ((USAGE) 0x20)
#define HID_USAGE_TELEPHONY_FLASH             ((USAGE) 0x21)
#define HID_USAGE_TELEPHONY_HOLD              ((USAGE) 0x23)
#define HID_USAGE_TELEPHONY_REDIAL            ((USAGE) 0x24)
#define HID_USAGE_TELEPHONY_TRANSFER          ((USAGE) 0x25)
#define HID_USAGE_TELEPHONY_DROP              ((USAGE) 0x26)
#define HID_USAGE_TELEPHONY_PARK              ((USAGE) 0x27)
#define HID_USAGE_TELEPHONY_FORWARD_CALLS     ((USAGE) 0x28)
#define HID_USAGE_TELEPHONY_LINE              ((USAGE) 0x2A)
#define HID_USAGE_TELEPHONY_SPEAKER_PHONE     ((USAGE) 0x2B)
#define HID_USAGE_TELEPHONY_CONFERENCE        ((USAGE) 0x2C)
#define HID_USAGE_TELEPHONY_RING_SELECT       ((USAGE) 0x2E)
#define HID_USAGE_TELEPHONY_PHONE_MUTE        ((USAGE) 0x2F)
#define HID_USAGE_TELEPHONY_CALLERID          ((USAGE) 0x30)
#define HID_USAGE_TELEPHONY_SEND              ((USAGE) 0x31)
#define HID_USAGE_TELEPHONY_DONOTDISTURB      ((USAGE) 0x72)
#define HID_USAGE_TELEPHONY_RINGER            ((USAGE) 0x9E)
#define HID_USAGE_TELEPHONY_PHONE_KEY_0       ((USAGE) 0xB0)
#define HID_USAGE_TELEPHONY_PHONE_KEY_1       ((USAGE) 0xB1)
#define HID_USAGE_TELEPHONY_PHONE_KEY_2       ((USAGE) 0xB2)
#define HID_USAGE_TELEPHONY_PHONE_KEY_3       ((USAGE) 0xB3)
#define HID_USAGE_TELEPHONY_PHONE_KEY_4       ((USAGE) 0xB4)
#define HID_USAGE_TELEPHONY_PHONE_KEY_5       ((USAGE) 0xB5)
#define HID_USAGE_TELEPHONY_PHONE_KEY_6       ((USAGE) 0xB6)
#define HID_USAGE_TELEPHONY_PHONE_KEY_7       ((USAGE) 0xB7)
#define HID_USAGE_TELEPHONY_PHONE_KEY_8       ((USAGE) 0xB8)
#define HID_USAGE_TELEPHONY_PHONE_KEY_9       ((USAGE) 0xB9)
#define HID_USAGE_TELEPHONY_PHONE_KEY_STAR    ((USAGE) 0xBA)
#define HID_USAGE_TELEPHONY_PHONE_KEY_POUND   ((USAGE) 0xBB)
#define HID_USAGE_TELEPHONY_PHONE_KEY_A       ((USAGE) 0xBC)
#define HID_USAGE_TELEPHONY_PHONE_KEY_B       ((USAGE) 0xBD)
#define HID_USAGE_TELEPHONY_PHONE_KEY_C       ((USAGE) 0xBE)
#define HID_USAGE_TELEPHONY_PHONE_KEY_D       ((USAGE) 0xBF)

#define HID_USAGE_CONSUMER_VOLUME             ((USAGE) 0xE0)

#define PHONESP_ALLBUTTONMODES                   \
        (   PHONEBUTTONMODE_CALL               | \
            PHONEBUTTONMODE_FEATURE            | \
            PHONEBUTTONMODE_KEYPAD             | \
            PHONEBUTTONMODE_LOCAL              | \
            PHONEBUTTONMODE_DISPLAY )

#define PHONESP_ALLBUTTONSTATES              \
        (PHONEBUTTONSTATE_UP               | \
         PHONEBUTTONSTATE_DOWN)     


// These act like bit masks which specify which reports are valid for a usage
#define INPUT_REPORT                   1
#define OUTPUT_REPORT                  2
#define FEATURE_REPORT                 4


/*****************************************************************************/
//
// This structure holds the information for the button
//
typedef struct _PHONESP_BUTTON_INFO
{
    // The ID for this button 
    DWORD dwButtonID;

   // The ButtonMode (whether it is a PHONEBUTTONMODE_FEATURE or _KEYPAD, etc)
    DWORD dwButtonMode;

    // the Function (PHONEBUTTONFUNCTION_NONE or _FLASH, etc),
    DWORD dwButtonFunction;

    //
    // This data is relevant for only on-off control buttons. The current state
    // of the button is stored here
    //
    DWORD dwButtonState;

    // the Button Text associated for the button - these are present in the 
    // string table 
    LPWSTR szButtonText;

} PHONESP_BUTTONINFO, *PPHONESP_BUTTONINFO;

/*****************************************************************************/
// 
//
// User friendly names for the indexes into the capabilities of the phone structure
//
#define PHONESP_PHONE_KEY_0             0
#define PHONESP_PHONE_KEY_1             1
#define PHONESP_PHONE_KEY_2             2
#define PHONESP_PHONE_KEY_3             3
#define PHONESP_PHONE_KEY_4             4
#define PHONESP_PHONE_KEY_5             5
#define PHONESP_PHONE_KEY_6             6
#define PHONESP_PHONE_KEY_7             7
#define PHONESP_PHONE_KEY_8             8
#define PHONESP_PHONE_KEY_9             9
#define PHONESP_PHONE_KEY_STAR          10
#define PHONESP_PHONE_KEY_POUND         11
#define PHONESP_PHONE_KEY_A             12
#define PHONESP_PHONE_KEY_B             13
#define PHONESP_PHONE_KEY_C             14
#define PHONESP_PHONE_KEY_D             15

// The number of dial buttons supported by this tsp
#define PHONESP_NUMBER_PHONE_KEYS       16

// Feature Button indices
#define PHONESP_FEATURE_FLASH                   16
#define PHONESP_FEATURE_HOLD                    17
#define PHONESP_FEATURE_REDIAL                  18
#define PHONESP_FEATURE_TRANSFER                19
#define PHONESP_FEATURE_DROP                    20
#define PHONESP_FEATURE_PARK                    21
#define PHONESP_FEATURE_FORWARD                 22
#define PHONESP_FEATURE_LINE                    23
#define PHONESP_FEATURE_CONFERENCE              24
#define PHONESP_FEATURE_RING_SELECT             25
#define PHONESP_FEATURE_PHONE_MUTE              26
#define PHONESP_FEATURE_CALLERID                27
#define PHONESP_FEATURE_DONOTDISTURB            28
#define PHONESP_FEATURE_SEND                    29
#define PHONESP_FEATURE_VOLUMEUP                30
#define PHONESP_FEATURE_VOLUMEDOWN              31

// The number of Feature buttons supported by this tsp
#define PHONESP_NUMBER_FEATURE_BUTTONS               16
#define PHONESP_NUMBER_BUTTONS              ( PHONESP_NUMBER_PHONE_KEYS +     \
                                              PHONESP_NUMBER_FEATURE_BUTTONS )

//
// The functions associated with the feature buttons 
//
DWORD gdwButtonFunction[] = 
{
    PHONEBUTTONFUNCTION_FLASH,
    PHONEBUTTONFUNCTION_HOLD,
    PHONEBUTTONFUNCTION_LASTNUM,
    PHONEBUTTONFUNCTION_TRANSFER,
    PHONEBUTTONFUNCTION_DROP,
    PHONEBUTTONFUNCTION_PARK,
    PHONEBUTTONFUNCTION_FORWARD,
    PHONEBUTTONFUNCTION_CALLAPP,
    PHONEBUTTONFUNCTION_CONFERENCE,
    PHONEBUTTONFUNCTION_SELECTRING,
    PHONEBUTTONFUNCTION_MUTE,
    PHONEBUTTONFUNCTION_CALLID,
    PHONEBUTTONFUNCTION_DONOTDISTURB,
    PHONEBUTTONFUNCTION_SEND,
    PHONEBUTTONFUNCTION_VOLUMEUP,
    PHONEBUTTONFUNCTION_VOLUMEDOWN
};

// 
// The associated string table ID for the text of the phone buttons
// 
DWORD gdwButtonText[] =
{
    IDS_PHONE_KEY_0,
    IDS_PHONE_KEY_1,
    IDS_PHONE_KEY_2,
    IDS_PHONE_KEY_3,
    IDS_PHONE_KEY_4,
    IDS_PHONE_KEY_5,
    IDS_PHONE_KEY_6,
    IDS_PHONE_KEY_7,
    IDS_PHONE_KEY_8,
    IDS_PHONE_KEY_9,
    IDS_PHONE_KEY_STAR,
    IDS_PHONE_KEY_POUND,
    IDS_PHONE_KEY_A,
    IDS_PHONE_KEY_B,
    IDS_PHONE_KEY_C,
    IDS_PHONE_KEY_D,
    IDS_BUTTON_FLASH,
    IDS_BUTTON_HOLD,
    IDS_BUTTON_REDIAL,
    IDS_BUTTON_TRANSFER,
    IDS_BUTTON_DROP,
    IDS_BUTTON_PARK,
    IDS_BUTTON_FORWARD,
    IDS_BUTTON_LINE,    
    IDS_BUTTON_CONFERENCE,
    IDS_BUTTON_RING_SELECT,
    IDS_BUTTON_MUTE,
    IDS_BUTTON_CALLERID,
    IDS_BUTTON_DONOTDISTURB,
    IDS_BUTTON_SEND,
    IDS_BUTTON_VOLUMEUP,
    IDS_BUTTON_VOLUMEDOWN
};



typedef struct _PHONESP_LOOKUP_USAGEINDEX
{
    USAGE Usage;
    DWORD Index;
}PHONESP_LOOKUPUSAGEINDEX, *PPHONESP_LOOKUPUSAGEINDEX;

// inorder to look up the index for the feature button usages
// The 1st value in this 2-D array are the feature usages supported
// The 2nd value is the respective index

PHONESP_LOOKUPUSAGEINDEX gdwLookupFeatureIndex [] =   
{
    { HID_USAGE_TELEPHONY_FLASH,         PHONESP_FEATURE_FLASH        },
    { HID_USAGE_TELEPHONY_HOLD,          PHONESP_FEATURE_HOLD         },
    { HID_USAGE_TELEPHONY_REDIAL,        PHONESP_FEATURE_REDIAL       },
    { HID_USAGE_TELEPHONY_TRANSFER,      PHONESP_FEATURE_TRANSFER     },
    { HID_USAGE_TELEPHONY_DROP,          PHONESP_FEATURE_DROP         },
    { HID_USAGE_TELEPHONY_PARK,          PHONESP_FEATURE_PARK         },
    { HID_USAGE_TELEPHONY_FORWARD_CALLS, PHONESP_FEATURE_FORWARD      },
    { HID_USAGE_TELEPHONY_LINE,          PHONESP_FEATURE_LINE         },
    { HID_USAGE_TELEPHONY_CONFERENCE,    PHONESP_FEATURE_CONFERENCE   },
    { HID_USAGE_TELEPHONY_RING_SELECT,   PHONESP_FEATURE_RING_SELECT  },
    { HID_USAGE_TELEPHONY_PHONE_MUTE,    PHONESP_FEATURE_PHONE_MUTE   },
    { HID_USAGE_TELEPHONY_CALLERID,      PHONESP_FEATURE_CALLERID     },
    { HID_USAGE_TELEPHONY_DONOTDISTURB,  PHONESP_FEATURE_DONOTDISTURB },
    { HID_USAGE_TELEPHONY_SEND,          PHONESP_FEATURE_SEND         }
};

/****************************************************************************/
//
// This structure maintains the information available about the phone. Every
// phone that has been enumerated has this structure associated with it
//
typedef struct _PHONESP_PHONE_INFO
{
    // The deviceID for the phone. The Device ID for the phone is initialized
    // in TSPI_providerInit 
    DWORD                   dwDeviceID;
    
    //
    // The version negotiated with TAPI using TSPI_phoneNegotiateTSPIVersion 
    // function that returns the highest SPI version the TSP can operate under 
    // for this device.
    //
    DWORD                   dwVersion;

    //
    // if this is true then it means that the
    // phone is open and phone close on the device hasn't been called yet
    //
    BOOL                    bPhoneOpen;

    //
    // if this is false it means that this entry in the phone array is
    // unused and can be filled in with a new phone
    //
    BOOL                    bAllocated;

    //
    // if this is true it means that a PHONE_CREATE message was sent for this
    // phone, but we are waiting for a TSPI_providerCreatePhoneDevice
    //
    BOOL                    bCreatePending;

    //
    // if this is true it means that a PHONE_REMOVE message was sent for this
    // phone, but we are waiting for a TSPI_phoneClose
    //
    BOOL                    bRemovePending;
    
    //
    // This variable keeps a count of the number of requests queued for this 
    // phone in the async queue
    //
    DWORD                   dwNumPendingReqInQueue;

    //
    // A handle to an event object which is set when there are no requests
    // pending in the queue for this phone. Phone Close waits on this event 
    // to ensure that all asynchronous operations on the phone has been
    // completed
    //
    HANDLE                  hNoPendingReqInQueueEvent;


    //
    // The handle for the phone received from TAPI and used by the phone
    // to notify TAPI about the events occuring on this phone
    //
    HTAPIPHONE              htPhone;

    //
    //Pointer to the Hid Device structure associated with this device
    //
    PHID_DEVICE                pHidDevice;

    //
    // Whether the phone device has a render device associated with it
    //
    BOOL                    bRender;
    
    //
    // if the render device exists for this phone, this data contains the 
    // render device id
    //
    DWORD                   dwRenderWaveId;

    //
    // Whether the phone device has a capture device associated with it
    //
    BOOL                    bCapture;

    //
    // if the capture device exists for this phone, this data contains the 
    // capture device id
    //
    DWORD                   dwCaptureWaveId;

 
    // This event is signalled when a input report is recieved from the device
    HANDLE                  hInputReportEvent;

    // This event is signalled when the phone is closed
    HANDLE                  hCloseEvent;

    // A handle to the read thread
    HANDLE                  hReadThread;
    
    // The structure to be passed to the ReadFile function - This struct will
    // pass the hInputReportEvent which will be triggered when ReadFile returns 
    LPOVERLAPPED            lpOverlapped;

    // The Critical Section for this phone
    CRITICAL_SECTION        csThisPhone;

    // lpfnPhoneEventProc is a callback function implemented by TAPI and 
    // supplied to the TSP as a parameter to TSPI_phoneOpen The TSP calls this
    // function to report events that occur on the phone.
    //
    PHONEEVENT              lpfnPhoneEventProc;  

    // The phone states messages for which TAPI can receive notification
    DWORD                   dwPhoneStates;

    //
    // The phone state messages TAPI is interested in receiving
    //
    DWORD                    dwPhoneStateMsgs;   
                                                 
    // 
    // The last three bits of this data signify which reports are valid for the
    // handset/speaker. If zero, the handset does not exist, if bit 0 is set - 
    // input report can be received, if bit 1 is set - output report can be 
    // sent, if bit 2 is set - feature report supported
    //
    DWORD                   dwHandset;
    DWORD                   dwSpeaker;


    //
    // The mode of the handset/ speaker at the moment whether _ONHOOK, _MIC, 
    // _SPEAKER, _MICSPEAKER. These modes are defined by TAPI
    //
    DWORD                   dwHandsetHookSwitchMode;
    DWORD                   dwSpeakerHookSwitchMode;

    BOOL                    bSpeakerHookSwitchButton;

    //
    // The hookswitch supported on this phone - handset and/or speaker
    //
    DWORD                   dwHookSwitchDevs; 

    // To determine whether the phone has a keypad
    BOOL                    bKeyPad;

    // 
    // The last three bits of this data signify which reports are valid for the
    // ringer. If zero, the handset does not exist, if bit 0 is set - input 
    // report can be received, if bit 1 is set - output report can be sent, if 
    // bit 2 is set - feature report supported
    //
    DWORD                    dwRing;

    // 
    // The last three bits of this data signify which reports are valid for the
    // volume control. If zero, the handset does not exist, if bit 0 is set - input 
    // report can be received, if bit 1 is set - output report can be sent, if 
    // bit 2 is set - feature report supported
    //
    DWORD                    dwVolume;

    //
    // The mode of the handset/ speaker at the moment whether ringing or not
    // if zero the phone is not ringing 
    //
    DWORD                   dwRingMode;

    // The buttonmodes for which the phone will send phone events
    DWORD                   dwButtonModesMsgs;

    // The button states for which the phone will send phone events
    DWORD                   dwButtonStateMsgs; 

    // Number of usable buttons on this phone 
    DWORD                    dwNumButtons;
    PPHONESP_BUTTONINFO     pButtonInfo;

    //
    // The Phone Name and other Info on this Phone which will be displayed 
    //
    LPWSTR                  wszPhoneName, wszPhoneInfo;

    //
    // The buttons valid for this phone - the entry for the 
    // corresponding button contains 0 if the button associated with the index 
    // does not exist else it specifies the report types valid for this button
    // using the last 3 bits. 
    //
    DWORD                   dwReportTypes[PHONESP_NUMBER_BUTTONS];

    //
    // After the button is created this contains the 
    // report Id assigned to the button
    //
    DWORD                   dwButtonIds[PHONESP_NUMBER_BUTTONS];

} PHONESP_PHONE_INFO, *PPHONESP_PHONE_INFO;
/*****************************************************************************/

typedef void (CALLBACK *ASYNCPROC)(PPHONESP_ASYNCREQINFO, BOOL);



/*****************************************************************************/
typedef struct _PHONESP_FUNC_INFO
{
    // number of parameters in this array - don't actually use it, can be removed
    DWORD                   dwNumParams;  

    // The pointer to the phone 
    ULONG_PTR               dwParam1;

    //
    // The rest of the parameters are dependent on the function 
    // to which this parameter list is passed
    //
    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;
    ULONG_PTR               dwParam4;
    ULONG_PTR               dwParam5;
    ULONG_PTR               dwParam6;
    ULONG_PTR               dwParam7;
    ULONG_PTR               dwParam8;

} PHONESP_FUNC_INFO, far *PPHONESP_FUNC_INFO;
/*****************************************************************************/

typedef struct _PHONESP_ASYNC_REQUEST_INFO
{
    // The function to be executed
    ASYNCPROC               pfnAsyncProc;

    // Parameters to be passed to the async function
    PPHONESP_FUNC_INFO            pFuncInfo;

} PHONESP_ASYNC_REQ_INFO, *PPHONESP_ASYNC_REQ_INFO;
/*****************************************************************************/

typedef struct _PHONESP_ASYNC_QUEUE
{

    //
    //The handle to the thread which services the queue
    //
    HANDLE                  hAsyncEventQueueServiceThread;
    
    //
    // The event if set signifies pending entries in the queue
    // else the thread waits on this thread
    //
    HANDLE                  hAsyncEventsPendingEvent;
    
    CRITICAL_SECTION        AsyncEventQueueCritSec;

    DWORD                   dwNumTotalQueueEntries;
    DWORD                   dwNumUsedQueueEntries;

    //Pointer to the queue
    PPHONESP_ASYNC_REQ_INFO           *pAsyncRequestQueue;
  
    //Pointer to the next entry in the queue where the request can be added
    PPHONESP_ASYNC_REQ_INFO           *pAsyncRequestQueueIn;
  
    //Pointer to the next request to be serviced in the queue
    PPHONESP_ASYNC_REQ_INFO           *pAsyncRequestQueueOut;
    
} PHONESP_ASYNCQUEUE, *PPHONESP_ASYNCQUEUE;
/*****************************************************************************/


//
// All these might be combined in a global structure
//
DWORD                       gdwNumPhones;
HINSTANCE                   ghInst;
DWORD                       gdwPermanentProviderID;
DWORD                       gdwPhoneDeviceIDBase;
HPROVIDER                   ghProvider;

// The memory for this queue is allocated in providerInit and will be used to 
// store requests on the phone. These requests will be processed asynchronously
// by a separate Thread created on this queue
PHONESP_ASYNCQUEUE          gAsyncQueue, gInputReportQueue;

// 256 is just a random number taken for the initial number of entries that the 
// can have.. the queue can be expanded later as required
#define MAX_QUEUE_ENTRIES   256


//
// glpfnCompletionProc is a callback function implemented by TAPI and supplied 
// to the TSP as a parameter to TSPI_providerInit.The TSP calls this function 
// to report the completion of a line or phone procedure that it executes 
// asynchronously.
//
ASYNC_COMPLETION            glpfnCompletionProc;

//
// glpfnPhoneCreateProc is a callback function implemented by TAPI and supplied
// to the TSP as a parameter to TSPI_providerInit The TSP calls this function 
// to report the creation of a new device.
//
PHONEEVENT                  glpfnPhoneCreateProc;

// gpPhone maintains an array of the phones enumerated - each of these phones 
// have a corresponding HidDevice value in the gpHidDevices. 
PPHONESP_PHONE_INFO         *gpPhone;      
            

// This the global heap from which all the memory allocations are carried out
HANDLE                      ghHeap;


// This two handles are required for registering for PNP events
HANDLE                      ghDevNotify;
HWND                        ghWndNotify;



const LPCWSTR               gpcstrServiceName = _T("TapiSrv");

LPCWSTR                     gszProviderInfo;

// This is to notify the thread that services the queue to exit
// maybe this could be changed to an event based termination of thread
BOOL gbProviderShutdown = FALSE;

CRITICAL_SECTION            csAllPhones;
CRITICAL_SECTION            csHidList;

PPHONESP_MEMINFO            gpMemFirst = NULL, gpMemLast = NULL;
CRITICAL_SECTION            csMemoryList;
BOOL                        gbBreakOnLeak = FALSE;



/**********************PRIVATE FUNCTIONS**************************************/
BOOL
AsyncRequestQueueIn (
                     PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo
                    );


LONG
CreateButtonsAndAssignID(
                         PPHONESP_PHONE_INFO pPhone
                         );

PPHONESP_BUTTONINFO
GetButtonFromID (
                 PPHONESP_PHONE_INFO pPhone,
                 DWORD dwButtonID
                );

VOID
GetButtonUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_BUTTON_CAPS pButtonCaps,
                DWORD dwNumberButtonCaps,
                DWORD ReportType
                );

PPHONESP_PHONE_INFO
GetPhoneFromID(
               DWORD   dwDeviceID,
               DWORD * pdwPhoneID
               );

PPHONESP_PHONE_INFO
GetPhoneFromHid (
                PHID_DEVICE HidDevice
               );

VOID
GetValueUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_VALUE_CAPS pValueCaps,
                DWORD dwNumberCaps,
                DWORD ReportType
               );


VOID 
InitPhoneAttribFromUsage (
                          DWORD ReportType,
                          USAGE UsagePage,
                          USAGE Usage,
                          PPHONESP_PHONE_INFO pPhone,
                          LONG Min,
                          LONG Max
                          );

LONG
LookupIndexForUsage(
                    IN  DWORD  Usage,
                    OUT DWORD *Index
                    );
DWORD 
WINAPI 
PNPServiceHandler(
                  DWORD dwControl,
                  DWORD dwEventType,
                  LPVOID lpEventData,
                  LPVOID lpContext
                 );

VOID
ReportUsage (
              PPHONESP_PHONE_INFO pPhone,
              USAGE     UsagePage,
              USAGE     Usage,
              ULONG     Value
            );

VOID
SendPhoneEvent(
    PPHONESP_PHONE_INFO    pPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

LONG
SendOutputReport(
                 PHID_DEVICE pHidDevice,
                 USAGE      Usage,
                 BOOL       bSet
                );


VOID
CALLBACK
ShowData(
         PPHONESP_FUNC_INFO pAsyncFuncInfo 
        );

LPWSTR
PHONESP_LoadString(
             IN UINT ResourceID,
             PLONG lResult
             );

BOOL
ReadInputReport (
                    PPHONESP_PHONE_INFO    pPhone
                );

VOID
InitUsage (
           PPHONESP_PHONE_INFO pPhone,
           USAGE     Usage,
           BOOL      bON
          );

VOID
ReenumDevices ();

VOID
FreePhone (
           PPHONESP_PHONE_INFO pPhone
          );

LONG
CreatePhone (
            PPHONESP_PHONE_INFO pPhone,
            PHID_DEVICE pHidDevice,
            DWORD dwPhoneCnt
          );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\hidphone.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

     hidphone.c

Abstract:

    This module contains implements the phone tsp functions is called by
    tapi in order to access the HID compliant USB phone device.
    This module communicates with the phone device using the HID interface.

Author: Shivani Aggarwal

Comments:
     Locking Mechanism:
        There are two critical section objects being used inorder to protect
        the phone structure from simultaneous access - csAllPhones and 
        csThisPhone. Every phone has one csThisPhone, the critical section 
        object, associated with it. csThisPhone ensures that the Phone Info
        is accessed in a thread-safe manner. csAllPhones is a global Critical
        Section Object that ensures that a thread acquires the csThisPhone 
        Critical Section Object in a thread safe manner. In other words, it 
        ensures that, the thread waits on csThisPhone while the Critical 
        Section Object is still valid. 
        The csAllPhones should always be acquired before csThisPhone. 
        A phone can be closed only after the thread has acquired both 
        csAllPhones and csThisPhone for the specific phone to be closed. Both
        these objects are released only after the function is completed. For 
        all other functions, the csAllPhones critical section is released as 
        soon as the thread acquires csThisPhone object.

------------------------------------------------------------------------------*/


#include "hidphone.h"     //** NOTE - hidphone.h must be defined before mylog.h
#include "mylog.h"

BOOL
WINAPI
DllMain(
    HANDLE  hDLL,
    DWORD   dwReason,
    LPVOID  lpReserved
    )
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // inorder to enable logging for this tsp              
            LOGREGISTERDEBUGGER(_T("hidphone"));

            LOG((PHONESP_TRACE, "DllMain - DLL_PROCESS_ATTACH"));

            ghInst = hDLL;                   

            // if the heap cannot be created, use the heap from the process
           
            if (!(ghHeap = HeapCreate(
                                      0,    // NULL on failure,serialize access
                                      0x1000, // initial heap size
                                      0       // max heap size (0 == growable)
                                     )))
            {
                LOG((PHONESP_ERROR, "DllMain - HeapCreate failed %d", GetLastError()));

                ghHeap = GetProcessHeap();

                if (ghHeap == NULL)
                {
                    LOG((PHONESP_ERROR, "DllMain - GetProcessHeap failed %d", GetLastError()));

                    return GetLastError();
                }
            }
            
            
            // Inorder to diasble notifications of thread attach and detach in 
            // multi-threaded apps it can be a very useful optimization

            DisableThreadLibraryCalls( hDLL );    
                    
            break;
        }
    
        case DLL_PROCESS_DETACH:
        {
            LOG((PHONESP_TRACE, "DllMain - DLL_PROCESS_DETACH"));

            LOGDEREGISTERDEBUGGER();
            
            // if ghHeap is NULL, then there is no heap to destroy
            if ( ( ghHeap != NULL) && ( ghHeap != GetProcessHeap() ) )
            {   
                    HeapDestroy (ghHeap);
            }
            break;
        }
     
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;
    
    } // switch
    return TRUE;
}
/*************************DLLMAIN - END***************************************/


/******************************************************************************
    IsTSPAlreadyInstalled:

    Searchs registry for previous instance of HidPhone TSP.

    Arguments:
        none

    Returns BOOL:
        Returns true if TSP already installed

    Comments:

******************************************************************************/
BOOL
IsTSPAlreadyInstalled()
{
    DWORD i;
    HKEY hKey;
    LONG lStatus;
    DWORD dwNumProviders = 0;
    DWORD dwDataSize = sizeof(DWORD);
    DWORD dwDataType = REG_DWORD;
    LPTSTR pszProvidersKey = TAPI_REGKEY_PROVIDERS;
    LPTSTR pszNumProvidersValue = TAPI_REGVAL_NUMPROVIDERS;
    TCHAR szName[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszProvidersKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != ERROR_SUCCESS)
    {
        LOG((PHONESP_ERROR, "IsTSPAlreadyInstalled - "
            "error opening tapi providers key - %lx", lStatus));

        // done
        return FALSE;
    }

    // see if installed bit set
    lStatus = RegQueryValueEx(
                hKey,
                pszNumProvidersValue,
                0,
                &dwDataType,
                (LPBYTE) &dwNumProviders,
                &dwDataSize
                );

    // validate status
    if( lStatus != ERROR_SUCCESS )
    {
        LOG((PHONESP_ERROR, "IsTSPAlreadyInstalled - "
            "error determining number of providers - %lx", lStatus));

        // release handle
        RegCloseKey(hKey);

        // done
        return FALSE;
    }

    // loop through each provider
    for (i = 0; i < dwNumProviders; i++)
    {
        // construct path to provider name
        wsprintf(szName, _T("ProviderFileName%d"), i);

        // reinitialize size
        dwDataSize = sizeof(szPath);

        // query the next name
        lStatus = RegQueryValueEx(
                        hKey,
                        szName,
                        0,
                        &dwDataType,
                        (unsigned char*)szPath,
                        &dwDataSize
                        );

        // validate status
        if (lStatus == ERROR_SUCCESS)
        {
            // upper case
            _tcsupr(szPath);

            // compare path string to hidphone provider
            if (_tcsstr(szPath, HIDPHONE_TSPDLL) != NULL)
            {
                // release handle
                RegCloseKey(hKey);

                // done
                return TRUE;
            }

        }
        else 
        {
            LOG((PHONESP_ERROR, "IsTSPAlreadyInstalled - "
            "error querying %s - %lx", szName, lStatus));
        }
    }

    // release handle
    RegCloseKey(hKey);

    // done
    return FALSE;
}

/******************************************************************************
    ReenumDevices:

    This function reenumerated hid devices after a pnp event. It will
    create phone devices for new hid arrivals and remove phone devices
    (provided they are closed) for hid removals. It will also notify
    TAPI of these events.

    Arguments:
        none

    Returns VOID:

    Comments:

******************************************************************************/

VOID
ReenumDevices ()
{
    PHID_DEVICE           pHidDevices;
    PHID_DEVICE           pHidDevice;
    PHID_DEVICE           pNextHidDevice;
    ULONG                 NumHidDevices;
    DWORD                 dwNewCount;
    DWORD                 dwRemovedCount;
    DWORD                 dwPhone;
    LONG                  lResult;
    PPHONESP_PHONE_INFO   pPhone;
    
    LOG((PHONESP_TRACE, "ReenumDevices - enter"));

    EnterCriticalSection(&csHidList);

    // Find Telephony hid Devices 
    lResult = FindKnownHidDevices (&pHidDevices, 
                                   &NumHidDevices);

    LOG((PHONESP_TRACE, "ReenumDevices - number of Hid Devices : %d ", NumHidDevices));

    dwNewCount = 0;
    dwRemovedCount = 0;

    EnterCriticalSection(&csAllPhones);

    for (pHidDevice = pHidDevices; pHidDevice != NULL; pHidDevice = pNextHidDevice)
    {
        //
        // Get pointer to the next Hid device now, so we can remove the current
        // device if necessary without messing up our search
        //
        pNextHidDevice = pHidDevice->Next;

        if (pHidDevice->bRemoved)
        {
            //
            // This device has been removed
            //

            dwRemovedCount++;

            pPhone = GetPhoneFromHid(pHidDevice);

            // Check whether the phone handle is still valid
            if ( !IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
            {

                EnterCriticalSection(&pPhone->csThisPhone);

                //
                // First lets get rid of the Hid device since it has already
                // physically left the system
                //

                pPhone->pHidDevice = NULL;
                CloseHidDevice(pHidDevice);

                //
                // Send a phone remove to TAPI
                //
                SendPhoneEvent(
                        pPhone,
                        PHONE_REMOVE,
                        pPhone->dwDeviceID,
                        0,
                        0
                        );

                if (pPhone->bPhoneOpen)
                {
                    //
                    // The phone is open, we can't remove it right away so
                    // mark it remove pending
                    //

                    pPhone->bRemovePending = TRUE;

                    LOG((PHONESP_TRACE, "ReenumDevices - phone remove pending [dwDeviceID %d] ", pPhone->dwDeviceID));
                }
                else
                {
                    //
                    // The phone is closed, we can remove it now
                    //

                    FreePhone(pPhone);

                    LOG((PHONESP_TRACE, "ReenumDevices - phone remove complete [dwDeviceID %d] ", pPhone->dwDeviceID));
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
            }
            else
            {
                LOG((PHONESP_ERROR, "ReenumDevices - GetPhoneFromHid returned an invalid phone pointer"));
            }
        }
        else if (pHidDevice->bNew)
        {
            BOOL bFound = FALSE;

            //
            // This device is new
            //

            dwNewCount++;

            pHidDevice->bNew = FALSE;

            //
            // We need to create a new phone device, find a spot
            //

            for (dwPhone = 0; dwPhone < gdwNumPhones; dwPhone++)
            {
                pPhone = (PPHONESP_PHONE_INFO) gpPhone[ dwPhone ];

                EnterCriticalSection(&pPhone->csThisPhone);

                if ( !pPhone->bAllocated && !pPhone->bCreatePending )
                {
                    //
                    // We have an open slot for this phone
                    //
                    LOG((PHONESP_TRACE, "ReenumDevices - slot %d open", dwPhone));

                    bFound = TRUE;

                    LeaveCriticalSection(&pPhone->csThisPhone);
                    break;
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
            }


            if (!bFound)
            {
                //
                // We don't have a slot open, so we will have to realloc the
                // array to create a new one
                //                

                PPHONESP_PHONE_INFO *pNewPhones;

                LOG((PHONESP_TRACE, "ReenumDevices - creating a new slot"));

                if ( ! ( pNewPhones = MemAlloc((gdwNumPhones + 1) * sizeof(PPHONESP_PHONE_INFO)) ) )
                {           
                    LOG((PHONESP_ERROR,"ReenumDevices - out of memory "));
                }
                else
                {
                    CopyMemory(
                            pNewPhones,
                            gpPhone,
                            sizeof(PPHONESP_PHONE_INFO) * gdwNumPhones
                           );

                    // Allocate memory for this phone 
                    if ( pNewPhones[gdwNumPhones] = (PPHONESP_PHONE_INFO)MemAlloc(sizeof(PHONESP_PHONE_INFO)) )
                    { 
                        LOG((PHONESP_TRACE, "ReenumDevices - initializing device: %d",gdwNumPhones+1));

                        ZeroMemory( pNewPhones[gdwNumPhones], sizeof(PHONESP_PHONE_INFO));

                        //
                        // Initialize the critical section object for this phone. only the 
                        // thread that owns this object can access the structure for this phone
                        //
                        __try
                        {
                            InitializeCriticalSection( &pNewPhones[gdwNumPhones]->csThisPhone );
                        }
                        __except(1)
                        {
                            MemFree(pNewPhones[gdwNumPhones]);
                            MemFree(pNewPhones);
                            pNewPhones = NULL;

                            LOG((PHONESP_ERROR,"ReenumDevices - Initialize Critical Section"
                                  " Failed for Phone %d", gdwNumPhones+1));
                        }
                        
                        if ( pNewPhones != NULL )
                        {
                            //
                            // Success
                            //

                            LOG((PHONESP_TRACE, "ReenumDevices - slot %d created", gdwNumPhones));

                            dwPhone = gdwNumPhones;
                            pPhone = pNewPhones[dwPhone];
                            bFound = TRUE;

                            MemFree(gpPhone);
                            gpPhone = pNewPhones;
                            gdwNumPhones++;   
                        }
                    }
                    else
                    { 
                        MemFree(pNewPhones);

                        LOG((PHONESP_ERROR,"ReenumDevices - out of memory "));
                    }                 
                }
            }

            if (bFound)
            {
                //
                // Now actually create the phone
                //

                EnterCriticalSection(&pPhone->csThisPhone);

                lResult = CreatePhone( pPhone, pHidDevice, dwPhone );

                if ( lResult != ERROR_SUCCESS )
                {
                    LOG((PHONESP_ERROR,"ReenumDevices - CreatePhone"
                          " Failed for Phone %d: error: %d", dwPhone, lResult));
                }
                else
                {
                    // Phone created successfully, send a PHONE_CREATE message

                    pPhone->bCreatePending = TRUE;

                    SendPhoneEvent(
                                    pPhone,
                                    PHONE_CREATE,
                                    (DWORD_PTR)ghProvider,
                                    dwPhone,
                                    0
                                   );

                    LOG((PHONESP_TRACE, "ReenumDevices - phone create pending [dwTempID %d] ", dwPhone));
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
            }
            else
            {
                LOG((PHONESP_ERROR, "ReenunDevices - unable to create new phone"));
            }
        }
    }

    LeaveCriticalSection(&csAllPhones);

    LeaveCriticalSection(&csHidList);

    LOG((PHONESP_TRACE, "ReenumDevices - new : %d ", dwNewCount));
    LOG((PHONESP_TRACE, "ReenumDevices - removed : %d ", dwRemovedCount));

    LOG((PHONESP_TRACE, "ReenumDevices - exit"));
}

/******************************************************************************
    FreePhone:
        
    This function frees all of a phones data structures

    Arguments:
        PPHONESP_PHONE_INFO pPhone

    Returns VOID:

    Comments:

******************************************************************************/
VOID
FreePhone (
            PPHONESP_PHONE_INFO pPhone
          )
{
    DWORD dwButtonCnt;

    LOG((PHONESP_TRACE, "FreePhone - enter"));

    // Check whether the phone handle is still valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
    {
        LOG((PHONESP_ERROR, "FreePhone - phone handle invalid"));
        return;
    }

    if ( !pPhone->bAllocated )
    {
        LOG((PHONESP_ERROR, "FreePhone - phone not allocated"));
        return;
    }
    
    for (dwButtonCnt = 0; 
        dwButtonCnt < pPhone->dwNumButtons; dwButtonCnt++)
    {
        if (pPhone->pButtonInfo[dwButtonCnt].szButtonText != NULL)
        {
            MemFree(pPhone->pButtonInfo[dwButtonCnt].szButtonText);
            pPhone->pButtonInfo[dwButtonCnt].szButtonText = NULL;
        }
    }

    if (pPhone->pButtonInfo != NULL)
    {
        MemFree(pPhone->pButtonInfo);
        pPhone->pButtonInfo = NULL;
    }

    if (pPhone->wszPhoneInfo != NULL)
    {
        MemFree((LPVOID) pPhone->wszPhoneInfo);
        pPhone->wszPhoneInfo = NULL;
    }

    if (pPhone->wszPhoneName != NULL)
    {
        MemFree((LPVOID) pPhone->wszPhoneName);
        pPhone->wszPhoneName = NULL;
    }  
    
    pPhone->bAllocated = FALSE;

    LOG((PHONESP_TRACE, "FreePhone - exit"));
}

/******************************************************************************
    UpdatePhoneFeatures:
        
    This function reads feature values from the phone.

    Arguments:
        PPHONESP_PHONE_INFO pPhone

    Returns VOID:

    Comments:

******************************************************************************/
VOID UpdatePhoneFeatures(
                         PPHONESP_PHONE_INFO pPhone
                        )
{
   LOG((PHONESP_TRACE, "UpdatePhoneFeatures - enter"));

   if( pPhone->pHidDevice->Caps.NumberFeatureValueCaps || 
       pPhone->pHidDevice->Caps.NumberFeatureButtonCaps  )
    {    
        USAGE UsagePage;
        USAGE Usage;

        if (GetFeature(pPhone->pHidDevice))
        {   
            DWORD       dwDataCnt;
            PHID_DATA   pHidData;            
            
            pHidData = pPhone->pHidDevice->FeatureData;
            for ( dwDataCnt = 0, pHidData = pPhone->pHidDevice->FeatureData; 
                  dwDataCnt < pPhone->pHidDevice->FeatureDataLength; 
                  dwDataCnt++, pHidData++ )
            {
                UsagePage = pHidData->UsagePage;

                if (UsagePage == HID_USAGE_PAGE_TELEPHONY)
                {
                    if(pHidData->IsButtonData)
                    {
                        for ( Usage = (USAGE)pHidData->ButtonData.UsageMin; 
                              Usage <= (USAGE)pHidData->ButtonData.UsageMax; 
                              Usage++ )
                        {
                            DWORD i;

                            for (i = 0; 
                                 i < pHidData->ButtonData.MaxUsageLength;
                                 i++)
                            {
                                if(Usage == pHidData->ButtonData.Usages[i])
                                {
                                    LOG((PHONESP_TRACE,"Button for Usage "
                                                       "0x%04x ON",Usage));

                                    InitUsage(pPhone, Usage, TRUE); 
                                    break;
                                }
                            }

                            if ( i == pHidData->ButtonData.MaxUsageLength)
                            {
                                InitUsage(pPhone, Usage, FALSE);
                            }
                        }
                    }
                    else
                    {
                        InitUsage(pPhone, pHidData->ValueData.Usage,
                                  pHidData->ValueData.Value);
                    }
                }
            }
        }
        else
        {
            LOG((PHONESP_ERROR, "UpdatePhoneFeatures - GetFeature failed"));
        }
    }
    else
    {
        LOG((PHONESP_TRACE, "UpdatePhoneFeatures - NO FEATURE"));
    }

    LOG((PHONESP_TRACE, "UpdatePhoneFeatures - exit"));
}

/******************************************************************************
    CreatePhone:
        
    This function creates all of a phones data structures

    Arguments:
        PPHONESP_PHONE_INFO pPhone
        PHID_DEVICE pHidDevice

    Returns LONG:

    Comments:

******************************************************************************/
LONG
CreatePhone (
            PPHONESP_PHONE_INFO pPhone,
            PHID_DEVICE pHidDevice,
            DWORD dwPhoneCnt
            )
{
    LONG                lResult;
    LPWSTR              wszPhoneName, wszPhoneInfo;
    WCHAR               wszPhoneID[MAX_CHARS];
    PHIDP_BUTTON_CAPS   pButtonCaps;
    PHIDP_VALUE_CAPS    pValueCaps;
    HRESULT hr;

    LOG((PHONESP_TRACE, "CreatePhone - enter"));

    // Check whether the phone handle is still valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
    {
        LOG((PHONESP_ERROR, "CreatePhone - phone handle invalid"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    if ( IsBadReadPtr(pHidDevice,sizeof(PHID_DEVICE) ))
    {
        LOG((PHONESP_ERROR, "CreatePhone - hid device pointer invalid"));
        return PHONEERR_OPERATIONFAILED;
    }

    if ( pPhone->bAllocated )
    {
        LOG((PHONESP_ERROR, "CreatePhone - phone already allocated"));
        return PHONEERR_OPERATIONFAILED;
    }
    
    // Load Phone Info From String Table
    wszPhoneInfo = PHONESP_LoadString( 
                                       IDS_PHONE_INFO,
                                       &lResult
                                      );
    
    if ( lResult != ERROR_SUCCESS )
    {
        if ( lResult == ERROR_OUTOFMEMORY )
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString out of memory"));

            return PHONEERR_NOMEM;
        }
        else
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString failed %d", lResult));

            return lResult;
        }
    }
 
    // Load Phone Name From String Table
    wszPhoneName = PHONESP_LoadString( 
                                      IDS_PHONE_NAME, 
                                      &lResult 
                                     );
    
    if ( lResult != ERROR_SUCCESS )
    {
        MemFree((LPVOID)wszPhoneInfo);
        
        if ( lResult == ERROR_OUTOFMEMORY )
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString out of memory"));

            return PHONEERR_NOMEM;
        }
        else
        {
            LOG((PHONESP_ERROR, "CreatePhone - "
                    "PHONESP_LoadString failed %d", lResult));

            return lResult;
        }
    }
    
    //
    // Associate phone with the hid and wave devices
    // 

    pPhone->bAllocated = TRUE;
    pPhone->pHidDevice = pHidDevice;

    // Discover Render Wave ID 

    hr = DiscoverAssociatedWaveId(pHidDevice->dwDevInst, 
                                  TRUE, 
                                  &pPhone->dwRenderWaveId);

    
    if (hr != S_OK)
    {
        pPhone->bRender = FALSE;
        LOG((PHONESP_ERROR, "CreatePhone - DiscoverAssociatedWaveID:"
                       " Render Failed for Phone %d: %0x", dwPhoneCnt, hr));
    }
    else
    {
        pPhone->bRender = TRUE;
        LOG((PHONESP_TRACE,"CreatePhone - DiscoverAssociatedWaveId for Render: %d", 
                        pPhone->dwRenderWaveId));
    }

    // Discover Capture Wave ID
    hr = DiscoverAssociatedWaveId(pHidDevice->dwDevInst, 
                                  FALSE, 
                                  &pPhone->dwCaptureWaveId);
    
    if (hr != S_OK)
    {
        pPhone->bCapture = FALSE;
        LOG((PHONESP_ERROR, "CreatePhone - DiscoverAssociatedWaveID:"
                      " Capture Failed for Phone %d: %0x", dwPhoneCnt, hr));
    }
    else
    {
        pPhone->bCapture = TRUE;
        LOG((PHONESP_TRACE,"CreatePhone - DiscoverAssociatedWaveId for Capture: %d", 
                        pPhone->dwCaptureWaveId));
    }

    pPhone->dwButtonModesMsgs = PHONESP_ALLBUTTONMODES;
    pPhone->dwButtonStateMsgs = PHONESP_ALLBUTTONSTATES;

    //
    // Extract Usages and Initialize the phone structure 
    //

    // Get the usages from the HID structure 

    // Parse input button caps structure
    LOG((PHONESP_TRACE, "CreatePhone - INPUT BUTTON CAPS"));
    pButtonCaps = pHidDevice->InputButtonCaps;

    
    GetButtonUsages(
                    pPhone,
                    pButtonCaps, 
                    pHidDevice->Caps.NumberInputButtonCaps,
                    INPUT_REPORT
                   );


    // Parse output button caps structure
    LOG((PHONESP_TRACE, "CreatePhone - OUTPUT BUTTON CAPS" ));
    pButtonCaps = pHidDevice->OutputButtonCaps;
    GetButtonUsages(
                    pPhone,
                    pButtonCaps, 
                    pHidDevice->Caps.NumberOutputButtonCaps,
                    OUTPUT_REPORT
                   );


    // Parse feature button caps structure
    LOG((PHONESP_TRACE, "CreatePhone - FEATURE BUTTON CAPS" ));
    pButtonCaps = pHidDevice->FeatureButtonCaps;
    GetButtonUsages(
                    pPhone,
                    pButtonCaps, 
                    pHidDevice->Caps.NumberFeatureButtonCaps,
                    FEATURE_REPORT
                   );



    // Parse input value caps structure
    LOG((PHONESP_TRACE, "CreatePhone - INPUT VALUE CAPS"));
    pValueCaps = pHidDevice->InputValueCaps;
    GetValueUsages(
                    pPhone,
                    pValueCaps, 
                    pHidDevice->Caps.NumberInputValueCaps,
                    INPUT_REPORT
                   );

    // Parse output value caps structure
    LOG((PHONESP_TRACE, "CreatePhone - OUTPUT VALUE CAPS" ));
    pValueCaps = pHidDevice->OutputValueCaps;

    GetValueUsages(
                    pPhone,
                    pValueCaps, 
                    pHidDevice->Caps.NumberOutputValueCaps,
                    OUTPUT_REPORT
                   );
    
    // Parse feature value caps structure
    LOG((PHONESP_TRACE, "CreatePhone - FEATURE VALUE CAPS" ));

    pValueCaps = pHidDevice->FeatureValueCaps;
    GetValueUsages(
                    pPhone,
                    pValueCaps, 
                    pHidDevice->Caps.NumberFeatureValueCaps,
                    FEATURE_REPORT
                   );

    //
    // The Phone should have a handset with input and feature 
    // reports supported. If it does not the phone will not be supported
    // by this TSP. If this part of the code is uncommented, then the nokia
    // box will be the unsupported phone device since it does not contain
    // a feature report for the handset
    //
   if ( !( pPhone->dwHandset & INPUT_REPORT ) )
                                                                
    {
        LOG((PHONESP_ERROR,"CreatePhone - This Phone not Supported")); 

        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_OPERATIONFAILED;
    }   

    //
    // Store the Phone ID as a string Value
    //

    wsprintf(wszPhoneID, TEXT(": %d"), dwPhoneCnt);

    //
    // Allocate space for storing the Phone Info
    //
    pPhone->wszPhoneInfo = (LPWSTR) MemAlloc ( (lstrlen(wszPhoneInfo) +
                                               lstrlen(wszPhoneID) + 1 ) *
                                               sizeof(WCHAR) );

    if( NULL == pPhone->wszPhoneInfo)
    {
        LOG((PHONESP_ERROR,"CreatePhone - unable to allocate wszPhoneInfo")); 

        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_NOMEM;
    }

    //
    // Copy the Phone Info in the phone structure and append it with
    // the Phone ID
    //
    lstrcpy(pPhone->wszPhoneInfo,wszPhoneInfo);
    lstrcat(pPhone->wszPhoneInfo,wszPhoneID);


    pPhone->wszPhoneName = (LPWSTR)MemAlloc ( ( lstrlen(wszPhoneName) +
                                                lstrlen(wszPhoneID) + 
                                                1 ) * sizeof(WCHAR) );

    if( NULL == pPhone->wszPhoneName)
    {
        LOG((PHONESP_ERROR,"CreatePhone - unable to allocate wszPhoneName")); 
        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_NOMEM;
    }

    //
    // Copy the Phone Name in the phone structure and append it with
    // the Phone ID
    //
    lstrcpy(pPhone->wszPhoneName,wszPhoneName);
    lstrcat(pPhone->wszPhoneName,wszPhoneID);

    //
    // Create Buttons for the ones discovered by tracking the usages
    //
    if ( CreateButtonsAndAssignID(pPhone) != ERROR_SUCCESS)
    {
        LOG((PHONESP_ERROR,"CreatePhone - CreateButtonsAndAssignID failed")); 
        MemFree((LPVOID) wszPhoneInfo);
        MemFree((LPVOID) wszPhoneName);

        FreePhone(pPhone);

        return PHONEERR_NOMEM;
    }
    
    //
    // Get initial values for phone features (such as hookswitch state)
    //
    UpdatePhoneFeatures( pPhone );

    //
    // Close the file handle
    //
    if ( !CloseHidFile(pPhone->pHidDevice) )
    {
        LOG((PHONESP_ERROR, "CreatePhone - CloseHidFile failed"));
    }

    MemFree((LPVOID) wszPhoneInfo);
    MemFree((LPVOID) wszPhoneName);  

    LOG((PHONESP_TRACE, "CreatePhone - exit"));

    return ERROR_SUCCESS;
}

/******************************************************************************
    NotifWndProc:
        
    This function handles the pnp events for which this tsp has registered for

    Arguments:
        HWND hwnd
        UINT uMsg
        WPARAM wParam
        LPARAM lParam

    Returns LRESULT:

    Comments:

******************************************************************************/

LRESULT CALLBACK NotifWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{ 
    switch (uMsg) 
    { 
        case WM_DEVICECHANGE: 
            switch(wParam)
            {
            case DBT_DEVICEARRIVAL:
                LOG((PHONESP_TRACE, "NotifWndProc - DBT_DEVICEARRIVAL"));
                ReenumDevices();
                break;

            case DBT_DEVICEREMOVECOMPLETE:
                LOG((PHONESP_TRACE, "NotifWndProc - DBT_DEVICEREMOVECOMPLETE"));
                ReenumDevices();
                break;
            }
            break;

        case WM_CREATE:
            LOG((PHONESP_TRACE, "NotifWndProc - WM_CREATE"));
            break;

        case WM_DESTROY: 
            LOG((PHONESP_TRACE, "NotifWndProc - WM_DESTROY"));
            break;

        default: 
            return DefWindowProc(hwnd, uMsg, wParam, lParam); 
    } 

    return 0; 
} 
/********************************NotifWndProc - end***************************/


/******************************************************************************
    AsyncEventQueueServiceThread:
    
    This routine services, in a serialized manner, the requests present in the 
    Async Queue. If no requests are currently outstanding, it waits for an 
    Event which happens when the queue has currently no requests and a new 
    request comes in.
    
    Arguments:
        LPVOID pParams: Any Information that needs to be passed to the thread
                        when startup. Currently no information is being passed.
                        
    Return Parameter: Void
    
******************************************************************************/
VOID 
AsyncEventQueueServiceThread(
                             LPVOID  pParams
                            )
{
    WNDCLASS wc;
    ATOM atom;

    LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - enter"));

    //
    // Create a window to receive PNP device notifications
    //

    ZeroMemory(&wc, sizeof(wc));
    wc.lpfnWndProc = NotifWndProc;
    wc.lpszClassName = TEXT("HidPhoneNotifClass");

    if (!(atom = RegisterClass(&wc)))
    {
        LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - can't register window class %08x", GetLastError()));
    }
    else
    {    
        ghWndNotify = CreateWindow((LPCTSTR)atom, TEXT(""), 0,
                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL);

        if (ghWndNotify == NULL)
        {
            LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - can't create notification window"));
        }
        else
        {
            DEV_BROADCAST_DEVICEINTERFACE NotificationFilter;

            LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - created notification window"));

            //
            // Register to receive PNP device notifications
            //        

            ZeroMemory( &NotificationFilter, sizeof(NotificationFilter) );
            NotificationFilter.dbcc_size = 
                sizeof(DEV_BROADCAST_DEVICEINTERFACE);
            NotificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
            NotificationFilter.dbcc_classguid = GUID_CLASS_INPUT;

            if ((ghDevNotify = RegisterDeviceNotification( ghWndNotify, 
                &NotificationFilter,
                DEVICE_NOTIFY_WINDOW_HANDLE
                )) == NULL)
            {
                LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - can't register for input device notification"));
            }
            else
            {
                LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - registered for PNP device notifications"));
            }
        }
    }

    while (!gbProviderShutdown)
    {
        // Waiting for a new request to arrive since the queue is currently 
        // empty

        DWORD dwResult;
        MSG msg;
        
        dwResult = MsgWaitForMultipleObjectsEx(
            1,                                      // wait for one event
            &gAsyncQueue.hAsyncEventsPendingEvent,  // array of events to wait for
            INFINITE,                               // wait forever
            QS_ALLINPUT,                            // get all window messages
            0                                       // return when an event is signaled
            );

        if ( ( dwResult == WAIT_OBJECT_0 ) || ( dwResult == WAIT_OBJECT_0 + 1 ) )
        {
            LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - thread is signaled"));

            while (1)
            {
                PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
                PPHONESP_PHONE_INFO     pPhone;

                EnterCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);

                // No requests in the queue present - wait for a new request
                if (gAsyncQueue.dwNumUsedQueueEntries == 0)
                {
                    ResetEvent (gAsyncQueue.hAsyncEventsPendingEvent);
                    LeaveCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);
                    break;
                }

                pAsyncReqInfo = *gAsyncQueue.pAsyncRequestQueueOut;

                // Increment the next-request-to-be-serviced counter 
                gAsyncQueue.pAsyncRequestQueueOut++;


                //
                // The queue is maintained a circular queue. If the bottom of the 
                // circular queue is reached, go back to the top and process the 
                // requests if any.
                //
                if (gAsyncQueue.pAsyncRequestQueueOut == 
                        (gAsyncQueue.pAsyncRequestQueue +
                            gAsyncQueue.dwNumTotalQueueEntries))
                {
                    gAsyncQueue.pAsyncRequestQueueOut = 
                                                    gAsyncQueue.pAsyncRequestQueue;
                }

                // Decrement the number of outstanding requests present in queue
                gAsyncQueue.dwNumUsedQueueEntries--;

                LeaveCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);


                // If async function for the request exists - call the function
                               
                if (pAsyncReqInfo->pfnAsyncProc)
                {
                    (*(pAsyncReqInfo->pfnAsyncProc))(
                                                     pAsyncReqInfo->pFuncInfo
                                                    );
                }

                pPhone = (PPHONESP_PHONE_INFO) pAsyncReqInfo->pFuncInfo->dwParam1;
            
                // Decrement the counter of pending requests for this phone
            
                if ( pPhone )
                {
                    EnterCriticalSection(&pPhone->csThisPhone);

                    pPhone->dwNumPendingReqInQueue--;

                    // if there are no requests pending for this phone
                    // Set no requests pending event on this phone
                    if (pPhone->dwNumPendingReqInQueue == 0 )
                    {
                        SetEvent(pPhone->hNoPendingReqInQueueEvent);
                    }

                    LeaveCriticalSection(&pPhone->csThisPhone);
                }

                // The memory allocated for the processed request is freed.
                MemFree(pAsyncReqInfo->pFuncInfo);
                MemFree(pAsyncReqInfo);
            }

            //
            // We have processed all commands and unblocked everyone
            // who is waiting for us. Now check for window messages.
            //

            while ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - shutdown"));

    //
    // Unregister for PNP device notifications and destroy window
    //

    if ( NULL != ghDevNotify )
    {
        if (!UnregisterDeviceNotification(ghDevNotify))
        {
            LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - "
                    "can't unregister device notification %d", GetLastError()));

        }

        ghDevNotify = NULL;
    }

    if ( NULL != ghWndNotify )
    {
        if (!DestroyWindow(ghWndNotify))
        {
            LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - "
                    "can't destroy notification window %d", GetLastError()));
        }

        ghWndNotify = NULL;
    }

    if (!UnregisterClass((LPCTSTR)atom, GetModuleHandle(NULL)))
    {
        LOG((PHONESP_ERROR, "AsyncEventQueueServiceThread - "
                "can't unregister window class %d", GetLastError()));
    }   

    LOG((PHONESP_TRACE, "AsyncEventQueueServiceThread - exit"));

    // Since the Provider Shutdown is called .. we terminate the thread
    ExitThread (0);
}
/*************************AsyncEventQueueServiceThread - end******************/


/******************************************************************************
    ReadThread:

    Arguments:
        
        PVOID lpParameter - The parameter passed to the function when this 
                            function is called. In this case - the parameter is
                            the pointer to the phone structure (PMYPHONE) that 
                            has just been opened

    Returns VOID
******************************************************************************/ 
VOID
ReadThread(
           PVOID lpParameter
          )
{
    PPHONESP_PHONE_INFO         pPhone;
    PHID_DEVICE                 pHidDevice; 
    DWORD                       dwInputDataCnt;
    PHID_DATA                   pHidData;
    DWORD                       dwResult;
    HANDLE                      hWaitHandles[2];
    DWORD                       dwWaitResult;

    LOG((PHONESP_TRACE, "ReadThread - enter"));

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) lpParameter;
    
    // Check whether the phone handle is still valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ))
    {
        LOG((PHONESP_ERROR, "ReadThread - phone handle invalid"));

        LeaveCriticalSection(&csAllPhones);        
        ExitThread(0);
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);
   
    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LOG((PHONESP_ERROR, "ReadThread - phone not allocated"));

        LeaveCriticalSection(&pPhone->csThisPhone);        
        ExitThread(0);
    }

    // verify whether the phone is open
    if( !pPhone->bPhoneOpen )
    {
        LOG((PHONESP_ERROR, "ReadThread - Phone not open"));

        LeaveCriticalSection(&pPhone->csThisPhone);
        ExitThread(0);
    }
    
    pHidDevice = pPhone->pHidDevice;

    // Check whether hid device is present
    if ( pHidDevice == NULL )
    {
        LOG((PHONESP_ERROR, "ReadThread - invalid hid device pointer"));

        LeaveCriticalSection(&pPhone->csThisPhone);
        ExitThread(0);
    }    

    hWaitHandles[0] = pPhone->hCloseEvent;
    hWaitHandles[1] = pPhone->hInputReportEvent;

    while (TRUE)
    {
        if (! ReadInputReport(pPhone))
        {   
            LOG((PHONESP_ERROR, "ReadThread - ReadInputReport failed - exiting"));

            LeaveCriticalSection(&pPhone->csThisPhone);            
            ExitThread(0);
        }

        LeaveCriticalSection(&pPhone->csThisPhone);

        //
        // Wait for the read to complete, or the phone to be closed
        //

        dwWaitResult = WaitForMultipleObjects( 2, hWaitHandles, FALSE, INFINITE );

        LOG((PHONESP_TRACE, "ReadThread - activated"));

        if ( dwWaitResult == WAIT_OBJECT_0 )
        {
            LOG((PHONESP_TRACE, "ReadThread - CloseEvent fired - exiting"));

            //
            // Cancel the pending IO operation
            //

            CancelIo( pHidDevice->HidDevice );
            ExitThread(0);
        }

        EnterCriticalSection(&pPhone->csThisPhone);

        // This function is implemented in report.c 
        // The report received from the device is unmarshalled here
        if ( UnpackReport(
                          pHidDevice->InputReportBuffer,
                          pHidDevice->Caps.InputReportByteLength,
                          HidP_Input,
                          pHidDevice->InputData,
                          pHidDevice->InputDataLength,
                          pHidDevice->Ppd
                         ) )
        {
 
            for (dwInputDataCnt = 0, pHidData = pHidDevice->InputData;
                 dwInputDataCnt < pHidDevice->InputDataLength; 
                 pHidData++, dwInputDataCnt++)
            {
    
                // Since pHidData->IsDataSet in all the input HidData structures 
                // initialized to false before reading the input report .. if the
                // pHidData->IsDataSet is set for the HidData structure, that 
                // HidData structure contains the new input report
                // Also we are interested in only telephony usage page usages only
        
                if ( pHidData->IsDataSet &&
                     ( (pHidData->UsagePage == HID_USAGE_PAGE_TELEPHONY) ||
                       (pHidData->UsagePage == HID_USAGE_PAGE_CONSUMER) ) )
                {
                    PPHONESP_FUNC_INFO pFuncInfo;
                    PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
    
                    if( ! (pFuncInfo = (PPHONESP_FUNC_INFO) 
                                        MemAlloc(sizeof (PHONESP_FUNC_INFO)) ) )
                    {
                        LOG((PHONESP_ERROR, "ReadThread - "
                                "MemAlloc pFuncInfo - out of memory"));

                        continue;     
                    }

                    ZeroMemory(pFuncInfo, sizeof(PHONESP_FUNC_INFO));

                    pFuncInfo->dwParam1 = (ULONG_PTR) pPhone;

                    if ( ! ( pAsyncReqInfo = (PPHONESP_ASYNC_REQ_INFO) 
                                        MemAlloc(sizeof(PHONESP_ASYNC_REQ_INFO))))
                    {
                        LOG((PHONESP_ERROR, "ReadThread - "
                                "MemAlloc pAsyncReqInfo - out of memory"));

                        MemFree(pFuncInfo);

                        continue;
                    }    
    
                    pAsyncReqInfo->pfnAsyncProc = ShowData; 
                    pAsyncReqInfo->pFuncInfo = pFuncInfo;

                    // if the usage is associated with a Button
                    if( pHidData->IsButtonData )
                    {
                        PUSAGE Usages;

                        // fill the structure to be put on the async queue
                        if ( ! ( Usages = (PUSAGE) 
                                           MemAlloc(sizeof(USAGE) * 
                                           pHidData->ButtonData.MaxUsageLength) ) )
                        {
                            LOG((PHONESP_ERROR, "ReadIOCompletionRoutine - "
                                    "MemAlloc Usages - out of memory"));

                            MemFree(pFuncInfo);
                            MemFree(pAsyncReqInfo);

                            continue;                                    
                        }

                        pFuncInfo->dwNumParams = 7;
                        pFuncInfo->dwParam2    = PHONESP_BUTTON;  
                        pFuncInfo->dwParam3    = pHidData->UsagePage;
                        pFuncInfo->dwParam4    = pHidData->ButtonData.UsageMin;
                        pFuncInfo->dwParam5    = pHidData->ButtonData.UsageMax;
                        pFuncInfo->dwParam6    = pHidData->ButtonData.MaxUsageLength;

                        CopyMemory(Usages,
                                   pHidData->ButtonData.Usages,
                                   sizeof(USAGE) * 
                                   pHidData->ButtonData.MaxUsageLength
                                  ); 

                        pFuncInfo->dwParam7    = (ULONG_PTR) Usages;
                    }   
                    else
                    {   
                        // the usage is associated with a Value
                        pFuncInfo->dwNumParams = 5;
                        pFuncInfo->dwParam2 = PHONESP_VALUE;
                        pFuncInfo->dwParam3 = pHidData->UsagePage;
                        pFuncInfo->dwParam4 = pHidData->ValueData.Usage;
                        pFuncInfo->dwParam5 = pHidData->ValueData.Value;
                    }

                    if ( AsyncRequestQueueIn(pAsyncReqInfo) )
                    {  
                        // Reset the event for number of pending requests in 
                        // queue for this phone and increment the counter
                        if (pPhone->dwNumPendingReqInQueue == 0)
                        {
                            ResetEvent(pPhone->hNoPendingReqInQueueEvent);
                        }
                        pPhone->dwNumPendingReqInQueue++;
                    }
                    else
                    {
                        if ( pFuncInfo->dwParam2 == PHONESP_BUTTON )
                        {
                            MemFree((LPVOID)pFuncInfo->dwParam7);
                        }

                        MemFree(pFuncInfo);
                        MemFree(pAsyncReqInfo);

                        LOG((PHONESP_ERROR,"ReadIOCompletionRoutine - "
                                "AsyncRequestQueueIn failed"));
                        
                        continue;
                    }

                    //ShowData(pFuncInfo);            
                }
            }
        } 
    }
}
/******************** ReadThread - end****************************/


/******************************************************************************
    ReadInputReport

    This function reads the phone device asynchronously. When an input report
    is received from the device, the Event specified in the lpOverlapped  
    structure which is part of the PHONESP_PHONE_INFO structure is set. This 
    event results in ReadIOcompletionRoutine being called

    Arguments:
        PPHONESP_PHONE_INFO pPhone - the pointer to the phone to be read

    Return BOOL: 
    TRUE if the function succeeds 
    FALSE if the function fails

******************************************************************************/
BOOL
ReadInputReport (
                 PPHONESP_PHONE_INFO   pPhone
                )
{
    DWORD       i, dwResult;
    PHID_DEVICE pHidDevice;
    PHID_DATA   pData;
    BOOL        bResult;

    LOG((PHONESP_TRACE, "ReadInputReport - enter"));

    pHidDevice = pPhone->pHidDevice;    

    // Check whether hid device is present
    if ( pHidDevice == NULL )
    {
        LOG((PHONESP_ERROR, "ReadInputReport - invalid hid device pointer"));
        return FALSE;
    }

    pData = pHidDevice->InputData;
 
    //
    // Set all the input hid data structures to False so we can identify the 
    // new reports from the device
    for ( i = 0; i < pHidDevice->InputDataLength; i++, pData++)
    {
        pData->IsDataSet = FALSE;
    }
    
    bResult = ReadFile(
                       pHidDevice->HidDevice,
                       pHidDevice->InputReportBuffer,
                       pHidDevice->Caps.InputReportByteLength,
                       NULL,
                       pPhone->lpOverlapped
                      );
     
    if ( !bResult )
    {
        // if the Readfile succeeds then GetLastError returns ERROR_IO_PENDING since 
        // this is an asynchronous read

        dwResult = GetLastError();

        if (  dwResult && ( dwResult != ERROR_IO_PENDING ) )
        {
            LOG((PHONESP_ERROR, "ReadInputReport - ReadFile Failed, error: %d", 
                                 GetLastError()));

            if (dwResult == ERROR_DEVICE_NOT_CONNECTED)
            {
                //
                // The hid device has most likely gone away. Lets close the file
                // handle so we can get proper pnp notifications.
                //
                if ( CloseHidFile(pHidDevice) )
                {
                    LOG((PHONESP_TRACE, "ReadInputReport - "
                            "closed hid device file handle"));
                }
                else
                {
                    LOG((PHONESP_ERROR, "ReadInputReport - "
                            "CloseHidFile failed" ));
                }
            }
            return FALSE;
        }
    }

    LOG((PHONESP_TRACE, "ReadInputReport - exit"));
    return TRUE;
}
/************************ReadInputReport - end *******************************/

// --------------------------- TAPI_lineXxx funcs -----------------------------
//


// The TSPI_lineNegotiateTSPIVersion function returns the highest SPI version the  
// service provider can operate under for this device, given the range of possible 
// SPI versions.


LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    LOG((PHONESP_TRACE, "TSPI_lineNegotiateTSPIVersion - enter"));
    
   
    if (dwHighVersion >= HIGH_VERSION)
    {
        // If the high version of the app is greater than the high version 
        // supported by this TSP and the low version of the app is less than
        // the High version of the TSP - The TSP high version will be negotiated
        // else the tsp cannot support this app
        if (dwLowVersion <= HIGH_VERSION)
        {
            *lpdwTSPIVersion = (DWORD) HIGH_VERSION;
        }
        else
        {   // the app is too new for us
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    else
    {
        if(dwHighVersion >= LOW_VERSION)
        {
            *lpdwTSPIVersion = dwHighVersion;
        }
        else
        {
            //we are too new for the app
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    LOG((PHONESP_TRACE, "TSPI_lineNegotiateTSPIVersion - exit"));
    return 0;
}


//
// -------------------------- TSPI_phoneXxx funcs -----------------------------
//

/******************************************************************************
    TSPI_phoneClose:
    
    This function closes the specified open phone device after completing all 
    the asynchronous operations pending on the device
        
    Arguments:
        HDRVPHONE hdPhone - the handle to the phone to be closed

    Returns LONG:
    Zero if the function succeeds
    Error code if an error occurs - Possible values are
    PHONEERR_INVALPHONEHANDLE

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneClose(
    HDRVPHONE   hdPhone
    )
{
    PPHONESP_PHONE_INFO pPhone; 
    LOG((PHONESP_TRACE, "TSPI_phoneClose - enter"));

    // We need a critical section in order to ensure that the critical section
    // of the phone is obtained while the phone handle is still valid.
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // Check whether the phone handle is valid
    if ( IsBadReadPtr( pPhone,sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneClose - Phone handle invalid"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        
        LOG((PHONESP_ERROR, "TSPI_phoneClose - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // Check if the phone to be closed is still open 
    if( pPhone->bPhoneOpen )
    {
        // Inorder to ensure that there no other activities happen on the phone
                
        pPhone->bPhoneOpen = FALSE;

        //
        // wait for the read thread to exit
        //
        SetEvent(pPhone->hCloseEvent);

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_TRACE,"TSPI_phoneClose - waiting for read thread"));

        WaitForSingleObject(pPhone->hReadThread, INFINITE);

        LOG((PHONESP_TRACE,"TSPI_phoneClose - read thread complete"));

        EnterCriticalSection(&pPhone->csThisPhone);
        
        //
        // if there are still pending requests on the phone in the queue, wait
        // till all the pending asynchronous operations are completed 
        //
        if (pPhone->dwNumPendingReqInQueue)
        {
            LOG((PHONESP_TRACE,"TSPI_phoneClose - requests pending"));

            LeaveCriticalSection(&pPhone->csThisPhone);

            WaitForSingleObject(&pPhone->hNoPendingReqInQueueEvent, INFINITE);

            EnterCriticalSection(&pPhone->csThisPhone);

            LOG((PHONESP_TRACE,"TSPI_phoneClose - requests completed"));
        }        

        CloseHandle(pPhone->hReadThread);
        CloseHandle(pPhone->hCloseEvent);
        CloseHandle(pPhone->hInputReportEvent);

        MemFree(pPhone->lpOverlapped);
        pPhone->htPhone = NULL;

        //
        // Close HID file handle
        //
        if ( !CloseHidFile(pPhone->pHidDevice) )
        {
            LOG((PHONESP_WARN, "TSPI_phoneClose - CloseHidFile failed"));
        }

        if (pPhone->bRemovePending)
        {
            //
            // This phone is gone, lets get rid of it
            //

            pPhone->bRemovePending = FALSE;

            FreePhone(pPhone);

            LOG((PHONESP_TRACE, "TSPI_phoneClose - phone remove complete [dwDeviceID %d] ", pPhone->dwDeviceID));
        }

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
    else
    {
        LOG((PHONESP_ERROR,"TSPI_phoneClose - Phone Not Open"));

        LeaveCriticalSection(&pPhone->csThisPhone);
        
        return PHONEERR_INVALPHONEHANDLE;
    }

    LOG((PHONESP_TRACE, "TSPI_phoneClose - exit"));

    return 0;
}


/******************************************************************************
    The TSPI_phoneDevSpecific:
    
    This function is used as a general extension mechanism to enable a Telephony
    API implementation to provide features not described in the other operations.
    The meanings of these extensions are device specific.


    Comments: To be implemented in Tier 2
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneDevSpecific(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    LPVOID          lpParams,
    DWORD           dwSize
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneDevSpecific - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneDevSpecific - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}

/***************************TSPI_phoneDevSpecific -End ***********************/


/******************************************************************************
    TSPI_phoneGetButtonInfo:
    This function returns information about a specified button.

    Arguments:
        IN HDRVPHONE hdPhone  - The handle to the phone to be queried.           
        IN DWORD dwButtonLampID - A button on the phone device. 
        IN OUT LPPHONEBUTTONINFO lpButtonInfo  - A pointer to memory into which
             the TSP writes a variably sized structure of type PHONEBUTTONINFO. 
             This data structure describes the mode and function, and provides
             additional descriptive text corresponding to the button. 

  Return Values
    Returns zero if the function succeeds, or 
    An error number if an error occurs. Possible return values are as follows: 
    PHONEERR_INVALPHONEHANDLE, _INVALBUTTONLAMPID,_INVALPHONESTATE 

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
    HDRVPHONE           hdPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{

    PPHONESP_PHONE_INFO pPhone;
    PPHONESP_BUTTONINFO pButtonInfo;
    DWORD dwNeededSize;

    LOG((PHONESP_TRACE, "TSPI_phoneGetButtonInfo - enter"));
    
    if (lpButtonInfo->dwTotalSize < sizeof(PHONEBUTTONINFO))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetButtonInfo - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // Check if pPhone points to a valid memory location - if not handle is 
    // invalid 
    if ( IsBadReadPtr( pPhone,sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneGetButtonInfo - Phone handle invalid"));
        return PHONEERR_INVALPHONEHANDLE;
    }


    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_GetButtonInfo - phone not allocated"));
        return PHONEERR_NODEVICE;
    }
    
    // verify whether the phone is open
    if ( ! (pPhone->bPhoneOpen) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR,"TSPI_GetButtonInfo - Phone not open"));
        return PHONEERR_INVALPHONESTATE;
    }
     

    // Get the Button structure for the queried button id if it exists
    // else pButtonInfo  will be NULL
    if (  ! ( pButtonInfo  = GetButtonFromID(pPhone, dwButtonLampID) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_TRACE, "TSPI_phoneGetButtonInfo - Invalid Button ID"));
        return PHONEERR_INVALBUTTONLAMPID;
    }
    
    // The needed size to store all the available information on the button
    lpButtonInfo->dwNeededSize = sizeof(PHONEBUTTONINFO) +                
                                 (lstrlen(pButtonInfo->szButtonText) + 1) *   
                                  sizeof (WCHAR); // size of the Button Text

    // Whether the button is a Feature Button, Keypad, etc
    lpButtonInfo->dwButtonMode = pButtonInfo->dwButtonMode;

    // The function associated with this button - will be _NONE for keypad
    // buttons and _FLASH, _HOLD, etc for feature buttons
    lpButtonInfo->dwButtonFunction = pButtonInfo->dwButtonFunction;

    // The current button state
    lpButtonInfo->dwButtonState = pButtonInfo->dwButtonState;
    
    if (lpButtonInfo->dwTotalSize >= lpButtonInfo->dwNeededSize)
    {
        lpButtonInfo->dwUsedSize = lpButtonInfo->dwNeededSize;

        // ButtonTextSize is the memory required to copy the string stored in
        // szButtonText field of the PHONESP_BUTTON_INFO structure for this 
        // Button   
        lpButtonInfo->dwButtonTextSize = (lstrlen(pButtonInfo->szButtonText)+1)
                                                  * sizeof (WCHAR);

        // Offset of the button text from the PHONEBUTTONINFO structure
        lpButtonInfo->dwButtonTextOffset = sizeof(PHONEBUTTONINFO);

        // Copy the button text at the lpButtonInfo->dwButtonTextOffset offset
        // from the ButtonText stored in the PHONESP_BUTTON_INFO structure for
        // this Button.   
        CopyMemory(
                   (LPBYTE)lpButtonInfo + lpButtonInfo->dwButtonTextOffset,
                    pButtonInfo->szButtonText,
                    lpButtonInfo->dwButtonTextSize
                   );
    }
    else
    {
        // no space to the store the button text info
        lpButtonInfo->dwUsedSize = sizeof(PHONEBUTTONINFO);
        lpButtonInfo->dwButtonTextSize = 0;
        lpButtonInfo->dwButtonTextOffset = 0;
    }

    LeaveCriticalSection(&pPhone->csThisPhone);
    
    LOG((PHONESP_TRACE, "TSPI_phoneGetButtonInfo - exit"));
    return 0;
}
/********************TSPI_phoneGetButtonInfo - end****************************/


/******************************************************************************
    TSPI_phoneGetDevCaps:
    
    This function queries a specified phone device to determine its telephony 
    capabilities.

    Arguments:
        DWORD dwDeviceID    - The phone device to be queried. 
        DWORD dwTSPIVersion - The negotiated TSPI version number. This value is
                              negotiated for this device through the 
                              TSPI_phoneNegotiateTSPIVersion function. 
        DWORD dwExtVersion  - The negotiated extension version number. This 
                              value is negotiated for this device through the 
                              TSPI_phoneNegotiateExtVersion function. 
        PHONECAPS lpPhoneCaps - A pointer to memory into which the TSP writes a 
                                variably sized structure of type PHONECAPS. 
                                Upon successful completion of the request, this
                                structure is filled with phone device capability
                                information. 

    Returns LONG:
    Zero if success 
    PHONEERR_ constants if an error occurs. Possible return values are:
    _BADDEVICEID,

    
******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetDevCaps(
    DWORD       dwDeviceID,
    DWORD       dwTSPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    PPHONESP_PHONE_INFO pPhone;
    PPHONESP_BUTTONINFO pButtonInfo;

    LOG((PHONESP_TRACE, "TSPI_phoneGetDevCaps - enter"));

    if (lpPhoneCaps->dwTotalSize < sizeof(PHONECAPS))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetDevCaps - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }
    
    EnterCriticalSection(&csAllPhones);

    // Given the deviceID retrieve the structure that contains the information
    // for this device
    pPhone = GetPhoneFromID(dwDeviceID, NULL); 

    if ( ! pPhone)
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneGetDevCaps - Bad Device ID"));
        return PHONEERR_BADDEVICEID;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);
       
    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetDevCaps - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    //
    // The size in bytes for this data structure that is needed to hold all the 
    // returned information. The returned includes the providerInfo string, 
    // PhoneInfo string and Phone Name string and Buttons Info - Button Function
    // and Button Mode.
    //
    lpPhoneCaps->dwNeededSize = sizeof (PHONECAPS) +
                                sizeof (WCHAR) *    
                                ( (lstrlenW(gszProviderInfo) + 1) +
                                  (lstrlenW(pPhone->wszPhoneInfo) + 1)    +
                                  (lstrlenW(pPhone->wszPhoneName) + 1)  ) +
                                (sizeof(DWORD) * pPhone->dwNumButtons * 2);

    lpPhoneCaps->dwUsedSize = sizeof(PHONECAPS);

    // lpPhoneCaps->dwPermanentPhoneID = ;

    //The string format to be used with this phone device
    lpPhoneCaps->dwStringFormat = STRINGFORMAT_UNICODE;

    // The state changes for this phone device for which the application can be
    // notified in a PHONE_STATE message. The Phone Info structure for each 
    // maintains this information
    lpPhoneCaps->dwPhoneStates = pPhone->dwPhoneStates;

    // Specifies the phone's hookswitch devices. Again the Phone Info structure 
    // maintains this information
    lpPhoneCaps->dwHookSwitchDevs = pPhone->dwHookSwitchDevs;
        
    // Specifies that we are a generic phone device. This means that in TAPI 3.1
    // we will be able to function on a variety of addresses.
    lpPhoneCaps->dwPhoneFeatures = PHONEFEATURE_GENERICPHONE;
                                  
    if(pPhone->dwHandset)
    {   // Specifies the phone's hookswitch mode capabilities of the handset.
        // The member is only meaningful if the hookswitch device is listed in
        // dwHookSwitchDevs. 
        lpPhoneCaps->dwHandsetHookSwitchModes = PHONEHOOKSWITCHMODE_ONHOOK | PHONEHOOKSWITCHMODE_MICSPEAKER;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETHOOKSWITCHHANDSET;
    }

    if(pPhone->dwSpeaker)
    {
        // Specifies the phone's hookswitch mode capabilities of the speaker.
        // The member is only meaningful if the hookswitch device is listed in
        // dwHookSwitchDevs.
        lpPhoneCaps->dwSpeakerHookSwitchModes = PHONEHOOKSWITCHMODE_ONHOOK | PHONEHOOKSWITCHMODE_MICSPEAKER;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETHOOKSWITCHSPEAKER |
                                        PHONEFEATURE_SETHOOKSWITCHSPEAKER;
    }

    // The ring capabilities of the phone device. The phone is able to ring
    // with dwNumRingModes different ring patterns, identified as 1, 2, through
    // dwNumRingModes minus one. If the value of this member is 0, applications
    // have no control over the ring mode of the phone. If the value of this 
    // member is greater than 0, it indicates the number of ring modes in 
    // addition to silence that are supported by the TSP. In this case, only one 
    // mode is supported.  
    if(pPhone->dwRing)
    {
        lpPhoneCaps->dwNumRingModes = 1;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETRING |
                                        PHONEFEATURE_SETRING;
    }

    if(pPhone->dwNumButtons)
    {
        // Specifies the number of button/lamps on the phone device that are 
        // detectable in TAPI. Button/lamps are identified by their identifier.     
        lpPhoneCaps->dwNumButtonLamps = pPhone->dwNumButtons;

        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETBUTTONINFO;
    }
    
    if(lpPhoneCaps->dwTotalSize >= lpPhoneCaps->dwNeededSize)
    {
        DWORD dwAlignedSize;
        DWORD dwRealSize; 


        ///////////////////
        // Provider Info
        ///////////////////

        // Size of the Provider Info string in bytes
        lpPhoneCaps->dwProviderInfoSize = ( lstrlen(gszProviderInfo) + 1) * 
                                            sizeof (WCHAR);
        dwRealSize = lpPhoneCaps->dwProviderInfoSize;

        // Offset of the Provider Info String from the PHONECAPS structure
        lpPhoneCaps->dwProviderInfoOffset = lpPhoneCaps->dwUsedSize;
    
        
        // Align it across DWORD boundary
        if (dwRealSize % sizeof(DWORD))
        {
            dwAlignedSize = dwRealSize - (dwRealSize % sizeof(DWORD)) + 
                            sizeof(DWORD);
        }
        else
        {
            dwAlignedSize = dwRealSize;
        }

        // Copy the provider Info string at the offset specified by 
        // lpPhoneCaps->dwProviderInfoOffset 
        CopyMemory(
                   ((LPBYTE)lpPhoneCaps) + lpPhoneCaps->dwProviderInfoOffset,
                   gszProviderInfo,
                   lpPhoneCaps->dwProviderInfoSize
                  );

        lpPhoneCaps->dwNeededSize += dwAlignedSize - dwRealSize;

        ///////////////////
        // Phone Info
        ///////////////////

        // Size of the Phone Info string in bytes
        lpPhoneCaps->dwPhoneInfoSize = (lstrlen(pPhone->wszPhoneInfo) + 1) * 
                                        sizeof(WCHAR);
        dwRealSize = lpPhoneCaps->dwPhoneInfoSize;

        // Offset of the Phone Info String from the PHONECAPS structure
        lpPhoneCaps->dwPhoneInfoOffset = lpPhoneCaps->dwProviderInfoOffset + 
                                         dwAlignedSize;

        // Align it across DWORD boundary
        if (dwRealSize % sizeof(DWORD))
        {
            dwAlignedSize = dwRealSize - (dwRealSize % sizeof(DWORD)) + 
                                          sizeof(DWORD);
        }
        else
        {
            dwAlignedSize = dwRealSize;
        }

        // Copy the Phone Info string at the offset specified by 
        // lpPhoneCaps->dwPhoneInfoOffset 
        CopyMemory(
                   ((LPBYTE)lpPhoneCaps) + lpPhoneCaps->dwPhoneInfoOffset,
                   pPhone->wszPhoneInfo,
                   lpPhoneCaps->dwPhoneInfoSize
                  );

        lpPhoneCaps->dwNeededSize += dwAlignedSize - dwRealSize;

        ///////////////////
        // Phone Name
        ///////////////////
    
        // Size of the Phone Name string in bytes
        lpPhoneCaps->dwPhoneNameSize = (lstrlen(pPhone->wszPhoneName)+ 1) * 
                                         sizeof (WCHAR);

        dwRealSize = lpPhoneCaps->dwPhoneNameSize;

        // Offset of the Phone Name String from the PHONECAPS structure
        lpPhoneCaps->dwPhoneNameOffset = lpPhoneCaps->dwPhoneInfoOffset +
                                         dwAlignedSize;

        // Align it across DWORD boundary
        if (dwRealSize % sizeof(DWORD))
        {
            dwAlignedSize = dwRealSize - (dwRealSize % sizeof(DWORD)) +
                                         sizeof(DWORD);
        }
        else
        {
            dwAlignedSize = dwRealSize;
        }

        // Copy the phone name string at the offset specified by 
        // lpPhoneCaps->dwPhoneNameOffset 
        CopyMemory(
                   ((LPBYTE)lpPhoneCaps) + lpPhoneCaps->dwPhoneNameOffset,
                   pPhone->wszPhoneName,
                   lpPhoneCaps->dwPhoneNameSize
                  );

        lpPhoneCaps->dwNeededSize += dwAlignedSize - dwRealSize;

        ////////////////////////////
        // Button Modes & Functions
        ////////////////////////////

        // If the phone has buttons, dial, feature, etc
        if(pPhone->dwNumButtons)
        {    
            DWORD i;

            // The size in bytes of the variably sized field containing the 
            // button modes of the phone's buttons, and the offset in bytes 
            // from the beginning of this data structure. This member uses the 
            // values specified by the PHONEBUTTONMODE_ constants. The 
            // array is indexed by button/lamp identifier. 
            lpPhoneCaps->dwButtonModesSize = (pPhone->dwNumButtons) * 
                                                sizeof (DWORD);
            lpPhoneCaps->dwButtonModesOffset = lpPhoneCaps->dwPhoneNameOffset +
                                               dwAlignedSize;
            
            //
            // The size in bytes of the variably sized field containing the 
            // button modes of the phone's buttons, and the offset in bytes 
            // from the beginning of this data structure. This member uses the 
            // values specified by the PHONEBUTTONFUNCTION_ constants. The 
            // array is indexed by button/lamp identifier. 
            //
            lpPhoneCaps->dwButtonFunctionsSize = pPhone->dwNumButtons * 
                                                    sizeof (DWORD);
            lpPhoneCaps->dwButtonFunctionsOffset  = 
                                            lpPhoneCaps->dwButtonModesOffset +
                                            lpPhoneCaps->dwButtonModesSize;

            pButtonInfo = pPhone->pButtonInfo;

            //
            // For each button on the phone copy the Button Function and Mode 
            // at the appropriate position
            //
            for ( i = 0; i < pPhone->dwNumButtons; i++, pButtonInfo++)
            {
                
                CopyMemory(
                           ((LPBYTE)lpPhoneCaps) + 
                           lpPhoneCaps->dwButtonModesOffset + i*sizeof(DWORD),
                            &pButtonInfo->dwButtonMode,
                           sizeof (DWORD)
                          );

                CopyMemory(
                           ((LPBYTE)lpPhoneCaps) + 
                           lpPhoneCaps->dwButtonFunctionsOffset + i*sizeof(DWORD),
                           &pButtonInfo->dwButtonFunction,
                           sizeof (DWORD)
                          );
            }

        }
        LeaveCriticalSection(&pPhone->csThisPhone);

        lpPhoneCaps->dwNumGetData = 0;
        lpPhoneCaps->dwNumSetData = 0;
        lpPhoneCaps->dwDevSpecificSize = 0;

        lpPhoneCaps->dwUsedSize = lpPhoneCaps->dwNeededSize;
    }
    else
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetDevCaps - "
                            "Not enough memory for Phonecaps [needed %d] [total %d]",
                            lpPhoneCaps->dwNeededSize, lpPhoneCaps->dwTotalSize));
    }

    LOG((PHONESP_TRACE, "TSPI_phoneGetDevCaps - exit"));
    return 0;
}
/**************************TSPI_phoneGetDevCaps - end*************************/




/******************************************************************************
    TSPI_phoneGetDisplay:
    
    This function returns the current contents of the specified phone display.

    Comments: To be implemented in Tier 2
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneGetDisplay(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDisplay
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneGetDisplay - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneGetDisplay - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}
/***********************TSPI_phoneGetDisplay - end****************************/


/******************************************************************************
    TSPI_phoneGetExtensionID:
    
    This function retrieves the extension identifier that the TSP supports for
    the indicated phone device.

    Comments: To be implemented in Tier 2
******************************************************************************/

    
LONG
TSPIAPI
TSPI_phoneGetExtensionID(
    DWORD               dwDeviceID,
    DWORD               dwTSPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneGetExtensionID - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneGetExtensionID - exit"));
    return 0;
}

/**********************TSPI_phoneGetExtensionID - end*************************/


/******************************************************************************
    TSPI_phoneGetHookSwitch:
    
    This function returns the current hookswitch mode of the specified open 
    phone device.

    Arguments:
        HDRVPHONE hdPhone - The handle to the phone
        LPDWORD lpdwHookSwitchDevs - The TSP writes the mode of the phone's 
                    hookswitch devices. This parameter uses the 
                    PHONEHOOKSWITCHDEV_ constants. If a bit position is False,
                    the corresponding hookswitch device is onhook.

    Returns LONG:
    Zero is the function succeeded
    else PHONEERR_ constants for error conditions


*******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwHookSwitchDevs
    )
{
    PPHONESP_PHONE_INFO pPhone;
    LOG((PHONESP_TRACE, "TSPI_phoneGetHookSwitch - enter"));
    
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // check whether the phone handle is valid
    if ( IsBadReadPtr(pPhone,sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneGetHookSwitch - Invalid Phone Handle"));
        return PHONEERR_INVALPHONEHANDLE;
    }


    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetHookSwitch - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // Check whether the phone is open
    if (! (pPhone->bPhoneOpen) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetHookSwitch - Phone Not Open"));
        return PHONEERR_INVALPHONESTATE;
    }

       *lpdwHookSwitchDevs = 0;

    // We are interested in only handset and speaker hookswitch - headset is not
    // supported
    if (pPhone->dwHandset)
    {
        if ( (pPhone->dwHandsetHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK) )
        {
            *lpdwHookSwitchDevs = PHONEHOOKSWITCHDEV_HANDSET;
        }
    }

    if (pPhone->dwSpeaker)
    {
        if( pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK) 
        {
            *lpdwHookSwitchDevs |= PHONEHOOKSWITCHDEV_SPEAKER;
        } 
    }
    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneGetHookSwitch - exit"));
    return 0;
}
/************************TSPI_phoneGetHookSwitch - end************************/


/******************************************************************************
    TSPI_phoneGetID:

    This function returns a device identifier for the given device class 
    associated with the specified phone device.

    Arguments:
        HDRVPHONE   hdPhone    - The handle to the phone to be queried.
        LPVARSTRING lpDeviceID - Pointer to the data structure of type VARSTRING 
                                 where the device idnetifier is returned.
        LPCWSTR lpszDeviceClass - Specifies the device class of the device whose
                                  identiifer is requested
        HANDLE hTargetProcess  - The process handle of the application on behalf 
                                 of which this function is being invoked.
    
    Returns LONG:
    Zero if the function succeeds
    PHONEERR_ constants if an error occurs.

    Comments: Currently supporting wave/in and wave/out only. 

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetID(
    HDRVPHONE   hdPhone,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass,
    HANDLE      hTargetProcess
    )
{
    PPHONESP_PHONE_INFO pPhone; 
    HRESULT hr;
    
    LOG((PHONESP_TRACE, "TSPI_phoneGetID - enter"));

    if (lpDeviceID->dwTotalSize < sizeof(VARSTRING))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetID - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // Verify whether the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneGetID - Invalid Phone Handle"));
        return PHONEERR_INVALPHONEHANDLE;
    } 
    
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetID - phone not allocated"));
        return PHONEERR_NODEVICE;
    }
        
    // verify whether the phone is open
    if ( ! pPhone->bPhoneOpen )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR,"TSPI_phoneGetID - Phone not open"));
        return PHONEERR_INVALPHONESTATE;
    }
        
    lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof (DWORD);

    lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;

    if ( lpDeviceID->dwTotalSize >= lpDeviceID->dwNeededSize )
    {                   
        // whether the requested ID is capture class
        if ( ! lstrcmpi(lpszDeviceClass, _T("wave/in") ) )
        {
            LOG((PHONESP_TRACE,"TSPI_phoneGetID - 'wave/in'"));

            if(pPhone->bCapture == TRUE)
            {
                // Discover Capture Wave ID 

                hr = DiscoverAssociatedWaveId(pPhone->pHidDevice->dwDevInst, 
                                              FALSE, 
                                              &pPhone->dwCaptureWaveId);

                if (hr != S_OK)
                {
                    LOG((PHONESP_ERROR, "TSPI_phoneGetID - "
                        "DiscoverAssociatedWaveID failed %0x", hr));
                }

                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                lpDeviceID->dwStringSize   = sizeof(DWORD);

                CopyMemory (
                       (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                        &pPhone->dwCaptureWaveId,
                        sizeof(DWORD)
                       );
            }
            else
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                LOG((PHONESP_ERROR,"TSPI_phoneGetID - No Capture Device"));
                return PHONEERR_NODEVICE;
            }
       
        }
        else
        { 
            // the wave ID is render class
            if ( ! lstrcmpi(lpszDeviceClass, _T("wave/out") ) )
            {
                LOG((PHONESP_TRACE,"TSPI_phoneGetID - 'wave/out'"));

                if(pPhone->bRender == TRUE)
                {
                    // Discover Render Wave ID 

                    hr = DiscoverAssociatedWaveId(pPhone->pHidDevice->dwDevInst, 
                                                  TRUE, 
                                                  &pPhone->dwRenderWaveId);

                    if (hr != S_OK)
                    {
                        LOG((PHONESP_ERROR, "TSPI_phoneGetID - "
                            "DiscoverAssociatedWaveID failed %0x", hr));
                    }

                    lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                    lpDeviceID->dwStringSize   = sizeof(DWORD);

                    CopyMemory (
                            (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                            &pPhone->dwRenderWaveId,
                            sizeof(DWORD)
                           );
                }
                else
                {
                    LeaveCriticalSection(&pPhone->csThisPhone);
                    LOG((PHONESP_ERROR,"TSPI_phoneGetID - No Render Device"));
                    return PHONEERR_NODEVICE;
                }
                    
            }
            else
            {   // the other classes are not supported or the phone does not have the 
                // specified device
                LeaveCriticalSection(&pPhone->csThisPhone);
                LOG((PHONESP_TRACE,"TSPI_phoneGetID - unsupported device class '%ws'", lpszDeviceClass));

                return PHONEERR_INVALDEVICECLASS;
            }     
        }
        lpDeviceID->dwUsedSize = lpDeviceID->dwNeededSize;
            
    }
    else
    {
        LOG((PHONESP_ERROR,"TSPI_phoneGetID : not enough total size"));
        lpDeviceID->dwUsedSize = sizeof(VARSTRING);
    }
 
    LeaveCriticalSection(&pPhone->csThisPhone);
  
  
    LOG((PHONESP_TRACE, "TSPI_phoneGetID - exit"));
    return 0;
}
/************************TSPI_phoneGetID  - end*******************************/


/******************************************************************************
    TSPI_phoneGetLamp:
    
    This function returns the current lamp mode of the specified lamp.

    Comments: To be implememted in Tier 2

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetLamp(
    HDRVPHONE   hdPhone,
    DWORD       dwButtonLampID,
    LPDWORD     lpdwLampMode
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneGetLamp - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneGetLamp - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}

/********************TSPI_phoneGetLamp - end**********************************/


/******************************************************************************
    TSPI_phoneGetRing:
    
    This function enables an application to query the specified open phone 
    device as to its current ring mode.

    Arguments:
        HDRVPHONE hdPhone - The handle to the phone whose ring mode is to be 
                            queried. 
        LPDWORD lpdwRingMode - The ringing pattern with which the phone is 
                         ringing. Zero indicates that the phone is not ringing.
        LPDWORD lpdwVolume - The volume level with which the phone is ringing. 
                        This is a number in the range from 0x00000000 (silence)
                        through 0x0000FFFF (maximum volume). 

    Returns LONG:
        Zero on Success
        PHONEERR_ constants on error

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneGetRing(
    HDRVPHONE   hdPhone,
    LPDWORD     lpdwRingMode,
    LPDWORD     lpdwVolume
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneGetRing - enter"));
    
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];
    // if the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - Invalid Phone Handle"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // whether the phone is open
    if ( ! pPhone->bPhoneOpen )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - Phone Not Open"));
        return PHONEERR_INVALPHONESTATE;    
    }

    // if the phone has a ringer attached to it
    if( ! pPhone->dwRing)
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetRing - "
                            "Phone does not have a ringer"));
        return PHONEERR_RESOURCEUNAVAIL;
    }
    
    *lpdwRingMode = pPhone->dwRingMode;
    
    // if ringmode is 0, it indicates that the phone is not ringing
    if(pPhone->dwRingMode) 
    {
         // The ring volume is maximum if the phone is ringing 
         *lpdwVolume = 0x0000FFFF;
    }
    else
    {
        // If the phone is not ringing the ring volume is 0
        *lpdwVolume = 0;
    }
    LeaveCriticalSection(&pPhone->csThisPhone); 
    
    LOG((PHONESP_TRACE, "TSPI_phoneGetRing - exit"));
    return 0;
}

/******************************TSPI_phoneGetRing - end************************/



/******************************************************************************
    TSPI_phoneGetStatus:

    This function queries the specified open phone device for its overall 
    status.

    Arguments:
    
        hdPhone         - The handle to the phone to be queried. 
        lpPhoneStatus   - A pointer to a variably sized data structure of type 
                PHONESTATUS, into which the TSP writes information about the 
                phone's status. Prior to calling TSPI_phoneGetStatus, the 
                application sets the dwTotalSize member of this structure to 
                indicate the amount of memory available to TAPI for returning
                information. 

    Returns LONG:
     
    Zero if the function succeeds, or 
    An error number if an error occurs. Possible return values are as follows: 
    PHONEERR_INVALPHONEHANDLE.
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneGetStatus(
    HDRVPHONE       hdPhone,
    LPPHONESTATUS   lpPhoneStatus
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneGetStatus - enter"));

    if (lpPhoneStatus->dwTotalSize < sizeof(PHONESTATUS))
    {
        LOG((PHONESP_ERROR, "TSPI_phoneGetStatus - structure too small"));
        return PHONEERR_STRUCTURETOOSMALL;
    }
    
    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];
    
    // check whether the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) ) 
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_TRACE,"TSPI_phoneGetStatus - INVALID PHONE HANDLE"));
        return PHONEERR_INVALPHONEHANDLE;
    }
  
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneGetStatus - phone not allocated"));
        return PHONEERR_NODEVICE;
    }
    
    if( ! pPhone->bPhoneOpen)
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_TRACE,"TSPI_phoneGetStatus - PHONE not Open"));
        return PHONEERR_INVALPHONEHANDLE;
    }

    lpPhoneStatus->dwNeededSize = sizeof(PHONESTATUS);

    if(lpPhoneStatus->dwTotalSize >= lpPhoneStatus->dwNeededSize)
    {
        lpPhoneStatus->dwUsedSize = sizeof (PHONESTATUS);
        lpPhoneStatus->dwStatusFlags = PHONESTATUSFLAGS_CONNECTED;

        // If the phone has a ringer 
        if(pPhone->dwRing)
        {
            lpPhoneStatus->dwRingMode = pPhone->dwRingMode;
            // If the Ring Mode is 0, the phone is not ringing
            if (pPhone->dwRingMode)
            {
                // by default the phone volume is 0xffff if it is ringing
                lpPhoneStatus->dwRingVolume = 0xffff;
            }
            else
            {
                // the phone volume is 0 if not ringing
                lpPhoneStatus->dwRingVolume = 0;
            }
        }
            
        lpPhoneStatus->dwHandsetHookSwitchMode = pPhone->dwHandsetHookSwitchMode;
        lpPhoneStatus->dwHandsetVolume = 0;
        lpPhoneStatus->dwHandsetGain = 0;
        
        if (pPhone->dwSpeaker)
        {
            lpPhoneStatus->dwSpeakerHookSwitchMode = pPhone->dwSpeakerHookSwitchMode;
            lpPhoneStatus->dwSpeakerVolume = 0;
            lpPhoneStatus->dwSpeakerGain = 0;
        }
    }

    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneGetStatus - exit"));
    return 0;
}
/****************************TSPI_phoneGetStatus - end************************/

/******************************************************************************
    TSPI_phoneNegotiateTSPIVersion:
    
    This function returns the highest SPI version the TSP can operate under for 
    this device, given the range of possible SPI versions.

    Arguments:

    Return LONG:

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneNegotiateTSPIVersion - enter"));
    
    if (dwHighVersion >= HIGH_VERSION)
    {
        if (dwLowVersion <= HIGH_VERSION)
        {
            *lpdwTSPIVersion = (DWORD) HIGH_VERSION;
        }
        else
        {   // the app is too new for us
            return PHONEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    else
    {
        if(dwHighVersion >= LOW_VERSION)
        {
            *lpdwTSPIVersion = dwHighVersion;
        }
        else
        {
            //we are too new for the app
            return PHONEERR_INCOMPATIBLEAPIVERSION;
        }
    }
   
    EnterCriticalSection(&csAllPhones);
    
    // Given the deviceID retrieve the structure that contains the information
    // for this device
    pPhone = GetPhoneFromID(dwDeviceID, NULL); 

    if ( ! pPhone)
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneNegotiateTSPIVersion - Bad Device ID"));
        return PHONEERR_BADDEVICEID;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneNegotiateTSPIVersion - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // Store the version negotiated for this phone 
    pPhone->dwVersion = *lpdwTSPIVersion;

    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneNegotiateTSPIVersion - exit"));
    return 0;
}
/**********************TSPI_phoneNegotiateTSPIVersion - end*******************/


/******************************************************************************
    TSPI_phoneOpen:
    
    This function opens the phone device whose device identifier is given, 
    returning the TSP's opaque handle for the device and retaining TAPI's 
    opaque handle for the device for use in subsequent calls to the PHONEEVENT
    procedure.

    Arguments:

    Returns:
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneOpen(
    DWORD       dwDeviceID,
    HTAPIPHONE  htPhone,
    LPHDRVPHONE lphdPhone,
    DWORD       dwTSPIVersion,
    PHONEEVENT  lpfnEventProc
    )
{
    LPPHONEBUTTONINFO lpButtonInfo;
    DWORD dwPhoneID;
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_phoneOpen - enter"));
       
    EnterCriticalSection(&csAllPhones);
    
    // if the device id is not valid return error condition
    if ( ! ( pPhone = GetPhoneFromID(dwDeviceID, &dwPhoneID) ) )
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Invalid Phone Handle"));
        return PHONEERR_BADDEVICEID;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneOpen - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // if the phone is already open then return error condition
    if (pPhone->bPhoneOpen)
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Phone is open"));
        return PHONEERR_INUSE;
    }

    // Create an event that signals the receipt of an input report from
    // the phone device
    if ( ! ( pPhone->hInputReportEvent = 
                                CreateEvent ((LPSECURITY_ATTRIBUTES) NULL,
                                               FALSE,   // manual reset
                                              FALSE,  // non-signaled
                                              NULL    // unnamed
                                             ) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Create Event: hInputReportEvent"
                           " Failed: %d", GetLastError()));
        return PHONEERR_NOMEM;
    }

    // Create an event that we will signal when we close the phone to
    // allow the read thread to exit
    if ( ! ( pPhone->hCloseEvent = 
                                CreateEvent ((LPSECURITY_ATTRIBUTES) NULL,
                                               FALSE,   // manual reset
                                              FALSE,  // non-signaled
                                              NULL    // unnamed
                                             ) ) )
    {
        CloseHandle(pPhone->hInputReportEvent);

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Create Event: hWaitCompletionEvent"
                           " Failed: %d", GetLastError()));
        return PHONEERR_NOMEM;
    }

    //
    // The overlapped structure contains the event to be set when an input 
    // report is received. The event to be set is the hInputReportEvent 
    // which is part of the PHONESP_PHONE_INFO structure. This overlapped
    // structure is passed to the ReadFile function call. 
    //
    if( ! ( pPhone->lpOverlapped = (LPOVERLAPPED) 
                                               MemAlloc (sizeof(OVERLAPPED)) ))
    {
        CloseHandle(pPhone->hCloseEvent);
        CloseHandle(pPhone->hInputReportEvent);

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Not enough memory for"
                            " lpOverlapped structure "));

        return PHONEERR_NOMEM;
    }
    pPhone->lpOverlapped->Offset = 0;
    pPhone->lpOverlapped->OffsetHigh = 0;
    pPhone->lpOverlapped->hEvent = pPhone->hInputReportEvent;

    //
    // Open the HID file handle
    //
    if ( ! OpenHidFile(pPhone->pHidDevice) )
    {
		MemFree(pPhone->lpOverlapped);
        CloseHandle(pPhone->hCloseEvent);
        CloseHandle(pPhone->hInputReportEvent);        

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - HidOpenFile failed"));

        return PHONEERR_OPERATIONFAILED;
    }
    

    // Increase the number of packets that the HID class driver ring buffer
    // holds for the device
    if ( ! HidD_SetNumInputBuffers(pPhone->pHidDevice->HidDevice, 
                                   20) )
    {
		CloseHidFile(pPhone->pHidDevice);
		MemFree(pPhone->lpOverlapped);
        CloseHandle(pPhone->hCloseEvent);
		CloseHandle(pPhone->hInputReportEvent);        

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - HidD_SetNumInputBuffers"
                           " Failed: %d", GetLastError()));

		return PHONEERR_OPERATIONFAILED;
    }

    //
    // Start a thread for waiting for input reports from the device. We
    // cannot use the thread pool for this because we will need to cancel
    // pending reads if we want to close the device.
    //
    if ( ! ( pPhone->hReadThread = 
                                CreateThread ((LPSECURITY_ATTRIBUTES) NULL,
                                              0,
                                              (LPTHREAD_START_ROUTINE) ReadThread,
                                              pPhone,
                                              0,
                                              NULL
                                             ) ) )
    {
		CloseHidFile(pPhone->pHidDevice);
		MemFree(pPhone->lpOverlapped);
        CloseHandle(pPhone->hCloseEvent);
		CloseHandle(pPhone->hInputReportEvent);        

        LeaveCriticalSection(&pPhone->csThisPhone);

        LOG((PHONESP_ERROR,"TSPI_phoneOpen - Create Thread: hReadThread"
                           " Failed: %d", GetLastError()));
        return PHONEERR_NOMEM;
    }

	//
	// Set phone open
	//
	pPhone->bPhoneOpen = TRUE;
    pPhone->htPhone = htPhone;
	pPhone->lpfnPhoneEventProc = lpfnEventProc;

    *lphdPhone = (HDRVPHONE)IntToPtr(dwPhoneID);

    //
    // Update values for phone features (such as hookswitch state)
    //
    UpdatePhoneFeatures( pPhone );

    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_phoneOpen - exit"));
    return 0;
}
/********************TSPI_phoneOpen - end*************************************/


/******************************************************************************
    TSPI_phoneSelectExtVersion:
    
    This function selects the indicated extension version for the indicated 
    phone device. Subsequent requests operate according to that extension 
    version.

    Comments: To be implemented in Tier 2

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
    HDRVPHONE   hdPhone,
    DWORD       dwExtVersion
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneSelectExtVersion- enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneSelectExtVersion - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}
/****************************TSPI_phoneSelectExtVersion - end*****************/


/******************************************************************************

    TSPI_phoneSetDisplay:
    
    This function causes the specified string to be displayed on the specified 
    open phone device.

    Comments: To be implemented in Tier 2
******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetDisplay(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRow,
    DWORD           dwColumn,
    LPCWSTR         lpsDisplay,
    DWORD           dwSize
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneSetDisplay - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneSetDisplay - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}

/****************************TSPI_phoneSetDisplay - end***********************/

/******************************************************************************
    TSPI_phoneSetHookSwitch_AsyncProc:
    
    This function sets the hook state of the specified open phone's hookswitch 
    devices to the specified mode. Only the hookswitch state of the hookswitch 
    devices listed is affected. 

    Arguments:
        PMYFUNC_INFO pAsyncFuncInfo - The parameters passed to this function
                     Param1  - Pointer to the phone structure
                     Param2  - dwRequestID which is needed while calling
                               ASYNC_COMPLETION to inform TAPI about the result 
                               of the operation. This was passed by tapi when 
                               calling TSPI_phoneSetHookSwitch
                     Param3  - PHONEHOOKSWITCHDEV_ constant. Currently only
                               _SPEAKER is supported.
                     Param4  - The HookSwitchMode that has to be set for 
                               the HookSwitch. This again is supplied by TAPI
                               Currently only PHONEHOOKSWITCHMODE_ONHOOK and
                               _MICSPEAKER is supported. 
    RETURNS VOID:

******************************************************************************/

VOID
CALLBACK
TSPI_phoneSetHookSwitch_AsyncProc(
                                  PPHONESP_FUNC_INFO pAsyncFuncInfo 
                                 )
{
    PPHONESP_PHONE_INFO pPhone;
    LONG                lResult = 0;
    
    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch_AsyncProc - enter"));

    EnterCriticalSection(&csAllPhones);
    
    pPhone = (PPHONESP_PHONE_INFO)pAsyncFuncInfo->dwParam1;
    
    // if the phone is not open
    if( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO)) || 
        ( ! pPhone->bAllocated) ||
        ( ! pPhone->bPhoneOpen) ||
        ( ! pPhone->pHidDevice) )
    {
        // This case may never arise since phone close waits for all 
        // asynchornous opreations on the phone to complete before closing the 
        // phone
        LONG lResult = PHONEERR_INVALPHONEHANDLE; 

        LeaveCriticalSection(&csAllPhones);
        // Notify TAPISRV about the error condition
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult
                                );
        LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch_AsyncProc - Invalid Phone"
                            " Handle"));
    }
    else
    {
        EnterCriticalSection(&pPhone->csThisPhone);
        LeaveCriticalSection(&csAllPhones);
        
        switch (pAsyncFuncInfo->dwParam4)
        {
        case PHONEHOOKSWITCHMODE_ONHOOK:
            if ( pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK )
            {
                //Inform tapi about the change in state of the hookswitch
                SendPhoneEvent(
                        pPhone,
                        PHONE_STATE, 
                        PHONESTATE_SPEAKERHOOKSWITCH, 
                        PHONEHOOKSWITCHMODE_ONHOOK,
                        (DWORD) 0
                      );

                pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;
            }           
            lResult = ERROR_SUCCESS;
            break;

        case PHONEHOOKSWITCHMODE_MICSPEAKER:
            if ( pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_MICSPEAKER )
            {
                //Inform tapi about the change in state of the hookswitch
                SendPhoneEvent(
                        pPhone,
                        PHONE_STATE, 
                        PHONESTATE_SPEAKERHOOKSWITCH, 
                        PHONEHOOKSWITCHMODE_MICSPEAKER,
                        (DWORD) 0
                      );

                pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;
            }            
            lResult = ERROR_SUCCESS;
            break;

        default:
           lResult = PHONEERR_RESOURCEUNAVAIL;    
           break;
        }
         
        // Send the result of the operation to TAPI
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult    // Result of the operation
                               );
       

        LeaveCriticalSection(&pPhone->csThisPhone);
    }

    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch_AsyncProc - exit"));
}

/******************************************************************************
    TSPI_phoneSetHookSwitch:

    This function sets the hook state of the specified open phone's hookswitch 
    devices to the specified mode. Only the hookswitch state of the hookswitch 
    devices listed is affected.

    Arguments:
        dwRequestID       - The identifier of the asynchronous request. 
        hdPhone           - The handle to the phone containing the hookswitch 
                            devices whose modes are to be set. 
        dwHookSwitchDevs  - The device(s) whose hookswitch mode is to be set. 
                         This parameter uses the following PHONEHOOKSWITCHDEV_ 
                         constants: PHONEHOOKSWITCHDEV_HANDSET, 
                         PHONEHOOKSWITCHDEV_SPEAKER, PHONEHOOKSWITCHDEV_HEADSET 
        dwHookSwitchMode  - The hookswitch mode to set. This parameter can have
                            only one of the following PHONEHOOKSWITCHMODE_ bits 
                            set: PHONEHOOKSWITCHMODE_ONHOOK, _MIC, _SPEAKER, 
                            _MICSPEAKER 

    Return LONG:
        Returns dwRequestID or an error number if an error occurs. 
        The lResult actual parameter of the corresponding ASYNC_COMPLETION is 
        zero if the function succeeds or it is an error number if an error 
        occurs. Possible return values are as follows: 
        PHONEERR_INVALPHONEHANDLE, PHONEERR_RESOURCEUNAVAIL, 
        PHONEERR_INVALHOOKSWITCHMODE, 

    Remarks
        A PHONE_STATE message is sent to the application after the hookswitch
        state has changed.

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwHookSwitchDevs,
    DWORD           dwHookSwitchMode
    )
{
    PPHONESP_PHONE_INFO pPhone;
    
    // 
    // Since only mode should be selected. We are making sure that only one 
    // mode is selected at a time.. 
    //
    BOOL ONHOOK = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_ONHOOK),
         MIC     = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_MIC), 
         SPEAKER = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_SPEAKER), 
         MICSPEAKER = ~(dwHookSwitchMode ^ PHONEHOOKSWITCHMODE_MICSPEAKER);

    PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
    PPHONESP_FUNC_INFO pFuncInfo;

    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch - enter"));

    EnterCriticalSection(&csAllPhones);
    
    pPhone = (PPHONESP_PHONE_INFO) gpPhone[ (DWORD_PTR) hdPhone ];

    // if the phone handle is valid and the phone is open
    if( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) || 
        (! pPhone->bPhoneOpen) )
    {
        LeaveCriticalSection(&csAllPhones);
        return PHONEERR_INVALPHONEHANDLE;
    }

    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    //
    // Only the speaker phone can be set, the other hookswitch types are error
    // conditions
    //
    if( ! (dwHookSwitchDevs & PHONEHOOKSWITCHDEV_SPEAKER) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch - only speaker hookswitch is supported"));
        return PHONEERR_RESOURCEUNAVAIL;
    }
   
    LOG((PHONESP_TRACE, "PHONEHOOKSWITCHDEV_SPEAKER"));

    //
    // Make sure the phone supports a speakerphone
    //
    if ( ! ( pPhone->dwSpeaker ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "No speaker"));
        return PHONEERR_RESOURCEUNAVAIL;
    }
   
    // Inorder to confirm that one mode is set 
    if( ! ( ONHOOK | MIC | SPEAKER| MICSPEAKER ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "Mulitple modes set for the speaker"));
        return PHONEERR_INVALHOOKSWITCHMODE;                    
    }
    
    // Build the structure for queueing the request in the Async queue
    if( ! (pFuncInfo = (PPHONESP_FUNC_INFO) 
                       MemAlloc( sizeof (PHONESP_FUNC_INFO)) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        return PHONEERR_NOMEM;
    }

    pFuncInfo->dwParam1    = (ULONG_PTR) pPhone; 

    pFuncInfo->dwParam2    = dwRequestID;

    pFuncInfo->dwParam3    = (ULONG_PTR) PHONEHOOKSWITCHDEV_SPEAKER;
    pFuncInfo->dwParam4    = (ULONG_PTR) dwHookSwitchMode;
    pFuncInfo->dwNumParams = 4;
    
    if ( ! ( pAsyncReqInfo = (PPHONESP_ASYNC_REQ_INFO) 
                              MemAlloc(sizeof (PHONESP_ASYNC_REQ_INFO)) ) )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        MemFree(pFuncInfo);
        return PHONEERR_NOMEM;
    }

    pAsyncReqInfo->pfnAsyncProc = TSPI_phoneSetHookSwitch_AsyncProc;
    pAsyncReqInfo->pFuncInfo = pFuncInfo;
    
    //
    // if Queue the request to perform asynchronously fails then we need to 
    // decrement the counter of number of pending requests on the phone
    //
    if( AsyncRequestQueueIn(pAsyncReqInfo) )
    {  
        // Reset the event for number of pending requests in the queue for this
        // phone and increment the counter
        if (pPhone->dwNumPendingReqInQueue == 0)
        {
          ResetEvent(pPhone->hNoPendingReqInQueueEvent);
        }
        pPhone->dwNumPendingReqInQueue++;
        LeaveCriticalSection(&pPhone->csThisPhone);
    }
    else
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        MemFree(pAsyncReqInfo);
        MemFree(pFuncInfo);
        // maybe need to free the request memory
        return PHONEERR_NOMEM;
    } 
    
 
    LOG((PHONESP_TRACE, "TSPI_phoneSetHookSwitch - exit"));
    return dwRequestID;
}
/*******************TSPI_phoneSetHookSwitch - end****************************/


/*****************************************************************************
    TSPI_phoneSetLamp:
    
    This function causes the specified lamp to be set on the specified open 
    phone device in the specified lamp mode.

    Comments: To be implemented in Tier 2
******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetLamp(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwButtonLampID,
    DWORD           dwLampMode
    )
{
    LOG((PHONESP_TRACE, "TSPI_phoneSetLamp - enter"));
    LOG((PHONESP_TRACE, "TSPI_phoneSetLamp - exit"));
    return PHONEERR_OPERATIONUNAVAIL;
}
/****************************TSPI_phoneSetLamp - end**************************/

/******************************************************************************
    TSPI_phoneSetRing_AsyncProc:

    Arguments:

    Returns:

    Comments: To be implemented. currently there is no corresponding usage in 
               Hid hence no output report is sent. 
******************************************************************************/
VOID
CALLBACK
TSPI_phoneSetRing_AsyncProc(
                            PPHONESP_FUNC_INFO pAsyncFuncInfo 
                           )
{
    PPHONESP_PHONE_INFO pPhone;
    LONG                lResult = 0;

    LOG((PHONESP_TRACE,"TSPI_phoneSetRing_AsyncProc - enter"));

    EnterCriticalSection(&csAllPhones);
    
    pPhone = (PPHONESP_PHONE_INFO)pAsyncFuncInfo->dwParam1;
    
    // if the phone is not open
    if( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO)) || 
        ( ! pPhone->bPhoneOpen) ||
        ( ! pPhone->bAllocated) ||
        ( ! pPhone->pHidDevice) )
    {
        // This case may never arise since phone close waits for all 
        // asynchornous opreations on the phone to complete before closing the 
        // phone
        LONG lResult = PHONEERR_INVALPHONEHANDLE; 

        LeaveCriticalSection(&csAllPhones);
        // Notify TAPISRV about the error condition
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult
                                );
        LOG((PHONESP_ERROR, "TSPI_phoneSetRing_AsyncProc - Invalid Phone"
                            " Handle"));
    }
    else
    {
        EnterCriticalSection(&pPhone->csThisPhone);
        LeaveCriticalSection(&csAllPhones);
    
        
        lResult = SendOutputReport(
                                   pPhone->pHidDevice, 
                                   HID_USAGE_TELEPHONY_RINGER,
                                   ((pAsyncFuncInfo->dwParam3 == 0) ? FALSE : TRUE)
                                  );

        if(lResult == ERROR_SUCCESS)
        {
            lResult = 0;

            pPhone->dwRingMode = (DWORD)pAsyncFuncInfo->dwParam3;

            //Inform tapi about the change in state of the hookswitch
            SendPhoneEvent(
                            pPhone,
                            PHONE_STATE, 
                            PHONESTATE_RINGMODE, 
                            (DWORD) pAsyncFuncInfo->dwParam3,
                            (DWORD) pAsyncFuncInfo->dwParam4
                      );
        }
        else
        {
            LOG((PHONESP_ERROR, "TSPI_phoneSetHookSwitch_AsyncProc - "
                                "SendOutputReport Failed"));
            lResult = PHONEERR_RESOURCEUNAVAIL;
        }
         
        // Send the result of the operation to TAPI
        (*(glpfnCompletionProc))(
                                (DRV_REQUESTID) pAsyncFuncInfo->dwParam2,
                                lResult    // Result of the operation
                               );
       

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
        

    LOG((PHONESP_TRACE,"TSPI_phoneSetRing_AsyncProc - exit"));
}
/*******************TSPI_phoneSetRing_AsyncProc - end*************************/

/******************************************************************************
    TSPI_phoneSetRing:
    
    This function rings the specified open phone device using the specified 
    ring mode and volume.

    Arguments:
        DRV_REQUESTID dwRequestID - Identifier of the asynchronous request. 
        HDRVPHONE hdPhone - Handle to the phone to be rung. 
        DWORD dwRingMode - The ringing pattern with which to ring the phone.
                         This parameter must be within the range from zero 
                         through the value of the dwNumRingModes member in the
                         PHONECAPS structure. If dwNumRingModes is zero, the 
                         ring mode of the phone cannot be controlled; if 
                         dwNumRingModes is 1, a value of 0 for dwRingMode 
                         indicates that the phone should not be rung (silence),
                         and other values from 1 through dwNumRingModes are 
                         valid ring modes for the phone device. 
        DWORD dwVolume - The volume level with which the phone is to be rung.
                         This is a number in the range from 0x00000000 
                         (silence) through 0x0000FFFF (maximum volume). 

    Returns LONG:
    Zero if success
    PHONEERR_ constants if an error occurs
    
******************************************************************************/

LONG
TSPIAPI
TSPI_phoneSetRing(
    DRV_REQUESTID   dwRequestID,
    HDRVPHONE       hdPhone,
    DWORD           dwRingMode,
    DWORD           dwVolume
    )
{
    PPHONESP_PHONE_INFO pPhone = (PPHONESP_PHONE_INFO)gpPhone[ (DWORD_PTR) hdPhone ];
    
    LOG((PHONESP_TRACE, "TSPI_phoneSetRing - enter"));
    
    EnterCriticalSection(&csAllPhones);
    
    // to confirm that the phone is open
    if( ! (pPhone && pPhone->htPhone) )
    {
        LeaveCriticalSection(&csAllPhones);
        return PHONEERR_INVALPHONEHANDLE;
    }
    
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetRing - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    // The ringer can only be set if the phone has an output feature for this
    // usage
    if( ! (pPhone->dwRing & OUTPUT_REPORT) )
    {
        // The phone has a ringer but no output feature
        if(pPhone->dwRing)
        {
            LeaveCriticalSection(&pPhone->csThisPhone);
            return PHONEERR_OPERATIONUNAVAIL;
        }
        // The phone does not have a ringer
        else
        {
            LeaveCriticalSection(&pPhone->csThisPhone);
            return PHONEERR_RESOURCEUNAVAIL;
        }
    }
 
    if ( (dwRingMode == 0) || (dwRingMode == 1) )
    {
        // Check whether the volume is within range
        if(dwVolume <= 0x0000FFFF)
        {
            PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo;
            PPHONESP_FUNC_INFO pFuncInfo;

            // Build the structure for the queueing the request in Async queue
            if ( ! (pFuncInfo = (PPHONESP_FUNC_INFO) 
                                MemAlloc(sizeof (PHONESP_FUNC_INFO)) ) )
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                return PHONEERR_NOMEM;
            }
            
            pFuncInfo->dwNumParams = 4;
            pFuncInfo->dwParam1 = (ULONG_PTR) pPhone;
            pFuncInfo->dwParam2 = dwRequestID;
            pFuncInfo->dwParam3 = (ULONG_PTR) dwRingMode;
            pFuncInfo->dwParam4 = (ULONG_PTR) dwVolume;

            if ( ! ( pAsyncReqInfo = (PPHONESP_ASYNC_REQ_INFO) 
                                     MemAlloc(sizeof(PHONESP_ASYNC_REQ_INFO))))
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                MemFree(pFuncInfo);
                return PHONEERR_NOMEM;
            }
            pAsyncReqInfo->pfnAsyncProc = TSPI_phoneSetRing_AsyncProc;
            pAsyncReqInfo->pFuncInfo = pFuncInfo;

            // Queue the request to perform the operation asynchronously
            if( AsyncRequestQueueIn(pAsyncReqInfo) )
            {  
                // Reset the event for number of pending requests in the queue 
                // for this phone and increment the counter
                if (pPhone->dwNumPendingReqInQueue == 0)
                {
                    ResetEvent(pPhone->hNoPendingReqInQueueEvent);
                }
                pPhone->dwNumPendingReqInQueue++;
                LeaveCriticalSection(&pPhone->csThisPhone);
            }
            else
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                MemFree(pFuncInfo);
                MemFree(pAsyncReqInfo);
                return PHONEERR_NOMEM;
            }  
        }
        else
        {
            LeaveCriticalSection(&pPhone->csThisPhone);
            return PHONEERR_INVALPARAM;
        }
    }
    else
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        return PHONEERR_INVALRINGMODE;
    }

    LOG((PHONESP_TRACE, "TSPI_phoneSetRing - exit"));
    return 0;
}
/********************TSPI_phoneSetRing - end**********************************/


/******************************************************************************
    TSPI_phoneSetStatusMessages:
    
    This function causes the TSP to filter status messages that are not 
    currently of interest to any application.

    Arguments:

    Returns:

******************************************************************************/
LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
    HDRVPHONE   hdPhone,
    DWORD       dwPhoneStates,
    DWORD       dwButtonModes,
    DWORD       dwButtonStates
    )
{
    PPHONESP_PHONE_INFO pPhone = (PPHONESP_PHONE_INFO)gpPhone[ (DWORD_PTR) hdPhone ];

    LOG((PHONESP_TRACE, "TSPI_phoneSetStatusMessages - enter"));
    
    EnterCriticalSection(&csAllPhones);
    if( ! (pPhone && pPhone->htPhone) )
    {
        LeaveCriticalSection(&csAllPhones);
        return PHONEERR_INVALPHONEHANDLE;
    }
  
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    // Check whether the phone handle is still in use
    if ( !pPhone->bAllocated )
    {
        LeaveCriticalSection(&pPhone->csThisPhone);
        LOG((PHONESP_ERROR, "TSPI_phoneSetStatusMessages - phone not allocated"));
        return PHONEERR_NODEVICE;
    }

    pPhone->dwPhoneStateMsgs = dwPhoneStates;
    if (dwButtonModes)
    {
        if(dwButtonStates)
        {
            pPhone->dwButtonModesMsgs = dwButtonModes;
            pPhone->dwButtonStateMsgs = dwButtonStates;
        }
    }
  
    LeaveCriticalSection(&pPhone->csThisPhone);
    LOG((PHONESP_TRACE, "TSPI_phoneSetStatusMessages - exit"));
    return 0;
}

/********************TSPI_phoneSetStatusMessages - end************************/

//
// ------------------------- TSPI_providerXxx funcs ---------------------------

/******************************************************************************
    TSPI_providerCreatePhoneDevice

    The TSP will use this function to implement PNP support. TapiSrv will call
    the TSP back with this function when the TSP sends the PHONE_CREATE message
    to Tapisrv, which allows the dynamic creation of a new phone device. 

    Arguments:
        dwTempID   - The temporary device identifier that the TSP passed to 
                     TAPI in the PHONE_CREATE message. 
        dwDeviceID - The device identifier that TAPI assigns to this device if 
                     this function succeeds. 

    Returns LONG:
        Zero if the request succeeds 
        An error number if an error occurs. 

    Comments: 

******************************************************************************/
LONG
TSPIAPI
TSPI_providerCreatePhoneDevice(
    DWORD_PTR   dwTempID,
    DWORD       dwDeviceID
    )
{
    PPHONESP_PHONE_INFO pPhone;

    LOG((PHONESP_TRACE, "TSPI_providerCreatePhoneDevice - enter"));

    EnterCriticalSection(&csAllPhones);

    pPhone = (PPHONESP_PHONE_INFO)gpPhone[ (DWORD_PTR) dwTempID ];
    
    // check whether the phone handle is valid
    if ( IsBadReadPtr(pPhone, sizeof(PHONESP_PHONE_INFO) ) ) 
    {
        LeaveCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR,"TSPI_providerCreatePhoneDevice - invalid temp id"));
        return PHONEERR_INVALPHONEHANDLE;
    }
  
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    if (pPhone->bCreatePending)
    {
        //
        // Set the device ID and mark create complete
        //
        pPhone->dwDeviceID = dwDeviceID;
        pPhone->bCreatePending = FALSE;
    }
    else
    {
        LOG((PHONESP_ERROR, "TSPI_providerCreatePhoneDevice - phone is not marked create pending"));
    }

    LOG((PHONESP_TRACE, "TSPI_providerCreatePhoneDevice - phone create complete [dwTempID %d] [dwDeviceID %d] ", dwTempID, dwDeviceID));
    
    LeaveCriticalSection(&pPhone->csThisPhone);

    LOG((PHONESP_TRACE, "TSPI_providerCreatePhoneDevice - exit"));
    return 0;
}

/*****************TSPI_providerCreatePhoneDevice - end************************/

/******************************************************************************
    TSPI_providerEnumDevices:

    TAPI calls the this function before TSPI_providerInit to determine the 
    number of line and phone devices supported by the TSP.
   
    Arguments:
        dwPermanentProviderID - The permanent identifier,unique within the TSPs
                                on this system, of the TSP being initialized. 
        lpdwNumLines(ignored) - TAPI initializes the value to 0.
        lpdwNumPhones         - A pointer to a DWORD-sized memory location into
                                which the TSP must write the number of phone 
                                devices it is configured to support. TAPI 
                                initializes the value to 0.         
        hProvider             - An opaque DWORD-sized value that uniquely 
                               identifies this instance of this TSP during this 
                               execution of the Win32 Telephony environment. 
        lpfnLineCreateProc(ignored)- A pointer to the LINEEVENT callback 
                                procedure supplied by TAPI. Ignored by this TSP
        lpfnPhoneCreateProc   - A pointer to the PHONEEVENT callback procedure 
                                supplied by TAPI. The TSP uses this function to 
                                send PHONE_CREATE messages when a new phone 
                                device needs to be created. 

    Returns LONG:
        Zero if the request succeeds or 
        An error number if an error occurs. 

    Comments:Gets a pointer to the Hid Devices belonging to the telephony page.

******************************************************************************/

LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
    )
{
    PPHONESP_PHONE_INFO   *pPhone;

    DWORD                 dwPhoneCnt, dwNumChars, dwCount;
    
    LONG                  lResult = 0;

    PHID_DEVICE           pHidDevice;
    PHID_DEVICE           pHidDevices;
    ULONG                 NumHidDevices;

    HRESULT               hr;

    LOG((PHONESP_TRACE, "TSPI_providerEnumDevices - enter"));

    //
    // Initialise critical section for all phones which is the global object.
    // Before accessing the phone structure, the thread must grab this object
    // 
    __try
    {
        InitializeCriticalSection(&csAllPhones);        
    }
    __except(1)
    {
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - Initialize Critical Section"
                            " Failed for csAllPhones"));
        return PHONEERR_NOMEM;
    }

    //
    // Initialise critical section for all hid devices which is the global object.
    // Before accessing the hid list, the thread must grab this object
    // 
    __try
    {
        InitializeCriticalSection(&csHidList);        
    }
    __except(1)
    {
        DeleteCriticalSection(&csAllPhones);
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - Initialize Critical Section"
                            " Failed for csHidList"));
        return PHONEERR_NOMEM;
    }

#if DBG
    //Initialize critical section for memory tracing
    __try
    {
        InitializeCriticalSection(&csMemoryList);
    }
    __except(1)
    {
        DeleteCriticalSection(&csAllPhones);
        DeleteCriticalSection(&csHidList);

        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - Initialize Critical Section"
                            " Failed for csMemoryList"));
        return PHONEERR_NOMEM;
    }
#endif

    EnterCriticalSection(&csHidList);

    // Find Telephony hid Devices 
    lResult = FindKnownHidDevices (&pHidDevices, 
                                   &NumHidDevices);

    if (lResult != ERROR_SUCCESS)  
    {     
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - FindKnownHidDevices failed %d", lResult));

        LeaveCriticalSection(&csHidList);
        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        if (lResult == ERROR_OUTOFMEMORY)
        {          
            return PHONEERR_NOMEM;
        }
        else
        {
            return PHONEERR_OPERATIONFAILED;
        }
    }


    LOG((PHONESP_TRACE, "TSPI_providerEnumDevices - number of Hid Devices : %d ", NumHidDevices));

    // Allocate memory for the array of pointers where each pointer points to
    // one of the phone discovered
    
    pPhone = MemAlloc(NumHidDevices * sizeof(PPHONESP_PHONE_INFO));

    if ( pPhone == NULL )
    {
        LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - OUT OF MEMORY allocating pPhone"));

        CloseHidDevices();
        LeaveCriticalSection(&csHidList);
        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }

    //
    // for each phone discovered, gather the capabilities of the phone and 
    // initialize the phone structure
    //
    dwPhoneCnt = 0;

    for (pHidDevice = pHidDevices; pHidDevice != NULL; pHidDevice = pHidDevice->Next)
    {
        pHidDevice->bNew = FALSE;

        // Allocate memory for this phone 
        pPhone[dwPhoneCnt] = (PPHONESP_PHONE_INFO)MemAlloc(sizeof(PHONESP_PHONE_INFO));

        if ( pPhone[dwPhoneCnt] == NULL )
        { 
            LOG((PHONESP_ERROR, "TSPI_providerEnumDevices - OUT OF MEMORY allocating PPHONESP_PHONE_INFO"
                " for Phone %d", dwPhoneCnt));

            // Release memory allocated to other phones
            for(dwCount = 0; dwCount < dwPhoneCnt ; dwCount++)
            {
                FreePhone(pPhone[dwCount]);
                MemFree((LPVOID)pPhone[dwCount]);
                DeleteCriticalSection(&pPhone[dwCount]->csThisPhone);
            }
            MemFree((LPVOID)pPhone);

            CloseHidDevices();

            LeaveCriticalSection(&csHidList);
            DeleteCriticalSection(&csHidList);
            DeleteCriticalSection(&csAllPhones);
#if DBG
            DeleteCriticalSection(&csMemoryList);
#endif

            return PHONEERR_NOMEM;
        }

        LOG((PHONESP_TRACE, "TSPI_ProviderEnumDevices: Initializing Device: %d",dwPhoneCnt+1));

        ZeroMemory( pPhone[dwPhoneCnt], sizeof(PHONESP_PHONE_INFO));

        //
        // Initialize the critical section object for this phone. only the 
        // thread that owns this object can access the structure for this phone
        //
        __try 
        {
            InitializeCriticalSection(&pPhone[dwPhoneCnt]->csThisPhone);
        }
        __except(1)
        {
            // Release memory allocated to the phones
            for(dwCount = 0; dwCount < dwPhoneCnt; dwCount++)
            {
                FreePhone(pPhone[dwCount]);
                MemFree((LPVOID)pPhone[dwCount]);
                DeleteCriticalSection(&pPhone[dwCount]->csThisPhone);
            }
            MemFree((LPVOID)pPhone[dwPhoneCnt]);
            MemFree((LPVOID)pPhone);

            CloseHidDevices();

            LeaveCriticalSection(&csHidList);
            DeleteCriticalSection(&csHidList);
            DeleteCriticalSection(&csAllPhones);
#if DBG
            DeleteCriticalSection(&csMemoryList);
#endif

            LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - Initialize Critical Section"
                  " Failed for Phone %d", dwPhoneCnt));

            return PHONEERR_NOMEM;
        }

        lResult = CreatePhone( pPhone[dwPhoneCnt], pHidDevice, dwPhoneCnt );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - CreatePhone"
                  " Failed for Phone %d: error: %d", dwPhoneCnt, lResult));
        }
        else
        {
            // Phone created successfully, increase phone count
            dwPhoneCnt++; 
        }
    }

    LeaveCriticalSection(&csHidList);   

    *lpdwNumPhones = gdwNumPhones = dwPhoneCnt;

    //
    // If the space allocated previously was greater than the actual number of
    // supported phones
    //
    if(NumHidDevices != gdwNumPhones)
    {
        gpPhone = MemAlloc(gdwNumPhones * sizeof(PPHONESP_PHONE_INFO));

        if ( gpPhone == NULL )
        {           
            for(dwCount = 0; dwCount < dwPhoneCnt ; dwCount++)
            {
                FreePhone(pPhone[dwCount]);
                MemFree((LPVOID)pPhone[dwCount]);
                DeleteCriticalSection(&pPhone[dwCount]->csThisPhone);
            }
            MemFree(pPhone);

            CloseHidDevices();

            DeleteCriticalSection(&csAllPhones);
#if DBG
            DeleteCriticalSection(&csMemoryList);
#endif
            DeleteCriticalSection(&csHidList);

            LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - OUT OF MEMORY allocating gpPhone"));

            return PHONEERR_NOMEM;
        }

        CopyMemory(
                gpPhone,
                pPhone,
                sizeof(PPHONESP_PHONE_INFO) * gdwNumPhones
               );

        MemFree(pPhone);
    }
    else
    {
        gpPhone = pPhone;
    }
     
    glpfnPhoneCreateProc = lpfnPhoneCreateProc;
    ghProvider = hProvider;
 
    LOG((PHONESP_TRACE, "TSPI_providerEnumDevices - exit"));

    return 0;
}
/*************************TSPI_providerEnumDevices - end*********************/



/******************************************************************************
    TSPI_providerInit:

    The TSPI_providerInit function initializes the service provider and gives 
    it parameters required for subsequent operation.
    
    Arguments:

        dwTSPIVersion         - The version of the TSPI definition under which 
                                this function must operate. 
        dwPermanentProviderID - The permanent identifier, unique within the TSP
                                on this system, of the TSP being initialized. 
        dwLineDeviceIDBase      - Ignored by this TSP 
        dwPhoneDeviceIDBase      - The lowest device identifier for the phone 
                                devices supported by this service provider. 
        dwNumLines(Ignored)      - The number of line devices this TSP supports. 
        dwNumPhones              - The number of phone devices this TSP supports. 
                                The value returned is the number of phone 
                                devices reported in TSPI_providerEnumDevices. 
        lpfnCompletionProc    - The procedure the TSP calls to report 
                                completion of all asynchronously operating 
                                procedures on line and phone devices. 
        lpdwTSPIOptions          - A pointer to a DWORD-sized memory location,into
                                which the TSP can write a value specifying 
                                LINETSPIOPTIONS_ values. This parameter allows 
                                the TSP to return bits indicating optional 
                                behaviors desired of TAPI. TAPI sets the 
                                options DWORD to 0. 

    Returns LONG:
        Zero if the request succeeds or 
        An error number if an error occurs. 

    Comments:

******************************************************************************/

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD_PTR           dwNumLines,
    DWORD_PTR           dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
    )
{
    DWORD             dwThreadID;
    LONG              lResult = 0;
    
    LOGREGISTERTRACING(_T("hidphone"));

    LOG((PHONESP_TRACE, "TSPI_providerInit - enter"));
   
    
    // Load Provider Info From String Table
    gszProviderInfo = PHONESP_LoadString( 
                                         IDS_PROVIDER_INFO, 
                                         &lResult
                                        );

    if(lResult != ERROR_SUCCESS)
    {  
        DWORD dwPhoneCnt;

        LOG((PHONESP_ERROR,"TSPI_providerEnumDevices - PHONESP_LoadString failed %d", lResult));     
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);     

            MemFree(gpPhone[dwPhoneCnt]);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);
        
        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        if(lResult == ERROR_OUTOFMEMORY)
        {
            return PHONEERR_NOMEM;
        }
        else
        {
            return lResult;
        }
    }
  

    glpfnCompletionProc = lpfnCompletionProc;
    gdwPhoneDeviceIDBase = dwPhoneDeviceIDBase;
    gdwPermanentProviderID = dwPermanentProviderID;
 
    //
    // Assign device IDs to the phones
    //
    {
        DWORD dwPhoneCnt;
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            gpPhone[dwPhoneCnt]->dwDeviceID = gdwPhoneDeviceIDBase + dwPhoneCnt;
        }
    }          

    //
    // Alloc a queue for storing async requests for async completion,
    // and start a thread to service that queue
    //

    //Initialize critical section for the async queue
    __try
    {
        InitializeCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);
    }
    __except(1)
    {
        DWORD dwPhoneCnt;

        LOG((PHONESP_ERROR, "TSPI_providerInit - Initialize Critical Section"
                            " Failed for gAsyncQueue.AsyncEventQueueCritSec"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }

    gAsyncQueue.dwNumTotalQueueEntries = MAX_QUEUE_ENTRIES;
    gAsyncQueue.dwNumUsedQueueEntries = 0;

    //
    // Alloc memory for the queue to accomodate dwNumTotalQueueEntries ot begin
    // with. The size of the queue can later be increased as required
    //

    gAsyncQueue.pAsyncRequestQueue =
        MemAlloc(gAsyncQueue.dwNumTotalQueueEntries * sizeof(PPHONESP_ASYNC_REQ_INFO));

    if ( gAsyncQueue.pAsyncRequestQueue == NULL )
    {
        DWORD dwPhoneCnt;   
        
        LOG((PHONESP_ERROR, "TSPI_providerInit - OUT OF MEMORY allocating"
                            " gAsyncQueue.pAsyncRequestQueue"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);        

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }

    
    gAsyncQueue.pAsyncRequestQueueIn =
    gAsyncQueue.pAsyncRequestQueueOut = gAsyncQueue.pAsyncRequestQueue;

    //
    // the thread associated waits on this event when there are no requests 
    // pending in the queue. This event informs the thread when a request is 
    // entered in an empty queue so the thread can exit the wait state and 
    // process the request
    //

    gAsyncQueue.hAsyncEventsPendingEvent = CreateEvent (
                                               (LPSECURITY_ATTRIBUTES) NULL,
                                               TRUE,   // manual reset
                                               FALSE,  // non-signaled
                                               NULL    // unnamed
                                               );

    if ( gAsyncQueue.hAsyncEventsPendingEvent == NULL )
    {
        DWORD dwPhoneCnt;

        LOG((PHONESP_ERROR, "TSPI_providerInit - CreateEvent failed"
                            " for gAsyncQueue.hAsyncEventsPendingEvent"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);
        MemFree((LPVOID)gAsyncQueue.pAsyncRequestQueue); 

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif

        return PHONEERR_NOMEM;
    }


    //
    // Create the thread to service the requests in the queue
    //

    gAsyncQueue.hAsyncEventQueueServiceThread =
                 CreateThread (
                        (LPSECURITY_ATTRIBUTES) NULL,
                        0,      // default stack size
                        (LPTHREAD_START_ROUTINE) AsyncEventQueueServiceThread,
                        NULL,   // thread param
                        0,      // creation flags
                        &dwThreadID      // &dwThreadID
                      );

    if ( gAsyncQueue.hAsyncEventQueueServiceThread == NULL )
    {
        DWORD dwPhoneCnt; 
        
        LOG((PHONESP_ERROR, "TSPI_providerInit - CreateThread failed"
                            " for gAsyncQueue.hAsyncEventQueueServiceThread"));
            
        for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
        {
            FreePhone(gpPhone[dwPhoneCnt]);

            MemFree(gpPhone[dwPhoneCnt]);
            DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        }
        
        EnterCriticalSection(&csHidList);
        CloseHidDevices();
        LeaveCriticalSection(&csHidList);

        MemFree((LPVOID) gszProviderInfo);

        DeleteCriticalSection(&gAsyncQueue.AsyncEventQueueCritSec);
        CloseHandle(gAsyncQueue.hAsyncEventsPendingEvent);
        MemFree((LPVOID)gAsyncQueue.pAsyncRequestQueue); 

        DeleteCriticalSection(&csHidList);
        DeleteCriticalSection(&csAllPhones);
#if DBG
        DeleteCriticalSection(&csMemoryList);
#endif
    
        return PHONEERR_NOMEM;
    }

    LOG((PHONESP_TRACE, "TSPI_providerInit - exit"));
    return 0;
}
/***************************TSPI_providerInit - end***************************/


/******************************************************************************
    TSPI_providerInstall:

    This function is obsolete. However due to a bug in TAPI, the TSP must 
    provide a do-nothing implementation of this function and export it (along 
    with the superseding function TUISPI_providerInstall)
  
*******************************************************************************/
LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
    )
{
    LOG((PHONESP_TRACE, "TSPI_providerInstall - enter"));
    LOG((PHONESP_TRACE, "TSPI_providerInstall - exit"));
    return 0;
}
/*********************TSPI_providerInstall - end******************************/


/******************************************************************************
    TSPI_providerRemove:

    This function is obsolete. However due to a bug in TAPI, the TSP must 
    provide a do-nothing implementation of this function and export it (along 
    with the superseding function TUISPI_providerRemove)
  
*******************************************************************************/

LONG
TSPIAPI
TSPI_providerRemove (
                     HWND hwndOwner,
                     DWORD dwPermanentProviderId
                    )
{
    LOG((PHONESP_TRACE, "TSPI_providerRemove - enter"));
    LOG((PHONESP_TRACE, "TSPI_providerRemove - exit"));
    return 0;
}

/*********************TSPI_providerRemove - end******************************/



/******************************************************************************
    TSPI_providerShutdown:

    This function shuts down the TSP. The TSP terminates any activities it has 
    in progress and releases any resources it has allocated.

    Arguments:
        dwTSPIVersion          -    The version of the TSPI definition under which 
                                this function must operate.  
        dwPermanentProviderID - This parameter allows the TSP to determine which 
                                among multiple possible instances of the TSP is 
                                being shut down. The value of the parameter is 
                                identical to that passed in    the parameter of 
                                the same name in TSPI_providerInit. 

    Returns LONG:
        Zero if the request succeeds or 
        An error number if an error occurs. Possible return values are as follows: 
            LINEERR_INCOMPATIBLEAPIVERSION, LINEERR_NOMEM. 

    Comments: Whenever TAPI API call PhoneShutdown is called , it first shuts
              down all the phones that are currently open using TSPI_phoneClose
              and then calls TSPI_providerShutdown 
              

******************************************************************************/


LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
    )
{
    DWORD dwPhoneCnt = 0;
  
    LOG((PHONESP_TRACE, "TSPI_providerShutdown - enter"));


    // this will terminate the queue service thread once all the operations 
    // pending in the queue are serviced
    gbProviderShutdown = TRUE;

    // the queue service waits for this event when the queue. By setting 
    // this event,the thread wakes up and realises that the queue is empty and
    // hence exists since gbProviderShutdown is true
    SetEvent(gAsyncQueue.hAsyncEventsPendingEvent);

    // Wait for the queue thread to terminate.
    WaitForSingleObject(gAsyncQueue.hAsyncEventQueueServiceThread, INFINITE);


    // Free all the associated memory with the providerinfo
    MemFree((LPVOID) gszProviderInfo);

    EnterCriticalSection(&csAllPhones);

    // Free all memory associated with the phones
    for(dwPhoneCnt = 0; dwPhoneCnt < gdwNumPhones; dwPhoneCnt++)
    {   
        EnterCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        FreePhone(gpPhone[dwPhoneCnt]);
        LeaveCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);

        DeleteCriticalSection(&gpPhone[dwPhoneCnt]->csThisPhone);
        
        MemFree(gpPhone[dwPhoneCnt]);
    }

    gdwNumPhones = 0;

    LeaveCriticalSection(&csAllPhones);
    
    CloseHandle (gAsyncQueue.hAsyncEventQueueServiceThread);
    CloseHandle (gAsyncQueue.hAsyncEventsPendingEvent);

    EnterCriticalSection(&csHidList);
    CloseHidDevices();
    LeaveCriticalSection(&csHidList);
    
    LOG((PHONESP_TRACE, "Free Heap taken by phone"));
    MemFree (gpPhone);

    LOG((PHONESP_TRACE, "Free Heap taken by queue"));
    MemFree (gAsyncQueue.pAsyncRequestQueue);

#if DBG
    LOG((PHONESP_TRACE, "Dumping Memory Trace"));
    DumpMemoryList();

    DeleteCriticalSection (&csMemoryList);
#endif

    DeleteCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);
    DeleteCriticalSection (&csHidList);
    DeleteCriticalSection (&csAllPhones);

    LOG((PHONESP_TRACE, "TSPI_providerShutdown - exit"));

    LOGDEREGISTERTRACING();

    return 0;
}
/***************TSPI_providerShutdown*****************************************/



/******************************************************************************
    TSPI_providerUIIdentify:
    
    This function extracts from the TSP, the fully qualified path to load 
    the TSP's UI DLL component.

    Arguments:
        lpszUIDLLName - Pointer to a block of memory at least MAX_PATH in length, 
                        into which the TSP must copy a NULL-terminated string 
                        specifying the fully-qualified path for the DLL 
                        containing the TSP functions which must execute in the 
                        process of the calling application. 

    Return LONG:
        Returns zero if successful. 
        Shouldn't ever fail, but if it does returns one of these negative 
        error values: LINEERR_NOMEM, LINEERR_OPERATIONFAILED. 

******************************************************************************/
LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR   lpszUIDLLName
    )
{
    LOG((PHONESP_TRACE, "TSPI_providerUIIdentify - enter"));

    //
    // If we ever want to specify some other dll to handle ui, we
    // would do it here.
    //
    GetModuleFileName(ghInst,
                      lpszUIDLLName,
                      MAX_PATH);

    LOG((PHONESP_TRACE, "TSPI_providerUIIdentify - exit"));

    return 0;
}
/***********************TSPI_providerUIIdentify - end ************************/

/******************************************************************************
    TUISPI_providerInstall:

    The TSP exports this function and provides a do-nothing implementation.
    The Advanced tab of the Phone and Modem Options control panel will call
    this function when the provider is to be installed, to give the TSP a
    chance to do custom UI. There is no requirement for custom configuration
    UI. The only requirement is that the control panel be able to
    automatically install the TSP.
  
*******************************************************************************/
LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    LOG((PHONESP_TRACE, "TUISPI_providerInstall - enter"));

    // check for previous instance
    if (IsTSPAlreadyInstalled())
    {
        // cannot be installed twice
        LOG((PHONESP_TRACE, "TUISPI_providerInstall - cannot be installed twice"));
        return LINEERR_NOMULTIPLEINSTANCE;
    }

    LOG((PHONESP_TRACE, "TUISPI_providerInstall - exit"));
    return 0;
}
/***********************TUISPI_providerInstall - end ************************/

/******************************************************************************
    TUISPI_providerRemove:

    The TSP exports this function and provides a do-nothing implementation.
    The Advanced tab of the Phone and Modem Options control panel will call
    this function when the provider is to be removed, to give the TSP a
    chance to do custom UI. There is no requirement for custom configuration
    UI. The only requirement is that the control panel be able to
    automatically remove the TSP.
  
*******************************************************************************/
LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    LOG((PHONESP_TRACE, "TUISPI_providerRemove - enter"));
    LOG((PHONESP_TRACE, "TUISPI_providerRemove - exit"));    
    return 0;
}
/***********************TUISPI_providerRemove - end ************************/

//----------------------------PRIVATE FUNCTIONS-------------------------------


/******************************************************************************
    AsyncRequestQueueIn:
    
    This function adds the new incoming request from the tapisrv to the async 
    queue.

    Arguments:
       IN PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo - Pointer to the request info.

    Returns BOOL:
        TRUE if the function is successful 
        FALSE if it is not

******************************************************************************/
BOOL
AsyncRequestQueueIn (
                     PPHONESP_ASYNC_REQ_INFO pAsyncReqInfo
                     )
{

    //LOG((PHONESP_TRACE, "AsyncRequestQueueIn - enter "));

    EnterCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);

    if (gAsyncQueue.dwNumUsedQueueEntries == gAsyncQueue.dwNumTotalQueueEntries)
    {
        
        //
        // We've max'd out our ring buffer, so try to grow it
        //

        DWORD                       dwMoveSize;
        PPHONESP_ASYNC_REQ_INFO     *pNewAsyncRequestQueue;

        if ( ! ( pNewAsyncRequestQueue = 
                 MemAlloc(2 * gAsyncQueue.dwNumTotalQueueEntries 
                            * sizeof (PPHONESP_ASYNC_REQ_INFO)) ) )
        {
            LeaveCriticalSection( &gAsyncQueue.AsyncEventQueueCritSec);
            LOG((PHONESP_ERROR,"AsyncRequestQueueIn - Not enough memory to"
                               " queue request"));
            return FALSE;
        }

        dwMoveSize = (DWORD) ((gAsyncQueue.pAsyncRequestQueue +
                               gAsyncQueue.dwNumTotalQueueEntries) -
                               gAsyncQueue.pAsyncRequestQueueOut) * 
                               sizeof (PPHONESP_ASYNC_REQ_INFO);

        CopyMemory(
                   pNewAsyncRequestQueue,
                   gAsyncQueue.pAsyncRequestQueueOut,
                   dwMoveSize
                  );

        CopyMemory(
                   ((LPBYTE) pNewAsyncRequestQueue) + dwMoveSize,
                   gAsyncQueue.pAsyncRequestQueue,
                   (gAsyncQueue.pAsyncRequestQueueOut -
                   gAsyncQueue.pAsyncRequestQueue) * 
                    sizeof (PPHONESP_ASYNC_REQ_INFO)
                  );

        MemFree (gAsyncQueue.pAsyncRequestQueue);

        gAsyncQueue.pAsyncRequestQueue    =
        gAsyncQueue.pAsyncRequestQueueOut = pNewAsyncRequestQueue;
        gAsyncQueue.pAsyncRequestQueueIn = pNewAsyncRequestQueue +
                                           gAsyncQueue.dwNumTotalQueueEntries;
        gAsyncQueue.dwNumTotalQueueEntries *= 2;
    } 

    *(gAsyncQueue.pAsyncRequestQueueIn) = pAsyncReqInfo;

    gAsyncQueue.pAsyncRequestQueueIn++;

    // The queue is maintained as a circular list - if the queue in pointer
    // has reached the bottom of the queue, reset it to point it to the top
    // of the queue
    if (gAsyncQueue.pAsyncRequestQueueIn == (gAsyncQueue.pAsyncRequestQueue +
                                           gAsyncQueue.dwNumTotalQueueEntries))
    {
        gAsyncQueue.pAsyncRequestQueueIn = gAsyncQueue.pAsyncRequestQueue;
    }

    // Increment the number of outstanding requests in the queue
    gAsyncQueue.dwNumUsedQueueEntries++;

    // If this is the first request in the queue - set event to resume the 
    // thread to process the queue
    
    if (gAsyncQueue.dwNumUsedQueueEntries == 1)
    {
        SetEvent (gAsyncQueue.hAsyncEventsPendingEvent);
    }

    LeaveCriticalSection (&gAsyncQueue.AsyncEventQueueCritSec);

    //LOG((PHONESP_TRACE, "AsyncRequestQueueIn - exit"));
    return TRUE;
}
/********************AsyncRequestQueueIn - end********************************/

/******************************************************************************
    CreateButtonsAndAssignID
        
    This function creates button structures for the phone from the capability
    array. It also determines whether the phone has a keypad. It assigns IDs to
    the buttons discovered.

    Arguments:
        PPHONESP_PHONE_INFO pPhone

    Returns LONG:
    ERROR_SUCCESS if the function succeeds
    ERROR_OUTOFMEMORY if error occurs while allocating memory

******************************************************************************/

LONG
CreateButtonsAndAssignID (
                          PPHONESP_PHONE_INFO pPhone
                         )
{
    DWORD i,j, dwNextFreeID = 0;
    BOOL KEYPAD = TRUE;
    BOOL KEYPAD_ABCD = TRUE;
    PPHONESP_BUTTONINFO pButtonInfo;
    DWORD lResult = 0;

    LOG((PHONESP_TRACE, "CreateButtonsAndAssignID - enter"));

    // First determine the number of buttons available on this phone
    
    // If all the 12 basic key pad buttons are present
    // then phone has a Keypad, else all the key pad buttons are ignored
    for(i = PHONESP_PHONE_KEY_0; i <= PHONESP_PHONE_KEY_POUND; i++)
    {
        if(!pPhone->dwReportTypes[i])
        {
            KEYPAD = FALSE;
            break;
        }
    }
    
    // Also determine if phone had ABCD buttons on its keypad
    for(i = PHONESP_PHONE_KEY_A; i <= PHONESP_PHONE_KEY_D; i++)
    {
        if(!pPhone->dwReportTypes[i])
        {
            KEYPAD_ABCD = FALSE;
            break;
        }
    }
    
    if (KEYPAD)
    {   
        if (KEYPAD_ABCD)
        {
            // keypad with ABCD
            pPhone->dwNumButtons = PHONESP_NUMBER_PHONE_KEYS;
        }
        else
        {
            // basic keypad
            pPhone->dwNumButtons = 12;
        }
    }
    else
    {
        pPhone->dwNumButtons = 0;
    }

    for(i = PHONESP_NUMBER_PHONE_KEYS; i < PHONESP_NUMBER_BUTTONS; i++)
    { 
        if(pPhone->dwReportTypes[i])
        {
            pPhone->dwNumButtons++;
        }
    }

    // Allocate memory for all the buttons
  
    if ( ! (pPhone->pButtonInfo = (PPHONESP_BUTTONINFO) 
                                  MemAlloc( pPhone->dwNumButtons * 
                                            sizeof(PHONESP_BUTTONINFO)
                                           ) ) )
    {
        return ERROR_OUTOFMEMORY;
    }

    pButtonInfo = pPhone->pButtonInfo;

    // if the phone has a keypad with all the 16 buttons
    if (KEYPAD)
    { 
        LOG((PHONESP_TRACE, "Phone Has a Keypad"));

        for( i = PHONESP_PHONE_KEY_0; i <= (DWORD)(KEYPAD_ABCD ? PHONESP_PHONE_KEY_D : PHONESP_PHONE_KEY_POUND) ; i++, pButtonInfo++)
        {

            pButtonInfo->dwButtonID = i;
            pButtonInfo->dwButtonMode = PHONEBUTTONMODE_KEYPAD;
            pButtonInfo->dwButtonFunction = PHONEBUTTONFUNCTION_NONE;
            pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;
            pPhone->dwButtonIds[i] = pButtonInfo->dwButtonID;

            pButtonInfo->szButtonText = PHONESP_LoadString( 
                                                     gdwButtonText[i], 
                                                     &lResult                
                                                    );

            if(lResult != ERROR_SUCCESS)
            {
                DWORD dwCount;
    
                for(dwCount =0; dwCount < i; dwCount++)
                {
                    MemFree(pPhone->pButtonInfo->szButtonText);
                    pPhone->pButtonInfo++;
                }
                
                MemFree(pPhone->pButtonInfo);
                return lResult;
            }

            LOG((PHONESP_TRACE,"Button Found '%ws' at %d", pButtonInfo->szButtonText, i));
        }
        
        dwNextFreeID = i;
        pPhone->bKeyPad = TRUE;
    }
    else
    {
        // If phone has no keypad - the button ID for the feature buttons start
        // from 0 else they start from 16
        dwNextFreeID = 0;
    }

    // assign appropriate button ids for the feature buttons if they exist
    for (i = PHONESP_NUMBER_PHONE_KEYS, j = 0; i < PHONESP_NUMBER_BUTTONS; i++, j++)
    {
        if(pPhone->dwReportTypes[i])
        {
            pButtonInfo->dwButtonID = dwNextFreeID;
            pButtonInfo->dwButtonMode = PHONEBUTTONMODE_FEATURE;
            pButtonInfo->dwButtonFunction = gdwButtonFunction[j];
            pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;
            pPhone->dwButtonIds[i] = pButtonInfo->dwButtonID;

            pButtonInfo->szButtonText = PHONESP_LoadString( 
                                                     gdwButtonText[i], 
                                                     &lResult
                                                    );

            if(lResult != ERROR_SUCCESS)
            {
                DWORD dwCount;
                DWORD dwStartID = 0;
                
                if(KEYPAD)
                {
                    for(dwCount = PHONESP_PHONE_KEY_0; 
                        dwCount <= (DWORD)(KEYPAD_ABCD ? PHONESP_PHONE_KEY_D : PHONESP_PHONE_KEY_POUND); dwCount++)
                    {
                        MemFree(pPhone->pButtonInfo->szButtonText);
                        pPhone->pButtonInfo++;
                    }
                    dwStartID = dwCount;
                }

                for(dwCount = dwStartID; dwCount < dwNextFreeID; dwCount++)
                {
                    MemFree(pPhone->pButtonInfo->szButtonText);
                    pPhone->pButtonInfo++;
                }
                
                MemFree(pPhone->pButtonInfo);
                
                return lResult;
            }

            LOG((PHONESP_TRACE,"Button Found '%ws' at %d", pButtonInfo->szButtonText, dwNextFreeID));

            dwNextFreeID++;
            pButtonInfo++;
        }
    }

    LOG((PHONESP_TRACE, "CreateButtonsAndAssignID - exit"));
    return ERROR_SUCCESS;  
}
/********************CreateButtonsAndAssignID - end****************************/

/*****************************************************************************
    GetButtonFromID
    
    This function will retrieve the structure for the Button from it's ID

    Arguments:
        IN PPHONESP_PHONE_INFO pPhone - Pointer to the phone whose button 
                              structure has to be retrieved.
        IN DWORD dwButtonID - The Button ID


    Returns: 
        PBUTTONINFO - Pointer to the button structure if successful
        NULL        - If Button not found
******************************************************************************/
PPHONESP_BUTTONINFO
GetButtonFromID (
                 PPHONESP_PHONE_INFO pPhone,
                 DWORD               dwButtonID
                )
{
    PPHONESP_BUTTONINFO pButtonInfo; 
    DWORD i;

    // if the phone has any buttons
    if (pPhone->pButtonInfo)
    {
        pButtonInfo = pPhone->pButtonInfo;
        
        // search the list of buttons to find the button corresponding to the
        // button id provided
        for( i = 0; i < pPhone->dwNumButtons; i++)
        {
            if (pButtonInfo->dwButtonID == dwButtonID)
            {
                return pButtonInfo;
            }
            pButtonInfo++;
        }
    }

    return (PPHONESP_BUTTONINFO) NULL;
}
/*************************GetButtonFromID - end*******************************/


/******************************************************************************
    GetPhoneFromID:
    
    This function returns the structure that contains the information on the
    phone whose device ID is passed to this function.

    Arguments:
        dwDeviceID - The device ID of the phone to be retrieved
        pdwPhoneID - The to a DWORD to store the index into gpPhone,
                     this parameter can be NULL
    
    Returns PPHONESP_PHONE_INFO
        Pointer to the phone structure if successful
        NULL if phone not found

******************************************************************************/
PPHONESP_PHONE_INFO
GetPhoneFromID(
    DWORD   dwDeviceID,
    DWORD * pdwPhoneID
    )
{
    DWORD                 dwPhone;
    PPHONESP_PHONE_INFO   pPhone;

    LOG((PHONESP_TRACE, " GetPhoneFromID - enter"));

    for (dwPhone = 0; dwPhone < gdwNumPhones; dwPhone++)
    {
        pPhone = (PPHONESP_PHONE_INFO) gpPhone[ dwPhone ];

        EnterCriticalSection(&pPhone->csThisPhone);

        if ( pPhone->bAllocated )
        {
            if ( pPhone->dwDeviceID == dwDeviceID )
            {
                // check pdwPhoneID, NULL is valid if the caller doesn't
                // want us to return the phone index
                if (pdwPhoneID != NULL)
                {
                    *pdwPhoneID = dwPhone;
                }

                LeaveCriticalSection(&pPhone->csThisPhone);
                return pPhone;
            }
        }

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
 
    LOG((PHONESP_TRACE, " GetPhoneFromID - exit"));

    return NULL;
}
/*****************************GetPhoneFromID - end****************************/

/******************************************************************************
    GetPhoneFromHid:
    
    This function returns the structure that contains the information on the
    phone whose HidDevice is passed to this function.

    Arguments:
        HidDevice - Pointer to a hid device

    
    Returns PPHONESP_PHONE_INFO
        Pointer to the phone structure if successful
        NULL if phone not found

******************************************************************************/
PPHONESP_PHONE_INFO
GetPhoneFromHid (
                PHID_DEVICE HidDevice
               )
{
    DWORD                 dwPhone;
    PPHONESP_PHONE_INFO   pPhone;

    LOG((PHONESP_TRACE, " GetPhoneFromHid - enter"));

    for (dwPhone = 0; dwPhone < gdwNumPhones; dwPhone++)
    {
        pPhone = (PPHONESP_PHONE_INFO) gpPhone[ dwPhone ];

        EnterCriticalSection(&pPhone->csThisPhone);

        if ( pPhone->bAllocated )
        {
            if ( pPhone->pHidDevice == HidDevice )
            {
                LeaveCriticalSection(&pPhone->csThisPhone);
                return pPhone;
            }
        }

        LeaveCriticalSection(&pPhone->csThisPhone);
    }
 
    LOG((PHONESP_TRACE, " GetPhoneFromHid - exit"));

    return NULL;
}

/******************************************************************************
    GetButtonUsages:

    This function parses the PHIDP_BUTTON_CAPS structure to retrieve the usages
    present for the phone and records them in the capabilities array of the 
    phone structure.

    Arguments:
       PPHONESP_PHONE_INFO pPhone - The phone structure to be updated
       PHIDP_BUTTON_CAPS pButtonCaps - The Button Caps structure to be parsed
       DWORD dwNumberCaps - The number of Button Caps structure of the Report
                            Type 
       DWORD ReportType - Whether the usage within the Button Caps structure is
                          associated with an INPUT, OUTPUT or FEATURE Report.

    Returns VOID.

******************************************************************************/
VOID
GetButtonUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_BUTTON_CAPS pButtonCaps,
                DWORD dwNumberCaps,
                DWORD ReportType
                )
{
    DWORD cNumCaps;
    USAGE Usage;

    for (cNumCaps = 0; cNumCaps < dwNumberCaps; pButtonCaps++,cNumCaps++)
    {   // if the button caps structure has a list of usages
        if(pButtonCaps->IsRange)
        {
            for(Usage = (USAGE) pButtonCaps->Range.UsageMin;
                Usage <= (USAGE) pButtonCaps->Range.UsageMax; Usage++)
            {
                InitPhoneAttribFromUsage(
                                         ReportType,
                                         pButtonCaps->UsagePage,
                                         Usage,
                                         pPhone,
                                         0,
                                         0
                                        );
            }
        }
        else // if the button caps structure has a single usage
        {
            InitPhoneAttribFromUsage(
                                     ReportType, 
                                     pButtonCaps->UsagePage,
                                     pButtonCaps->NotRange.Usage, 
                                     pPhone,
                                     0,
                                     0
                                    );
        }
    }
}
/*****************************GetUsages - end********************************/

/******************************************************************************
    GetReportID

    This function returns the HidData structure that contains the usage 
    provided. The HidData structure contains the report ID for this usage

    Arguments:
        IN PHID_DEVICE  pHidDevice - the device whose usage is provided
        IN USAGE        Usage      - The usage whose report Id is to be discovered
        OUT PHID_DATA   pHidData   - If the function succeeds, this structure
                                     contains the report id for the usage, else
                                     it is NULL
    
    Returns LONG:
        ERROR_SUCCESS - if the functions succeeds
        MY_RESOURCENOTFOUND - if the usage was not found in the pHidDevice 
                              structure provided
******************************************************************************/    
LONG
GetReportID (
             IN PHID_DEVICE pHidDevice,
             IN USAGE Usage,
             OUT PHID_DATA pHidData
             )
{
    PHID_DATA pData;
    USAGE ButtonUsage;

    pData = pHidDevice->OutputData;

    while (pData)
    {
        // if the hid data structure has button data
        if (pData->IsButtonData)
        {
            for(ButtonUsage = (USAGE) pData->ButtonData.UsageMin;
                ButtonUsage <= (USAGE) pData->ButtonData.UsageMax; ButtonUsage++)
            {
                if (Usage == ButtonUsage)
                {
                    pHidData = pData;
                    return ERROR_SUCCESS;
                }
            }

        }
        else
        {   // if the hid data structure has value data
            if (Usage == pData->ValueData.Usage)
            {
                pHidData = pData;
                return ERROR_SUCCESS;
            }
        }
        pData++;
    }

    pHidData = NULL;

    return ERROR_INVALID_DATA;
}
/*************************GetReportID - end **********************************/


/******************************************************************************
    GetValueUsages:

    This function parses the PHIDP_VALUE_CAPS structure to retrieve the usages
    present for the phone and records them in the capabilities array of the 
    phone structure.

    Arguments:
       PPHONESP_PHONE_INFO pPhone  - The phone structure to be updated
       PHIDP_VALUE_CAPS pValueCaps - The Value Caps structure to be parsed
       DWORD dwNumberCaps - The number of Button Caps structure of the Report
                            Type 
       DWORD ReportType - Whether the usage within the Button Caps structure is
                          associated with an INPUT, OUTPUT or FEATURE Report.

    Returns VOID.

******************************************************************************/

VOID
GetValueUsages(
                PPHONESP_PHONE_INFO pPhone,
                PHIDP_VALUE_CAPS pValueCaps,
                DWORD dwNumberCaps,
                DWORD ReportType
               )
{
    DWORD cNumCaps;
    USAGE Usage;

    for (cNumCaps=0; cNumCaps < dwNumberCaps; pValueCaps++, cNumCaps++)
    {
        if(pValueCaps->IsRange)
        {
            for(Usage = (USAGE) pValueCaps->Range.UsageMin;
                Usage <= (USAGE) pValueCaps->Range.UsageMax; Usage++)
            {
                InitPhoneAttribFromUsage(
                                         ReportType,
                                         pValueCaps->UsagePage,
                                         Usage,
                                         pPhone,
                                         pValueCaps->LogicalMin,
                                         pValueCaps->LogicalMax
                                        );
            }
        }
        else
        {    
            InitPhoneAttribFromUsage(
                                     ReportType, 
                                     pValueCaps->UsagePage,
                                     pValueCaps->NotRange.Usage, 
                                     pPhone,
                                     pValueCaps->LogicalMin,
                                     pValueCaps->LogicalMax
                                    );
        }
    
    }
}
/**********************GetValueUsages - end***********************************/

/******************************************************************************
    InitPhoneAttribFromUsages:

    This function is called by providerInit to determine the capabilities of 
    the device 
   
    Arguments:
        IN DWORD ReportType - Whether the usage is a input/feature/output
        IN USAGE Usage      - A Usage of the device  
        IN OUT PPHONESP_PHONE_INFO pPhone - The pointer to the phone whose 
                                  capabilities are being determined.

    Returns VOID
 
******************************************************************************/
VOID 
InitPhoneAttribFromUsage (
                          DWORD ReportType,
                          USAGE UsagePage,
                          USAGE Usage,
                          PPHONESP_PHONE_INFO pPhone,
                          LONG Min,
                          LONG Max
                          )
{

    PPHONESP_BUTTONINFO pButtonInfo;

    //LOG((PHONESP_TRACE, "InitPhoneAttribFromUsage - enter"));

    switch (UsagePage)
    {
    case HID_USAGE_PAGE_TELEPHONY:
        {
            switch (Usage)
            {        
            case HID_USAGE_TELEPHONY_HOOKSWITCH:
                pPhone->dwHandset |= ReportType;
                pPhone->dwHookSwitchDevs |= PHONEHOOKSWITCHDEV_HANDSET;                 
                pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;  //Assume handset is on hook

                LOG((PHONESP_TRACE,"HOOKSWITCH USAGE, ReportType 0x%04x", ReportType));
                break;

            case HID_USAGE_TELEPHONY_RINGER:
                pPhone->dwRing |= ReportType;
                pPhone->dwRingMode = 0;  //Assume the phone is not ringing 

                LOG((PHONESP_TRACE,"RINGER USAGE, ReportType: %d", ReportType));
                break;

            case HID_USAGE_TELEPHONY_SPEAKER_PHONE:
                pPhone->dwSpeaker |= ReportType;
                pPhone->dwHookSwitchDevs |= PHONEHOOKSWITCHDEV_SPEAKER;  
                pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK; //Assume speaker is on hook
                LOG((PHONESP_TRACE,"SPEAKERPHONE USAGE, ReportType 0x%04x", ReportType));
                break;


            default:
                // Key Pad buttons
                if ( (Usage >= HID_USAGE_TELEPHONY_PHONE_KEY_0) && 
                     (Usage <= HID_USAGE_TELEPHONY_PHONE_KEY_D) )
                {
                    pPhone->dwReportTypes[Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0] |= ReportType;
                    LOG((PHONESP_TRACE,"PHONE_KEY_%d USAGE, ReportType 0x%04x",
                                Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0, ReportType));
                }
                else
                {  // Feature Buttons
                    DWORD Index;
                    if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
                    {
                        pPhone->dwReportTypes[Index] |= ReportType;
                        LOG((PHONESP_TRACE,"PHONE USAGE: 0x%04x, ReportType 0x%04x", 
                                            Usage, ReportType));
                    }
                    else
                    {
                        LOG((PHONESP_TRACE, "Unsupported PHONE USAGE: 0x%04x", Usage ));
                    } 

                }
                break;
            }
        }
        
    case HID_USAGE_PAGE_CONSUMER:
        {
            switch (Usage)
            {
            case HID_USAGE_CONSUMER_VOLUME:
                if ((Min == -1) && (Max == 1))
                {
                    // Phone has volume controls
                    pPhone->dwReportTypes[PHONESP_FEATURE_VOLUMEUP] |= ReportType;
                    pPhone->dwReportTypes[PHONESP_FEATURE_VOLUMEDOWN] |= ReportType;
                    pPhone->dwVolume |= ReportType;
                    LOG((PHONESP_TRACE,"VOLUME USAGE, ReportType 0x%04x", ReportType));
                }
                break;          
            }
        }
    }

    //LOG((PHONESP_TRACE, "InitPhoneAttribFromUsage - exit"));
}

/**************************InitPhoneAttribFromUsage - end ********************/

/******************************************************************************
    InitUsage

    This function takes the usage retrieved in the input report and updates the
    device status and sends an appropriate Phone event

    Arguments:
        PPHONESP_PHONE_INFO pPhone - Pointer to phone whose input report is 
                                     received
        USAGE               Usage  - The usage whose value is recieved
        BOOL                bON    - The status of the usage Received

    Returns VOID
******************************************************************************/

VOID
InitUsage (
           PPHONESP_PHONE_INFO pPhone,
           USAGE     Usage,
           BOOL      bON
          )
{
   
    DWORD Index;
    DWORD dwMode;

    LOG((PHONESP_TRACE, "InitUsage - enter"));

    switch (Usage)
    {
       case HID_USAGE_TELEPHONY_HOOKSWITCH:
        if (bON)
        {
            LOG((PHONESP_TRACE, "HANDSET OFFHOOK"));
            pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;
        }
        else
        {
            LOG((PHONESP_TRACE, "HANDSET ONHOOK"));
            pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;
        }
        break;

    case HID_USAGE_TELEPHONY_SPEAKER_PHONE:
        if (bON == TRUE)
        {
            pPhone->bSpeakerHookSwitchButton = TRUE;
        }
        else
        {
            pPhone->bSpeakerHookSwitchButton = FALSE;
        }
        break;
   
    default:
        // Feature & Phone Key Buttons

        // Find the index of the usage
        if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
        {
            PPHONESP_BUTTONINFO pButtonInfo;

            //
            // The index retrieved when indexed in the dwButtonIds array of the 
            // phone structure gives the Button ID. With this ID get the Button 
            // Info for that button id
            //
            pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Index]);
        
            if(pButtonInfo != NULL)
            {
                if(bON == TRUE)
                {
                    // This feature button is currently on
                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText ));
                    pButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;
                }
                else
                {
                    // This feature button is currently off
                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText ));
                    pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;
                }
            }                    

        }
        break;
    }

    LOG((PHONESP_TRACE, "InitUsage - exit"));

}
/*************************InitUsage - end*************************************/

/******************************************************************************
    LookupIndexForUsage

    This function retrieves the index of the usage provided. Only the Feature 
    Button usages are present in this Lookup Table. Therefore only the index
    for the feature buttons can be retrieved.

    Arguments:
        DWORD   Usage - THe usage whose index is to be retrieved
        DWORD  *Index - The Index of the Usage retrieved

    Returns LONG:
        ERROR_SUCCESS - if the usage was found in the table
        ERROR_INVALID_DATA - if the usage was not found in the Lookup Table

******************************************************************************/
LONG
LookupIndexForUsage(
                    IN  DWORD  Usage,
                    OUT DWORD  *Index
                    )
{ 
    DWORD cnt;

    for(cnt = 0; cnt < PHONESP_NUMBER_FEATURE_BUTTONS; cnt++)
    {
        if(gdwLookupFeatureIndex[cnt].Usage == Usage)
        {
           *Index = gdwLookupFeatureIndex[cnt].Index;
           return ERROR_SUCCESS;
        }
    }
    return ERROR_INVALID_DATA;
}
/***************LookupIndexForUsage - end*************************************/

/******************************************************************************
    PHONESP_LoadString:
       
    This function loads the string from the String Table.


    Arguments:
        IN UINT ResourceID - Specifies the integer identifier of the string to 
                             be loaded from the resource table
        OUT WCHAR *szBuffer- The pointer to the Buffer that contains the string

    Returns LONG
    ERROR_SUCCESS if operation successful else 
    MY_NOMEM if operation failed because of not enough memory. 
    MY_RESOURCENOTFOUND - if the resource was not found in the string table
******************************************************************************/

LPWSTR
PHONESP_LoadString(
             IN UINT ResourceID,
             PLONG lResult
            )

{
    DWORD dwNumBytes;
    DWORD dwNumChars;
    DWORD dwBufferChars = 100;

    WCHAR *wszBuffer; 
    WCHAR *szBuffer;   

    while (1)
    {
        if (! ( wszBuffer = (WCHAR *) MemAlloc(dwBufferChars * sizeof(WCHAR))))
        {
            LOG((PHONESP_ERROR,"PHONESP_LoadString - Not enough Memory"));
            *lResult = ERROR_OUTOFMEMORY;
            return (LPWSTR) NULL;
        }
        
        // load string into buffer
        dwNumChars = LoadString(
                            ghInst,
                            ResourceID,
                            wszBuffer,
                            dwBufferChars
                           );

        if( dwNumChars < dwBufferChars)
        {
            break;
        }

        // LoadString returns 0 in the dwNumChars if string resource does not exist
        if (dwNumChars == 0)
        { 
            MemFree(wszBuffer);
            *lResult = ERROR_INVALID_DATA;
            return (LPWSTR) NULL;
        }
        
        dwBufferChars *= 2;
        MemFree(wszBuffer);
    }
              
    // determine memory needed
    dwNumBytes = (dwNumChars + 1) * sizeof(WCHAR);

    // allocate memory for unicode string
    if ( ! ( szBuffer = (WCHAR *) MemAlloc(dwNumBytes) ) )
    {
        MemFree(wszBuffer);
        LOG((PHONESP_ERROR,"PHONESP_LoadString - Not enough Memory"));
        *lResult = ERROR_OUTOFMEMORY;
        return (LPWSTR) NULL;
    }
   
    // copy loaded string into buffer
    CopyMemory (
                szBuffer,
                wszBuffer,
                dwNumBytes
               );
  
    MemFree(wszBuffer);
    *lResult = ERROR_SUCCESS;

    return (LPWSTR) szBuffer;
}
/*******************MyLoadString - end ***************************************/



/******************************************************************************
    ReportUsage

    This function takes the usage retrieved in the input report and updates the
    device status and sends an appropriate Phone event

    Arguments:
        PPHONESP_PHONE_INFO pPhone - Pointer to phone whose input report is 
                                     received
        USAGE               Usage  - The usage whose value is recieved
        BOOL                bON    - The status of the usage Received

    Returns VOID
******************************************************************************/

VOID
ReportUsage (
              PPHONESP_PHONE_INFO pPhone,
              USAGE     UsagePage,
              USAGE     Usage,
              ULONG     Value
            )
{
   
    DWORD Index;

    //LOG((PHONESP_TRACE, "ReportUsage - enter"));

    EnterCriticalSection(&csAllPhones);
    
    if ( ! ( pPhone && pPhone->htPhone ) )
    { 
        LeaveCriticalSection(&csAllPhones);
        return; // exception handling
    }
    
    EnterCriticalSection(&pPhone->csThisPhone);
    LeaveCriticalSection(&csAllPhones);

    switch (UsagePage)
    {
    case HID_USAGE_PAGE_TELEPHONY:
        {
            switch (Usage)
            {
            case HID_USAGE_TELEPHONY_HOOKSWITCH:
                if (Value == TRUE)
                {
                    if (pPhone->dwHandsetHookSwitchMode != PHONEHOOKSWITCHMODE_MICSPEAKER)
                    {
                        LOG((PHONESP_TRACE, "HANDSET OFFHOOK "));
                        pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;

                        SendPhoneEvent(
                               pPhone, 
                               PHONE_STATE, 
                               PHONESTATE_HANDSETHOOKSWITCH, 
                               PHONEHOOKSWITCHMODE_MICSPEAKER,
                               0
                              );
                    }
                }
                else
                {
                    if (pPhone->dwHandsetHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK)
                    {
                        LOG((PHONESP_TRACE, "HANDSET ONHOOK"));
                        pPhone->dwHandsetHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;

                        SendPhoneEvent(
                               pPhone, 
                               PHONE_STATE, 
                               PHONESTATE_HANDSETHOOKSWITCH, 
                               PHONEHOOKSWITCHMODE_ONHOOK,
                               0
                              );
                    }
                }
                break;

            case HID_USAGE_TELEPHONY_SPEAKER_PHONE:
                if (Value == TRUE)
                {
                    if (pPhone->bSpeakerHookSwitchButton == FALSE)
                    {
                        pPhone->bSpeakerHookSwitchButton = TRUE;

                        if (pPhone->dwSpeakerHookSwitchMode != PHONEHOOKSWITCHMODE_ONHOOK)
                        {
                            LOG((PHONESP_TRACE, "SPEAKER ONHOOK"));
                            pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_ONHOOK;

                            SendPhoneEvent(
                                       pPhone, 
                                       PHONE_STATE, 
                                       PHONESTATE_SPEAKERHOOKSWITCH, 
                                       PHONEHOOKSWITCHMODE_ONHOOK,
                                       0
                                      );
                        }
                        else
                        {
                            LOG((PHONESP_TRACE, "SPEAKER OFFHOOK "));
                            pPhone->dwSpeakerHookSwitchMode = PHONEHOOKSWITCHMODE_MICSPEAKER;

                            SendPhoneEvent(
                                       pPhone, 
                                       PHONE_STATE, 
                                       PHONESTATE_SPEAKERHOOKSWITCH, 
                                       PHONEHOOKSWITCHMODE_MICSPEAKER,
                                       0
                                      );
                        }
                    }
                }
                else
                {
                    pPhone->bSpeakerHookSwitchButton = FALSE;
                }        
                break;
   
                // Feature Buttons with on-off control
            case HID_USAGE_TELEPHONY_HOLD:
            case HID_USAGE_TELEPHONY_PARK:
            case HID_USAGE_TELEPHONY_FORWARD_CALLS:
            case HID_USAGE_TELEPHONY_CONFERENCE:
            case HID_USAGE_TELEPHONY_PHONE_MUTE:
            case HID_USAGE_TELEPHONY_DONOTDISTURB:
            case HID_USAGE_TELEPHONY_SEND:
        
                if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
                {
                    PPHONESP_BUTTONINFO pButtonInfo;

                    pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Index]);

                    if (pButtonInfo != NULL)
                    {
                        if (Value == TRUE)
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText));
                                pButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                SendPhoneEvent(
                                               pPhone, 
                                               PHONE_BUTTON, 
                                               pPhone->dwButtonIds[Index], 
                                               PHONEBUTTONMODE_FEATURE,
                                               PHONEBUTTONSTATE_DOWN
                                              );
                            }
                        }
                        else
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText));
                                pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                SendPhoneEvent(
                                               pPhone, 
                                               PHONE_BUTTON, 
                                               pPhone->dwButtonIds[Index], 
                                               PHONEBUTTONMODE_FEATURE,
                                               PHONEBUTTONSTATE_UP
                                              );
                            }
                        }
                    }                                           
                }
                break;

            default:
        
                // Key Pad buttons
                if ( (pPhone->bKeyPad) &&
                     (Usage >= HID_USAGE_TELEPHONY_PHONE_KEY_0) &&
                     (Usage <= HID_USAGE_TELEPHONY_PHONE_KEY_D) )
                {
                    PPHONESP_BUTTONINFO pButtonInfo;
        
                    pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0]);

                    if (pButtonInfo != NULL)
                    {
                        if (Value == TRUE)
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                            {
                                if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText));
                                    pButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0, 
                                                   PHONEBUTTONMODE_KEYPAD,
                                                   PHONEBUTTONSTATE_DOWN
                                                  );
                                }
                            }
                        }
                        else
                        {
                            if (pButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText));
                                pButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                SendPhoneEvent(
                                               pPhone, 
                                               PHONE_BUTTON, 
                                               Usage - HID_USAGE_TELEPHONY_PHONE_KEY_0,
                                               PHONEBUTTONMODE_KEYPAD,
                                               PHONEBUTTONSTATE_UP
                                              );
                            }
                        }
                    }
                }
                else
                {   // Feature Buttons - with one-shot control
                    if (LookupIndexForUsage(Usage, &Index) == ERROR_SUCCESS)
                    {
                        if (Value == TRUE)
                        {
                            PPHONESP_BUTTONINFO pButtonInfo;
        
                            pButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[Index]);

                            if ( pButtonInfo != NULL )
                            {
                                LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pButtonInfo->szButtonText));

                                SendPhoneEvent(
                                       pPhone, 
                                       PHONE_BUTTON, 
                                       pPhone->dwButtonIds[Index], 
                                       PHONEBUTTONMODE_FEATURE,
                                       PHONEBUTTONSTATE_DOWN
                                      );

                                LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pButtonInfo->szButtonText));

                                SendPhoneEvent(
                                       pPhone, 
                                       PHONE_BUTTON, 
                                       pPhone->dwButtonIds[Index], 
                                       PHONEBUTTONMODE_FEATURE,
                                       PHONEBUTTONSTATE_UP
                                      );
                            }
                        }
                    }
                    else
                    {
                        LOG((PHONESP_TRACE, "Unsupported PHONE USAGE: 0x%04x",Usage));
                    }
                }
                break;
            }
        }
        break;

    case HID_USAGE_PAGE_CONSUMER:
        {
            switch (Usage)
            {
            case HID_USAGE_CONSUMER_VOLUME:
                {
                    if (pPhone->dwVolume)
                    {
                        PPHONESP_BUTTONINFO pUpButtonInfo;
                        PPHONESP_BUTTONINFO pDownButtonInfo;

                        pUpButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP]);
                        pDownButtonInfo = GetButtonFromID(pPhone,pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN]);

                        if ((pUpButtonInfo != NULL) && (pDownButtonInfo != NULL))
                        {
                            switch (Value) // 2-bit signed
                            {
                            case 0x0:
                                if (pUpButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pUpButtonInfo->szButtonText));
                                    pUpButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }

                                if (pDownButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pDownButtonInfo->szButtonText));
                                    pDownButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }
                                break;
                            case 0x1:
                                if (pUpButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pUpButtonInfo->szButtonText));
                                    pUpButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_DOWN
                                                  );
                                }

                                if (pDownButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pDownButtonInfo->szButtonText));
                                    pDownButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }
                                break;
                            case 0x3:
                                if (pUpButtonInfo->dwButtonState != PHONEBUTTONSTATE_UP)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' UP", pUpButtonInfo->szButtonText));
                                    pUpButtonInfo->dwButtonState = PHONEBUTTONSTATE_UP;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEUP],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_UP
                                                  );
                                }

                                if (pDownButtonInfo->dwButtonState != PHONEBUTTONSTATE_DOWN)
                                {
                                    LOG((PHONESP_TRACE, "BUTTON '%ws' DOWN", pDownButtonInfo->szButtonText));
                                    pDownButtonInfo->dwButtonState = PHONEBUTTONSTATE_DOWN;

                                    SendPhoneEvent(
                                                   pPhone, 
                                                   PHONE_BUTTON, 
                                                   pPhone->dwButtonIds[PHONESP_FEATURE_VOLUMEDOWN],
                                                   PHONEBUTTONMODE_FEATURE,
                                                   PHONEBUTTONSTATE_DOWN
                                                  );
                                }
                                break;
                            }                        
                        }
                        break;
                    }
                }
            }
        }
        break;
    }

    LeaveCriticalSection(&pPhone->csThisPhone);

    //LOG((PHONESP_TRACE, "ReportUsage - exit"));

}
/**********************ReportUsage - end**************************************/


/******************************************************************************
    SendPhoneEvent:

    This function determines whether TAPI had requested the receipt of this 
    message and if requested, then sends the phone device message .

    Arguments:
        PMYPHONE pPhone  -  The pointer to the phone 
        DWORD     dwMsg   -  Type of Phone Event such as PHONE_BUTTON, etc
        ULONG_PTR Param1  -  Details relating to the Phone Event 
        ULONG_PTR Param2  -         "
        ULONG_PTR Param3  -         "

    Returns VOID

******************************************************************************/
VOID
SendPhoneEvent(
               PPHONESP_PHONE_INFO   pPhone,
               DWORD                 dwMsg,
               ULONG_PTR             Param1,
               ULONG_PTR             Param2,
               ULONG_PTR             Param3
              )
{
    LOG((PHONESP_TRACE, "SendPhoneEvent - enter"));

    switch (dwMsg)
    {
    case PHONE_BUTTON:
        
        if ( ((Param2) & pPhone->dwButtonModesMsgs ) && 
             ((Param3) & pPhone->dwButtonStateMsgs) )
        {
            (*(pPhone->lpfnPhoneEventProc))(
                                     pPhone->htPhone,
                                     dwMsg,
                                     Param1,
                                     Param2,
                                     Param3
                                    );
        }
        break;

    case PHONE_REMOVE:
        (*(glpfnPhoneCreateProc))(
                                 0,
                                 dwMsg,
                                 Param1,
                                 Param2,
                                 Param3
                                );
        break;

    case PHONE_CREATE:
        (*(glpfnPhoneCreateProc))(
                                 0,
                                 dwMsg,
                                 Param1,
                                 Param2,
                                 Param3
                                );
    
        break;

    case PHONE_STATE:
        if (Param1 & pPhone->dwPhoneStateMsgs)
        {
            (*(pPhone->lpfnPhoneEventProc))(
                                     pPhone->htPhone,
                                     dwMsg,
                                     Param1,
                                     Param2,
                                     Param3
                                    );
        }
        break;

    default:
        break;
    }

    LOG((PHONESP_TRACE, "SendPhoneEvent - exit"));
}
/****************************SendPhoneEvent - end*****************************/

/******************************************************************************
    SendOutputReport

    This function forms an output report for the usage provided and sends it to
    the device

    Arguments:
        PHID_DEVICE pHidDevice - The hid device to which the output report is 
                                 be sent
        USAGE       Usage      - The Usage for which the output report is to be
                                 sent
        BOOL        bSet       - Whether the usage has to be set or reset

    Returns LONG:
        ERROR_SUCCESS if the function succeeded
        ERROR_INVALID_DATA on error       

******************************************************************************/

LONG
SendOutputReport(
                 PHID_DEVICE pHidDevice,
                 USAGE       Usage,
                 BOOL        bSet
                )
{
    HID_DATA  HidData;
    PUSAGE UsageList = &Usage;
    LONG NumUsages = 1;
    
    if ( GetReportID(pHidDevice, Usage, &HidData) == ERROR_SUCCESS)
    {
        NTSTATUS Result;

        memset ( pHidDevice->OutputReportBuffer, 
                (UCHAR) 0, 
                pHidDevice->Caps.OutputReportByteLength
                );

        if (HidData.IsButtonData)
        {
            if (bSet)
            {
                Result = HidP_SetUsages (
                                         HidP_Output,
                                         HidData.UsagePage,
                                         0,
                                         UsageList,
                                         &NumUsages,
                                         pHidDevice->Ppd,
                                         pHidDevice->OutputReportBuffer,
                                         pHidDevice->Caps.OutputReportByteLength
                                        );
                
                if(Result != HIDP_STATUS_SUCCESS)
                {
                    return ERROR_INVALID_DATA;
                }
            }
            else
            {               
                Result = HidP_UnsetUsages (
                                HidP_Output,
                                HidData.UsagePage,
                                0,
                                UsageList,
                                &NumUsages,
                                pHidDevice->Ppd,
                                pHidDevice->OutputReportBuffer,
                                pHidDevice->Caps.OutputReportByteLength
                                );
                if(Result != HIDP_STATUS_SUCCESS)
                {
                    return ERROR_INVALID_DATA;
                }

            }
       }
       else
       {
            Result = HidP_SetUsageValue (
                                HidP_Output,
                                HidData.UsagePage,
                                0,
                                Usage,
                                HidData.ValueData.Value,
                                pHidDevice->Ppd,
                                pHidDevice->OutputReportBuffer,
                                pHidDevice->Caps.OutputReportByteLength
                            );
            if(Result != HIDP_STATUS_SUCCESS)
            {
                return ERROR_INVALID_DATA;
            }
            
        }
       
        Write(pHidDevice);
    }
    else
    {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}
/************************SendOutputReport - end*******************************/


/******************************************************************************
    ShowData

    This function is called by the queue service thread when the request queued
    is an input report. This function retrieves the Usages present in this 
    structure and passes them on to ReportUsage which performs appropriate 
    actions.

******************************************************************************/
VOID 
CALLBACK
ShowData(
         PPHONESP_FUNC_INFO pAsyncFuncInfo 
        )
{

    PPHONESP_PHONE_INFO pPhone = (PPHONESP_PHONE_INFO) pAsyncFuncInfo->dwParam1;    
    BOOL bButton;

    if( (DWORD) pAsyncFuncInfo->dwParam2 == PHONESP_BUTTON)
    {
        USAGE  UsagePage = (USAGE) pAsyncFuncInfo->dwParam3;
        USAGE  UsageMin = (USAGE) pAsyncFuncInfo->dwParam4;
        USAGE  UsageMax = (USAGE) pAsyncFuncInfo->dwParam5;
        DWORD  MaxUsageLength = (DWORD) pAsyncFuncInfo->dwParam6;
        PUSAGE Usages = (PUSAGE) pAsyncFuncInfo->dwParam7;
        USAGE  Usage;

        for ( Usage = UsageMin; Usage <= UsageMax; Usage++ )
        {
            DWORD i;

            for ( i = 0; i < MaxUsageLength; i++ )
            {
                 if ( Usage == Usages[i] )
                 {
                     //LOG((PHONESP_TRACE,"ShowData - UsagePage 0x%04x Usage 0x%04x BUTTON DOWN", UsagePage, Usage));
                     ReportUsage(pPhone, UsagePage, Usage, TRUE); 
                     break;
                 }
            }

            if ( i == MaxUsageLength )
            {
                //LOG((PHONESP_TRACE,"ShowData - UsagePage 0x%04x Usage 0x%04x BUTTON UP", UsagePage, Usage));
                ReportUsage(pPhone, UsagePage, Usage, FALSE);
            }
        }
        MemFree(Usages);
    }
    else
    {
        USAGE UsagePage = (USAGE) pAsyncFuncInfo->dwParam3;
        USAGE Usage = (USAGE) pAsyncFuncInfo->dwParam4;
        ULONG Value = (ULONG) pAsyncFuncInfo->dwParam5;

        //LOG((PHONESP_TRACE,"ShowData - UsagePage 0x%04x Usage 0x%04x VALUE %d", UsagePage, Usage, Value));
        ReportUsage(pPhone, UsagePage, Usage, Value);
    }
}
/*******************ShowData - end********************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\mymem.c ===
/* Copyright (c) 1999  Microsoft Corporation */

#include "mymem.h"
#include "mylog.h"

extern PPHONESP_MEMINFO      gpMemFirst, gpMemLast;
extern CRITICAL_SECTION      csMemoryList;
extern BOOL                  gbBreakOnLeak;
extern HANDLE                ghHeap;

#if DBG

LPVOID
WINAPI
MemAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
{
    //
    // Alloc 16 extra bytes so we can make sure the pointer we pass back
    // is 64-bit aligned & have space to store the original pointer
    //
    PPHONESP_MEMINFO       pHold;
    PDWORD_PTR       pAligned;
    PBYTE            p;


    p = (LPBYTE)HeapAlloc(ghHeap, HEAP_ZERO_MEMORY, dwSize + sizeof(PHONESP_MEMINFO) + 16);

    if (p == NULL)
    {
        return NULL;
    }

    // note note note - this only works because mymeminfo is
    // a 16 bit multiple in size.  if it wasn't, this
    // align stuff would cause problems.
    pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
    
    *pAligned = (DWORD_PTR) p;
    pHold = (PPHONESP_MEMINFO)((DWORD_PTR)pAligned + 8);
    
    
    pHold->dwSize = dwSize;
    pHold->dwLine = dwLine;
    pHold->pszFile = pszFile;

    EnterCriticalSection(&csMemoryList);

    if (gpMemLast != NULL)
    {
        gpMemLast->pNext = pHold;
        pHold->pPrev = gpMemLast;
        gpMemLast = pHold;
    }
    else
    {
        gpMemFirst = gpMemLast = pHold;
    }

    LeaveCriticalSection(&csMemoryList);
    

    return (LPVOID)(pHold + 1);
}

#else

LPVOID
WINAPI
MemAllocReal(
    DWORD   dwSize
    )
{
    PDWORD_PTR       pAligned;
    PBYTE            p;

    if (p = (LPBYTE)HeapAlloc(ghHeap, HEAP_ZERO_MEMORY, dwSize + 16))
    {
        pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
        *pAligned = (DWORD_PTR) p;
        pAligned = (PDWORD_PTR)((DWORD_PTR)pAligned + 8);
    }
    else
    {
        pAligned = NULL;
    }

    return ((LPVOID) pAligned);
}

#endif

VOID
WINAPI
MemFree(
    LPVOID  p
    )
{       
    LPVOID  pOrig;

    if (p == NULL)
    {
        return;
    }

#if DBG

    {
        PPHONESP_MEMINFO    pHold;

        pHold = (PPHONESP_MEMINFO)(((LPBYTE)p) - sizeof(PHONESP_MEMINFO));

        EnterCriticalSection(&csMemoryList);

        if (pHold->pPrev)
        {
            pHold->pPrev->pNext = pHold->pNext;
        }
        else
        {
            gpMemFirst = pHold->pNext;
        }

        if (pHold->pNext)
        {
            pHold->pNext->pPrev = pHold->pPrev;
        }
        else
        {
            gpMemLast = pHold->pPrev;
        }

        LeaveCriticalSection(&csMemoryList);

        pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)pHold - 8));
    }

#else
    
    pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)p - 8));

#endif

    HeapFree(ghHeap,0, pOrig);

    return;
}

#if DBG

void
DumpMemoryList()
{

    PPHONESP_MEMINFO       pHold;

    if (gpMemFirst == NULL)
    {
        LOG((PHONESP_TRACE, "DumpMemoryList: All memory deallocated"));
        return;
    }

    pHold = gpMemFirst;

    while (pHold)
    {
       LOG((PHONESP_ERROR, "DumpMemoryList: %lx not freed - LINE %d FILE %s!", pHold+1, pHold->dwLine, pHold->pszFile));
       pHold = pHold->pNext;
    }

    if (gbBreakOnLeak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\mylog.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mylog.c

Abstract:

    This module contains the debugging support.

Author:
    
    Mu Han (muhan)   26-March-1997

--*/

#ifdef PHONESPLOG

#include <windows.h>

#include <stdio.h>
#include "mylog.h"

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwTracingToConsole  = 0;
static DWORD   sg_dwTracingToFile     = 0;
static DWORD   sg_dwDebuggerMask      = 0;

/*++

Routine Description:

    Registers for tracing on a debugger if it is enabled in the registry.
    This may be called from DllMain().

Arguments:

    szName   - Component name for use in the tracing

Return Value:

    BOOL

--*/
BOOL NTAPI LogRegisterDebugger(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    return TRUE;
}

/*++

Routine Description:

    Registers for tracing using the Tracing API.
    This is NOT safe to be called from DllMain().

Arguments:

    szName   - Component name for use in the tracing

Return Value:

    BOOL

--*/
BOOL NTAPI LogRegisterTracing(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";

    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

/*++

Routine Description:

    DeRegisters for tracing on a debugger.
    This may be called from DllMain().

--*/
void NTAPI LogDeRegisterDebugger()
{
    sg_dwTracingToDebugger = 0;
}

/*++

Routine Description:

    DeRegisters for tracing using the Tracing API.
    This is NOT safe to be called from DllMain().

--*/
void NTAPI LogDeRegisterTracing()
{
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}

/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
void NTAPI LogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{

    static char * message[24] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    SYSTEMTIME SystemTime;
    va_list ap;
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case PHONESP_ERROR: dwIndex = 0; break;
        case PHONESP_WARN:  dwIndex = 1; break;
        case PHONESP_INFO:  dwIndex = 2; break;
        case PHONESP_TRACE: dwIndex = 3; break;
        case PHONESP_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        // retrieve local time
     
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

       
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        if ( ( sg_dwTracingToConsole > 0 ) || ( sg_dwTracingToFile > 0 ) )
        {
            switch(dwDbgLevel)
            {
            case PHONESP_ERROR: dwIndex = 0; break;
            case PHONESP_WARN:  dwIndex = 1; break;
            case PHONESP_INFO:  dwIndex = 2; break;
            case PHONESP_TRACE: dwIndex = 3; break;
            case PHONESP_EVENT: dwIndex = 4; break;
            default:        dwIndex = 5; break;
            }

            wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        
            va_start(arglist, lpszFormat);
            TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
            va_end(arglist);
        }
    }
}

#endif // PHONESPLOG

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\mymem.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#ifndef _MYMEM_H
#define _MYMEM_H

#include <windows.h>
#include <winbase.h>
#include <setupapi.h>
#include <TCHAR.h>

typedef struct _PHONESP_MEMINFO
{
    struct _PHONESP_MEMINFO * pNext;
    struct _PHONESP_MEMINFO * pPrev;
    DWORD               dwSize;
    DWORD               dwLine;
    PSTR                pszFile;
    DWORD               dwAlign;
} PHONESP_MEMINFO, *PPHONESP_MEMINFO;

#if DBG

    #define MemAlloc( __size__ ) MemAllocReal( __size__, __LINE__, __FILE__ )

    LPVOID
    WINAPI
    MemAllocReal(
             DWORD   dwSize,
             DWORD   dwLine,
             PSTR    pszFile
            );

    VOID
    DumpMemoryList();

#else

    #define MemAlloc( __size__ ) MemAllocReal( __size__ )

    LPVOID
    WINAPI
    MemAllocReal(
            DWORD   dwSize
            );

#endif

VOID
WINAPI
MemFree(
     LPVOID  p
     );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\pnp.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <setupapi.h>
#include "hidsdi.h"
#include "hid.h"
#include "mylog.h"
#include "mymem.h"

PHID_DEVICE     gpHidDevices = NULL; 

LONG
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInterfaceData,
    IN OUT   PHID_DEVICE                 HidDevice
    );

VOID
CloseHidDevice (
    IN OUT   PHID_DEVICE                 HidDevice
    );

VOID
AddHidDevice (
              IN PHID_DEVICE HidDevice
             );

VOID
RemoveHidDevice (
                 IN PHID_DEVICE HidDevice
                );

PHID_DEVICE
FindHidDeviceByDevInst (
                        IN DWORD DevInst
                       );

LONG
FindKnownHidDevices (
   OUT PHID_DEVICE   *pHidDevices,
   OUT PULONG        pNumberHidDevices
   )
/*++
Routine Description:
   Do the required PnP things in order to find all the HID devices in
   the system at this time.
--*/
{
    HDEVINFO                  hardwareDeviceInfo;
    SP_DEVICE_INTERFACE_DATA  hidDeviceInterfaceData;
    SP_DEVINFO_DATA hidDeviceInfoData;
    ULONG                     i;
    PHID_DEVICE               hidDevice;
    GUID                      hidGuid;
    LONG                      lResult;

    LOG((PHONESP_TRACE, "FindKnownHidDevices - enter"));

    HidD_GetHidGuid (&hidGuid);

    *pHidDevices = NULL;
    *pNumberHidDevices = 0;

    //
    // Open a handle to the dev info list
    //
    hardwareDeviceInfo = SetupDiGetClassDevs (
                                               &hidGuid,
                                               NULL, // Define no enumerator (global)
                                               NULL, // Define no
                                               (DIGCF_PRESENT | // Only Devices present
                                                DIGCF_INTERFACEDEVICE)); // Function class devices.
  
    if(hardwareDeviceInfo == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    //
    // Mark all existing hid devices as removed. Any of these that are still present
    // will have this mark removed during enumeration below.
    //
    hidDevice = gpHidDevices;

    while (hidDevice != NULL)
    {
        //
        // Include existing devices in out count of hid devices
        //
        (*pNumberHidDevices)++;

        hidDevice->bRemoved = TRUE;
        hidDevice = hidDevice->Next;
    }

    i = 0;

    hidDeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    while (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                        0, // No care about specific PDOs
                                        &hidGuid,
                                        i++,
                                        &hidDeviceInterfaceData)) 
    {
        //
        // We enumerated a hid device, first lets get the device instance
        //      

        hidDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (SetupDiGetDeviceInterfaceDetail(hardwareDeviceInfo,
                                           &hidDeviceInterfaceData,
                                           NULL,
                                           0,
                                           NULL,
                                           &hidDeviceInfoData)
             // ERROR_INSUFFICIENT_BUFFER is alright because we passed in NULL
             // for the device interface detail data structure.
             || (GetLastError() == ERROR_INSUFFICIENT_BUFFER) )  
        {  
            LOG((PHONESP_TRACE, "FindKnownHidDevices - device instance %08x", hidDeviceInfoData.DevInst )); 
          
            //
            // Check that the hid device is not already in our list
            //

            if ((hidDevice = FindHidDeviceByDevInst(hidDeviceInfoData.DevInst)) == NULL)
            {
                //
                // This is a new hid device
                //
                // Allocate a HID_DEVICE structure
                //

                hidDevice = (PHID_DEVICE) MemAlloc(sizeof(HID_DEVICE));

                if(hidDevice == NULL)
                {
                    LOG((PHONESP_TRACE, "FindKnownHidDevices - unable to allocate hid device"));
                    SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
                    return ERROR_OUTOFMEMORY;
                }

                ZeroMemory(hidDevice, sizeof(HID_DEVICE));

                //
                // Mark this as new, so we can create a new phone for it later
                //
                hidDevice->bNew = TRUE;
                hidDevice->dwDevInst = hidDeviceInfoData.DevInst;

                //
                // Open the hid device
                //
                lResult = OpenHidDevice (hardwareDeviceInfo, &hidDeviceInterfaceData, hidDevice);

                if(lResult == ERROR_SUCCESS)
                {
                    //
                    // This is a good hid device
                    //
                    (*pNumberHidDevices)++;

                    //
                    // So add it to our hid list
                    //
                    AddHidDevice(hidDevice);

                    LOG((PHONESP_TRACE, "FindKnownHidDevices - new hid devive added"));
                }
                else
                {
                    LOG((PHONESP_TRACE, "FindKnownHidDevices - OpenHidDevice failed %08x", lResult )); 
                    MemFree(hidDevice);
                }
            }
            else
            {
                LOG((PHONESP_TRACE, "FindKnownHidDevices - hid device already enumerated"));

                //
                // Clear the removed mark on this device, so we don't remove its phone later
                //
                hidDevice->bRemoved = FALSE;
            }
        }
        else
        {
            LOG((PHONESP_TRACE, "FindKnownHidDevices - SetupDiGetDeviceInterfaceDetail failed %08x", GetLastError() ));          
        }
    }

    lResult = GetLastError();

    if (ERROR_NO_MORE_ITEMS != lResult) 
    {
        LOG((PHONESP_TRACE, "FindKnownHidDevices - SetupDiEnumDeviceInterfaces failed %08x", lResult )); 
        SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
        return lResult;
    }

    LOG((PHONESP_TRACE, "FindKnownHidDevices - exit"));

    *pHidDevices = gpHidDevices;

    SetupDiDestroyDeviceInfoList(hardwareDeviceInfo);
    return ERROR_SUCCESS;
}

LONG
OpenHidDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInterfaceData,
    IN OUT   PHID_DEVICE                 HidDevice
    )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
    LONG                                 lResult;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //

    LOG((PHONESP_TRACE,"OpenHidDevice - enter"));

    SetupDiGetDeviceInterfaceDetail(
                                    HardwareDeviceInfo,
                                    DeviceInterfaceData,
                                    NULL, // probing so no output buffer yet
                                    0, // probing so output buffer length of zero
                                    &requiredLength,
                                    NULL    // not interested in the specific dev-node
                                   );
   
    predictedLength = requiredLength;

    HidDevice->functionClassDeviceData = MemAlloc (predictedLength);

    if (HidDevice->functionClassDeviceData == NULL)
    {
        LOG((PHONESP_TRACE,"OpenHidDevice - out of memory"));
        return ERROR_OUTOFMEMORY;
    }

    HidDevice->functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
                                           HardwareDeviceInfo,
                                           DeviceInterfaceData,
                                           HidDevice->functionClassDeviceData,
                                           predictedLength,
                                           &requiredLength,
                                           NULL)) 
    {
        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;
        LOG((PHONESP_TRACE,"OpenHidDevice - SetupDiGetDeviceInterfaceDetail 2"
                           " Failed: %d", GetLastError()));
        return GetLastError();
    }

    HidDevice->HidDevice = CreateFile (
                              HidDevice->functionClassDeviceData->DevicePath,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL, // no SECURITY_ATTRIBUTES structure
                              OPEN_EXISTING, // No special create flags
                              FILE_FLAG_OVERLAPPED, // No special attributes
                              NULL); // No template file

    if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) 
    {
        LOG((PHONESP_TRACE,"OpenHidDevice - CreateFile Failed: %d", GetLastError()));

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        return GetLastError();
    }

    if (!HidD_GetPreparsedData (HidDevice->HidDevice, &HidDevice->Ppd)) 
    {
        LOG((PHONESP_ERROR, "OpenHidDevice - HidD_GetPreparsedData failed"));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        return ERROR_INVALID_DATA;
    }

    if (!HidD_GetAttributes (HidDevice->HidDevice, &HidDevice->Attributes)) 
    {
        LOG((PHONESP_ERROR, "OpenHidDevice - HidD_GetAttributes failed"));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        HidD_FreePreparsedData (HidDevice->Ppd);

        return ERROR_INVALID_DATA;
    }

    if ((!HidP_GetCaps (HidDevice->Ppd, &HidDevice->Caps)) || 
        (HidDevice->Caps.UsagePage != HID_USAGE_PAGE_TELEPHONY) || 
        (HidDevice->Caps.Usage != HID_USAGE_TELEPHONY_PHONE) ) 
    {
        LOG((PHONESP_TRACE, " HID USAGE PAGE NOT TELEPHONY " ));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        HidD_FreePreparsedData (HidDevice->Ppd);

        return ERROR_INVALID_DATA;
    }
    else 
    {
        LOG((PHONESP_TRACE, " HID USAGE PAGE TELEPHONY " ));
    }
    //
    // At this point the client has a choice.  It may chose to look at the
    // Usage and Page of the top level collection found in the HIDP_CAPS
    // structure.  In this way it could just use the usages it knows about.
    // If either HidP_GetUsages or HidP_GetUsageValue return an error then
    // that particular usage does not exist in the report.
    // This is most likely the preferred method as the application can only
    // use usages of which it already knows.
    // In this case the app need not even call GetButtonCaps or GetValueCaps.
    //
    // In this example, however, we will call FillDeviceInfo to look for all
    //    of the usages in the device.
    //

    lResult = FillDeviceInfo(HidDevice);
    
    if(lResult != ERROR_SUCCESS)
    {
        LOG((PHONESP_ERROR, "OpenHidDevice - FillDeviceInfo failed"));

        CloseHandle(HidDevice->HidDevice);
        HidDevice->HidDevice = NULL;

        MemFree(HidDevice->functionClassDeviceData);
        HidDevice->functionClassDeviceData = NULL;

        HidD_FreePreparsedData (HidDevice->Ppd);

        return lResult;
    }

    LOG((PHONESP_TRACE,"OpenHidDevice - exit"));

    return ERROR_SUCCESS;
}



LONG
FillDeviceInfo(
               IN  PHID_DEVICE HidDevice
              )
{
    USHORT                               numValues;
    USHORT                               numCaps;
    PHIDP_BUTTON_CAPS                    buttonCaps;
    PHIDP_VALUE_CAPS                     valueCaps;
    PHID_DATA                            data;
    ULONG                                i;
    USAGE                                usage;

    //
    // setup Input Data buffers.
    //

    //
    // Allocate memory to hold on input report
    //
    
    LOG((PHONESP_TRACE,"FillDeviceInfo - enter"));


    if ( ! ( HidDevice->InputReportBuffer = (PCHAR)
           MemAlloc (HidDevice->Caps.InputReportByteLength * sizeof (CHAR)) ) )
    {
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberInputButtonCaps %d", HidDevice->Caps.NumberInputButtonCaps));

    //
    // Allocate memory to hold the button and value capabilities.
    // NumberXXCaps is in terms of array elements.
    //
    HidDevice->InputButtonCaps = 
    buttonCaps                 = (PHIDP_BUTTON_CAPS)
                                MemAlloc (HidDevice->Caps.NumberInputButtonCaps
                                          * sizeof (HIDP_BUTTON_CAPS));

    if ( ! buttonCaps)
    {
        MemFree(HidDevice->InputReportBuffer);
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberInputValueCaps %d", HidDevice->Caps.NumberInputValueCaps));

    HidDevice->InputValueCaps = 
    valueCaps = (PHIDP_VALUE_CAPS)
                 MemAlloc (HidDevice->Caps.NumberInputValueCaps *
                           sizeof (HIDP_VALUE_CAPS));

    if ( ! valueCaps)
    {
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        return ERROR_OUTOFMEMORY;
    }
 
    //
    // Have the HidP_X functions fill in the capability structure arrays.
    //
    numCaps = HidDevice->Caps.NumberInputButtonCaps;
    HidP_GetButtonCaps (HidP_Input,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberInputValueCaps;
    HidP_GetValueCaps (HidP_Input,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    //
    // Depending on the device, some value caps structures may represent more
    // than one value.  (A range).  In the interest of being verbose, over
    // efficient, we will expand these so that we have one and only one
    // struct _HID_DATA for each value.
    //
    // To do this we need to count up the total number of values are listed
    // in the value caps structure.  For each element in the array we test
    // for range if it is a range then UsageMax and UsageMin describe the
    // usages for this range INCLUSIVE.
    //
    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberInputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax - 
                          valueCaps->Range.UsageMin + 1;
        } 
        else 
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->InputValueCaps;


    //
    // Allocate a buffer to hold the struct _HID_DATA structures.
    // One element for each set of buttons, and one element for each value
    // found.
    //
    HidDevice->InputDataLength = HidDevice->Caps.NumberInputButtonCaps + 
                                 numValues;

    HidDevice->InputData = 
    data =  (PHID_DATA) MemAlloc (HidDevice->InputDataLength *
                                  sizeof (HID_DATA));

    if( ! data )
    {
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);
        return ERROR_OUTOFMEMORY;
    }

    //
    // Fill in the button data
    //
    for (i = 0; i < HidDevice->Caps.NumberInputButtonCaps; 
                i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else 
        {
            data->ButtonData.UsageMin = 
            data->ButtonData.UsageMax = buttonCaps -> NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Input,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);

        data->ButtonData.Usages = (PUSAGE)
                                  MemAlloc (data->ButtonData.MaxUsageLength *
                                            sizeof (USAGE));

        // if MemAlloc fails release all previous allocated memory and return 
        // error
        if ( data->ButtonData.Usages == NULL)
        {
            DWORD dwCnt;
            
            for(dwCnt = 0; dwCnt < i; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->InputData);
            MemFree(HidDevice->InputReportBuffer);
            MemFree(HidDevice->InputButtonCaps);
            MemFree(HidDevice->InputValueCaps);
            
            return ERROR_OUTOFMEMORY;
        }

        data->ReportID = buttonCaps->ReportID;
    }

    //
    // Fill in the value data
    //
    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps->ReportID;
                data++;
            }
        } 
        else 
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps->ReportID;
            data++;
        }
    }

    //
    // setup Output Data buffers.
    //
    if ( ! ( HidDevice->OutputReportBuffer = (PCHAR)
                           MemAlloc (HidDevice->Caps.OutputReportByteLength * 
                                     sizeof (CHAR)) ) )
    {  
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberOutputButtonCaps %d", HidDevice->Caps.NumberOutputButtonCaps));

    HidDevice->OutputButtonCaps = 
    buttonCaps = (PHIDP_BUTTON_CAPS) 
                  MemAlloc(HidDevice->Caps.NumberOutputButtonCaps * 
                           sizeof (HIDP_BUTTON_CAPS));
    if ( ! buttonCaps )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);
        MemFree(HidDevice->OutputReportBuffer);
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberOutputValueCaps %d", HidDevice->Caps.NumberOutputValueCaps));

    HidDevice->OutputValueCaps = 
    valueCaps = (PHIDP_VALUE_CAPS)
                 MemAlloc (HidDevice->Caps.NumberOutputValueCaps * 
                 sizeof (HIDP_VALUE_CAPS));
    if ( ! valueCaps )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);

        return ERROR_OUTOFMEMORY;
    }


    numCaps = HidDevice->Caps.NumberOutputButtonCaps;

    HidP_GetButtonCaps (HidP_Output,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);


    numCaps = HidDevice->Caps.NumberOutputValueCaps;

    HidP_GetValueCaps (HidP_Output,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberOutputValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax - 
                          valueCaps->Range.UsageMin + 1;
        } 
        else 
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->OutputValueCaps;

    HidDevice->OutputDataLength = HidDevice->Caps.NumberOutputButtonCaps
                                  + numValues;

    HidDevice->OutputData = 
    data = (PHID_DATA) MemAlloc (HidDevice->OutputDataLength * 
                                 sizeof (HID_DATA));

    if ( ! data )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
        return ERROR_OUTOFMEMORY;
    }

    for (i = 0; i < HidDevice->Caps.NumberOutputButtonCaps;
                i++, data++, buttonCaps++) 
    {

        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps -> Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps -> Range.UsageMax;
        }
        else 
        {
            data->ButtonData.UsageMin = 
            data->ButtonData.UsageMax = buttonCaps->NotRange.Usage;
        }

        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                   HidP_Output,
                                                   buttonCaps->UsagePage,
                                                   HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
                                   MemAlloc (data->ButtonData.MaxUsageLength *
                                             sizeof (USAGE));
        
        if( ! data)
        {
            DWORD dwCnt;
            
            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->InputData);
            MemFree(HidDevice->InputReportBuffer);
            MemFree(HidDevice->InputButtonCaps);
            MemFree(HidDevice->InputValueCaps);

            for(dwCnt = 0; dwCnt < i; dwCnt++)
            {
                MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->OutputData);
            MemFree(HidDevice->OutputReportBuffer);
            MemFree(HidDevice->OutputButtonCaps);
            MemFree(HidDevice->OutputValueCaps);
            
            return ERROR_OUTOFMEMORY;
        }

        data->ReportID = buttonCaps->ReportID;
    }


    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax; usage++) 
            {

                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps -> ReportID;
                data++;
            }
        } 
        else 
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    //
    // setup Feature Data buffers.
    //

    if ( ! ( HidDevice->FeatureReportBuffer = (PCHAR)
                     MemAlloc (HidDevice->Caps.FeatureReportByteLength *
                               sizeof (CHAR)) ) )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
            
        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberFeatureButtonCaps %d", HidDevice->Caps.NumberFeatureButtonCaps));

    if ( ! ( HidDevice->FeatureButtonCaps = buttonCaps = (PHIDP_BUTTON_CAPS)
                        MemAlloc (HidDevice->Caps.NumberFeatureButtonCaps *
                                  sizeof (HIDP_BUTTON_CAPS)) ) )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
            
        MemFree(HidDevice->FeatureReportBuffer);

        return ERROR_OUTOFMEMORY;
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - NumberFeatureValueCaps %d", HidDevice->Caps.NumberFeatureValueCaps));

    HidDevice->FeatureValueCaps = 
    valueCaps = (PHIDP_VALUE_CAPS)
                MemAlloc (HidDevice->Caps.NumberFeatureValueCaps *
                          sizeof (HIDP_VALUE_CAPS));

    if ( ! valueCaps)
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);

        MemFree(HidDevice->FeatureReportBuffer);
        MemFree(HidDevice->FeatureButtonCaps);
            
        return ERROR_OUTOFMEMORY;
    }



    numCaps = HidDevice->Caps.NumberFeatureButtonCaps;
    HidP_GetButtonCaps (HidP_Feature,
                        buttonCaps,
                        &numCaps,
                        HidDevice->Ppd);

    numCaps = HidDevice->Caps.NumberFeatureValueCaps;
    HidP_GetValueCaps (HidP_Feature,
                       valueCaps,
                       &numCaps,
                       HidDevice->Ppd);


    numValues = 0;
    for (i = 0; i < HidDevice->Caps.NumberFeatureValueCaps; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            numValues += valueCaps->Range.UsageMax
                       - valueCaps->Range.UsageMin + 1;
        } 
        else 
        {
            numValues++;
        }
    }
    valueCaps = HidDevice->FeatureValueCaps;

    HidDevice->FeatureDataLength = HidDevice->Caps.NumberFeatureButtonCaps
                                      + numValues;

    HidDevice->FeatureData = 
    data = (PHID_DATA)
            MemAlloc (HidDevice->FeatureDataLength * sizeof (HID_DATA));
    
    if ( ! data )
    {
        DWORD dwCnt;
            
        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->InputData);
        MemFree(HidDevice->InputReportBuffer);
        MemFree(HidDevice->InputButtonCaps);
        MemFree(HidDevice->InputValueCaps);

        for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
        {
            MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
        }
        MemFree(HidDevice->OutputData);
        MemFree(HidDevice->OutputReportBuffer);
        MemFree(HidDevice->OutputButtonCaps);
        MemFree(HidDevice->OutputValueCaps);
        
        MemFree(HidDevice->FeatureReportBuffer);
        MemFree(HidDevice->FeatureButtonCaps);
        MemFree(HidDevice->FeatureValueCaps);
            
        return ERROR_OUTOFMEMORY;
    }


    for ( i = 0; i < HidDevice->Caps.NumberFeatureButtonCaps;
          i++, data++, buttonCaps++) 
    {
        data->IsButtonData = TRUE;
        data->Status = HIDP_STATUS_SUCCESS;
        data->UsagePage = buttonCaps->UsagePage;

        if (buttonCaps->IsRange) 
        {
            data->ButtonData.UsageMin = buttonCaps->Range.UsageMin;
            data->ButtonData.UsageMax = buttonCaps->Range.UsageMax;
        }
        else 
        {
            data->ButtonData.UsageMin = 
            data->ButtonData.UsageMax = buttonCaps->NotRange.Usage;
        }
        
        data->ButtonData.MaxUsageLength = HidP_MaxUsageListLength (
                                                HidP_Feature,
                                                buttonCaps->UsagePage,
                                                HidDevice->Ppd);
        data->ButtonData.Usages = (PUSAGE)
                                  MemAlloc (data->ButtonData.MaxUsageLength *
                                            sizeof (USAGE));

        if ( ! data->ButtonData.Usages )
        {
            DWORD dwCnt;
            
            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->InputData);
            MemFree(HidDevice->InputReportBuffer);
            MemFree(HidDevice->InputButtonCaps);
            MemFree(HidDevice->InputValueCaps);

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->OutputData);
            MemFree(HidDevice->OutputReportBuffer);
            MemFree(HidDevice->OutputButtonCaps);
            MemFree(HidDevice->OutputValueCaps);

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberFeatureButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->FeatureData[dwCnt].ButtonData.Usages);
            }
            MemFree(HidDevice->FeatureData);
            MemFree(HidDevice->FeatureReportBuffer);
            MemFree(HidDevice->FeatureButtonCaps);
            MemFree(HidDevice->FeatureValueCaps);
            
            return ERROR_OUTOFMEMORY;  
        }

        data->ReportID = buttonCaps->ReportID;
    }

    for (i = 0; i < numValues; i++, valueCaps++) 
    {
        if (valueCaps->IsRange) 
        {
            for (usage = valueCaps->Range.UsageMin;
                 usage <= valueCaps->Range.UsageMax;
                 usage++) 
            {
                data->IsButtonData = FALSE;
                data->Status = HIDP_STATUS_SUCCESS;
                data->UsagePage = valueCaps->UsagePage;
                data->ValueData.Usage = usage;
                data->ReportID = valueCaps->ReportID;
                data++;
            }
        } 
        else 
        {
            data->IsButtonData = FALSE;
            data->Status = HIDP_STATUS_SUCCESS;
            data->UsagePage = valueCaps->UsagePage;
            data->ValueData.Usage = valueCaps->NotRange.Usage;
            data->ReportID = valueCaps -> ReportID;
            data++;
        }
    }

    LOG((PHONESP_TRACE,"FillDeviceInfo - exit"));

    return ERROR_SUCCESS;
}

VOID
CloseHidDevices()
{
    LOG((PHONESP_TRACE, "CloseHidDevices - enter"));

    while (gpHidDevices != NULL)
    {
        CloseHidDevice(gpHidDevices);
    }

    LOG((PHONESP_TRACE, "CloseHidDevices - exit"));

    return;
}

BOOL
OpenHidFile (
    IN  PHID_DEVICE HidDevice
    )
{
    LOG((PHONESP_TRACE, "OpenHidFile - enter"));

    if (HidDevice != NULL)
    {
        if (HidDevice->functionClassDeviceData != NULL)
        {
            HidDevice->HidDevice = CreateFile (
                                      HidDevice->functionClassDeviceData->DevicePath,
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL, // no SECURITY_ATTRIBUTES structure
                                      OPEN_EXISTING, // No special create flags
                                      FILE_FLAG_OVERLAPPED, // No special attributes
                                      NULL); // No template file

            if (INVALID_HANDLE_VALUE == HidDevice->HidDevice) 
            {
                LOG((PHONESP_ERROR,"OpenHidFile - CreateFile failed: %d", GetLastError()));
                return FALSE;
            }

            LOG((PHONESP_TRACE, "OpenHidFile - exit"));
            return TRUE;
        }
    }

    LOG((PHONESP_WARN, "OpenHidFile - no device"));

    return FALSE;
}

BOOL
CloseHidFile (
    IN  PHID_DEVICE HidDevice
    )
{
    LOG((PHONESP_TRACE, "CloseHidFile - enter"));

    if (HidDevice != NULL)
    {
        if ((NULL != HidDevice->HidDevice) &&
            (INVALID_HANDLE_VALUE != HidDevice->HidDevice))
        {
            CloseHandle(HidDevice->HidDevice);
            HidDevice->HidDevice = NULL;

            LOG((PHONESP_TRACE, "CloseHidFile - exit"));
            return TRUE;
        }
    }

    LOG((PHONESP_WARN, "CloseHidFile - no device"));
    return FALSE;
}

VOID
CloseHidDevice (
                IN PHID_DEVICE HidDevice
               )
{
    LOG((PHONESP_TRACE, "CloseHidDevice - enter"));

    if (HidDevice != NULL)
    {
        if (NULL != HidDevice->functionClassDeviceData)
        {
            MemFree(HidDevice->functionClassDeviceData);
        }

        if ((NULL != HidDevice -> HidDevice) &&
            (INVALID_HANDLE_VALUE != HidDevice -> HidDevice))
        {
            CloseHandle(HidDevice->HidDevice);
            HidDevice->HidDevice = NULL;
        }

        if (NULL != HidDevice->Ppd) 
        {
            HidD_FreePreparsedData(HidDevice->Ppd);
            HidDevice->Ppd = NULL;
        }

        if (NULL != HidDevice->InputReportBuffer) 
        {
            MemFree(HidDevice->InputReportBuffer);
            HidDevice->InputReportBuffer = NULL;
        }

        if (NULL != HidDevice->InputData) 
        {
            DWORD dwCnt;

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberInputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->InputData[dwCnt].ButtonData.Usages);
                HidDevice->InputData[dwCnt].ButtonData.Usages = NULL;
            }

            MemFree(HidDevice->InputData);
            HidDevice->InputData = NULL;
        }

        if (NULL != HidDevice->InputButtonCaps) 
        {
            MemFree(HidDevice->InputButtonCaps);
            HidDevice->InputButtonCaps = NULL;
        }

        if (NULL != HidDevice->InputValueCaps) 
        {
            MemFree(HidDevice->InputValueCaps);
            HidDevice->InputValueCaps = NULL;
        }

        if (NULL != HidDevice->OutputReportBuffer) 
        {
            MemFree(HidDevice->OutputReportBuffer);
            HidDevice->OutputReportBuffer = NULL;
        }

        if (NULL != HidDevice->OutputData) 
        {
            DWORD dwCnt;

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberOutputButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->OutputData[dwCnt].ButtonData.Usages);
                HidDevice->OutputData[dwCnt].ButtonData.Usages = NULL;
            }

            MemFree(HidDevice->OutputData);
            HidDevice->OutputData = NULL;
        }

        if (NULL != HidDevice->OutputButtonCaps) 
        {
            MemFree(HidDevice->OutputButtonCaps);
            HidDevice->OutputButtonCaps = NULL;
        }

        if (NULL != HidDevice->OutputValueCaps) 
        {
            MemFree(HidDevice->OutputValueCaps);
            HidDevice->OutputValueCaps = NULL;
        }

        if (NULL != HidDevice->FeatureReportBuffer) 
        {
            MemFree(HidDevice->FeatureReportBuffer);
            HidDevice->FeatureReportBuffer = NULL;
        }

        if (NULL != HidDevice->FeatureData) 
        {
            DWORD dwCnt;

            for(dwCnt = 0; dwCnt < HidDevice->Caps.NumberFeatureButtonCaps; dwCnt++)
            {
                MemFree(HidDevice->FeatureData[dwCnt].ButtonData.Usages);
                HidDevice->FeatureData[dwCnt].ButtonData.Usages = NULL;
            }

            MemFree(HidDevice->FeatureData);
            HidDevice->FeatureData = NULL;
        }

        if (NULL != HidDevice->FeatureButtonCaps) 
        {
            MemFree(HidDevice->FeatureButtonCaps);
            HidDevice->FeatureButtonCaps = NULL;
        }

        if (NULL != HidDevice->FeatureValueCaps) 
        {
            MemFree(HidDevice->FeatureValueCaps);
            HidDevice->FeatureValueCaps = NULL;
        }

        RemoveHidDevice(HidDevice);
        MemFree(HidDevice);
    }

    LOG((PHONESP_TRACE, "CloseHidDevice - exit"));
    return;
}
    
VOID
AddHidDevice (
              IN PHID_DEVICE HidDevice
             )
{
    LOG((PHONESP_TRACE, "AddHidDevice - enter"));

    HidDevice->Next = gpHidDevices;
    HidDevice->Prev = NULL;

    if (gpHidDevices)
    {
        gpHidDevices->Prev = HidDevice;
    }

    gpHidDevices = HidDevice;

    LOG((PHONESP_TRACE, "AddHidDevice - exit"));
}

VOID
RemoveHidDevice (
                 IN PHID_DEVICE HidDevice
                )
{
    LOG((PHONESP_TRACE, "RemoveHidDevice - enter"));

    if (HidDevice->Prev)
    {
        HidDevice->Prev->Next = HidDevice->Next;
    }
    else
    {
        // first in list
        gpHidDevices = HidDevice->Next;
    }

    if (HidDevice->Next)
    {
        HidDevice->Next->Prev = HidDevice->Prev;
    }

    HidDevice->Next = NULL;
    HidDevice->Prev = NULL;

    LOG((PHONESP_TRACE, "RemoveHidDevice - exit"));
}

PHID_DEVICE
FindHidDeviceByDevInst (
                        IN DWORD DevInst
                       )
{
    PHID_DEVICE HidDevice = gpHidDevices;

    LOG((PHONESP_TRACE, "FindHidDeviceByDevInst - enter"));

    while (HidDevice != NULL)
    {
        if (HidDevice->dwDevInst == DevInst)
        {
            LOG((PHONESP_TRACE, "FindHidDeviceByDevInst - exit"));
            return HidDevice;
        }

        HidDevice = HidDevice->Next;
    }

    LOG((PHONESP_WARN, "FindHidDeviceByDevInst - not found"));
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\report.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    report.c

Abstract:

    This module contains the code for translating HID reports to something
    useful.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <stdlib.h>
#include <wtypes.h>
#include "hidsdi.h"
#include "hid.h"
#include "mylog.h"
#include "mymem.h"


BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );

// Haven't used this with Write .. let's see whether i need this with set/get feature
BOOL
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   );



VOID CALLBACK 
WriteIOCompletionRoutine (
                         DWORD dwErrorCode,
                         DWORD dwNumberofBytesTransferrred,
                         LPOVERLAPPED lpOverlapped
                         )
{
    PHID_DEVICE pHidDevice = (PHID_DEVICE) lpOverlapped->hEvent;

    LOG((PHONESP_TRACE, "WriteIOCompletionRoutine - enter"));

    if(dwErrorCode)
    {
        LOG((PHONESP_ERROR, "Error occured while writing" ));
    }

    MemFree(lpOverlapped);
    LOG((PHONESP_TRACE, "WriteIOCompletionRoutine - exit"));
}



BOOL
Write (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, take the information in the HID_DATA array
   pack it into multiple write reports and send each report to the HID device
--*/
{
    DWORD        bytesWritten;
    PHID_DATA    pData;
    ULONG        Index;
    BOOL         Status;
    BOOL         WriteStatus;
    LPOVERLAPPED lpOverlapped;

    LOG((PHONESP_TRACE, "Write - enter"));

    lpOverlapped = (LPOVERLAPPED) MemAlloc (sizeof(OVERLAPPED));

    if (lpOverlapped == NULL)
    {
        LOG((PHONESP_ERROR,"Write - out of memory"));
        return FALSE;
    }

    lpOverlapped->Offset = 0;
    lpOverlapped->OffsetHigh = 0;
    lpOverlapped->hEvent = (HANDLE) HidDevice;

    LOG((PHONESP_TRACE,"Write - Report Packed"));
    WriteStatus = WriteFileEx (HidDevice->HidDevice,
                                  HidDevice->OutputReportBuffer,
                                  HidDevice->Caps.OutputReportByteLength,
                                  lpOverlapped,
                                  &WriteIOCompletionRoutine); 

    SleepEx(INFINITE, TRUE);
    LOG((PHONESP_TRACE, "Write - Report sent"));

    LOG((PHONESP_TRACE, "Write - exit"));

    return TRUE;
}

BOOL
SetFeature (
    PHID_DEVICE    HidDevice
    )
/*++
RoutineDescription:
Given a struct _HID_DEVICE, take the information in the HID_DATA array
pack it into multiple reports and send it to the hid device via HidD_SetFeature()
--*/
{
    PHID_DATA pData;
    ULONG     Index;
    BOOL      Status;
    BOOL      FeatureStatus;
    DWORD     ErrorCode;
    /*
    // Begin by looping through the HID_DEVICE's HID_DATA structure and setting
    //   the IsDataSet field to FALSE to indicate that each structure has
    //   not yet been set for this SetFeature() call.
    */

    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {
        pData -> IsDataSet = FALSE;
    }

    /*
    // In setting all the data in the reports, we need to pack a report buffer
    //   and call WriteFile for each report ID that is represented by the 
    //   device structure.  To do so, the IsDataSet field will be used to 
    //   determine if a given report field has already been set.
    */

    Status = TRUE;

    pData = HidDevice -> FeatureData;
    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {

        if (!pData -> IsDataSet) {

            /*
            // Package the report for this data structure.  PackReport will
            //    set the IsDataSet fields of this structure and any other 
            //    structures that it includes in the report with this structure
            */

            PackReport (HidDevice->FeatureReportBuffer,
                     HidDevice->Caps.FeatureReportByteLength,
                     HidP_Feature,
                     pData,
                     HidDevice->FeatureDataLength - Index,
                     HidDevice->Ppd);

            /*
            // Now a report has been packaged up...Send it down to the device
            */

            FeatureStatus =(HidD_SetFeature (HidDevice->HidDevice,
                                          HidDevice->FeatureReportBuffer,
                                          HidDevice->Caps.FeatureReportByteLength));

            ErrorCode = GetLastError();

            Status = Status && FeatureStatus;
        }
    }
    return (Status);
}

BOOL
GetFeature (
   PHID_DEVICE    HidDevice
   )
/*++
RoutineDescription:
   Given a struct _HID_DEVICE, fill in the feature data structures with
   all features on the device.  May issue multiple HidD_GetFeature() calls to
   deal with multiple report IDs.
--*/
{
    ULONG     Index;
    PHID_DATA pData;
    BOOL      FeatureStatus;
    BOOL      Status;

    /*
    // As with writing data, the IsDataSet value in all the structures should be
    //    set to FALSE to indicate that the value has yet to have been set
    */

    LOG((PHONESP_TRACE,"GetFeature - enter"));
    pData = HidDevice->FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) 
    {
        pData -> IsDataSet = FALSE;
    }

    /*
    // Next, each structure in the HID_DATA buffer is filled in with a value
    //   that is retrieved from one or more calls to HidD_GetFeature.  The 
    //   number of calls is equal to the number of reportIDs on the device
    */

    Status = TRUE; 
    pData = HidDevice -> FeatureData;

    for (Index = 0; Index < HidDevice -> FeatureDataLength; Index++, pData++) {
       
        /*
        // If a value has yet to have been set for this structure, build a report
        //    buffer with its report ID as the first byte of the buffer and pass
        //    it in the HidD_GetFeature call.  Specifying the report ID in the
        //    first specifies which report is actually retrieved from the device.
        //    The rest of the buffer should be zeroed before the call
        */
        if (!pData -> IsDataSet) {

            memset(HidDevice -> FeatureReportBuffer, 0x00, HidDevice->Caps.FeatureReportByteLength);

            HidDevice -> FeatureReportBuffer[0] = (UCHAR) pData -> ReportID;

            FeatureStatus = HidD_GetFeature ( HidDevice->HidDevice,
                                              HidDevice->FeatureReportBuffer,
                                              HidDevice->Caps.FeatureReportByteLength);

            /*
            // If the return value is TRUE, scan through the rest of the HID_DATA
            //    structures and fill whatever values we can from this report
            */


            if (FeatureStatus)
            {
                FeatureStatus = UnpackReport ( HidDevice->FeatureReportBuffer,
                                           HidDevice->Caps.FeatureReportByteLength,
                                           HidP_Feature,
                                           HidDevice->FeatureData,
                                           HidDevice->FeatureDataLength,
                                           HidDevice->Ppd
                                         );
            }
            else
            {
                LOG((PHONESP_ERROR, "GetFeature - HidD_GetFeature failed %d", GetLastError()));
            }

            Status = Status && FeatureStatus;
        }
   }

   LOG((PHONESP_TRACE, "GetFeature - exit"));
   
   return Status;
}


BOOL
UnpackReport (
   IN       PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN OUT   PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   Given ReportBuffer representing a report from a HID device where the first
   byte of the buffer is the report ID for the report, extract all the HID_DATA
   in the Data list from the given report.
--*/
{
    ULONG       numUsages; // Number of usages returned from GetUsages.
    ULONG       i;
    UCHAR       reportID;
    ULONG       Index;
    ULONG       nextUsage;

    reportID = ReportBuffer[0];

    for (i = 0; i < DataLength; i++, Data++) {

        if (reportID == Data->ReportID) {

            if (Data->IsButtonData) {
                numUsages = Data->ButtonData.MaxUsageLength;
                Data->Status = HidP_GetUsages (
                                               ReportType,
                                               Data->UsagePage,
                                               0, // All collections
                                               Data->ButtonData.Usages,
                                               &numUsages,
                                               Ppd,
                                               ReportBuffer,
                                               ReportBufferLength);


                //
                // Get usages writes the list of usages into the buffer
                // Data->ButtonData.Usages newUsage is set to the number of usages
                // written into this array.
                // A usage cannot not be defined as zero, so we'll mark a zero
                // following the list of usages to indicate the end of the list of
                // usages
                //
                // NOTE: One anomaly of the GetUsages function is the lack of ability
                //        to distinguish the data for one ButtonCaps from another
                //        if two different caps structures have the same UsagePage
                //        For instance:
                //          Caps1 has UsagePage 07 and UsageRange of 0x00 - 0x167
                //          Caps2 has UsagePage 07 and UsageRange of 0xe0 - 0xe7
                //
                //        However, calling GetUsages for each of the data structs
                //          will return the same list of usages.  It is the 
                //          responsibility of the caller to set in the HID_DEVICE
                //          structure which usages actually are valid for the
                //          that structure. 
                //      

                /*
                // Search through the usage list and remove those that 
                //    correspond to usages outside the define ranged for this
                //    data structure.
                */
                
                for (Index = 0, nextUsage = 0; Index < numUsages; Index++) {

                    if (Data -> ButtonData.UsageMin <= Data -> ButtonData.Usages[Index] && 
                            Data -> ButtonData.Usages[Index] <= Data -> ButtonData.UsageMax) {

                        Data -> ButtonData.Usages[nextUsage++] = Data -> ButtonData.Usages[Index];
                        
                    }
                }

                if (nextUsage < Data -> ButtonData.MaxUsageLength) {
                    Data->ButtonData.Usages[nextUsage] = 0;
                }
            }
            else {
                Data->Status = HidP_GetUsageValue (
                                                ReportType,
                                                Data->UsagePage,
                                                0,               // All Collections.
                                                Data->ValueData.Usage,
                                                &Data->ValueData.Value,
                                                Ppd,
                                                ReportBuffer,
                                                ReportBufferLength);

                Data->Status = HidP_GetScaledUsageValue (
                                                       ReportType,
                                                       Data->UsagePage,
                                                       0, // All Collections.
                                                       Data->ValueData.Usage,
                                                       &Data->ValueData.ScaledValue,
                                                       Ppd,
                                                       ReportBuffer,
                                                       ReportBufferLength);
            } 
            Data -> IsDataSet = TRUE;
        }
    }
    return (TRUE);
}


BOOL
PackReport (
   OUT      PCHAR                ReportBuffer,
   IN       USHORT               ReportBufferLength,
   IN       HIDP_REPORT_TYPE     ReportType,
   IN       PHID_DATA            Data,
   IN       ULONG                DataLength,
   IN       PHIDP_PREPARSED_DATA Ppd
   )
/*++
Routine Description:
   This routine takes in a list of HID_DATA structures (DATA) and builds 
      in ReportBuffer the given report for all data values in the list that 
      correspond to the report ID of the first item in the list.  

   For every data structure in the list that has the same report ID as the first
      item in the list will be set in the report.  Every data item that is 
      set will also have it's IsDataSet field marked with TRUE.

   A return value of FALSE indicates an unexpected error occurred when setting
      a given data value.  The caller should expect that assume that no values
      within the given data structure were set.

   A return value of TRUE indicates that all data values for the given report
      ID were set without error.
--*/
{
    ULONG       numUsages; // Number of usages to set for a given report.
    ULONG       i;
    ULONG       CurrReportID;

    /*
    // All report buffers that are initially sent need to be zero'd out
    */

    memset (ReportBuffer, (UCHAR) 0, ReportBufferLength);

    /*
    // Go through the data structures and set all the values that correspond to
    //   the CurrReportID which is obtained from the first data structure 
    //   in the list
    */

    CurrReportID = Data -> ReportID;

    for (i = 0; i < DataLength; i++, Data++) {

        /*
        // There are two different ways to determine if we set the current data
        //    structure: 
        //    1) Store the report ID were using and only attempt to set those
        //        data structures that correspond to the given report ID.  This
        //        example shows this implementation.
        //
        //    2) Attempt to set all of the data structures and look for the 
        //        returned status value of HIDP_STATUS_INVALID_REPORT_ID.  This 
        //        error code indicates that the given usage exists but has a 
        //        different report ID than the report ID in the current report 
        //        buffer
        */

        if (Data -> ReportID == CurrReportID) {

            if (Data->IsButtonData) {
             numUsages = Data->ButtonData.MaxUsageLength;
             Data->Status = HidP_SetUsages (
                              ReportType,
                              Data->UsagePage,
                              0, // All collections
                              Data->ButtonData.Usages,
                              &numUsages,
                              Ppd,
                              ReportBuffer,
                              ReportBufferLength);
            } else {
             Data->Status = HidP_SetUsageValue (
                                 ReportType,
                                 Data->UsagePage,
                                 0, // All Collections.
                                 Data->ValueData.Usage,
                                 Data->ValueData.Value,
                                 Ppd,
                                 ReportBuffer,
                                 ReportBufferLength);
            }

            if (HIDP_STATUS_SUCCESS != Data->Status)
            {
              return FALSE;
            }
        }
    }   

    /*
    // At this point, all data structures that have the same ReportID as the
    //    first one will have been set in the given report.  Time to loop 
    //    through the structure again and mark all of those data structures as
    //    having been set.
    */

    for (i = 0; i < DataLength; i++, Data++) {

        if (CurrReportID == Data -> ReportID) {

            Data -> IsDataSet = TRUE;

        }
   }
   return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\phonemgr\phonemgr.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#include <windows.h>
#include <winuser.h>
#include <strmif.h>
#include <control.h>

#include <TCHAR.h>
#include <tapi3.h>
#include <mmsystem.h>
#include <string.h>

#include "resource.h"
#include "tones.h"
 
typedef struct _MYPHONE
{
    HPHONE             hPhone;

    DWORD              dwDevID;

    DWORD              dwPrivilege;

    DWORD              dwAPIVersion;

    HPHONEAPP          hPhoneApp;

    LONG               lRenderID;
    
    LONG               lCaptureID;

    DWORD              dwHandsetMode;

    LPWSTR             wszDialStr;

    CRITICAL_SECTION   csdial;

    CTonePlayer      * pTonePlayer;

} MYPHONE, *PMYPHONE;

static BYTE             pbData[WAVE_FILE_SIZE];

PMYPHONE                gpPhone;
DWORD                   gdwNumPhoneDevs;
HPHONEAPP               ghPhoneApp;
DWORD                   gdwAPIVersion = 0x00030000;

LPWSTR                  g_wszMsg, g_wszDest,g_szDialStr;
const WCHAR             *gszTapi30  = L"TAPI 3.0 Outgoing Call Demo Using Phone TSP";

HINSTANCE               ghInst;
HWND                    ghDlg = NULL;
ITTAPI *                gpTapi;
ITAddress *             gpAddress = NULL;
ITBasicCallControl *    gpCall;

///////////////////////////////////////////////////////////////////////////////

INT_PTR
CALLBACK
MainWndProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              );

VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

void
SetStatusMessage(
                 LPWSTR pszMessage
                );

void
CreatePhone(
            PMYPHONE pPhone,
            DWORD dwDevID
            );

void
FreePhone(
            PMYPHONE pPhone
         );

PMYPHONE
GetPhone(
         HPHONE hPhone 
        );

PMYPHONE
GetPhoneByID (
              DWORD dwDevID
              );

void
RemovePhone (PMYPHONE pPhone);

PMYPHONE
AddPhone ();

void
DoMessage(
          LPWSTR pszMessage
         );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\phonemgr\phonemgr.cpp ===
/* Copyright (c) 1999  Microsoft Corporation */

#include "phonemgr.h"

#include <stdlib.h>
#include <stdio.h>
#include <wxdebug.h>

#ifdef _DBG
#define DEBUG(_x_) OutputDebugString(_x_)
#else
#define DEBUG(_x_)
#endif

ITRequest * g_pITRequest = NULL;


HRESULT InitAssistedTelephony(void)
{
    HRESULT     hr;

    //
    // Initialize COM.
    //

    printf("Initializing COM...\n");

    hr = CoInitializeEx(
                        NULL,
                        COINIT_MULTITHREADED
                       );

    if ( FAILED(hr) )
    {
        printf("CoInitialize failed - 0x%08x\n", hr);

        return hr;
    }

    //
    // Cocreate the assisted telephony object.
    //

    printf("Creating RequestMakeCall object...\n");

    hr = CoCreateInstance(
                          CLSID_RequestMakeCall,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITRequest,
                          (void **) & g_pITRequest
                         );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance failed - 0x%08x\n", hr);

        return hr;
    }

    return S_OK;
}



HRESULT MakeAssistedTelephonyCall(WCHAR * wszDestAddress)
{
    HRESULT     hr;
    BSTR        bstrDestAddress = NULL;
    BSTR        bstrAppName     = NULL;
    BSTR        bstrCalledParty = NULL;
    BSTR        bstrComment     = NULL;

    bstrDestAddress = SysAllocString(
                                     wszDestAddress
                                    );

    if ( bstrDestAddress == NULL )
    {
        printf("SysAllocString failed");

        return E_OUTOFMEMORY;
    }


    //
    // Make a call.
    //

    printf("Calling ITRequest::MakeCall...\n");

    hr = g_pITRequest->MakeCall(
                                bstrDestAddress,
                                bstrAppName,
                                bstrCalledParty,
                                bstrComment
                               );

    SysFreeString(
              bstrDestAddress
             );
                                 
    if ( FAILED(hr) )
    {
        printf("ITRequest::MakeCall failed - 0x%08x\n", hr);

        return hr;
    }

    return S_OK;
}



int
WINAPI
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
    )
{
    MSG     msg;
    HWND    hwnd, hwndEdit;

    ghInst = hInstance;
   
    DialogBox(
              ghInst,
              MAKEINTRESOURCE(IDD_MAINDLG),
              NULL,
              MainWndProc
            );

    return 0;
}




INT_PTR
CALLBACK
MainWndProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              )
{

    LPCTSTR                 lszAppName = _T("Generate DialTone");
    DWORD                   dwNumDevs, i; 
    LONG                    lResult;
    PHONEINITIALIZEEXPARAMS initExParams;
    PMYPHONE pNextPhone;
    PWCHAR szAddressToCall;
    
    ghDlg = hDlg;

    switch (uMsg)
    {
    case WM_INITDIALOG:
    
        initExParams.dwTotalSize = sizeof (PHONEINITIALIZEEXPARAMS);
        initExParams.dwOptions = (DWORD) PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW;

        lResult = phoneInitializeEx(
                (LPHPHONEAPP)               &ghPhoneApp,
                (HINSTANCE)                 ghInst,
                (PHONECALLBACK)             tapiCallback,
                                            lszAppName,
                (LPDWORD)                   &dwNumDevs,
                (LPDWORD)                   &gdwAPIVersion,
                (LPPHONEINITIALIZEEXPARAMS) &initExParams
                );

        if (lResult == 0)
        {
            gdwNumPhoneDevs = dwNumDevs;
        }

        gpPhone = (PMYPHONE) LocalAlloc(LPTR,gdwNumPhoneDevs * sizeof(MYPHONE));

        g_wszMsg = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * 100 );
        g_wszDest = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * 100 );

        // Opening all the phones 
        for(i = 0, pNextPhone = gpPhone; i < gdwNumPhoneDevs; i++, pNextPhone++)
        {
            CreatePhone(pNextPhone, i);
        }

        SetStatusMessage(TEXT("Waiting for input from Phones"));

        g_szDialStr   = (LPWSTR) LocalAlloc(LPTR, 20 * sizeof(WCHAR));
        lstrcpy(g_szDialStr, TEXT("Dial Number: "));
        
        break;

    case WM_COMMAND:
        if ( LOWORD(wParam) == IDCANCEL )
        {
            //
            // The close box or Exit button was pressed.
            //
        
            SetStatusMessage(TEXT("End Application"));

            if(ghPhoneApp)
            {
                phoneShutdown(ghPhoneApp);
            }
            EndDialog( hDlg, 0 );

            LocalFree(g_szDialStr);
            LocalFree(g_wszMsg);
            LocalFree(g_wszDest);

            for( i=0; i<gdwNumPhoneDevs; i++ )
            {
                FreePhone(&gpPhone[i]);
            }
            LocalFree(gpPhone);

        }
        else if ( LOWORD(wParam) == IDC_MAKECALL )
        {
            //
            // The Make Call button was pressed.
            //


            //
            // Stop dialtone.
            // this only works for one phone.
            // Should be fine as we don't have
            // the window visible unless you have the phone off hook.
            //

            gpPhone[0].pTonePlayer->StopDialtone();

            //
            // Dial the dest address in the edit box.
            //
            
            const int ciMaxPhoneNumberSize = 400;
            WCHAR     wszPhoneNumber[ciMaxPhoneNumberSize];
            UINT      uiResult;
    
            uiResult = GetDlgItemText(
                ghDlg,                // handle to dialog box
                IDC_DESTADDRESS,      // identifier of control
                wszPhoneNumber,       // pointer to buffer for text (unicode)
                ciMaxPhoneNumberSize  // maximum size of string (in our buffer)
                );

            if ( uiResult == 0 )
            {
                DoMessage(L"Could not get dialog item text; not making call");
            }
            else
            {
                MakeAssistedTelephonyCall(wszPhoneNumber);
            }
        }

        break;

    default:
        break;
    }

    return 0;
}


VOID
CALLBACK
tapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    ULONG_PTR   CallbackInstance,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    PMYPHONE pPhone;
    DWORD    i;
    BOOL     bDialtone = FALSE;

    if (hDevice != NULL)
    {
        pPhone = GetPhone((HPHONE) hDevice);

        if (pPhone == NULL)
        {
            DEBUG(L"tapiCallback - phone not found\n");
            return;
        }        
    }

    switch (dwMsg)
    {
    case PHONE_STATE:
        DEBUG(L"PHONE_STATE\n");
        if (pPhone != NULL)
        {
            EnterCriticalSection(&pPhone->csdial);
            if ( Param1 == PHONESTATE_HANDSETHOOKSWITCH ) 
            {
                if ( Param2 != PHONEHOOKSWITCHMODE_ONHOOK ) // if off hook
                {
                    if ( FAILED(pPhone->pTonePlayer->StartDialtone()) )
                    {
                        DoMessage(L"StartDialTone Failed");
                    }


                    // ZoltanS: show the window now
                    ShowWindow(ghDlg, SW_SHOWNORMAL);


                    pPhone->dwHandsetMode = PHONEHOOKSWITCHMODE_MICSPEAKER;

                    lstrcpy(pPhone->wszDialStr,TEXT(""));
                    lstrcpy(g_wszMsg,TEXT("Generating Dialtone for phones: "));

                    for( i=0 ; i < gdwNumPhoneDevs; i++)
                    {
                        if ( gpPhone[i].pTonePlayer->IsInUse() )
                        {
                            wsprintf(g_wszDest,TEXT("%d"),i);
                            lstrcat(g_wszMsg,g_wszDest);
                        }
                    }
                
                    SetStatusMessage(g_wszMsg);
  
                }
                else // on hook
                {
                
                    pPhone->dwHandsetMode = PHONEHOOKSWITCHMODE_ONHOOK;
                    lstrcpy(pPhone->wszDialStr,TEXT(""));

                    if ( pPhone->pTonePlayer->IsInUse() )
                    {
                        pPhone->pTonePlayer->StopDialtone();
                    }

                    // ZoltanS: hide the window now
                    ShowWindow(ghDlg, SW_HIDE);


                    bDialtone = FALSE;
                    lstrcpy(g_wszMsg,TEXT("Generating Dialtone for phones: "));
                    for( i = 0 ; i < gdwNumPhoneDevs; i++ )
                    {
                        if ( gpPhone[i].pTonePlayer->DialtonePlaying() )
                        {
                            wsprintf(g_wszDest,TEXT("%d"),i);
                            lstrcat(g_wszMsg,g_wszDest);
                            bDialtone = TRUE;
                        }
                    }
                
                    if(!bDialtone)
                    {
                        SetStatusMessage(TEXT("Waiting for input from Phones"));
                    }
                    else
                    {
                        SetStatusMessage(g_wszMsg);
                    } 
                }
            }
            LeaveCriticalSection(&pPhone->csdial);
        }
        break;

    case PHONE_BUTTON:
        DEBUG(L"PHONE_BUTTON\n");
        if (pPhone != NULL)
        {
            EnterCriticalSection(&pPhone->csdial);
            if ( Param2 == PHONEBUTTONMODE_KEYPAD )
            {
                if (pPhone->dwHandsetMode != PHONEHOOKSWITCHMODE_ONHOOK)
                {
                    if ( Param3 == PHONEBUTTONSTATE_DOWN )
                    {
                        if ( pPhone->pTonePlayer->IsInUse() )
                        {
                            if ( ( (int)Param1 >= 0 ) && ( (int)Param1 <= 9 ) )
                            {   
                                //
                                // We have a dialed digit. Append it to the phone
                                // number we have so far.
                                //

                                wsprintf(g_wszDest, TEXT("%d"), Param1);

                                lstrcat(pPhone->wszDialStr, g_wszDest);

                                //
                                // Append the phone number so far to a standard prefix
                                // ("Phone number: ") and update the UI.
                                //

                                lstrcpy(g_wszMsg, g_szDialStr);

                                lstrcat(g_wszMsg,pPhone->wszDialStr);

                                SetStatusMessage(g_wszMsg);

                                //
                                // Generate a DTMF tone for this digit.
                                //

                                pPhone->pTonePlayer->GenerateDTMF( (long)Param1 );                    
                            }
                            else if ( Param1 == 10 )
                            {
                                //
                                // Generate a DTMF tone for "*". This will not count
                                // as part of the dialed number.
                                //

                                pPhone->pTonePlayer->GenerateDTMF( (long)Param1 );
                            }
                            else if ( Param1 == 11 )
                            {
                                //
                                // Generate a DTMF tone for "#". This will not count
                                // as part of the dialed number but it will tell us
                                // to make the call immediately.
                                //

                                pPhone->pTonePlayer->GenerateDTMF( (long)Param1 );

                                //
                                // Make the call.
                                //
                        
                                if ( S_OK == MakeAssistedTelephonyCall(pPhone->wszDialStr) )
                                {
                                    SetStatusMessage(L"Call created");
                                }
                                else
                                {
                                    SetStatusMessage(L"Failed to create the call");
                                }

                            }
                        } // if in use
                    } // if button down
                } // if off hook
            } // if keypad
            LeaveCriticalSection(&pPhone->csdial);
        }
        break; // case phone_button

    case PHONE_CLOSE:
        DEBUG(L"PHONE_CLOSE\n");
        if (pPhone != NULL)
        {
            EnterCriticalSection(&pPhone->csdial);

            phoneClose(pPhone->hPhone);   

            LeaveCriticalSection(&pPhone->csdial);
        }
        break;

    case PHONE_REMOVE:
        DEBUG(L"PHONE_REMOVE\n");
        pPhone = GetPhoneByID( (DWORD)Param1);

        if (pPhone != NULL)
        {
            FreePhone(pPhone);
            RemovePhone(pPhone);
        }
        break;

    case PHONE_CREATE:
        DEBUG(L"PHONE_CREATE\n");

        pPhone = AddPhone();
        CreatePhone(pPhone, (DWORD)Param1);
        break;

    default:
        break;
    }   
}

//////////////////////////////////////////////////////////////////
// SetStatusMessage
//////////////////////////////////////////////////////////////////

void
SetStatusMessage(
                 LPWSTR pszMessage
                )  
{
    SetDlgItemText(
                   ghDlg,
                   IDC_STATUS,
                   pszMessage
                  );
}

//////////////////////////////////////////////////////////////////
// CreatePhone
//////////////////////////////////////////////////////////////////

void
CreatePhone(
            PMYPHONE pPhone,
            DWORD dwDevID
            )
{
    LRESULT lResult;

    pPhone->hPhoneApp = ghPhoneApp;
    InitializeCriticalSection(&pPhone->csdial);

    // won't detect overrun if dialing more than 100 digits
    pPhone->wszDialStr   = (LPWSTR) LocalAlloc(LPTR, 100 * sizeof(WCHAR));
    pPhone->dwHandsetMode = PHONEHOOKSWITCHMODE_ONHOOK;

    lResult = phoneOpen(
                        ghPhoneApp,
                        dwDevID,
                        &pPhone->hPhone,
                        gdwAPIVersion,
                        0,
                        (DWORD_PTR) NULL,
                        PHONEPRIVILEGE_OWNER
                        );

    //
    // Save info about this phone that we can display later
    //
    
    pPhone->dwDevID      = dwDevID;
    pPhone->dwAPIVersion = gdwAPIVersion;
    pPhone->dwPrivilege  = PHONEPRIVILEGE_OWNER;

    DWORD dwBigBuffSize = sizeof(VARSTRING) + 
                          sizeof(DWORD) * 5;

    LPVOID pBuffer = LocalAlloc(LPTR,dwBigBuffSize);

    LPVARSTRING lpDeviceID = (LPVARSTRING) pBuffer;

    lpDeviceID->dwTotalSize = dwBigBuffSize;

    LPWSTR lpszDeviceClass;

    lpszDeviceClass = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * 20);
  
    lstrcpy(lpszDeviceClass, TEXT("wave/in"));

    lResult = phoneGetID(
                         pPhone->hPhone,          
                         lpDeviceID,  
                         lpszDeviceClass  
                        );

    if(lResult != 0)
    {
        pPhone->lCaptureID = WAVE_MAPPER;
    }
    else
    {
        CopyMemory(
                    &pPhone->lCaptureID,
                    (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                    lpDeviceID->dwStringSize
                   );
    }

   
    lstrcpy(lpszDeviceClass, TEXT("wave/out"));
    lResult = phoneGetID(
                         pPhone->hPhone,          
                         lpDeviceID,  
                         lpszDeviceClass  
                        );

    if(lResult != 0)
    {
        pPhone->lRenderID = WAVE_MAPPER;
    }
    else
    {
        CopyMemory(
                    &pPhone->lRenderID,
                    (LPBYTE) lpDeviceID + lpDeviceID->dwStringOffset,
                    lpDeviceID->dwStringSize
                   );
    }

    LocalFree(lpszDeviceClass);
    LocalFree(pBuffer);

    lResult = phoneSetStatusMessages(
                                     pPhone->hPhone,
                                     PHONESTATE_HANDSETHOOKSWITCH,
                                     PHONEBUTTONMODE_FEATURE | PHONEBUTTONMODE_KEYPAD,
                                     PHONEBUTTONSTATE_UP | PHONEBUTTONSTATE_DOWN
                                     );

    pPhone->pTonePlayer = new CTonePlayer;

    if ( (pPhone->pTonePlayer == NULL) ||
         FAILED(pPhone->pTonePlayer->Initialize()) )
    {
        DoMessage(L"Tone Player Initialization Failed");
    }
    else if ( FAILED(pPhone->pTonePlayer->OpenWaveDevice( pPhone->lRenderID )) )
    {
        DoMessage(L"OpenWaveDevice Failed");
    }

    if ( FAILED( InitAssistedTelephony() ) )
    {
        DoMessage(L"InitAssistedTelephony Failed");                
    }
}

//////////////////////////////////////////////////////////////////
// FreePhone
//////////////////////////////////////////////////////////////////

void
FreePhone(
            PMYPHONE pPhone
         )
{
    EnterCriticalSection(&pPhone->csdial);

    if ( pPhone->pTonePlayer->IsInUse() )
    {
        pPhone->pTonePlayer->StopDialtone();
        pPhone->pTonePlayer->CloseWaveDevice();
    }
    
    LocalFree(pPhone->wszDialStr);

    LeaveCriticalSection(&pPhone->csdial);

    DeleteCriticalSection(&pPhone->csdial);
}

///////////////////////////////////////////////////////////////////
// GetPhone
///////////////////////////////////////////////////////////////////

PMYPHONE
GetPhone (HPHONE hPhone )
{

    DWORD i;
    
    for(i = 0; i < gdwNumPhoneDevs; i++)
    {
        if(gpPhone[i].hPhone == hPhone)
        {
            return &gpPhone[i];
        }
    }
    
    return (PMYPHONE) NULL;    
}

///////////////////////////////////////////////////////////////////
// GetPhoneByID
///////////////////////////////////////////////////////////////////

PMYPHONE
GetPhoneByID (DWORD dwDevID )
{

    DWORD i;
    
    for(i = 0; i < gdwNumPhoneDevs; i++)
    {
        if(gpPhone[i].dwDevID == dwDevID)
        {
            return &gpPhone[i];
        }
    }
    
    return (PMYPHONE) NULL;    
}

///////////////////////////////////////////////////////////////////
// RemovePhone
///////////////////////////////////////////////////////////////////

void
RemovePhone (PMYPHONE pPhone)
{
    DWORD i,j;
    PMYPHONE pNewPhones;

    pNewPhones = (PMYPHONE) LocalAlloc(LPTR,(gdwNumPhoneDevs-1) * sizeof(MYPHONE));
    
    for(i = 0, j = 0; i < gdwNumPhoneDevs; i++)
    {
        if(&gpPhone[i] != pPhone)
        {
            CopyMemory( &pNewPhones[j], &gpPhone[i], sizeof(MYPHONE));
            j++;
        }
    }

    LocalFree(gpPhone);
    gpPhone = pNewPhones;
    gdwNumPhoneDevs--;
}

///////////////////////////////////////////////////////////////////
// AddPhone
///////////////////////////////////////////////////////////////////

PMYPHONE
AddPhone ()
{
    PMYPHONE pNewPhones;

    pNewPhones = (PMYPHONE) LocalAlloc(LPTR,(gdwNumPhoneDevs+1) * sizeof(MYPHONE));
    
    CopyMemory( pNewPhones, gpPhone, gdwNumPhoneDevs * sizeof(MYPHONE));

    LocalFree(gpPhone);
    gpPhone = pNewPhones;
    gdwNumPhoneDevs++;

    return &gpPhone[gdwNumPhoneDevs-1];
}
    
///////////////////////////////////////////////////////////////////
// DoMessage
///////////////////////////////////////////////////////////////////
void
DoMessage(
          LPWSTR pszMessage
         )
{
    MessageBox(
               ghDlg,
               pszMessage,
               gszTapi30,
               MB_OK
              );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\phonemgr\resource.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#define IDD_MAINDLG                     101
#define IDC_STATUS                      102
#define IDC_DESTADDRESS			103
#define IDC_MAKECALL			104

#define IDC_STATIC1                     201
#define IDC_STATIC2                     202
#define IDC_STATIC3                     203
#define IDC_STATIC4                     204

#define IDI_ICON1			301
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\resource.h ===
/* Copyright (c) 1999  Microsoft Corporation */

#define IDS_PROVIDER_INFO       201
#define IDS_PHONE_INFO          202
#define IDS_PHONE_NAME          203

#define IDS_BUTTON_FLASH           116
#define IDS_BUTTON_HOLD            117
#define IDS_BUTTON_REDIAL          118
#define IDS_BUTTON_TRANSFER        119
#define IDS_BUTTON_DROP           120
#define IDS_BUTTON_PARK            121
#define IDS_BUTTON_FORWARD         122
#define IDS_BUTTON_LINE              123    
#define IDS_BUTTON_CONFERENCE    124
#define IDS_BUTTON_RING_SELECT    125
#define IDS_BUTTON_MUTE            126
#define IDS_BUTTON_CALLERID        127
#define IDS_BUTTON_DONOTDISTURB    128
#define IDS_BUTTON_SEND            129
#define IDS_BUTTON_VOLUMEUP        130
#define IDS_BUTTON_VOLUMEDOWN      131

#define IDS_PHONE_KEY_0            100     
#define IDS_PHONE_KEY_1           101
#define IDS_PHONE_KEY_2           102    
#define IDS_PHONE_KEY_3           103
#define IDS_PHONE_KEY_4           104
#define IDS_PHONE_KEY_5           105
#define IDS_PHONE_KEY_6           106
#define IDS_PHONE_KEY_7           107
#define IDS_PHONE_KEY_8           108
#define IDS_PHONE_KEY_9           109    
#define IDS_PHONE_KEY_STAR         110
#define IDS_PHONE_KEY_POUND        111
#define IDS_PHONE_KEY_A            112
#define IDS_PHONE_KEY_B            113
#define IDS_PHONE_KEY_C            114
#define IDS_PHONE_KEY_D            115
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\phonemgr\tones.h ===
//
// tones.h
//

#ifndef _TONES_H_
#define _TONES_H_

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <wxdebug.h>

#define  WAVE_FILE_SIZE     1600
#define  NUM_DIGITS         12

//////////////////////////////////////////////////////////////////////////////
//
// class CTonePlayer
//
// Implements tone player for a single phone device.
//

class CTonePlayer
{
public:
    CTonePlayer();
    ~CTonePlayer();

    HRESULT Initialize(void);

    HRESULT OpenWaveDevice(long lWaveId);
    void    CloseWaveDevice(void);
    BOOL    IsInUse(void) { return (m_hWaveOut != NULL); }

    HRESULT StartDialtone(void);
    HRESULT StopDialtone(void);
    BOOL    DialtonePlaying(void) { return m_fDialtonePlaying; }

    HRESULT GenerateDTMF(long lDigit);

private:
    // TRUE if Initialize has succeeded.
    BOOL     m_fInitialized;

    BOOL     m_fDialtonePlaying;

    // Handle to the wave out device. NULL when the device is not open.
    HWAVEOUT m_hWaveOut;

    // Header structure that we submit to the wave device.
    WAVEHDR  m_WaveHeader;

    // buffer containing dialtone waveform
    BYTE     m_abDialtoneWaveform[ WAVE_FILE_SIZE ];

    // buffer containing all dtmf waveforms, concatenated in order, 0-9,*,#
    BYTE     m_abDigitWaveforms  [ NUM_DIGITS * WAVE_FILE_SIZE ];
};

#endif // _TONES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\phonemgr\tones.cpp ===
#include "tones.h"

//////////////////////////////////////////////////////////////////////////////
//
// Helper function used to read a wave file's data into an in-memory buffer.
//

HRESULT ReadWaveFile(char * szFileName, DWORD dwFileSize, BYTE * pbData)
{
    const int   WAVE_HEADER_SIZE = 44;
    FILE      * fp;
    size_t      result;


    //
    // Check arguments.
    //
    // Assumption: we are reading at least WAVE_HEADER_SIZE bytes from the file.
    // Note: this is data in addition to the header.
    //

    // _ASSERTE( ! IsBadWritePtr( pbData, dwFileSize ) );

    // _ASSERTE( ! IsBadStringPtr( szFileName, (UINT) -1 ) );

    if ( dwFileSize < WAVE_HEADER_SIZE )
    {
        return E_INVALIDARG;
    }


    //
    // Open the file for reading.
    //

    fp = fopen(szFileName, "rb");

    if ( fp == NULL )
    {
        return E_FAIL;
    }


    //
    // Skip the wave header.
    //
    
    result = fread(pbData, sizeof(BYTE), WAVE_HEADER_SIZE, fp);

    if ( result != WAVE_HEADER_SIZE )
    {
        fclose(fp);

        return E_FAIL;
    }


    //
    // Read the waveform from the file and close the file.
    //

    result = fread(pbData, sizeof(BYTE), dwFileSize, fp);


    fclose(fp);

    if ( result != dwFileSize )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

CTonePlayer::CTonePlayer()
{
    m_hWaveOut = NULL;
    m_fInitialized = FALSE;
    m_fDialtonePlaying = FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//

CTonePlayer::~CTonePlayer()
{
    //
    // We should have closed the wave device by now.
    //

    if ( m_fInitialized == TRUE )
    {
        ASSERT( m_hWaveOut == NULL );
    }
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::Initialize(void)
{
    int i;

    //
    // It's wasteful to initialize twice, but it won't break anything.
    //

    ASSERT( m_fInitialized == FALSE );

    //
    // Read all the files.
    //

    HRESULT hr = ReadWaveFile(
        "dialtone.wav",
        WAVE_FILE_SIZE,
        (BYTE * ) & m_abDialtoneWaveform
        );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // For each digit
    //

    for ( i = 0; i < NUM_DIGITS; i ++ )
    {
        //
        // Construct the filename for this digit.
        //
    
        char szFilename[20];

        if ( i < 10 )
        {
            sprintf(szFilename,"dtmf%d.wav", i);
        }
        else if ( i == 10 )
        {
            sprintf(szFilename,"dtmfstar.wav", i);
        }
        else if ( i == 11 )
        {
            sprintf(szFilename,"dtmfpound.wav", i);
        }
        else
        {
            ASSERT( FALSE );
        }

        //
        // Read the wave file for this digit.
        //

        HRESULT hr = ReadWaveFile(
            szFilename,
            WAVE_FILE_SIZE,
            (BYTE * ) ( & m_abDigitWaveforms ) + ( i * WAVE_FILE_SIZE )
            );

        if ( FAILED(hr) )
        { 
            return hr;
        }
    }

    //
    // We can now go ahead with the other methods.
    //

    m_fInitialized = TRUE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::StartDialtone(
    void
    )
{
    MMRESULT mmresult;

    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    //
    // Reset the wave device to flush out any pending buffers.
    //

    waveOutReset( m_hWaveOut );

    //
    // Construct a wave header structure that will indicate what to play
    // in waveOutWrite, and read in the data from the file. This can also
    // be done ahead of time.
    //

    ZeroMemory( & m_WaveHeader, sizeof( m_WaveHeader ) );

    m_WaveHeader.lpData          = (LPSTR) & m_abDialtoneWaveform;
    m_WaveHeader.dwBufferLength  = WAVE_FILE_SIZE;
    m_WaveHeader.dwFlags         = WHDR_BEGINLOOP | WHDR_ENDLOOP;
    m_WaveHeader.dwLoops         = (DWORD) -1;

    //
    // Submit the data to the wave device. The wave header indicated that
    // we want to loop. Need to prepare the header first, but it can
    // only be prepared after the device has been opened.
    //

    mmresult = waveOutPrepareHeader(m_hWaveOut,
                                    & m_WaveHeader,
                                    sizeof(WAVEHDR)
                                    );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    mmresult = waveOutWrite(m_hWaveOut,
                            & m_WaveHeader,
                            sizeof(WAVEHDR)
                            );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    m_fDialtonePlaying = TRUE;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// Reset the device to stop playing.
//

HRESULT CTonePlayer::StopDialtone( void )
{
    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    waveOutReset( m_hWaveOut );

    m_fDialtonePlaying = FALSE;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::GenerateDTMF(
    long lDigit
    )
{
    MMRESULT mmresult;

    if ( lDigit < 0 )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( lDigit > NUM_DIGITS )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    if ( m_hWaveOut == NULL )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
     
    //
    // Reset the wave device to flush out any pending buffers.
    //

    waveOutReset( m_hWaveOut );

    m_fDialtonePlaying = FALSE;

    //
    // Construct a wave header structure that will indicate what to play
    // in waveOutWrite, and read in the data from the file. This can also
    // be done ahead of time.
    //
 
    ZeroMemory( & m_WaveHeader, sizeof( m_WaveHeader ) );

    m_WaveHeader.lpData          = (LPSTR) & m_abDigitWaveforms + lDigit * WAVE_FILE_SIZE;
    m_WaveHeader.dwBufferLength  = WAVE_FILE_SIZE;
    m_WaveHeader.dwFlags         = 0;
    m_WaveHeader.dwLoops         = (DWORD) 0;

    //
    // Submit the data to the wave device. The wave header indicated that
    // we want to loop. Need to prepare the header first, but it can
    // only be prepared after the device has been opened.
    //

    mmresult = waveOutPrepareHeader(m_hWaveOut,
                                    & m_WaveHeader,
                                    sizeof(WAVEHDR)
                                    );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    mmresult = waveOutWrite(m_hWaveOut,
                            & m_WaveHeader,
                            sizeof(WAVEHDR)
                            );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

HRESULT CTonePlayer::OpenWaveDevice(
    long lWaveID
    )
{
    MMRESULT mmresult; 

    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }

    //
    // We expect that the wave device will not be opened twice. This is
    // dependent on the calling code.
    //

    ASSERT( m_hWaveOut == NULL );

    //
    // Open the wave device. Here we specify a hard-coded audio format.
    //

    WAVEFORMATEX waveFormat;

    waveFormat.wFormatTag      = WAVE_FORMAT_PCM; // linear PCM
    waveFormat.nChannels       = 1;               // mono
    waveFormat.nSamplesPerSec  = 8000;            // 8 KHz
    waveFormat.wBitsPerSample  = 16;              // 16-bit samples
    waveFormat.nBlockAlign     = waveFormat.nChannels * waveFormat.wBitsPerSample / 8;
    waveFormat.nAvgBytesPerSec = waveFormat.nSamplesPerSec *  waveFormat.nBlockAlign;
    waveFormat.cbSize          = 0;               // no extra format info

    mmresult = waveOutOpen(& m_hWaveOut,        // returned handle
                           lWaveID,             // which device to use
                           &waveFormat,         // wave format to use
                           0,                   // callback function pointer
                           0,                   // callback instance data
                           WAVE_FORMAT_DIRECT   // we don't want ACM
                           );

    if ( mmresult != MMSYSERR_NOERROR )
    {
        return E_FAIL;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//

void CTonePlayer::CloseWaveDevice(void)
{
    if ( m_fInitialized == FALSE )
    {
        ASSERT( FALSE );
    }

    ASSERT( m_hWaveOut != NULL );

    if ( m_hWaveOut != NULL )
    {
        waveOutClose( m_hWaveOut );

        m_hWaveOut = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\phonemgr\wxutil.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes for building multimedia filters
//

#include <streams.h>

//
//  Declare function from largeint.h we need so that PPC can build
//

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

#ifndef _X86_

#define LLtoU64(x) (*(unsigned __int64*)(void*)(&(x)))

__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
        // return remainder if necessary
        if (Remainder != NULL)
                *Remainder = (ULONG)(LLtoU64(Dividend) % Divisor);
        return (ULONG)(LLtoU64(Dividend) / Divisor);
}

#else
__inline
ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    )
{
    ULONG ulResult;
    _asm {
        mov eax,Dividend.LowPart
        mov edx,Dividend.HighPart
        mov ecx,Remainder
        div Divisor
        or  ecx,ecx
        jz  short label
        mov [ecx],edx
label:
        mov ulResult,eax
    }
    return ulResult;
}
#endif

// --- CAMEvent -----------------------
CAMEvent::CAMEvent(BOOL fManualReset)
{
    m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
    ASSERT(m_hEvent);
}

CAMEvent::~CAMEvent()
{
    if (m_hEvent) {
    EXECUTE_ASSERT(CloseHandle(m_hEvent));
    }
}


// --- CAMMsgEvent -----------------------
// One routine.  The rest is handled in CAMEvent

BOOL CAMMsgEvent::WaitMsg(DWORD dwTimeout)
{
    // wait for the event to be signalled, or for the
    // timeout (in MS) to expire.  allow SENT messages
    // to be processed while we wait
    DWORD dwWait;
    DWORD dwStartTime;

    // set the waiting period.
    DWORD dwWaitTime = dwTimeout;

    // the timeout will eventually run down as we iterate
    // processing messages.  grab the start time so that
    // we can calculate elapsed times.
    if (dwWaitTime != INFINITE) {
        dwStartTime = timeGetTime();
    }

    do {
        dwWait = MsgWaitForMultipleObjects(1,&m_hEvent,FALSE, dwWaitTime, QS_SENDMESSAGE);
        if (dwWait == WAIT_OBJECT_0 + 1) {
        MSG Message;
            PeekMessage(&Message,NULL,0,0,PM_NOREMOVE);

        // If we have an explicit length of time to wait calculate
        // the next wake up point - which might be now.
        // If dwTimeout is INFINITE, it stays INFINITE
        if (dwWaitTime != INFINITE) {

        DWORD dwElapsed = timeGetTime()-dwStartTime;

        dwWaitTime =
            (dwElapsed >= dwTimeout)
            ? 0  // wake up with WAIT_TIMEOUT
            : dwTimeout-dwElapsed;
        }
        }
    } while (dwWait == WAIT_OBJECT_0 + 1);

    // return TRUE if we woke on the event handle,
    //        FALSE if we timed out.
    return (dwWait == WAIT_OBJECT_0);
}

// --- CAMThread ----------------------


CAMThread::CAMThread()
    : m_EventSend(TRUE)     // must be manual-reset for CheckRequest()
{
    m_hThread = NULL;
}

CAMThread::~CAMThread() {
    Close();
}


// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CAMThread::InitialThreadProc(LPVOID pv)
{
    CAMThread * pThread = (CAMThread *) pv;

    return pThread->ThreadProc();
}

BOOL
CAMThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
    return FALSE;
    }

    m_hThread = CreateThread(
            NULL,
            0,
            CAMThread::InitialThreadProc,
            this,
            0,
            &threadid);

    if (!m_hThread) {
    return FALSE;
    }

    return TRUE;
}

DWORD
CAMThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
    return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// Wait for a request from the client
DWORD
CAMThread::GetRequest()
{
    m_EventSend.Wait();
    return m_dwParam;
}

// is there a request?
BOOL
CAMThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
    return FALSE;
    } else {
    if (pParam) {
        *pParam = m_dwParam;
    }
    return TRUE;
    }
}

// reply to the request
void
CAMThread::Reply(DWORD dw)
{
    m_dwReturnVal = dw;

    // The request is now complete so CheckRequest should fail from
    // now on
    //
    // This event should be reset BEFORE we signal the client or
    // the client may Set it before we reset it and we'll then
    // reset it (!)

    m_EventSend.Reset();

    // Tell the client we're finished

    m_EventComplete.Set();
}

HRESULT CAMThread::CoInitializeHelper()
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(0, COINIT_DISABLE_OLE1DDE );
        }
    }
    else
    {
        // caller must load ole32.dll
        DbgBreak("couldn't locate ole32.dll");
    }

    return hr;
}


// destructor for CMsgThread  - cleans up any messages left in the
// queue when the thread exited
CMsgThread::~CMsgThread()
{
    if (m_hThread != NULL) {
        WaitForSingleObject(m_hThread, INFINITE);
        EXECUTE_ASSERT(CloseHandle(m_hThread));
    }

    POSITION pos = m_ThreadQueue.GetHeadPosition();
    while (pos) {
        CMsg * pMsg = m_ThreadQueue.GetNext(pos);
        delete pMsg;
    }
    m_ThreadQueue.RemoveAll();

    if (m_hSem != NULL) {
        EXECUTE_ASSERT(CloseHandle(m_hSem));
    }
}

BOOL
CMsgThread::CreateThread(
    )
{
    m_hSem = CreateSemaphore(NULL, 0, 0x7FFFFFFF, NULL);
    if (m_hSem == NULL) {
        return FALSE;
    }

    m_hThread = ::CreateThread(NULL, 0, DefaultThreadProc,
                   (LPVOID)this, 0, &m_ThreadId);
    return m_hThread != NULL;
}


// This is the threads message pump.  Here we get and dispatch messages to
// clients thread proc until the client refuses to process a message.
// The client returns a non-zero value to stop the message pump, this
// value becomes the threads exit code.

DWORD WINAPI
CMsgThread::DefaultThreadProc(
    LPVOID lpParam
    )
{
    CMsgThread *lpThis = (CMsgThread *)lpParam;
    CMsg msg;
    LRESULT lResult;

    // !!!
    CoInitialize(NULL);

    // allow a derived class to handle thread startup
    lpThis->OnThreadInit();

    do {
    lpThis->GetThreadMsg(&msg);
    lResult = lpThis->ThreadMessageProc(msg.uMsg,msg.dwFlags,
                        msg.lpParam, msg.pEvent);
    } while (lResult == 0L);

    // !!!
    CoUninitialize();

    return (DWORD)lResult;
}


// Block until the next message is placed on the list m_ThreadQueue.
// copies the message to the message pointed to by *pmsg
void
CMsgThread::GetThreadMsg(CMsg *msg)
{
    CMsg * pmsg = NULL;

    // keep trying until a message appears
    while (TRUE) {
        {
            CAutoLock lck(&m_Lock);
            pmsg = m_ThreadQueue.RemoveHead();
            if (pmsg == NULL) {
                m_lWaiting++;
            } else {
                break;
            }
        }
        // the semaphore will be signalled when it is non-empty
        WaitForSingleObject(m_hSem, INFINITE);
    }
    // copy fields to caller's CMsg
    *msg = *pmsg;

    // this CMsg was allocated by the 'new' in PutThreadMsg
    delete pmsg;

}


// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

#ifndef UNICODE
// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR  lpReturn = lpString1;
    while (*lpString1++ = *lpString2++);

    return lpReturn;
}

// Windows 95 doesn't implement this, so we provide an implementation.
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    ASSERT(iMaxLength);
    LPWSTR  lpReturn = lpString1;
    if (iMaxLength) {
        while (--iMaxLength && (*lpString1++ = *lpString2++));

        // If we ran out of room (which will be the case if
        // iMaxLength is now 0) we still need to terminate the
        // string.
        if (!iMaxLength) *lpString1 = L'\0';
    }
    return lpReturn;
}

int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
    WCHAR c1 = *lpString1;
    WCHAR c2 = *lpString2;
    if (c1 != c2)
        return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);
    return 0;
}


int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
    WCHAR c1 = *lpString1;
    WCHAR c2 = *lpString2;
    if (c1 >= L'A' && c1 <= L'Z')
        c1 -= (WCHAR) (L'A' - L'a');
    if (c2 >= L'A' && c2 <= L'Z')
        c2 -= (WCHAR) (L'A' - L'a');
    
    if (c1 != c2)
        return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);

    return 0;
}


int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    )
{
    int i = -1;
    while (*(lpString+(++i)))
        ;
    return i;
}


int WINAPIV wsprintfWInternal(LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    char fmt[256]; // !!!
    char ach[256]; // !!!
    int i;

    va_list va;
    va_start(va, pszFmt);
    WideCharToMultiByte(GetACP(), 0, pszFmt, -1, fmt, 256, NULL, NULL);
    i = wvsprintfA(ach, fmt, va);
    va_end(va);

    MultiByteToWideChar(CP_ACP, 0, ach, -1, wszOut, i+1);

    return i;
}
#else

// need to provide the implementations in unicode for non-unicode
// builds linking with the unicode strmbase.lib
LPWSTR WINAPI lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcpyW(lpString1, lpString2);
}

LPWSTR WINAPI lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    )
{
    return lstrcpynW(lpString1, lpString2, iMaxLength);
}

int WINAPI lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcmpW(lpString1, lpString2);
}


int WINAPI lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return lstrcmpiW(lpString1, lpString2);
}


int WINAPI lstrlenWInternal(
    LPCWSTR lpString
    )
{
    return lstrlenW(lpString);
}


int WINAPIV wsprintfWInternal(
    LPWSTR wszOut, LPCWSTR pszFmt, ...)
{
    va_list va;
    va_start(va, pszFmt);
    int i = wvsprintfW(wszOut, pszFmt, va);
    va_end(va);
    return i;
}
#endif


// Helper function - convert int to WSTR
void WINAPI IntToWstr(int i, LPWSTR wstr)
{
#ifdef UNICODE
    wsprintf(wstr, L"%d", i);
#else
    TCHAR temp[32];
    wsprintf(temp, "%d", i);
    MultiByteToWideChar(CP_ACP, 0, temp, -1, wstr, 32);
#endif
} // IntToWstr


#if 0
void * memchrInternal(const void *pv, int c, size_t sz)
{
    BYTE *pb = (BYTE *) pv;
    while (sz--) {
    if (*pb == c)
        return (void *) pb;
    pb++;
    }
    return NULL;
}
#endif


#define MEMORY_ALIGNMENT        4
#define MEMORY_ALIGNMENT_LOG2   2
#define MEMORY_ALIGNMENT_MASK   MEMORY_ALIGNMENT - 1

void * __stdcall memmoveInternal(void * dst, const void * src, size_t count)
{
    void * ret = dst;

#ifdef _X86_
    if (dst <= src || (char *)dst >= ((char *)src + count)) {

        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            cld
            mov     edx,ecx
            and     edx,MEMORY_ALIGNMENT_MASK
            shr     ecx,MEMORY_ALIGNMENT_LOG2
            rep     movsd
            or      ecx,edx
            jz      memmove_done
            rep     movsb
memmove_done:
        }
    }
    else {

        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        _asm {
            mov     esi,src
            mov     edi,dst
            mov     ecx,count
            std
            add     esi,ecx
            add     edi,ecx
            dec     esi
            dec     edi
            rep     movsb
            cld
        }
    }
#else
    MoveMemory(dst, src, count);
#endif

    return ret;
}

/*  Arithmetic functions to help with time format conversions
*/

/*   Compute (a * b + d) / c */
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d)
{
    /*  Compute the absolute values to avoid signed arithmetic problems */
    ULARGE_INTEGER ua, ub;
    DWORDLONG uc;

    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub.QuadPart = (DWORDLONG)(b >= 0 ? b : -b);
    uc          = (DWORDLONG)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p[2];
    p[0].QuadPart  = UInt32x32To64(ua.LowPart, ub.LowPart);

    /*  This next computation cannot overflow into p[1].HighPart because
        the max number we can compute here is:

                 (2 ** 32 - 1) * (2 ** 32 - 1) +  // ua.LowPart * ub.LowPart
    (2 ** 32) *  (2 ** 31) * (2 ** 32 - 1) * 2    // x.LowPart * y.HighPart * 2

    == 2 ** 96 - 2 ** 64 + (2 ** 64 - 2 ** 33 + 1)
    == 2 ** 96 - 2 ** 33 + 1
    < 2 ** 96
    */

    ULARGE_INTEGER x;
    x.QuadPart     = UInt32x32To64(ua.LowPart, ub.HighPart) +
                     UInt32x32To64(ua.HighPart, ub.LowPart) +
                     p[0].HighPart;
    p[0].HighPart  = x.LowPart;
    p[1].QuadPart  = UInt32x32To64(ua.HighPart, ub.HighPart) + x.HighPart;

    if (d != 0) {
        ULARGE_INTEGER ud[2];
        if (bSign) {
            ud[0].QuadPart = (DWORDLONG)(-d);
            if (d > 0) {
                /*  -d < 0 */
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        } else {
            ud[0].QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud[1].QuadPart = (DWORDLONG)(LONGLONG)-1;
            } else {
                ud[1].QuadPart = (DWORDLONG)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud[0].LowPart + p[0].LowPart;
        p[0].LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud[0].HighPart + p[0].HighPart;
        p[0].HighPart      = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add MS DWORDLONGs - no carry expected */
        p[1].QuadPart     += ud[1].QuadPart + uliTotal.QuadPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p[1].HighPart < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p[0].QuadPart  = ~p[0].QuadPart;
            p[1].QuadPart  = ~p[1].QuadPart;
            p[0].QuadPart += 1;
            p[1].QuadPart += (p[0].QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p[1].QuadPart) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    DWORDLONG ullResult;

    /*  Do the division */
    /*  If the dividend is a DWORD_LONG use the compiler */
    if (p[1].QuadPart == 0) {
        ullResult = p[0].QuadPart / uc;
        return bSign ? -(LONGLONG)ullResult : (LONGLONG)ullResult;
    }

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER ulic;
    ulic.QuadPart = uc;
    if (ulic.HighPart == 0) {
        ULARGE_INTEGER uliDividend;
        ULARGE_INTEGER uliResult;
        DWORD dwDivisor = (DWORD)uc;
        // ASSERT(p[1].HighPart == 0 && p[1].LowPart < dwDivisor);
        uliDividend.HighPart = p[1].LowPart;
        uliDividend.LowPart = p[0].HighPart;
#ifndef USE_LARGEINT
        uliResult.HighPart = (DWORD)(uliDividend.QuadPart / dwDivisor);
        p[0].HighPart = (DWORD)(uliDividend.QuadPart % dwDivisor);
        uliResult.LowPart = 0;
        uliResult.QuadPart = p[0].QuadPart / dwDivisor + uliResult.QuadPart;
#else
        /*  NOTE - this routine will take exceptions if
            the result does not fit in a DWORD
        */
        if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
            uliResult.HighPart = EnlargedUnsignedDivide(
                                     uliDividend,
                                     dwDivisor,
                                     &p[0].HighPart);
        } else {
            uliResult.HighPart = 0;
        }
        uliResult.LowPart = EnlargedUnsignedDivide(
                                 p[0],
                                 dwDivisor,
                                 NULL);
#endif
        return bSign ? -(LONGLONG)uliResult.QuadPart :
                        (LONGLONG)uliResult.QuadPart;
    }


    ullResult = 0;

    /*  OK - do long division */
    for (int i = 0; i < 64; i++) {
        ullResult <<= 1;

        /*  Shift 128 bit p left 1 */
        p[1].QuadPart <<= 1;
        if ((p[0].HighPart & 0x80000000) != 0) {
            p[1].LowPart++;
        }
        p[0].QuadPart <<= 1;

        /*  Compare */
        if (uc <= p[1].QuadPart) {
            p[1].QuadPart -= uc;
            ullResult += 1;
        }
    }

    return bSign ? - (LONGLONG)ullResult : (LONGLONG)ullResult;
}


LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG d)
{
    ULARGE_INTEGER ua;
    DWORD ub;
    DWORD uc;

    /*  Compute the absolute values to avoid signed arithmetic problems */
    ua.QuadPart = (DWORDLONG)(a >= 0 ? a : -a);
    ub = (DWORD)(b >= 0 ? b : -b);
    uc = (DWORD)(c >= 0 ? c : -c);
    BOOL bSign = (a < 0) ^ (b < 0);

    /*  Do long multiplication */
    ULARGE_INTEGER p0;
    DWORD p1;
    p0.QuadPart  = UInt32x32To64(ua.LowPart, ub);

    if (ua.HighPart != 0) {
        ULARGE_INTEGER x;
        x.QuadPart     = UInt32x32To64(ua.HighPart, ub) + p0.HighPart;
        p0.HighPart  = x.LowPart;
        p1   = x.HighPart;
    } else {
        p1 = 0;
    }

    if (d != 0) {
        ULARGE_INTEGER ud0;
        DWORD ud1;

        if (bSign) {
            //
            //  Cast d to LONGLONG first otherwise -0x80000000 sign extends
            //  incorrectly
            //
            ud0.QuadPart = (DWORDLONG)(-(LONGLONG)d);
            if (d > 0) {
                /*  -d < 0 */
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        } else {
            ud0.QuadPart = (DWORDLONG)d;
            if (d < 0) {
                ud1 = (DWORD)-1;
            } else {
                ud1 = (DWORD)0;
            }
        }
        /*  Now do extended addition */
        ULARGE_INTEGER uliTotal;

        /*  Add ls DWORDs */
        uliTotal.QuadPart  = (DWORDLONG)ud0.LowPart + p0.LowPart;
        p0.LowPart       = uliTotal.LowPart;

        /*  Propagate carry */
        uliTotal.LowPart   = uliTotal.HighPart;
        uliTotal.HighPart  = 0;

        /*  Add 2nd most ls DWORDs */
        uliTotal.QuadPart += (DWORDLONG)ud0.HighPart + p0.HighPart;
        p0.HighPart      = uliTotal.LowPart;

        /*  Add MS DWORDLONGs - no carry expected */
        p1 += ud1 + uliTotal.HighPart;

        /*  Now see if we got a sign change from the addition */
        if ((LONG)p1 < 0) {
            bSign = !bSign;

            /*  Negate the current value (ugh!) */
            p0.QuadPart  = ~p0.QuadPart;
            p1 = ~p1;
            p0.QuadPart += 1;
            p1 += (p0.QuadPart == 0);
        }
    }

    /*  Now for the division */
    if (c < 0) {
        bSign = !bSign;
    }


    /*  This will catch c == 0 and overflow */
    if (uc <= p1) {
        return bSign ? (LONGLONG)0x8000000000000000 :
                       (LONGLONG)0x7FFFFFFFFFFFFFFF;
    }

    /*  Do the division */

    /*  If the divisor is a DWORD then its simpler */
    ULARGE_INTEGER uliDividend;
    ULARGE_INTEGER uliResult;
    DWORD dwDivisor = uc;
    uliDividend.HighPart = p1;
    uliDividend.LowPart = p0.HighPart;
    /*  NOTE - this routine will take exceptions if
        the result does not fit in a DWORD
    */
    if (uliDividend.QuadPart >= (DWORDLONG)dwDivisor) {
        uliResult.HighPart = EnlargedUnsignedDivide(
                                 uliDividend,
                                 dwDivisor,
                                 &p0.HighPart);
    } else {
        uliResult.HighPart = 0;
    }
    uliResult.LowPart = EnlargedUnsignedDivide(
                             p0,
                             dwDivisor,
                             NULL);
    return bSign ? -(LONGLONG)uliResult.QuadPart :
                    (LONGLONG)uliResult.QuadPart;
}

#ifdef DEBUG
/******************************Public*Routine******************************\
* Debug CCritSec helpers
*
* We provide debug versions of the Constructor, destructor, Lock and Unlock
* routines.  The debug code tracks who owns each critical section by
* maintaining a depth count.
*
* History:
*
\**************************************************************************/

CCritSec::CCritSec()
{
    InitializeCriticalSection(&m_CritSec);
    m_currentOwner = m_lockCount = 0;
    m_fTrace = FALSE;
}

CCritSec::~CCritSec()
{
    DeleteCriticalSection(&m_CritSec);
}

void CCritSec::Lock()
{
    UINT tracelevel=3;
    DWORD us = GetCurrentThreadId();
    DWORD currentOwner = m_currentOwner;
    if (currentOwner && (currentOwner != us)) {
        // already owned, but not by us
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 2, TEXT("Thread %d about to wait for lock %x owned by %d"),
                GetCurrentThreadId(), &m_CritSec, currentOwner));
            tracelevel=2;
        // if we saw the message about waiting for the critical
        // section we ensure we see the message when we get the
        // critical section
        }
    }
    EnterCriticalSection(&m_CritSec);
    if (0 == m_lockCount++) {
        // we now own it for the first time.  Set owner information
        m_currentOwner = us;
    //ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
    // only valid on NT
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, tracelevel, TEXT("Thread %d now owns lock %x"), m_currentOwner, &m_CritSec));
        }
    }
}

void CCritSec::Unlock() {
    if (0 == --m_lockCount) {
        // about to be unowned
        if (m_fTrace) {
            DbgLog((LOG_LOCKING, 3, TEXT("Thread %d releasing lock %x"), m_currentOwner, &m_CritSec));
        //ASSERT(((PRTL_CRITICAL_SECTION)&m_CritSec)->OwningThread == (HANDLE)m_currentOwner);
        // only valid on NT
        }
        m_currentOwner = 0;
    }
    LeaveCriticalSection(&m_CritSec);
}

void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace)
{
    pcCrit->m_fTrace = fTrace;
}

BOOL WINAPI CritCheckIn(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() == pcCrit->m_currentOwner);
}

BOOL WINAPI CritCheckOut(CCritSec * pcCrit)
{
    return (GetCurrentThreadId() != pcCrit->m_currentOwner);
}
#endif


typedef BSTR (STDAPICALLTYPE *LPSYSALLOCSTRING)(const OLECHAR FAR *);

// Dyna-link to SysAllocString to copy BSTR strings

STDAPI WriteBSTR(BSTR *pstrDest, LPCWSTR szSrc)
{
    LPSYSALLOCSTRING    lpfnSysAllocString;
    HINSTANCE        hInst;
    static const char    szSysAllocString[]      = "SysAllocString";

    //
    // Try to get the Ole32Aut.dll module handle.
    //

    hInst = LoadOLEAut32();
    if (hInst == NULL) {
    DWORD dwError = GetLastError();
    return HRESULT_FROM_WIN32(dwError);
    }
    lpfnSysAllocString = (LPSYSALLOCSTRING)GetProcAddress(hInst,
                              szSysAllocString);
    if (lpfnSysAllocString == NULL) {
    DWORD dwError = GetLastError();
    return HRESULT_FROM_WIN32(dwError);
    }

    *pstrDest = (*lpfnSysAllocString)(szSrc);

    return S_OK;
}


// Free an OLE BSTR through the task allocator

STDAPI FreeBSTR(BSTR* pstr)
{
    if (*pstr != NULL) {
        // get pointer to string
        DWORD* p = (DWORD*) (*pstr);

        // back up to point at DWORD length
        p--;

        // set pointer to null
        *pstr = NULL;

        // and free this
        CoTaskMemFree(p);

        return S_OK;
    } else {
        return S_FALSE;
    }
}


// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR psz, LPWSTR *ppszReturn)
{
    CheckPointer(ppszReturn, E_POINTER);
    ValidateReadWritePtr(ppszReturn, sizeof(LPWSTR));
    DWORD nameLen = sizeof(WCHAR) * (lstrlenW(psz)+1);
    *ppszReturn = (LPWSTR)CoTaskMemAlloc(nameLen);
    if (*ppszReturn == NULL) {
       return E_OUTOFMEMORY;
    }
    CopyMemory(*ppszReturn, psz, nameLen);
    return NOERROR;
}

// Waits for the HANDLE hObject.  While waiting messages sent
// to windows on our thread by SendMessage will be processed.
// Using this function to do waits and mutual exclusion
// avoids some deadlocks in objects with windows.
// Return codes are the same as for WaitForSingleObject
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd, UINT uMsg)
{
    BOOL bPeeked = FALSE;
    DWORD dwResult;
    DWORD dwStart;
    DWORD dwThreadPriority;

    static UINT uMsgId = 0;

    if (dwWait != INFINITE && dwWait != 0) {
        dwStart = GetTickCount();
    }
    for (; ; ) {
        DWORD dwTimeOut = dwWait;
        if (dwTimeOut > 10) {
            dwTimeOut = 10;
        }
        dwResult = MsgWaitForMultipleObjects(
                             1,
                             &hObject,
                             FALSE,
                             dwTimeOut,
                             hwnd == NULL ? QS_SENDMESSAGE :
                                            QS_SENDMESSAGE + QS_POSTMESSAGE);
        if (dwResult == WAIT_OBJECT_0 + 1 ||
            dwResult == WAIT_TIMEOUT && dwTimeOut != dwWait) {
            MSG msg;
            if (hwnd != NULL) {
                while (PeekMessage(&msg, hwnd, uMsg, uMsg, PM_REMOVE)) {
                    DispatchMessage(&msg);
                }
            }
            // Do this anyway - the previous peek doesn't flush out the
            // messages
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);

            if (dwWait != INFINITE && dwWait != 0) {
                DWORD dwNow = GetTickCount();

                // Working with differences handles wrap-around
                DWORD dwDiff = dwNow - dwStart;
                if (dwDiff > dwWait) {
                    dwWait = 0;
                } else {
                    dwWait -= dwDiff;
                }
                dwStart = dwNow;
            }
            if (!bPeeked) {
                //  Raise our priority to prevent our message queue
                //  building up
                dwThreadPriority = GetThreadPriority(GetCurrentThread());
                if (dwThreadPriority < THREAD_PRIORITY_HIGHEST) {
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
                }
                bPeeked = TRUE;
            }
        } else {
            break;
        }
    }
    if (bPeeked) {
        SetThreadPriority(GetCurrentThread(), dwThreadPriority);
        if (HIWORD(GetQueueStatus(QS_POSTMESSAGE)) & QS_POSTMESSAGE) {
            if (uMsgId == 0) {
                uMsgId = RegisterWindowMessage(TEXT("AMUnblock"));
            }
            if (uMsgId != 0) {
                MSG msg;
                //  Remove old ones
                while (PeekMessage(&msg, (HWND)-1, uMsgId, uMsgId, PM_REMOVE)) {
                }
            }
            PostThreadMessage(GetCurrentThreadId(), uMsgId, 0, 0);
        }
    }
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\apierror.h ===
/****************************************************************************
 *
 *	$Archive:   S:\sturgeon\src\include\vcs\apierror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the tERROR of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.30  $
 *	$Date:   26 Feb 1997 15:35:04  $
 *	$Author:   CHULME  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		Media Service Manager "public" header file. This file contains
 *		#defines, typedefs, struct definitions and prototypes used by
 *		and in conjunction with MSM. Any EXE or DLL which interacts with
 *		MSM will include this header file.
 *
 *	Notes:
 *
 ***************************************************************************/

#ifndef APIERROR_H
#define APIERROR_H

#include <objbase.h>

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus


#ifndef DllExport
#define DllExport	__declspec( dllexport )
#endif	// DllExport


// Prototype for function that converts HRESULT into a string.  The function
// and string resources are contained in NETMMERR.DLL.
//
typedef WORD	(*NETMMERR_ERRORTOSTRING)	(HRESULT, LPSTR, int);


extern DllExport BOOL GetResultUserString(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);
extern DllExport BOOL GetResultSubStrings(HRESULT hResult, LPSTR lpBuffer, int iBufferSize);


// This description was extracted from winerror.h.  It appears here only for
// the purpose of convenience.

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs.  SCODEs are no longer used.  The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


// Macro to create a custom HRESULT
//
#define MAKE_CUSTOM_HRESULT(sev,cus,fac,code) \
((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(cus)<<29) | ((unsigned long)(fac)<<16) | ((unsigned long)(code) & 0xffff)) )


// Macro to test for custom HRESULT
//
#define HRESULT_CUSTOM(hr)  (((hr) >> 29) & 0x1)



// Custom facility codes
//
#define FACILITY_BASE                          0x080
#define FACILITY_MSM                           (FACILITY_BASE +  1)
#define FACILITY_AUDIOMSP                      (FACILITY_BASE +  2)
#define FACILITY_VIDEOMSP                      (FACILITY_BASE +  3)
#define FACILITY_FILEIOMSP                     (FACILITY_BASE +  4)
#define FACILITY_CALLCONTROL                   (FACILITY_BASE +  5)
#define FACILITY_SESSIONMANAGER                (FACILITY_BASE +  6)
#define FACILITY_RTPCHANMAN                    (FACILITY_BASE +  7)
#define FACILITY_RTPMSP                        (FACILITY_BASE +  8)
#define FACILITY_RTPRTCPCONTROL                (FACILITY_BASE +  9)
#define FACILITY_WINSOCK                       (FACILITY_BASE + 10)
#define FACILITY_TESTMSP                       (FACILITY_BASE + 11)
#define FACILITY_MSM_SESSION_CLASSES           (FACILITY_BASE + 12)
#define FACILITY_SCRIPTING                     (FACILITY_BASE + 13)
#define FACILITY_Q931                          (FACILITY_BASE + 14)
#define FACILITY_WSCB                          (FACILITY_BASE + 15)
#define FACILITY_DRWS                          (FACILITY_BASE + 16)
#define FACILITY_ISDM                          (FACILITY_BASE + 17)
#define FACILITY_AUTOREG                       (FACILITY_BASE + 18)
#define FACILITY_CAPREG                        (FACILITY_BASE + 19)
#define FACILITY_H245WS                        (FACILITY_BASE + 20)
#define FACILITY_H245                          (FACILITY_BASE + 21)
#define FACILITY_ARSCLIENT                     (FACILITY_BASE + 22)
#define FACILITY_PPM                           (FACILITY_BASE + 23)
#define FACILITY_STRMSP                        (FACILITY_BASE + 24)
#define FACILITY_STRMAN                        (FACILITY_BASE + 25) 
#define FACILITY_MIXERMSP                      (FACILITY_BASE + 26) 
#define FACILITY_GKI                           (FACILITY_BASE + 27)
#define FACILITY_CCLOCK                        (FACILITY_BASE + 28)

#define FACILITY_WINSOCK2                      FACILITY_WINSOCK

// Macros to support custom error reporting
//
#define MAKE_MSM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_AUDIOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUDIOMSP, (error))
#define MAKE_VIDEOMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_VIDEOMSP, (error))
#define MAKE_FILEIOMSP_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_FILEIOMSP,(error))
#define MAKE_RTPCHANMAN_ERROR(error)           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPCHANNELMANAGER, (error))
#define MAKE_RTPMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_RTPMSP, (error))
#define MAKE_WINSOCK_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WINSOCK, (error))
#define MAKE_TESTMSP_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_TESTMSP, (error))
#define MAKE_MSM_SESSION_CLASSES_ERROR(error)  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MSM_SESSION_CLASSES, (error))
#define MAKE_SCRIPTING_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_SCRIPTING,(error))
#define MAKE_Q931_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_Q931, (error))
#define MAKE_WSCB_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_WSCB, (error))
#define MAKE_DRWS_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_DRWS, (error))
#define MAKE_ISDM_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ISDM, (error))
#define MAKE_AUTOREG_ERROR(error)              MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_AUTOREG, (error))
#define MAKE_CAPREG_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_CAPREG, (error))
#define MAKE_H245WS_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245WS, (error))
#define MAKE_H245_ERROR(error)                 MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_H245, (error))
#define MAKE_ARSCLIENT_ERROR(error)            MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_ARSCLIENT, (error))
#define MAKE_PPM_ERROR(error)                  MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_PPM, (error))
#define MAKE_STRMSP_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMSP, (error))
#define MAKE_STRMAN_ERROR(error)               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_STRMAN, (error))
#define MAKE_MIXERMSP_ERROR(error)             MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_MIXERMSP, (error))


// Error defines for MSM
//
//
#define ERROR_BASE_ID                          0x8000
#define ERROR_LOCAL_BASE_ID                    0xA000

//
// MessageId: ERROR_UNKNOWN
//
// MessageText:
//
//  An unkown error has occured in the system
//
#define ERROR_UNKNOWN					(ERROR_BASE_ID +  0)


//
// MessageId: ERROR_INVALID_BUFFER
//
// MessageText:
//
//  An invalid buffer handle was encountered.
//
#define ERROR_INVALID_BUFFER			(ERROR_BASE_ID +  1)


//
// MessageId: ERROR_INVALID_BUFFER_SIZE
//
// MessageText:
//
//  An invalid buffer size was encountered.
//
#define ERROR_INVALID_BUFFER_SIZE		(ERROR_BASE_ID +  2)


//
// MessageId: ERROR_INVALID_CALL_ORDER
//
// MessageText:
//
//  A bad call sequence was encountered.
//
#define ERROR_INVALID_CALL_ORDER		(ERROR_BASE_ID +  3)


//
// MessageId: ERROR_INVALID_CONFIG_SETTING
//
// MessageText:
//
//  A specified configuration parameter was invalid
//
#define ERROR_INVALID_CONFIG_SETTING	(ERROR_BASE_ID +  4)


//
// MessageId: ERROR_INVALID_LINK
//
// MessageText:
//
//  An invalid link handle was encountered.
//
#define ERROR_INVALID_LINK				(ERROR_BASE_ID +  5)


//
// MessageId: ERROR_INVALID_PORT
//
// MessageText:
//
//  An invalid port handle was encountered.
//
#define ERROR_INVALID_PORT				(ERROR_BASE_ID +  6)


//
// MessageId: ERROR_INVALID_SERVICE
//
// MessageText:
//
//  An invalid service handle was encountered.
//
#define ERROR_INVALID_SERVICE			(ERROR_BASE_ID +  7)


//
// MessageId: ERROR_INVALID_SERVICE_DLL
//
// MessageText:
//
//  The specified service DLL does not support required interface
//
#define ERROR_INVALID_SERVICE_DLL		(ERROR_BASE_ID +  8)


//
// MessageId: ERROR_INVALID_SERIVCE_ID
//
// MessageText:
//
//  The specified service was not located in the registry
//
#define ERROR_INVALID_SERVICE_ID		(ERROR_BASE_ID +  9)


//
// MessageId: ERROR_INVALID_SESSION
//
// MessageText:
//
//  An invalid session handle was encountered.
//
#define ERROR_INVALID_SESSION			(ERROR_BASE_ID + 10)


//
// MessageId: ERROR_INVALID_SYNC
//
// MessageText:
//
//  An invalid sync handle was encountered.
//
#define ERROR_INVALID_SYNC				(ERROR_BASE_ID + 11)

//
// MessageId: ERROR_INVALID_VERSION
//
// MessageText:
//
//  An invalid version of an object or structure was detected.
//
#define ERROR_INVALID_VERSION			(ERROR_BASE_ID + 12)

//
// MessageId: ERROR_BUFFER_LIMIT
//
// MessageText:
//
//  No buffers are available for performing this operation.
//
#define ERROR_BUFFER_LIMIT				(ERROR_BASE_ID + 13)

//
// MessageId: ERROR_INVALID_SKEY
//
// MessageText:
//
//  An invalid status key was encountered.
//
#define ERROR_INVALID_SKEY				(ERROR_BASE_ID + 14)

//
// MessageId: ERROR_INVALID_SVALUE
//
// MessageText:
//
//  An invalid status value was encountered.
//
#define ERROR_INVALID_SVALUE			(ERROR_BASE_ID + 15)



#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif // APIMSM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\blberr.h ===
#ifndef __SDPBLB_ERROR_CODES__
#define __SDPBLB_ERROR_CODES__

#include <sdperr.h>

// First four bits - SEVERITY(11), CUSTOMER FLAG(1), RESERVED(0)
#define SDPBLB_CONF_BLOB_DESTROYED                  0xe0000300



#endif // __SDPBLB_ERROR_CODES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\filerecordingterminal.h ===
// FileRecordingTerminal.h: interface for the CFileRecordingTerminal class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILERECORDINGTERMINAL_H__A8DDD920_08D7_4CE8_AB7F_9AD202D4E6B0__INCLUDED_)
#define AFX_FILERECORDINGTERMINAL_H__A8DDD920_08D7_4CE8_AB7F_9AD202D4E6B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "MultiTrackTerminal.h"
#include "..\terminals\Storage\RecordUnit.h"

#include "..\termmgr\resource.h"

#define MAX_MEDIA_TRACKS       (16)

extern const CLSID CLSID_FileRecordingTerminalCOMClass;


/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITMediaRecordVtbl : public ITMediaRecord
{
};

template <class T>
class  ITTerminalVtblFR : public ITTerminal
{
};
                                                                           
template <class T>
class  ITMediaControlVtblFR : public ITMediaControl
{
};


class CFileRecordingTerminal  : 
    public CComCoClass<CFileRecordingTerminal, &CLSID_FileRecordingTerminal>,
    public IDispatchImpl<ITMediaRecordVtbl<CFileRecordingTerminal>, &IID_ITMediaRecord, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITMediaControlVtblFR<CFileRecordingTerminal>, &IID_ITMediaControl, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITTerminalVtblFR<CFileRecordingTerminal>, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITPluggableTerminalInitialization,
    public CMSPObjectSafetyImpl,
    public CMultiTrackTerminal
{

public:

    DECLARE_REGISTRY_RESOURCEID(IDR_FILE_RECORDING)

    BEGIN_COM_MAP(CFileRecordingTerminal)
        COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
        COM_INTERFACE_ENTRY(ITMediaRecord)
        COM_INTERFACE_ENTRY(ITMediaControl)
        COM_INTERFACE_ENTRY(ITTerminal)
        COM_INTERFACE_ENTRY(ITPluggableTerminalInitialization)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_CHAIN(CMultiTrackTerminal)
    END_COM_MAP()


    //
    // ITTerminal methods
    //

    STDMETHOD(get_TerminalClass)(OUT  BSTR *pbstrTerminalClass);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pTerminalType);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pTerminalState);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);


    //
    // ITMediaRecord methods
    //

    virtual HRESULT STDMETHODCALLTYPE put_FileName( 
        IN BSTR bstrFileName
        );

    virtual HRESULT STDMETHODCALLTYPE get_FileName( 
         OUT BSTR *pbstrFileName);

    // 
    // ITPluggableTerminalInitialization methods
    //

    virtual HRESULT STDMETHODCALLTYPE InitializeDynamic (
	        IN IID                   iidTerminalClass,
	        IN DWORD                 dwMediaType,
	        IN TERMINAL_DIRECTION    Direction,
            IN MSP_HANDLE            htAddress
            );


    // 
    // ITMultiTrackTerminal methods
    //

    virtual HRESULT STDMETHODCALLTYPE CreateTrackTerminal(
            IN  long                  MediaType,
            IN  TERMINAL_DIRECTION    TerminalDirection,
            OUT ITTerminal         ** ppTerminal
            );

    virtual HRESULT STDMETHODCALLTYPE RemoveTrackTerminal(
            IN ITTerminal           * pTrackTerminalToRemove
            );

    //
    // ITMediaControl methods
    //

    virtual HRESULT STDMETHODCALLTYPE Start( void);
    
    virtual HRESULT STDMETHODCALLTYPE Stop( void);
    
    virtual HRESULT STDMETHODCALLTYPE Pause( void);
        
    virtual  HRESULT STDMETHODCALLTYPE get_MediaState( 
        OUT TERMINAL_MEDIA_STATE *pFileTerminalState);

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );


public:

    //
    // overriding IObjectSafety methods. we are only safe if properly 
    // initialized by terminal manager, so these methods will fail if this
    // is not the case.
    //

    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions);

    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions);


public:

	CFileRecordingTerminal();

	virtual ~CFileRecordingTerminal();


    //
    // cleanup before destructor to make sure cleanup is done by the time the 
    // derived ccomobject is going away.
    //

    void FinalRelease();


    //
    // the derived class, CComObject, implements these. Here declare as pure 
    // virtual so we can refer to these methods from ChildRelease and 
    // ChildAddRef()
    // 
    
    virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
    virtual ULONG STDMETHODCALLTYPE Release() = 0;


    //
    // these methods are called by the track terminals when they need to notify
    // us when their refcount changes. the implementation is in the Multitrack class
    // but we also need this here, so we can prevent calling base class if
    // destructor are being executed. otherwise, CComObject's addref and release
    // might be called from ~CRecordingTerminal, at which point CComObject is 
    // already gone, which is not good.
    //

    virtual void ChildAddRef();
    virtual void ChildRelease();


    //
    // each track calls this method after it has been selected
    //

    HRESULT OnFilterConnected(CBRenderFilter *pRenderingFilter);

    
    //
    // this function is called whevever there is an event from the recording filter graph
    //

    HRESULT HandleFilterGraphEvent(long lEventCode, ULONG_PTR lParam1, ULONG_PTR lParam2);


private:


    //
    // a helper method that removes all the tracks. not thread safe.
    //

    HRESULT ShutdownTracks();


    //
    // a helper method that fires events on one of the tracks
    //

    HRESULT FireEvent(
            TERMINAL_MEDIA_STATE tmsState,
            FT_STATE_EVENT_CAUSE ftecEventCause,
            HRESULT hrErrorCode
            );



    //
    // a helper method that causes a state transition
    //

    HRESULT DoStateTransition(TERMINAL_MEDIA_STATE tmsDesiredState);

private:

    //
    // storage used for recording
    //

    CRecordingUnit *m_pRecordingUnit;


    //
    // the name of the file that is currently playing
    //

    BSTR m_bstrFileName;


    //
    // current terminal state
    //

    TERMINAL_MEDIA_STATE m_enState;


    //
    // current terminal state (selected?)
    //

    BOOL  m_TerminalInUse;


    //
    // address handle
    //

    MSP_HANDLE  m_mspHAddress;


    //
    // this terminal should only be instantiated in the context of terminal 
    // manager. the object will only be safe for scripting if it has been 
    // InitializeDynamic'ed. 
    //
    // this flag will be set when InitializeDynamic succeeds
    //

    BOOL m_bKnownSafeContext;


    //
    // this flag is set when the object is going away to prevent problems with 
    // tracks notifying the parent of addref/release after CComObject's 
    // desctructor completed
    //

    BOOL m_bInDestructor;

};

#endif // !defined(AFX_FILERECORDINGTERMINAL_H__A8DDD920_08D7_4CE8_AB7F_9AD202D4E6B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\av_asn1.h ===
#ifndef _MS_AV_ASN1_H_
#define _MS_AV_ASN1_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

// lonchanc: copied from ossdll.h
#define DLL_ENTRY       WINAPI
#define DLL_ENTRY_FDEF  WINAPI
#define DLL_ENTRY_FPTR  WINAPI


extern ASN1module_t     Q931ASN_Module;

#define q931asn         Q931ASN_Module
#define ObjectID_       ASN1objectidentifier_s

typedef ASN1bool_t      ASN1_BOOL;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}
    ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}
    ASN1_BUF;

int Q931_InitModule(void);
int Q931_TermModule(void);
int Q931_InitWorld(ASN1_CODER_INFO *pWorld);
int Q931_TermWorld(ASN1_CODER_INFO *pWorld);
int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize);
int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize);

int H245_InitModule(void);
int H245_TermModule(void);
int H245_InitWorld(ASN1_CODER_INFO *pWorld);
int H245_TermWorld(ASN1_CODER_INFO *pWorld);
int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);




__inline freePDU(ASN1_CODER_INFO *pWorld, int nPDU, void *pDecoded, ASN1module_t pModule)
{
    ASN1_FreeDecoded(pWorld->pDecInfo, pDecoded, nPDU);
    return ASN1_SUCCESS;
}


#ifdef __cplusplus
}
#endif

#endif // _MS_AV_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\fpbridge.h ===
//
// FPPriv.h
//

#ifndef __FP_BRIDGE__
#define __FP_BRIDGE__

#include <OBJBASE.h>
#include <INITGUID.H>


// {7CFF69E2-FF93-4f48-BD94-F73D28589613}
DEFINE_GUID(IID_IFPBridge, 
0x7cff69e2, 0xff93, 0x4f48, 0xbd, 0x94, 0xf7, 0x3d, 0x28, 0x58, 0x96, 0x13);

//
// IFPBridge
//
DECLARE_INTERFACE_(
    IFPBridge, IUnknown)
{
    STDMETHOD (Deliver) (
        IN  long            nMediaType,
        IN  IMediaSample*   pSample
        ) = 0;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\hidtsp\phonemgr\wxutil.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// helper classes and functions for building multimedia filters
//

#ifndef __WXUTIL__
#define __WXUTIL__

// eliminate spurious "statement has no effect" warnings.
#pragma warning(disable: 4705)

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

#ifdef DEBUG
public:
    DWORD   m_currentOwner;
    DWORD   m_lockCount;
    BOOL    m_fTrace;        // Trace this one
public:
    CCritSec();
    ~CCritSec();
    void Lock();
    void Unlock();
#else

public:
    CCritSec() {
    InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
    DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
    EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
    LeaveCriticalSection(&m_CritSec);
    };
#endif
};

//
// To make deadlocks easier to track it is useful to insert in the
// code an assertion that says whether we own a critical section or
// not.  We make the routines that do the checking globals to avoid
// having different numbers of member functions in the debug and
// retail class implementations of CCritSec.  In addition we provide
// a routine that allows usage of specific critical sections to be
// traced.  This is NOT on by default - there are far too many.
//

#ifdef DEBUG
    BOOL WINAPI CritCheckIn(CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(CCritSec * pcCrit);
    void WINAPI DbgLockTrace(BOOL fTrace);
#else
    #define CritCheckIn(x) TRUE
    #define CritCheckOut(x) TRUE
    #define DbgLockTrace(pc, fT)
#endif


// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE);
    ~CAMEvent();

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
    return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    void Reset() { ResetEvent(m_hEvent); };
    BOOL Check() { return Wait(0); };
};


// wrapper for event objects that do message processing
// This adds ONE method to the CAMEvent object to allow sent
// messages to be processed while waiting

class CAMMsgEvent : public CAMEvent
{

public:

    // Allow SEND messages to be processed while waiting
    BOOL WaitMsg(DWORD dwTimeout = INFINITE);
};

// old name supported for the time being
#define CTimeoutEvent CAMEvent

// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CAMThread {

    // make copy constructor and assignment operator inaccessible

    CAMThread(const CAMThread &refThread);
    CAMThread &operator=(const CAMThread &refThread);

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

protected:
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CAMThread();
    ~CAMThread();

    CCritSec m_AccessLock;    // locks access by client threads
    CCritSec m_WorkerLock;    // locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};


// CQueue
//
// Implements a simple Queue ADT.  The queue contains a finite number of
// objects, access to which is controlled by a semaphore.  The semaphore
// is created with an initial count (N).  Each time an object is added
// a call to WaitForSingleObject is made on the semaphore's handle.  When
// this function returns a slot has been reserved in the queue for the new
// object.  If no slots are available the function blocks until one becomes
// available.  Each time an object is removed from the queue ReleaseSemaphore
// is called on the semaphore's handle, thus freeing a slot in the queue.
// If no objects are present in the queue the function blocks until an
// object has been added.

#define DEFAULT_QUEUESIZE   2

template <class T> class CQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T              *QueueObjects;   // Array of objects (ptr's to void)

    void Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);
        QueueObjects = new T[n];
    }


public:
    CQueue(int n) {
        Initialize(n);
    }

    CQueue() {
        Initialize(DEFAULT_QUEUESIZE);
    }

    ~CQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T GetQueueObject() {
        int iSlot;
        T Object;
        LONG lPrevious;

        // Wait for someone to put something on our queue, returns straight
        // away is there is already an object on the queue.
        //
        WaitForSingleObject(hSemGet, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet++ % nMax;
        Object = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return Object;
    }

    void PutQueueObject(T Object) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut++ % nMax;
        QueueObjects[iSlot] = Object;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};

// miscellaneous string conversion functions
// NOTE: as we need to use the same binaries on Win95 as on NT this code should
// be compiled WITHOUT unicode being defined.  Otherwise we will not pick up
// these internal routines and the binary will not run on Win95.

int WINAPIV wsprintfWInternal(LPWSTR, LPCWSTR, ...);

LPWSTR
WINAPI
lstrcpyWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    );
int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
int
WINAPI
lstrcmpiWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );
int
WINAPI
lstrlenWInternal(
    LPCWSTR lpString
    );

#ifndef UNICODE
#define wsprintfW wsprintfWInternal
#define lstrcpyW lstrcpyWInternal
#define lstrcpynW lstrcpynWInternal
#define lstrcmpW lstrcmpWInternal
#define lstrcmpiW lstrcmpiWInternal
#define lstrlenW lstrlenWInternal
#endif

extern "C"
void * __stdcall memmoveInternal(void *, const void *, size_t);

inline void * __cdecl memchrInternal(const void *buf, int chr, size_t cnt)
{
#ifdef _X86_
    void *pRet = NULL;

    _asm {
        cld                 // make sure we get the direction right
        mov     ecx, cnt    // num of bytes to scan
        mov     edi, buf    // pointer byte stream
        mov     eax, chr    // byte to scan for
        repne   scasb       // look for the byte in the byte stream
        jnz     exit_memchr // Z flag set if byte found
        dec     edi         // scasb always increments edi even when it
                            // finds the required byte
        mov     pRet, edi
exit_memchr:
    }
    return pRet;

#else
    while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
        buf = (unsigned char *)buf + 1;
        cnt--;
    }

    return(cnt ? (void *)buf : NULL);
#endif
}

void WINAPI IntToWstr(int i, LPWSTR wstr);

#define WstrToInt(sz) atoiW(sz)

inline int atoiW(const WCHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= L'0' && *sz <= L'9')
        i = i*10 + *sz++ - L'0';
        
    return i;        
}

inline int WINAPI atoiA(const CHAR *sz)
{
    int i = 0;

    while (*sz && *sz >= '0' && *sz <= '9')
        i = i*10 + *sz++ - '0';
        
    return i;        
}

#ifdef UNICODE
#define atoi    atoiW
#else
#define atoi    atoiA
#endif



// These are available to help managing bitmap VIDEOINFOHEADER media structures

extern const DWORD bits555[3];
extern const DWORD bits565[3];
extern const DWORD bits888[3];

// These help convert between VIDEOINFOHEADER and BITMAPINFO structures

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(WORD) GetBitCount(const GUID *pSubtype);

// strmbase.lib implements this for compatibility with people who
// managed to link to this directly.  we don't want to advertise it.
//
// STDAPI_(/* T */ CHAR *) GetSubtypeName(const GUID *pSubtype);

STDAPI_(CHAR *) GetSubtypeNameA(const GUID *pSubtype);
STDAPI_(WCHAR *) GetSubtypeNameW(const GUID *pSubtype);

#ifdef UNICODE
#define GetSubtypeName GetSubtypeNameW
#else
#define GetSubtypeName GetSubtypeNameA
#endif

STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo);
STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo);


// Compares two interfaces and returns TRUE if they are on the same object
BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond);

// This is for comparing pins
#define EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2)


// Arithmetic helper functions

// Compute (a * b + rnd) / c
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd);
LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd);


// Avoids us dyna-linking to SysAllocString to copy BSTR strings
STDAPI WriteBSTR(BSTR * pstrDest, LPCWSTR szSrc);
STDAPI FreeBSTR(BSTR* pstr);

// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR pszString, LPWSTR *ppszReturn);

// Special wait for objects owning windows
DWORD WINAPI WaitDispatchingMessages(HANDLE hObject, DWORD dwWait, HWND hwnd = NULL, UINT uMsg = 0);
#endif /* __WXUTIL__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\formats.h ===
//
// FORMATS.H
//

#ifndef __STREAM_FORMATS__
#define __STREAM_FORMATS__

#include <amvideo.h>

class CTAudioFormat :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITScriptableAudioFormat, &IID_ITScriptableAudioFormat, &LIBID_TAPI3Lib>,
    public CMSPObjectSafetyImpl
{
public:
    CTAudioFormat();
    ~CTAudioFormat();

DECLARE_GET_CONTROLLING_UNKNOWN()

virtual HRESULT FinalConstruct(void);

public:

    BEGIN_COM_MAP(CTAudioFormat)
        COM_INTERFACE_ENTRY(ITScriptableAudioFormat)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP()

public:
    STDMETHOD(get_Channels)(
        OUT long* pVal
        );

    STDMETHOD(put_Channels)(
        IN    const long nNewVal
        );

    STDMETHOD(get_SamplesPerSec)(
        OUT long* pVal
        );

    STDMETHOD(put_SamplesPerSec)(
        IN    const long nNewVal
        );

    STDMETHOD(get_AvgBytesPerSec)(
        OUT long* pVal
        );

    STDMETHOD(put_AvgBytesPerSec)(
        IN    const long nNewVal
        );

    STDMETHOD(get_BlockAlign)(
        OUT long* pVal
        );

    STDMETHOD(put_BlockAlign)(
        IN    const long nNewVal
        );

    STDMETHOD(get_BitsPerSample)(
        OUT long* pVal
        );

    STDMETHOD(put_BitsPerSample)(
        IN    const long nNewVal
        );

    STDMETHOD(get_FormatTag)(
        OUT long* pVal
        );

    STDMETHOD(put_FormatTag)(
        IN const long nNewVal
        );

private:
    WAVEFORMATEX        m_wfx;        // Waveformat structure
    CMSPCritSection     m_Lock;     // Critical section
    IUnknown*            m_pFTM;     // pointer to the free threaded marshaler

public:
    HRESULT Initialize(
        IN const WAVEFORMATEX* pwfx
        )
    {
        //
        // Don't care right now for the buffer
        // 
 
        m_wfx = *pwfx;
        m_wfx.cbSize = 0;
        return S_OK;
    }
};


/*

class CTVideoFormat :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITScriptableVideoFormat, &IID_ITScriptableVideoFormat, &LIBID_TAPI3Lib>,
    public CMSPObjectSafetyImpl
{
public:
    CTVideoFormat();
    ~CTVideoFormat();

DECLARE_GET_CONTROLLING_UNKNOWN()

virtual HRESULT FinalConstruct(void);

public:
    BEGIN_COM_MAP(CTVideoFormat)
        COM_INTERFACE_ENTRY(ITScriptableVideoFormat)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP()
public:
    STDMETHOD(get_BitRate)(
        OUT long* pVal
        );

    STDMETHOD(put_BitRate)(
        IN const long nNewVal
        );

    STDMETHOD(get_BitErrorRate)(
        OUT long* pVal
        );

    STDMETHOD(put_BitErrorRate)(
        IN const long nNewVal
        );

    STDMETHOD(get_AvgTimePerFrame)(
        OUT double* pVal
        );

    STDMETHOD(put_AvgTimePerFrame)(
        IN const double nNewVal
        );

    STDMETHOD(get_Width)(
        OUT long* pVal
        );

    STDMETHOD(put_Width)(
        IN const long nNewVal
        );

    STDMETHOD(get_Height)(
        OUT long* pVal
        );

    STDMETHOD(put_Height)(
        IN const long nNewVal
        );

    STDMETHOD(get_BitCount)(
        OUT long* pVal
        );

    STDMETHOD(put_BitCount)(
        IN const long nNewVal
        );

    STDMETHOD(get_Compression)(
        OUT long* pVal
        );

    STDMETHOD(put_Compression)(
        IN const long nNewVal
        );

    STDMETHOD(get_SizeImage)(
        OUT long* pVal
        );

    STDMETHOD(put_SizeImage)(
        IN const long nNewVal
        );

private:
    VIDEOINFOHEADER m_vih;            // Video structure
    CMSPCritSection     m_Lock;     // Critical section
    IUnknown*            m_pFTM;     // pointer to the free threaded marshaler

public:
    HRESULT Initialize(
        IN const VIDEOINFOHEADER* pvih
        )
    {
        m_vih = *pvih;
        return S_OK;
    }
};

*/

#endif

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\fpterm.h ===
//
// FPTerm.h
//

#ifndef __FPTERMINAL__
#define __FPTERMINAL__

#include "MultiTrackTerminal.h"

#include "..\terminals\Storage\FPUnit.h"
#include "fpbridge.h"

extern const CLSID CLSID_FilePlaybackTerminalCOMClass;

typedef enum
{
    TCS_NONE = 0,
    TCS_TOBECREATED,
    TCS_CREATED
} TRACK_CREATIONSTATE;

typedef struct
{
    TRACK_CREATIONSTATE CreationState;
    AM_MEDIA_TYPE*      pMediaType;
} TRACK_INFO;

typedef enum
{
    TRACK_AUDIO = 0,
    TRACK_VIDEO
} TRACK_MEDIATYPE;

//
// FilePlayback Terminal
// This is the class that implements the multitrack termnal
//

/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITMediaPlaybackVtbl : public ITMediaPlayback
{
};

template <class T>
class  ITTerminalVtbl : public ITTerminal
{
};
                                                                           
template <class T>
class  ITMediaControlVtbl : public ITMediaControl
{
};
                                                                           

//
// FilePlayback Terminal
// This is the class that implements the multitrack termnal
//

class CFPTerminal :
    public CComCoClass<CFPTerminal, &CLSID_FilePlaybackTerminal>,
    public IDispatchImpl<ITMediaPlaybackVtbl<CFPTerminal>, &IID_ITMediaPlayback, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITTerminalVtbl<CFPTerminal>, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITPluggableTerminalInitialization,
    public ITPluggableTerminalEventSinkRegistration,
    public IFPBridge,
    public IDispatchImpl<ITMediaControlVtbl<CFPTerminal>, &IID_ITMediaControl, &LIBID_TAPI3Lib>,
    public CMSPObjectSafetyImpl,
    public CMultiTrackTerminal
{
public:
    //
    // Constructor / Destructor
    //
    CFPTerminal();
    ~CFPTerminal();

    DECLARE_NOT_AGGREGATABLE(CFPTerminal) 
    DECLARE_GET_CONTROLLING_UNKNOWN()

    virtual HRESULT FinalConstruct(void);

public:

    DECLARE_REGISTRY_RESOURCEID(IDR_FILE_PLAYBACK)

    BEGIN_COM_MAP(CFPTerminal)
        COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
        COM_INTERFACE_ENTRY(ITMediaPlayback)
        COM_INTERFACE_ENTRY(ITTerminal)
        COM_INTERFACE_ENTRY(ITPluggableTerminalInitialization)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(ITMediaControl)
        COM_INTERFACE_ENTRY(ITPluggableTerminalEventSinkRegistration)
        COM_INTERFACE_ENTRY(IFPBridge)
        COM_INTERFACE_ENTRY_CHAIN(CMultiTrackTerminal)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    // --- ITTeminal ---

    STDMETHOD(get_TerminalClass)(
        OUT  BSTR *pVal);

    STDMETHOD(get_TerminalType)(
        OUT  TERMINAL_TYPE *pVal);

    STDMETHOD(get_State)(
        OUT  TERMINAL_STATE *pVal);

    STDMETHOD(get_Name)(
        OUT  BSTR *pVal);

    STDMETHOD(get_MediaType)(
        OUT  long * plMediaType);

    STDMETHOD(get_Direction)(
        OUT  TERMINAL_DIRECTION *pDirection);

    // --- ITMediaPlayback ---

    virtual HRESULT STDMETHODCALLTYPE put_PlayList(
        IN  VARIANTARG  PlayListVariant 
        );

    virtual HRESULT STDMETHODCALLTYPE get_PlayList(
        OUT  VARIANTARG*  pPlayListVariant 
        );

    // --- ITPluggableTerminalInitialization ---

    virtual HRESULT STDMETHODCALLTYPE InitializeDynamic (
            IN IID                   iidTerminalClass,
            IN DWORD                 dwMediaType,
            IN TERMINAL_DIRECTION    Direction,
            IN MSP_HANDLE            htAddress);

    // --- ITMediaControl ---

    virtual HRESULT STDMETHODCALLTYPE Start( void);
    
    virtual HRESULT STDMETHODCALLTYPE Stop( void);
    
    virtual HRESULT STDMETHODCALLTYPE Pause( void);
        
    virtual  HRESULT STDMETHODCALLTYPE get_MediaState( 
        OUT TERMINAL_MEDIA_STATE *pTerminalMediaState);
    
    // --- CMultiTrackTerminal ---
    virtual HRESULT STDMETHODCALLTYPE CreateTrackTerminal(
                IN long MediaType,
                IN TERMINAL_DIRECTION TerminalDirection,
                OUT ITTerminal **ppTerminal
                );

    // this function is not accessible on the playback terminal
    // so override it to retutn E_NOTSUPPORTED
    virtual HRESULT STDMETHODCALLTYPE RemoveTrackTerminal(
            IN ITTerminal           * pTrackTerminalToRemove
            );


    // --- ITPluggableTerminalEventSinkRegistration ---
    STDMETHOD(RegisterSink)(
        IN  ITPluggableTerminalEventSink *pSink
        );

    STDMETHOD(UnregisterSink)();

    // --- IFPBridge ---
    STDMETHOD(Deliver)(
        IN  long            nMediaType,
        IN  IMediaSample*   pSample
        );

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );


public:

    //
    // overriding IObjectSafety methods. we are only safe if properly 
    // initialized by terminal manager, so these methods will fail if this
    // is not the case.
    //

    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions);

    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions, 
                                         DWORD *pdwEnabledOptions);


private:
    // --- Memebers --
    TERMINAL_MEDIA_STATE  m_State;              // Terminal current state
    CMSPCritSection     m_Lock;                 // Critical section
    ITPluggableTerminalEventSink* m_pEventSink; // Fire events to client

    // --- Terminal attributes ---
    MSP_HANDLE          m_htAddress;            // MSP address handle
    IID                 m_TerminalClassID;      // TerminalClass
    TERMINAL_DIRECTION  m_Direction;            // Direction
    TERMINAL_STATE      m_TerminalState;        // Terminal State
    DWORD               m_dwMediaTypes;         // Media types supported
    TCHAR               m_szName[MAX_PATH+1];   // Terminal friendly name

    int                 m_nPlayIndex;           // Index of playing storage
    VARIANT             m_varPlayList;          // The playlist

    IUnknown*            m_pFTM;                // pointer to the free threaded marshaler

    CPlaybackUnit*      m_pPlaybackUnit;        // The playback graph


    HRESULT ValidatePlayList(
        IN  VARIANTARG  varPlayList,
        OUT long*       pnLeftBound,
        OUT long*       pnRightBound
        );

    HRESULT RollbackTrackInfo();

    //
    // uninitialize all tracks and remove them from the list of managed tracks
    //

    HRESULT ShutdownTracks();


    //
    // uninitialize a given track and remove it from the list of managed tracks
    //

    HRESULT InternalRemoveTrackTerminal(
                      IN ITTerminal *pTrackTerminalToRemove
                      );


    //
    // a helper method that fires events on one of the tracks
    //

    HRESULT FireEvent(
        TERMINAL_MEDIA_STATE tmsState,
        FT_STATE_EVENT_CAUSE ftecEventCause,
        HRESULT hrErrorCode
        );


    //
    // a helper method that attempts to stop all tracks
    //
    
    HRESULT StopAllTracks();

    BSTR    GetFileNameFromPlayList(
        IN  VARIANTARG  varPlayList,
        IN  long        nIndex
        );

    //
    // Create the playback graph
    //
    HRESULT CreatePlaybackUnit(
        IN  BSTR    bstrFileName
        );

	//
	// Play a file from the list
	//
	HRESULT ConfigurePlaybackUnit(
		IN	BSTR    bstrFileName
		);

    //
    // Helper method that causes a state transition
    //

    HRESULT DoStateTransition(
        IN  TERMINAL_MEDIA_STATE tmsDesiredState
        );

    //
    // Create a track for a specific media
    //

    HRESULT CreateMediaTracks(
        IN  long            nMediaType
        );

    HRESULT NextPlayIndex(
        );

public:

    //
    // Returns a track for a media type
    //
    int TracksCreated(
        IN  long    lMediaType
        );

    //
    // a helper method called by tracks when they decide to make a state change.
    //

    HRESULT TrackStateChange(TERMINAL_MEDIA_STATE tmsState,
                             FT_STATE_EVENT_CAUSE ftecEventCause,
                             HRESULT hrErrorCode);

    HRESULT PlayItem(
        IN  int nItem
        );

private:

    //
    // this terminal should only be instantiated in the context of terminal 
    // manager. the object will only be safe for scripting if it has been 
    // InitializeDynamic'ed. 
    //
    // this flag will be set when InitializeDynamic succeeds
    //

    BOOL m_bKnownSafeContext;

};


#endif

//eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\h26xinc.h ===
/****************************************************************************
 *  @doc INTERNAL H26XINC
 *
 *  @module H26XInc.h | Header file for the common H.26X video codec defines.
 ***************************************************************************/

#ifndef _H26XINC_H_
#define _H26XINC_H_

enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5};

// MSH26X Configuration Information
typedef struct tagMSH26XCONF{
        BOOL    bInitialized;               // Whether custom msgs can be rcv'd.
        BOOL    bCompressBegin;                         // Whether the CompressBegin msg was rcv'd.
        BOOL    bRTPHeader;                 // Whether to generate RTP header info
        /* used if bRTPHeader */
        UINT    unPacketSize;               // Maximum packet size
        BOOL    bEncoderResiliency;         // Whether to use resiliency restrictions
        /* used if bEncoderResiliency */
        UINT    unPacketLoss;
        BOOL    bBitRateState;
        /* used if bBitRateState */
        UINT    unBytesPerSecond;
        /* The following information is determined from the packet loss value.   */
        /*  These values are calculated each time we receive a resiliency msg or */
        /*  the value is changed through the dialog box.  They are not stored in */
        /*  the registry.  Only the above elements are stored in the registry.   */
        BOOL    bDisallowPosVerMVs;             // if true, disallow positive vertical MVs
        BOOL    bDisallowAllVerMVs;             // if true, disallow all vertical MVs
        UINT    unPercentForcedUpdate;      // Percent Forced Update per Frame
        UINT    unDefaultIntraQuant;        // Default Intra Quant
        UINT    unDefaultInterQuant;        // Default Inter Quant
} MSH26XCONF;

// MSH26X Compressor Instance information
typedef struct tagMSH26XCOMPINSTINFO{
        BOOL            Initialized;
        WORD            xres, yres;
        FrameSize       FrameSz;                // Which of the supported frame sizes.
        float           FrameRate;
        DWORD           DataRate;               // Data rate in bytes per second.
        HGLOBAL         hEncoderInst;   // Instance data private to encoder.
        LPVOID          EncoderInst;
        WORD            CompressedSize;
        BOOL            Is160x120;
        BOOL            Is240x180;
        BOOL            Is320x240;
        MSH26XCONF      Configuration;
} MSH26XCOMPINSTINFO, *PMSH26XCOMPINSTINFO;

// MSH26X BitStream Info Trailer structure
typedef struct tagH26X_RTP_BSINFO_TRAILER {
        DWORD dwVersion;
        DWORD dwFlags;
        DWORD dwUniqueCode;
        DWORD dwCompressedSize;
        DWORD dwNumOfPackets;
        BYTE  bySrc;
        BYTE  byTR;
        BYTE  byTRB;
        BYTE  byDBQ;
} H26X_RTP_BSINFO_TRAILER, *PH26X_RTP_BSINFO_TRAILER;

// MSH263 BitStream Info structure
typedef struct tagRTP_H263_BSINFO {
        DWORD dwFlags;
        DWORD dwBitOffset;
        BYTE  byMode;
        BYTE  byMBA;
        BYTE  byQuant;
        BYTE  byGOBN;
        char  cHMV1;
        char  cVMV1;
        char  cHMV2;
        char  cVMV2;
} RTP_H263_BSINFO, *PRTP_H263_BSINFO;

// MSH261 BitStream Info structure
typedef struct tagRTP_H261_BSINFO {
        DWORD dwFlags;
        DWORD dwBitOffset;
        BYTE  byMBA;
        BYTE  byQuant;
        BYTE  byGOBN;
        char  cHMV;
        char  cVMV;
        BYTE  byPadding0;
        WORD  wPadding1;
} RTP_H261_BSINFO, *PRTP_H261_BSINFO;

// Constants
#define H263_RTP_BS_START_CODE          MakeFOURCC('H','2','6','3')
#define H261_RTP_BS_START_CODE          MakeFOURCC('H','2','6','1')
#define RTP_H26X_INTRA_CODED            0x00000001
#define RTP_H263_PB                                     0x00000002
#define RTP_H263_AP                                     0x00000004
#define RTP_H263_SAC                            0x00000008
#define RTP_H263_UMV                            0x00000010
#define RTP_H263_MODE_A                         0x00
#define RTP_H263_MODE_B                         0x01
#define RTP_H263_MODE_C                         0x02
#define H26X_RTP_PAYLOAD_VERSION    0x00000000
#define RTP_H26X_PACKET_LOST            0x00000001

// Decompressor Instance information
typedef struct
{
        BOOL            Initialized;
        BOOL            bProposedCorrectAspectRatio;// proposed
        BOOL            bCorrectAspectRatio;            // whether to correct the aspect ratio
        WORD            xres, yres;                                     // size of image within movie
        FrameSize       FrameSz;                                        // Which of the supported frame sizes.
//      int                     pXScale, pYScale;                       // proposed scaling (Query)
//      int                     XScale, YScale;                         // current scaling (Begin)
        UINT            uColorConvertor;                        // Current Color Convertor
        WORD            outputDepth;                            // and bit depth
        LPVOID          pDecoderInst;
        BOOL            UseActivePalette;                       // decompress to active palette == 1
        BOOL            InitActivePalette;                      // active palette initialized == 1
        BOOL            bUseBlockEdgeFilter;            // switch for block edge filter
        RGBQUAD         ActivePalette[256];                     // stored active palette
} DECINSTINFO, FAR *LPDECINST;

// Configuration Information
typedef struct
{
        BOOL    bInitialized;                   // Whether custom msgs can be rcv'd.
        BOOL    bCompressBegin;                 // Whether the CompressBegin msg was rcv'd.
        BOOL    bRTPHeader;                             // Whether to generate RTP header info
        // Used if bRTPHeader
        UINT    unPacketSize;                   // Maximum packet size
        BOOL    bEncoderResiliency;             // Whether to use resiliency restrictions
        // Used if bEncoderResiliency
        UINT    unPacketLoss;
        BOOL    bBitRateState;
        // Used if bBitRateState
        UINT    unBytesPerSecond;
        /* The following information is determined from the packet loss value.   */
        /*  These values are calculated each time we receive a resiliency msg or */
        /*  the value is changed through the dialog box.  They are not stored in */
        /*  the registry.  Only the above elements are stored in the registry.   */
        BOOL    bDisallowPosVerMVs;             // if true, disallow positive vertical MVs
        BOOL    bDisallowAllVerMVs;             // if true, disallow all vertical MVs
        UINT    unPercentForcedUpdate;  // Percent Forced Update per Frame
        UINT    unDefaultIntraQuant;    // Default Intra Quant
        UINT    unDefaultInterQuant;    // Default Inter Quant
} T_CONFIGURATION;

// Compressor Instance information
typedef struct
{
        BOOL                    Initialized;
        WORD                    xres, yres;
        FrameSize               FrameSz;                // Which of the supported frame sizes.
        float                   FrameRate;
        DWORD                   DataRate;               // Data rate in bytes per second.
        HGLOBAL                 hEncoderInst;   // Instance data private to encoder.
        LPVOID                  EncoderInst;
        WORD                    CompressedSize;
        BOOL                    Is160x120;
        BOOL                    Is240x180;
        BOOL                    Is320x240;
        T_CONFIGURATION Configuration;
} COMPINSTINFO, FAR *LPCODINST;

// Instance information
// @todo Remove useless fields of this structure
typedef struct tagINSTINFO
{
        DWORD           dwFlags;
        DWORD           fccHandler;     // So we know what codec has been opened.
        BOOL            enabled;
        LPCODINST       CompPtr;        // ICM
        LPDECINST       DecompPtr;      // ICM
} INSTINFO, FAR *LPINST;

// For GetProcAddresss on DriverProc
typedef LRESULT (WINAPI *LPFNDRIVERPROC)(IN DWORD dwDriverID, IN HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2);

// FourCC codes for DDraw and codecs
#define FOURCC_YUY2     mmioFOURCC('Y', 'U', 'Y', '2')
#define FOURCC_UYVY     mmioFOURCC('U', 'Y', 'V', 'Y')
#define FOURCC_I420     mmioFOURCC('I', '4', '2', '0')
#define FOURCC_IYUV     mmioFOURCC('I', 'Y', 'U', 'V')
#define FOURCC_YV12     mmioFOURCC('Y', 'V', '1', '2')
#define FOURCC_M263     mmioFOURCC('M', '2', '6', '3')
#define FOURCC_M261     mmioFOURCC('M', '2', '6', '1')
#define FOURCC_R263     mmioFOURCC('R', '2', '6', '3')
#define FOURCC_R261     mmioFOURCC('R', '2', '6', '1')

#endif // _H26XINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\h245.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#ifndef _H245_Module_H_
#define _H245_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define noMultiplex_chosen 1
#   define transportStream_chosen 2
#   define programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
    } u;
} MiscellaneousIndication_type;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
    } u;
} MiscellaneousCommand_type;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct H223AnnexAReconfiguration_headerCRC {
    ASN1choice_t choice;
#   define H223AnnexAReconfiguration_headerCRC_nil_chosen 1
#   define threebits_chosen 2
#   define H223AnnexAReconfiguration_headerCRC_eightbits_chosen 3
} H223AnnexAReconfiguration_headerCRC;

typedef struct H223AnnexAReconfiguration_headerFEC {
    ASN1choice_t choice;
#   define rate5by15_chosen 1
#   define rate6by31_chosen 2
#   define rate7by63_chosen 3
#   define rate7by15_chosen 4
#   define rate10by63_chosen 5
#   define rate11by31_chosen 6
#   define rate11by15_chosen 7
#   define rate16by63_chosen 8
#   define rate16by31_chosen 9
#   define rate18by63_chosen 10
} H223AnnexAReconfiguration_headerFEC;

typedef struct H223AnnexAReconfiguration_headerInterleaving {
    ASN1choice_t choice;
#   define bitInterleaving_chosen 1
#   define byteInterleaving_chosen 2
#   define noInterleaving_chosen 3
} H223AnnexAReconfiguration_headerInterleaving;

typedef struct H223AnnexAReconfiguration_synchFlagLength {
    ASN1choice_t choice;
#   define length15_chosen 1
#   define length31_chosen 2
} H223AnnexAReconfiguration_synchFlagLength;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct AL3MParameters_arqType {
    ASN1choice_t choice;
#   define AL3MParameters_arqType_noArq_chosen 1
#   define AL3MParameters_arqType_typeIArq_chosen 2
#   define AL3MParameters_arqType_typeIIArq_chosen 3
} AL3MParameters_arqType;

typedef struct AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define AL3MParameters_crcLength_nil_chosen 1
#   define AL3MParameters_crcLength_eightbits_chosen 2
#   define AL3MParameters_crcLength_sixteenbits_chosen 3
#   define AL3MParameters_crcLength_thirtytwobits_chosen 4
} AL3MParameters_crcLength;

typedef struct AL1MParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define AL1MParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} AL1MParameters_numberOfRetransmissions;

typedef struct AL1MParameters_arqType {
    ASN1choice_t choice;
#   define AL1MParameters_arqType_noArq_chosen 1
#   define AL1MParameters_arqType_typeIArq_chosen 2
#   define AL1MParameters_arqType_typeIIArq_chosen 3
} AL1MParameters_arqType;

typedef struct AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define AL1MParameters_crcLength_nil_chosen 1
#   define AL1MParameters_crcLength_eightbits_chosen 2
#   define AL1MParameters_crcLength_sixteenbits_chosen 3
#   define AL1MParameters_crcLength_thirtytwobits_chosen 4
} AL1MParameters_crcLength;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
#   define h261aVideoPacketization_chosen 1
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define wAddress_chosen 1
#   define woAddress_chosen 2
} V76LogicalChannelParameters_suspendResume;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct H223AnnexACapability_h223AnnexAMultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen 1
#	define H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen 2
	H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced enhanced;
    } u;
} H223AnnexACapability_h223AnnexAMultiplexTableCapability;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define H223Capability_h223MultiplexTableCapability_basic_chosen 1
#	define H223Capability_h223MultiplexTableCapability_enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223Capability {
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct MediaPacketizationCapability {
    ASN1bool_t h261aVideoPacketization;
} MediaPacketizationCapability;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H223AnnexACapability {
    ASN1bool_t transferWithI_frames;
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
    ASN1uint16_t maximumDelayJitter;
    ASN1bool_t reconfigurationCapability;
    H223AnnexACapability_h223AnnexAMultiplexTableCapability h223AnnexAMultiplexTableCapability;
} H223AnnexACapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
} H263VideoCapability;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelClose {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelClose;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct AL1MParameters {
    AL1MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL1MParameters_arqType arqType;
    AL1MParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL1MParameters;

typedef struct AL3MParameters {
    AL3MParameters_crcLength crcLength;
    ASN1uint16_t targetCodeRate;
    AL3MParameters_arqType arqType;
    ASN1uint16_t numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} AL3MParameters;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define suspendResumewAddress_chosen 1
#   define suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
} H263VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct H223AnnexAReconfiguration {
    H223AnnexAReconfiguration_synchFlagLength synchFlagLength;
    ASN1uint16_t informationFieldSize;
    H223AnnexAReconfiguration_headerInterleaving headerInterleaving;
    H223AnnexAReconfiguration_headerFEC headerFEC;
    H223AnnexAReconfiguration_headerCRC headerCRC;
    ASN1uint16_t headerCounterForward;
} H223AnnexAReconfiguration;

typedef struct H223AnnexAReconfigurationAck {
    char placeholder;
} H223AnnexAReconfigurationAck;

typedef struct H223AnnexAReconfigurationReject {
    char placeholder;
} H223AnnexAReconfigurationReject;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
    } u;
} ConferenceCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
    } u;
} ConferenceIndication;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
} NewATMVCIndication;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H2250Capability {
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
} H2250Capability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729AnnexAwSilenceSuppression_chosen 15
	ASN1uint16_t g729AnnexAwSilenceSuppression;
    } u;
} AudioCapability;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
    } u;
} DataProtocolCapability;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729AnnexAwSilenceSuppression_chosen 15
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
    } u;
} ConferenceRequest;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
    } u;
} EndSessionCommand;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataMode_application;

typedef struct H223AnnexAModeParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexAModeParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexAModeParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexAModeParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexAModeParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexAModeParameters_adaptationLayertype;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct H223AnnexALogicalChannelParameters_adaptationLayertype {
    ASN1choice_t choice;
    union {
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al1M_chosen 2
	AL1MParameters al1M;
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al2M_chosen 3
#	define H223AnnexALogicalChannelParameters_adaptationLayertype_al3M_chosen 4
	AL3MParameters al3M;
    } u;
} H223AnnexALogicalChannelParameters_adaptationLayertype;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataApplicationCapability_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
    } u;
} DataApplicationCapability_application;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
#	define h223AnnexACapability_chosen 6
	H223AnnexACapability h223AnnexACapability;
    } u;
} MultiplexCapability;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
    } u;
} DataType;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} TransportAddress;

typedef struct H223AnnexALogicalChannelParameters {
    H223AnnexALogicalChannelParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexALogicalChannelParameters;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct H223AnnexAModeParameters {
    H223AnnexAModeParameters_adaptationLayertype adaptationLayertype;
    ASN1bool_t segmentableFlag;
} H223AnnexAModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MCLocationIndication {
    TransportAddress signalAddress;
} MCLocationIndication;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define videoMode_chosen 2
	VideoMode videoMode;
#	define audioMode_chosen 3
	AudioMode audioMode;
#	define dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
    } u;
} ModeElement_type;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
    } u;
} CommandMessage;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
    } u;
} Capability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
} NetworkAccessParameters;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
} H2250LogicalChannelParameters;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h223AnnexAModeParameters_present 0x4000
    H223AnnexAModeParameters h223AnnexAModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
} CommunicationModeTableEntry;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 5
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen 4
	H223AnnexALogicalChannelParameters h223AnnexALogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
} OpenLogicalChannelAck;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
#	define h223AnnexAReconfiguration_chosen 14
	H223AnnexAReconfiguration h223AnnexAReconfiguration;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
#	define h223AnnexAReconfigurationAck_chosen 22
	H223AnnexAReconfigurationAck h223AnnexAReconfigurationAck;
#	define h223AnnexAReconfigurationReject_chosen 23
	H223AnnexAReconfigurationReject h223AnnexAReconfigurationReject;
    } u;
} ResponseMessage;

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 0
#define SIZE_H245_Module_PDU_0 sizeof(MultimediaSystemControlMessage)


extern ASN1module_t H245_Module;
extern void ASN1CALL H245_Module_Startup(void);
extern void ASN1CALL H245_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
	extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
	extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
	extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
	extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
	extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
	extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\h323pdu.h ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    H323pdu.h

Abstract:

    Describes interface between H323TSP and H323MSP.

Environment:

    User Mode - Win32

--*/

#ifndef __H323_PDU_H_
#define __H323_PDU_H_

typedef enum {

    //
    // H323TSP_NEW_CALL_INDICATION - sent only from the TSP
    //  to the MSP in order to initiate communication once
    //  a call has been created.
    //

    H323TSP_NEW_CALL_INDICATION,

    //
    // H323TSP_CLOSE_CALL_COMMAND - sent only from the TSP
    //  to the MSP in order to stop all the streaming for a call.
    //

    H323TSP_CLOSE_CALL_COMMAND,

    //
    // H323TSP_OPEN_CHANNEL_RESPONSE - sent only from the TSP
    // to the MSP in response to H323MSP_OPEN_CHANNEL_REQUEST.
    //

    H323TSP_OPEN_CHANNEL_RESPONSE,

    //
    // H323TSP_ACCEPT_CHANNEL_REQUEST - sent only from the TSP
    // to the MSP in order to request the acceptance of an
    // incoming logical channel.
    //

    H323TSP_ACCEPT_CHANNEL_REQUEST,

    //
    // H323TSP_CLOSE_CHANNEL_COMMAND - sent only from the TSP
    // to the MSP in order to demand the immediate closure of
    // an incoming or outgoing logical channel.
    //

    H323TSP_CLOSE_CHANNEL_COMMAND,

	//
	// H323TSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND - sent only from the TSP 
	// to the MSP in order to request an I-frame transmittal
	//

	H323TSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND,

	//
	// H323TSP_FLOW_CONTROL_COMMAND - sent only from the TSP 
	// to the MSP in order to request media stream bit rate 
	// change 

	H323TSP_FLOW_CONTROL_COMMAND

} H323TSP_MESSAGE_TYPE;

typedef enum {

    //
    // H323MSP_OPEN_CHANNEL_REQUEST - sent only from the MSP
    // to the TSP in order to request the negotiation on an
    // outgoing logical channel.
    //

    H323MSP_OPEN_CHANNEL_REQUEST,

    //
    // H323MSP_ACCEPT_CHANNEL_RESPONSE - sent only from the MSP
    // to the TSP in reponse to H323TSP_ACCEPT_CHANNEL_REQUEST.
    //

    H323MSP_ACCEPT_CHANNEL_RESPONSE,

    //
    // H323MSP_CLOSE_CHANNEL_COMMAND - sent only from the MSP
    // to the TSP in order to demand the immediate closure of
    // an incoming or outgoing logical channel.
    //

    H323MSP_CLOSE_CHANNEL_COMMAND,

    //
    // H323MSP_QOS_EVENT - sent only from the MSP to the TSP for 
    // QOS events. In the future, we might move the event to MSP space.
    //

    H323MSP_QOS_Evnet, 

	// 
	// H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND - sent only from the
	// MSP to the TSP in order to request an I-frame transmittal from
	// the remote entity
	//

	H323MSP_VIDEO_FAST_UPDATE_PICTURE_COMMAND,

	// 
	// H323MSP_FLOW_CONTROL_COMMAND - sent only from the MSP to the TSP
	// in order to ask the remote entity to change media stream bit rate
	//

	H323MSP_FLOW_CONTROL_COMMAND,

	// 
	// H323MSP_CONFIG_T120_COMMAND - sent only from the MSP to the TSP
	// in order to set an external T120 address to the TSP.
	//

	H323MSP_CONFIG_T120_COMMAND,

	// 
	// H323MSP_CONFIG_CAPABILITY_COMMAND - sent only from the MSP to the TSP
	// in order to configure the capability array of the TSP.
	//

	H323MSP_CONFIG_CAPABILITY_COMMAND,

    //
    // H323MSP_SET_ALIAS_COMMAND - sent only from the MSP to the TSP
    // to setup an alias name for the address
    //

    H323MSP_SET_ALIAS_COMMAND

} H323MSP_MESSAGE_TYPE;

typedef enum {

    MEDIA_AUDIO,
    MEDIA_VIDEO

} MEDIATYPE;

#ifndef H245_CAPABILITY_DEFINED
typedef enum H245_CAPABILITY
{
    HC_G711,
    HC_G723,
    HC_H263QCIF,
    HC_H261QCIF

} H245_CAPABILITY;
#endif

#define MAX_CAPS (HC_H261QCIF - HC_G711 + 1)

typedef struct _VIDEOSETTINGS
{
    BOOL  bCIF;
    DWORD dwMaxBitRate;      // the encoder should never exceed this value.
    DWORD dwStartUpBitRate;  // the encoder uses this value to start

} VIDEOSETTINGS, *PVIDEOSETTINGS;

typedef struct _G723SETTINGS
{
	BOOL  bG723LowSpeed;
} G723SETTINGS, *PG723SETTINGS;

typedef struct  _G729SETTINGS
{
	BOOL bDummy;	// I.K. 03-23-1999.
					// A dummy field for now.
} G729SETTINGS, *PG729SETTINGS;

typedef struct _AUDIOSETTINGS
{
    DWORD dwMillisecondsPerPacket;
	
    union {
        G723SETTINGS G723Settings;
        G729SETTINGS G729Settings;
    };

} AUDIOSETTINGS, *PAUDIOSETTINGS;

typedef struct _STREAMSETTINGS
{
    MEDIATYPE MediaType;

    DWORD     dwPayloadType;    // RTP payload type
    DWORD     dwDynamicType;    // RTP dynamic payload type

    DWORD     dwIPLocal;        // local IP address in host byte order.
    WORD      wRTPPortLocal;    // local port number in host byte order.
    WORD      wRTCPPortLocal;

    DWORD     dwIPRemote;       // remote IP address in host byte order.
    WORD      wRTPPortRemote;   // remote port number in host byte order.
    WORD      wRTCPPortRemote;

    union {
        VIDEOSETTINGS Video;
        AUDIOSETTINGS Audio;
    };

} STREAMSETTINGS, *PSTREAMSETTINGS;

typedef struct _H323MSG_OPEN_CHANNEL_REQUEST {

    HANDLE          hmChannel;  // msp channel handle
    STREAMSETTINGS  Settings;   // local address and requested settings

} H323MSG_OPEN_CHANNEL_REQUEST, *PH323MSG_OPEN_CHANNEL_REQUEST;

typedef struct _H323MSG_OPEN_CHANNEL_RESPONSE {

    HANDLE          hmChannel;  // handle from OPEN_CHANNEL_REQUEST
    HANDLE          htChannel;  // tsp channel channel
    STREAMSETTINGS  Settings;   // remote address and agreed upon settings

} H323MSG_OPEN_CHANNEL_RESPONSE, *PH323MSG_OPEN_CHANNEL_RESPONSE;

typedef struct _H323MSG_ACCEPT_CHANNEL_REQUEST {

    HANDLE          htChannel;  // tsp channel handle
    STREAMSETTINGS  Settings;   // remote address and requested settings

} H323MSG_ACCEPT_CHANNEL_REQUEST, *PH323MSG_ACCEPT_CHANNEL_REQUEST;

typedef struct _H323MSG_ACCEPT_CHANNEL_RESPONSE {

    HANDLE          htChannel;  // handle from ACCEPT_CHANNEL_REQUEST
    HANDLE          hmChannel;  // msp channel handle
    STREAMSETTINGS  Settings;   // local address and agreed upon settings

} H323MSG_ACCEPT_CHANNEL_RESPONSE, *PH323MSG_ACCEPT_CHANNEL_RESPONSE;

typedef struct _H323MSG_CLOSE_CHANNEL_COMMAND {

    DWORD           dwReason;   // normal case is zero
    HANDLE          hChannel;    // channel handle

} H323MSG_CLOSE_CHANNEL_COMMAND, *PH323MSG_CLOSE_CHANNEL_COMMAND;

typedef struct _H323MSG_FLOW_CONTROL_COMMAND {

    DWORD           dwBitRate;  // requested bit rate (units of bps)
    HANDLE          hChannel;   // MSP or TSP channel handle

} H323MSG_FLOW_CONTROL_COMMAND, *PH323MSG_FLOW_CONTROL_COMMAND;

typedef struct _H323MSG_CONFIG_T120_COMMAND {

    BOOL            fEnable;    // Enable or disable T120. 
    DWORD           dwIP;       // The IP address of the external T120 service.
    WORD            wPort;      // The port number of the external T120 service.

} H323MSG_CONFIG_T120_COMMAND, *PH323MSG_CONFIG_T120_COMMAND;

typedef struct _H323MSG_CONFIG_CAPABILITY_COMMAND {

    DWORD           dwNumCaps;
    DWORD           pCapabilities[MAX_CAPS];  // The list of capabilities.
    DWORD           pdwWeights[MAX_CAPS];       // MSP or TSP channel handle

} H323MSG_CONFIG_CAPABILITY_COMMAND, *PH323MSG_CONFIG_CAPABILITY_COMMAND;

#define MAX_ALIAS_LENGTH 64

typedef struct _H323MSG_SET_ALIAS_COMMAND {

    WCHAR           strAlias[MAX_ALIAS_LENGTH]; // alias name
    DWORD           dwLength; // length of the alias

} H323MSG_SET_ALIAS_COMMAND, *PH323MSG_SET_ALIAS_COMMAND;

typedef struct _H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND {

    HANDLE          hChannel;   // MSP or TSP channel handle

} H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND,
 *PH323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND;

typedef struct _H323MSG_QOS_EVENT {

    DWORD           dwEvent;      // the QOS event as defined in TSPI.h
    HANDLE          htChannel;    // channel handle

} H323MSG_QOS_EVENT, *PH323MSG_QOS_EVENT;

typedef struct _H323TSP_MESSAGE {

    H323TSP_MESSAGE_TYPE Type;

    union {
        H323MSG_OPEN_CHANNEL_RESPONSE             OpenChannelResponse;
        H323MSG_ACCEPT_CHANNEL_REQUEST            AcceptChannelRequest;
        H323MSG_CLOSE_CHANNEL_COMMAND             CloseChannelCommand;
		H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND VideoFastUpdatePictureCommand;
		H323MSG_FLOW_CONTROL_COMMAND              FlowControlCommand;
    };

} H323TSP_MESSAGE, *PH323TSP_MESSAGE;

typedef struct _H323MSP_MESSAGE {

    H323MSP_MESSAGE_TYPE Type;

    union {
        H323MSG_OPEN_CHANNEL_REQUEST              OpenChannelRequest;
        H323MSG_ACCEPT_CHANNEL_RESPONSE           AcceptChannelResponse;
        H323MSG_CLOSE_CHANNEL_COMMAND             CloseChannelCommand;
        H323MSG_QOS_EVENT                         QOSEvent;
		H323MSG_VIDEO_FAST_UPDATE_PICTURE_COMMAND VideoFastUpdatePictureCommand;
		H323MSG_FLOW_CONTROL_COMMAND              FlowControlCommand;
        H323MSG_CONFIG_T120_COMMAND               ConfigT120Command;
        H323MSG_CONFIG_CAPABILITY_COMMAND         ConfigCapabilityCommand;
        H323MSG_SET_ALIAS_COMMAND                 SetAliasCommand;
    };

} H323MSP_MESSAGE, *PH323MSP_MESSAGE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\h245api.h ===
#ifndef H245API_H
#define H245API_H

/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   h245api.h  $
 *  $Revision:   1.64  $
 *  $Modtime:   04 Mar 1997 16:51:38  $
 *  $Log:   S:/sturgeon/src/include/vcs/h245api.h_v  $
 * 
 *    Rev 1.64   04 Mar 1997 17:32:36   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 * 
 *    Rev 1.63   26 Feb 1997 10:56:20   MANDREWS
 * Added H245_MAX_CAPID.
 * 
 *    Rev 1.62   Feb 24 1997 18:28:26   tomitowx
 * multiple modedescriptor support
 * 
 *    Rev 1.61   19 Dec 1996 17:16:10   EHOWARDX
 * Now using ASN.1 compiler C++ flag.
 * 
 *    Rev 1.60   17 Dec 1996 17:14:12   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 * 
 *    Rev 1.59   12 Dec 1996 11:24:38   EHOWARDX
 * Backed out H245_CONF_H323_OLD change.
 * 
 *    Rev 1.57   11 Dec 1996 13:46:46   SBELL1
 * Changed H245Init to return linkLayer Physical ID
 * 
 *    Rev 1.56   24 Oct 1996 15:57:54   MANDREWS
 * Fixed typo in last update.
 * 
 *    Rev 1.55   Oct 21 1996 17:11:00   mandrews
 * Fixed type in last check-in.
 * 
 *    Rev 1.54   Oct 21 1996 16:41:20   mandrews
 * Added H245_MASTER_SLAVE_CONFLICT as an additional openChannelReject
 * reason code.
 * 
 *    Rev 1.53   17 Oct 1996 18:17:54   EHOWARDX
 * Changed general string to always be Unicode.
 * 
 *    Rev 1.52   14 Oct 1996 14:00:28   EHOWARDX
 * 
 * Unicode changes.
 * 
 *    Rev 1.51   03 Sep 1996 18:09:54   EHOWARDX
 * 
 * Changed some parameters to const.
 * Changed H245_REQ_ENTRY_H243_CONFERENCE_ID to H245_REQ_ENTER_H243_CONFERENCE
 * 
 *    Rev 1.50   15 Aug 1996 14:33:48   EHOWARDX
 * Changed definition of H245_COMM_MODE_ENTRY_T as per Mike Andrews' request.
 * 
 *    Rev 1.49   24 Jul 1996 15:18:16   EHOWARDX
 * Backed out change of IndNonstandardRequest to IndNonstandardReq,
 * IndNonstandardResponse to IndNonStandardRsp, and IndNonstandardCommand to
 * IndNonstandardCmd to make less work for upper layers (CCTEST).
 * 
 *    Rev 1.48   19 Jul 1996 14:12:20   EHOWARDX
 * 
 * Added indication callback structure for CommunicationModeResponse and
 * CommunicationModeCommand.
 * 
 *    Rev 1.47   19 Jul 1996 12:50:30   EHOWARDX
 * 
 * Multipoint clean-up.
 * 
 *    Rev 1.46   16 Jul 1996 17:53:48   unknown
 * Added FNS indication.
 * 
 *    Rev 1.45   16 Jul 1996 11:51:58   EHOWARDX
 * 
 * Changed ERROR_LOCAL_BASE_ID to ERROR_BASE_ID.
 * 
 *    Rev 1.44   16 Jul 1996 11:46:10   EHOWARDX
 * 
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET (changing the existing
 * mux cap should not be an error).
 * 
 *    Rev 1.43   11 Jul 1996 18:42:14   rodellx
 * 
 * Fixed bug where HRESULT ids were in violation of Facility and/or Code
 * value rules.
 * 
 *    Rev 1.42   10 Jul 1996 11:33:42   unknown
 * Changed error base.
 * 
 *    Rev 1.41   01 Jul 1996 22:07:24   EHOWARDX
 * Added Conference and CommunicationMode structures and API functions.
 * 
 *    Rev 1.40   18 Jun 1996 14:48:54   EHOWARDX
 * 
 * Bumped version number to 2 and modified H245MaintenanceLoopRelease()
 * and associated Confirms.
 * 
 *    Rev 1.39   14 Jun 1996 18:59:38   EHOWARDX
 * Geneva update.
 * 
 *    Rev 1.38   31 May 1996 18:19:46   EHOWARDX
 * Brought error codes in line with STURERR.DOC guidelines.
 * 
 *    Rev 1.37   30 May 1996 23:37:26   EHOWARDX
 * Clean up.
 * 
 *    Rev 1.36   30 May 1996 13:55:02   EHOWARDX
 * Changed H245EndConnection to H245EndSession.
 * Removed H245_CONF_ENDCONNECTION.
 * 
 *    Rev 1.35   29 May 1996 14:23:58   EHOWARDX
 * Changed definition of H245_ERROR_OK back to 0 (NOERROR == S_OK == 0).
 * 
 *    Rev 1.34   29 May 1996 13:19:50   EHOWARDX
 * RESULT to HRESULT conversion.
 * 
 *    Rev 1.33   24 May 1996 23:12:56   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.32   21 May 1996 18:23:58   EHOWARDX
 * 
 * Added dwTransId parameter to H245RequestMultiplexEntry,
 * H245RequestMode, and H245MaintenanceLoopRequest.
 * 
 *    Rev 1.31   20 May 1996 14:14:42   EHOWARDX
 * Fixed typo.
 * 
 *    Rev 1.30   20 May 1996 14:05:20   EHOWARDX
 * Removed dwTransId formal parameter from H245EndConnection().
 * 
 *    Rev 1.29   16 May 1996 15:51:56   EHOWARDX
 * Fixed typo in H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.28   16 May 1996 10:57:46   unknown
 * Added H245_INVALID_CAPDESCID.
 * 
 *    Rev 1.27   14 May 1996 20:20:14   EHOWARDX
 * Removed H245_IND_SYS.
 * 
 *    Rev 1.26   14 May 1996 19:00:58   EHOWARDX
 * Deleted unused H245_SYSCON_xxx values.
 * 
 *    Rev 1.25   14 May 1996 16:58:48   EHOWARDX
 * Changed H245_IND_CAPDESC_T To H245_TOTCAPDESC_T.
 * H245EnumCaps() cap desc callback now takes single pointer to
 * H245_TOTCAPDESC_T instead of separate H245_CAPDESCID_T and
 * H245_CAPDESC_T pointer.
 * 
 *    Rev 1.24   13 May 1996 23:13:46   EHOWARDX
 * Everything ready for Micrsoft drop on the 17th.
 * 
 *    Rev 1.23   13 May 1996 15:43:16   EHOWARDX
 * Changed return type of H245CopyCapDescriptor from H245_CAPDESC_T pointer
 * to H245_TOTCAPDESC_T pointer.
 * 
 *    Rev 1.22   13 May 1996 14:05:16   EHOWARDX
 * Added H245CopyCapDescriptor() and H245FreeCapDescriptor().
 * 
 *    Rev 1.21   11 May 1996 20:00:34   EHOWARDX
 * Changed IS1381 to IS13818 (correct name for capability).
 * Changed H245SystemControl() - eliminated dwTransId and added
 * H245_SYSCON_GET_XXX requests.
 * 
 *    Rev 1.20   10 May 1996 17:38:28   unknown
 * Changed H245GetCaps and H245EnumCaps to also return Cap Descriptors.
 * 
 *    Rev 1.19   09 May 1996 20:22:58   EHOWARDX
 * Latest and greatest...
 * 
 *    Rev 1.35   09 May 1996 19:38:14   EHOWARDX
 * Redesigned locking logic and added new functionality.
 * 
 *    Rev 1.34   06 May 1996 13:19:44   EHOWARDX
 * Moved enums out of structures.
 * Added H245NonStandardH221() and H245NonStandardObject().
 * 
 *    Rev 1.33   01 May 1996 19:29:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address to H245_xxx.
 * 
 *    Rev 1.32   27 Apr 1996 21:04:26   EHOWARDX
 * Changed channel numbers to words, added new open/open ack fields.
 * 
 *    Rev 1.31   26 Apr 1996 15:57:14   EHOWARDX
 * Added new Terminal Capabilities.
 * 
 *    Rev 1.27.1.6   25 Apr 1996 17:53:06   EHOWARDX
 * Added H245_INVALID_ID, currently set to zero, should be 0xFFFFFFFF later.
 * 
 *    Rev 1.27.1.5   25 Apr 1996 16:50:04   EHOWARDX
 * Added new functions as per API Changes spec.
 * 
 *    Rev 1.27.1.4   24 Apr 1996 20:57:30   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 * 
 *    Rev 1.27.1.3   18 Apr 1996 15:56:42   EHOWARDX
 * Updated to 1.30.
 * 
 *    Rev 1.27.1.2   16 Apr 1996 20:09:52   EHOWARDX
 * Added new H2250LogicalChannelParameter fields.
 * 
 *    Rev 1.27.1.1   16 Apr 1996 18:45:24   EHOWARDX
 * Added silenceSupression to H.225.0 Logical Channel Parameters.
 * 
 *    Rev 1.27.1.0   03 Apr 1996 15:56:14   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.27   02 Apr 1996 08:29:44   cjutzi
 * - Changed CapDescriptor API
 * 
 *    Rev 1.26   01 Apr 1996 16:46:50   cjutzi
 * 
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 * 
 *    Rev 1.25   29 Mar 1996 14:55:52   cjutzi
 * 
 * - added USERINPUT stuff
 * - Added hooks for stats in SYSCON H245SystemControl
 * 
 *    Rev 1.24   27 Mar 1996 10:55:40   cjutzi
 * - added c++ wrapper for API calls..
 *
 *    Rev 1.23   20 Mar 1996 14:42:46   cjutzi
 * - added ERROR NO_CAPDESC
 *
 *    Rev 1.22   18 Mar 1996 15:14:56   cjutzi
 *
 * - added RxPort and TEST_TIMER
 *
 *    Rev 1.21   12 Mar 1996 15:49:24   cjutzi
 *
 * - implemented locking
 * - added EndSession
 * - added Shutdown
 *
 *
 *    Rev 1.20   08 Mar 1996 14:06:04   cjutzi
 *
 * - Removed Simultanious capability api
 * - added CapabilityDescriptor api.. (very similar.. made more sence)
 * - compeleted Mux Table upcall information..
 *
 *    Rev 1.19   06 Mar 1996 08:45:58   cjutzi
 *
 * - added ERROR ASN1
 *
 *    Rev 1.18   05 Mar 1996 17:32:24   cjutzi
 *
 * - master slave indication message from Hani.. implemented..
 *   added H245_IND_MSTSLV ..
 *
 *    Rev 1.17   05 Mar 1996 16:36:46   cjutzi
 *
 * - removed MUX_ENTRY_DESC_T .. cleaned it up.. don't need it..
 *
 *    Rev 1.16   05 Mar 1996 10:06:30   cjutzi
 *
 * - added mux table entry stuff
 * - changed errors to map to 10000
 *
 *    Rev 1.15   01 Mar 1996 13:46:20   cjutzi
 * - added more error messages
 *
 *    Rev 1.14   29 Feb 1996 17:27:38   cjutzi
 *
 * - bi-directional channel working
 *
 *    Rev 1.13   29 Feb 1996 11:33:50   cjutzi
 * - fixed bug w/ H245_CONF_IND_T .. as global union.. fixed to be
 *   struct
 *
 *    Rev 1.12   29 Feb 1996 08:26:48   cjutzi
 *
 * - added 2 error messages (SIMCAPID and DATA_FORMAT)
 *
 *    Rev 1.11   27 Feb 1996 13:28:50   cjutzi
 * - added global protocol id H245_PROTOID
 *
 *    Rev 1.10   26 Feb 1996 17:24:10   cjutzi
 *
 * -  added MiscCommand.. had to add channel to H245_IND_MISC_T..
 *
 *    Rev 1.9   26 Feb 1996 11:07:24   cjutzi
 *
 * - added simultanoius caps..
 *
 *    Rev 1.8   16 Feb 1996 12:59:26   cjutzi
 * - added tracing and debug..
 * - got close to work.. Added structure to H245_IND_T.. new CLOSE indication
 *
 *    Rev 1.7   15 Feb 1996 14:13:08   cjutzi
 *
 * - re-arranged the AL_T entries for more clairity..
 *
 *    Rev 1.6   15 Feb 1996 10:48:30   cjutzi
 *
 * - major changes..
 * - added MUX_T
 * - changed H245_IND_T
 * - changed IND_OPEN/IND_OPEN_NEEDSRSP etc..
 *
 *    Rev 1.5   09 Feb 1996 16:14:04   cjutzi
 *
 * - removed init_success
 * - removed shutdown success
 * - added masterslave type for callback/confirm
 * - added SYSCON TraceLvl
 *
 *****************************************************************************/

//
// H.245 return codes
//
#if defined(OIL)

#include "common.x"
#define HRESULT RESULT
#define ERROR_BASE_ID             0x8000
#define MAKE_H245_ERROR(error)          (error)
#define H245_ERROR_OK                   0
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_BASE_ID+0x01) /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_BASE_ID+0x02) /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_BASE_ID+0x03) /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_BASE_ID+0x04) /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_BASE_ID+0x05) /* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_BASE_ID+0x06) /* system is not in the connected state             */

#else

#pragma warning( disable : 4115 4201 4214 4514 )
#include "apierror.h"
#define H245_ERROR_OK                   NOERROR
#define H245_ERROR_INVALID_DATA_FORMAT  MAKE_H245_ERROR(ERROR_INVALID_DATA)       /* Data Structure passed down is somehow invalid    */
#define H245_ERROR_NOMEM                MAKE_H245_ERROR(ERROR_OUTOFMEMORY)        /* memory allocation failure                        */
#define H245_ERROR_NOSUP                MAKE_H245_ERROR(ERROR_NOT_SUPPORTED)      /* H245 feature not valid, or not in this H245 spec */
#define H245_ERROR_PARAM                MAKE_H245_ERROR(ERROR_INVALID_PARAMETER)  /* invalid parameter or data structure passed to API*/
#define H245_ERROR_ALREADY_INIT         MAKE_H245_ERROR(ERROR_ALREADY_INITIALIZED)/* system has already been initialized              */
#define H245_ERROR_NOT_CONNECTED        MAKE_H245_ERROR(ERROR_NOT_CONNECTED)      /* system is not in the connected state             */

#endif

#define H245_ERROR_NORESOURCE           MAKE_H245_ERROR(ERROR_BASE_ID+0x10) /* No resources left for this call                  */
#define H245_ERROR_NOTIMP               MAKE_H245_ERROR(ERROR_BASE_ID+0x11) /* H245 feature should be implemented.. but is not  */
#define H245_ERROR_SUBSYS               MAKE_H245_ERROR(ERROR_BASE_ID+0x12) /* subsystem failure.. error unknown                */
#define H245_ERROR_FATAL                MAKE_H245_ERROR(ERROR_BASE_ID+0x13) /* fatal error.. system will be coming down..       */
#define H245_ERROR_MAXTBL               MAKE_H245_ERROR(ERROR_BASE_ID+0x14) /* you have reached the maxium number of tbl entries*/
#define H245_ERROR_CHANNEL_INUSE        MAKE_H245_ERROR(ERROR_BASE_ID+0x15) /* channel is currently in use                      */
#define H245_ERROR_INVALID_CAPID        MAKE_H245_ERROR(ERROR_BASE_ID+0x16) /* Invalid Cap ID.. can not be found                */
#define H245_ERROR_INVALID_OP           MAKE_H245_ERROR(ERROR_BASE_ID+0x17) /* Invalid operation at this time..                 */
#define H245_ERROR_UNKNOWN              MAKE_H245_ERROR(ERROR_BASE_ID+0x18) /* unknown error                                    */
#define H245_ERROR_NOBANDWIDTH          MAKE_H245_ERROR(ERROR_BASE_ID+0x19) /* Bandwidth will not allow this                    */
#define H245_ERROR_LOSTCON              MAKE_H245_ERROR(ERROR_BASE_ID+0x1A) /* System connection .. channel 0 was lost          */
#define H245_ERROR_INVALID_MUXTBLENTRY  MAKE_H245_ERROR(ERROR_BASE_ID+0x1B) /* Invalid Multiplex Table Entry                    */
#define H245_ERROR_INVALID_INST         MAKE_H245_ERROR(ERROR_BASE_ID+0x1C) /* instance is either no longer valid or is invalid */
#define H245_ERROR_INPROCESS            MAKE_H245_ERROR(ERROR_BASE_ID+0x1D) /* request is denied.. action already in process    */
#define H245_ERROR_INVALID_STATE        MAKE_H245_ERROR(ERROR_BASE_ID+0x1E) /* Not proper state to process request              */
#define H245_ERROR_TIMEOUT              MAKE_H245_ERROR(ERROR_BASE_ID+0x1F) /* Timeout occured                                  */
#define H245_ERROR_INVALID_CHANNEL      MAKE_H245_ERROR(ERROR_BASE_ID+0x20) /* Invalid channel                                  */
#define H245_ERROR_INVALID_CAPDESCID    MAKE_H245_ERROR(ERROR_BASE_ID+0x21) /* Invalid Capbility Descriptor ID                  */
#define H245_ERROR_CANCELED             MAKE_H245_ERROR(ERROR_BASE_ID+0x22) /* operation you are responding to has been canceled*/
#define H245_ERROR_MUXELEMENT_DEPTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x23) /* Mux Table Entry is too complex.. MAX recursion   */
#define H245_ERROR_MUXELEMENT_WIDTH     MAKE_H245_ERROR(ERROR_BASE_ID+0x24) /* Mux Table Entry has reached max subelement width */
#define H245_ERROR_ASN1                 MAKE_H245_ERROR(ERROR_BASE_ID+0x25) /* ASN1 PDU compiler error - see PDU log            */
#define H245_ERROR_NO_MUX_CAPS          MAKE_H245_ERROR(ERROR_BASE_ID+0x26) /* Mux Capabilities have not been loaded            */
#define H245_ERROR_NO_CAPDESC           MAKE_H245_ERROR(ERROR_BASE_ID+0x27) /* No Capability Descriptors set                    */

#if defined(REMOVE_FROM_TSP)

// declare exported functions
#if defined(H245DLL_EXPORT)
#define H245DLL __declspec (dllexport)
#else   // (H245DLL_EXPORT)
#define H245DLL __declspec (dllimport)
#endif  // (H245DLL_EXPORT)

#else  // REMOVE_FROM_TSP

#define H245DLL

#endif // REMOVE_FROM_TSP


/************************************/
/* ASN.1 DATASTRUCTURES ABSTRACTION */
/************************************/

#include "h245asn1.h"

typedef struct NonStandardIdentifier    H245_NONSTANDID_T;

typedef struct NonStandardParameter     H245_NONSTANDARD_PARAMETER_T;

typedef H245_NONSTANDARD_PARAMETER_T    H245_CAP_NONSTANDARD_T;

typedef struct H261VideoCapability      H245_CAP_H261_T;

typedef struct H262VideoCapability      H245_CAP_H262_T;

typedef struct H263VideoCapability      H245_CAP_H263_T;

typedef struct IS11172VideoCapability   H245_CAP_VIS11172_T;

typedef struct IS11172AudioCapability   H245_CAP_AIS11172_T;

typedef struct IS13818AudioCapability   H245_CAP_IS13818_T;

typedef struct DataApplicationCapability H245_CAP_DATAAPPLICATION_T;

typedef struct H222Capability           H245_CAP_H222_T;

typedef struct H223Capability           H245_CAP_H223_T;

typedef struct V76Capability            H245_CAP_VGMUX_T;

typedef struct H2250Capability          H245_CAP_H2250_T;

typedef struct ConferenceCapability     H245_CAP_CONFERENCE_T;

typedef struct TerminalLabel            H245_TERMINAL_LABEL_T;

#define PDU_T           MltmdSystmCntrlMssg
#define H245_ACCESS_T   NetworkAccessParameters
typedef unsigned long  H245_INST_T;
typedef unsigned short H245_CHANNEL_T;
typedef unsigned long  H245_PORT_T;
#define H245_INVALID_ID          ((H245_INST_T)0)
#define H245_INVALID_CHANNEL     ((H245_CHANNEL_T)0)
#define H245_INVALID_PORT_NUMBER ((H245_PORT_T)-1)

typedef struct
{
  unsigned int    length;
  unsigned char  *value;
} H245_OCTET_STRING_T;



/************************/
/* H245 ABSTRACTION     */
/************************/

/* H245_CAPDIR_T */
typedef enum
{
  H245_CAPDIR_DONTCARE = 0,
  H245_CAPDIR_RMTRX,
  H245_CAPDIR_RMTTX,
  H245_CAPDIR_RMTRXTX,
  H245_CAPDIR_LCLRX,
  H245_CAPDIR_LCLTX,
  H245_CAPDIR_LCLRXTX
} H245_CAPDIR_T;

/* H245_DATA_T */
typedef enum
{
  H245_DATA_DONTCARE = 0,
  H245_DATA_NONSTD,
  H245_DATA_NULL,
  H245_DATA_VIDEO,
  H245_DATA_AUDIO,
  H245_DATA_DATA,
  H245_DATA_ENCRYPT_D,
  H245_DATA_CONFERENCE,
  H245_DATA_MUX         /* mux parameters */
} H245_DATA_T;

/* H245_CLIENT_T */
typedef enum
{
  H245_CLIENT_DONTCARE = 0,     // For H245EnumCap/H245GetCap
  H245_CLIENT_NONSTD,

  H245_CLIENT_VID_NONSTD,
  H245_CLIENT_VID_H261,
  H245_CLIENT_VID_H262,
  H245_CLIENT_VID_H263,
  H245_CLIENT_VID_IS11172,

  H245_CLIENT_AUD_NONSTD,
  H245_CLIENT_AUD_G711_ALAW64,
  H245_CLIENT_AUD_G711_ALAW56,
  H245_CLIENT_AUD_G711_ULAW64,
  H245_CLIENT_AUD_G711_ULAW56,
  H245_CLIENT_AUD_G722_64,
  H245_CLIENT_AUD_G722_56,
  H245_CLIENT_AUD_G722_48,
  H245_CLIENT_AUD_G723,
  H245_CLIENT_AUD_G728,
  H245_CLIENT_AUD_G729,
  H245_CLIENT_AUD_GDSVD,
  H245_CLIENT_AUD_IS11172,
  H245_CLIENT_AUD_IS13818,

  H245_CLIENT_DAT_NONSTD,
  H245_CLIENT_DAT_T120,
  H245_CLIENT_DAT_DSMCC,
  H245_CLIENT_DAT_USERDATA,
  H245_CLIENT_DAT_T84,
  H245_CLIENT_DAT_T434,
  H245_CLIENT_DAT_H224,
  H245_CLIENT_DAT_NLPID,
  H245_CLIENT_DAT_DSVD,
  H245_CLIENT_DAT_H222,

  H245_CLIENT_ENCRYPTION_TX,
  H245_CLIENT_ENCRYPTION_RX,
  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_CLIENT_MUX_NONSTD,
  H245_CLIENT_MUX_H222,
  H245_CLIENT_MUX_H223,
  H245_CLIENT_MUX_VGMUX,
  H245_CLIENT_MUX_H2250,
  H245_CLIENT_MUX_H223_ANNEX_A

} H245_CLIENT_T;


/* H245_CAP_T */
typedef union
{
  H245_CAP_NONSTANDARD_T        H245_NonStd;            /* not implemented */

  H245_CAP_NONSTANDARD_T        H245Vid_NONSTD;
  H245_CAP_H261_T               H245Vid_H261;
  H245_CAP_H262_T               H245Vid_H262;
  H245_CAP_H263_T               H245Vid_H263;
  H245_CAP_VIS11172_T           H245Vid_IS11172;

  H245_CAP_NONSTANDARD_T        H245Aud_NONSTD;
  unsigned short                H245Aud_G711_ALAW64;
  unsigned short                H245Aud_G711_ALAW56;
  unsigned short                H245Aud_G711_ULAW64;
  unsigned short                H245Aud_G711_ULAW56;
  unsigned short                H245Aud_G722_64;
  unsigned short                H245Aud_G722_56;
  unsigned short                H245Aud_G722_48;
  H245_CAP_G723_T               H245Aud_G723;
  unsigned short                H245Aud_G728;
  unsigned short                H245Aud_G729;
  unsigned short                H245Aud_GDSVD;
  H245_CAP_AIS11172_T           H245Aud_IS11172;
  H245_CAP_IS13818_T            H245Aud_IS13818;

  H245_CAP_DATAAPPLICATION_T    H245Dat_NONSTD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T120;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSMCC;
  H245_CAP_DATAAPPLICATION_T    H245Dat_USERDATA;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T84;
  H245_CAP_DATAAPPLICATION_T    H245Dat_T434;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H224;
  H245_CAP_DATAAPPLICATION_T    H245Dat_NLPID;
  H245_CAP_DATAAPPLICATION_T    H245Dat_DSVD;
  H245_CAP_DATAAPPLICATION_T    H245Dat_H222;

  ASN1_BOOL                     H245Encryption_TX;
  unsigned char                 H245Encryption_RX;
  H245_CAP_CONFERENCE_T         H245Conference;

  // Multiplex capabilities
  H245_CAP_NONSTANDARD_T        H245Mux_NONSTD;
  H245_CAP_H222_T               H245Mux_H222;
  H245_CAP_H223_T               H245Mux_H223;
  H245_CAP_VGMUX_T              H245Mux_VGMUX;
  H245_CAP_H2250_T              H245Mux_H2250;

} H245_CAP_T;

/* H245_CAPID_T */
typedef unsigned short H245_CAPID_T;
#define H245_INVALID_CAPID      ((H245_CAPID_T)-1)
#define H245_MAX_CAPID			(((H245_CAPID_T)-1) / 2)

/* H245_CAPDESCID_T */
typedef unsigned short H245_CAPDESCID_T;
#define H245_INVALID_CAPDESCID  ((H245_CAPDESCID_T)-1)

/* H245_SIMCAP_T */
#define H245_MAX_ALTCAPS        16
typedef struct
{
  unsigned short Length;                     /* number of CapId's in Array   */
  H245_CAPID_T AltCaps[H245_MAX_ALTCAPS];   /* list of alternatives CapId's */

} H245_SIMCAP_T;

#define H245_MAX_SIMCAPS        16
/* H245_CAPDESC_T */
typedef struct
{
  unsigned short Length;
  H245_SIMCAP_T SimCapArray[H245_MAX_SIMCAPS];

} H245_CAPDESC_T;

/* H245_TOTCAPDESC_T */
typedef struct
{
  H245_CAPDESCID_T      CapDescId;
  H245_CAPDESC_T        CapDesc;

} H245_TOTCAPDESC_T;

/* H245_TOTCAP_T */
typedef struct
{
  H245_CAPDIR_T   Dir;
  H245_DATA_T     DataType;
  H245_CLIENT_T   ClientType;
  H245_CAPID_T    CapId;
  H245_CAP_T      Cap;

} H245_TOTCAP_T;



/* H245_CONFIG_T */
typedef enum
{
  H245_CONF_H324 = 1,
  H245_CONF_H323,
  H245_CONF_H310,
  H245_CONF_GVD

} H245_CONFIG_T;




/* H245_ACC_REJ_T */

typedef unsigned long H245_ACC_REJ_T;

#define H245_ACC                        0
#define H245_REJ                        1 // unspecified

// Master Slave Determination reject causes
#define H245_REJ_MSD_IDENTICAL          identicalNumbers_chosen

// Terminal Capability Set reject causes
#define H245_REJ_UNDEF_TBL_ENTRY        undefinedTableEntryUsed_chosen
#define H245_REJ_DIS_CAP_EXCEED         dscrptrCpctyExcdd_chosen
#define H245_REJ_TBLENTRY_CAP_EXCEED    tblEntryCpctyExcdd_chosen

// Open Logical Channel reject causes
#define H245_REJ_REV_PARAM              unstblRvrsPrmtrs_chosen
#define H245_REJ_TYPE_NOTSUPPORT        dataTypeNotSupported_chosen
#define H245_REJ_TYPE_NOTAVAIL          dataTypeNotAvailable_chosen
#define H245_REJ_TYPE_UNKNOWN           unknownDataType_chosen
#define H245_REJ_AL_COMB                dtTypALCmbntnNtSpprtd_chosen
#define H245_REJ_MULTICAST              mltcstChnnlNtAllwd_chosen
#define H245_REJ_BANDWIDTH              insufficientBandwidth_chosen
#define H245_REJ_STACK                  sprtStckEstblshmntFld_chosen
#define H245_REJ_SESSION_ID             invalidSessionID_chosen
#define H245_REJ_MASTER_SLAVE_CONFLICT  masterSlaveConflict_chosen

// Request Channel Close reject causes - use H245_REJ

// Multiplex Table Entry Send reject causes
#define H245_REJ_MUX_COMPLICATED        descriptorTooComplex_chosen

// Request Mode reject causes
#define H245_REJ_UNAVAILABLE            modeUnavailable_chosen
#define H245_REJ_MULTIPOINT             multipointConstraint_chosen
#define H245_REJ_DENIED                 requestDenied_chosen




/* H245_ACC_REJ_MUX_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_ACC_REJ_MUX_T[15];

/* H245_H222_LOGICAL_PARAM_T */
typedef struct
{
  unsigned short        resourceID;
  unsigned short        subChannelID;
  ASN1_BOOL             pcr_pidPresent;
  unsigned short        pcr_pid;                // optional
  H245_OCTET_STRING_T   programDescriptors;     // optional
  H245_OCTET_STRING_T   streamDescriptors;      // optional
} H245_H222_LOGICAL_PARAM_T;

/* H245_H223_LOGICAL_PARAM_T */
typedef enum
{
  H245_H223_AL_NONSTD        = H223LCPs_aLTp_nnStndrd_chosen,
  H245_H223_AL_AL1FRAMED     = H223LCPs_aLTp_al1Frmd_chosen,
  H245_H223_AL_AL1NOTFRAMED  = H223LCPs_aLTp_al1NtFrmd_chosen,
  H245_H223_AL_AL2NOSEQ      = H223LCPs_aLTp_a2WSNs_1_chosen,
  H245_H223_AL_AL2SEQ        = H223LCPs_aLTp_a2WSNs_2_chosen,
  H245_H223_AL_AL3           = H223LCPs_aLTp_al3_chosen

} H245_H223_AL_T;

typedef struct
{
  H245_H223_AL_T                AlType;
  unsigned int                  SndBufSize;   // 0..16777215
  unsigned char                 CtlFldOctet;  // 0..2
  ASN1_BOOL                     SegmentFlag;
  H245_NONSTANDARD_PARAMETER_T  H223_NONSTD;

} H245_H223_LOGICAL_PARAM_T;

/* H245_VGMUX_LOGICAL_PARAM_T */
typedef enum
{
  H245_V76_CRC8BIT  = crc8bit_chosen,
  H245_V76_CRC16BIT = crc16bit_chosen,
  H245_V76_CRC32BIT = crc32bit_chosen
} H245_V76_CRC_LENGTH_T;

typedef enum
{
  H245_V76_WITH_ADDRESS    = wAddress_chosen,
  H245_V76_WITHOUT_ADDRESS = woAddress_chosen
} H245_V76_SUSPEND_RESUME_T;

typedef enum
{
  H245_V76_ERM   = eRM_chosen,
  H245_V76_UNERM = uNERM_chosen
} H245_V76_MODE_T;

typedef enum
{
  H245_V76_REJ   = rej_chosen,
  H245_V76_SREJ  = sREJ_chosen,
  H245_V76_MSREJ = mSREJ_chosen
} H245_V76_RECOVERY_T;

typedef struct
{
  H245_V76_CRC_LENGTH_T       crcLength;
  unsigned short              n401;
  ASN1_BOOL                   loopbackTestProcedure;
  H245_V76_SUSPEND_RESUME_T   suspendResume;
  ASN1_BOOL                   uIH;
  H245_V76_MODE_T             mode;
  unsigned short              windowSize;       // Only valid if mode = ERM
  H245_V76_RECOVERY_T         recovery;         // Only valid if mode = ERM
  ASN1_BOOL                   audioHeaderPresent;
} H245_VGMUX_LOGICAL_PARAM_T;


typedef struct
{
  unsigned char               type;
  /* Note: All unicast types should be odd */
#define H245_IP_UNICAST       1
#define H245_IP_MULTICAST     2
#define H245_IP6_UNICAST      3
#define H245_IP6_MULTICAST    4
#define H245_IPSSR_UNICAST    5  // IP Strict Source Route
#define H245_IPLSR_UNICAST    6  // IP Loose  Source Route
#define H245_IPX_UNICAST      9
#define H245_NETBIOS_UNICAST 11
  union
  {
    // type == H245_IP_UNICAST or H245_IP_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
    } ip;

    // type == H245_IP6_UNICAST or H245_IP6_MULTICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[16];
    } ip6;

    // type == H245_IPSSR_UNICAST or H245_IPLSR_UNICAST
    struct
    {
       unsigned short         tsapIdentifier;
       unsigned char          network[4];
       unsigned char *        route;            // Routing info
       unsigned long          dwCount;          // Number of addresses in above
    } ipSourceRoute;

    // type == H245_IPX_UNICAST
    struct
    {
       unsigned char          node[6];
       unsigned char          netnum[4];
       unsigned char          tsapIdentifier[2];
    } ipx;

    // type == H245_NETBIOS_UNICAST
    unsigned char             netBios[16];
  } u;
} H245_TRANSPORT_ADDRESS_T;

/* H245_H2250_LOGICAL_PARAM_T */
typedef struct
{
  // Note: first 8 fields MUST be same as H245_H2250ACK_LOGICAL_PARAM_T
  H2250LCPs_nnStndrdLink      nonStandardList;              // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;        // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent; // TRUE if previous field used
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
  ASN1_BOOL                   silenceSuppression;           // TRUE if using silence suppression
  ASN1_BOOL                   silenceSuppressionPresent;    // TRUE if previous field used
  H245_TERMINAL_LABEL_T       destination;                  // Terminal label for destination
  ASN1_BOOL                   destinationPresent;           // TRUE if previous field used
  ASN1_BOOL                   h261aVideoPacketization;
} H245_H2250_LOGICAL_PARAM_T;

/* H245_H2250ACK_LOGICAL_PARAM_T */
typedef struct
{
  H2250LCAPs_nnStndrdLink     nonStandardList;             // Optional
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                // Transport address
  ASN1_BOOL                   mediaChannelPresent;         // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;         // Forward RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;  // TRUE if previous field used
  unsigned char               dynamicRTPPayloadType;       // 96..127
  ASN1_BOOL                   dynamicRTPPayloadTypePresent;// TRUE if previous field used
  unsigned char               sessionID;                   // 1..255
  ASN1_BOOL                   sessionIDPresent;            // TRUE if previous field used
} H245_H2250ACK_LOGICAL_PARAM_T;


// Comments from MikeV.
// 07/17/98, mikev comments: this enum is hacky - it's using the ASN.1 choice 
// integers to tag internal structures.   The internal structures don't always 
// have a 1:1 relationship with the ASN.1. For example, H245_H2250ACK_LOGICAL_PARAM_T
// is tagged H245_H2250ACK, and there is no real "choice" for that

/* H245_MUX_T */
typedef enum
{
  H245_H222     = fLCPs_mPs_h222LCPs_chosen,
  H245_H223     = fLCPs_mPs_h223LCPs_chosen,
  H245_VGMUX    = fLCPs_mPs_v76LCPs_chosen,
  H245_H2250    = fLCPs_mPs_h2250LCPs_chosen,
  H245_H2250ACK = H245_H2250 + 1
} H245_MUX_KIND_T;

typedef struct
{
  H245_MUX_KIND_T Kind;
  union
  {
    H245_H222_LOGICAL_PARAM_T     H222;
    H245_H223_LOGICAL_PARAM_T     H223;
    H245_VGMUX_LOGICAL_PARAM_T    VGMUX;
    H245_H2250_LOGICAL_PARAM_T    H2250;
    H245_H2250ACK_LOGICAL_PARAM_T H2250ACK;
  } u;
} H245_MUX_T;


/*
   H245_MUX_ENTRY_ELEMENT_T

   This structure defines the multiplex pattern
   which will be used to decode bit patterns in
   a given mux table entry.  the Kind defines
   whether this is a recursive structure (i.e.
   pointing to yet another Mux Entry Element) or
   whether it is a terminating leaf in the recursive
   mux tree.

   RepeatCount indicates how many bits should be
   used for this channel.  If bit count == 0 this
   indicates repeat sequence until close flag
*/

typedef enum
{
  H245_MUX_LOGICAL_CHANNEL = 1,     /* logical channel number (Terminate list) */
  H245_MUX_ENTRY_ELEMENT            /* recursive.. yet another one             */
} H245_MUX_ENTRY_KIND_T;

typedef struct H245_MUX_ENTRY_ELEMENT_T
{
  struct H245_MUX_ENTRY_ELEMENT_T      *pNext;
  H245_MUX_ENTRY_KIND_T                 Kind;
  union
  {
      H245_CHANNEL_T                    Channel;
      struct H245_MUX_ENTRY_ELEMENT_T  *pMuxTblEntryElem;
  } u;

  /* RepeatCount                                */
  /* RepeatCount == 0 -> repeat until close     */
  /* RepeatCount != 0 -> repeate count          */
  unsigned long                         RepeatCount;

} H245_MUX_ENTRY_ELEMENT_T;


/*
   H245_MUX_TABLE_T

   an H245 Mux Table is defined as a linked list of
   Mux Entry Descriptors.  Each descriptor has an
   associated entry number.  These entry numbers
   range from 1-15 and must be unique within the table.
   The end of the list is designated by a pNext == NULL
*/

typedef  struct H245_MUX_TABLE_T
{
  struct H245_MUX_TABLE_T       *pNext;
  unsigned long                  MuxEntryId;
  H245_MUX_ENTRY_ELEMENT_T      *pMuxTblEntryElem;      /* NULL indicates delete entry */

} H245_MUX_TABLE_T;

/********************/
/********************/
/*  Indicator Code  */
/********************/
/********************/

#define H245_IND_MSTSLV                 0x01
#define H245_IND_CAP                    0x02
#define H245_IND_CESE_RELEASE           0x30
#define H245_IND_OPEN                   0x03
#define H245_IND_OPEN_CONF              0x04
#define H245_IND_CLOSE                  0x05
#define H245_IND_REQ_CLOSE              0x06
#define H245_IND_CLCSE_RELEASE          0x31
#define H245_IND_MUX_TBL                0x07
#define H245_IND_MTSE_RELEASE           0x08
#define H245_IND_RMESE                  0x09
#define H245_IND_RMESE_RELEASE          0x0A
#define H245_IND_MRSE                   0x0B
#define H245_IND_MRSE_RELEASE           0x0C
#define H245_IND_MLSE                   0x0D
#define H245_IND_MLSE_RELEASE           0x0E
#define H245_IND_NONSTANDARD_REQUEST    0x0F
#define H245_IND_NONSTANDARD_RESPONSE   0x10
#define H245_IND_NONSTANDARD_COMMAND    0x11
#define H245_IND_NONSTANDARD            0x12
#define H245_IND_MISC_COMMAND           0x13
#define H245_IND_MISC                   0x14
#define H245_IND_COMM_MODE_REQUEST      0x15
#define H245_IND_COMM_MODE_RESPONSE     0x16
#define H245_IND_COMM_MODE_COMMAND      0x17
#define H245_IND_CONFERENCE_REQUEST     0x18
#define H245_IND_CONFERENCE_RESPONSE    0x19
#define H245_IND_CONFERENCE_COMMAND     0x1A
#define H245_IND_CONFERENCE             0x1B
#define H245_IND_SEND_TERMCAP           0x1C
#define H245_IND_ENCRYPTION             0x1D
#define H245_IND_FLOW_CONTROL           0x1E
#define H245_IND_ENDSESSION             0x1F
#define H245_IND_FUNCTION_NOT_UNDERSTOOD 0x20
#define H245_IND_JITTER                 0x21
#define H245_IND_H223_SKEW              0x22
#define H245_IND_NEW_ATM_VC             0x23
#define H245_IND_USERINPUT              0x24
#define H245_IND_H2250_MAX_SKEW         0x25
#define H245_IND_MC_LOCATION            0x26
#define H245_IND_VENDOR_ID              0x27
#define H245_IND_FUNCTION_NOT_SUPPORTED 0x28
#define H245_IND_H223_RECONFIG          0x29
#define H245_IND_H223_RECONFIG_ACK      0x2A
#define H245_IND_H223_RECONFIG_REJECT   0x2B

/* H245_MSTSLV_T */
typedef enum
{
  H245_INDETERMINATE = 0,       // Master/Slave Determination failed
  H245_MASTER = master_chosen,  // Local terminal is Master
  H245_SLAVE  = slave_chosen    // Local terminal is Slave

} H245_MSTSLV_T;

/* H245_IND_OPEN_T */
typedef struct
{
  /* for receive */
  H245_CHANNEL_T RxChannel;
  H245_PORT_T    RxPort;        // optional
  H245_DATA_T    RxDataType;
  H245_CLIENT_T  RxClientType;
  H245_CAP_T    *pRxCap;
  H245_MUX_T    *pRxMux;

  /* for bi-directional channel */
  /* requested transmit stuff   */

  H245_DATA_T    TxDataType;
  H245_CLIENT_T  TxClientType;
  H245_CAP_T    *pTxCap;
  H245_MUX_T    *pTxMux;

  H245_ACCESS_T *pSeparateStack; // optional

} H245_IND_OPEN_T;

/* H245_IND_OPEN_CONF_T */
typedef struct
{
  /* receive channel              */
  /* remote requested channel #   */
  H245_CHANNEL_T          RxChannel;

  /* transmit channel                     */
  /* locally opened transmit channel #    */
  H245_CHANNEL_T          TxChannel;

} H245_IND_OPEN_CONF_T;

/* H245_IND_CLOSE_T */
typedef enum
{
  H245_USER = user_chosen,
  H245_LCSE = lcse_chosen

} H245_IND_CLOSE_REASON_T;

typedef struct
{
  H245_CHANNEL_T          Channel;
  H245_IND_CLOSE_REASON_T Reason;

} H245_IND_CLOSE_T;

/* H245_IND_MUX_TBL */
typedef struct
{
  H245_MUX_TABLE_T      *pMuxTbl;
  unsigned long          Count;

} H245_IND_MUXTBL_T;

/* H245_RMESE_T */
typedef struct
{
  unsigned short        awMultiplexTableEntryNumbers[15];
  unsigned long         dwCount;

} H245_RMESE_T;

/* H245_IND_MRSE_T */
typedef struct
{
  RequestedModesLink pRequestedModes;

} H245_IND_MRSE_T;

/* H245_MLSE_T */
typedef enum
{
  H245_SYSTEM_LOOP  = systemLoop_chosen,
  H245_MEDIA_LOOP   = mediaLoop_chosen,
  H245_CHANNEL_LOOP = logicalChannelLoop_chosen

} H245_LOOP_TYPE_T;

typedef struct
{
  H245_LOOP_TYPE_T      LoopType;
  H245_CHANNEL_T        Channel;

} H245_MLSE_T;

/* H245_IND_ENDSESSION_T */
typedef enum
{
  H245_ENDSESSION_NONSTD     = EndSssnCmmnd_nonStandard_chosen,
  H245_ENDSESSION_DISCONNECT = disconnect_chosen,
  H245_ENDSESSION_TELEPHONY,
  H245_ENDSESSION_V8BIS,
  H245_ENDSESSION_V34DSVD,
  H245_ENDSESSION_V34DUPFAX,
  H245_ENDSESSION_V34H324

} H245_ENDSESSION_T;

typedef struct
{
  H245_ENDSESSION_T             SessionMode;
  /* if non standard chosen */
  H245_NONSTANDARD_PARAMETER_T  SessionNonStd;

} H245_IND_ENDSESSION_T;

/* H245_IND_NONSTANDARD_T */
typedef struct
{
  unsigned char *        pData;
  unsigned long          dwDataLength;
  unsigned short *       pwObjectId;
  unsigned long          dwObjectIdLength;
  unsigned char          byCountryCode;
  unsigned char          byExtension;
  unsigned short         wManufacturerCode;
} H245_IND_NONSTANDARD_T;

typedef struct
{
  CMTEy_nnStndrdLink          pNonStandard;                 // NULL if not present
  unsigned char               sessionID;                    // 0..255
  unsigned char               associatedSessionID;          // 1..255
  ASN1_BOOL                   associatedSessionIDPresent;   // TRUE if previous field used
  H245_TERMINAL_LABEL_T       terminalLabel;
  ASN1_BOOL                   terminalLabelPresent;
  unsigned short *            pSessionDescription;
  unsigned short              wSessionDescriptionLength;
  H245_TOTCAP_T               dataType;
  H245_TRANSPORT_ADDRESS_T    mediaChannel;                 // Media Channel Address
  ASN1_BOOL                   mediaChannelPresent;          // TRUE if previous field used
  H245_TRANSPORT_ADDRESS_T    mediaControlChannel;          // Reverse RTCP channel
  ASN1_BOOL                   mediaControlChannelPresent;   // TRUE if previous field used
  ASN1_BOOL                   mediaGuaranteed;              // TRUE if guaranteed delivery
  ASN1_BOOL                   mediaGuaranteedPresent;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteed;       // TRUE if previous field used
  ASN1_BOOL                   mediaControlGuaranteedPresent;// TRUE if previous field used
} H245_COMM_MODE_ENTRY_T;

typedef struct
{
  H245_COMM_MODE_ENTRY_T *pTable;
  unsigned char          byTableCount;
} H245_IND_COMM_MODE_T;

typedef enum
{
  H245_REQ_TERMINAL_LIST            = terminalListRequest_chosen,
  H245_REQ_MAKE_ME_CHAIR            = makeMeChair_chosen,
  H245_REQ_CANCEL_MAKE_ME_CHAIR     = cancelMakeMeChair_chosen,
  H245_REQ_DROP_TERMINAL            = dropTerminal_chosen,
  H245_REQ_TERMINAL_ID              = requestTerminalID_chosen,
  H245_REQ_ENTER_H243_PASSWORD      = enterH243Password_chosen,
  H245_REQ_ENTER_H243_TERMINAL_ID   = enterH243TerminalID_chosen,
  H245_REQ_ENTER_H243_CONFERENCE_ID = enterH243ConferenceID_chosen
} H245_CONFER_REQ_ENUM_T;

typedef struct
{
  H245_CONFER_REQ_ENUM_T  RequestType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_REQ_T;

typedef enum
{
  H245_RSP_MC_TERMINAL_ID           = mCTerminalIDResponse_chosen,
  H245_RSP_TERMINAL_ID              = terminalIDResponse_chosen,
  H245_RSP_CONFERENCE_ID            = conferenceIDResponse_chosen,
  H245_RSP_PASSWORD                 = passwordResponse_chosen,
  H245_RSP_TERMINAL_LIST            = terminalListResponse_chosen,
  H245_RSP_VIDEO_COMMAND_REJECT     = videoCommandReject_chosen,
  H245_RSP_TERMINAL_DROP_REJECT     = terminalDropReject_chosen,
  H245_RSP_DENIED_CHAIR_TOKEN,
  H245_RSP_GRANTED_CHAIR_TOKEN
} H245_CONFER_RSP_ENUM_T;

typedef struct
{
  H245_CONFER_RSP_ENUM_T  ResponseType;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
  unsigned char          *pOctetString;
  unsigned char           byOctetStringLength;
  TerminalLabel          *pTerminalList;
  unsigned short          wTerminalListCount;
} H245_CONFER_RSP_T;

typedef enum
{
  H245_CMD_BROADCAST_CHANNEL        = brdcstMyLgclChnnl_chosen,
  H245_CMD_CANCEL_BROADCAST_CHANNEL = cnclBrdcstMyLgclChnnl_chosen,
  H245_CMD_BROADCASTER              = makeTerminalBroadcaster_chosen,
  H245_CMD_CANCEL_BROADCASTER       = cnclMkTrmnlBrdcstr_chosen,
  H245_CMD_SEND_THIS_SOURCE         = sendThisSource_chosen,
  H245_CMD_CANCEL_SEND_THIS_SOURCE  = cancelSendThisSource_chosen,
  H245_CMD_DROP_CONFERENCE          = dropConference_chosen
} H245_CONFER_CMD_ENUM_T;

typedef struct
{
  H245_CONFER_CMD_ENUM_T  CommandType;
  H245_CHANNEL_T          Channel;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_CMD_T;

typedef enum
{
  H245_IND_SBE_NUMBER               = sbeNumber_chosen,
  H245_IND_TERMINAL_NUMBER_ASSIGN   = terminalNumberAssign_chosen,
  H245_IND_TERMINAL_JOINED          = terminalJoinedConference_chosen,
  H245_IND_TERMINAL_LEFT            = terminalLeftConference_chosen,
  H245_IND_SEEN_BY_ONE_OTHER        = seenByAtLeastOneOther_chosen,
  H245_IND_CANCEL_SEEN_BY_ONE_OTHER = cnclSnByAtLstOnOthr_chosen,
  H245_IND_SEEN_BY_ALL              = seenByAll_chosen,
  H245_IND_CANCEL_SEEN_BY_ALL       = cancelSeenByAll_chosen,
  H245_IND_TERMINAL_YOU_ARE_SEEING  = terminalYouAreSeeing_chosen,
  H245_IND_REQUEST_FOR_FLOOR        = requestForFloor_chosen
} H245_CONFER_IND_ENUM_T;

typedef struct
{
  H245_CONFER_IND_ENUM_T  IndicationType;
  unsigned char           bySbeNumber;
  unsigned char           byMcuNumber;
  unsigned char           byTerminalNumber;
} H245_CONFER_IND_T;

typedef enum
{
  H245_SCOPE_CHANNEL_NUMBER   = FCCd_scp_lgclChnnlNmbr_chosen,
  H245_SCOPE_RESOURCE_ID      = FlwCntrlCmmnd_scp_rsrcID_chosen,
  H245_SCOPE_WHOLE_MULTIPLEX  = FCCd_scp_whlMltplx_chosen
} H245_SCOPE_T;

#define H245_NO_RESTRICTION 0xFFFFFFFFL

typedef struct
{
  H245_SCOPE_T           Scope;
  H245_CHANNEL_T         Channel;       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
  unsigned short         wResourceID;   // only used if Scope is H245_SCOPE_RESOURCE_ID
  unsigned long          dwRestriction; // H245_NO_RESTRICTION if no restriction
} H245_IND_FLOW_CONTROL_T;

/* H245_USERINPUT_T */
typedef enum
{
  H245_USERINPUT_NONSTD = UsrInptIndctn_nnStndrd_chosen,
  H245_USERINPUT_STRING = alphanumeric_chosen
} H245_USERINPUT_KIND_T;

typedef struct
{
  H245_USERINPUT_KIND_T     Kind;
  union
  {
    WCHAR *                           pGenString;
    H245_NONSTANDARD_PARAMETER_T      NonStd;
  } u;
} H245_IND_USERINPUT_T;

typedef struct
{
  H245_CHANNEL_T        LogicalChannelNumber1;
  H245_CHANNEL_T        LogicalChannelNumber2;
  unsigned short        wSkew;
} H245_IND_SKEW_T;

typedef struct
{
  H245_NONSTANDID_T      Identifier;
  unsigned char         *pProductNumber;
  unsigned char          byProductNumberLength;
  unsigned char         *pVersionNumber;
  unsigned char          byVersionNumberLength;
} H245_IND_VENDOR_ID_T;

typedef enum
{
  UNKNOWN,
  REQ_NONSTANDARD,
  REQ_MASTER_SLAVE,
  REQ_TERMCAP_SET,
  REQ_OPEN_LOGICAL_CHANNEL,
  REQ_CLOSE_LOGICAL_CHANNEL,
  REQ_REQUEST_CHANNEL_CLOSE,
  REQ_MULTIPLEX_ENTRY_SEND,
  REQ_REQUEST_MULTIPLEX_ENTRY,
  REQ_REQUEST_MODE,
  REQ_ROUND_TRIP_DELAY,
  REQ_MAINTENANCE_LOOP,
  REQ_COMMUNICATION_MODE,
  REQ_CONFERENCE,
  REQ_H223_ANNEX_A_RECONFIG,
  RSP_NONSTANDARD,
  RSP_MASTER_SLAVE_ACK,
  RSP_MASTER_SLAVE_REJECT,
  RSP_TERMCAP_SET_ACK,
  RSP_TERMCAP_SET_REJECT,
  RSP_OPEN_LOGICAL_CHANNEL_ACK,
  RSP_OPEN_LOGICAL_CHANNEL_REJECT,
  RSP_CLOSE_LOGICAL_CHANNEL_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_ACK,
  RSP_REQUEST_CHANNEL_CLOSE_REJECT,
  RSP_MULTIPLEX_ENTRY_SEND_ACK,
  RSP_MULTIPLEX_ENTRY_SEND_REJECT,
  RSP_REQUEST_MULTIPLEX_ENTRY_ACK,
  RSP_REQUEST_MULTIPLEX_ENTRY_REJECT,
  RSP_REQUEST_MODE_ACK,
  RSP_REQUEST_MODE_REJECT,
  RSP_ROUND_TRIP_DELAY,
  RSP_MAINTENANCE_LOOP_ACK,
  RSP_MAINTENANCE_LOOP_REJECT,
  RSP_COMMUNICATION_MODE,
  RSP_CONFERENCE,
  RSP_H223_ANNEX_A_RECONFIG_ACK,
  RSP_H223_ANNEX_A_RECONFIG_REJECT,
  CMD_NONSTANDARD,
  CMD_MAINTENANCE_LOOP_OFF,
  CMD_SEND_TERMCAP,
  CMD_ENCRYPTION,
  CMD_FLOW_CONTROL,
  CMD_END_SESSION,
  CMD_MISCELLANEOUS,
  CMD_COMMUNICATION_MODE,
  CMD_CONFERENCE,
  IND_NONSTANDARD,
  IND_FUNCTION_NOT_UNDERSTOOD,
  IND_MASTER_SLAVE_RELEASE,
  IND_TERMCAP_SET_RELEASE,
  IND_OPEN_LOGICAL_CHANNEL_CONFIRM,
  IND_REQUEST_CHANNEL_CLOSE_RELEASE,
  IND_MULTIPLEX_ENTRY_SEND_RELEASE,
  IND_REQUEST_MULTIPLEX_ENTRY_RELEASE,
  IND_REQUEST_MODE_RELEASE,
  IND_MISCELLANEOUS,
  IND_JITTER,
  IND_H223_SKEW,
  IND_NEW_ATM_VC,
  IND_USER_INPUT,
  IND_H2250_MAX_SKEW,
  IND_MC_LOCATION,
  IND_CONFERENCE_INDICATION,
  IND_VENDOR_IDENTIFICATION,
  IND_FUNCTION_NOT_SUPPORTED,
} H245_SUBMESSAGE_T;

typedef enum
{
  H245_SYNTAX_ERROR     = syntaxError_chosen,
  H245_SEMANTIC_ERROR   = semanticError_chosen,
  H245_UNKNOWN_FUNCTION = unknownFunction_chosen
} H245_FNS_CAUSE_T;

typedef struct
{
  H245_FNS_CAUSE_T      Cause;
  H245_SUBMESSAGE_T     Type;
} H245_IND_FNS_T;

/**************/
/* H245_IND_T */
/**************/

typedef struct
{
  unsigned long         Indicator;              // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  union
  {
    H245_MSTSLV_T            IndMstSlv;         // H245_IND_MSTSLV
                                                // H245_IND_CAP
                                                // H245_IND_CESE_RELEASE
    H245_IND_OPEN_T          IndOpen;           // H245_IND_OPEN
    H245_IND_OPEN_CONF_T     IndOpenConf;       // H245_IND_OPEN_CONF
    H245_IND_CLOSE_T         IndClose;          // H245_IND_CLOSE
    H245_CHANNEL_T           IndReqClose;       // H245_IND_REQ_CLOSE
                                                // H245_IND_CLCSE_RELEASE
    H245_IND_MUXTBL_T        IndMuxTbl;         // H245_IND_MUX_TBL
                                                // H245_IND_MTSE_RELEASE
    H245_RMESE_T             IndRmese;          // H245_IND_RMESE
                                                // H245_IND_RMESE_RELEASE
    H245_IND_MRSE_T          IndMrse;           // H245_IND_MRSE
                                                // H245_IND_MRSE_RELEASE
    H245_MLSE_T              IndMlse;           // H245_IND_MLSE
                                                // H245_IND_MLSE_RELEASE
    H245_IND_NONSTANDARD_T   IndNonstandardRequest; // H245_IND_NONSTANDARD_REQUEST
    H245_IND_NONSTANDARD_T   IndNonstandardResponse; // H245_IND_NONSTANDARD_RESPONSE
    H245_IND_NONSTANDARD_T   IndNonstandardCommand; // H245_IND_NONSTANDARD_COMMAND
    H245_IND_NONSTANDARD_T   IndNonstandard;    // H245_IND_NONSTANDARD
                                                // H245_IND_MISC_COMMAND
                                                // H245_IND_MISC
                                                // H245_IND_COMM_MODE_REQUEST
    H245_IND_COMM_MODE_T     IndCommRsp;        // H245_IND_COMM_MODE_RESPONSE
    H245_IND_COMM_MODE_T     IndCommCmd;        // H245_IND_COMM_MODE_COMMAND
    H245_CONFER_REQ_T        IndConferReq;      // H245_IND_CONFERENCE_REQUEST
    H245_CONFER_RSP_T        IndConferRsp;      // H245_IND_CONFERENCE_RESPONSE
    H245_CONFER_CMD_T        IndConferCmd;      // H245_IND_CONFERENCE_COMMAND
    H245_CONFER_IND_T        IndConfer;         // H245_IND_CONFERENCE
                                                // H245_IND_SEND_TERMCAP
                                                // H245_IND_ENCRYPTION
    H245_IND_FLOW_CONTROL_T  IndFlowControl;    // H245_IND_FLOW_CONTROL
    H245_IND_ENDSESSION_T    IndEndSession;     // H245_IND_ENDSESSION
                                                // H245_IND_FUNCTION_NOT_UNDERSTOOD
                                                // H245_IND_JITTER
    H245_IND_SKEW_T          IndH223Skew;       // H245_IND_H223_SKEW
                                                // H245_IND_NEW_ATM_VC
    H245_IND_USERINPUT_T     IndUserInput;      // H245_IND_USERINPUT
    H245_IND_SKEW_T          IndH2250MaxSkew;   // H245_IND_H2250_MAX_SKEW
    H245_TRANSPORT_ADDRESS_T IndMcLocation;     // H245_IND_MC_LOCATION
    H245_IND_VENDOR_ID_T     IndVendorId;       // H245_IND_VENDOR_ID
    H245_IND_FNS_T           IndFns;            // H245_IND_FUNCTION_NOT_SUPPORTED
                                                // H245_IND_H223_RECONFIG
                                                // H245_IND_H223_RECONFIG_ACK
                                                // H245_IND_H223_RECONFIG_REJECT
  } u;
} H245_IND_T;


/********************/
/********************/
/*  Confirm   Code  */
/********************/
/********************/

#define H245_CONF_INIT_MSTSLV    0x101
#define H245_CONF_SEND_TERMCAP   0x102
#define H245_CONF_OPEN           0x103
#define H245_CONF_NEEDRSP_OPEN   0x104
#define H245_CONF_CLOSE          0x105
#define H245_CONF_REQ_CLOSE      0x106
#define H245_CONF_MUXTBL_SND     0x107

#define H245_CONF_RMESE          0x109
#define H245_CONF_RMESE_REJECT   0x10A
#define H245_CONF_RMESE_EXPIRED  0x10B
#define H245_CONF_MRSE           0x10C
#define H245_CONF_MRSE_REJECT    0x10D
#define H245_CONF_MRSE_EXPIRED   0x10E
#define H245_CONF_MLSE           0x10F
#define H245_CONF_MLSE_REJECT    0x110
#define H245_CONF_MLSE_EXPIRED   0x111
#define H245_CONF_RTDSE          0x112
#define H245_CONF_RTDSE_EXPIRED  0x113

/* H245_CONF_SEND_TERMCAP_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;

} H245_CONF_SEND_TERMCAP_T;

/* H245_CONF_OPEN_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        TxChannel;
  H245_MUX_T *          pTxMux;         // optional
  H245_CHANNEL_T        RxChannel;      // bi-dir only
  H245_MUX_T *          pRxMux;         // bi-dir only
  H245_PORT_T           RxPort;         // bi-dir only
  H245_ACCESS_T *       pSeparateStack; // optional

} H245_CONF_OPEN_T;

typedef H245_CONF_OPEN_T H245_CONF_NEEDRSP_OPEN_T;

/* H245_CONF_CLOSE_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  H245_CHANNEL_T        Channel;

} H245_CONF_CLOSE_T;

/* H245_CONF_REQ_CLOSE_T */
typedef H245_CONF_CLOSE_T H245_CONF_REQ_CLOSE_T;

/* H245_CONF_MUXTBL_T */
typedef struct
{
  H245_ACC_REJ_T        AccRej;
  unsigned long         MuxEntryId;

} H245_CONF_MUXTBL_T;



/***************/
/* H245_CONF_T */
/***************/

typedef struct
{
  unsigned long         Confirm;                // Type
  unsigned long         dwPreserved;            // User supplied dwPreserved from H245Init()
  unsigned long         dwTransId;              // User supplied dwTransId from originating call
  HRESULT               Error;                  // Error code
  union                                         // Data for specific indications:
  {
    H245_MSTSLV_T             ConfMstSlv;       // H245_CONF_INIT_MSTSLV
    H245_CONF_SEND_TERMCAP_T  ConfSndTcap;      // H245_CONF_SEND_TERMCAP
    H245_CONF_OPEN_T          ConfOpen;         // H245_CONF_OPEN
    H245_CONF_NEEDRSP_OPEN_T  ConfOpenNeedRsp;  // H245_CONF_NEEDRSP_OPEN
    H245_CONF_CLOSE_T         ConfClose;        // H245_CONF_CLOSE
    H245_CONF_REQ_CLOSE_T     ConfReqClose;     // H245_CONF_REQ_CLOSE
    H245_CONF_MUXTBL_T        ConfMuxSnd;       // H245_CONF_MUXTBL_SND
    H245_RMESE_T              ConfRmese;        // H245_CONF_RMESE
    H245_RMESE_T              ConfRmeseReject;  // H245_CONF_RMESE_REJECT
                                                // H245_CONF_RMESE_EXPIRED
    unsigned short            ConfMrse;         // H245_CONF_MRSE
    unsigned short            ConfMrseReject;   // H245_CONF_MRSE_REJECT
                                                // H245_CONF_MRSE_EXPIRED
    H245_MLSE_T               ConfMlse;         // H245_CONF_MLSE
    H245_MLSE_T               ConfMlseReject;   // H245_CONF_MLSE_REJECT
                                                // H245_CONF_MLSE_EXPIRED
                                                // H245_CONF_RTDSE
                                                // H245_CONF_RTDSE_EXPIRED
  } u;
} H245_CONF_T;



typedef enum
{
  H245_MESSAGE_REQUEST     = MltmdSystmCntrlMssg_rqst_chosen,
  H245_MESSAGE_RESPONSE    = MSCMg_rspns_chosen,
  H245_MESSAGE_COMMAND     = MSCMg_cmmnd_chosen,
  H245_MESSAGE_INDICATION  = indication_chosen
} H245_MESSAGE_TYPE_T;



/*******************/
/* H245_CONF_IND_T */
/*******************/
typedef enum
{
  H245_CONF = 1,
  H245_IND
} H245_CONF_IND_KIND_T;

typedef struct
{
  H245_CONF_IND_KIND_T  Kind;
  union
  {
    H245_CONF_T         Confirm;
    H245_IND_T          Indication;
  } u;

} H245_CONF_IND_T;



/***************************/
/* SYSTEM CONTROL MESSAGES */
/***************************/

typedef struct
{
  unsigned long NumPduTx;       /* number of tranmitted pdu's    */
  unsigned long NumPduRx;       /* number of received pdu's      */
  unsigned long NumCRCErrors;   /* number of crc errors          */
  unsigned long NumPduReTx;     /* number of pdu's retransmitted */

} H245_SYSCON_STATS_T;

#define H245_SYSCON_TRACE_LVL           0x0100  /* pData = &dwTraceLevel   */
#define H245_SYSCON_DUMP_TRACKER        0x0200  /* pData = NULL (debug)    */
#define H245_SYSCON_GET_STATS           0x0300  /* pData = &H245_SYSCON_STATS_T */
#define H245_SYSCON_RESET_STATS         0x0400  /* pData = NULL            */

#define H245_SYSCON_SET_FSM_N100        0x1000  /* pData = &dwRetryCount   */
#define H245_SYSCON_SET_FSM_T101        0x1100  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T102        0x1200  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T103        0x1300  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T104        0x1400  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T105        0x1500  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T106        0x1600  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T107        0x1700  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T108        0x1800  /* pData = &dwMilliseconds */
#define H245_SYSCON_SET_FSM_T109        0x1900  /* pData = &dwMilliseconds */

#define H245_SYSCON_GET_FSM_N100        0x2000  /* pData = &dwRetryCount   */
#define H245_SYSCON_GET_FSM_T101        0x2100  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T102        0x2200  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T103        0x2300  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T104        0x2400  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T105        0x2500  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T106        0x2600  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T107        0x2700  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T108        0x2800  /* pData = &dwMilliseconds */
#define H245_SYSCON_GET_FSM_T109        0x2900  /* pData = &dwMilliseconds */



/************************/
/* PROTOCOL ID FOR H245 */
/************************/

#define H245_PROTOID                    "0.0.8.245.0.2"



/**************************************************/
/* API Procedure Call Typedefs and API Prototypes */
/**************************************************/

typedef unsigned long H245_INST_T;
typedef HRESULT (*H245_CONF_IND_CALLBACK_T)(H245_CONF_IND_T *, void *);
typedef int (*H245_CAP_CALLBACK_T)(unsigned long, H245_TOTCAP_T *);
typedef int (*H245_CAPDESC_CALLBACK_T)(unsigned long, H245_TOTCAPDESC_T *);

#ifdef __cplusplus
extern "C" {
#endif

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwPhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         unsigned long            dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        );

H245DLL H245_INST_T
H245GetInstanceId       (unsigned long          dwPhysicalId);

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst);

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        );

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        );

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        );

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        );

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         unsigned long            dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        );

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T      * * ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T  * * ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        );

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T		   **ppDestTotCap,
						 const H245_TOTCAP_T   *pTotCap);

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T          *pTotCap);

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T		 **ppDestCapDesc,
						 const H245_TOTCAPDESC_T *pCapDesc);

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T     *pCapDesc);

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *     pMux);

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux);

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        );

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        );

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        );

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        );

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        );

/*
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         const ModeElement *    pModeElements,
                         unsigned long          dwCount
                        );
*/
H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
//                         const ModeElement *    pModeElements,
//tomitowoju@intel.com
						 ModeDescription 		ModeDescriptions[],
//tomitowoju@intel.com
                         unsigned long          dwCount
                        ) ;



H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        );

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId
                        );

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         unsigned long          dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst);

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        );

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        );

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        );

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        );

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst);

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        );

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        );

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        );

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                  pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        );

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        );

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        );

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        );

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        );

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,       // optional
                         unsigned char          byProductNumberLength,// optional
                         const unsigned char   *pVersionNumber,       // optional
                         unsigned char          byVersionNumberLength // optional
                        );

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        );

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        );

#ifdef __cplusplus
        }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\h245asn1.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef H245ASN1_H
#define H245ASN1_H

#include "h245.h"
#include "av_asn1.h"
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif


// LONCHANC: ORIGINAL MAPPING WITH NEW STRUCTURE NAMES

#define VCCapabilityLink                PH222Capability_vcCapability
#define SmltnsCpbltsLink                PCapabilityDescriptor_simultaneousCapabilities
#define CapabilityTableLink             PTerminalCapabilitySet_capabilityTable
#define MultiplexEntryDescriptorLink    PMultiplexEntrySend_multiplexEntryDescriptors
#define CommunicationModeTableLink      PCommunicationModeResponse_communicationModeTable
#define TerminalListResponseLink        PConferenceResponse_terminalListResponse
#define CpbltyTblEntryNmbrsLink         PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers
#define CommunicationModeCommandLink    PCommunicationModeCommand_communicationModeTable
#define CentralizedDataLink             PMediaDistributionCapability_centralizedData
#define DistributedDataLink             PMediaDistributionCapability_distributedData
#define MediaDistributionCapabilityLink PMultipointCapability_mediaDistributionCapability
#define NonStandardDataLink             PConferenceCapability_nonStandardData
#define RouteLink                       PUnicastAddress_iPSourceRouteAddress_route
#define H2250LCPs_nnStndrdLink          PH2250LogicalChannelParameters_nonStandard
#define MultiplexElementLink            PMultiplexElement_type_subElementList
#define RequestedModesLink              PRequestMode_requestedModes
#define H2250LCAPs_nnStndrdLink         PH2250LogicalChannelAckParameters_nonStandard
#define CMTEy_nnStndrdLink              PCommunicationModeTableEntry_nonStandard
#define OBJECTID                        struct ObjectID_
#define POBJECTID                       struct ObjectID_ *
typedef DataApplicationCapability_application_t84       H245_CAP_T84_T;
typedef DataApplicationCapability_application_nlpid     H245_CAP_NLPID_T;
typedef AudioCapability_g7231                           H245_CAP_G723_T;


// LONCHANC: NEW MAPPING FOR FIELDS AND DEFINITIONS

// _choice2 vs H223Capability_h223MultiplexTableCapability
#define h223MltplxTblCpblty_bsc_chosen  H223Capability_h223MultiplexTableCapability_basic_chosen
#define h223MTCy_enhncd_chosen          H223Capability_h223MultiplexTableCapability_enhanced_chosen
#define h223MTCy_enhncd                 enhanced

// V76Capability
#define sspndRsmCpbltywAddrss           suspendResumeCapabilitywoAddress

// DataProtocolCapability
#define DtPrtclCpblty_nnStndrd_chosen   DataProtocolCapability_nonStandard_chosen
#define sgmnttnAndRssmbly_chosen        segmentationAndReassembly_chosen          
#define DtPrtclCpblty_nnStndrd          nonStandard

// _choice3 vs DataApplicationCapability_application
#define DACy_applctn_nnStndrd_chosen    DataApplicationCapability_application_nonStandard_chosen
#define DACy_applctn_t120_chosen        DataApplicationCapability_application_t120_chosen
#define DACy_applctn_dsm_cc_chosen      DataApplicationCapability_application_dsm_cc_chosen
#define DACy_applctn_usrDt_chosen       DataApplicationCapability_application_userData_chosen
#define DACy_applctn_t84_chosen         DataApplicationCapability_application_t84_chosen
#define DACy_applctn_t434_chosen        DataApplicationCapability_application_t434_chosen
#define DACy_applctn_h224_chosen        DataApplicationCapability_application_h224_chosen
#define DACy_applctn_nlpd_chosen        DataApplicationCapability_application_nlpid_chosen
#define DACy_applctn_dsvdCntrl_chosen   DataApplicationCapability_application_dsvdControl_chosen
#define DACy_an_h222DtPrttnng_chosen    DataApplicationCapability_application_h222DataPartitioning_chosen
#define DACy_applctn_nnStndrd           nonStandard
#define DACy_applctn_t120               t120
#define DACy_applctn_dsm_cc             dsm_cc
#define DACy_applctn_usrDt              userData
#define DACy_applctn_t84                t84
#define DACy_applctn_t434               t434
#define DACy_applctn_h224               h224
#define DACy_applctn_nlpd               nlpid
#define DACy_an_h222DtPrttnng           h222DataPartitioning

// H2250Capability
#define rcvAndTrnsmtMltpntCpblty        receiveAndTransmitMultipointCapability

// _choice4 vs H223AnnexACapability_h223AnnexAMultiplexTableCapability
#define h223AAMTCy_bsc_chosen           H223AnnexACapability_h223AnnexAMultiplexTableCapability_basic_chosen
#define h223AAMTCy_enhncd_chosen        H223AnnexACapability_h223AnnexAMultiplexTableCapability_enhanced_chosen
#define h223AAMTCy_enhncd               enhanced

// MultiplexCapability
#define MltplxCpblty_nonStandard_chosen MultiplexCapability_nonStandard_chosen
#define MltplxCpblty_nonStandard        nonStandard

// H261VideoCapability
#define H261VdCpblty_qcifMPI_present    H261VideoCapability_qcifMPI_present
#define H261VdCpblty_cifMPI_present     H261VideoCapability_cifMPI_present
#define H261VdCpblty_qcifMPI            qcifMPI
#define H261VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability

// H262VideoCapability
#define H262VdCpblty_vdBtRt_present     H262VideoCapability_videoBitRate_present
#define H262VdCpblty_vbvBffrSz_present  H262VideoCapability_vbvBufferSize_present
#define H262VdCpblty_smplsPrLn_present  H262VideoCapability_samplesPerLine_present
#define H262VdCpblty_lnsPrFrm_present   H262VideoCapability_linesPerFrame_present
#define H262VdCpblty_frmsPrScnd_present H262VideoCapability_framesPerSecond_present
#define H262VCy_lmnncSmplRt_present     H262VideoCapability_luminanceSampleRate_present
#define H262VdCpblty_vdBtRt             videoBitRate
#define H262VdCpblty_vbvBffrSz          vbvBufferSize
#define H262VdCpblty_smplsPrLn          samplesPerLine
#define H262VdCpblty_lnsPrFrm           linesPerFrame
#define H262VdCpblty_frmsPrScnd         framesPerSecond
#define H262VCy_lmnncSmplRt             luminanceSampleRate

// H263VideoCapability
#define H263VdCpblty_qcifMPI_present    H263VideoCapability_qcifMPI_present
#define H263VdCpblty_cifMPI_present     H263VideoCapability_cifMPI_present
#define H263VCy_errrCmpnstn_present     H263VideoCapability_errorCompensation_present
#define H263VdCpblty_qcifMPI            qcifMPI
#define H263VdCpblty_cifMPI             cifMPI
#define tmprlSptlTrdOffCpblty           temporalSpatialTradeOffCapability
#define H263VCy_errrCmpnstn             errorCompensation

// IS11172VideoCapability
#define IS11172VdCpblty_vdBtRt_present  IS11172VideoCapability_videoBitRate_present
#define IS11172VCy_vbvBffrSz_present    IS11172VideoCapability_vbvBufferSize_present
#define IS11172VCy_smplsPrLn_present    IS11172VideoCapability_samplesPerLine_present
#define IS11172VCy_lnsPrFrm_present     IS11172VideoCapability_linesPerFrame_present
#define IS11172VdCpblty_pctrRt_present  IS11172VideoCapability_pictureRate_present
#define IS11172VCy_lmnncSmplRt_present  IS11172VideoCapability_luminanceSampleRate_present
#define IS11172VdCpblty_vdBtRt          videoBitRate
#define IS11172VCy_vbvBffrSz            vbvBufferSize
#define IS11172VCy_smplsPrLn            samplesPerLine
#define IS11172VCy_lnsPrFrm             linesPerFrame
#define IS11172VdCpblty_pctrRt          pictureRate
#define IS11172VCy_lmnncSmplRt          luminanceSampleRate

// VideoCapability
#define VdCpblty_nonStandard_chosen     VideoCapability_nonStandard_chosen
#define VdCpblty_nonStandard            nonStandard

// AudioCapability
#define AdCpblty_nonStandard_chosen     AudioCapability_nonStandard_chosen
#define AdCpblty_g711Alaw64k_chosen     AudioCapability_g711Alaw64k_chosen
#define AdCpblty_g711Alaw56k_chosen     AudioCapability_g711Alaw56k_chosen
#define AdCpblty_g711Ulaw64k_chosen     AudioCapability_g711Ulaw64k_chosen
#define AdCpblty_g711Ulaw56k_chosen     AudioCapability_g711Ulaw56k_chosen
// #define AudioCapability_g722_64k_chosen g722_64k_chosen
// #define AudioCapability_g722_56k_chosen g722_56k_chosen
// #define AudioCapability_g722_48k_chosen g722_48k_chosen
#define AdCpblty_g729AnnexA_chosen      AudioCapability_g729AnnexA_chosen
#define ACy_g729AASSn_chosen            AudioCapability_g729AnnexAwSilenceSuppression_chosen
#define AdCpblty_nonStandard            nonStandard
#define AdCpblty_g711Alaw64k            g711Alaw64k
#define AdCpblty_g711Alaw56k            g711Alaw56k
#define AdCpblty_g711Ulaw64k            g711Ulaw64k
#define AdCpblty_g711Ulaw56k            g711Ulaw56k
#define AudioCapability_g722_64k        g722_64k
#define AudioCapability_g722_56k        g722_56k
#define AudioCapability_g722_48k        g722_48k
#define AudioCapability_g7231           g7231
#define AudioCapability_g728            g728
#define AudioCapability_g729            g729
#define AdCpblty_g729AnnexA             g729AnnexA
#define ACy_g729AASSn                   g729AnnexAwSilenceSuppression

// Capability
#define rcvAndTrnsmtVdCpblty_chosen     receiveAndTransmitVideoCapability_chosen
#define rcvAndTrnsmtAdCpblty_chosen     receiveAndTransmitAudioCapability_chosen
#define rcvDtApplctnCpblty_chosen       receiveDataApplicationCapability_chosen
#define trnsmtDtApplctnCpblty_chosen    transmitDataApplicationCapability_chosen
#define rATDACy_chosen                  receiveAndTransmitDataApplicationCapability_chosen
#define h233EncryptnTrnsmtCpblty_chosen h233EncryptionTransmitCapability_chosen
#define h233EncryptnRcvCpblty_chosen    h233EncryptionReceiveCapability_chosen
#define Capability_nonStandard          nonStandard
#define rcvAndTrnsmtVdCpblty            receiveAndTransmitVideoCapability
#define rcvAndTrnsmtAdCpblty            receiveAndTransmitAudioCapability
#define rcvDtApplctnCpblty              receiveDataApplicationCapability
#define trnsmtDtApplctnCpblty           transmitDataApplicationCapability
#define rATDACy                         receiveAndTransmitDataApplicationCapability
#define h233EncryptnTrnsmtCpblty        h233EncryptionTransmitCapability
#define h233EncryptnRcvCpblty           h233EncryptionReceiveCapability

// CapabilityDescriptor
#define smltnsCpblts_present            simultaneousCapabilities_present
#define smltnsCpblts                    simultaneousCapabilities

// EncryptionMode
#define EncryptnMd_nonStandard_chosen   EncryptionMode_nonStandard_chosen
#define EncryptnMd_nonStandard          nonStandard

// DataType
#define DataType_nonStandard            nonStandard
#define DataType_videoData              videoData
#define DataType_audioData              audioData
#define DataType_data                   data

// _choice5 vs H223LogicalChannelParameters_adaptationLayerType
#define H223LCPs_aLTp_nnStndrd_chosen   H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen
#define H223LCPs_aLTp_al1Frmd_chosen    H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen
#define H223LCPs_aLTp_al1NtFrmd_chosen  H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen
#define H223LCPs_aLTp_a2WSNs_1_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223LCPs_aLTp_a2WSNs_2_chosen   H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223LCPs_aLTp_al3_chosen        H223LogicalChannelParameters_adaptationLayerType_al3_chosen
#define H223LCPs_aLTp_nnStndrd          nonStandard
#define H223LCPs_aLTp_al3               al3

// UnicastAddress
#define UncstAddrss_iP6Address_chosen   UnicastAddress_iP6Address_chosen
#define UAs_nnStndrdAddrss_chosen       UnicastAddress_nonStandardAddress_chosen
#define UnicastAddress_iPAddress        iPAddress
#define UncstAddrss_iP6Address          iP6Address
#define UnicastAddress_nsap             nsap
#define UAs_nnStndrdAddrss              nonStandardAddress

// MulticastAddress
#define MltcstAddrss_iPAddress_chosen   MulticastAddress_iPAddress_chosen
#define MltcstAddrss_iP6Address_chosen  MulticastAddress_iP6Address_chosen
#define MAs_nnStndrdAddrss_chosen       MulticastAddress_nonStandardAddress_chosen
#define MltcstAddrss_iPAddress          iPAddress
#define MltcstAddrss_iP6Address         iP6Address
#define MulticastAddress_nsap           nsap
#define MAs_nnStndrdAddrss              nonStandardAddress

// H2250LogicalChannelParameters
#define H2250LCPs_nnStndrd_present      H2250LogicalChannelParameters_nonStandard_present
#define H2250LCPs_assctdSssnID_present  H2250LogicalChannelParameters_associatedSessionID_present
#define H2250LCPs_mdChnnl_present       H2250LogicalChannelParameters_mediaChannel_present
#define H2250LCPs_mdGrntdDlvry_present  H2250LogicalChannelParameters_mediaGuaranteedDelivery_present
#define H2250LCPs_mdCntrlChnnl_present  H2250LogicalChannelParameters_mediaControlChannel_present
#define H2250LCPs_mCGDy_present         H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present
#define H2250LCPs_dRTPPTp_present       H2250LogicalChannelParameters_dynamicRTPPayloadType_present
#define H2250LCPs_nnStndrd              nonStandard
#define H2250LCPs_assctdSssnID          associatedSessionID
#define H2250LCPs_mdChnnl               mediaChannel
#define H2250LCPs_mdGrntdDlvry          mediaGuaranteedDelivery
#define H2250LCPs_mdCntrlChnnl          mediaControlChannel
#define H2250LCPs_mCGDy                 mediaControlGuaranteedDelivery
#define H2250LCPs_dRTPPTp               dynamicRTPPayloadType

// _choice20 vs OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
#define fLCPs_mPs_h222LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define fLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define fLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define fLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define fLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define fLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define fLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define fLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define fLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define fLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// _choice21 vs OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h223LCPs_chosen       OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen
#define rLCPs_mPs_v76LCPs_chosen        OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen
#define rLCPs_mPs_h2250LCPs_chosen      OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h223AALCPs_chosen     OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223AnnexALogicalChannelParameters_chosen
#define rLCPs_mPs_h223LCPs              h223LogicalChannelParameters
#define rLCPs_mPs_v76LCPs               v76LogicalChannelParameters
#define rLCPs_mPs_h2250LCPs             h2250LogicalChannelParameters
#define rLCPs_mPs_h223AALCPs            h223AnnexALogicalChannelParameters

// OpenLogicalChannel
#define OLCl_rLCPs_present              OpenLogicalChannel_reverseLogicalChannelParameters_present
#define OpnLgclChnnl_sprtStck_present   OpenLogicalChannel_separateStack_present
#define fLCPs_prtNmbr_present           OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present
#define fLCPs_prtNmbr                   portNumber
#define OLCl_rLCPs_mltplxPrmtrs_present OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present
#define OLCl_rLCPs_mltplxPrmtrs         multiplexParameters
#define OLCl_rLCPs                      reverseLogicalChannelParameters
#define OpnLgclChnnl_sprtStck           separateStack

// _choice23 vs MultiplexElement_type
#define typ_logicalChannelNumber_chosen MultiplexElement_type_logicalChannelNumber_chosen
#define typ_logicalChannelNumber        logicalChannelNumber

// _choice24 vs MultiplexElement_repeatCount
#define repeatCount_finite_chosen       MultiplexElement_repeatCount_finite_chosen
#define repeatCount_finite              finite

// _choice25 vs H261VideoMode_resolution
#define H261VdMd_resolution_qcif_chosen H261VideoMode_resolution_qcif_chosen
#define H261VdMd_resolution_cif_chosen  H261VideoMode_resolution_cif_chosen

// _choice26 vs H262VideoMode_profileAndLevel
#define prflAndLvl_SpatialatH_14_chosen profileAndLevel_SpatialatH_14_chosen

// H262VideoMode
#define H262VdMd_videoBitRate_present   H262VideoMode_videoBitRate_present
#define H262VdMd_vbvBufferSize_present  H262VideoMode_vbvBufferSize_present
#define H262VdMd_samplesPerLine_present H262VideoMode_samplesPerLine_present
#define H262VdMd_linesPerFrame_present  H262VideoMode_linesPerFrame_present
#define H262VdMd_frmsPrScnd_present     H262VideoMode_framesPerSecond_present
#define H262VdMd_lmnncSmplRt_present    H262VideoMode_luminanceSampleRate_present
#define H262VdMd_videoBitRate           videoBitRate
#define H262VdMd_vbvBufferSize          vbvBufferSize
#define H262VdMd_samplesPerLine         samplesPerLine
#define H262VdMd_linesPerFrame          linesPerFrame
#define H262VdMd_frmsPrScnd             framesPerSecond
#define H262VdMd_lmnncSmplRt            luminanceSampleRate

// _choice27 vs H263VideoMode_resolution
#define H263VdMd_resolution_qcif_chosen H263VideoMode_resolution_qcif_chosen
#define H263VdMd_resolution_cif_chosen  H263VideoMode_resolution_cif_chosen

// H263VideoMode
#define H263VdMd_errrCmpnstn_present    H263VideoMode_errorCompensation_present
#define H263VdMd_errrCmpnstn            errorCompensation

// IS11172VideoMode
#define IS11172VdMd_vdBtRt_present      IS11172VideoMode_videoBitRate_present
#define IS11172VdMd_vbvBffrSz_present   IS11172VideoMode_vbvBufferSize_present
#define IS11172VdMd_smplsPrLn_present   IS11172VideoMode_samplesPerLine_present
#define IS11172VdMd_lnsPrFrm_present    IS11172VideoMode_linesPerFrame_present
#define IS11172VdMd_pictureRate_present IS11172VideoMode_pictureRate_present
#define IS11172VdMd_lmnncSmplRt_present IS11172VideoMode_luminanceSampleRate_present
#define IS11172VdMd_vdBtRt              videoBitRate
#define IS11172VdMd_vbvBffrSz           vbvBufferSize
#define IS11172VdMd_smplsPrLn           samplesPerLine
#define IS11172VdMd_lnsPrFrm            linesPerFrame
#define IS11172VdMd_pictureRate         pictureRate
#define IS11172VdMd_lmnncSmplRt         luminanceSampleRate

// VideoMode
#define VideoMode_nonStandard           nonStandard

// _choice28 vs IS11172AudioMode_audioLayer
#define audioLayer1_chosen      IS11172AudioMode_audioLayer_audioLayer1_chosen
#define audioLayer2_chosen      IS11172AudioMode_audioLayer_audioLayer2_chosen
#define audioLayer3_chosen      IS11172AudioMode_audioLayer_audioLayer3_chosen

// _choice29 vs IS11172AudioMode_audioSampling
#define IS11172AMd_aSg_aS32k_chosen     IS11172AudioMode_audioSampling_audioSampling32k_chosen
#define IS11172AMd_aSg_aS441_chosen     IS11172AudioMode_audioSampling_audioSampling44k1_chosen
#define IS11172AMd_aSg_aS48k_chosen     IS11172AudioMode_audioSampling_audioSampling48k_chosen

// _choice30 vs IS11172AudioMode_multichannelType
#define IS11172AMd_mTp_snglChnnl_chosen IS11172AudioMode_multichannelType_singleChannel_chosen
#define IS11172AMd_mTp_tCSr_chosen      IS11172AudioMode_multichannelType_twoChannelStereo_chosen
#define IS11172AMd_mTp_twChnnlDl_chosen IS11172AudioMode_multichannelType_twoChannelDual_chosen

// _choice32 vs IS13818AudioMode_audioSampling
#define IS13818AMd_aSg_aS32k_chosen     IS13818AudioMode_audioSampling_audioSampling32k_chosen
#define IS13818AMd_aSg_aS441_chosen     IS13818AudioMode_audioSampling_audioSampling44k1_chosen
#define IS13818AMd_aSg_aS48k_chosen     IS13818AudioMode_audioSampling_audioSampling48k_chosen

// _choice33 vs IS13818AudioMode_multichannelType
#define IS13818AMd_mTp_snglChnnl_chosen IS13818AudioMode_multichannelType_singleChannel_chosen
#define IS13818AMd_mTp_tCSr_chosen      IS13818AudioMode_multichannelType_twoChannelStereo_chosen
#define IS13818AMd_mTp_twChnnlDl_chosen IS13818AudioMode_multichannelType_twoChannelDual_chosen

// _choice34 vs AudioMode_g7231
#define nSlncSpprssnLwRt_chosen         noSilenceSuppressionLowRate_chosen
#define nSlncSpprssnHghRt_chosen        noSilenceSuppressionHighRate_chosen
#define slncSpprssnLwRt_chosen          silenceSuppressionLowRate_chosen
#define slncSpprssnHghRt_chosen         silenceSuppressionHighRate_chosen

// AudioMode
#define AMd_g729AASSn_chosen            AudioMode_g729AnnexAwSilenceSuppression_chosen
#define AudioMode_nonStandard           nonStandard
#define AudioMode_g7231                 g7231

// _choice35 vs DataMode_application
#define DtMd_applctn_nonStandard_chosen DataMode_application_nonStandard_chosen
#define DtMd_application_t120_chosen    DataMode_application_t120_chosen
#define DtMd_application_dsm_cc_chosen  dsm_cc_chosen
#define DtMd_applctn_userData_chosen    DataMode_application_userData_chosen
#define DtMd_application_t434_chosen    DataMode_application_t434_chosen
#define DtMd_application_h224_chosen    DataMode_application_h224_chosen
#define DtMd_application_nlpid_chosen   DataMode_application_nlpid_chosen
#define DtMd_applctn_dsvdControl_chosen DataMode_application_dsvdControl_chosen
#define DMd_an_h222DtPrttnng_chosen     DataMode_application_h222DataPartitioning_chosen
#define DtMd_applctn_nonStandard        nonStandard
#define DtMd_application_t120           t120
#define DtMd_application_dsm_cc         dsm_cc
#define DtMd_applctn_userData           userData
#define DataMode_application_t84        t84
#define DtMd_application_t434           t434
#define DtMd_application_h224           h224
#define DtMd_application_nlpid          nlpid
#define DMd_an_h222DtPrttnng            h222DataPartitioning

// _choice36 vs H223ModeParameters_adaptationLayerType
#define H223MPs_aLTp_nnStndrd_chosen    H223ModeParameters_adaptationLayerType_nonStandard_chosen
#define H223MPs_aLTp_al1Frmd_chosen     H223ModeParameters_adaptationLayerType_al1Framed_chosen
#define H223MPs_aLTp_al1NtFrmd_chosen   H223ModeParameters_adaptationLayerType_al1NotFramed_chosen
#define H223MPs_aLTp_a2WSNs_1_chosen    H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen
#define H223MPs_aLTp_a2WSNs_2_chosen    H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen
#define H223MPs_adpttnLyrTyp_al3_chosen H223ModeParameters_adaptationLayerType_al3_chosen
#define H223MPs_aLTp_nnStndrd           nonStandard
#define H223MPs_adpttnLyrTyp_al3        al3

// ModeElement
#define h223AnnxAMdPrmtrs_present       h223AnnexAModeParameters_present
#define h223AnnxAMdPrmtrs               h223AnnexAModeParameters

// _choice38 vs MaintenanceLoopRequest_type
#define systemLoop_chosen               MaintenanceLoopRequest_type_systemLoop_chosen // MaintenanceLoopReject_type_systemLoop_chosen
#define mediaLoop_chosen                MaintenanceLoopRequest_type_mediaLoop_chosen // MaintenanceLoopReject_type_mediaLoop_chosen
#define logicalChannelLoop_chosen       MaintenanceLoopRequest_type_logicalChannelLoop_chosen // MaintenanceLoopReject_type_logicalChannelLoop_chosen

// RequestMessage
#define RqstMssg_nonStandard_chosen     RequestMessage_nonStandard_chosen
#define h223AnnxARcnfgrtn_chosen        h223AnnexAReconfiguration_chosen
#define RqstMssg_nonStandard            nonStandard
#define h223AnnxARcnfgrtn               h223AnnexAReconfiguration

// _choice45 vs TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
#define hghstEntryNmbrPrcssd_chosen     highestEntryNumberProcessed_chosen
#define hghstEntryNmbrPrcssd            highestEntryNumberProcessed

// _choice46 vs TerminalCapabilitySetReject_cause
#define TCSRt_cs_unspcfd_chosen         TerminalCapabilitySetReject_cause_unspecified_chosen
#define dscrptrCpctyExcdd_chosen        descriptorCapacityExceeded_chosen
#define tblEntryCpctyExcdd_chosen       tableEntryCapacityExceeded_chosen
#define tblEntryCpctyExcdd              tableEntryCapacityExceeded

// H2250LgclChnnlAckPrmtrs vs H2250LogicalChannelAckParameters
#define H2250LgclChnnlAckPrmtrs         H2250LogicalChannelAckParameters
#define H2250LCAPs_nnStndrd_present     H2250LogicalChannelAckParameters_nonStandard_present
#define H2250LCAPs_mdChnnl_present      H2250LogicalChannelAckParameters_mediaChannel_present
#define H2250LCAPs_mdCntrlChnnl_present H2250LogicalChannelAckParameters_mediaControlChannel_present
#define H2250LCAPs_dRTPPTp_present      H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present
#define H2250LCAPs_nnStndrd             nonStandard
#define H2250LCAPs_mdChnnl              mediaChannel
#define H2250LCAPs_mdCntrlChnnl         mediaControlChannel
#define H2250LCAPs_dRTPPTp              dynamicRTPPayloadType

// _choice47 vs OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
#define rLCPs_mPs_h222LCPs_chosen       OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen
#define mPs_h2250LgclChnnlPrmtrs_chosen OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen
#define rLCPs_mPs_h222LCPs              h222LogicalChannelParameters
#define mPs_h2250LgclChnnlPrmtrs        h2250LogicalChannelParameters

// _choice48 vs OpenLogicalChannelAck_forwardMultiplexAckParameters
#define h2250LgclChnnlAckPrmtrs_chosen  h2250LogicalChannelAckParameters_chosen
#define h2250LgclChnnlAckPrmtrs         h2250LogicalChannelAckParameters

// OpenLogicalChannelAck
#define OLCAk_rLCPs_present             OpenLogicalChannelAck_reverseLogicalChannelParameters_present
#define OLCAk_sprtStck_present          OpenLogicalChannelAck_separateStack_present
#define frwrdMltplxAckPrmtrs_present    forwardMultiplexAckParameters_present
#define rLCPs_prtNmbr_present           OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present
#define OLCAk_rLCPs_mPs_present         OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present
#define rLCPs_prtNmbr                   portNumber
#define OLCAk_rLCPs_mPs                 multiplexParameters
#define OLCAk_rLCPs                     reverseLogicalChannelParameters
#define OLCAk_sprtStck                  separateStack
#define frwrdMltplxAckPrmtrs            forwardMultiplexAckParameters

// _choice49 vs OpenLogicalChannelReject_cause
#define OLCRt_cs_unspcfd_chosen         OpenLogicalChannelReject_cause_unspecified_chosen
#define unstblRvrsPrmtrs_chosen         unsuitableReverseParameters_chosen
#define dtTypALCmbntnNtSpprtd_chosen    dataTypeALCombinationNotSupported_chosen
#define mltcstChnnlNtAllwd_chosen       multicastChannelNotAllowed_chosen
#define sprtStckEstblshmntFld_chosen    separateStackEstablishmentFailed_chosen

// _choice51 vs MultiplexEntryRejectionDescriptions_cause
#define MERDs_cs_unspcfdCs_chosen       MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// MltplxEntryRjctnDscrptns vs MultiplexEntryRejectionDescriptions
#define MltplxEntryRjctnDscrptns        MultiplexEntryRejectionDescriptions

// _choice52 vs RequestMultiplexEntryRejectionDescriptions_cause
#define RMERDs_cs_unspcfdCs_chosen      RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen

// RqstMltplxEntryRjctnDscrptns vs RequestMultiplexEntryRejectionDescriptions
#define RqstMltplxEntryRjctnDscrptns    RequestMultiplexEntryRejectionDescriptions

// _choice53 vs RequestModeAck_response
#define wllTrnsmtMstPrfrrdMd_chosen     willTransmitMostPreferredMode_chosen
#define wllTrnsmtLssPrfrrdMd_chosen     willTransmitLessPreferredMode_chosen

// _choice57 vs CommunicationModeTableEntry_dataType
#define dataType_videoData_chosen       CommunicationModeTableEntry_dataType_videoData_chosen
#define dataType_audioData_chosen       CommunicationModeTableEntry_dataType_audioData_chosen
#define dataType_data_chosen            CommunicationModeTableEntry_dataType_data_chosen
#define dataType_videoData              videoData
#define dataType_audioData              audioData
#define dataType_data                   data

// CommunicationModeTableEntry
#define CMTEy_nnStndrd_present          CommunicationModeTableEntry_nonStandard_present
#define CMTEy_assctdSssnID_present      CommunicationModeTableEntry_associatedSessionID_present
#define CMTEy_mdChnnl_present           CommunicationModeTableEntry_mediaChannel_present
#define CMTEy_mdGrntdDlvry_present      CommunicationModeTableEntry_mediaGuaranteedDelivery_present
#define CMTEy_mdCntrlChnnl_present      CommunicationModeTableEntry_mediaControlChannel_present
#define CMTEy_mdCntrlGrntdDlvry_present CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present
#define CMTEy_nnStndrd                  nonStandard
#define CMTEy_assctdSssnID              associatedSessionID
#define CMTEy_mdChnnl                   mediaChannel
#define CMTEy_mdGrntdDlvry              mediaGuaranteedDelivery
#define CMTEy_mdCntrlChnnl              mediaControlChannel
#define CMTEy_mdCntrlGrntdDlvry         mediaControlGuaranteedDelivery

// ResponseMessage
#define RspnsMssg_nonStandard_chosen    ResponseMessage_nonStandard_chosen
#define mstrSlvDtrmntnAck_chosen        masterSlaveDeterminationAck_chosen
#define mstrSlvDtrmntnRjct_chosen       masterSlaveDeterminationReject_chosen
#define trmnlCpbltyStRjct_chosen        terminalCapabilitySetReject_chosen
#define rqstChnnlClsRjct_chosen         requestChannelCloseReject_chosen
#define rqstMltplxEntryRjct_chosen      requestMultiplexEntryReject_chosen
#define cmmnctnMdRspns_chosen           communicationModeResponse_chosen
#define h223AnnxARcnfgrtnAck_chosen     h223AnnexAReconfigurationAck_chosen
#define h223AnnxARcnfgrtnRjct_chosen    h223AnnexAReconfigurationReject_chosen
#define RspnsMssg_nonStandard           nonStandard
#define mstrSlvDtrmntnAck               masterSlaveDeterminationAck
#define mstrSlvDtrmntnRjct              masterSlaveDeterminationReject
#define trmnlCpbltyStRjct               terminalCapabilitySetReject
#define rqstChnnlClsRjct                requestChannelCloseReject
#define rqstMltplxEntryRjct             requestMultiplexEntryReject
#define cmmnctnMdRspns                  communicationModeResponse
#define h223AnnxARcnfgrtnAck            h223AnnexAReconfigurationAck
#define h223AnnxARcnfgrtnRjct           h223AnnexAReconfigurationReject

// SendTerminalCapabilitySet
#define cpbltyTblEntryNmbrs_present     capabilityTableEntryNumbers_present
#define cpbltyDscrptrNmbrs_present      capabilityDescriptorNumbers_present
#define cpbltyTblEntryNmbrs             capabilityTableEntryNumbers
#define cpbltyDscrptrNmbrs              capabilityDescriptorNumbers

// _choice59 vs FlowControlCommand_scope
#define FCCd_scp_lgclChnnlNmbr_chosen   FlowControlCommand_scope_logicalChannelNumber_chosen
#define FlwCntrlCmmnd_scp_rsrcID_chosen FlowControlCommand_scope_resourceID_chosen
#define FCCd_scp_whlMltplx_chosen       FlowControlCommand_scope_wholeMultiplex_chosen
#define FCCd_scp_lgclChnnlNmbr          logicalChannelNumber
#define FlwCntrlCmmnd_scp_rsrcID        resourceID

// EndSessionCommand
#define EndSssnCmmnd_nonStandard_chosen EndSessionCommand_nonStandard_chosen
#define EndSssnCmmnd_nonStandard        nonStandard

// _choice62 vs MiscellaneousCommand_type
#define cnclMltpntMdCmmnd_chosen        cancelMultipointModeCommand_chosen
#define MCd_tp_vdTmprlSptlTrdOff_chosen MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen
#define vdSndSyncEvryGOBCncl_chosen     videoSendSyncEveryGOBCancel_chosen
#define MCd_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// ConferenceCommand
#define brdcstMyLgclChnnl_chosen        broadcastMyLogicalChannel_chosen
#define cnclBrdcstMyLgclChnnl_chosen    cancelBroadcastMyLogicalChannel_chosen
#define cnclMkTrmnlBrdcstr_chosen       cancelMakeTerminalBroadcaster_chosen
#define brdcstMyLgclChnnl               broadcastMyLogicalChannel
#define cnclBrdcstMyLgclChnnl           cancelBroadcastMyLogicalChannel
             
// CommandMessage
#define CmmndMssg_nonStandard_chosen    CommandMessage_nonStandard_chosen
#define mntnncLpOffCmmnd_chosen         maintenanceLoopOffCommand_chosen
#define sndTrmnlCpbltySt_chosen         sendTerminalCapabilitySet_chosen
#define CmmndMssg_nonStandard           nonStandard
#define mntnncLpOffCmmnd                maintenanceLoopOffCommand
#define sndTrmnlCpbltySt                sendTerminalCapabilitySet

// FunctionNotUnderstood
#define FnctnNtUndrstd_request_chosen   FunctionNotUnderstood_request_chosen
#define FnctnNtUndrstd_response_chosen  FunctionNotUnderstood_response_chosen
#define FnctnNtUndrstd_command_chosen   FunctionNotUnderstood_command_chosen
#define FnctnNtUndrstd_request          request
#define FnctnNtUndrstd_response         response
#define FnctnNtUndrstd_command          command

// _choice63 vs MiscellaneousIndication_type
#define cnclMltpntCnfrnc_chosen         cancelMultipointConference_chosen
#define mltpntScndryStts_chosen         multipointSecondaryStatus_chosen
#define cnclMltpntScndryStts_chosen     cancelMultipointSecondaryStatus_chosen
#define vdIndctRdyTActvt_chosen         videoIndicateReadyToActivate_chosen
#define MIn_tp_vdTmprlSptlTrdOff_chosen MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen
#define MIn_tp_vdTmprlSptlTrdOff        videoTemporalSpatialTradeOff

// _choice64 vs JitterIndication_scope
#define JIn_scp_lgclChnnlNmbr_chosen    JitterIndication_scope_logicalChannelNumber_chosen
#define JttrIndctn_scp_rsrcID_chosen    JitterIndication_scope_resourceID_chosen
#define JttrIndctn_scp_whlMltplx_chosen JitterIndication_scope_wholeMultiplex_chosen
#define JIn_scp_lgclChnnlNmbr           logicalChannelNumber
#define JttrIndctn_scp_rsrcID           resourceID

// UserInputIndication
#define UsrInptIndctn_nnStndrd_chosen   UserInputIndication_nonStandard_chosen
#define UsrInptIndctn_nnStndrd          nonStandard

// ConferenceIndication
#define cnclSnByAtLstOnOthr_chosen      cancelSeenByAtLeastOneOther_chosen

// IndicationMessage
#define IndctnMssg_nonStandard_chosen   IndicationMessage_nonStandard_chosen
#define mstrSlvDtrmntnRls_chosen        masterSlaveDeterminationRelease_chosen
#define trmnlCpbltyStRls_chosen         terminalCapabilitySetRelease_chosen
#define opnLgclChnnlCnfrm_chosen        openLogicalChannelConfirm_chosen
#define rqstChnnlClsRls_chosen          requestChannelCloseRelease_chosen
#define mltplxEntrySndRls_chosen        multiplexEntrySendRelease_chosen
#define rqstMltplxEntryRls_chosen       requestMultiplexEntryRelease_chosen
#define h2250MxmmSkwIndctn_chosen       h2250MaximumSkewIndication_chosen
#define IndctnMssg_nonStandard          nonStandard
#define mstrSlvDtrmntnRls               masterSlaveDeterminationRelease
#define trmnlCpbltyStRls                terminalCapabilitySetRelease
#define opnLgclChnnlCnfrm               openLogicalChannelConfirm
#define rqstChnnlClsRls                 requestChannelCloseRelease
#define mltplxEntrySndRls               multiplexEntrySendRelease
#define rqstMltplxEntryRls              requestMultiplexEntryRelease
#define h2250MxmmSkwIndctn              h2250MaximumSkewIndication

// MltmdSystmCntrlMssg vs MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg             MultimediaSystemControlMessage
#define MltmdSystmCntrlMssg_PDU         MultimediaSystemControlMessage_PDU
#define MltmdSystmCntrlMssg_rqst_chosen MultimediaSystemControlMessage_request_chosen
#define MSCMg_rspns_chosen              MultimediaSystemControlMessage_response_chosen
#define MSCMg_cmmnd_chosen              MultimediaSystemControlMessage_command_chosen
#define MltmdSystmCntrlMssg_rqst        request
#define MSCMg_rspns                     response
#define MSCMg_cmmnd                     command


#ifdef __cplusplus
}
#endif

#endif // H245ASN1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\incommon.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/incommon.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1996 Intel Corporation.
 *
 *      $Revision:   1.41  $
 *      $Date:   12 Feb 1997 09:34:42  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:    INCOMMON.H
 *
 *      Abstract:        commonly used structures
 *              
 *
 *      Notes:
 *
 ***************************************************************************/
#ifndef INCOMMON_H
#define INCOMMON_H

#pragma pack(push,8)

#define CC_INVALID_HANDLE                    0

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define CC_REJECT_NO_BANDWIDTH              1
#define CC_REJECT_GATEKEEPER_RESOURCES      2
#define CC_REJECT_UNREACHABLE_DESTINATION   3
#define CC_REJECT_DESTINATION_REJECTION     4
#define CC_REJECT_INVALID_REVISION          5
#define CC_REJECT_NO_PERMISSION             6
#define CC_REJECT_UNREACHABLE_GATEKEEPER    7
#define CC_REJECT_GATEWAY_RESOURCES         8
#define CC_REJECT_BAD_FORMAT_ADDRESS        9
#define CC_REJECT_ADAPTIVE_BUSY             10
#define CC_REJECT_IN_CONF                   11
#define CC_REJECT_ROUTE_TO_GATEKEEPER       12
#define CC_REJECT_CALL_FORWARDED            13
#define CC_REJECT_ROUTE_TO_MC               14
#define CC_REJECT_UNDEFINED_REASON          15
#define CC_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define CC_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define CC_REJECT_USER_BUSY                 18    // User is busy with another call
#define CC_REJECT_NO_ANSWER                 19    // Callee does not answer
#define CC_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define CC_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define CC_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define CC_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define CC_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define CC_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call

// Q931 call types
#define CC_CALLTYPE_UNKNOWN                 0
#define CC_CALLTYPE_PT_PT                   1
#define CC_CALLTYPE_1_N                     2
#define CC_CALLTYPE_N_1                     3
#define CC_CALLTYPE_N_N                     4

// alias contants
#define CC_ALIAS_MAX_H323_ID                256
#define CC_ALIAS_MAX_H323_PHONE             128

// unicode character mask contants
#define CC_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define CC_ODOTTO_CHARS                     L".0123456789"


// alias type codes
#define CC_ALIAS_H323_ID                    1    // Return call information.
#define CC_ALIAS_H323_PHONE                 2    // H323 Phone Number.

// default port id's
#define CC_H323_GATE_DISC    1718 // Gatekeeper IP Discovery Port
#define CC_H323_GATE_STAT    1719 // Gatekeeper UDP Reg. and Status Port
#define CC_H323_HOST_CALL    1720 // Endpoint TCP Call Signalling Por

// Call creation goals
#define CC_GOAL_UNKNOWN                     0
#define CC_GOAL_CREATE                      1
#define CC_GOAL_JOIN                        2
#define CC_GOAL_INVITE                      3
    
// H245 non-standard message types
#define CC_H245_MESSAGE_REQUEST             0
#define CC_H245_MESSAGE_RESPONSE            1
#define CC_H245_MESSAGE_COMMAND             2
#define CC_H245_MESSAGE_INDICATION          3

// Call Control handle typedefs
typedef DWORD        CC_HLISTEN, *PCC_HLISTEN;
typedef DWORD        CC_HCONFERENCE, *PCC_HCONFERENCE;
typedef DWORD        CC_HCALL, *PCC_HCALL;
typedef DWORD        CC_HCHANNEL, *PCC_HCHANNEL;

// IP address in domain name format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[255];     // UNICODE zstring
} CC_IP_DomainName_t;

// IP address in conventional dot notation
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} CC_IP_Dot_t;

// IP address in binary format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} CC_IP_Binary_t;

typedef enum
{
    CC_IP_DOMAIN_NAME,
    CC_IP_DOT,
    CC_IP_BINARY
} CC_ADDRTYPE;

typedef struct _ADDR
{
    CC_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union 
    {
        CC_IP_DomainName_t   IP_DomainName;
        CC_IP_Dot_t          IP_Dot;
        CC_IP_Binary_t       IP_Binary;
    } Addr;
} CC_ADDR, *PCC_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;
} CC_OCTETSTRING, *PCC_OCTETSTRING;

typedef struct
{
    CC_OCTETSTRING          sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} CC_NONSTANDARDDATA, *PCC_NONSTANDARDDATA;

#define CC_MAX_PRODUCT_LENGTH 256
#define CC_MAX_VERSION_LENGTH 256
#define CC_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PCC_OCTETSTRING         pProductNumber;
    PCC_OCTETSTRING         pVersionNumber;
} CC_VENDORINFO, *PCC_VENDORINFO;

typedef struct
{
    PCC_VENDORINFO          pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} CC_ENDPOINTTYPE, *PCC_ENDPOINTTYPE;

typedef struct
{
    WORD                    wType;
    WORD                    wPrefixLength;
    LPWSTR                  pPrefix;
    WORD                    wDataLength;   // UNICODE character count
    LPWSTR                  pData;         // UNICODE data.
} CC_ALIASITEM, *PCC_ALIASITEM;

typedef struct
{
    WORD                    wCount;
    PCC_ALIASITEM           pItems;
} CC_ALIASNAMES, *PCC_ALIASNAMES;

typedef struct _CONFERENCE_ID
{
    BYTE                    buffer[16];  // This is OCTET data, not ASCII.
} CC_CONFERENCEID, *PCC_CONFERENCEID;

#pragma pack(pop)

#endif    INCOMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\multitrackterminal.h ===
// MultiTrackTerminal.h: interface for the CMultiTrackTerminal class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(_MULTITRACKTERMINAL_DOT_H_INCLUDED_)
#define _MULTITRACKTERMINAL_DOT_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template <class T>
class  ITMultiTrackTerminalVtbl : public ITMultiTrackTerminal
{
};

class CMultiTrackTerminal;

typedef IDispatchImpl<ITMultiTrackTerminalVtbl<CMultiTrackTerminal>, &IID_ITMultiTrackTerminal, &LIBID_TAPI3Lib> CTMultiTrack;

class CMultiTrackTerminal :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CTMultiTrack
{

public:

BEGIN_COM_MAP(CMultiTrackTerminal)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITMultiTrackTerminal)
END_COM_MAP()


    //
    // the logic for creating a track terminal needs to be implemented by the
    // specific terminals, so this is a pure virtual method
    //

	virtual HRESULT STDMETHODCALLTYPE CreateTrackTerminal(
			    IN long MediaType,
			    IN TERMINAL_DIRECTION TerminalDirection,
			    OUT ITTerminal **ppTerminal
			    ) = 0;


public:

    virtual HRESULT STDMETHODCALLTYPE get_TrackTerminals(
			    OUT VARIANT *pVariant
			    );

	virtual HRESULT STDMETHODCALLTYPE EnumerateTrackTerminals(
			    IEnumTerminal **ppEnumTerminal
			    );

	virtual HRESULT STDMETHODCALLTYPE get_MediaTypesInUse(
			    OUT long *plMediaTypesInUse
			    );

	virtual HRESULT STDMETHODCALLTYPE get_DirectionsInUse(
			    OUT TERMINAL_DIRECTION *plDirectionsInUsed
			    );

    virtual HRESULT STDMETHODCALLTYPE RemoveTrackTerminal(
                IN ITTerminal *pTrackTerminalToRemove
                );


public:

    CMultiTrackTerminal();

	virtual ~CMultiTrackTerminal();


protected:

    HRESULT AddTrackTerminal(ITTerminal *pTrackTerminalToAdd);

    HRESULT ReleaseAllTracks();

    
    //
    // a helper method that returns true if the terminal is in the list of managed tracks
    //

    BOOL DoIManageThisTrack(ITTerminal *pTrackInQuestion)
    {
        CLock lock(m_lock);

        int nIndex = m_TrackTerminals.Find(pTrackInQuestion);

        return (nIndex >= 0);
    }


    //
    // returns the number of tracks managed by this terminal
    //

    int CountTracks();


public:

    //
    // the derived class, CComObject, implements these. Here declare as pure 
    // virtual so we can refer to these methods from ChildRelease and 
    // ChildAddRef()
    // 
    
    virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
    virtual ULONG STDMETHODCALLTYPE Release() = 0;


    //
    // called by a track terminals when they are addref'ed or released
    //
    
    virtual void ChildAddRef();
    virtual void ChildRelease();


protected:

    //
    // we have to adjust refcount with the information on the number of tracks that we are managing
    //

    ULONG InternalAddRef();
    ULONG InternalRelease();


protected:

    //
    // collection of track terminals
    //

    CMSPArray<ITTerminal*>  m_TrackTerminals;


protected:
    

    //
    // critical section. 
    //

    CMSPCritSection         m_lock;


private:
    

    //
    // this data member is used to keep the count of the tracks managed by this
    // terminal
    //

    int m_nNumberOfTracks;

};

#endif // !defined(_MULTITRACKTERMINAL_DOT_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\objectsafeimpl.h ===
#ifndef _OBJECT_SAFE_IMPL_H_
#define _OBJECT_SAFE_IMPL_H_

#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectSafeImpl.h

Abstract:

  base class for object safety. basic implementation for IObjectSafety

  derive your control from this class if the control is safe for scripting 
  on all the interfaces it exposes

  if you want to delegate IObjectSafety requests to the IObjectSafety
  interface of the aggrefate that supports the interface requested, 
  have your derived class implement QIOnAggregate() 

--*/


class CObjectSafeImpl : public IObjectSafety
{

public:
    
    CObjectSafeImpl()
        :m_dwSafety(0)
    {}


    //
    // we support INTERFACESAFE_FOR_UNTRUSTED_CALLER and INTERFACESAFE_FOR_UNTRUSTED_DATA
    //

    enum { SUPPORTED_SAFETY_OPTIONS = 
        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA };


    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
    {

       
        IUnknown *pNonDelegatingUnknown = NULL;

        //
        // any options requested that we do not support?
        //
        
        if ( (~SUPPORTED_SAFETY_OPTIONS & dwOptionSetMask) != 0 )
        {
            return E_FAIL;
        }

        
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
                
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to set the new 
                // safety options
                //

                hr = pAggrObjectSafety->SetInterfaceSafetyOptions(riid,
                                                                  dwOptionSetMask,
                                                                  dwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. Set safety options.
                // 

                s_CritSection.Lock();

                //
                // set the bits specified by the mask to the values specified by the values
                //

                m_dwSafety = (dwEnabledOptions & dwOptionSetMask) |
                             (m_dwSafety & ~dwOptionSetMask);

                s_CritSection.Unlock();

            }

        }

        return hr;
    }





    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        
        //
        // check caller's pointers
        //

        if ( IsBadWritePtr(pdwSupportedOptions, sizeof(DWORD)) ||
             IsBadWritePtr(pdwEnabledOptions, sizeof(DWORD)) )
        {
             return E_POINTER;
        }

        //
        //  if we fail, at least return something meaningful.
        //

        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;


        IUnknown *pNonDelegatingUnknown = NULL;
       
        //
        //  Is the interface exposed by one of the aggregated objects?
        //
        
        HRESULT hr = QIOnAggregates(riid, &pNonDelegatingUnknown);

        if (SUCCEEDED(hr))
        {

            //
            // get IObjectSafety on non delegating unknown of the aggregated object
            //

            IObjectSafety *pAggrObjectSafety = NULL;

            hr = pNonDelegatingUnknown->QueryInterface(IID_IObjectSafety, (void**)&pAggrObjectSafety);

            pNonDelegatingUnknown->Release();
            pNonDelegatingUnknown = NULL;
            
            if (SUCCEEDED(hr))
            {

                // 
                // the aggregate exposes IObjectSafety. use it to get the new 
                // safety options
                //

                hr = pAggrObjectSafety->GetInterfaceSafetyOptions(riid,
                                                                  pdwSupportedOptions,
                                                                  pdwEnabledOptions);

                pAggrObjectSafety->Release();
                pAggrObjectSafety = NULL;

            }

        }
        else 
        {
            //
            // the interface requested is not requested by the object's 
            // aggregates. see if the interface is supported at all
            //

            hr = InterfaceSupported(riid);

            if (SUCCEEDED(hr))
            {

                //
                // the object supports the interface. get options
                // 

                *pdwSupportedOptions = SUPPORTED_SAFETY_OPTIONS;

                s_CritSection.Lock();

                *pdwEnabledOptions = m_dwSafety;

                s_CritSection.Unlock();

            }

        }

        return hr;
    }


private:

    DWORD m_dwSafety;

    // 
    // thread safety
    //
    // this interface is not likely to be a performance bottleneck, 
    // at the same time, having one critical section per object
    // is wasteful. so have a static critical section
    //

    static CComAutoCriticalSection s_CritSection;


protected:

    //
    // return S_OK if the interface requested is exposed 
    // by the object
    //
    
    HRESULT InterfaceSupported(REFIID riid)
    {

        void *pVoid = NULL;

    
        HRESULT hr = E_FAIL;
     
        // 
        // does the object support requested interface
        //

        hr = QueryInterface(riid, &pVoid);


        if (SUCCEEDED(hr))
        {

            //
            // don't need the interface itself, just wanted to see if
            // it is supported
            //

            ((IUnknown*)pVoid)->Release();

        }
        

        return hr;
    }


    //
    // Implement in the derived class if you have any aggregates
    //
    // returns the non delegating IUnknown of the first (in the order of COMMAP)
    // aggregate that supports the iid requested
    //
    
    virtual HRESULT QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown)
    {
        return E_NOINTERFACE;
    }

};

#endif // _OBJECT_SAFE_IMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\promptedobjectsafety.h ===
#ifndef _TAPI_PROMPTED_OBJECT_SAFETY_H_
#define _TAPI_PROMPTED_OBJECT_SAFETY_H_

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    PromptedObjectSafety.h

Abstract:

  abstract base class for secure object safety mechanism

  calls the derived class's Ask() method to determine 
  whether safe for scripting request should be rejected

--*/


#include "ObjectSafeImpl.h"


class CPromptedObjectSafety : public CObjectSafeImpl
{

public:
   
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions)
    {
        if ( SUCCEEDED(InterfaceSupported(riid)) && Ask() )
        {
            return CObjectSafeImpl::SetInterfaceSafetyOptions(riid, 
                                                        dwOptionSetMask,
                                                        dwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }


    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
                                         DWORD *pdwSupportedOptions,
                                         DWORD *pdwEnabledOptions)
    {
        if (SUCCEEDED(InterfaceSupported(riid)) && Ask())
        {
            return CObjectSafeImpl::GetInterfaceSafetyOptions(riid, 
                                                          pdwSupportedOptions,
                                                          pdwEnabledOptions);
        }
        else
        {
            return E_FAIL;
        }
    }

    //
    // implement Ask() in the derived class. Should contain the logic to make 
    // the decision on whether the control should be allowed to run
    //
    // return FALSE if you want to mark your control as not safe for scripting
    // return TRUE otherwise
    //

    virtual BOOL Ask() = 0;

};

#endif // _TAPI_PROMPTED_OBJECT_SAFETY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\rtppktd.h ===
/****************************************************************************
 *  @doc INTERNAL RTPPKTD
 *
 *  @module RtpPktD.h | Header file for the RTP packetization descriptor
 *    structures.
 ***************************************************************************/

#ifndef _RTPPKTD_H_
#define _RTPPKTD_H_

/*****************************************************************************
 *  @doc INTERNAL CRTPPKTDSTRUCTENUM
 *
 *  @struct RTP_PD | The <t RTP_PD> structure is used to specify the details
 *    of the RTP Pd format.
 *
 *  @field DWORD | dwThisHeaderLength | Specifies the length, in bytes, of
 *    this structure. This field is the offset to the next <t RTP_PD>
 *    structure, if there is one, or the start of the payload headers.
 *
 *  @field DWORD | dwPayloadHeaderOffset | Specifies the offset from the start
 *    of the RTP packetization descriptor data to the first byte of the payload
 *    header.
 *
 *  @field DWORD | dwPayloadHeaderLength | Specifies the length, in bytes, of
 *    the payload header.
 *
 *  @field DWORD | dwPayloadStartBitOffset | Specifies the offset from the
 *    start of the corresponding compressed video buffer to the first bit of
 *    the payload data associated with this <t RTP_PD> structure.
 *
 *  @field DWORD | dwPayloadEndBitOffset | Specifies the offset from the start
 *    of the corresponding compressed video buffer to the last bit of the
 *    payload data associated with this <t RTP_PD> structure.
 *
 *  @field DWORD | fEndMarkerBit | If set to TRUE, this flag signals that
 *    this structure applies to the last chunk of a video frame. Typically,
 *    only the last packet descriptor in a series of descriptors would have
 *    this flag turned on. However, this may not be the case for devices
 *    that do not respect frame boundaries and fill video capture buffers
 *    with truncated or multiple video frames.
 *
 *  @field DWORD | dwLayerId | Specifies the ID of the encoding layer this
 *    descriptor applies to. For standard video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc.
 *
 *  @field DWORD | dwTimestamp | Specifies the value of the timestamp field
 *    to be set by the downstream filter when creating the RTP header for
 *    this packet. The units and ranges for this field shall adhere to the
 *    definition of timestamp given in section 5.1 of RFC 1889.
 *
 *  @field DWORD | dwAudioAttributes | Specifies some bitfield attributes
 *    used to characterize the sample in the audio stream associated to this
 *    RTP packetization descriptor. This field shall always be set to 0,
 *    unless the audio sample described by this RTP packetization descriptor
 *    structure is a silent frame, in which case, this field shall be set
 *    to AUDIO_SILENT (defined as 1).
 *
 *  @field DWORD | dwVideoAttributes | Specifies some bitfield attributes
 *    used to characterize the sample in the video stream associated to this
 *    RTP packetization descriptor. There are no video attributes defined at
 *    this time. Therefore, this field shall always be set to 0.
 *
 *  @field DWORD | dwReserved | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD
{
    DWORD dwThisHeaderLength;
    DWORD dwPayloadHeaderOffset;
    DWORD dwPayloadHeaderLength;
    DWORD dwPayloadStartBitOffset;
    DWORD dwPayloadEndBitOffset;
	BOOL  fEndMarkerBit;
    DWORD dwLayerId;
    DWORD dwTimestamp;
	union {
	DWORD dwAudioAttributes;
	DWORD dwVideoAttributes;
	};
    DWORD dwReserved;
} RTP_PD, *PRTP_PD;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_HEADER | The <t RTP_PD_HEADER> structure is used to specify
 *    the details of the RTP Pd format.
 *
 *  @field DWORD | dwThisHeaderLength | Specifies the length, in bytes, of
 *    this structure. This field is the offset to the first <t RTP_PD>
 *    structure.
 *
 *  @field DWORD | dwTotalByteLength | Specifies the length, in bytes, of the
 *    entire data. This includes this structure, the <t RTP_PD> structures,
 *    and the payload information.
 *
 *  @field DWORD | dwNumHeaders | Specifies the number of <t RTP_PD>
 *    structures.
 *
 *  @field DWORD | dwReserved | Reserved. Shall be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_HEADER
{
    DWORD dwThisHeaderLength;
    DWORD dwTotalByteLength;
    DWORD dwNumHeaders;
    DWORD dwReserved;
} RTP_PD_HEADER, *PRTP_PD_HEADER;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_INFO | The <t RTP_PD_INFO> structure is used to specify the
 *    details of the RTP Pd format.
 *
 *  @field REFERENCE_TIME | AvgTimePerSample | Specifies the average time per
 *    list of RTP packet descriptor, in 100ns units. This value shall be
 *    identical to the value of the <p AvgTimePerFrame> field of the video
 *    info header of the related compressed video stream format.
 *
 *  @field DWORD | dwMaxRTPPacketizationDescriptorBufferSize | Specifies the
 *    maximum size in bytes of the entire RTP packetization descriptor buffer.
 *    The format of this buffer is described in the following section. The
 *    maximum size of the entire RTP packetization descriptor buffer rarely
 *    needs to exceed a few hundred bytes.
 *
 *  @field DWORD | dwMaxRTPPayloadHeaderSize | Specifies the maximum size in
 *    bytes of the payload header data for one RTP packet. For example, the
 *    maximum size of a payload header for H.263 version 1 is 12 bytes (Mode
 *    C header).
 *
 *  @field DWORD | dwMaxRTPPacketSize | Specifies the maximum RTP packet
 *    size in bytes to be described by the list of packetization descriptor.
 *    Typically, this number is just below the MTU size of the network.
 *
 *  @field DWORD | dwNumLayers | Specifies the number of encoding layers to
 *    be described by the list of packetization descriptor. Typically, this
 *    number is equal to 1. Only in the case of multi-layered encoders would
 *    this number be higher than 1.
 *
 *  @field DWORD | dwPayloadType | Specifies the static payload type the
 *    stream describes. If the RTP packetization descriptors do not apply to
 *    an existing static payload type but a dynamic payload type, this field
 *    shall be set to DYNAMIC_PAYLOAD_TYPE (defined as MAXDWORD).
 *
 *  @field DWORD | dwDescriptorVersion | Specifies a version identifier
 *    qualifying the format of packetization descriptors. This field shall
 *    be set to VERSION_1 (defined as 1UL) to identify the packetization
 *    descriptor structures described in the next section.
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_INFO {
	REFERENCE_TIME	AvgTimePerSample;
	DWORD			dwMaxRTPPacketizationDescriptorBufferSize;
	DWORD			dwMaxRTPPayloadHeaderSize;
	DWORD			dwMaxRTPPacketSize;
	DWORD			dwNumLayers;
	DWORD			dwPayloadType;
	DWORD			dwDescriptorVersion;
    DWORD			dwReserved[4];
} RTP_PD_INFO, *PRTP_PD_INFO;

/*****************************************************************************
 *  @doc INTERNAL CRTPPDSTRUCTENUM
 *
 *  @struct RTP_PD_CONFIG_CAPS | The <t RTP_PD_CONFIG_CAPS> structure is used
 *    to store the RTP packetization descriptor configuration capabilities.
 *
 *  @field DWORD | dwSmallestRTPPacketSize | Specifies the size in bytes of the
 *    smallest RTP packet the stream can describe (typically, 512 bytes on Modem).
 *
 *  @field DWORD | dwLargestRTPPacketSize | Specifies the size in bytes of the
 *    largest packet the stream can describe (typically, 1350 bytes on LAN).
 *
 *  @field DWORD | dwRTPPacketSizeGranularity | Specifies the granularity of
 *    the increments between the smallest and largest packet size the stream
 *    supports (ex. 1).
 *
 *  @field DWORD | dwSmallestNumLayers | Specifies the smallest number of
 *    encoding layers the stream can describe (typically 1).
 *
 *  @field DWORD | dwLargestNumLayers | Specifies the largest number of
 *    encoding layers the stream can describe (typically 1).
 *
 *  @field DWORD | dwNumLayersGranularity | Specifies the granularity of the
 *    increments between the smallest and largest number of encoding layers
 *    the stream supports (ex. 0).
 *
 *  @field DWORD | dwNumStaticPayloadTypes | Specifies the number of static
 *    payload types the stream supports. This value is valid between 0 and
 *    4  (ex. 2 if it supports RFC 2190 and 2429 with H.263, but typically
 *    only 1).
 *
 *  @field DWORD | dwStaticPayloadTypes[4] | Specifies an array of static
 *    payload types the stream supports. A stream can support at most 4
 *    static payload types. The number of valid entries in this array is
 *    indicated by the <p dwNumStaticPayloadTypes> field (ex. 34 for H.263).
 *
 *  @field DWORD | dwNumDescriptorVersions | Specifies the number of
 *    packetization descriptor versions the stream supports. This value is
 *    valid between 1 and 4 (typically 1).
 *
 *  @field DWORD | dwDescriptorVersions[4] | Specifies an array of version
 *    identifiers qualifying the format of packetization descriptors. A
 *    stream can support at most 4 packetization descriptor versions. The
 *    number of valid entries in this array is indicated by the
 *    <p dwNumDescriptorVersions> field (ex. VERION_1).
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/
typedef struct tagRTP_PD_CONFIG_CAPS  {
	DWORD dwSmallestRTPPacketSize;
	DWORD dwLargestRTPPacketSize;
    DWORD dwRTPPacketSizeGranularity;
	DWORD dwSmallestNumLayers;
	DWORD dwLargestNumLayers;
    DWORD dwNumLayersGranularity;
	DWORD dwNumStaticPayloadTypes;
	DWORD dwStaticPayloadTypes[4];
	DWORD dwNumDescriptorVersions;
	DWORD dwDescriptorVersions[4];
    DWORD dwReserved[4];
} RTP_PD_CONFIG_CAPS, *PRTP_PD_CONFIG_CAPS;

#endif // _RTPPKTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\rendp.h ===
///////////////////////////////////////////////////////////////////////////////
//
// rendp.h
//
// Description: Private rend includes
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __REND_PRIVATE_INCLUDES
#define __REND_PRIVATE_INCLUDES

typedef enum OBJECT_ATTRIBUTE
{
    MEETING_ATTRIBUTES_BEGIN,
    MA_ADVERTISING_SCOPE,
    MA_CONFERENCE_BLOB,
    MA_DESCRIPTION,  
    MA_ISENCRYPTED,
    MA_MEETINGNAME,
    MA_ORIGINATOR,  
    MA_PROTOCOL,
    MA_START_TIME,
    MA_STOP_TIME,
    MA_TYPE,
    MA_URL,
    MEETING_ATTRIBUTES_END,

    USER_ATTRIBUTES_BEGIN,
    UA_USERNAME,
    UA_TELEPHONE_NUMBER,
    UA_IPPHONE_PRIMARY,
    UA_TAPIUID,
    USER_ATTRIBUTES_END

} OBJECT_ATTRIBUTE;
    
// {B6B6BCC0-8E1D-11d1-B011-00C04FC31FEE}
DEFINE_GUID(IID_ITConfBlobPrivate, 
0xb6b6bcc0, 0x8e1d, 0x11d1, 0xb0, 0x11, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee);

interface ITConfBlobPrivate : IUnknown
{
public:

    STDMETHOD (GetName)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetName)(IN BSTR newVal) = 0;

    STDMETHOD (GetOriginator)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetOriginator)(IN BSTR newVal) = 0;

    STDMETHOD (GetUrl)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetUrl)(IN BSTR newVal) = 0;

    STDMETHOD (GetDescription)(OUT BSTR *pVal) = 0;
    STDMETHOD (SetDescription)(IN BSTR newVal) = 0;

    STDMETHOD (GetAdvertisingScope)(OUT RND_ADVERTISING_SCOPE *pVal) = 0;
    STDMETHOD (SetAdvertisingScope)(IN RND_ADVERTISING_SCOPE newVal) = 0;

    STDMETHOD (GetStartTime)(OUT DWORD *pVal) = 0;
    STDMETHOD (SetStartTime)(IN DWORD newVal) = 0;

    STDMETHOD (GetStopTime)(OUT DWORD *pVal) = 0;
    STDMETHOD (SetStopTime)(IN DWORD newVal) = 0;

    STDMETHOD (get_IsModified)(VARIANT_BOOL *pfIsModified) = 0;
};

// {B6B6BCC1-8E1D-11d1-B011-00C04FC31FEE}
DEFINE_GUID(IID_ITDirectoryObjectPrivate, 
0xb6b6bcc1, 0x8e1d, 0x11d1, 0xb0, 0x11, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee);

interface ITDirectoryObjectPrivate : IUnknown
{
public:
    STDMETHOD (GetAttribute)(
        IN    OBJECT_ATTRIBUTE    Attribute,
        OUT   BSTR *              ppAttributeValue
        ) = 0;

    STDMETHOD (SetAttribute)(
        IN    OBJECT_ATTRIBUTE    Attribute,
        IN    BSTR                pAttributeValue
        ) = 0;

    STDMETHOD (GetTTL)(
        OUT   DWORD *             pdwTTL
        ) = 0;


    STDMETHOD (get_SecurityDescriptorIsModified)(
        OUT   VARIANT_BOOL *      pfIsModified
        ) = 0;

    STDMETHOD (put_SecurityDescriptorIsModified)(
        IN   VARIANT_BOOL         fIsModified
        ) = 0;

    STDMETHOD (PutConvertedSecurityDescriptor) (
        IN char *                 pSD,
        IN DWORD                  dwSize
        ) = 0;

    STDMETHOD (GetConvertedSecurityDescriptor) (
        OUT char **                 ppSD,
        OUT DWORD *                 pdwSize
        ) = 0;
};

// {B6B6BCC2-8E1D-11d1-B011-00C04FC31FEE}
DEFINE_GUID(IID_ITDynamicDirectory, 
0xb6b6bcc2, 0x8e1d, 0x11d1, 0xb0, 0x11, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee);

interface ITDynamicDirectory : IUnknown
{
public:
    STDMETHOD (Update)(DWORD dwSecondsPassed) = 0;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\objectwithsite.h ===
#ifndef _TAPI_OBJECT_WITH_SITE_H_
#define _TAPI_OBJECT_WITH_SITE_H_


/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjectWithSite.h

Abstract:

    The implementation of IObjectWithSite interface that allows 
    for per-page persistent data to be stored in registry or as
    a cookie.

--*/


#include <Mshtml.h>
#include <Wininet.h>


//
// this url is used to construct the URL for cookies -- a security measure 
// so a script applet cannot drop a cookie with the same name and data
// and fool us into thinking it is our cookie
//

static const TCHAR gszHardCodedURL[] = _T("http://www.microsoft.com/");

//
// the expiration date is needed to make the cookie persistent
//

static const TCHAR  gszCookieData[] = 
                        _T("6; expires = Sat, 12-Sep-2099 00:00:00 GMT");



//
// dummy suffix to be appended to the url string
//

static const TCHAR  gszURLSuffix[] = 
                        _T("/url");

class CObjectWithSite : public  IObjectWithSite
{

public:

    //
    // current validation level. used to determine whether the page is safe, 
    // unsafe, or whether information from the user is needed
    //
    
    enum EnValidation { VALIDATED_SAFE, VALIDATED_SAFE_PERMANENT, VALIDATED_UNSAFE, UNVALIDATED };


public:

    
    //
    // store type
    // 

    enum EnMechanism { COOKIES, REGISTRY };


    CObjectWithSite(TCHAR const *pszStorageName)
        :m_pszURL(NULL),
        m_dwSecurityZone(URLZONE_UNTRUSTED),
        m_pUnkSite(NULL),
        m_pszStorageName(NULL)
    {
        SetStorageName(pszStorageName);
    }


    ~CObjectWithSite()
    {
    
        if (m_pszURL)
        {
            delete m_pszURL;
        
            m_pszURL = NULL;
        }

        
        if (m_pUnkSite)
        {
            m_pUnkSite->Release();

            m_pUnkSite = NULL;
        }


        if (m_pszStorageName)
        {

            delete m_pszStorageName;

            m_pszStorageName = NULL;

        }
    }

    ////////////////////////////
    //
   	// IObjectWithSite methods


    STDMETHOD(SetSite)(IUnknown *pUnkSite)
    {


        if ((NULL != pUnkSite) && IsBadCodePtr((FARPROC)pUnkSite))
        {
            return E_POINTER;
        }


        s_ObjectWithSiteCritSection.Lock();

        //
        // we are moving away from a page. this is the new page, as far as
        // validation logic is concerned, so invalidate the current page
        //

        if (NULL == pUnkSite)
        {
            Validate(UNVALIDATED);
        }

        // 
        // Get URL and zone information for this site
        //

        //
        // Note: we could delay this until we are actually asked for
        // zone or URL, but this should not be a performance bottlneck 
        // in our case, so do this now to keep the code simple.

        StoreURLAndZone(pUnkSite);


        //
        // replace the current site pointer with the new one
        //

        if (m_pUnkSite)
        {
            m_pUnkSite->Release();
        }


        m_pUnkSite = pUnkSite;

        if (m_pUnkSite)
        {
            m_pUnkSite->AddRef();
        }

        s_ObjectWithSiteCritSection.Unlock();

        return S_OK;
    }


    STDMETHOD(GetSite)(REFIID riid, void **ppSite)
    {

        HRESULT hr = E_POINTER;

        if (!IsBadWritePtr(ppSite, sizeof(void*)))
        {
    
            s_ObjectWithSiteCritSection.Lock();

            *ppSite = NULL;

            if (m_pUnkSite)
            {
                hr = m_pUnkSite->QueryInterface(riid, ppSite);
            }
            else
            {
                hr = E_FAIL;
            }

            s_ObjectWithSiteCritSection.Unlock();

        }

        return hr;
    }


    //
    // has this page been validated?
    //

    EnValidation GetValidation() 
    {

        //
        // if the page has not been validated, see if it is marked as safe
        //

        s_ObjectWithSiteCritSection.Lock();


        if (UNVALIDATED == s_enValidation)
        {
            if (IsPageSafe())
            {
                s_enValidation = VALIDATED_SAFE;
            }
        }

        EnValidation enValidation = s_enValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enValidation;
    }


    //
    // validate page as safe, unsafe, or reset validation
    //
    
    EnValidation Validate(EnValidation enNewValidation)
    {

        s_ObjectWithSiteCritSection.Lock();


        //
        // keep the validation before the change
        //
        
        EnValidation enOldValidation = s_enValidation;


        //
        // safe permanent is a special case:
        //

        if (VALIDATED_SAFE_PERMANENT == enNewValidation)
        {

            //
            // set persistent safety flag and 
            // validate page as safe
            //

            MarkPageAsSafe();
            enNewValidation = VALIDATED_SAFE;
        }


        //
        // change our validation level for this page
        //

        s_enValidation = enNewValidation;

        s_ObjectWithSiteCritSection.Unlock();

        return enOldValidation;
    }



    BOOL IsIntranet()
    {
        
        //
        //  if anything other that intranet assume internet -- a less secure zone
        //

        s_ObjectWithSiteCritSection.Lock();

        BOOL bIntranet = ( m_dwSecurityZone == URLZONE_INTRANET );

        s_ObjectWithSiteCritSection.Unlock();

        return bIntranet;

    }


    ////////////////////
    //
    // HaveSite()
    //
    // return true if we have a site pointer
    //

    BOOL HaveSite()
    {

        s_ObjectWithSiteCritSection.Lock();


        BOOL bHaveSite = FALSE;

        if (NULL != m_pUnkSite)
        {
            bHaveSite = TRUE;
        }


        s_ObjectWithSiteCritSection.Unlock();

        return bHaveSite;
    }



private:

    ////////////////////////////
    //
    //  store the current url in the "safe" list
    //
    //
    // not thread safe, called from inside a lock
    //

    HRESULT MarkPageAsSafe(EnMechanism enMechanism = COOKIES)
    {

        //
        // if storage is invalid, the object has not been properly initialized
        //

        if (IsBadStringPtr(m_pszStorageName, -1))
        {
            return E_UNEXPECTED;
        }


        //
        // is we don't have the url, can't do what we are asked
        //

        if (NULL == m_pszURL)
        {
            return S_FALSE;
        }


        //
        // if url is garbage, we have a problem
        //

        if ( IsBadStringPtr(m_pszURL, -1) )
        {
            return E_FAIL;
        }


        HRESULT hr = E_FAIL;

        switch (enMechanism)
        {

            case REGISTRY:

                hr = MarkPageSafeInRegistry(m_pszStorageName);
                break;

            case COOKIES:

                hr = MarkPageSafeCookie(m_pszStorageName);
                break;

            default:

                break;

        }

        return hr;
    }


    //
    //  Returns TRUE if the current page is in the safe list
    //

    //
    // not thread safe, called from inside a lock
    //

    BOOL IsPageSafe( EnMechanism enMechanism = COOKIES )
    {

        //
        // if we cannot get safety marking for whatever reason,
        // return false
        //
        
        _ASSERTE(NULL != m_pszStorageName);

        if ( IsBadStringPtr(m_pszURL, -1) || 
             IsBadStringPtr(m_pszStorageName, -1))
        {
            return FALSE;
        }

        BOOL bSafe = FALSE;

        switch (enMechanism)
        {

        case REGISTRY:
 
            bSafe = IsPageSafeRegistry(m_pszStorageName);
            break;

        case COOKIES:
 
            bSafe = IsPageSafeCookie(m_pszStorageName);
            break;

        default:
 
            break;
        }

        return bSafe;
    }



private:

    //
    // this method is only called from the constructor. not thread safe.
    //

    HRESULT SetStorageName(TCHAR const *pszStorageName)
    {
        //
        // calling this method invalidates the old storage name
        // so deallocate it before doing anything else
        //

        if (NULL != m_pszStorageName) 
        {
            delete m_pszStorageName;
            m_pszStorageName = NULL;
        }

        //
        // argument must be valid
        //

        if (IsBadStringPtr(pszStorageName, -1))
        {
            return E_POINTER;
        }

        // 
        // allocate buffer for the new storage name
        // 

        size_t nSize = _tcsclen(pszStorageName) + 1;

        m_pszStorageName = new TCHAR[nSize];

        if (NULL == m_pszStorageName)
        {
            return E_OUTOFMEMORY;
        }

        _tcscpy(m_pszStorageName, pszStorageName);

        return S_OK;
    }



    //
    // cache the url string and security zone id
    // not thread safe must be called from inside a lock
    //
    
    HRESULT StoreURLAndZone(IUnknown *pUnkSite)
    {

        //
        // reset zone and deallocate URL, if it exists
        //

        m_dwSecurityZone = URLZONE_UNTRUSTED;

        if (m_pszURL)
        {
            delete m_pszURL;
            m_pszURL = NULL;
        }
		    
        if (pUnkSite == NULL)
        {
            return S_OK;
        }

        // 
        // use pUnkSite to get to IHTMLDocument2, which will give us the URL
        // 

        //
        // these interfaces need to be released on exit.
        // smart pointers will do exactly what we need
        //

        HRESULT hr = E_FAIL;
                
        CComPtr<IOleClientSite> pSite;

	    if (FAILED(hr = pUnkSite->QueryInterface(IID_IOleClientSite, (LPVOID *) &pSite)))
        {
		    return hr;
        }

        
        CComPtr<IOleContainer>  pOleCtr;

	    if (FAILED(hr = pSite->GetContainer(&pOleCtr)))
        {
		    return hr;
        }


        CComPtr<IHTMLDocument2> pDoc;

        if (FAILED(hr = pOleCtr->QueryInterface(IID_IHTMLDocument2, (LPVOID *) &pDoc)))
        {
		    return hr;
        }

    
        // 
        //  get and keep the url
        //

        BSTR bstrURL;
        
        if (FAILED(hr = pDoc->get_URL(&bstrURL)))
        {
		    return hr;
        }

        UINT nURLLength = SysStringLen(bstrURL) + 1;

        _ASSERTE(NULL == m_pszURL);

        m_pszURL = new TCHAR[nURLLength];

        if (NULL == m_pszURL)
        {
            SysFreeString(bstrURL);
            return E_OUTOFMEMORY;
        }



#ifdef _UNICODE

        _tcscpy(m_pszURL, bstrURL);

#else
        int r = WideCharToMultiByte(
                                  CP_ACP,
                                  0,
                                  bstrURL,
                                  nURLLength,
                                  m_pszURL,
                                  nURLLength,
                                  NULL,
                                  NULL );

        if (0 == r)
        {
            SysFreeString(bstrURL);

            delete m_pszURL;
            m_pszURL = NULL;
            
            return E_FAIL;
        }


#endif

        //
        // whatever follows '#' and '?' is "extra info" and is not considered 
        // to be a part of the actual URL by Internet(Set/Get)Coookie. Extra 
        // Info has no value for us -- so throw it out
        //
        
        TCHAR *psDelimiter = _tcsstr(m_pszURL, _T("#"));
        
        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        psDelimiter = _tcsstr(m_pszURL, _T("?"));

        if (NULL != psDelimiter)
        {
            *psDelimiter = _T('\0');
        }


        //
        // at this point we cached the URL
        // now attempt to get the security zone. if we fail getting zone
        // information still keep the url.
        //

        //
        //  Get security zone
        //
        
        CComPtr<IInternetSecurityManager> pSecMgr;
	           

        hr = CoCreateInstance(CLSID_InternetSecurityManager,
		                 NULL,
		                 CLSCTX_INPROC_SERVER,
		                 IID_IInternetSecurityManager,
		                 (LPVOID *) &pSecMgr);

	    if (pSecMgr == NULL)
        {
            SysFreeString(bstrURL);
		    return hr;
        }

	    hr = pSecMgr->MapUrlToZone(bstrURL, &m_dwSecurityZone, 0);
        
        
        //
        // if failed, reset url to untrusted, just in case
        //

        if ( FAILED(hr) )
        {
            m_dwSecurityZone = URLZONE_UNTRUSTED;
        }


        SysFreeString(bstrURL);

        //
        // we should have at least the URL at this point
        //

        return S_OK;
    }

    
    // 
    //  drop a cookie for this page as an indicator that this page is safe
    //

    HRESULT MarkPageSafeCookie(TCHAR const *pszCookieName)
    {

        TCHAR *pszURL = NULL;

        //
        // generate the url for the cookie
        // remember to delete the returned string
        //

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
            return E_OUTOFMEMORY;

        BOOL bReturn = InternetSetCookie(pszURL, pszCookieName, gszCookieData);

        delete pszURL;

        return (bReturn)?S_OK:E_FAIL;
    }



    //
    //  presence of a cookie for this page is an indicator that it's safe
    //  returns TRUE if the cookie exists. FALSE otherwise
    // 
    
    BOOL IsPageSafeCookie(TCHAR const *pszCookieName)
    {
        
        //
        // m_pszURL was checked by the calling function and the object
        // is protected. m_pszURL should never be null here.
        //
        
        _ASSERTE(m_pszURL);

        // 
        // same goes for pszCookieName
        //

        _ASSERTE(pszCookieName);


        BOOL bReturn = FALSE;

        BOOL bFinalReturn = FALSE;


        TCHAR *pszURL = NULL;

        // remember to delete the returned string

        GenerateURLString(&pszURL);

        if (NULL == pszURL)
        {
            return FALSE;
        }
        
        //
        // see how much data the cookie contains
        //
        
        DWORD dwCookieDataSize = 0;
        
        // 
        // assuming the return code is TRUE if the method succeeds in getting
        // get the buffer size. the current documentation is not 100% clear
        //

        bReturn = InternetGetCookie(pszURL, pszCookieName, NULL, &dwCookieDataSize);


        //
        // dwCookieDataSize has the length of cookie data
        //
        
        if ( bReturn && dwCookieDataSize )
        {

            // 
            //  allocate the buffer for cookie data
            //

            TCHAR *pCookieDataBuffer = new TCHAR[dwCookieDataSize];

            if (NULL != pCookieDataBuffer)
            {
                //
                // all cookies for this page are returned in cookie data,
                // the name argument is ignored
                //
            
                bReturn = InternetGetCookie(pszURL,
                                            pszCookieName,
                                            pCookieDataBuffer,
                                            &dwCookieDataSize);
            

                // 
                // is succeeded, parse cookie data buffer to see if the 
                // cookie we are looking for is there
                //
                                
                if ( bReturn && ( NULL != _tcsstr(pCookieDataBuffer, pszCookieName) ) )
                {

                    bFinalReturn = TRUE;
                }


                delete pCookieDataBuffer;
                pCookieDataBuffer = NULL;
            }
        }


        delete pszURL;
        pszURL = NULL;

        return bFinalReturn;
    }

    

    //
    // add a registry entry for this page as an indicator that the page is safe
    // returns TRUE if the registry entry exists
    //

    HRESULT MarkPageSafeInRegistry(TCHAR const *szRegistryKeyName)
    {
       
        _ASSERTE(m_pszURL);

        //
        // open the registry key. create if not there
        //

        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {
            DWORD dwData = 0;

            //
            //  add the current URL to the registry
            //

            rc = RegSetValueEx(hKey,
                               m_pszURL,
                               0,
                               REG_DWORD,
                               (BYTE*)&dwData, 
                               sizeof(DWORD));
 
        }

        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        if (rc == ERROR_SUCCESS )
        {
            return S_OK;
        }
        else 
        {
            return E_FAIL;
        }
    }


    // 
    // presence of a registry entry for this page indicates that the 
    // page is safe
    //
    
    BOOL IsPageSafeRegistry(TCHAR const *szRegistryKeyName)
    {
        
        DWORD dwDisposition = 0;
        HKEY hKey = 0;

        //
        // the default is not safe
        //

        if (NULL == m_pszURL)
        {
            return FALSE;
        }

        //
        // open the registry key where the page information is kept.
        // create if not there
        //

        LONG rc = RegCreateKeyEx(HKEY_CURRENT_USER,
                            szRegistryKeyName, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_CREATE_SUB_KEY | KEY_READ,
                            NULL,
                            &hKey,
                            &dwDisposition);

        if ( rc == ERROR_SUCCESS )
        {


            DWORD dwDataType = 0;
            DWORD dwDataSize = 0;
            
            // 
            // read the setting for the current page.
            // Note: we don't need the actual data, we just
            // want to see if the value exists
            // 

            rc = RegQueryValueEx(hKey,
                            m_pszURL,
                            0,
                            &dwDataType,
                            NULL,
                            &dwDataSize
                           );
        }
        
        if (hKey)
        {
            RegCloseKey(hKey);
        }

        hKey = NULL;

        return (rc == ERROR_SUCCESS);
    }


    // 
    // build the URL string based on the hardcoded URL and 
    // the actual URL for this page.
    // we are hoping that the striing will be unique (per page) and no
    // mischevious scripting app can drop a cookie corresponding to 
    // this URL
    // 
    // Note: if the implementation of of Internet(Set/Get)Cookie changes
    // to have stricter validation for the URL string, this technique will
    // not work
    // 

    void GenerateURLString(TCHAR **ppszURL)
    {
        
        //
        // the precondition is that m_pszURL exists
        //

        _ASSERT(NULL != m_pszURL);

        *ppszURL = NULL;

        //
        // alias the char pointer pointer to by *pszURL.
        // so it is easier to refer to.
        //

        TCHAR* &pszURL = *ppszURL;
        
        //
        // allocate memory for concatenated string
        //

        pszURL = new TCHAR[_tcslen(gszHardCodedURL) + 
                           _tcslen(m_pszURL) + 
                           _tcslen(gszURLSuffix) + 1];

        // concatenate 

        if (pszURL)
        {
            *pszURL = _T('\0');
        
            _tcscat(pszURL, gszHardCodedURL);
            _tcscat(pszURL, m_pszURL);
            _tcscat(pszURL, gszURLSuffix);
        }

    }



private:
    
    //
    // cached URL string
    //

    TCHAR *m_pszURL;


    //
    // cached security zone
    //
    
    DWORD m_dwSecurityZone;


    //
    // site for IObjectWithSite
    //

    IUnknown *m_pUnkSite;

    // 
    // thread safety
    //

    static CComAutoCriticalSection s_ObjectWithSiteCritSection;

    //
    // the status of the current page
    //

    static EnValidation s_enValidation;

    //
    // name of the persistent cookie or registry key
    //
    
    TCHAR *m_pszStorageName;

};

#endif // _TAPI_OBJECT_WITH_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\scrpscrtdlg.h ===
// DlgAddr.h : Declaration of the CScriptSecurityDialog

#ifndef __SCRIPTSECURITYDIALOG_H_
#define __SCRIPTSECURITYDIALOG_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CScriptSecurityDialog


//
// this class is not thread safe
//

class CScriptSecurityDialog : 
	public CDialogImpl<CScriptSecurityDialog>
{

public:

    CScriptSecurityDialog ()
        :m_hModule(NULL),
        m_psMessageText(NULL)

    {
        //
        // the resource module is used to load the string and the dialog itself
        // so keep it around as a data member
        //

        m_hModule = ::LoadLibrary(_T("tapiui.dll"));
        
    }


    ~CScriptSecurityDialog ()
    {
        if (m_hModule)
        {
            FreeLibrary(m_hModule);
            m_hModule = NULL;
        }
    }


    INT_PTR DoModalWithText(UINT uResourceID, HWND hWndParent = ::GetActiveWindow())
    {

        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //
                
        _ASSERTE(NULL == m_psMessageText);

        //
        // load string from resource module
        //

        m_psMessageText = SafeLoadString(uResourceID);


        // 
        // if failed, bail out now
        //

        if (NULL == m_psMessageText)
        {

            return -1;
        }

        
        //
        // attempt to display the dialog box
        // the string is used in OnInitDialog to set the dialog's text
        //
        
        INT_PTR rc = _DoModal(hWndParent);

        //
        // deallocate string
        //

        delete m_psMessageText;
        m_psMessageText = NULL;

        return rc;
    }



    INT_PTR DoModalWithText(LPTSTR psMessageText, HWND hWndParent = ::GetActiveWindow())
    {
        //
        // this assertion could fail is if the class is used from 
        // a multithreaded app, and domodalX is called on two different threads
        // the class is not thread safe and this should be caught during 
        // testing.
        // another way this assert could fire is if the class itself is
        // broken. this, too, is a test-time error. 
        //

        _ASSERTE(NULL == m_psMessageText);

        //
        // the dialog is modal, so the lifetime of psMessageText is guaranteed 
        // to exceed the lifetime of the dialog.
        //

        m_psMessageText = psMessageText;

        
        //
        // attempt to display the dialog. the string will be used to set 
        // the message text in OnInitDialog
        // 

        INT_PTR rc = _DoModal(hWndParent);

        //
        // no longer need the string + the string cannot be assumed 
        // valid after we return
        //
        
        m_psMessageText = NULL;

        return rc;
    }

	enum { IDD = IDD_TAPI_SECURITY_DIALOG };


public:

BEGIN_MSG_MAP(CScriptSecurityDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(ID_YES, OnYes)
	COMMAND_ID_HANDLER(ID_NO, OnNo)
END_MSG_MAP()



//
// Attributes
//

private:

    //
    // the module where the resource is contained
    // needed for the prompt string and for the dialog itself
    // 

    HINSTANCE m_hModule;

    //
    // the prompt text
    //

    LPTSTR m_psMessageText;
    

protected:

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {   
        //
        // m_psMessageText must be set before _DoModal is called
        // if m_psMessageText is null here, the error is in the class itself
        // and this should be detected during testing
        //

        _ASSERTE(NULL != m_psMessageText);


        //
        // display the text that was passed into DoModalWithText as a string 
        // or a resources
        //

        SetDlgItemText(IDC_SECURITY_WARNING_TEXT, m_psMessageText);

	    return TRUE;
    }

	LRESULT OnYes(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        //
        // see if do not ask in the future is set
        // 
        
        if (IsDlgButtonChecked(IDC_DONOT_PROMPT_IN_THE_FUTURE))
            wID = ID_YES_DONT_ASK_AGAIN;

        EndDialog(wID);
       
        return FALSE;
    }


    LRESULT OnNo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        
        EndDialog(wID);
        
        return FALSE;
    }

	
private:

    INT_PTR _DoModal(HWND hWndParent)
    {
        
        // 
        // if the resource dll failed to load, bail out
        //
        
        if (NULL == m_hModule)
        {
            return -1;
        }
        
        //
        // otherwise, attempt to display the dialog box
        //

        _ASSERTE(m_hWnd == NULL);
        _Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
        INT_PTR nRet = ::DialogBoxParam(m_hModule,
                        MAKEINTRESOURCE(CScriptSecurityDialog::IDD),
                        hWndParent,
                        CScriptSecurityDialog::StartDialogProc,
                        NULL);

 
        m_hWnd = NULL;
        return nRet;
    }


private:

    //
    // Load string for this resource. Safe with respect to string size
    //
    
    TCHAR *SafeLoadString( UINT uResourceID )
    {

        TCHAR *pszTempString = NULL;

        int nCurrentSizeInChars = 128;
        
        int nCharsCopied = 0;
        
        do
        {

            if ( NULL != pszTempString )
            {
                delete  pszTempString;
                pszTempString = NULL;
            }

            nCurrentSizeInChars *= 2;

            pszTempString = new TCHAR[ nCurrentSizeInChars ];

            if (NULL == pszTempString)
            {
                return NULL;
            }

            nCharsCopied = ::LoadString( m_hModule,
                                         uResourceID,
                                         pszTempString,
                                         nCurrentSizeInChars
                                        );

            if ( 0 == nCharsCopied )
            {
                delete pszTempString;
                return NULL;
            }

            //
            // nCharsCopied does not include the null terminator
            // so compare it to the size of the buffer - 1
            // if the buffer was filled completely, retry with a bigger buffer
            //

        } while ( (nCharsCopied >= (nCurrentSizeInChars - 1) ) );

        return pszTempString;
    }


    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    HWND Create(HWND hWndParent, LPCTSTR psMessageText = NULL)
    {
        // this dialog must be created as modal

        _ASSERTE(FALSE);

        return NULL;
    }

    //
    // private, not to be called. the dialog must be created with DoModalWithText
    //

    INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
    {
        _ASSERTE(FALSE);

        return -1;
    }


};

#endif //__SCRIPTSECURITYDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdp.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdp.h

Abstract:


Author:

*/

#ifndef __SDP__
#define __SDP__

#include "sdpcommo.h"
#include "sdpcset.h"
#include "sdpgen.h"
#include "sdpver.h"
#include "sdporigi.h"
#include "sdpconn.h"
#include "sdpbw.h"
#include "sdpatt.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"
#include "sdptime.h"
#include "sdpadtex.h"
#include "sdpenc.h"
#include "sdpmedia.h"


enum PARSE_STATE
{
    STATE_START,
    STATE_VERSION,
    STATE_ORIGIN,
    STATE_SESSION_NAME,
    STATE_TITLE,
    STATE_URI,
    STATE_EMAIL,
    STATE_PHONE,
    STATE_CONNECTION,
    STATE_BANDWIDTH,
    STATE_TIME,
    STATE_REPEAT,
    STATE_ADJUSTMENT,
    STATE_KEY,
    STATE_ATTRIBUTE,
    STATE_MEDIA,
    STATE_MEDIA_TITLE,
    STATE_MEDIA_CONNECTION,
    STATE_MEDIA_BANDWIDTH,
    STATE_MEDIA_KEY,
    STATE_MEDIA_ATTRIBUTE,
    STATE_NUM_STATES           // not a valid state, merely to count the number of states
};




class _DllDecl SDP
{
public:

    inline SDP();

    BOOL    Init();

    BOOL    IsValid();

	void	Reset();

    BOOL    IsModified();

    BOOL    ParseSdpPacket(
                IN      CHAR    *SdpPacket,
                IN      SDP_CHARACTER_SET CharacterSet = CS_IMPLICIT
                );

    // clears the modified state for each member field/value
    // this is used in sdpblb.dll to clear the modified state (when an sdp 
    // is parsed in, the state of all parsed in fields/values is modified) and 
    // the m_WasModified dirty flag
    void    ClearModifiedState();

    CHAR    *GenerateSdpPacket();

    inline BOOL                     GetWasModified();

    inline SDP_CHARACTER_SET        GetCharacterSet();

    inline SDP_VERSION              &GetProtocolVersion();

    inline SDP_ORIGIN               &GetOrigin();

    inline SDP_REQD_BSTRING_LINE    &GetSessionName();

    inline SDP_REQD_BSTRING_LINE    &GetSessionTitle();

    inline SDP_CHAR_STRING_LINE     &GetUri();

    inline SDP_EMAIL_LIST           &GetEmailList();
    
    inline SDP_PHONE_LIST           &GetPhoneList();

    inline SDP_CONNECTION           &GetConnection();

    inline SDP_BANDWIDTH            &GetBandwidth();

    inline void                     ClearDestroyTimeListFlag();

    inline SDP_TIME_LIST            &GetTimeList();

    inline SDP_ENCRYPTION_KEY       &GetEncryptionKey();

    inline SDP_ATTRIBUTE_LIST       &GetAttributeList();

    inline void                     ClearDestroyMediaListFlag();

    inline SDP_MEDIA_LIST           &GetMediaList();

    virtual ~SDP();

protected:

    // tracks if the last attempt to generate an sdp packet failed (starts with FALSE)
    BOOL                    m_LastGenFailed;
    CHAR                    *m_SdpPacket;
    DWORD                   m_BytesAllocated;
    DWORD                   m_SdpPacketLength;

    // dirty flag - is initially false and is set to TRUE when an sdp is generated because it had
    // been modified since the last time the sdp was generated.
    // (as IsModified() becomes FALSE after that)
    BOOL                    m_WasModified;

    CHAR                    *m_Current;
    PARSE_STATE             m_ParseState;

    BOOL                    m_DestroyMediaList;
    BOOL                    m_DestroyTimeList;

    SDP_CHARACTER_SET       m_CharacterSet;
    SDP_VERSION             m_ProtocolVersion;
    SDP_ORIGIN              m_Origin;
    SDP_REQD_BSTRING_LINE   m_SessionName;
    SDP_REQD_BSTRING_LINE   m_SessionTitle;     // optional
    SDP_CHAR_STRING_LINE    m_Uri;              // optional
    SDP_EMAIL_LIST          m_EmailList;        // optional
    SDP_PHONE_LIST          m_PhoneList;        // optional
    SDP_CONNECTION          m_Connection;
    SDP_BANDWIDTH           m_Bandwidth;        // optional
    SDP_TIME_LIST           *m_TimeList;         // optional
    SDP_ENCRYPTION_KEY      m_EncryptionKey;    // optional
    SDP_ATTRIBUTE_LIST      m_AttributeList;    // optional
    SDP_MEDIA_LIST          *m_MediaList;

    BOOL    DetermineCharacterSet(
                IN      CHAR                *SdpPacket,
                    OUT SDP_CHARACTER_SET   &CharacterSet
                );

private:


    BOOL    GetType(
                    OUT CHAR    &Type,
                    OUT BOOL    &EndOfPacket
                );

    
    BOOL    CheckTransition(
                IN      CHAR        Type,
                IN      PARSE_STATE CurrentParseState,
                    OUT PARSE_STATE &NewParseState
                );

    BOOL    GetValue(IN CHAR    Type);

    BOOL    IsValidEndState()   const;

};




inline 
SDP::SDP(
    )
    : m_SessionName(SDP_INVALID_SESSION_NAME, SESSION_NAME_STRING),
      m_SessionTitle(SDP_INVALID_SESSION_TITLE, TITLE_STRING),
      m_Uri(SDP_INVALID_URI, URI_STRING),
      m_AttributeList(ATTRIBUTE_STRING),
      m_DestroyMediaList(FALSE),
      m_MediaList(NULL),
      m_DestroyTimeList(FALSE),
      m_TimeList(NULL),
      m_SdpPacket(NULL),
      m_Current(NULL),
	  m_ParseState(STATE_START),
      m_LastGenFailed(FALSE),
      m_WasModified(FALSE),
      m_BytesAllocated(0),
      m_SdpPacketLength(0)
{
}


inline BOOL                     
SDP::GetWasModified(
    )
{
    return m_WasModified;
}


inline SDP_CHARACTER_SET              
SDP::GetCharacterSet(
    )
{
    return m_CharacterSet;
}



inline SDP_VERSION          &
SDP::GetProtocolVersion(
    )
{
    return m_ProtocolVersion;
}

inline SDP_ORIGIN           &
SDP::GetOrigin(
    )
{
    return m_Origin;
}

inline SDP_REQD_BSTRING_LINE     &
SDP::GetSessionName(
    )
{
    return m_SessionName;
}

inline SDP_REQD_BSTRING_LINE     &
SDP::GetSessionTitle(
    )
{
    return m_SessionTitle;
}


inline SDP_CHAR_STRING_LINE     &
SDP::GetUri(
    )
{
    return m_Uri;
}


inline SDP_EMAIL_LIST       &
SDP::GetEmailList(
    )
{
    return m_EmailList;
}
    
inline SDP_PHONE_LIST       &
SDP::GetPhoneList(
    )
{
    return m_PhoneList;
}

inline SDP_CONNECTION       &
SDP::GetConnection(
    )
{
    return m_Connection;
}

inline SDP_BANDWIDTH        &
SDP::GetBandwidth(
    )
{
    return m_Bandwidth;
}


inline void                     
SDP::ClearDestroyTimeListFlag(
    )
{
    m_DestroyTimeList = FALSE;
}


inline SDP_TIME_LIST        &
SDP::GetTimeList(
    )
{
    ASSERT(NULL != m_TimeList);
    return *m_TimeList;
}

inline SDP_ENCRYPTION_KEY   &
SDP::GetEncryptionKey(
    )
{
    return m_EncryptionKey;
}

inline SDP_ATTRIBUTE_LIST &
SDP::GetAttributeList(
    )
{
    return m_AttributeList;
}


inline void                     
SDP::ClearDestroyMediaListFlag(
    )
{
    m_DestroyMediaList = FALSE;
}


inline SDP_MEDIA_LIST       &
SDP::GetMediaList(
    )
{
    ASSERT(NULL != m_MediaList);
    return *m_MediaList;
}




#endif // __SDP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpatt.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpatt.h

Abstract:


Author:

*/
#ifndef __SDP_ATTRIBUTE__
#define __SDP_ATTRIBUTE__


#include "sdpcommo.h"
#include "sdpval.h"

#include "sdpsatt.h"


class _DllDecl SDP_ATTRIBUTE_LIST : 
    public SDP_VALUE_LIST,
    public SDP_ATTRIBUTE_SAFEARRAY
{
public:

    inline SDP_ATTRIBUTE_LIST(
        IN      const   CHAR    *TypeString
        );

    virtual SDP_VALUE   *CreateElement();

protected:

    const   CHAR    * const m_TypeString;
};



inline 
SDP_ATTRIBUTE_LIST::SDP_ATTRIBUTE_LIST(
    IN      const   CHAR    *TypeString
    )
    : SDP_ATTRIBUTE_SAFEARRAY(*this),
      m_TypeString(TypeString)
{
}


#endif // __SDP_ATTRIBUTE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpcommo.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpcommo.h

Abstract:


Author:

*/
#ifndef __SDP_COMMON__
#define __SDP_COMMON__


#ifndef __SDP_LIB__
#define _DllDecl 
#else
#define _DllDecl 
#endif


#include <afx.h>
#include <afxtempl.h>

#include <windows.h>
#include <wtypes.h>


// Disable warning messages for using "this" in base member initializer list.
#pragma warning( disable : 4355 )  

// forward declaration for output stream from #include <strstrea.h>
class ostrstream;

class SDP;

class SDP_FIELD;
class SDP_SINGLE_FIELD;
class SDP_VALUE;

class SDP_BSTRING;
class SDP_OPTIONAL_BSTRING;
class SDP_BSTRING_LINE;
class SDP_REQD_BSTRING_LINE;

class SDP_CHAR_STRING;
class SDP_LIMITED_CHAR_STRING;
class SDP_CHAR_STRING_LINE;

class SDP_BYTE;
class SDP_LONG;
class SDP_ULONG;
class SDP_ADDRESS;

class SDP_ADDRESS_TEXT;
class SDP_ADDRESS_TEXT_LIST;

class SDP_TIME_PERIOD;
class SDP_TIME_PERIOD_LIST;

class SDP_VERSION;
class SDP_ORIGIN;
class SDP_EMAIL;
class SDP_EMAIL_LIST;
class SDP_PHONE;
class SDP_PHONE_LIST;
class SDP_CONNECTION;
class SDP_BANDWIDTH;
class SDP_TIME;
class SDP_TIME_LIST;
class SDP_REPEAT;
class SDP_REPEAT_LIST;
class SDP_ADJUSTMENT;
class SDP_ATTRIBUTE_LIST;
class SDP_MEDIA;
class SDP_MEDIA_LIST;

class SDP_LINE_TRANSITION;
struct LINE_TRANSITION_INFO;

class SDP_ADDRESS_TEXT_SAFEARRAY;
class SDP_ATTRIBUTE_SAFEARRAY;
class SDP_TIME_PERIOD_SAFEARRAY;
class SDP_ADJUSTMENT_SAFEARRAY;

#endif // __SDP_COMMON__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpbw.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpbw.h

Abstract:


Author:

*/
#ifndef __SDP_BANDWIDTH__
#define __SDP_BANDWIDTH__

#include "sdpcommo.h"
#include "sdpval.h"
#include "sdpbstrl.h"
#include "sdpgen.h"



class _DllDecl SDP_BANDWIDTH : public SDP_VALUE
{
public:

    SDP_BANDWIDTH();

    inline SDP_OPTIONAL_BSTRING &GetModifier();

    inline SDP_ULONG            &GetBandwidthValue();

    HRESULT SetBandwidth(
        IN          BSTR    Modifier,
        IN          ULONG   Value
        );

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void    InternalReset();

private:

    SDP_OPTIONAL_BSTRING    m_Modifier;
    SDP_ULONG               m_Bandwidth;
};



inline SDP_OPTIONAL_BSTRING &
SDP_BANDWIDTH::GetModifier(
    )
{
    return m_Modifier;
}

inline SDP_ULONG    &
SDP_BANDWIDTH::GetBandwidthValue(
    )
{
    return m_Bandwidth;
}


#endif // __SDP_BANDWIDTH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpadtex.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpadtex.h

Abstract:


Author:

*/

#ifndef __SDP_ADDRESS_TEXT__
#define __SDP_ADDRESS_TEXT__

#include "sdpcommo.h"
#include "sdpgen.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"

#include "sdpsadt.h"


class _DllDecl SDP_ADDRESS_TEXT : public SDP_VALUE
{
public:

    inline  SDP_ADDRESS_TEXT(
        IN              DWORD                   ErrorCode,
        IN      const   CHAR                    *TypeString,
        IN      const   SDP_LINE_TRANSITION     *SdpLineTransition = NULL
        );

    inline  SDP_OPTIONAL_BSTRING    &GetAddress();

    inline  SDP_BSTRING             &GetText();

    inline  BOOL                    SetCharacterSet(
        IN      SDP_CHARACTER_SET   CharacterSet
        );

    HRESULT SetAddressTextValues(
        IN		BSTR    AddressBstr,
        IN		BSTR    TextBstr
        );

protected:

    SDP_OPTIONAL_BSTRING    m_Address;
    SDP_BSTRING             m_Text;

    
    virtual BOOL    GetField(
			OUT SDP_FIELD   *&Field,
			OUT BOOL        &AddToArray
    ) = 0;

    virtual void	InternalReset();
};
 


inline 
SDP_ADDRESS_TEXT::SDP_ADDRESS_TEXT(
    IN              DWORD                   ErrorCode,
    IN      const   CHAR                    *TypeString,
    IN      const   SDP_LINE_TRANSITION     *SdpLineTransition
    )
    : SDP_VALUE(ErrorCode, TypeString, SdpLineTransition)
{
}



inline  SDP_OPTIONAL_BSTRING    &
SDP_ADDRESS_TEXT::GetAddress(
    )
{
    return m_Address;
}


inline  SDP_BSTRING             &
SDP_ADDRESS_TEXT::GetText(
    )
{
    return m_Text;
}


inline  BOOL
SDP_ADDRESS_TEXT::SetCharacterSet(
    IN      SDP_CHARACTER_SET   CharacterSet
    )
{
    return m_Text.SetCharacterSet(CharacterSet);
}


class _DllDecl SDP_ADDRESS_TEXT_LIST: 
    public SDP_VALUE_LIST,
    public SDP_ADDRESS_TEXT_SAFEARRAY
{
public:

    inline SDP_ADDRESS_TEXT_LIST();

    inline void SetCharacterSet(
        IN      SDP_CHARACTER_SET   CharacterSet
        );

protected:

    SDP_CHARACTER_SET   m_CharacterSet;
};



inline 
SDP_ADDRESS_TEXT_LIST::SDP_ADDRESS_TEXT_LIST(
    )
    : SDP_ADDRESS_TEXT_SAFEARRAY(*this)
{
}


// no need to check if the character set value is acceptable
// the check is performed in the list member
inline void 
SDP_ADDRESS_TEXT_LIST::SetCharacterSet(
    IN SDP_CHARACTER_SET CharacterSet
    )
{
    m_CharacterSet = CharacterSet;
}




class _DllDecl SDP_PHONE: public SDP_ADDRESS_TEXT
{
public:

    SDP_PHONE();

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );
};



class _DllDecl  SDP_PHONE_LIST : public SDP_ADDRESS_TEXT_LIST
{
protected:

    virtual SDP_VALUE   *CreateElement();
};



class _DllDecl  SDP_EMAIL: public SDP_ADDRESS_TEXT
{
public:

    SDP_EMAIL();

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );
};


class _DllDecl  SDP_EMAIL_LIST : public SDP_ADDRESS_TEXT_LIST
{
protected:

    virtual SDP_VALUE   *CreateElement();
};


#endif // __SDP_ADDRESS_TEXT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpbstrl.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpbstrl.h

Abstract:


Author:

*/
#ifndef __SDP_BSTRING_LINE__
#define __SDP_BSTRING_LINE__

#include "sdpcommo.h"

#include <wtypes.h>
#include "sdpdef.h"
#include "sdpgen.h"
#include "sdpcstrl.h"
#include "sdpcset.h"




class _DllDecl SDP_ARRAY_BSTR : public CArray<BSTR, BSTR>
{
public:

    virtual ~SDP_ARRAY_BSTR();
};


class _DllDecl SDP_BSTRING : public SDP_CHAR_STRING
{
public:

    inline                      SDP_BSTRING();

	virtual void				Reset();

    inline SDP_CHARACTER_SET    GetCharacterSet() const;

    inline BOOL                 SetCharacterSet(IN SDP_CHARACTER_SET CharacterSet);

    inline BSTR                 &GetBstr();

	HRESULT						GetBstrCopy(IN BSTR *Bstr);

    virtual HRESULT             GetBstr(IN BSTR *Bstr);

    virtual HRESULT             SetBstr(IN BSTR Bstr);

    virtual                     ~SDP_BSTRING();

protected:

    SDP_CHARACTER_SET   m_CharacterSet;
    UINT                m_CodePage;
    BSTR                m_Bstr;

    virtual BOOL        InternalSetCharStrByRef(
        IN			CHAR    *CharacterStringByReference,
		IN			DWORD	Length
        );

    virtual BOOL        InternalSetCharStrByCopy(
        IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length
        );

    virtual BOOL        InternalParseToken(
        IN			CHAR    *Token
        );
    
    BOOL ConvertToBstr(
        );
};



inline 
SDP_BSTRING::SDP_BSTRING(
    )
    : m_Bstr(NULL),
      m_CharacterSet(CS_UTF8),
      m_CodePage(CP_UTF8)
{
}


inline SDP_CHARACTER_SET   
SDP_BSTRING::GetCharacterSet(
    ) const
{
    return m_CharacterSet;
}


inline BOOL 
SDP_BSTRING::SetCharacterSet(
    IN SDP_CHARACTER_SET CharacterSet
    )
{
    // check if the character set value is acceptable
    if ( !IsLegalCharacterSet(CharacterSet, &m_CodePage) )
    {
        SetLastError(SDP_INTERNAL_ERROR);
        return FALSE;
    }

    m_CharacterSet = CharacterSet;
    return TRUE;
}


inline BSTR                 &
SDP_BSTRING::GetBstr(
    )
{
    return m_Bstr;
}



// its initially created with the ascii character set and
// it doesn't allow for changing the character set
class _DllDecl SDP_OPTIONAL_BSTRING : public SDP_BSTRING
{
public:

    inline SDP_OPTIONAL_BSTRING();

	virtual void Reset();
    
    // returns the bstr for the character string
    // creates a bstr if required
    virtual HRESULT     GetBstr(IN BSTR *Bstr);

    virtual HRESULT     SetBstr(IN BSTR Bstr);

protected:

    BOOL    m_IsBstrCreated;

    virtual BOOL        InternalSetCharStrByRef(
        IN			CHAR    *CharacterStringByReference,
		IN			DWORD	Length
        );

    virtual BOOL        InternalSetCharStrByCopy(
        IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length
        );

private:

    // since the bstr must only be created on demand, parsing must
    // be over-ridden such that the bstr is not created during parsing
    virtual BOOL    InternalParseToken(
        IN      CHAR    *Token
        );

    // ZoltanS win64 fix: This bogus code was causing warnings.
    // Removed these methods so that the compiler will make sure that they
    // are never called. (Why it was ever done this way is a real mystery.)
    // 
    // inline BOOL     SetCharacterSet(IN SDP_CHARACTER_SET CharacterSet)
    // {
    //     // this is never called
    //     ASSERT(FALSE);
    //     return FALSE;
    // }
    //
    // inline BSTR     &GetBstr()
    // {
    //     BSTR    ReturnValue;
    //     // this is never called
    //     ASSERT(FALSE);
    //     return ReturnValue;
    // }
};


inline 
SDP_OPTIONAL_BSTRING::SDP_OPTIONAL_BSTRING(
    )
    : m_IsBstrCreated(FALSE)
{}




class _DllDecl SDP_BSTRING_LINE : public SDP_STRING_LINE
{
public:

    inline SDP_BSTRING_LINE(
        IN      const   DWORD       ErrorCode,
        IN      const   CHAR        *TypeString,
        IN              SDP_BSTRING &SdpBstring
        );

    virtual HRESULT     GetBstrCopy(IN BSTR *Bstr);

    virtual HRESULT     SetBstr(IN BSTR Bstr);

    inline SDP_BSTRING  &GetBstring();
};



inline 
SDP_BSTRING_LINE::SDP_BSTRING_LINE(
    IN      const   DWORD       ErrorCode,
    IN      const   CHAR        *TypeString,
    IN              SDP_BSTRING &SdpBstring
    )
    : SDP_STRING_LINE(ErrorCode, TypeString, SdpBstring)
{
}


inline SDP_BSTRING  &
SDP_BSTRING_LINE::GetBstring(
    )
{
    return (SDP_BSTRING &)m_ParseField;
}


class _DllDecl SDP_REQD_BSTRING_LINE : public SDP_BSTRING_LINE
{
public:

    inline SDP_REQD_BSTRING_LINE(
        IN      const   DWORD   ErrorCode,
        IN      const   CHAR    *TypeString
        );

private:

    SDP_BSTRING m_Bstring;

	virtual void InternalReset();
};



inline 
SDP_REQD_BSTRING_LINE::SDP_REQD_BSTRING_LINE(
    IN      const   DWORD   ErrorCode,
    IN      const   CHAR    *TypeString
    )
    : SDP_BSTRING_LINE(ErrorCode, TypeString, m_Bstring)
{
}





class _DllDecl SDP_CHAR_STRING_LINE : public SDP_BSTRING_LINE
{
public:

    inline SDP_CHAR_STRING_LINE(
        IN      const   DWORD   ErrorCode,
        IN      const   CHAR    *TypeString
        );

private:

    SDP_OPTIONAL_BSTRING m_SdpOptionalBstring;

	virtual void InternalReset();
};


inline 
SDP_CHAR_STRING_LINE::SDP_CHAR_STRING_LINE(
    IN      const   DWORD   ErrorCode,
    IN      const   CHAR    *TypeString
    )
    : SDP_BSTRING_LINE(ErrorCode, TypeString, m_SdpOptionalBstring)
{
}




class _DllDecl SDP_LIMITED_CHAR_STRING : public SDP_OPTIONAL_BSTRING
{
public:

    inline SDP_LIMITED_CHAR_STRING(
        IN      const   CHAR    **LegalStrings,
        IN              DWORD   NumStrings
        );

    HRESULT SetLimitedCharString(
        IN              CHAR    *String
        );

protected:

    const CHAR	**m_LegalStrings;
    const DWORD	m_NumStrings;
    
    virtual BOOL InternalParseToken(
        IN              CHAR    *Token
        );
};



inline 
SDP_LIMITED_CHAR_STRING::SDP_LIMITED_CHAR_STRING(
        IN      const   CHAR    **LegalStrings,
        IN              DWORD   NumStrings
        )
        : m_LegalStrings(LegalStrings),
          m_NumStrings(NumStrings)
{
}




class _DllDecl SDP_ADDRESS : public SDP_OPTIONAL_BSTRING
{
public:

    inline SDP_ADDRESS();

    inline  BOOL    IsMulticast() const;

    inline  void    SetMulticast(
        IN      BOOL    IsMulticastFlag
        );

    HRESULT SetAddress(
        IN      BSTR    Address
        );

    // calls SetAddress(Bstr)
    virtual HRESULT SetBstr(
        IN BSTR Bstr
        );

protected:

    BOOL   m_IsMulticastFlag;
    
    virtual BOOL InternalParseToken(
        IN      CHAR    *Token
        );

    BOOL IsValidIP4Address(
        IN  CHAR    *Address,
        OUT ULONG   &Ip4AddressValue
        );
};


inline SDP_ADDRESS::SDP_ADDRESS(
    )
    : m_IsMulticastFlag(FALSE)
{
}


inline  BOOL   
SDP_ADDRESS::IsMulticast(
    )   const
{
    return m_IsMulticastFlag;
}


inline  void 
SDP_ADDRESS::SetMulticast(
    IN BOOL IsMulticastFlag
    )
{
    m_IsMulticastFlag = IsMulticastFlag;
}



#endif // __SDP_BSTRING_LINE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpcset.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpcset.h

Abstract:


Author:

*/

#ifndef __SDP_CHARACTER_SET__
#define __SDP_CHARACTER_SET__

// for code pages etc.
#include <winnls.h>


const   CHAR    SDP_CHARACTER_SET_STRING[]  = "\na=charset:";
const   USHORT  SDP_CHARACTER_SET_STRLEN    = (USHORT) strlen(SDP_CHARACTER_SET_STRING);

const   CHAR    ASCII_STRING[]              = "ascii";
const   USHORT  ASCII_STRLEN                = (USHORT) strlen(ASCII_STRING);    

const   CHAR    UTF7_STRING[]               = "unicode-1-1-utf7";
const   USHORT  UTF7_STRLEN                 = (USHORT) strlen(UTF7_STRING);    

const   CHAR    UTF8_STRING[]               = "unicode-1-1-utf8";
const   USHORT  UTF8_STRLEN                 = (USHORT) strlen(UTF8_STRING);   


enum SDP_CHARACTER_SET
{
    CS_IMPLICIT,        // implicit from the sdp
    CS_ASCII,           // 8bit ISO 8859-1
    CS_UTF7,            // unicode, ISO 10646, UTF-7 encoding (rfc 1642)
    CS_UTF8,             // unicode, UTF-8 encoding
    CS_INVALID          // invalid character set
};





struct  SDP_CHARACTER_SET_ENTRY
{
    SDP_CHARACTER_SET   m_CharSetCode;
    const CHAR          *m_CharSetString;
    USHORT              m_Length;
};


const   SDP_CHARACTER_SET_ENTRY SDP_CHARACTER_SET_TABLE[] = {
    {CS_UTF7, UTF7_STRING, UTF7_STRLEN},
    {CS_UTF8, UTF8_STRING, UTF8_STRLEN}, 
    {CS_ASCII, ASCII_STRING, ASCII_STRLEN}
};

const USHORT    NUM_SDP_CHARACTER_SET_ENTRIES = sizeof(SDP_CHARACTER_SET_TABLE)/sizeof(SDP_CHARACTER_SET_ENTRY);




inline BOOL
IsLegalCharacterSet(
    IN      SDP_CHARACTER_SET   CharacterSet,
    IN  OUT UINT                *CodePage   = NULL
    )
{
    switch(CharacterSet)
    {
    case CS_ASCII:
        {
            if ( NULL != CodePage )
                *CodePage = CP_ACP;
        }

        break;

    case CS_UTF7:
        {
            if ( NULL != CodePage )
                *CodePage = CP_UTF7;
        }

        break;

    case CS_UTF8:
        {            
            if ( NULL != CodePage )
                *CodePage = CP_UTF8;
        }

        break;

    default:
        {
            return FALSE;
        }
    }

    return TRUE;
}


#endif // __SDP_CHARACTER_SET__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpconn.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpconn.h

Abstract:


Author:

*/

#ifndef __SDP_CONNECTION__
#define __SDP_CONNECTION__

#include "sdpcommo.h"
#include "sdpbstrl.h"
#include "sdpgen.h"




class _DllDecl SDP_CONNECTION : public SDP_VALUE
{
public:

    SDP_CONNECTION();

    inline SDP_LIMITED_CHAR_STRING &GetNetworkType();

    inline SDP_LIMITED_CHAR_STRING &GetAddressType();

    inline SDP_ADDRESS  &GetStartAddress();

    inline SDP_ULONG    &GetNumAddresses();

    inline SDP_BYTE     &GetTtl();

    HRESULT SetConnection(
        IN      BSTR    StartAddress,
        IN      ULONG   NumAddresses,
        IN      BYTE    Ttl
        );

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void InternalReset();

private:

    SDP_LIMITED_CHAR_STRING     m_NetworkType;
    SDP_LIMITED_CHAR_STRING     m_AddressType;
    SDP_ADDRESS                 m_StartAddress;
    SDP_ULONG                   m_NumAddresses;
    SDP_BYTE                    m_Ttl;
};




inline SDP_LIMITED_CHAR_STRING &
SDP_CONNECTION::GetNetworkType(
    )
{
    return m_NetworkType;
}


inline SDP_LIMITED_CHAR_STRING &
SDP_CONNECTION::GetAddressType(
    )
{
    return m_AddressType;
}

inline SDP_ADDRESS  &
SDP_CONNECTION::GetStartAddress(
    )
{
    return m_StartAddress;
}


inline SDP_ULONG    &
SDP_CONNECTION::GetNumAddresses(
    )
{
    return m_NumAddresses;
}


inline SDP_BYTE     &
SDP_CONNECTION::GetTtl(
    )
{
    return m_Ttl;
}


#endif // __SDP_CONNECTION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpenc.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpenc.h
    
Abstract:


Author:

*/

#ifndef __SDP_ENCRYPTION_KEY__
#define __SDP_ENCRYPTION_KEY__

#include "sdpcommo.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"


class _DllDecl SDP_ENCRYPTION_KEY : public SDP_VALUE
{
public:

    SDP_ENCRYPTION_KEY();

    inline SDP_OPTIONAL_BSTRING  &GetKeyType();

    inline SDP_OPTIONAL_BSTRING  &GetKeyData();

    HRESULT SetKey(
        IN      BSTR    KeyType,
        IN      BSTR    *KeyData
        );

protected:

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );
	
	virtual void InternalReset();

private:

    SDP_OPTIONAL_BSTRING m_KeyType;
    SDP_OPTIONAL_BSTRING m_KeyData;
};



inline SDP_OPTIONAL_BSTRING &
SDP_ENCRYPTION_KEY::GetKeyType(
    )
{
    return m_KeyType;
}


inline SDP_OPTIONAL_BSTRING &
SDP_ENCRYPTION_KEY::GetKeyData(
    )
{
    return m_KeyData;
}


#endif // __SDP_ENCRYPTION_KEY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpfld.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_FIELD__
#define __SDP_FIELD__

#include <strstrea.h>
#include "sdpcommo.h"
#include "sdpdef.h"
#include "sdpgen.h"



class _DllDecl SDP_FIELD
{
public:

    virtual  void    Reset()            = 0;

    virtual  BOOL    IsValid() const    = 0;

    virtual  BOOL    IsModified() const = 0;

    virtual  void    IsModified(
        IN          BOOL    ModifiedFlag
        ) = 0;

    virtual  DWORD   GetCharacterStringSize() = 0;

    virtual  BOOL    PrintField(
            OUT     ostrstream  &OutputStream
        ) = 0;

    virtual BOOL      ParseToken(
        IN          CHAR        *Token
        ) = 0;

    virtual ~SDP_FIELD()
    {}
};


class _DllDecl SDP_SINGLE_FIELD : public SDP_FIELD
{
public:

    inline SDP_SINGLE_FIELD(
        IN          DWORD   BufferSize,
        IN          CHAR    *Buffer
        );

	// SDP_VALUE instances use an inline Reset method which calls a virtual InternalReset method.
	// this is possible because unlike the SDP_FIELD inheritance tree, SDP_VALUE and SDP_VALUE_LIST
	// do not share a common base class. This combined with the fact that the SDP_VALUE inheriance 
	// tree is quite shallow and has fewer instances (than SDP_FIELD) makes the scheme appropriate
	// it as it reduces the number of Reset related calls to 1 and the inline code is not repeated
	// to often.
	// For the SDP_FIELD inheritance tree, the appropriate Reset calling sequence is a series of
	// Reset calls starting with the top most virtual Reset body followed by the
	// base class Reset method (recursively). This is appropriate because, the number of calls
	// would not decrease if the InternalReset scheme is adopted (virtual Reset()) and that the
	// inheritance tree is much deeper
    virtual  void    Reset();

    // the IsValid and IsModified methods are virtual only because the base
    // class is virtual. It is required that none of the classes derived
    // from this class over-ride these methods.
    virtual  BOOL    IsValid() const;

    virtual  BOOL    IsModified() const;

    virtual  void    IsModified(
        IN          BOOL    ModifiedFlag
        );

    virtual  DWORD   GetCharacterStringSize();

    virtual  BOOL    PrintField(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL      ParseToken(
        IN          CHAR        *Token
        );

    virtual ~SDP_SINGLE_FIELD()
    {}

protected:

    // flag - tells whether the type value is valid (parsed in / added later etc.)
    BOOL    m_IsValid;

    BOOL    m_IsModified;
    
	// this should be const, but cannot be because ostrstream does not take 
	// const length for parameter
    DWORD   m_PrintBufferSize;
    CHAR    *m_PrintBuffer;
    DWORD   m_PrintLength;


    void    IsValid(
        IN          BOOL    ValidFlag
        );

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyField(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL    InternalParseToken(
        IN          CHAR        *Token
        ) = 0;

    inline void     RemoveWhiteSpaces(
        IN  OUT     CHAR    *&Token
        );

    inline BOOL     IsWhiteSpaces(
        IN          CHAR    *Token,
        IN          DWORD   ErrorCode
        );
    
    virtual BOOL    PrintData(
            OUT     ostrstream  &OutputStream
        ) = 0;
};



inline 
SDP_SINGLE_FIELD::SDP_SINGLE_FIELD(
    IN          DWORD   BufferSize,
    IN          CHAR    *Buffer
    )
    : m_IsValid(FALSE),
      m_IsModified(FALSE),
      m_PrintBufferSize(BufferSize),
      m_PrintBuffer(Buffer),
      m_PrintLength(0)
{
}



inline void 
SDP_SINGLE_FIELD::RemoveWhiteSpaces(
    IN  OUT     CHAR    *&Token
    )
{
    // use of line terminator ensures that the token ptr cannot be null
    ASSERT(NULL != Token);

    while ( EOS != *Token )
    {
        if ( (CHAR_BLANK == *Token) 
            || (CHAR_TAB == *Token)
            || (CHAR_RETURN == *Token) )
        {
            Token++;
        }
        else
        {
            return;
        }
    }
}


inline BOOL 
SDP_SINGLE_FIELD::IsWhiteSpaces(
    IN          CHAR    *Token,
    IN          DWORD   ErrorCode
    )
{
    while ( EOS != *Token )
    {
        if ( (CHAR_BLANK == *Token) 
            || (CHAR_TAB == *Token)
            || (CHAR_RETURN == *Token) )
        {
            Token++;
        }
        else
        {
            SetLastError(ErrorCode);
            return FALSE;
        }
    }

    return TRUE;
}



class _DllDecl SDP_FIELD_LIST : public SDP_POINTER_ARRAY<SDP_FIELD *>,
                                public SDP_FIELD
{
public:

    inline          SDP_FIELD_LIST(
        IN      CHAR    SeparatorChar = CHAR_BLANK
        );

    virtual void    Reset();

    virtual BOOL    IsValid() const;

    virtual BOOL    IsModified() const;

    virtual void    IsModified(
        IN      BOOL    ModifiedFlag
        );

    virtual DWORD   GetCharacterStringSize();

    virtual BOOL    PrintField(
            OUT ostrstream  &OutputStream
        );

    virtual BOOL    ParseToken(
        IN      CHAR    *Token
        );

protected:

    const   CHAR    m_SeparatorChar;

    virtual SDP_FIELD   *CreateElement() = 0;
};


inline 
SDP_FIELD_LIST::SDP_FIELD_LIST(
    IN      CHAR    SeparatorChar
    )
    : m_SeparatorChar(SeparatorChar)
{
}



// for reading unsigned integral base type values largest of which may
// be a ULONG
// no Reset method to set the value member to 0 again (as its not really required and it saves 
// one call per instance)
template <class T>
class _DllDecl SDP_UNSIGNED_INTEGRAL_BASE_TYPE : public SDP_SINGLE_FIELD
{
public:

    inline SDP_UNSIGNED_INTEGRAL_BASE_TYPE();

    inline  HRESULT GetValue(
        IN  T   &Value
        );

    inline  T       GetValue() const;

    inline  void    SetValue(
        IN  T   Value
        );

    inline  void    SetValueAndFlag(
        IN  T   Value
        );

protected:

    T       m_Value;

    CHAR    m_NumericalValueBuffer[25];
    
    virtual BOOL    InternalParseToken(
        IN   CHAR    *Token
        );

    
    virtual BOOL    PrintData(
            OUT ostrstream  &OutputStream
        );
};


template <class T>
inline 
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::SDP_UNSIGNED_INTEGRAL_BASE_TYPE(
    )
    : SDP_SINGLE_FIELD(sizeof(m_NumericalValueBuffer), m_NumericalValueBuffer),
      m_Value(0)
{
}


template <class T>
inline  HRESULT 
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::GetValue(
    IN  T   &Value
    )
{
    if ( !IsValid() )
    {
        return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
    }

    Value = m_Value;
    return S_OK;
}


template <class T>
inline T   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::GetValue(
    ) const
{
    return m_Value;
}


template <class T>
inline void   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::SetValue(
    IN  T   Value
    )
{
    m_Value = Value;
}


template <class T>
inline void   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::SetValueAndFlag(
    IN  T   Value
    )
{
    m_Value = Value;
    IsValid(TRUE);
    IsModified(TRUE);
}



template <class T>
inline BOOL   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::InternalParseToken(
    IN   CHAR    *Token
    )
{
    CHAR    *Current = Token;

    // remove preceding white spaces
    RemoveWhiteSpaces(Current);

    // check that the first character is a digit (to weed out -ve values)
    if ( !isdigit(*Current) )
    {
        SetLastError(SDP_INVALID_NUMERICAL_VALUE);
        return FALSE;
    }
        
    // since T is UNSIGNED, max value will contain all 1's - the
    // maximum value it can store
    const T MaxValue = -1;

    // ensure that T is unsigned
    // since such an error will be detected during debugging, no need
    // for if ( ! ... ) code
    ASSERT(MaxValue > 0);

    CHAR    *RestOfToken = NULL;
    ULONG   TokenValue   = strtoul(Current, &RestOfToken, 10);

    if ( (ULONG_MAX == TokenValue) || (MaxValue < TokenValue) )
    {
        SetLastError(SDP_INVALID_NUMERICAL_VALUE);
        return FALSE;
    }

    // ensure that rest of the string is white spaces
    if ( !IsWhiteSpaces(RestOfToken, SDP_INVALID_NUMERICAL_VALUE) )
    {
        return FALSE;
    }

    m_Value = (T)TokenValue;
    return TRUE;
}       


template <class T>
inline BOOL   
SDP_UNSIGNED_INTEGRAL_BASE_TYPE<T>::PrintData(
        OUT ostrstream  &OutputStream
    )
{
    OutputStream << (ULONG)m_Value;
    if ( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    return TRUE;
}


class _DllDecl SDP_ULONG : public SDP_UNSIGNED_INTEGRAL_BASE_TYPE<ULONG>
{
};


class _DllDecl SDP_USHORT : public SDP_UNSIGNED_INTEGRAL_BASE_TYPE<USHORT>
{
};


class _DllDecl SDP_BYTE : public SDP_UNSIGNED_INTEGRAL_BASE_TYPE<BYTE>
{
};



class SDP_BYTE_LIST : public SDP_FIELD_LIST
{
public:
    
    virtual SDP_FIELD   *CreateElement()
    {
        SDP_BYTE *SdpByte;

        try
        {
            SdpByte = new SDP_BYTE();
        }
        catch(...)
        {
            SdpByte = NULL;
        }

        return SdpByte;
    }
};



class SDP_ULONG_LIST : public SDP_FIELD_LIST
{
public:
    
    virtual SDP_FIELD   *CreateElement()
    {
        SDP_ULONG *SdpULong;

        try
        {
            SdpULong = new SDP_ULONG();
        }
        catch(...)
        {
            SdpULong = NULL;
        }

        return SdpULong;
    }
};


#endif // __SDP_FIELD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpcstrl.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpcstrl.h

Abstract:


Author:

*/

#ifndef __SDP_CHAR_STRING__
#define __SDP_CHAR_STRING__

#include "sdpcommo.h"
#include "sdpfld.h"
#include "sdpval.h"





class _DllDecl SDP_CHAR_STRING : public SDP_SINGLE_FIELD
{
public:

    inline          SDP_CHAR_STRING();

	virtual void	Reset();

    inline  BOOL    ByReference() const;

    inline  CHAR    *GetCharacterString() const;

    inline  CHAR    *GetModifiableCharString();

    inline	BOOL	SetCharacterStringByReference(
        IN			CHAR    *CharacterStringByReference,
		IN			DWORD	Length = 0
        );

	inline	BOOL	SetCharacterStringByCopy(
		IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length = 0
		);

    inline  DWORD   GetLength() const;

    virtual         ~SDP_CHAR_STRING();

protected:
    
    virtual BOOL    InternalParseToken(
        IN          CHAR    *Token
        );

    inline BOOL     ReAllocCharacterString(
        IN          UINT    BufferSize
        );

    virtual BOOL	InternalSetCharStrByRef(
        IN          CHAR    *CharacterStringByReference,
		IN			DWORD	Length
        );

    virtual BOOL	InternalSetCharStrByCopy(
        IN	const	CHAR    *CharacterStringByCopy,
		IN			DWORD	Length
        );

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyField(
            OUT     ostrstream  &OutputStream
    );
    
    // this method should not be used
    virtual BOOL    PrintData(
            OUT     ostrstream  &OutputStream
        )
    {
        ASSERT(FALSE);
        return FALSE;
    }

private:

    DWORD   m_CharacterStringLength;
    CHAR    *m_CharacterString;

    DWORD   m_LengthByReference;
    CHAR    *m_CharacterStringByReference;

    DWORD   m_BytesAllocated;
};


inline 
SDP_CHAR_STRING::SDP_CHAR_STRING(
    )
    : SDP_SINGLE_FIELD(0, NULL),   // no buffer used (custom PrintField)
      m_CharacterString(NULL),
      m_CharacterStringLength(0),
      m_LengthByReference(0),
      m_CharacterStringByReference(NULL),
      m_BytesAllocated(0)
{}

      
inline  BOOL    
SDP_CHAR_STRING::ByReference(
    ) const
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    return (NULL == m_CharacterString);
}


inline CHAR *
SDP_CHAR_STRING::GetCharacterString(
    ) const
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    return ((TRUE == ByReference())? m_CharacterStringByReference : m_CharacterString);
}


inline  CHAR    *
SDP_CHAR_STRING::GetModifiableCharString(
    )
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    // the reference string is not modifiable
    ASSERT(FALSE == ByReference());
    
    return ((TRUE == ByReference())? NULL : m_CharacterString);
}
    
inline DWORD 
SDP_CHAR_STRING::GetLength(
    ) const
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    return ((TRUE == ByReference())? m_LengthByReference : m_CharacterStringLength);
}



inline BOOL    
SDP_CHAR_STRING::ReAllocCharacterString(
    IN      UINT    BufferSize
    )
{
    CHAR    *NewCharacterString;

    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    ASSERT(0 != BufferSize);

    // if the length of the token (not including the end of string) is not less than
    // the number of bytes allocated, release the bytes and allocate again
    if ( (BufferSize - 1) >= m_BytesAllocated )
    {
        try
        {
            NewCharacterString   = new CHAR[BufferSize];
        }
        catch(...)
        {
            NewCharacterString   = NULL;
        }

        if ( NULL == NewCharacterString )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        // If there is an old character string, delete it
        if ( NULL != m_CharacterString )
        {
            delete m_CharacterString;
        }

        m_BytesAllocated    = BufferSize;
        m_CharacterString   = NewCharacterString;
    }

    m_CharacterStringLength = BufferSize - 1;

    // If there was a reference to another string, remove it
    if ( ByReference() )
    {
        m_LengthByReference = 0;
        m_CharacterStringByReference = NULL;
    }

    return TRUE;
}


inline BOOL    
SDP_CHAR_STRING::SetCharacterStringByReference(
    IN          CHAR    *CharacterStringByReference,
	IN			DWORD	Length
    )
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    ASSERT(NULL != CharacterStringByReference);
    if ( NULL == CharacterStringByReference )
    {
        SetLastError(SDP_INVALID_VALUE);
        return FALSE;
    }

    if ( !InternalSetCharStrByRef(
			CharacterStringByReference, 
			(0==Length)? strlen(CharacterStringByReference): Length
			) )
    {
        return FALSE;
    }

    IsValid(TRUE);
    IsModified(TRUE);
    return TRUE;
}



inline BOOL    
SDP_CHAR_STRING::SetCharacterStringByCopy(
    IN	const	CHAR    *CharacterStringByCopy,
	IN			DWORD	Length
    )
{
    // check that both the char string and the char string by ref are not null
    // at the same time
    ASSERT((NULL == m_CharacterString) != (NULL == m_CharacterStringByReference));

    ASSERT(NULL != CharacterStringByCopy);
    if ( NULL == CharacterStringByCopy )
    {
        SetLastError(SDP_INVALID_VALUE);
        return FALSE;
    }

    if ( !InternalSetCharStrByCopy(
			CharacterStringByCopy, 
			(0==Length)? strlen(CharacterStringByCopy): Length
			) )
    {
        return FALSE;
    }

    IsValid(TRUE);
    IsModified(TRUE);
    return TRUE;
}


class _DllDecl SDP_STRING_LINE : public SDP_VALUE
{
public:

    inline SDP_STRING_LINE(
        IN      const   DWORD       ErrorCode,
        IN      const   CHAR        *TypeString,
        IN              SDP_FIELD   &ParseField
        );

    virtual HRESULT     GetBstrCopy(IN BSTR *Bstr) = 0;

    virtual HRESULT     SetBstr(IN BSTR Bstr) = 0;

protected:

    SDP_FIELD   &m_ParseField;
    
    virtual BOOL        InternalParseLine(
        IN  OUT         CHAR    *&Line
        );

    inline  SDP_FIELD   &GetParseField();
};


inline 
SDP_STRING_LINE::SDP_STRING_LINE(
    IN      const   DWORD       ErrorCode,
    IN      const   CHAR        *TypeString,
    IN              SDP_FIELD   &ParseField
    )
    : SDP_VALUE(ErrorCode, TypeString),
      m_ParseField(ParseField)
{
}


inline SDP_FIELD &
SDP_STRING_LINE::GetParseField(
    )
{
    return m_ParseField;
}



#endif // __SDP_CHAR_STRING__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpgen.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_GENERAL__
#define __SDP_GENERAL__

#include "sdpcommo.h"
#include <stdlib.h>     // for strtoul()
#include <ctype.h>      // for isdigit()

#include "sdpdef.h"


template <class T>
class _DllDecl SDP_ARRAY : public CArray<T, T>
{
public:

    virtual void Reset()
    {
        RemoveAll();
        return;
    }
};


class _DllDecl BSTR_ARRAY : public SDP_ARRAY<BSTR>
{
};


class _DllDecl CHAR_ARRAY : public SDP_ARRAY<CHAR>
{
};


class _DllDecl BYTE_ARRAY : public SDP_ARRAY<BYTE>
{
};


class _DllDecl LONG_ARRAY : public SDP_ARRAY<LONG>
{
};


class _DllDecl ULONG_ARRAY : public SDP_ARRAY<ULONG>
{
};



template <class T_PTR>
class _DllDecl SDP_POINTER_ARRAY : public SDP_ARRAY<T_PTR>
{
public:

    inline SDP_POINTER_ARRAY();

    inline void ClearDestroyMembersFlag(
        );

    virtual void Reset();

    virtual ~SDP_POINTER_ARRAY()
    {
        Reset();
    }

protected:

    BOOL    m_DestroyMembers;
};

template <class T_PTR>
inline
SDP_POINTER_ARRAY<T_PTR>::SDP_POINTER_ARRAY(
	)
    : m_DestroyMembers(TRUE)
{
}


template <class T_PTR>
inline void
SDP_POINTER_ARRAY<T_PTR>::ClearDestroyMembersFlag(
    )
{
    m_DestroyMembers = FALSE;
}


template <class T_PTR>
/* virtual */ void
SDP_POINTER_ARRAY<T_PTR>::Reset(
	)
{
    // if members must be destroyed on destruction, delete each of them
    if ( m_DestroyMembers )
    {
	    int Size = (int) GetSize();

	    if ( 0 < Size )
	    {
		    for ( int i=0; i < Size; i++ )
		    {
			    T_PTR Member = GetAt(i);

			    ASSERT(NULL != Member);
			    if ( NULL == Member )
			    {
				    SetLastError(SDP_INTERNAL_ERROR);
				    return;
			    }

			    delete Member;
		    }
	    }
    }

	SDP_ARRAY<T_PTR>::Reset();
	return;
}


class _DllDecl LINE_TERMINATOR
{
public:

    inline LINE_TERMINATOR(
        IN CHAR *Start,
        IN const CHAR Replacement
        );

    inline IsLegal() const;

    inline DWORD GetLength() const;

    inline ~LINE_TERMINATOR();

private:

    CHAR    *m_Start;
    DWORD   m_Length;

    CHAR    m_Replacement;
};



inline
LINE_TERMINATOR::LINE_TERMINATOR(
    IN          CHAR    *Start,
    IN  const   CHAR    Replacement
    )
    : m_Start(Start),
      m_Replacement(Replacement)
{
    if ( NULL != Start )
    {
        m_Length = strlen(m_Start);
    }
}



inline
LINE_TERMINATOR::IsLegal(
    ) const
{
    return (NULL == m_Start)? FALSE : TRUE;
}



inline DWORD
LINE_TERMINATOR::GetLength(
    ) const
{
    return m_Length;
}


inline
LINE_TERMINATOR::~LINE_TERMINATOR(
    )
{
    if ( IsLegal() )
    {
        m_Start[m_Length] = m_Replacement;
    }
}


// Isolates tokens by searching for one of the separators
// and returns the first separator thats found
CHAR    *
GetToken(
    IN              CHAR    *String,
    IN              BYTE    NumSeparators,
    IN      const   CHAR    *SeparatorChars,
        OUT         CHAR    &Separator
    );


#endif // __SDP_GENERAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpmedia.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_MEDIA__
#define __SDP_MEDIA__

#include "sdpcommo.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"
#include "sdpconn.h"
#include "sdpbw.h"
#include "sdpenc.h"
#include "sdpatt.h"
#include "sdpval.h"

#include "sdpsobst.h"


class _DllDecl SDP_FORMAT_CODE_LIST :
    public SDP_OPT_BSTRING_LIST,
    public SDP_OPT_BSTRING_SAFEARRAY
{
public:

    inline SDP_FORMAT_CODE_LIST();
};


inline 
SDP_FORMAT_CODE_LIST::SDP_FORMAT_CODE_LIST(
    )
    : SDP_OPT_BSTRING_SAFEARRAY(*((SDP_OPT_BSTRING_LIST *)this))
{
}


class _DllDecl SDP_MEDIA : public SDP_VALUE
{
public:

    SDP_MEDIA();

    inline SDP_OPTIONAL_BSTRING     &GetName();

    inline SDP_REQD_BSTRING_LINE    &GetTitle();

    inline SDP_USHORT               &GetStartPort();

    inline SDP_USHORT               &GetNumPorts();

    inline SDP_OPTIONAL_BSTRING     &GetProtocol();

    inline SDP_FORMAT_CODE_LIST     &GetFormatCodeList();

    inline SDP_CONNECTION           &GetConnection();

    inline SDP_BANDWIDTH            &GetBandwidth();

    inline SDP_ENCRYPTION_KEY       &GetEncryptionKey();

    inline SDP_ATTRIBUTE_LIST       &GetAttributeList();

	HRESULT SetPortInfo(
		IN	USHORT	StartPort, 
		IN	USHORT	NumPorts
		);


protected:

    SDP_OPTIONAL_BSTRING    m_Name;
    SDP_USHORT              m_StartPort;
    SDP_USHORT              m_NumPorts;
    SDP_OPTIONAL_BSTRING    m_TransportProtocol;
    SDP_FORMAT_CODE_LIST    m_FormatCodeList;    
    SDP_REQD_BSTRING_LINE   m_Title;
    SDP_CONNECTION          m_Connection;
    SDP_BANDWIDTH           m_Bandwidth;
    SDP_ENCRYPTION_KEY      m_EncryptionKey;
    SDP_ATTRIBUTE_LIST      m_AttributeList;

    virtual void			InternalReset();

    virtual BOOL            CalcIsModified() const;

    virtual DWORD           CalcCharacterStringSize();

    virtual BOOL            CopyValue(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL            InternalParseLine(
        IN  OUT         CHAR    *&Line
        );

    virtual BOOL GetField(
            OUT     SDP_FIELD   *&Field,
            OUT     BOOL        &AddToArray
        );
};


inline SDP_OPTIONAL_BSTRING  &
SDP_MEDIA::GetName(
    )
{
    return m_Name;
}


inline SDP_REQD_BSTRING_LINE &
SDP_MEDIA::GetTitle(
    )
{
    return m_Title;
}


inline SDP_USHORT   &
SDP_MEDIA::GetStartPort(
    )
{
    return m_StartPort;
}


inline SDP_USHORT   &
SDP_MEDIA::GetNumPorts(
    )
{
    return m_NumPorts;
}


inline SDP_OPTIONAL_BSTRING  &
SDP_MEDIA::GetProtocol(
    )
{
    return m_TransportProtocol;
}


inline SDP_FORMAT_CODE_LIST    &
SDP_MEDIA::GetFormatCodeList(
    )
{
    return m_FormatCodeList;
}


inline SDP_CONNECTION   &
SDP_MEDIA::GetConnection(
    )
{
    return m_Connection;
}


inline SDP_BANDWIDTH    &
SDP_MEDIA::GetBandwidth(
    )
{
    return m_Bandwidth;
}


inline SDP_ENCRYPTION_KEY   &
SDP_MEDIA::GetEncryptionKey(
    )
{
    return m_EncryptionKey;
}


inline SDP_ATTRIBUTE_LIST &
SDP_MEDIA::GetAttributeList(
    )
{
    return m_AttributeList;
}



class _DllDecl SDP_MEDIA_LIST : public SDP_VALUE_LIST
{
public:

    inline SDP_MEDIA_LIST();

    inline void SetCharacterSet(
        IN  SDP_CHARACTER_SET CharacterSet
        );

protected:

    SDP_CHARACTER_SET   m_CharacterSet;

    virtual SDP_VALUE   *CreateElement();
};



inline
SDP_MEDIA_LIST::SDP_MEDIA_LIST(
    )
    : m_CharacterSet(CS_ASCII)  
{
}


inline void 
SDP_MEDIA_LIST::SetCharacterSet(
    IN  SDP_CHARACTER_SET CharacterSet
    )
{
    m_CharacterSet = CharacterSet;
}


#endif // __SDP_MEDIA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdporigi.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ORIGIN__
#define __SDP_ORIGIN__

#include "sdpcommo.h"
#include "sdpgen.h"
#include "sdpfld.h"
#include "sdpval.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"


class _DllDecl SDP_ORIGIN : public SDP_VALUE
{
public:

    SDP_ORIGIN();

    inline SDP_BSTRING              &GetUserName();

    inline SDP_ULONG                &GetSessionId();

    inline SDP_ULONG                &GetSessionVersion();

    inline SDP_LIMITED_CHAR_STRING  &GetNetworkType();

    inline SDP_LIMITED_CHAR_STRING  &GetAddressType();

    inline SDP_BSTRING              &GetAddress();

protected:

    virtual BOOL GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    );

	virtual void InternalReset();

private:

    SDP_BSTRING             m_UserName;
    SDP_ULONG               m_SessionId;
    SDP_ULONG               m_SessionVersion;
    SDP_LIMITED_CHAR_STRING m_NetworkType;
    SDP_LIMITED_CHAR_STRING m_AddressType;
    SDP_BSTRING             m_Address;   
};





inline SDP_BSTRING  &
SDP_ORIGIN::GetUserName(
    )
{
    return m_UserName;
}

inline SDP_ULONG    &
SDP_ORIGIN::GetSessionId(
    )
{
    return m_SessionId;
}

inline SDP_ULONG    &
SDP_ORIGIN::GetSessionVersion(
    )
{
    return m_SessionVersion;
}

inline SDP_LIMITED_CHAR_STRING &
SDP_ORIGIN::GetNetworkType(
    )
{
    return m_NetworkType;
}


inline SDP_LIMITED_CHAR_STRING &
SDP_ORIGIN::GetAddressType(
    )
{
    return m_AddressType;
}


inline SDP_BSTRING      &
SDP_ORIGIN::GetAddress(
    )
{
    return m_Address;
}




#endif // __SDP_ORIGIN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpsadj.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ADJUSTMENT_SAFEARRAY__
#define __SDP_ADJUSTMENT_SAFEARRAY__


#include "sdpcommo.h"

#include "sdpstp.h"
#include "sdpsuit.h"
#include "sdpfld.h"


class _DllDecl SDP_ULONG_SAFEARRAY : public SDP_UITYPE_SAFEARRAY<ULONG, SDP_ULONG, SDP_ULONG_LIST>
{
public:

    inline SDP_ULONG_SAFEARRAY(
        IN      SDP_ULONG_LIST  &SdpUlongList
        );
};



inline 
SDP_ULONG_SAFEARRAY::SDP_ULONG_SAFEARRAY(
    IN      SDP_ULONG_LIST  &SdpUlongList
    )
    : SDP_UITYPE_SAFEARRAY<ULONG, SDP_ULONG, SDP_ULONG_LIST>(SdpUlongList)
{
    m_VarType[0] = VT_UI4;
}



class _DllDecl SDP_ADJUSTMENT_SAFEARRAY : 
    protected SDP_TIME_PERIOD_SAFEARRAY,
    protected SDP_ULONG_SAFEARRAY
{
public:

    SDP_ADJUSTMENT_SAFEARRAY(
        IN      SDP_ADJUSTMENT  &SdpAdjustment
        );

    HRESULT GetSafeArray(
            OUT VARIANT   *AdjustmentTimesVariant,
            OUT VARIANT   *IsCompactVariant,
            OUT VARIANT   *UnitVariant,
            OUT VARIANT   *CompactValueVariant,
            OUT VARIANT   *PeriodValueVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT   &AdjustmentTimesVariant,
        IN      VARIANT   &IsCompactVariant,
        IN      VARIANT   &UnitVariant,
        IN      VARIANT   &CompactValueVariant,
        IN      VARIANT   &PeriodValueArray
        );

protected:

    VARTYPE         m_VarType[5];

    virtual BOOL GetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        );

    virtual BOOL SetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        );

    virtual void RemoveExcessElements(
        IN      ULONG   StartIndex
        );
};



inline HRESULT 
SDP_ADJUSTMENT_SAFEARRAY::SetSafeArray(
	IN      VARIANT   &AdjustmentTimesVariant,
	IN      VARIANT   &IsCompactVariant,
	IN      VARIANT   &UnitVariant,
	IN      VARIANT   &CompactValueVariant,
	IN      VARIANT   &PeriodValueVariant
    )
{
    VARIANT   *VariantArray[] = {
            &IsCompactVariant, &UnitVariant, 
            &CompactValueVariant, &PeriodValueVariant
            };

    return SDP_ULONG_SAFEARRAY::SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif // __SDP_ADJUSTMENT_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpsadt.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ADDRESS_TEXT_SAFEARRAY__
#define __SDP_ADDRESS_TEXT_SAFEARRAY__

#include "sdpcommo.h"

#include "sdpsarr.h"


class _DllDecl SDP_ADDRESS_TEXT_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_ADDRESS_TEXT, SDP_ADDRESS_TEXT_LIST>
{
public:

    inline SDP_ADDRESS_TEXT_SAFEARRAY(
        IN      SDP_ADDRESS_TEXT_LIST    &SdpAddressTextList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*AddressVariant,
            OUT VARIANT	*TextVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&AddressVariant,
        IN      VARIANT	&TextVariant
        );

protected:

    VARTYPE m_VarType[2];

    virtual BOOL Get(
        IN      SDP_ADDRESS_TEXT    &ListMember,
        IN      ULONG               NumEntries,
        IN      void                **Element,
            OUT HRESULT             &HResult
        );

    virtual BOOL Set(
        IN      SDP_ADDRESS_TEXT    &ListMember,
        IN      ULONG               NumEntries,
        IN      void                ***Element,
            OUT HRESULT             &HResult
        );
};



inline 
SDP_ADDRESS_TEXT_SAFEARRAY::SDP_ADDRESS_TEXT_SAFEARRAY(
        IN      SDP_ADDRESS_TEXT_LIST    &SdpAddressTextList
        )
    : SDP_SAFEARRAY_WRAP_EX<SDP_ADDRESS_TEXT, SDP_ADDRESS_TEXT_LIST>(SdpAddressTextList)
{
    m_VarType[0] = VT_BSTR;
    m_VarType[1] = VT_BSTR;
}




inline HRESULT 
SDP_ADDRESS_TEXT_SAFEARRAY::SetSafeArray(
    IN      VARIANT   &AddressVariant,
    IN      VARIANT   &TextVariant
    )
{
    VARIANT   *VariantArray[] = {&AddressVariant, &TextVariant};

    return SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif   // __SDP_ADDRESS_TEXT_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpsatt.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_ATTRIBUTE_SAFEARRAY__
#define __SDP_ATTRIBUTE_SAFEARRAY__


#include "sdpcommo.h"

#include "sdpsarr.h"

class _DllDecl SDP_ATTRIBUTE_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_CHAR_STRING_LINE, SDP_ATTRIBUTE_LIST>
{
public:

    inline SDP_ATTRIBUTE_SAFEARRAY(
        IN      SDP_ATTRIBUTE_LIST    &SdpAttributeList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*Variant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&Variant
        );

protected:

    VARTYPE m_VarType[1];

    virtual BOOL Get(
        IN      SDP_CHAR_STRING_LINE    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    **Element,
            OUT HRESULT &HResult
        );

    virtual BOOL Set(
        IN      SDP_CHAR_STRING_LINE    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    ***Element,
            OUT HRESULT                 &HResult
        );
};



inline 
SDP_ATTRIBUTE_SAFEARRAY::SDP_ATTRIBUTE_SAFEARRAY(
    IN      SDP_ATTRIBUTE_LIST    &SdpAttributeList
    )
    : SDP_SAFEARRAY_WRAP_EX<SDP_CHAR_STRING_LINE, SDP_ATTRIBUTE_LIST>(SdpAttributeList)
{
    m_VarType[0] = VT_BSTR;
}


inline HRESULT 
SDP_ATTRIBUTE_SAFEARRAY::SetSafeArray(
    IN      VARIANT   &Variant
    )
{
	VARIANT *VariantArray = &Variant;
    return SDP_SAFEARRAY_WRAP::SetSafeArrays(1, m_VarType, &VariantArray);
}

#endif  //  __SDP_ATTRIBUTE_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpsobst.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_OPT_BSTRING_SAFEARRAY__
#define __SDP_OPT_BSTRING_SAFEARRAY__

#include "sdpcommo.h"

#include "sdpsarr.h"


class SDP_OPT_BSTRING_LIST : public SDP_FIELD_LIST
{
public:
    
    virtual SDP_FIELD   *CreateElement();
};


class _DllDecl SDP_OPT_BSTRING_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_OPTIONAL_BSTRING, SDP_OPT_BSTRING_LIST>
{
public:

    inline SDP_OPT_BSTRING_SAFEARRAY(
        IN      SDP_OPT_BSTRING_LIST    &SdpOptBstringList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*OptBstringVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&OptBstringVariant
        );

protected:

    VARTYPE m_VarType[1];

    virtual BOOL Get(
        IN      SDP_OPTIONAL_BSTRING    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    **Element,
            OUT HRESULT                 &HResult
        );

    virtual BOOL Set(
        IN      SDP_OPTIONAL_BSTRING    &ListMember,
        IN      ULONG                   NumEntries,
        IN      void                    ***Element,
            OUT HRESULT                 &HResult
        );
};



inline 
SDP_OPT_BSTRING_SAFEARRAY::SDP_OPT_BSTRING_SAFEARRAY(
        IN      SDP_OPT_BSTRING_LIST    &SdpOptBstringList
        )
    : SDP_SAFEARRAY_WRAP_EX<SDP_OPTIONAL_BSTRING, SDP_OPT_BSTRING_LIST>(SdpOptBstringList)
{
    m_VarType[0] = VT_BSTR;
}




inline HRESULT 
SDP_OPT_BSTRING_SAFEARRAY::SetSafeArray(
    IN      VARIANT   &OptBstringVariant
    )
{
    VARIANT   *VariantArray[] = {&OptBstringVariant};

    return SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif   // __SDP_OPT_BSTRING_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpstp.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_TIME_PERIOD_SAFEARRAY__
#define __SDP_TIME_PERIOD_SAFEARRAY__


#include "sdpcommo.h"

#include "sdpsarr.h"


class _DllDecl SDP_TIME_PERIOD_SAFEARRAY : 
    protected SDP_SAFEARRAY_WRAP_EX<SDP_TIME_PERIOD, SDP_TIME_PERIOD_LIST>

{
public:

    inline SDP_TIME_PERIOD_SAFEARRAY(
        IN      SDP_TIME_PERIOD_LIST    &SdpTimePeriodList
        );

    HRESULT GetSafeArray(
            OUT VARIANT	*IsCompactVariant,
            OUT VARIANT	*UnitVariant,
            OUT VARIANT	*CompactValueVariant,
            OUT VARIANT	*PeriodValueVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT	&IsCompactVariant,
        IN      VARIANT	&UnitVariant,
        IN      VARIANT	&CompactValueVariant,
        IN      VARIANT	&PeriodValueVariant
        );

protected:

    VARTYPE         m_VarType[4];
    VARIANT_BOOL    m_IsCompact;
    CHAR            m_Unit;
    LONG            m_CompactValue;
    LONG            m_PeriodValue;

    virtual BOOL Get(
        IN      SDP_TIME_PERIOD &ListMember,
        IN      ULONG           NumEntries,
        IN      void            **Element,
            OUT HRESULT         &HResult
        );

    virtual BOOL Set(
        IN      SDP_TIME_PERIOD &ListMember,
        IN      ULONG           NumEntries,
        IN      void            ***Element,
            OUT HRESULT         &HResult
        );
};



inline 
SDP_TIME_PERIOD_SAFEARRAY::SDP_TIME_PERIOD_SAFEARRAY(
        IN      SDP_TIME_PERIOD_LIST    &SdpTimePeriodList
        )
        : SDP_SAFEARRAY_WRAP_EX<SDP_TIME_PERIOD, SDP_TIME_PERIOD_LIST>(SdpTimePeriodList)
{
    m_VarType[0] = VT_BOOL;
    m_VarType[1] = VT_I1;
    m_VarType[2] = VT_I4;
    m_VarType[3] = VT_I4;
}




inline HRESULT 
SDP_TIME_PERIOD_SAFEARRAY::SetSafeArray(
	IN      VARIANT	&IsCompactVariant,
	IN      VARIANT	&UnitVariant,
	IN      VARIANT	&CompactValueVariant,
	IN      VARIANT	&PeriodValueVariant
    )
{
    VARIANT   *VariantArray[] = {
            &IsCompactVariant, &UnitVariant, 
            &CompactValueVariant, &PeriodValueVariant
            };

    return SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


#endif   // __SDP_TIME_PERIOD_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpsarr.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_SAFEARRAY__
#define __SDP_SAFEARRAY__

#include <afxdisp.h>

#include "sdpcommo.h"
#include "sdpdef.h"


inline BOOL
ValidateSafeArray(
    IN          VARTYPE VarType,
    IN          VARIANT *Variant
    )
{
    ASSERT(NULL != Variant);

    // check if its a safearray and the type of elements in the safe array is whats expected
    if ( !(V_VT(Variant) & (VT_ARRAY | VarType)) )
    {
        return FALSE;
    }

    // check number of dimensions, cannot handle more than one dimension
    if ( V_ARRAY(Variant)->cDims != 1 )
    {
        return FALSE;
    }

    return TRUE;
}



class _DllDecl SDP_SAFEARRAY : public COleSafeArray
{
public:

    inline  SDP_SAFEARRAY();

    BOOL CreateAndAttach(
        IN      ULONG       MinSize,
        IN      VARTYPE     VarType,
        IN  OUT VARIANT     &Variant,
            OUT HRESULT     &HResult
        );

    inline  void Attach(
        IN  VARIANT   &Variant
        );

    inline  void Detach();

    inline  BOOL Free(
            OUT HRESULT     &HResult
        );

    inline  BOOL IsAllocated() const;

    inline  ~SDP_SAFEARRAY();

protected:

    VARIANT   *m_Variant;
};


inline 
SDP_SAFEARRAY::SDP_SAFEARRAY(
    )
    : m_Variant(NULL)
{
}


inline void 
SDP_SAFEARRAY::Attach(
    IN  VARIANT &Variant
    )
{
    m_Variant = &Variant;

    // because of the way attach is implemented, the variant vt type field is set to VT_EMPTY
    // and the ptr is set to null
    // if the instance is destroyed without calling free, the vt type and the safe array are assigned
    // back to the member variant
    COleSafeArray::Attach(Variant);
}



inline void 
SDP_SAFEARRAY::Detach(
    )
{
    ASSERT(NULL != m_Variant);

    if ( NULL != m_Variant )
    {
        *m_Variant = COleSafeArray::Detach();
        m_Variant = NULL;
    }
}



inline  BOOL 
SDP_SAFEARRAY::Free(
        OUT HRESULT     &HResult
    )
{
    if (NULL == m_Variant)
    {
        HResult = S_OK;
        return TRUE;
    }
    
    // destroy the underlying safearray
    Clear();

    // set the member variant ptr to null so that we are no longer attached to it
    m_Variant = NULL;

    return TRUE;
}


inline BOOL 
SDP_SAFEARRAY::IsAllocated(
    ) const
{
    return (NULL != m_Variant) ? TRUE : FALSE;
}



inline 
SDP_SAFEARRAY::~SDP_SAFEARRAY(
    )
{
    if ( NULL != m_Variant )
    {
        *m_Variant = COleSafeArray::Detach();
    }
}



template <class T>
class DYNAMIC_ARRAY
{
public:

    inline DYNAMIC_ARRAY(
        IN      ULONG NumElements
        );

    inline T &operator[](
        IN      ULONG Index
        );

    inline T *operator()();

    virtual ~DYNAMIC_ARRAY();

protected:

    T   *m_Array;
};


template <class T>
inline 
DYNAMIC_ARRAY<T>::DYNAMIC_ARRAY(
    IN      ULONG NumElements
    )
{
    ASSERT(0 != NumElements);
    m_Array = new T[NumElements];
}


template <class T>
inline T &
DYNAMIC_ARRAY<T>::operator[](
    IN      ULONG Index
    )
{
    return m_Array[Index];
}


template <class T>
inline T *
DYNAMIC_ARRAY<T>::operator ()(
    )
{
    return m_Array;
}


template <class T>
DYNAMIC_ARRAY<T>::~DYNAMIC_ARRAY(
    )
{
    ASSERT( NULL != m_Array );
    
    delete[] m_Array;
}


template <class T>
class DYNAMIC_POINTER_ARRAY : public DYNAMIC_ARRAY<T *>
{
public:

    inline DYNAMIC_POINTER_ARRAY(
        IN      ULONG NumElements
        );

    inline T &operator[](
        IN      ULONG Index
        );

    virtual ~DYNAMIC_POINTER_ARRAY();

protected:

    ULONG   m_NumElements;

    // should not be called
    inline T *operator()()
    {
        ASSERT(FALSE);
        return NULL;
    }
};


template <class T>
inline 
DYNAMIC_POINTER_ARRAY<T>::DYNAMIC_POINTER_ARRAY(
    IN      ULONG NumElements
    )
    : DYNAMIC_ARRAY<T *>(NumElements),
      m_NumElements(NumElements)
{
    for (UINT i=0; i < NumElements; i++)
    {
        m_Array[i] = new T();
    }
}


template <class T>
inline T &
DYNAMIC_POINTER_ARRAY<T>::operator[](
    IN      ULONG Index
    )
{
    return *m_Array[Index];
}



template <class T>
DYNAMIC_POINTER_ARRAY<T>::~DYNAMIC_POINTER_ARRAY(
    )
{
    ASSERT( NULL != m_Array );
    
    for (UINT i=0; i < m_NumElements; i++)
    {
        delete m_Array[i];
    }
}



class _DllDecl SDP_SAFEARRAY_WRAP
{
public:

    HRESULT GetSafeArrays(
        IN      const   ULONG       NumElements,                                        
        IN      const   ULONG       NumSafeArrays,
        IN              VARTYPE     VarType[],
            OUT         VARIANT		*Variant[]
        );

    HRESULT SetSafeArrays(
        IN      const   ULONG       NumSafeArrays,
        IN              VARTYPE     VarType[],
        IN              VARIANT		*Variant[]
        );

protected:

    virtual BOOL GetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual BOOL SetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual void RemoveExcessElements(
        IN      ULONG   StartIndex
        ) = 0;
};


template <class T, class TLIST>
class _DllDecl SDP_SAFEARRAY_WRAP_EX : public SDP_SAFEARRAY_WRAP
{
public:

    inline SDP_SAFEARRAY_WRAP_EX(
        IN      TLIST    &TList
        );

protected:

    TLIST   &m_TList;


    T   *GetListMember(
        IN      ULONG   Index,
            OUT HRESULT &HResult
    );


    virtual BOOL Get(
        IN      T       &ListMember,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual BOOL GetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    **Element,
            OUT HRESULT &HResult
        );


    T   *CreateListMemberIfRequired(
        IN      ULONG   Index,
            OUT HRESULT &HResult
    );


    virtual BOOL Set(
        IN      T       &ListMember,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        ) = 0;

    virtual BOOL SetElement(
        IN      ULONG   Index,
        IN      ULONG   NumEntries,
        IN      void    ***Element,
            OUT HRESULT &HResult
        );

    virtual void RemoveExcessElements(
        IN      ULONG   StartIndex
        );
};


template <class T, class TLIST>
inline 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::SDP_SAFEARRAY_WRAP_EX(
        IN      TLIST    &TList
        )
        : m_TList(TList)
{}


template <class T, class TLIST>
T   * 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::GetListMember(
    IN      ULONG   Index,
        OUT HRESULT &HResult
    )
{
    T   *ToReturn = dynamic_cast<T *>(m_TList[Index]);

    if ( NULL == ToReturn )
    {
        HResult = HRESULT_FROM_ERROR_CODE(SDP_INTERNAL_ERROR);
    }

    return ToReturn;
}



template <class T, class TLIST>
BOOL 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::GetElement(
    IN      ULONG   Index,
    IN      ULONG   NumEntries,
    IN      void    **Element,
        OUT HRESULT &HResult
    )
{
    T   *ListMember = GetListMember(Index, HResult);
    if ( NULL == ListMember )
    {
        return FALSE;
    }

    ASSERT(ListMember->IsValid());
    if ( !Get(*ListMember, NumEntries, Element, HResult) )
    {
        return FALSE;
    }

    return TRUE;
}



template <class T, class TLIST>
T   * 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::CreateListMemberIfRequired(
    IN      ULONG   Index,
        OUT HRESULT &HResult
    )
{
    // assert that the index is atmost 1 more than the size of the list
    ASSERT(0 <= m_TList.GetSize());
    ASSERT(Index <= (ULONG)(m_TList.GetSize() + 1));

    if ( Index >= (ULONG)m_TList.GetSize() )
    {

        T   *NewElement = dynamic_cast<T *>(m_TList.CreateElement());
       
        if ( NULL == NewElement )
        {
            HResult = HRESULT_FROM_ERROR_CODE(SDP_INTERNAL_ERROR);
        }
        return NewElement;
    }
    else
    {
        return GetListMember(Index, HResult);
    }

    // should never reach here
    ASSERT(FALSE);
}

template <class T, class TLIST>
BOOL 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::SetElement(
    IN      ULONG   Index,
    IN      ULONG   NumEntries,
    IN      void    ***Element,
        OUT HRESULT &HResult
    )
{
    T   *ListMember = CreateListMemberIfRequired(Index, HResult);
    if ( NULL == ListMember )
    {
        return FALSE;
    }

    if ( !Set(*ListMember, NumEntries, Element, HResult) )
    {
        return FALSE;
    }
    
    ASSERT(ListMember->IsValid());

    // if its a newly created instance, make it valid and add it to the list at the appropriate
    // index
    if ( Index >= (ULONG)m_TList.GetSize() )
    {
        try
        {
            m_TList.SetAtGrow(Index, ListMember);
        }
        catch(...)
        {
            delete ListMember;

            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    return TRUE;
}


template <class T, class TLIST>
void 
SDP_SAFEARRAY_WRAP_EX<T, TLIST>::RemoveExcessElements(
    IN      ULONG   StartIndex
    )
{
    ASSERT(0 <= m_TList.GetSize());

    // for each list element that is in excess of the safearray members,
    // delete and remove them
    for ( ULONG i = StartIndex; i < (ULONG)m_TList.GetSize(); i++ )
    {
        delete m_TList[i];
        m_TList.RemoveAt(i);
        i++;
    }
}


#endif   // __SDP_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpsuit.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_UNSIGNED_INTEGRAL_TYPE_SAFEARRAY__
#define __SDP_UNSIGNED_INTEGRAL_TYPE_SAFEARRAY__


#include "sdpcommo.h"

template <class BASE, class T, class TLIST>
class _DllDecl SDP_UITYPE_SAFEARRAY :
    protected SDP_SAFEARRAY_WRAP_EX<T, TLIST>
{
public:

    inline SDP_UITYPE_SAFEARRAY(
        IN      TLIST    &SdpUitypeList
        );

    inline HRESULT GetSafeArray(
            OUT VARIANT   *UitypeVariant
        );

    inline HRESULT SetSafeArray(
        IN      VARIANT   &UitypeVariant
        );

protected:

    VARTYPE m_VarType[1];
    BASE    m_BaseValue;

    virtual BOOL Get(
        IN      T           &ListMember,
        IN      ULONG       NumEntries,
        IN      void        **Element,
            OUT HRESULT     &HResult
        );

    virtual BOOL Set(
        IN      T           &ListMember,
        IN      ULONG       NumEntries,
        IN      void        ***Element,
            OUT HRESULT     &HResult
        );
};


// the vartype is initialized in the deriving class
template <class BASE, class T, class TLIST>
inline
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::SDP_UITYPE_SAFEARRAY(
    IN      TLIST    &SdpUitypeList
    )
    : SDP_SAFEARRAY_WRAP_EX<T, TLIST>(SdpUitypeList)
{}



template <class BASE, class T, class TLIST>
inline HRESULT
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::GetSafeArray(
		OUT VARIANT   *UitypeVariant
    )
{
    VARIANT   *VariantArray[] = {UitypeVariant};

    return SDP_SAFEARRAY_WRAP::GetSafeArrays(
        m_TList.GetSize(), 
        sizeof(VariantArray)/sizeof(VARIANT	*),
        m_VarType,
        VariantArray
        );
}



template <class BASE, class T, class TLIST>
inline HRESULT
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::SetSafeArray(
    IN      VARIANT   &UitypeVariant
    )
{
    VARIANT   *VariantArray[] = {&UitypeVariant};

    return SDP_SAFEARRAY_WRAP::SetSafeArrays(
        sizeof(VariantArray)/sizeof(VARIANT	*), 
        m_VarType,
        VariantArray
        );
}



template <class BASE, class T, class TLIST>
BOOL
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::Get(
    IN      T           &ListMember,
    IN      ULONG       NumEntries,
    IN      void        **Element,
        OUT HRESULT     &HResult
    )
{
    ASSERT(1 == NumEntries);

    m_BaseValue = ListMember.GetValue();
    Element[0] = &m_BaseValue;

    return TRUE;
}



template <class BASE, class T, class TLIST>
BOOL
SDP_UITYPE_SAFEARRAY<BASE, T, TLIST>::Set(
    IN      T           &ListMember,
    IN      ULONG       NumEntries,
    IN      void        ***Element,
        OUT HRESULT     &HResult
    )
{
    ASSERT(1 == NumEntries);

    ASSERT(NULL != Element[0]);

    ListMember.SetValueAndFlag(*((BASE *)Element[0]));

    return TRUE;
}



#endif // __SDP_UNSIGNED_INTEGRAL_TYPE_SAFEARRAY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpver.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpver.h

Abstract:


Author:

*/
#ifndef __SDP_VERSION__
#define __SDP_VERSION__


#include "sdpcommo.h"
#include "sdpval.h"
#include "sdpfld.h"



const   ULONG   CURRENT_SDP_VERSION = 0;


class _DllDecl SDP_VERSION : public SDP_VALUE 
{
public:

    SDP_VERSION();

    inline USHORT   GetVersionValue() const;

private:

    SDP_USHORT    m_Version;
    
    virtual BOOL InternalParseLine(
        IN  OUT     CHAR    *&Line
        );

	virtual void InternalReset();
};



inline USHORT   
SDP_VERSION::GetVersionValue(
    ) const
{
    return m_Version.GetValue();
}


#endif // __SDP_VERSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdptime.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_TIME__
#define __SDP_TIME__

#include "sdpcommo.h"
#include "sdpgen.h"
#include "sdpfld.h"
#include "sdpval.h"

#include "sdpstp.h"
#include "sdpsadj.h"


// no Reset method to set the member values to 0 again (as its not really required and it saves 
// one call per instance)
class _DllDecl SDP_TIME_PERIOD : public SDP_SINGLE_FIELD
{
public:

    inline          SDP_TIME_PERIOD();

    inline BOOL     IsCompact() const;

    inline void     IsCompact(
        IN BOOL IsCompactFlag
        );

    inline CHAR     GetUnit() const;

    inline void     SetUnit(
        IN CHAR Unit
        );

    inline LONG     GetCompactValue() const;

    inline void     SetCompactValue(
        IN LONG CompactValue
        );

    inline LONG     GetPeriodValue() const;

    inline void     SetPeriodValue(
        IN LONG PeriodValue
        );

    inline void     Get(
            OUT     BOOL    &IsCompactFlag,
            OUT     CHAR    &Unit,
            OUT     LONG    &CompactValue,
            OUT     LONG    &PeriodValue
        ) const;

    inline void     Set(
        IN          BOOL    IsCompactFlag,
        IN          CHAR    Unit,
        IN          LONG    CompactValue,
        IN          LONG    PeriodValue
        );

protected:

    BOOL    m_IsCompact;
    CHAR    m_Unit;
    LONG    m_CompactValue;
    LONG    m_PeriodValue;

    CHAR    m_SdpTimePeriodBuffer[25];

    virtual BOOL    InternalParseToken(
        IN      CHAR        *Token
        );
    
    virtual BOOL    PrintData(
            OUT ostrstream  &OutputStream
        );
};


inline      
SDP_TIME_PERIOD::SDP_TIME_PERIOD(
    )
    : SDP_SINGLE_FIELD(sizeof(m_SdpTimePeriodBuffer), m_SdpTimePeriodBuffer)
{
}


inline BOOL 
SDP_TIME_PERIOD::IsCompact(
    ) const
{
    return m_IsCompact;
}


inline void     
SDP_TIME_PERIOD::IsCompact(
    IN BOOL IsCompactFlag
    )
{
    m_IsCompact = IsCompactFlag;
}

   
inline CHAR 
SDP_TIME_PERIOD::GetUnit(
    ) const
{
    return m_Unit;
}



inline void     
SDP_TIME_PERIOD::SetUnit(
    IN CHAR Unit
    )
{
    m_Unit = Unit;
}

    
inline LONG 
SDP_TIME_PERIOD::GetCompactValue(
    ) const
{
    return m_CompactValue;
}



inline void     
SDP_TIME_PERIOD::SetCompactValue(
    IN LONG CompactValue
    )
{
    m_CompactValue = CompactValue;
}

    
inline LONG 
SDP_TIME_PERIOD::GetPeriodValue(
    ) const
{
    return m_PeriodValue;
}



inline void 
SDP_TIME_PERIOD::SetPeriodValue(
    IN LONG PeriodValue
    )
{
    m_PeriodValue = PeriodValue;
}


inline void     
SDP_TIME_PERIOD::Get(
        OUT     BOOL    &IsCompactFlag,
        OUT     CHAR    &Unit,
        OUT     LONG    &CompactValue,
        OUT     LONG    &PeriodValue
    ) const
{
    IsCompactFlag   = IsCompact();
    Unit            = GetUnit();
    CompactValue    = GetCompactValue();
    PeriodValue     = GetPeriodValue();
}


inline void     
SDP_TIME_PERIOD::Set(
    IN          BOOL    IsCompactFlag,
    IN          CHAR    Unit,
    IN          LONG    CompactValue,
    IN          LONG    PeriodValue
    )
{
    IsCompact(IsCompactFlag);
    SetUnit(Unit);
    SetCompactValue(CompactValue);
    SetPeriodValue(PeriodValue);

    IsValid(TRUE);
    IsModified(TRUE);
}



class _DllDecl SDP_TIME_PERIOD_LIST :
    public SDP_FIELD_LIST,
    public SDP_TIME_PERIOD_SAFEARRAY
{
public:

    inline  SDP_TIME_PERIOD_LIST();

    virtual SDP_FIELD   *CreateElement();
};



inline  
SDP_TIME_PERIOD_LIST::SDP_TIME_PERIOD_LIST(
    )
    : SDP_FIELD_LIST(CHAR_BLANK),
      SDP_TIME_PERIOD_SAFEARRAY(*this)
{
}


class _DllDecl SDP_REPEAT : public SDP_VALUE
{
public:

    SDP_REPEAT();

    inline SDP_TIME_PERIOD  &GetInterval();

    inline SDP_TIME_PERIOD  &GetDuration();

    inline SDP_TIME_PERIOD_LIST  &GetOffsets();

protected:

    SDP_TIME_PERIOD         m_Interval;
    SDP_TIME_PERIOD         m_Duration;
    SDP_TIME_PERIOD_LIST    m_Offsets;   // array of SDP_TIME_PERIOD

    virtual BOOL    InternalParseLine(
        IN  OUT         CHAR    *&Line
        );

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void InternalReset();
};


inline SDP_TIME_PERIOD  &
SDP_REPEAT::GetInterval(
    )
{
    return m_Interval;
}


inline SDP_TIME_PERIOD  &
SDP_REPEAT::GetDuration(
    )
{
    return m_Duration;
}


inline SDP_TIME_PERIOD_LIST  &
SDP_REPEAT::GetOffsets(
    )
{
    return m_Offsets;
}




class _DllDecl SDP_REPEAT_LIST : public SDP_VALUE_LIST
{
protected:

    virtual SDP_VALUE   *CreateElement();
};




class _DllDecl SDP_ADJUSTMENT : 
    public SDP_VALUE,
    public SDP_ADJUSTMENT_SAFEARRAY
{
public:

    SDP_ADJUSTMENT();

    inline SDP_ULONG_LIST       &GetAdjustmentTimes();

    inline SDP_TIME_PERIOD_LIST &GetOffsets();

protected:

    SDP_ULONG_LIST          m_AdjustmentTimes;   // array of SDP_ULONG 
    SDP_TIME_PERIOD_LIST    m_Offsets;           // array of SDP_TIME_PERIOD 
    
    CHAR    m_PrintBuffer[400];
    DWORD   m_PrintLength;

    virtual void InternalReset();

    BOOL    PrintData(
        OUT     ostrstream  &OutputStream
    );

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual BOOL    CalcIsModified() const;

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyValue(
            OUT         ostrstream  &OutputStream
        );

    BOOL    PrintElement(
        IN      DWORD       Index,
            OUT ostrstream  &OutputStream
        );
  };



inline SDP_ULONG_LIST &
SDP_ADJUSTMENT::GetAdjustmentTimes(
    )
{
    return m_AdjustmentTimes;
}



inline SDP_TIME_PERIOD_LIST &
SDP_ADJUSTMENT::GetOffsets(
    )
{
    return m_Offsets;
}




class _DllDecl SDP_TIME : public SDP_VALUE
{
public:

    SDP_TIME();

    inline HRESULT          SetTimes(
        IN          ULONG   StartTime,
        IN          ULONG   StopTime
        );

    inline HRESULT          SetStartTime(
        IN          ULONG   StartTime
        );

    inline HRESULT          SetStopTime(
        IN          ULONG   StopTime
        );

    inline HRESULT          GetStartTime(
        OUT         ULONG   &StartTime
        );

    inline HRESULT          GetStopTime(
        OUT         ULONG   &StopTime
        );

    inline SDP_REPEAT_LIST  &GetRepeatList();

protected:

    virtual BOOL            CalcIsModified() const;

    virtual DWORD           CalcCharacterStringSize();

    virtual BOOL            CopyValue(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL            GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );

    virtual void InternalReset();

private:

    SDP_ULONG       m_StartTime;
    SDP_ULONG       m_StopTime;
    SDP_REPEAT_LIST m_RepeatList;
 
    inline HRESULT FillArrays();
};



inline HRESULT          
SDP_TIME::FillArrays(
    )
{
    // check if the field and separator char arrays have been filled properly
    if ( (2 != m_FieldArray.GetSize()) || (2 != m_SeparatorCharArray.GetSize()) )
    {
        // clear the field and separator arrays
        m_FieldArray.RemoveAll();
        m_SeparatorCharArray.RemoveAll();

        try
        {
            // insert the fields and the separator characters into respective arrays
            m_FieldArray.SetAtGrow(0, &m_StartTime);
            m_SeparatorCharArray.SetAtGrow(0, CHAR_BLANK);

            m_FieldArray.SetAtGrow(1, &m_StopTime);
            m_SeparatorCharArray.SetAtGrow(1, CHAR_NEWLINE);
        }
        catch(...)
        {
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            return E_OUTOFMEMORY;
        }
    }

    ASSERT(&m_StartTime == m_FieldArray[0]);
    ASSERT(&m_StopTime == m_FieldArray[1]);

    return S_OK;
}


inline HRESULT          
SDP_TIME::SetTimes(
    IN      ULONG   StartTime,
    IN      ULONG   StopTime
    )
{
    HRESULT hr;

    // validate the start/stop times (either stop time == 0 or starttime <= stop time)
    if ( !( (0 == StopTime) || (StartTime <= StopTime) ) )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    m_StartTime.SetValueAndFlag(StartTime);
    m_StopTime.SetValueAndFlag(StopTime);

    hr = FillArrays();

    return hr;
}


inline HRESULT             
SDP_TIME::SetStartTime(
    IN      ULONG   StartTime
    )
{
    HRESULT hr;

    hr = FillArrays();

    if ( FAILED(hr) )
    {
        return hr;
    }

    // set the value and the valid, modified flag
    m_StartTime.SetValueAndFlag(StartTime);

    // if the stop time is invalid, there is nothing to compare against
    if ( !m_StopTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // check if the new start time is <= the current stop time,
    // special case for an unbounded start/stop time (value 0)
    if ( !((0 == m_StopTime.GetValue())         ||
           (0 == StartTime)                     ||
           (StartTime <= m_StopTime.GetValue())) )
    {
        // unbound the stop time
        m_StopTime.SetValueAndFlag(0);
    }

    return S_OK;
}

inline HRESULT             
SDP_TIME::SetStopTime(
    IN      ULONG   StopTime
    )
{
    HRESULT hr;

    hr = FillArrays();

    if ( FAILED(hr) )
    {
        return hr;
    }

    // set the value and the valid, modified flag
    m_StopTime.SetValueAndFlag(StopTime);

    // if the start time is invalid, there is nothing to compare against
    if ( !m_StartTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // check if the current start time is <= the new stop time,
    // special case for an unbounded start/stop time (value 0)
    if ( !((0 == m_StartTime.GetValue())        || 
           (0 == StopTime)                      || 
           (m_StartTime.GetValue() <= StopTime)) )
    {
        // unbound the start time
        m_StartTime.SetValueAndFlag(0);
    }

    return S_OK;
}

inline  HRESULT         
SDP_TIME::GetStartTime(
        OUT ULONG   &StartTime
    )
{
    // check if the value being asked for is valid
    if ( !m_StartTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    StartTime = m_StartTime.GetValue();
    return S_OK;
}

inline  HRESULT         
SDP_TIME::GetStopTime(
        OUT ULONG   &StopTime
    )
{
    // check if the value being asked for is valid
    if ( !m_StopTime.IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    StopTime = m_StopTime.GetValue();
    return S_OK;
}


inline SDP_REPEAT_LIST  &
SDP_TIME::GetRepeatList(
    )
{
    return m_RepeatList;
}






class _DllDecl SDP_TIME_LIST : public SDP_VALUE_LIST
{
public:

	virtual void Reset();

    inline SDP_ADJUSTMENT   &GetAdjustment();

    virtual BOOL        IsModified() const;

    virtual DWORD       GetCharacterStringSize();

    virtual BOOL        PrintValue(
            OUT         ostrstream  &OutputStream
        );

protected:

    SDP_ADJUSTMENT      m_Adjustment;

    virtual SDP_VALUE   *CreateElement();
};



inline SDP_ADJUSTMENT   &
SDP_TIME_LIST::GetAdjustment(
    )
{
    return m_Adjustment;
}


#endif // __SDP_TIME__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\sdpval.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_VALUE__
#define __SDP_VALUE__

#include "sdpcommo.h"
#include "sdpfld.h"


// this value indicates that line transitions must start
// this has to be a value of 0 that is same as the first (start) state for
// all line transitions
const DWORD LINE_START  = 0;


// Usage - Modifications involving change in the layout of the value
// line must also modify the CArrays m_FieldArray and m_SeparatorCharArray if they are used
class _DllDecl SDP_VALUE
{
public:

    inline SDP_VALUE(
        IN              DWORD                   ErrorCode,
        IN      const   CHAR                    *TypePrefixString,
        IN      const   SDP_LINE_TRANSITION     *SdpLineTransition = NULL
        );

	// SDP_VALUE instances use an inline Reset method which calls a virtual InternalReset method.
	// this is possible because unlike the SDP_FIELD inheritance tree, SDP_VALUE and SDP_VALUE_LIST
	// do not share a common base class. This combined with the fact that the SDP_VALUE inheriance 
	// tree is quite shallow and has fewer instances (than SDP_FIELD) makes the scheme appropriate
	// it as it reduces the number of Reset related calls to 1 and the inline code is not repeated
	// to often.
	// For the SDP_FIELD inheritance tree, the appropriate Reset calling sequence is a series of
	// Reset calls starting with the top most virtual Reset body followed by the
	// base class Reset method (recursively). This is appropriate because, the number of calls
	// would not decrease if the InternalReset scheme is adopted (virtual Reset()) and that the
	// inheritance tree is much deeper
    inline void    Reset();

    virtual BOOL    IsValid() const;

    inline  BOOL    IsModified() const;

    inline  DWORD   GetCharacterStringSize();

    inline  BOOL    PrintValue(
            OUT     ostrstream  &OutputStream
        );

    inline  BOOL    ParseLine(
        IN  OUT     CHAR    *&Line
        );

    virtual ~SDP_VALUE()
    {}


protected:

    // the line state is the initial state for parsing the line and must be
    // assigned by the deriving value class
    DWORD                               m_LineState;

    // the error code, type prefix string and the transition info (table) must be 
    // specified by the deriving class to this class's constructor
    const   DWORD                       m_ErrorCode;
    const   CHAR                * const m_TypePrefixString;
    const   SDP_LINE_TRANSITION * const m_SdpLineTransition;

    CArray<SDP_FIELD *, SDP_FIELD *>    m_FieldArray;
    CArray<CHAR, CHAR>                  m_SeparatorCharArray;

    virtual void    InternalReset() = 0;

    virtual BOOL    CalcIsModified() const;

    virtual DWORD   CalcCharacterStringSize();

    virtual BOOL    CopyValue(
            OUT     ostrstream  &OutputStream
        );

    virtual BOOL    InternalParseLine(
        IN  OUT     CHAR    *&Line
        );

    BOOL GetFieldToParse(
        IN      const   CHAR                    SeparatorChar,
        IN      const   LINE_TRANSITION_INFO    *LineTransitionInfo,
            OUT         SDP_FIELD               *&Field,
            OUT         BOOL                    &Finished,
            OUT         BOOL                    &AddToArray
        );

    
    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        )
    {
        // we should not reach here 
        // this method must be overridden to be used
        // to be done
        ASSERT(FALSE);
        return FALSE;
    }

};


inline
SDP_VALUE::SDP_VALUE(
    IN              DWORD                   ErrorCode,
    IN      const   CHAR                    *TypePrefixString,
    IN      const   SDP_LINE_TRANSITION     *SdpLineTransition
    )
    : m_ErrorCode(ErrorCode),
      m_TypePrefixString(TypePrefixString),
      m_SdpLineTransition(SdpLineTransition),
      m_LineState(LINE_START)
{
    ASSERT(NULL != TypePrefixString);
    ASSERT(strlen(TypePrefixString) == TYPE_STRING_LEN);
}



inline  void    
SDP_VALUE::Reset(
        )
{
    InternalReset();

	// empty the separator char / field arrays
	m_FieldArray.RemoveAll();
	m_SeparatorCharArray.RemoveAll();

	m_LineState = LINE_START; 
}


inline  BOOL    
SDP_VALUE::IsModified(
    ) const
{
    return ( IsValid() ? CalcIsModified() : FALSE );
}


inline  DWORD   
SDP_VALUE::GetCharacterStringSize(
    )
{
    return ( IsValid() ? CalcCharacterStringSize() : 0 );
}
   


inline  BOOL    
SDP_VALUE::PrintValue(
    OUT     ostrstream  &OutputStream
    )
{
    // should not be modified
    ASSERT(!IsModified());

    return ( IsValid() ? CopyValue(OutputStream) : TRUE );
}
    


inline BOOL    
SDP_VALUE::ParseLine(
    IN  OUT     CHAR    *&Line
    )
{
    // parse the line
    return InternalParseLine(Line);
}


class _DllDecl SDP_VALUE_LIST : public SDP_POINTER_ARRAY<SDP_VALUE *>
{
public:

    inline  BOOL        IsValid() const;

    inline BOOL         ParseLine(
        IN              CHAR        *&Line
        );

    inline SDP_VALUE    *GetCurrentElement();

    virtual BOOL        IsModified() const;

    virtual DWORD       GetCharacterStringSize();

    virtual BOOL        PrintValue(
            OUT         ostrstream  &OutputStream
        );

    virtual SDP_VALUE   *CreateElement() = 0;
};



inline  BOOL    
SDP_VALUE_LIST::IsValid(
    ) const
{
    // check each of the members in the list for validity
    for (int i=0; i < GetSize(); i++)
    {
        // if even one member is valid, return TRUE
        if ( GetAt(i)->IsValid() )
        {
            return TRUE;
        }
    }

    // all members are invalid
    return FALSE;
}


inline BOOL        
SDP_VALUE_LIST::ParseLine(
    IN CHAR *&Line
    )
{
    SDP_VALUE *SdpValue = CreateElement();
    if ( NULL == SdpValue )
    {
        return FALSE;
    }

    if ( !SdpValue->ParseLine(Line) )
    {
        delete SdpValue;
        return FALSE;
    }

    try
    {
        Add(SdpValue);
    }
    catch(...)
    {
        delete SdpValue;
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    return TRUE;
}



inline SDP_VALUE   *
SDP_VALUE_LIST::GetCurrentElement(
    )
{
    ASSERT(0 < GetSize());
    ASSERT(NULL != GetAt(GetSize()-1));

    return GetAt(GetSize()-1);
}



#endif // __SDP_VALUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\tapih26x.h ===
/****************************************************************************
 *  @doc INTERNAL TAPIH26X
 *
 *  @module TAPIH26X.h | Header file for the supported compressed input formats.
 ***************************************************************************/

#ifndef _TAPIH26X_H_
#define _TAPIH26X_H_

//#define USE_OLD_FORMAT_DEFINITION 1

// RTP-packetized video subtypes
#define STATIC_MEDIASUBTYPE_R263_V1 0x33363252L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
#define STATIC_MEDIASUBTYPE_R261 0x31363252L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71

// H.26x specific structures
/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct BITMAPINFOHEADER_H263 | The <t BITMAPINFOHEADER_H263> structure
 *    is used to specify the details of the H.263 video format.
 *
 *  @field BITMAPINFOHEADER | bmi | Specifies a well-known GDI bitmap info
 *    header structure.
 *
 *  @field DWORD | dwMaxBitrate | Specifies the maximum bit rate in units of
 *    100 bits/s at which the receiver can receive video. This value is valid
 *    between 1 and 192400.
 *
 *  @field DWORD | dwBppMaxKb | Specifies the maximum number of bits for one
 *    coded picture that the receiver can receive and decode correctly, and is
 *    measured in units of 1024 bits. This value is valid between 0 and 65535.
 *
 *  @field DWORD | dwHRD_B | Specifies the Hypothetical Reference Decoder
 *    parameter B as described in Annex B of H.263. This value is valid
 *    between 0 and 524287.
 *
 *  @field DWORD | fUnrestrictedVector:1 | Specifies that the receiver can
 *    receive video data using the unrestricted motion vectors mode as defined
 *    in Annex D of H.263.
 *
 *  @field DWORD | fArithmeticCoding:1| Specifies that the receiver can receive
 *    video data using the syntax based arithmetic coding mode as defined in
 *    Annex E of H.263.
 *
 *  @field DWORD | fAdvancedPrediction:1 | Specifies that the receiver can
 *    receive video data using the advanced prediction mode as defined in Annex
 *    F of H.263.
 *
 *  @field DWORD | fPBFrames:1 | Specifies that the receiver can receive video
 *    data using the PB-frames mode as defined in Annex G of H.263.
 *
 *  @field DWORD | fErrorCompensation:1 | Specifies that the receiver can
 *    identify MBs received with transmission errors, treat them as not coded,
 *    and send appropriate videoNotDecodedMBs indications.
 *
 *  @field DWORD | fAdvancedIntraCodingMode:1 | Specifies that the receiver can
 *    receive video data using the advanced INTRA coding mode as defined in
 *    Annex I of H.263.
 *
 *  @field DWORD | fDeblockingFilterMode:1 | Specifies that the receiver can
 *    receive video data using the deblocking filter mode as defined in Annex J
 *    of H.263.
 *
 *  @field DWORD | fImprovedPBFrameMode:1 | Specifies that the receiver can
 *    receive video data using the improved PB-frames mode as defined in Annex
 *    M of H.263.
 *
 *  @field DWORD | fUnlimitedMotionVectors:1 | Specifies that the receiver can
 *    receive video data using the unrestricted motion vector range when
 *    unrestricted motion vector mode as defined in Annex D of H.263 is also
 *    indicated.
 *
 *  @field DWORD | fFullPictureFreeze:1 | Specifies that the receiver can receive
 *    Full Picture Freeze commands as described in Annex L of H.263.
 *
 *  @field DWORD | fPartialPictureFreezeAndRelease:1 | Specifies that the
 *    receiver can receive the Resizing Partial Picture Freeze and Release
 *    commands as described in Annex L of H.263.
 *
 *  @field DWORD | fResizingPartPicFreezeAndRelease:1 | Specifies that the
 *    receiver can receive the Resizing Partial Picture Freeze and Release
 *    commands as described in Annex L of H.263.
 *
 *  @field DWORD | fFullPictureSnapshot:1 | Specifies that the receiver can
 *    receive Full Picture snapshots of the video content as described in Annex L
 *    of H.263.
 *
 *  @field DWORD | fPartialPictureSnapshot:1 | Specifies that the receiver can
 *    receive Partial Picture Snapshots of the video content as described in
 *    Annex L of H.263.
 *
 *  @field DWORD | fVideoSegmentTagging:1 | Specifies that the receiver can
 *    receive Video Segment tagging for the video content as described in Annex L
 *    of H.263.
 *
 *  @field DWORD | fProgressiveRefinement:1 | Specifies that the receiver can
 *    receive Progressive Refinement tagging as described in Annex L of H.263. In
 *    addition, when true, the encoder shall respond to the progressive refinement
 *    miscellaneous commands doOneProgression, doContinuousProgressions,
 *    doOneIndependentProgression, doContinuousIndependentProgressions,
 *    progressiveRefinementAbortOne, and progressiveRefinementAbortContinuous. In
 *    addition, the encoder shall insert the Progressive Refinement Segment Start
 *    Tags and the Progressive Refinement Segment End Tags as defined in the
 *    Supplemental Enhancement Information Specification (Annex L) of
 *    Recommendation H.263. Note, Progressive Refinement tagging can be sent by an
 *    encoder and received by a decoder even when not commanded in a miscellaneous
 *    command.
 *
 *  @field DWORD | fDynamicPictureResizingByFour:1 | Specifies that the receiver
 *    supports the picture resizing-by-four (with clipping) submode of the
 *    implicit Reference Picture Resampling Mode (Annex P) of H.263.
 *
 *  @field DWORD | fDynamicPictureResizingSixteenthPel:1 | Specifies that the
 *    receiver supports resizing a reference picture to any width and height using
 *    the implicit Reference Picture Resampling mode (Annex P) of H.263 (with
 *    clipping). If DynamicPictureResizingSixteenthPel is true then
 *    DynamicPictureResizingByFour shall be true.
 *
 *  @field DWORD | fDynamicWarpingHalfPel:1 | Specifies that the receiver supports
 *    the arbitrary picture warping operation within the Reference Picture
 *    Resampling mode (Annex P) of H.263 (with any fill mode) using half-pixel
 *    accuracy warping.
 *
 *  @field DWORD | fDynamicWarpingSixteenthPel:1 | Specifies that the receiver
 *    supports the arbitrary picture warping operation within the Reference Picture
 *    Resampling mode (Annex P) of H.263 (with any fill mode) using either
 *    half-pixel or sixteenth pixel accuracy warping.
 *
 *  @field DWORD | fIndependentSegmentDecoding:1 | Specifies that the receiver
 *    supports the Independent Segment Decoding Mode (H.263 Annex R) of H.263.
 *
 *  @field DWORD | fSlicesInOrder_NonRect:1 | Specifies that the receiver supports
 *    the submode of Slice Structured Mode (H.263 Annex K) where slices are
 *    transmitted in order and contain macroblocks in scanning order of the
 *    picture.
 *
 *  @field DWORD | fSlicesInOrder_Rect:1 | Specifies that the receiver supports
 *    the submode of Slice Structured Mode (H.263 Annex K) where slices are
 *    transmitted in order and the slice occupies a rectangular region of the
 *    picture.
 *
 *  @field DWORD | fSlicesNoOrder_NonRect:1 | Specifies that the receiver
 *    supports the submode of Slice Structured Mode (H.263 Annex K) where
 *    slices contain macroblocks in scanning order of the picture and need
 *    not be transmitted in order.
 *
 *  @field DWORD | fSlicesNoOrder_Rect:1 | Specifies that the receiver
 *    supports the submode of Slice Structured Mode (H.263 Annex K) where
 *    slices occupy a rectangular region of the picture and need not be
 *    transmitted in order.
 *
 *  @field DWORD | fAlternateInterVLCMode:1 | Specifies that the receiver
 *    can receive video data using the alternate inter VLC mode as defined
 *    in Annex S of H.263.
 *
 *  @field DWORD | fModifiedQuantizationMode:1 | Specifies that the receiver
 *    can receive video data using the modified quantization mode as defined
 *    in Annex T of H.263.
 *
 *  @field DWORD | fReducedResolutionUpdate:1 | Specifies that the receiver
 *    can receive video data using the reduced resolution update mode as
 *    defined in Annex Q of H.263.
 *
 *  @field DWORD | fReserved:4 | Reserved. Shall be set to 0.
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/

#define MAX_BITRATE_H263 (192400)

typedef struct tagBITMAPINFOHEADER_H263
{
	// Generic bitmap info header fields
	BITMAPINFOHEADER   bmi;

#ifndef USE_OLD_FORMAT_DEFINITION
	// H.263 specific fields
	DWORD dwMaxBitrate;
	DWORD dwBppMaxKb;
	DWORD dwHRD_B;

	// Options
	DWORD fUnrestrictedVector:1;
	DWORD fArithmeticCoding:1;
	DWORD fAdvancedPrediction:1;
	DWORD fPBFrames:1;
	DWORD fErrorCompensation:1;
	DWORD fAdvancedIntraCodingMode:1;
	DWORD fDeblockingFilterMode:1;
	DWORD fImprovedPBFrameMode:1;
	DWORD fUnlimitedMotionVectors:1;
	DWORD fFullPictureFreeze:1;
	DWORD fPartialPictureFreezeAndRelease:1;
	DWORD fResizingPartPicFreezeAndRelease:1;
	DWORD fFullPictureSnapshot:1;
	DWORD fPartialPictureSnapshot:1;
	DWORD fVideoSegmentTagging:1;
	DWORD fProgressiveRefinement:1;
	DWORD fDynamicPictureResizingByFour:1;
	DWORD fDynamicPictureResizingSixteenthPel:1;
	DWORD fDynamicWarpingHalfPel:1;
	DWORD fDynamicWarpingSixteenthPel:1;
	DWORD fIndependentSegmentDecoding:1;
	DWORD fSlicesInOrder_NonRect:1;
	DWORD fSlicesInOrder_Rect:1;
	DWORD fSlicesNoOrder_NonRect:1;
	DWORD fSlicesNoOrder_Rect:1;
	DWORD fAlternateInterVLCMode:1;
	DWORD fModifiedQuantizationMode:1;
	DWORD fReducedResolutionUpdate:1;
	DWORD fReserved:4;

	// Reserved
	DWORD dwReserved[4];
#endif
} BITMAPINFOHEADER_H263, *PBITMAPINFOHEADER_H263;

/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct VIDEOINFOHEADER_H263 | The <t VIDEOINFOHEADER_H263> structure
 *    is used to specify the details of the H.263 video format.
 *
 *  @field RECT | rcSource | Specifies a <t RECT> structure that defines the
 *    source video window.
 *
 *  @field RECT | rcTarget | Specifies a <t RECT> structure that defines the
 *    destination video window.
 *
 *  @field DWORD | dwBitRate | Specifies a <t DWORD> value that indicates
 *    the video stream's approximate data rate, in bits per second.
 *
 *  @field DWORD | dwBitErrorRate | Specifies a <t DWORD> value that
 *    indicates the video stream's data error rate, in bit errors per second.
 *
 *  @field REFERENCE_TIME | AvgTimePerFrame | Specifies a <t REFERENCE_TIME>
 *    value that indicates the video frame's average display time, in
 *    100-nanosecond units.
 *
 *  @field BITMAPINFOHEADER_H263 | bmiHeader | Specifies a
 *    <t BITMAPINFOHEADER_H263> structure that contains detailed format
 *    information for the H.263 video data.
 ***************************************************************************/
typedef struct tagVIDEOINFOHEADER_H263
{
    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)
    BITMAPINFOHEADER_H263 bmiHeader;
} VIDEOINFOHEADER_H263, *PVIDEOINFOHEADER_H263;

/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct BITMAPINFOHEADER_H261 | The <t BITMAPINFOHEADER_H261> structure
 *    is used to specify the details of the H.261 video format.
 *
 *  @field BITMAPINFOHEADER | bmi | Specifies a well-known GDI bitmap info
 *    header structure.
 *
 *  @field DWORD | dwMaxBitrate | Specifies the maximum bit rate in units
 *    of 100 bits/s at which the receiver can receive video. This value is
 *    only valid between 1 and 19200.
 *
 *  @field BOOL | fStillImageTransmission | Specifies that the receiver can
 *    receive still images as defined in Annex D of H.261.
 *
 *  @field DWORD | dwReserved[4] | Reserved. Shall all be set to 0.
 ***************************************************************************/

#define MAX_BITRATE_H261 (19200)

typedef struct tagBITMAPINFOHEADER_H261
{
	// Generic bitmap info header fields
	BITMAPINFOHEADER   bmi;

#ifndef USE_OLD_FORMAT_DEFINITION
	// H.261 specific fields
	DWORD dwMaxBitrate;
	BOOL fStillImageTransmission;

	// Reserved
	DWORD dwReserved[4];
#endif
} BITMAPINFOHEADER_H261, *PBITMAPINFOHEADER_H261;

/*****************************************************************************
 *  @doc INTERNAL TAPIH26XSTRUCTENUM
 *
 *  @struct VIDEOINFOHEADER_H261 | The <t VIDEOINFOHEADER_H261> structure
 *    is used to specify the details of the H.261 video format.
 *
 *  @field RECT | rcSource | Specifies a <t RECT> structure that defines the
 *    source video window.
 *
 *  @field RECT | rcTarget | Specifies a <t RECT> structure that defines the
 *    destination video window.
 *
 *  @field DWORD | dwBitRate | Specifies a <t DWORD> value that indicates
 *    the video stream's approximate data rate, in bits per second.
 *
 *  @field DWORD | dwBitErrorRate | Specifies a <t DWORD> value that
 *    indicates the video stream's data error rate, in bit errors per second.
 *
 *  @field REFERENCE_TIME | AvgTimePerFrame | Specifies a <t REFERENCE_TIME>
 *    value that indicates the video frame's average display time, in
 *    100-nanosecond units.
 *
 *  @field BITMAPINFOHEADER_H261 | bmiHeader | Specifies a
 *    <t BITMAPINFOHEADER_H261> structure that contains detailed format
 *    information for the H.261 video data.
 ***************************************************************************/
typedef struct tagVIDEOINFOHEADER_H261
{
    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)
    BITMAPINFOHEADER_H261 bmiHeader;
} VIDEOINFOHEADER_H261, *PVIDEOINFOHEADER_H261;

#endif // _TAPIH26X_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\inc\tm.h ===
/////////////////////////////////////////////
//
// Copyright (c) 2000  Microsoft Corporation
//
// Module Name:
//
//    tm.h
//
//
// Abstract:
//
//  this file contains declarations used throughout modules that compose 
//  termmgr
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef ___TM_DOT_H_INCLUDED___
#define ___TM_DOT_H_INCLUDED___


//
// safely load a resource string described by the specified resources id
//
// returns NULL on failure, or the string on success
//
// on success, the caller is responsible for freeing return memory by calling
// SysFreeString()
//

BSTR SafeLoadString( UINT uResourceID );


//
// returns TRUE if the two media types are the equal
//

bool IsEqualMediaType(AM_MEDIA_TYPE const & mt1, AM_MEDIA_TYPE const & mt2);

BOOL IsBadMediaType(IN const AM_MEDIA_TYPE *mt1);


//
// our own assert, so we don't have to use CRT's
//

#ifdef DBG

    #define TM_ASSERT(x) { if (!(x)) { DebugBreak(); } }

#else

    #define TM_ASSERT(x)

#endif



//
// helper function that dumps allocator properties preceeded by the argument
// string
//

void DumpAllocatorProperties(const char *szString, 
                             const ALLOCATOR_PROPERTIES *pAllocProps);


//
// only dump alloc properties in debug build
//

#ifdef DBG

 #define DUMP_ALLOC_PROPS(string, x) DumpAllocatorProperties(string, x);

#else 

 #define DUMP_ALLOC_PROPS(string, x) 

#endif


#endif // ___TM_DOT_H_INCLUDED___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgaudio.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgaudio.h

Abstract:

    Definitions for the audio bridge filters

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BGAUDIO_H_
#define _BGAUDIO_H_


class CTAPIAudioBridgeSinkFilter :
    public CTAPIBridgeSinkFilter
{
public:
    CTAPIAudioBridgeSinkFilter(
        IN LPUNKNOWN        pUnk, 
        IN IDataBridge *    pIDataBridge, 
        OUT HRESULT *       phr
        );

    static HRESULT CreateInstance(
        IN IDataBridge *    pIDataBridge, 
        OUT IBaseFilter ** ppIBaseFilter
        );

    // methods called by the input pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);
};


class CTAPIAudioBridgeSourceFilter : 
    public CTAPIBridgeSourceFilter
    {
public:

    CTAPIAudioBridgeSourceFilter(
        IN LPUNKNOWN pUnk, 
        OUT HRESULT *phr
        );

    ~CTAPIAudioBridgeSourceFilter ();

    static HRESULT CreateInstance(
        OUT IBaseFilter ** ppIBaseFilter
        );

    // override the IDataBridge methods.
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        );

    // methods called by the output pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);

    // overrides the base filter
    // IAMBufferNegotiation stuff
    STDMETHOD (SuggestAllocatorProperties) (IN const ALLOCATOR_PROPERTIES *pprop);
    STDMETHOD (GetAllocatorProperties) (OUT ALLOCATOR_PROPERTIES *pprop);

    // IAMStreamConfig stuff
    STDMETHOD (SetFormat) (IN AM_MEDIA_TYPE *pmt);
    STDMETHOD (GetFormat) (OUT AM_MEDIA_TYPE **ppmt);

protected:

    // following members were moved from CTAPIBridgeSourceOutputPin
    // because they are only need in audio part; we implement a derived filter class
    // for audio; same pin is shared by both audio and video
    ALLOCATOR_PROPERTIES m_prop;
    BOOL m_fPropSet;

    AM_MEDIA_TYPE m_mt;
    BOOL m_fMtSet;

    BOOL m_fClockStarted;
    BOOL m_fJustBurst;
    REFERENCE_TIME m_last_wall_time;
    REFERENCE_TIME m_last_stream_time;
    // assume output sample won't change size
    REFERENCE_TIME m_output_sample_time;

    // algorithm of SendSample can only deal with samples with fixed size
    LONG m_nInputSize, m_nOutputSize, m_nOutputFree;
    IMediaSample *m_pOutputSample;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgaudio.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgaudio.cpp

Abstract:

    Implementation of the audio bridge filters.

Author:

    Mu Han (muhan) 11/16/1998

--*/

#include "stdafx.h"

CTAPIAudioBridgeSinkFilter::CTAPIAudioBridgeSinkFilter(
    IN LPUNKNOWN        pUnk, 
    IN IDataBridge *    pIDataBridge, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSinkFilter(pUnk, pIDataBridge, phr)
{
}

HRESULT CTAPIAudioBridgeSinkFilter::CreateInstance(
    IN IDataBridge *    pIDataBridge, 
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSinkFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIAudioBridgeSinkFilter(NULL, pIDataBridge, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        BGLOG((BG_ERROR, 
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIAudioBridgeSinkFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSinkFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    HRESULT hr = VFW_S_NO_MORE_ITEMS;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIAudioBridgeSinkFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    E_UNEXPECTED - internal media type not set
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSinkFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // media type is only stored in source filter
    // return S_OK here
    // if error, the source filter will detect it anyway
    HRESULT hr = S_OK;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


CTAPIAudioBridgeSourceFilter::CTAPIAudioBridgeSourceFilter(
    IN LPUNKNOWN        pUnk, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSourceFilter(pUnk, phr)
{
    m_fPropSet = FALSE; // allocator properties not set yet
    m_fMtSet = FALSE; // media type not set yet

    // m_last_wall_time, m_last_stream_time not initiated
    m_fClockStarted = FALSE;
    m_fJustBurst = FALSE;

    m_nInputSize = 0;
    m_nOutputSize = 0;
    m_nOutputFree = 0;
    m_pOutputSample = NULL;
}

CTAPIAudioBridgeSourceFilter::~CTAPIAudioBridgeSourceFilter ()
{
    if (m_fMtSet)
    {
        FreeMediaType (m_mt);
    }

    if (NULL != m_pOutputSample)
    {
        m_pOutputSample->Release ();
    }
}

HRESULT CTAPIAudioBridgeSourceFilter::CreateInstance(
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSourceFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIAudioBridgeSourceFilter(NULL, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        BGLOG((BG_ERROR,  
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIAudioBridgeSourceFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSourceFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    ASSERT(!IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

   HRESULT hr;
   if (iPosition == 0)
   {
        AM_MEDIA_TYPE *pmt = NULL;
        hr = m_pOutputPin->GetFormat (&pmt);
        if (FAILED(hr))
            return hr;
        *pMediaType = *pmt;
        FreeMediaType (*pmt);
        free (pmt);
    }
    else
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }
    // END

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIAudioBridgeSourceFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support PCM L16 8KHz samples.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIAudioBridgeSourceFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (!m_fMtSet)
    {
        BGLOG ((BG_ERROR, "%s tries to check media type before setting", __fxName));
        return E_UNEXPECTED;
    }

    // create media type based on stored AM_MEDIA_TYPE
    CMediaType *pmediatype = new CMediaType (m_mt);
    if (NULL == pmediatype)
    {
        BGLOG ((BG_ERROR, "%s failed to new media type class", __fxName));
        return E_OUTOFMEMORY;
    }

    HRESULT hr;
    if (*pMediaType == *pmediatype)
        hr = S_OK;
    else
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        BGLOG ((BG_TRACE, "%s rejects media type class %p", __fxName, pMediaType));
    }

    delete pmediatype;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIAudioBridgeSourceFilter::SendSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the bridge sink filter. Overides the base implementation

Arguments:

    pSample - The media sample object.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    ENTER_FUNCTION ("CTAPIAudioBridgeSourceFilter::SendSample");

    CAutoLock Lock(m_pLock);

    _ASSERT(m_pOutputPin != NULL);

    // we don't deliver anything if the filter is not in running state.
    if (m_State != State_Running) 
    {
        return S_OK;
    }

    // if the sample is the 1st of the burst
    if (S_OK == pSample->IsDiscontinuity ())
    {
        LONGLONG start, end;

        m_fJustBurst = TRUE;
        if (S_OK != (hr = pSample->GetTime (&start, &end)))
        {
            BGLOG ((BG_TRACE, "%s, 1st sample in a burst, GetTime returns %x", __fxName, hr));

            // timestampes stored remain unchange
            return S_OK;
        }
        // else. in NT 5.1, 1st sample has valid timestamp.
    }

    // check if allocator properties is set
    if (!m_fPropSet)
    {
        BGLOG ((BG_ERROR, "%s tries to send sample before setting allocator property", __fxName));
        return E_UNEXPECTED;
    }

    // check if media type is set
    if (!m_fMtSet)
    {
        BGLOG ((BG_ERROR, "%s tries to send sample before setting media type", __fxName));
        return E_UNEXPECTED;
    }

    /*
    * get size info
    */
    // get input sample size and output allocator size
    HRESULT nInputSize, nOutputSize;

    nInputSize = pSample->GetActualDataLength ();
    nOutputSize = m_prop.cbBuffer;

    // 1st run, record size
    if (m_nInputSize == 0 || m_nOutputSize == 0)
    {
        m_nInputSize = nInputSize;
        m_nOutputSize = nOutputSize;
    }

    if (
        m_nInputSize != nInputSize ||
        m_nOutputSize != nOutputSize ||
        m_nInputSize == 0 ||
        m_nOutputSize == 0
        )
    {
        BGLOG ((BG_ERROR, "%s, sample size (%d => %d) or output size (%d => %d) is changed",
              __fxName, m_nInputSize, nInputSize, m_nOutputSize, nOutputSize));
        return E_UNEXPECTED;
    }

    /*
    * get time info
    */
    REFERENCE_TIME wall;

    // wall time
    if (FAILED (hr = m_pClock->GetTime (&wall)))
    {
        BGLOG ((BG_ERROR, "%s failed to get wall time", __fxName));
        return hr;
    }

    // if timestamp not initiated
    if (!m_fClockStarted)
    {
        m_last_stream_time = 0;
        m_last_wall_time = wall;
        m_fClockStarted = TRUE;

        // delta is the time of playing sample:
        m_output_sample_time = nOutputSize * 80000; // s->10000ns, bits->bytes
        m_output_sample_time /= ((WAVEFORMATEX*)m_mt.pbFormat)->wBitsPerSample *
                ((WAVEFORMATEX*)m_mt.pbFormat)->nSamplesPerSec;
        m_output_sample_time *= 1000; // bytes/100ns
    }

    /*
    * calculate new stream time
    */
    if (m_fJustBurst)
    {
        // 1st useful sample after burst
        m_last_stream_time += (wall - m_last_wall_time);
        m_last_wall_time = wall;

        m_fJustBurst = FALSE;

        // clear buffer
        if (NULL != m_pOutputSample)
        {
            m_pOutputSample->Release ();
            m_pOutputSample = NULL;
            m_nOutputFree = 0;
        }
    }

    REFERENCE_TIME end = m_last_stream_time + m_output_sample_time;

    /*
    * case 1: input size == output size
    */
    if (m_nInputSize == m_nOutputSize)
    {
        if (FAILED (pSample->SetTime (&m_last_stream_time, &end)))
        {
            BGLOG ((BG_ERROR, "%s failed to set time", __fxName));
        }

        // adjust time
        m_last_stream_time = end;
        m_last_wall_time += m_output_sample_time;

        // deliver directly
        return m_pOutputPin->Deliver(pSample);
    }

    /*
    * case 2: size differs
    */
    BYTE *pInputBuffer, *pOutputBuffer;

    if (FAILED (hr = pSample->GetPointer (&pInputBuffer)))
    {
        BGLOG ((BG_ERROR, "%s failed to get buffer pointer from input sample %p",
            __fxName, pSample));
        return hr;
    }
    
    LONG nNextPos = 0;

    // old fashion goto
DELIVERY_BUFFER:

    // get delivery buffer if it's null
    if (NULL == m_pOutputSample)
    {
        hr = m_pOutputPin->GetDeliveryBuffer (
            &m_pOutputSample, // media sample **
            NULL, // start time
            NULL, // end time
            AM_GBF_NOTASYNCPOINT // dynamic format changes are not allowed,
            );
        if (FAILED (hr))
        {
            BGLOG ((BG_ERROR, "%s, output pin failed to get delivery buffer. return %d",
                __fxName, hr));
            return hr;
        }

        if (m_pOutputSample->GetSize() < m_nOutputSize)
        {
            // oops, what happend, the size should be the same
            BGLOG ((BG_ERROR, "%s, delivery buffer size %d and output size %d are inconsistent",
                __fxName, m_pOutputSample->GetSize(), m_nOutputSize));
            return E_UNEXPECTED;
        }

        // set size
        if (FAILED (hr = m_pOutputSample->SetActualDataLength (m_nOutputSize)))
        {
            BGLOG ((BG_ERROR, "%s failed to set output sample size", __fxName));
            return hr;
        }
/*
        // set format
        if (FAILED (hr = m_pOutputSample->SetMediaType (&m_mt)))
        {
            BGLOG ((BG_ERROR, "%s failed to set media type for delivery buffer", __fxName));
            return hr;
        }
*/
        // set time
        if (FAILED (hr = m_pOutputSample->SetTime (&m_last_stream_time, &end)))
        {
            BGLOG ((BG_ERROR, "%s failed to set stream time for delivery buffer", __fxName));
            return hr;
        }

        // the whole buffer is free
        m_nOutputFree = m_nOutputSize;
    }

    // get buffer in output sample
    if (FAILED (hr = m_pOutputSample->GetPointer (&pOutputBuffer)))
    {
        BGLOG ((BG_ERROR, "%s failed to get buffer pointer from output sample %p",
            __fxName, m_pOutputSample));

        // release output sample
        m_pOutputSample->Release ();
        m_pOutputSample = NULL;
        m_nOutputFree = 0;

        return hr;
    }

    // if input buffer is smaller than free output buffer
    // copy input to output and return
    if (m_nInputSize-nNextPos < m_nOutputFree)
    {
        CopyMemory (
            (PVOID)(pOutputBuffer + (m_nOutputSize - m_nOutputFree)),
            (PVOID)(pInputBuffer + nNextPos),
            (DWORD)(m_nInputSize - nNextPos)
            );

        // reduce free buffer size
        m_nOutputFree -= m_nInputSize - nNextPos;

        return S_OK;
    }

    // else: input buffer is greater or equal to free output buffer
    CopyMemory (
        (PVOID)(pOutputBuffer + (m_nOutputSize - m_nOutputFree)),
        (PVOID)(pInputBuffer + nNextPos),
        (DWORD)(m_nOutputFree)
        );

    // now output sample is full, deliver it
    if (FAILED (hr = m_pOutputPin->Deliver (m_pOutputSample)))
    {
        BGLOG ((BG_ERROR, "%s failed to deliver copied sample. return %x", __fxName, hr));

        // clear sample
        m_pOutputSample->Release ();
        m_pOutputSample = NULL;
        m_nOutputFree = 0;

        return hr;
    }

    // adjust next position in input buffer
    nNextPos += m_nOutputFree;

    // clear output sample since it was deliverd
    m_pOutputSample->Release ();
    m_pOutputSample = NULL;
    m_nOutputFree = 0;

    // adjust time
    m_last_stream_time = end;
    m_last_wall_time += m_output_sample_time;

    // check if nothing left
    if (nNextPos == m_nInputSize)
        return S_OK;

    // there is more in input buffer
    goto DELIVERY_BUFFER;
}

HRESULT CTAPIAudioBridgeSourceFilter::GetAllocatorProperties (OUT ALLOCATOR_PROPERTIES *pprop)
/*++

Routine Description:

    Returns the allocator properties

Arguments:

    pprop -
        The pointer to an ALLOCATOR_PROPERTIES

Return Value:

    E_POINTER -
        if pprop is NULL

    S_OK

--*/
{
    ENTER_FUNCTION ("CTAPIAudioBridgeSourceFilter::GetAllocatorProperties");
    _ASSERT(pprop);

    if (!pprop)
        return E_POINTER;

    if (!m_fPropSet)
    {
        BGLOG ((BG_INFO, "%s retrieves allocator properties before setting", __fxName));
        // return default value anyway
        // buffer size = (16bits / 8bits) * 8khz * 30 ms = 480 bytes
        pprop->cBuffers = 1;
        pprop->cbBuffer = 480; // default
        pprop->cbAlign = 0;
        pprop->cbPrefix = 0;
        return S_OK;
    }

    // properties were set
    pprop->cBuffers = m_prop.cBuffers;
    pprop->cbBuffer = m_prop.cbBuffer;
    pprop->cbAlign = m_prop.cbAlign;
    pprop->cbPrefix = m_prop.cbPrefix;
    return S_OK;
}

HRESULT CTAPIAudioBridgeSourceFilter::SuggestAllocatorProperties (IN const ALLOCATOR_PROPERTIES *pprop)
/*++

Routine Description:

    Asks the pin to use the allocator buffer properties

Arguments:

    pprop -
        The pointer to an ALLOCATOR_PROPERTIES

Return Value:

    E_POINTER

    S_OK

--*/
{
    _ASSERT (pprop);

    if (!pprop)
        return E_POINTER;

    m_prop.cBuffers = pprop->cBuffers;
    m_prop.cbBuffer = pprop->cbBuffer;
    m_prop.cbAlign = pprop->cbAlign;
    m_prop.cbPrefix = pprop->cbPrefix;
    m_fPropSet = TRUE;

    return S_OK;
}

HRESULT CTAPIAudioBridgeSourceFilter::GetFormat (OUT AM_MEDIA_TYPE **ppmt)
/*++

Routine Description:

    Retrieves the stream format

Arguments:

    ppmt -
        Address of a pointer to an AM_MEDIA_TYPE structure

Return Value:

    E_PONTER

    E_OUTOFMEMORY

    HRESULT of SetFormat

    S_OK

--*/
{
    ENTER_FUNCTION ("CTAPIAudioBridgeSourceFilter::GetFormat");

    _ASSERT (ppmt);
    if (NULL == ppmt)
        return E_POINTER;

    if (NULL != *ppmt)
        BGLOG ((BG_INFO, "is media type structure freed when passed in %s?", __fxName));

    *ppmt = new AM_MEDIA_TYPE;
    if (NULL == *ppmt)
    {
        BGLOG ((BG_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    if (!m_fMtSet)
    {
        BGLOG ((BG_INFO, "%s retrieves media type before setting. Default is to set.", __fxName));

        // st format
        HRESULT hr;
        AM_MEDIA_TYPE mt;
        WAVEFORMATEX wfx;

        wfx.wFormatTag          = WAVE_FORMAT_PCM;
        wfx.wBitsPerSample      = 16;
        wfx.nChannels           = 1;
        wfx.nSamplesPerSec      = 8000;
        wfx.nBlockAlign         = wfx.wBitsPerSample * wfx.nChannels / 8;
        wfx.nAvgBytesPerSec     = ((DWORD) wfx.nBlockAlign * wfx.nSamplesPerSec);
        wfx.cbSize              = 0;

        mt.majortype            = MEDIATYPE_Audio;
        mt.subtype              = MEDIASUBTYPE_PCM;
        mt.bFixedSizeSamples    = TRUE;
        mt.bTemporalCompression = FALSE;
        mt.lSampleSize          = 0;
        mt.formattype           = FORMAT_WaveFormatEx;
        mt.pUnk                 = NULL;
        mt.cbFormat             = sizeof(WAVEFORMATEX);
        mt.pbFormat             = (BYTE*)&wfx;

        hr = SetFormat (&mt);
        if (FAILED (hr))
        {
            BGLOG ((BG_ERROR, "%s, failed to set default format", __fxName));
            return hr;
        }
    }

    CopyMediaType (*ppmt, &m_mt);

    return S_OK;
}

HRESULT CTAPIAudioBridgeSourceFilter::SetFormat (IN AM_MEDIA_TYPE *pmt)
/*++

Routine Description:

    Sets the stream format

Arguments:

    pmt -
        Pointer to an AM_MEDIA_TYPE structure

Return Value:

    E_POINTER

    S_OK

--*/
{
    _ASSERT (pmt);

    if (NULL == pmt)
        return E_POINTER;

    CopyMediaType (&m_mt, pmt);
    m_fMtSet = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgbase.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgbase.cpp

Abstract:

    Implementation of the base classes of the bridge filters.

Author:

    Mu Han (muhan) 11/16/1998

--*/

#include "stdafx.h"

CTAPIBridgeSinkInputPin::CTAPIBridgeSinkInputPin(
    IN CTAPIBridgeSinkFilter *pFilter,
    IN CCritSec *pLock,
    OUT HRESULT *phr
    ) 
    : CBaseInputPin(
        NAME("CTAPIBridgeSinkInputPin"),
        pFilter,                   // Filter
        pLock,                     // Locking
        phr,                       // Return code
        L"Input"                   // Pin name
        )
{
}

#define MTU_SIZE 1450

STDMETHODIMP CTAPIBridgeSinkInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *pProperties
    )
/*++

Routine Description:

    This is a hint to the upstream RTP source filter about the buffers to 
    allocate.

Arguments:

    pProperties -
        Pointer to the allocator properties.

Return Value:

    S_OK - success.

    E_FAIL - the buffer size can't fulfill our requirements.
--*/
{
    _ASSERT(pProperties);

    if (!pProperties)
        return E_POINTER;

    pProperties->cBuffers = 8;
    pProperties->cbAlign = 0;
    pProperties->cbPrefix = 0;
    pProperties->cbBuffer = MTU_SIZE;

    return NOERROR;
}

inline STDMETHODIMP CTAPIBridgeSinkInputPin::Receive(IN IMediaSample *pSample) 
{
    return ((CTAPIBridgeSinkFilter*)m_pFilter)->ProcessSample(pSample);
}

inline HRESULT CTAPIBridgeSinkInputPin::GetMediaType(IN int iPosition, IN CMediaType *pMediaType)
{
    return ((CTAPIBridgeSinkFilter*)m_pFilter)->GetMediaType(iPosition, pMediaType);
}

inline HRESULT CTAPIBridgeSinkInputPin::CheckMediaType(IN const CMediaType *pMediaType)
{
    return ((CTAPIBridgeSinkFilter*)m_pFilter)->CheckMediaType(pMediaType);
}

CTAPIBridgeSourceOutputPin::CTAPIBridgeSourceOutputPin(
    IN CTAPIBridgeSourceFilter *pFilter,
    IN CCritSec *pLock,
    OUT HRESULT *phr
    )
    : CBaseOutputPin(
        NAME("CTAPIBridgeSourceOutputPin"),
        pFilter,                   // Filter
        pLock,                     // Locking
        phr,                       // Return code
        L"Output"                  // Pin name
        )
{
}

CTAPIBridgeSourceOutputPin::~CTAPIBridgeSourceOutputPin ()
{
}

STDMETHODIMP
CTAPIBridgeSourceOutputPin::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    Overrides CBaseOutputPin::NonDelegatingQueryInterface().
    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. 

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    HRESULT hr;

    if (riid == __uuidof(IAMBufferNegotiation)) {

        return GetInterface(static_cast<IAMBufferNegotiation*>(this), ppv);
    }
    else if (riid == __uuidof(IAMStreamConfig)) {

        return GetInterface(static_cast<IAMStreamConfig*>(this), ppv);
    }
    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
} 

inline HRESULT CTAPIBridgeSourceOutputPin::GetMediaType(IN int iPosition, IN CMediaType *pMediaType)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->GetMediaType(iPosition, pMediaType);
}

inline HRESULT CTAPIBridgeSourceOutputPin::CheckMediaType(IN const CMediaType *pMediaType)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->CheckMediaType(pMediaType);
}

HRESULT CTAPIBridgeSourceOutputPin::DecideBufferSize(
    IMemAllocator *pAlloc,
    ALLOCATOR_PROPERTIES *pProperties
    )
/*++

Routine Description:

    This fuction is called during the process of deciding an allocator. We tell
    the allocator what we want. It is also a chance to find out what the 
    downstream pin wants when we don't have a preference.

Arguments:

    pAlloc -
        Pointer to a IMemAllocator interface.

    pProperties -
        Pointer to the allocator properties.

Return Value:

    S_OK - success.

    E_FAIL - the buffer size can't fulfill our requirements.
--*/
{
    ENTER_FUNCTION("CTAPIBridgeSourceOutputPin::DecideBufferSize");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    ALLOCATOR_PROPERTIES Actual;
    
    pProperties->cbBuffer = 1024;
    pProperties->cBuffers = 4;

    HRESULT hr = pAlloc->SetProperties(pProperties, &Actual);

    if (FAILED(hr))
    {
        return hr;
    }

    *pProperties = Actual;
    return S_OK;
}

HRESULT CTAPIBridgeSourceOutputPin::GetAllocatorProperties (OUT ALLOCATOR_PROPERTIES *pprop)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->GetAllocatorProperties (pprop);
}


HRESULT CTAPIBridgeSourceOutputPin::SuggestAllocatorProperties (IN const ALLOCATOR_PROPERTIES *pprop)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->SuggestAllocatorProperties (pprop);
}

HRESULT CTAPIBridgeSourceOutputPin::GetFormat (OUT AM_MEDIA_TYPE **ppmt)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->GetFormat (ppmt);
}

HRESULT CTAPIBridgeSourceOutputPin::SetFormat (IN AM_MEDIA_TYPE *pmt)
{
    return ((CTAPIBridgeSourceFilter*)m_pFilter)->SetFormat (pmt);
}

HRESULT CTAPIBridgeSourceOutputPin::GetNumberOfCapabilities (OUT int *piCount, OUT int *piSize)
/*++

Routine Description:

    Retrieves the number of stream capabilities structures for the compressor

Arguments:

    piCount -
        Pointer to the number of stream capabilites structures

    piSize -
        Pointer to the size of the configuration structure.

Return Value:

    TBD

--*/
{
    ENTER_FUNCTION ("CTAPIBridgeSourceOutputPin::GetNumberOfCapabilities");
    BGLOG ((BG_ERROR, "%s is not implemented", __fxName));

    return E_NOTIMPL;
}

HRESULT CTAPIBridgeSourceOutputPin::GetStreamCaps (IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, BYTE *pSCC)
/*++

Routine Description:

    Obtains capabilites of a stream depending on which type of structure is
    pointed to in the pSCC parameter

Arguments:

    iIndex -
        Index to the desired media type and capablity pair

    ppmt -
        Address of a pointer to an AM_MEDIA_TYPE structure

    pSCC -
        Pointer to a stream configuration structure

Return Value:

    TBD

--*/
{
    ENTER_FUNCTION ("CTAPIBridgeSourceOutputPin::GetStreamCaps");
    BGLOG ((BG_ERROR, "%s is not implemented", __fxName));

    return E_NOTIMPL;
}

CTAPIBridgeSinkFilter::CTAPIBridgeSinkFilter(
    IN  LPUNKNOWN pUnk, 
    IN IDataBridge *    pIDataBridge, 
    OUT HRESULT *phr
    ) : 
    CBaseFilter(
        NAME("CTAPIBridgeSinkFilter"), 
        pUnk, 
        &m_Lock, 
        __uuidof(TAPIBridgeSinkFilter)
        ),
    m_pInputPin(NULL)
{
    _ASSERT(pIDataBridge != NULL);

    m_pIDataBridge = pIDataBridge;
    m_pIDataBridge->AddRef();
}

CTAPIBridgeSinkFilter::~CTAPIBridgeSinkFilter()
{
    _ASSERT(m_pIDataBridge != NULL);

    m_pIDataBridge->Release();

    if (m_pInputPin)
    {
        delete m_pInputPin;
    }
}


int CTAPIBridgeSinkFilter::GetPinCount()
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPinCount().
    Get the total number of pins on this filter. 

Arguments:

    Nothing.

Return Value:

    The number of pins.

--*/
{
    // There is only one pin on this filter.
    return 1;
}

CBasePin * CTAPIBridgeSinkFilter::GetPin(
    int n
    )
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPin().
    Get the pin object at position n. n is zero based.

Arguments:

    n -
        The index of the pin, zero based.

Return Value:

    Returns a pointer to the pin object if the index is valid. Otherwise,
    NULL is returned. Note: the pointer doesn't add refcount.

--*/
{
    ENTER_FUNCTION("CTAPIBridgeSinkFilter::GetPin");

    BGLOG((BG_TRACE, 
        "%s, pin number:%d", __fxName, n));

    if (n != 0)
    {
        // there is only one pin on this filter.
        return NULL;
    }

    HRESULT hr;

    CAutoLock Lock(m_pLock);

    if (m_pInputPin == NULL)
    {
        hr = S_OK; // hr may not be set in constructor
        m_pInputPin = new CTAPIBridgeSinkInputPin(this, &m_Lock, &hr);
    
        if (m_pInputPin == NULL) 
        {
            BGLOG((BG_ERROR, "%s, out of memory.", __fxName));
            return NULL;
        }

        // If there was anything failed during the creation of the pin, delete it.
        if (FAILED(hr))
        {
            delete m_pInputPin;
            m_pInputPin = NULL;

            BGLOG((BG_ERROR, "%s, create pin failed. hr=%x.", __fxName, hr));
            return NULL;
        }
    }

    return m_pInputPin;
}

HRESULT CTAPIBridgeSinkFilter::ProcessSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the input pin. This method just pass it on to the
    bridge source filter's IDataBridge interface

Arguments:

    pSample - The media sample object.

Return Value:

    HRESULT.

--*/
{
    _ASSERT(m_pIDataBridge != NULL);

    return m_pIDataBridge->SendSample(pSample);
}



CTAPIBridgeSourceFilter::CTAPIBridgeSourceFilter(
    IN  LPUNKNOWN pUnk, 
    OUT HRESULT *phr
    ) : 
    CBaseFilter(
        NAME("CTAPIBridgeSourceFilter"), 
        pUnk, 
        &m_Lock, 
        __uuidof(TAPIBridgeSourceFilter)
        ),
    m_pOutputPin(NULL)
{
}

CTAPIBridgeSourceFilter::~CTAPIBridgeSourceFilter()
{
    if (m_pOutputPin)
    {
        delete m_pOutputPin;
    }
}

STDMETHODIMP
CTAPIBridgeSourceFilter::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    Overrides CBaseFilter::NonDelegatingQueryInterface().
    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. 

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IDataBridge)) {

        return GetInterface(static_cast<IDataBridge*>(this), ppv);
    }
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
} 

int CTAPIBridgeSourceFilter::GetPinCount()
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPinCount().
    Get the total number of pins on this filter. 

Arguments:

    Nothing.

Return Value:

    The number of pins.

--*/
{
    // There is only one pin on this filter.
    return 1;
}

CBasePin * CTAPIBridgeSourceFilter::GetPin(
    int n
    )
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPin().
    Get the pin object at position n. n is zero based.

Arguments:

    n - The index of the pin, zero based.

Return Value:

    Returns a pointer to the pin object if the index is valid. Otherwise,
    NULL is returned. Note: the pointer doesn't add refcount.

--*/
{
    ENTER_FUNCTION("CTAPIBridgeSourceFilter::GetPin");

    BGLOG((BG_TRACE, 
        "%s, pin number:%d", __fxName, n));

    if (n != 0)
    {
        // there is only one pin on this filter.
        return NULL;
    }

    HRESULT hr;

    CAutoLock Lock(m_pLock);

    if (m_pOutputPin == NULL)
    {
        hr = S_OK; // hr may not be set in constructor
        m_pOutputPin = new CTAPIBridgeSourceOutputPin(this, &m_Lock, &hr);
    
        if (m_pOutputPin == NULL) 
        {
            BGLOG((BG_ERROR, "%s, out of memory.", __fxName));
            return NULL;
        }

        // If there was anything failed during the creation of the pin, delete it.
        if (FAILED(hr))
        {
            delete m_pOutputPin;
            m_pOutputPin = NULL;

            BGLOG((BG_ERROR, "%s, create pin failed. hr=%x.", __fxName, hr));
            return NULL;
        }
    }

    return m_pOutputPin;
}

// override GetState to report that we don't send any data when paused, so
// renderers won't starve expecting that
//
STDMETHODIMP CTAPIBridgeSourceFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE;
    else
        return S_OK;
}


HRESULT CTAPIBridgeSourceFilter::SendSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the bridge sink filter. The base implementation just
    deliver it directly to the next filter.

Arguments:

    pSample - The media sample object.

Return Value:

    HRESULT.

--*/
{
    CAutoLock Lock(m_pLock);
    
    // we don't deliver anything if the filter is not in running state.
    if (m_State != State_Running) 
    {
        return S_OK;
    }

    _ASSERT(m_pOutputPin != NULL);

    return m_pOutputPin->Deliver(pSample);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgdebug.h ===
/*++

Module Name

    bgdebug.h

Description

    Defines functions used for debugging

Note

    Revised based on msplog.h

--*/

#ifndef _BGDEBUG_H
#define _BGDEBUG_H

    #include <rtutils.h>

    #define BG_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define BG_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define BG_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define BG_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define BG_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL BGLogRegister(LPCTSTR szName);
    void BGLogDeRegister();
    void BGLogPrint(DWORD dwDbgLevel, LPCSTR DbgMessage, ...);

#ifdef BGDEBUG

    #define BGLOGREGISTER(arg) BGLogRegister(arg)
    #define BGLOGDEREGISTER() BGLogDeRegister()
    #define BGLOG(arg) BGLogPrint arg

#else // BGDEBUG

    #define BGLOGREGISTER(arg)
    #define BGLOGDEREGISTER()
    #define BGLOG(arg)

#endif // BGDEBUG

#endif // _BGDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgbase.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgbase.h

Abstract:

    Definitions of the base classes of the bridge filters.

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BGBASE_H_
#define _BGBASE_H_

class CTAPIBridgeSinkInputPin;
class CTAPIBridgeSourceOutputPin;
class CTAPIBridgeSinkFilter;
class CTAPIBridgeSourceFilter;

class CTAPIBridgeSinkInputPin : 
    public CBaseInputPin
{
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSinkInputPin(
        IN CTAPIBridgeSinkFilter *pFilter,
        IN CCritSec *pLock,
        OUT HRESULT *phr
        );
    
    // override CBaseInputPin methods.
    STDMETHOD (GetAllocatorRequirements)(OUT ALLOCATOR_PROPERTIES *pProperties);

    STDMETHOD (ReceiveCanBlock) () { return S_FALSE; }

    STDMETHOD (Receive) (IN IMediaSample *pSample);

    // CBasePin stuff
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);
};

    // the interface to pass dat from the sink filter to the source filter.
interface DECLSPEC_UUID("afb2050e-1ecf-4a97-8753-54e78b6c7bc4") DECLSPEC_NOVTABLE
IDataBridge : public IUnknown
{
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        ) PURE;
};

struct DECLSPEC_UUID("8cdf1491-b5ab-49fb-b51f-eda6043d11be") TAPIBridgeSinkFilter;

class DECLSPEC_NOVTABLE CTAPIBridgeSinkFilter : 
    public CBaseFilter
{
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSinkFilter(
        IN LPUNKNOWN        pUnk, 
        IN IDataBridge *    pIDataBridge, 
        OUT HRESULT *       phr
        );

    ~CTAPIBridgeSinkFilter();

    // Pin enumeration functions.
    CBasePin * GetPin(int n);
    int GetPinCount();
    
    // methods called by the input pin.
    virtual HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType) PURE;
    virtual HRESULT CheckMediaType(IN const CMediaType *pMediatype) PURE;
    virtual HRESULT ProcessSample(IN IMediaSample *pSample);

protected:

    // The lock for the filter and the pin.
    CCritSec                    m_Lock;

    // The filter's input pin.
    CTAPIBridgeSinkInputPin *   m_pInputPin;
    IDataBridge *               m_pIDataBridge;
};


class CTAPIBridgeSourceOutputPin : 
    public CBaseOutputPin,
    public IAMBufferNegotiation,
    public IAMStreamConfig
{
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSourceOutputPin(
        IN CTAPIBridgeSourceFilter *pFilter,
        IN CCritSec *pLock,
        OUT HRESULT *phr
        );

    ~CTAPIBridgeSourceOutputPin ();

    STDMETHOD (NonDelegatingQueryInterface) (
        IN REFIID  riid,
        OUT PVOID*  ppv
        );

    // CBasePin stuff
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediaType);

    // CBaseOutputPin stuff
    HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
        );

    // IAMBufferNegotiation stuff
    STDMETHOD (SuggestAllocatorProperties) (IN const ALLOCATOR_PROPERTIES *pprop);
    STDMETHOD (GetAllocatorProperties) (OUT ALLOCATOR_PROPERTIES *pprop);

    // IAMStreamConfig stuff
    STDMETHOD (SetFormat) (IN AM_MEDIA_TYPE *pmt);
    STDMETHOD (GetFormat) (OUT AM_MEDIA_TYPE **ppmt);
    STDMETHOD (GetNumberOfCapabilities) (OUT int *piCount, OUT int *piSize);
    STDMETHOD (GetStreamCaps) (IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, BYTE *pSCC);

};

struct DECLSPEC_UUID("9a712df9-50d0-4ca3-842e-6dc3d3b4b5a8") TAPIBridgeSourceFilter;

class DECLSPEC_NOVTABLE CTAPIBridgeSourceFilter : 
    public CBaseFilter,
    public IDataBridge
    {
public:
    DECLARE_IUNKNOWN

    CTAPIBridgeSourceFilter(
        IN LPUNKNOWN pUnk, 
        OUT HRESULT *phr
        );

    ~CTAPIBridgeSourceFilter();

    STDMETHOD (NonDelegatingQueryInterface) (
        IN REFIID  riid,
        OUT PVOID*  ppv
        );

    // Pin enumeration functions.
    CBasePin * GetPin(int n);
    int GetPinCount();

    // Overrides CBaseFilter methods.
    STDMETHOD (GetState) (DWORD dwMSecs, FILTER_STATE *State);

    // methods called by the output pins.
    virtual HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    virtual HRESULT CheckMediaType(IN const CMediaType *pMediatype);

    // method for IDataBridge
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        );

    // audio related methods are moved into CTAPIAudioBridgeSourceFilter
    // IAMBufferNegotiation stuff
    STDMETHOD (SuggestAllocatorProperties) (IN const ALLOCATOR_PROPERTIES *pprop) {return E_NOTIMPL;};
    STDMETHOD (GetAllocatorProperties) (OUT ALLOCATOR_PROPERTIES *pprop) {return E_NOTIMPL;};

    // IAMStreamConfig stuff
    STDMETHOD (SetFormat) (IN AM_MEDIA_TYPE *pmt) {return E_NOTIMPL;};
    STDMETHOD (GetFormat) (OUT AM_MEDIA_TYPE **ppmt) {return E_NOTIMPL;};

protected:

    // The lock for the filter and the pin.
    CCritSec                m_Lock;

    // The filter's output pin.
    CTAPIBridgeSourceOutputPin *   m_pOutputPin;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgdebug.cpp ===
/*++

Module Name

    bgdebug.cpp

Description

    Implements functions used for debugging

Note

    Revised based on msplog.cpp

--*/

#include "stdafx.h"
#include <stdio.h>

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwDebuggerMask      = 0;


BOOL BGLogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
		DWORD      dwDataSize = sizeof (DWORD);
		DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

void BGLogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void BGLogPrint(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    static char * message[24] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        va_list arglist;
        va_start(arglist, lpszFormat);
        TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
        va_end(arglist);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgvideo.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgvideo.h

Abstract:

    Definitions for the video bridge filters

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BGVIDEO_H_
#define _BGVIDEO_H_


class CTAPIVideoBridgeSinkFilter :
    public CTAPIBridgeSinkFilter 
{
public:

    CTAPIVideoBridgeSinkFilter(
        IN LPUNKNOWN        pUnk, 
        IN IDataBridge *    pIDataBridge, 
        OUT HRESULT *       phr
        );

    static HRESULT CreateInstance(
        IN IDataBridge *    pIDataBridge, 
        OUT IBaseFilter ** ppIBaseFilter
        );

    // methods called by the input pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);
};


class CTAPIVideoBridgeSourceFilter : 
    public CTAPIBridgeSourceFilter
    {
public:
    CTAPIVideoBridgeSourceFilter(
        IN LPUNKNOWN pUnk, 
        OUT HRESULT *phr
        );

    static HRESULT CreateInstance(
        OUT IBaseFilter ** ppIBaseFilter
        );

    // Overrides CBaseFilter methods.
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // override the IDataBridge methods.
    STDMETHOD (SendSample) (
        IN  IMediaSample *pSample
        );

    // methods called by the output pin.
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);

private:
    DWORD   m_dwSSRC;
    long    m_lWaitTimer;
    BOOL    m_fWaitForIFrame;
};

// switch anyway if we don't have a I-Frame in 60 seconds.
const I_FRAME_TIMER = 60;

/*  This is the RTP header according to RFC 1889
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

typedef struct 
{                             
    WORD            CSRCCount:4;
    WORD            HeaderExtensionFlag:1;
    WORD            PaddingFlag:1;
    WORD            VersionType:2;
    WORD            PayLoadType:7;
    WORD            MarkerBit:1;

    WORD            wSequenceNumber;
    DWORD           dwTimeStamp;
    DWORD           dwSSRC;

} RTP_HEADER;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bgvideo.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgvideo.cpp

Abstract:

    Implementation of the Video bridge filters.

Author:

    Mu Han (muhan) 11/16/1998

--*/

#include "stdafx.h"

CTAPIVideoBridgeSinkFilter::CTAPIVideoBridgeSinkFilter(
    IN LPUNKNOWN        pUnk, 
    IN IDataBridge *    pIDataBridge, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSinkFilter(pUnk, pIDataBridge, phr)
{
}

HRESULT CTAPIVideoBridgeSinkFilter::CreateInstance(
    IN IDataBridge *    pIDataBridge, 
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSinkFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIVideoBridgeSinkFilter(NULL, pIDataBridge, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 0, 
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIVideoBridgeSinkFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSinkFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    ASSERT(!IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    HRESULT hr;

    if (iPosition == 0)
    {
        pMediaType->majortype = __uuidof(MEDIATYPE_RTP_Single_Stream);
        pMediaType->subtype = GUID_NULL;
        hr = S_OK;
    }
    else
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIVideoBridgeSinkFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSinkFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // H.263 is not published, ignore checking here
    HRESULT hr = S_OK;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


CTAPIVideoBridgeSourceFilter::CTAPIVideoBridgeSourceFilter(
    IN LPUNKNOWN        pUnk, 
    OUT HRESULT *       phr
    ) 
    : CTAPIBridgeSourceFilter(pUnk, phr),
      m_dwSSRC(0),
      m_lWaitTimer(I_FRAME_TIMER),
      m_fWaitForIFrame(FALSE)
{
}

HRESULT CTAPIVideoBridgeSourceFilter::CreateInstance(
    OUT IBaseFilter ** ppIBaseFilter
    )
/*++

Routine Description:

    This method create a instance of the bridge's sink filter.

Arguments:

    ppIBaseFilter - the returned filter interface pointer.

Return Value:

    E_OUTOFMEMORY - no memory for the new object.

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::CreateInstance");

    BGLOG((BG_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;
    CUnknown* pUnknown = new CTAPIVideoBridgeSourceFilter(NULL, &hr);
                
    if (pUnknown == NULL) 
    {
        hr = E_OUTOFMEMORY;
        DbgLog((LOG_ERROR, 0, 
            "%s, out of memory creating the filter", 
            __fxName));
    }
    else if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, 
            "%s, the filter's constructor failed, hr:%d", 
            __fxName, hr));

        delete pUnknown;
    }
    else
    {
        pUnknown->NonDelegatingAddRef();

        hr = pUnknown->NonDelegatingQueryInterface(
            __uuidof(IBaseFilter), (void **)ppIBaseFilter
            );

        pUnknown->NonDelegatingRelease();
    }

    BGLOG((BG_TRACE, 
        "%s, returning:%p, hr:%x", __fxName, *ppIBaseFilter, hr));

    return hr;
} 

HRESULT CTAPIVideoBridgeSourceFilter::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    Get the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::GetMediaType");

    BGLOG((BG_TRACE, 
        "%s, iPosition:%d, pMediaType:%p", 
        __fxName, iPosition, pMediaType));

    ASSERT(!IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    HRESULT hr;
    
    if (iPosition == 0)
    {
        pMediaType->majortype = __uuidof(MEDIATYPE_RTP_Single_Stream);
        pMediaType->subtype = GUID_NULL;
        hr = S_OK;
    }
    else
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}


HRESULT CTAPIVideoBridgeSourceFilter::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    Check the media type that this filter wants to support. Currently we
    only support RTP H263 data.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::CheckMediaType");

    BGLOG((BG_TRACE, 
        "%s, pMediaType:%p", __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // media type H.263 is not published, ignore checking
    HRESULT hr = S_OK;

    BGLOG((BG_TRACE, "%s returns %d", __fxName, hr));

    return hr;
}

BOOL IsIFrame(IN const BYTE * pPacket, IN long lPacketLength)
{
    BYTE *pH263PayloadHeader = (BYTE*)(pPacket + sizeof(RTP_HEADER));

    // Header in mode A
    // 0                   1                   2                   3
    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //|F|P|SBIT |EBIT | SRC | R       |I|A|S|DBQ| TRB |    TR         |
    //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    // If I is 1, it is a key frame.

    return (BOOL)(pH263PayloadHeader[2] & 0x80);
}

STDMETHODIMP CTAPIVideoBridgeSourceFilter::Run(REFERENCE_TIME tStart)
/*++

Routine Description:

    start the filter 

Arguments:

    Nothing.

Return Value:

    S_OK.
--*/
{
    m_dwSSRC = 0;
    m_fWaitForIFrame = FALSE;
    m_lWaitTimer = 0;

    return CBaseFilter::Run(tStart);
}

HRESULT CTAPIVideoBridgeSourceFilter::SendSample(
    IN IMediaSample *pSample
    )
/*++

Routine Description:

    Process a sample from the bridge sink filter. We need to look for I-frames
    when the SSRC changes.

Arguments:

    pSample - The media sample object. Assumption: it has to contain an RTP
        packet that has H.263 data in it.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CTAPIVideoBridgeSourceFilter::SendSample");

    CAutoLock Lock(m_pLock);
    
    // we don't deliver anything if the filter is not in running state.
    if (m_State != State_Running) 
    {
        return S_OK;
    }

    ASSERT(pSample != NULL);

    BYTE *pPacket;
    HRESULT hr;

    if (FAILED (hr = pSample->GetPointer (&pPacket)))
    {
        BGLOG ((BG_ERROR, "%s failed to get buffer pointer from input sample %p",
            __fxName, pSample));
        return hr;
    }
   
    long lPacketSize = pSample->GetActualDataLength();
    const long H263PayloadHeaderLength = 4;

    if (lPacketSize < sizeof(RTP_HEADER) + H263PayloadHeaderLength)
    {
        BGLOG ((BG_ERROR, "%s get a bad RTP packet %p",
            __fxName, pSample));
        return E_UNEXPECTED;
    }

    RTP_HEADER *pRTPHeader = (RTP_HEADER *)pPacket;

    if (m_dwSSRC == 0)
    {
        m_dwSSRC = pRTPHeader->dwSSRC;
    }
    else if (m_dwSSRC != pRTPHeader->dwSSRC)
    {
        m_dwSSRC = pRTPHeader->dwSSRC;
        BGLOG ((BG_TRACE, "%s new SSRC detected", __fxName, m_dwSSRC));

        // the source changed, we need to wait for an I-frame
        if (IsIFrame(pPacket, lPacketSize))
        {
            // we got an I-Frame
            m_fWaitForIFrame = FALSE;
            BGLOG ((BG_TRACE, "%s switched to %x", __fxName, m_dwSSRC));
        }
        else
        {
            m_fWaitForIFrame = TRUE;
            m_lWaitTimer = I_FRAME_TIMER;

            // discard the frame.
            return S_FALSE;
        }

    }
    else if (m_fWaitForIFrame)
    {
        if (IsIFrame(pPacket, lPacketSize))
        {
            // we got an I-Frame
            m_fWaitForIFrame = FALSE;
            BGLOG ((BG_TRACE, "%s switched to %x", __fxName, m_dwSSRC));
        }
        else
        {
            // this is not an I frame,
            m_lWaitTimer --;
            if (m_lWaitTimer > 0)
            {
                // discard the frame.
                return S_FALSE;
            }
            BGLOG ((BG_TRACE, "%s switched to because of timeout %x", 
                __fxName, m_dwSSRC));
        }
    }


    _ASSERT(m_pOutputPin != NULL);
    return m_pOutputPin->Deliver(pSample);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bridge.cpp ===
// bridge.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f bridgeps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
//#include "bridge.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

//#include "bridge_i.c"
#include "ConfBridge.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(__uuidof(ConfBridge), CConfBridge)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        BGLOGREGISTER(_T("bridge"));
        _Module.Init(ObjectMap, hInstance); //@@, &LIBID_BRIDGELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        BGLOGDEREGISTER();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\confbridge.h ===
// ConfBridge.h : Declaration of the CConfBridge

#ifndef __CONFBRIDGE_H_
#define __CONFBRIDGE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CConfBridge
class ATL_NO_VTABLE CConfBridge : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CConfBridge, &__uuidof(ConfBridge)>,
	public IConfBridge
{

public:

DECLARE_REGISTRY_RESOURCEID(IDR_CONFBRIDGE)
DECLARE_PROTECT_FINAL_CONSTRUCT()

public:

BEGIN_COM_MAP(CConfBridge)
	COM_INTERFACE_ENTRY(IConfBridge)
END_COM_MAP()

	CConfBridge()
	{
	}

    STDMETHOD (CreateBridgeTerminal) (
        long lMediaType,
        ITTerminal **ppTerminal
    );

};

#endif //__CONFBRIDGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\confbridge.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ConfBridge.cpp

Abstract:

    Implementations for bridge terminal creation

Author:

    Qianbo Huai (qhuai) 1/21/2000

--*/

#include "stdafx.h"
#include <bridge.h>
#include "ConfBridge.h"

/*//////////////////////////////////////////////////////////////////////////////
    Creates bridge terminal
////*/
STDMETHODIMP
CConfBridge::CreateBridgeTerminal (
    long lMediaType,
    ITTerminal **ppTerminal
)
{
    ENTER_FUNCTION("CIPConfBridge::CreateBridgeTerminal");
    BGLOG((BG_TRACE, "%s entered", __fxName)); 

    if (IsBadWritePtr(ppTerminal, sizeof(void *)))
    {
        LOG ((BG_ERROR, "%x receives bad write pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr;

    // Make sure we support the requested media type.
    if ( ! IsValidSingleMediaType( (DWORD) lMediaType,
        TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO ) )
    {
        BGLOG((BG_ERROR, "%s, bad media type %d", __fxName, lMediaType));
        return E_INVALIDARG;
    }

    // create the bridge terminal with the desired media type.

    ITTerminal *pTerminal;
    hr = CIPConfBridgeTerminal::CreateTerminal(
        (DWORD)lMediaType,
        NULL, // msp address
        &pTerminal
        );

    if (FAILED (hr))
    {
        BGLOG ((BG_ERROR, "%s, Create bridge terminal failed. hr=%x", __fxName, hr));
        return E_INVALIDARG;
    }

    *ppTerminal = pTerminal;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bridge.rc
//
#define IDS_PROJNAME                    100
#define IDR_CONFBRIDGE                  101
#define IDS_AUDBGNAME                   101
#define IDS_VIDBGNAME                   102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__78E7EB26_CAE8_4888_BE56_540011CEB8F6__INCLUDED_)
#define AFX_STDAFX_H__78E7EB26_CAE8_4888_BE56_540011CEB8F6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <mspbase.h>
#include <streams.h>
#include <h323priv.h>
#include <bridge.h>
#include "bgdebug.h"
#include "bridgetm.h"
#include "bgbase.h"
#include "bgaudio.h"
#include "bgvideo.h"

#include "resource.h"

#ifdef BGDEBUG
#define ENTER_FUNCTION(s) \
    const CHAR __fxName[] = s
#else
#define ENTER_FUNCTION(s)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__78E7EB26_CAE8_4888_BE56_540011CEB8F6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bridgetm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bridgetm.h

Abstract:

    Definitions for the bridge terminals.

Author:

    Mu Han (muhan) 11/12/1998

--*/

#ifndef _BRIDGETERM_H_
#define _BRIDGETERM_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CIPConfBaseTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CIPConfBaseTerminal : 
    virtual public CComObjectRootEx<CComMultiThreadModelNoCS>, // we have our own CS implementation
    public IDispatchImpl<ITTerminal, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITTerminalControl
{

BEGIN_COM_MAP(CIPConfBaseTerminal)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTerminal)

    COM_INTERFACE_ENTRY(ITTerminalControl)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

public:

    CIPConfBaseTerminal(
        const GUID &        ClassID,
        TERMINAL_DIRECTION  TerminalDirection,
        TERMINAL_TYPE       TerminalType,
        DWORD               dwMediaType
        );

    HRESULT FinalConstruct();
    virtual ~CIPConfBaseTerminal();

public:
// ITTerminal -- COM interface for use by MSP or application
    STDMETHOD(get_TerminalClass)(OUT  BSTR *pVal);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pVal);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pVal);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);

// ITTerminalControl -- COM interface for use by MSP only

    STDMETHOD (get_AddressHandle) (
            OUT     MSP_HANDLE    * phtAddress
            );

    STDMETHOD (CompleteConnectTerminal) (void);

    STDMETHOD (RunRenderFilter) (void);

    STDMETHOD (StopRenderFilter) (void);

public:
    HRESULT Initialize(
            IN  WCHAR *             strName,
            IN  MSP_HANDLE          htAddress,
            IN  DWORD               dwMediaType
            );
protected:
    void Lock()     { EnterCriticalSection(&m_CritSec); }
    void Unlock()   { LeaveCriticalSection(&m_CritSec); }

protected:
    // The lock that protects the data members.
    CRITICAL_SECTION    m_CritSec;
    BOOL                m_fCritSecValid;

    // these five members need to be set by the derived class.
    GUID                m_TerminalClassID;
    TERMINAL_DIRECTION  m_TerminalDirection;
    TERMINAL_TYPE       m_TerminalType;
    TERMINAL_STATE      m_TerminalState;
    DWORD               m_dwMediaType;

    WCHAR               m_szName[MAX_PATH + 1];
    MSP_HANDLE          m_htAddress;

    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CIPConfBridgeTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef enum
{
	SOURCE,
	SINK
} FILTER_TYPE;

class CIPConfBridgeTerminal : 
    public CIPConfBaseTerminal
{

public:
    CIPConfBridgeTerminal();

    virtual ~CIPConfBridgeTerminal();

    static HRESULT CreateTerminal(
        IN  DWORD           dwMediaType,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal    **ppTerm
        );

    HRESULT Initialize (
        IN  DWORD           dwMediaType,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHOD (ConnectTerminal) (
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved,
        IN OUT  DWORD          * pdwNumPins,
        OUT     IPin          ** ppPins
        );

    STDMETHOD (DisconnectTerminal) (
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        );

protected:
    HRESULT CreateFilters();

	HRESULT AddFilter(
		IN		FILTER_TYPE		 FilterType,
		IN      IGraphBuilder  * pGraph,
		OUT     IPin          ** ppPins
		);

protected:

    // The sink filter is the data sink for the upstream graph.
	IGraphBuilder *     m_pUpStreamGraph;
    IBaseFilter *       m_pSinkFilter;
    IPin*				m_pSinkInputPin;

    // The source filter is the data source for the upstream graph.
    IGraphBuilder *     m_pDownStreamGraph;
    IBaseFilter *       m_pSourceFilter;
    IPin*				m_pSourceOutputPin;
};


#endif // _IPConfTERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\inc\bridge.h ===
#ifndef __BRIDGE_H_
#define __BRIDGE_H_

struct DECLSPEC_UUID("D3672FA1-99F2-452B-B2BD-8CDCD9B84C3F") ConfBridge;
struct DECLSPEC_UUID("581d09e5-0b45-11d3-a565-00c04f8ef6e3") IPConfBridgeTerminal;

interface DECLSPEC_UUID("5d410fe1-3f6e-4e1a-8d6d-7caaa52d9e93") DECLSPEC_NOVTABLE 
IConfBridge : public IUnknown
{
    STDMETHOD (CreateBridgeTerminal) (
        IN  long lMediaType,
        OUT ITTerminal **ppTerminal
        ) PURE;
};

#define IID_IConfBridge (__uuidof(IConfBridge))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\bridgetm\bridgetm.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bridgetm.cpp

Abstract:

    Implementations for the bridge terminals.

Author:

    Mu Han (muhan) 11/12/99

--*/

#include "stdafx.h"

HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE // param not used
    )
/*++

Routine Description:

    Find a input pin or output pin on a filter.

Arguments:
    
    pIFilter    - the filter that has pins.

    ppIPin      - the place to store the returned interface pointer.

    direction   - PINDIR_INPUT or PINDIR_OUTPUT.

    bFree       - look for a free pin or not.

Return Value:

    HRESULT

--*/
{
    _ASSERTE(ppIPin != NULL);

    HRESULT hr;
    DWORD dwFeched;

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pIFilter->EnumPins(&pIEnumPins)))
    {
        BGLOG((BG_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    IPin * pIPin = NULL;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            BGLOG((BG_ERROR, "find pin on filter."));
            return E_FAIL;
        }
        if (0 == dwFeched)
        {
            BGLOG((BG_ERROR, "get 0 pin from filter."));
            return E_FAIL;
        }

        PIN_DIRECTION dir;
        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            BGLOG((BG_ERROR, "query pin direction. %x", hr));
            pIPin->Release();
            return hr;
        }
        if (direction == dir)
        {
            if (!bFree)
            {
                break;
            }

            // Check to see if the pin is free.
            CComPtr<IPin> pIPinConnected;
            hr = pIPin->ConnectedTo(&pIPinConnected);
            if (pIPinConnected == NULL)
            {
                break;
            }
        }
        pIPin->Release();
    }

    *ppIPin = pIPin;

    return S_OK;
}

CIPConfBaseTerminal::CIPConfBaseTerminal(
        const GUID &        ClassID,
        TERMINAL_DIRECTION  TerminalDirection,
        TERMINAL_TYPE       TerminalType,
        DWORD               dwMediaType
        )
    : m_fCritSecValid(FALSE)
    , m_TerminalClassID(ClassID)
    , m_TerminalDirection(TD_BIDIRECTIONAL)
    , m_TerminalType(TerminalType)
    , m_TerminalState(TS_NOTINUSE)
    , m_dwMediaType(dwMediaType)
    , m_pFTM(NULL)
    , m_htAddress(NULL)
{
    BGLOG((BG_TRACE, "CIPConfBaseTerminal::CIPConfBaseTerminal() called"));
    m_szName[0] = TEXT('\0');
}

HRESULT CIPConfBaseTerminal::FinalConstruct()
/*++

Routine Description:

    Finish the initialization of the object. If anything fails, this object
    will be deleted.

Arguments:
    
    nothing.

Return Value:

    S_OK
    E_OUTOFMEMORY
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::FinalConstruct");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    m_fCritSecValid = TRUE;

    __try
    {
        InitializeCriticalSection(&m_CritSec);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        m_fCritSecValid = FALSE;
    }

    if (!m_fCritSecValid)
    {
        BGLOG((BG_ERROR, "%s init critical section failed", __fxName));
        return E_OUTOFMEMORY;
    }

    HRESULT hr = CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pFTM
            );

    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, "%s create ftm failed, hr=%x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

CIPConfBaseTerminal::~CIPConfBaseTerminal()
/*++

Routine Description:

    This is the destructor of the base terminal.

Arguments:
    
Return Value:

    S_OK
--*/
{

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    if (m_fCritSecValid)
    {
        DeleteCriticalSection(&m_CritSec);
    }
    
    BGLOG((BG_TRACE, 
        "CIPConfBaseTerminal::~CIPConfBaseTerminal() for %ws finished", m_szName));
}

HRESULT CIPConfBaseTerminal::Initialize(
    IN  WCHAR *             strName,
    IN  MSP_HANDLE          htAddress,
    IN  DWORD               dwMediaType
    )
/*++

Routine Description:

    This function sets the name and the address handle on the terminal.

Arguments:
    
    strName - The name of the terminal.

    htAddress - The handle that identifies the address object that this
                terminal belongs to.

Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::Initialize");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    m_htAddress         = htAddress;
    lstrcpynW(m_szName, strName, MAX_PATH);
    m_dwMediaType       = dwMediaType;

    BGLOG((BG_TRACE, "%s - exit S_OK", __fxName));
    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_Name(
    BSTR * pbsName
    )
/*++

Routine Description:

    This function return the name of the terminal.

Arguments:
    
    pbsName - A pointer to a BSTR to receive the terminal name.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_Name");

    if ( IsBadWritePtr( pbsName, sizeof(BSTR) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pbsName = SysAllocString(m_szName);

    if ( *pbsName == NULL )
    {
        BGLOG((BG_ERROR, "%s, out of memory for name", __fxName)); 
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_State(
    TERMINAL_STATE * pVal
    )
/*++

Routine Description:

    This function return the state of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_STATE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_State");

    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_STATE) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalState;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalType(
    TERMINAL_TYPE * pVal
    )
/*++

Routine Description:

    This function return the type of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_TYPE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalType");
    
    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_TYPE) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalType;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalClass(
    BSTR * pbsClassID
    )
/*++

Routine Description:

    This function return the class of the terminal.

Arguments:
    
    pbsClassID - A pointer to a BSTR to receive the classID as a string.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalClass");

    if ( IsBadWritePtr( pbsClassID, sizeof(BSTR) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    // Convert the CLSID to an string.
    WCHAR *pszName = NULL;
    
    HRESULT hr = ::StringFromCLSID(m_TerminalClassID, &pszName);

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, failed to convert GUID, hr = %x", __fxName, hr));
        return hr;
    }

    // Put the string in a BSTR.
    BSTR bClassID = ::SysAllocString(pszName);

    // Free the OLE string.
    ::CoTaskMemFree(pszName);

    if (bClassID == NULL)
    {
        BGLOG((BG_ERROR, "%s, out of mem for class ID", __fxName));
        return E_OUTOFMEMORY;
    }

    *pbsClassID = bClassID;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_Direction(
    OUT  TERMINAL_DIRECTION *pDirection
    )
/*++

Routine Description:

    This function return the direction of the terminal.

Arguments:
    
    pDirection - A pointer to a variable of type TERMINAL_DIRECTION

Return Value:

    E_POINTER
    S_OK
--*/
{   
    ENTER_FUNCTION("CIPConfBaseTerminal::get_Direction");

    if ( IsBadWritePtr( pDirection, sizeof(TERMINAL_DIRECTION) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pDirection = m_TerminalDirection;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_MediaType(
    long * plMediaType
    )
/*++

Routine Description:

    This function return the media type of the terminal.

Arguments:
    
    plMediaType - A pointer to a variable of type long

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_MediaType");

    if ( IsBadWritePtr(plMediaType, sizeof(long) ) )
    {
        BGLOG((BG_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }
    
    *plMediaType = (long) m_dwMediaType;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_AddressHandle(
        OUT     MSP_HANDLE    * phtAddress
        )
/*++

Routine Description:

    This function return the handle of the address that created this terminal.

Arguments:
    
    phtAddress - A pointer to a variable of type MSP_HANDLE

Return Value:

    E_POINTER
    S_OK
--*/
{
    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadWritePtr(phtAddress, sizeof(MSP_HANDLE)));

    *phtAddress = m_htAddress;

    return S_OK;
}

STDMETHODIMP 
CIPConfBaseTerminal::CompleteConnectTerminal(void)
/*++

Routine Description:

    This function is called after a successful ConnectTerminal so that the 
    terminal can do post-connection intitialization. 

Arguments:

    nothing    

Return Value:

S_OK
--*/
{
    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::RunRenderFilter(void)
/*++

Routine Description:

    start the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP CIPConfBaseTerminal::StopRenderFilter(void)
/*++

Routine Description:

    stops the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

 
CIPConfBridgeTerminal::CIPConfBridgeTerminal()
    : CIPConfBaseTerminal(
        __uuidof(IPConfBridgeTerminal),
        (TD_CAPTURE),
        TT_DYNAMIC,
        0)
    , m_pUpStreamGraph(NULL)
    , m_pSinkFilter(NULL)
    , m_pSinkInputPin(NULL)
    , m_pDownStreamGraph(NULL)
    , m_pSourceFilter(NULL)
    , m_pSourceOutputPin(NULL)
{
    BGLOG((BG_TRACE, "CIPConfBridgeTerminal::CIPConfBaseTerminal() called"));
}

CIPConfBridgeTerminal::~CIPConfBridgeTerminal()
/*++

Routine Description:

    This is the destructor of the bridge terminal.

Arguments:
    
Return Value:

    S_OK
--*/
{
    if (m_pUpStreamGraph)
    {
        m_pUpStreamGraph->Release();
    }
    
    if (m_pSinkFilter)
    {
        m_pSinkFilter->Release();
    }
  
    if (m_pSinkInputPin)
    {
        m_pSinkInputPin->Release();
    }
  
    if (m_pDownStreamGraph)
    {
        m_pDownStreamGraph->Release();
    }

    if (m_pSourceFilter)
    {
        m_pSourceFilter->Release();
    }

    if (m_pSourceOutputPin)
    {
        m_pSourceOutputPin->Release();
    }

    BGLOG((BG_TRACE, 
        "CIPConfBridgeTerminal::~CIPConfBridgeTerminal() for %ws finished", m_szName));
}

HRESULT CIPConfBridgeTerminal::CreateTerminal(
    IN  DWORD           dwMediaType,
    IN  MSP_HANDLE      htAddress,
    OUT ITTerminal      **ppTerm
    )
/*++

Routine Description:

    This method creates a bridge terminal

Arguments:

    dwMediaType - The media type of this terminal.

    htAddress - the handle to the address object.

    ppTerm - memory to store the returned terminal pointer.
    
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::CreateTerminal");
    BGLOG((BG_TRACE, "%s, htAddress:%x", __fxName, htAddress));

    _ASSERT(!IsBadWritePtr(ppTerm, sizeof(ITTerminal *)));

    HRESULT hr;

    //
    // Create the terminal.
    //
    CMSPComObject<CIPConfBridgeTerminal> *pTerminal = NULL;

    hr = CMSPComObject<CIPConfBridgeTerminal>::CreateInstance(&pTerminal);
    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s can't create the terminal object hr = %8x", __fxName, hr));

        return hr;
    }


    // query for the ITTerminal interface
    ITTerminal *pITTerminal;
    hr = pTerminal->_InternalQueryInterface(__uuidof(ITTerminal), (void**)&pITTerminal);
    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, 
            "%s, query terminal interface failed, %x", __fxName, hr));
        delete pTerminal;

        return hr;
    }

    // initialize the terminal 
    hr = pTerminal->Initialize(
            dwMediaType,
            htAddress
            );

    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, 
            "%s, Initialize failed; returning 0x%08x", __fxName, hr));

        pITTerminal->Release();
    
        return hr;
    }

    BGLOG((BG_TRACE, "%s, Bridge erminal %p created", __fxName, pITTerminal));

    *ppTerm = pITTerminal;

    return S_OK;
}

// max length of a bridge terminal name
#define MAX_BGTMNAME 80

HRESULT CIPConfBridgeTerminal::Initialize(
    IN  DWORD           dwMediaType,
    IN  MSP_HANDLE      htAddress
    )
{

    WCHAR pszTerminalName[MAX_BGTMNAME];
    int len;

    if (dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        len = LoadString (
            _Module.GetResourceInstance (),
            IDS_AUDBGNAME,
            pszTerminalName,
            MAX_BGTMNAME
            );
    }
    else if (dwMediaType == TAPIMEDIATYPE_VIDEO)
    {
        len = LoadString (
            _Module.GetResourceInstance (),
            IDS_VIDBGNAME,
            pszTerminalName,
            MAX_BGTMNAME
            );
    }
    else
    {
        LOG ((BG_ERROR, "CIPConfBridgeTerminal::Initialize receives unknown media type %d", dwMediaType));
        return E_INVALIDARG;
    }

    if (len == 0)
    {
        LOG ((BG_ERROR, "Failed to load bridge terminal name, media %d, err %d",
            dwMediaType, GetLastError ()));
        return E_UNEXPECTED;
    }

    return CIPConfBaseTerminal::Initialize(
        pszTerminalName, htAddress, dwMediaType
        );
}

HRESULT CIPConfBridgeTerminal::CreateFilters()
/*++

Routine Description:

    Create the two filters used in the terminal.

Arguments:
    
Return Value:

HRESULT
--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::CreateFilters");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;

    // Create the source filter.
    CComPtr <IBaseFilter> pSourceFilter;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        hr = CTAPIAudioBridgeSourceFilter::CreateInstance(&pSourceFilter);
    }
    else
    {
        hr = CTAPIVideoBridgeSourceFilter::CreateInstance(&pSourceFilter);
    }

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, Create source filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    CComPtr <IDataBridge> pIDataBridge;
    hr = pSourceFilter->QueryInterface(&pIDataBridge);

    // this should never fail.
    _ASSERT(SUCCEEDED(hr));


    // Create the sink filter.
    CComPtr <IBaseFilter> pSinkFilter;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        hr = CTAPIAudioBridgeSinkFilter::CreateInstance(pIDataBridge, &pSinkFilter);
    }
    else
    {
        hr = CTAPIVideoBridgeSinkFilter::CreateInstance(pIDataBridge, &pSinkFilter);
    }

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, Create sink filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    // Find the pins.
    CComPtr<IPin> pIPinOutput;
    if (FAILED(hr = ::FindPin(pSourceFilter, &pIPinOutput, PINDIR_OUTPUT)))
    {
        BGLOG((BG_ERROR, "%s, find output pin on sink filter. hr=%x", __fxName, hr));
        return hr;
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pSinkFilter, &pIPinInput, PINDIR_INPUT)))
    {
        BGLOG((BG_ERROR, "%s, find input pin on sink filter. hr=%x", __fxName, hr));
        return hr;
    }

    // save the reference.
    m_pSinkFilter = pSinkFilter;
    m_pSinkFilter->AddRef();

    m_pSinkInputPin = pIPinInput;
    m_pSinkInputPin->AddRef();

    m_pSourceFilter = pSourceFilter;
    m_pSourceFilter->AddRef();

    m_pSourceOutputPin = pIPinOutput;
    m_pSourceOutputPin->AddRef();

    return S_OK;
}

HRESULT CIPConfBridgeTerminal::AddFilter(
        IN      FILTER_TYPE      FilterType,
        IN      IGraphBuilder  * pGraph,
        OUT     IPin          ** ppPins
        )
/*++

Routine Description:

    Add a filter into the graph provided by the stream and returning the pin
    that can be connected at the same time.

Arguments:
    
    FilterType - the type of the filter. Either the source or the sink.

    pGraph - The filter graph.

    ppPins  - A pointer to the buffer that can store the IPin pointer.

Return Value:

S_OK
TAPI_E_TERMINALINUSE - the terminal is in use.
--*/

{
    ENTER_FUNCTION("CIPConfBridgeTerminal::AddSourceFilter");
    BGLOG((BG_TRACE, "%s entered", __fxName));

    // check to see if the terminal is already in use.
    if ((FilterType == SINK) && (m_pUpStreamGraph != NULL)
        || (FilterType == SOURCE) && (m_pDownStreamGraph != NULL))
    {
        BGLOG((BG_ERROR, "%s, terminal already in use", __fxName));

        return TAPI_E_TERMINALINUSE;
    }

    HRESULT hr;

    if (m_pSourceFilter == NULL)
    {
        // the filters have not been created, create them now.
        hr = CreateFilters();

        if (FAILED(hr))
        {
            BGLOG((BG_ERROR, "%s, can't Create filter, hr=%x", __fxName, hr));
            return hr;
        }
    }

    IBaseFilter *pFilter;
    IPin *pPin;

    if (FilterType == SINK)
    {
        pFilter = m_pSinkFilter;
        pPin = m_pSinkInputPin;
        m_pUpStreamGraph = pGraph;
        m_pUpStreamGraph->AddRef();
    }
    else
    {
        pFilter = m_pSourceFilter;
        pPin = m_pSourceOutputPin;
        m_pDownStreamGraph = pGraph;
        m_pDownStreamGraph->AddRef();
    }

    // add the filter to the graph.
    hr = pGraph->AddFilter(pFilter, NULL);
    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, "%s, can't add filter to the graph hr=%x", __fxName, hr));
        return hr;
    }

    pPin->AddRef();
    *ppPins = pPin;

    return S_OK;
}

STDMETHODIMP CIPConfBridgeTerminal::ConnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved,
        IN OUT  DWORD          * pdwNumPins,
        OUT     IPin          ** ppPins
        )
/*++

Routine Description:

    This function is called by the MSP while trying to connect the filter in
    the terminal to the rest of the graph in the MSP. It adds the filter into
    the graph and returns the pins can be used by the MSP.

Arguments:
    
    pGraph - The filter graph.

    dwReserved - the direction for the connection.

    pdwNumPins - The maxinum number of pins the msp wants.

    ppPins  - A pointer to the buffer that can store the IPin pointers. If it
              is NULL, only the actual number of pins will be returned.

Return Value:

S_OK
TAPI_E_NOTENOUGHMEMORY - the buffer is too small.
TAPI_E_TERMINALINUSE - the terminal is in use.
--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::ConnectTerminal");
    BGLOG((BG_TRACE, 
        "%s entered, pGraph:%p, dwREserved:%p", __fxName, pGraph, dwReserved));

    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadReadPtr(pGraph, sizeof(IGraphBuilder)));
    _ASSERT(!IsBadWritePtr(pdwNumPins, sizeof(DWORD)));

    // there is only one pin on each side of the bridge.
    const DWORD dwNumOfPins = 1;

    //
    // If ppPins is NULL, just return the number of pins and don't try to
    // connect the terminal.
    //
    if ( ppPins == NULL )
    {
        BGLOG((BG_TRACE, 
            "%s number of exposed pins:%d", __fxName, dwNumOfPins));
        *pdwNumPins = dwNumOfPins;
        return S_OK;
    }

    //
    // Otherwise, we have a pin return buffer. Check that the purported buffer
    // size is big enough and that the buffer is actually writable to the size
    // we need.
    //
    if ( *pdwNumPins < dwNumOfPins )
    {
        BGLOG((BG_ERROR, "%s not enough space to place pins.", __fxName));

        *pdwNumPins = dwNumOfPins;
        
        return TAPI_E_NOTENOUGHMEMORY;
    }

    _ASSERT(!IsBadWritePtr(ppPins, dwNumOfPins * sizeof(IPin *)));

    Lock();

    HRESULT hr;
    hr = AddFilter((dwReserved == TD_CAPTURE) ? SOURCE : SINK, pGraph, ppPins);

    if (FAILED(hr))
    {
        BGLOG((BG_ERROR, "%s, AddFilter failed", __fxName));
    }
    else
    {
        m_TerminalState = TS_INUSE;
        *pdwNumPins = 1;
    }

    Unlock();

    BGLOG((BG_TRACE, "CIPConfBridgeTerminal::ConnectTerminal success"));
    return hr;
}

STDMETHODIMP 
CIPConfBridgeTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBridgeTerminal::DisconnectTerminal");
    BGLOG((BG_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    if (pGraph == NULL)
    {
        BGLOG((BG_TRACE, "%s, bad graph pointer:%p", __fxName, pGraph));
        return E_INVALIDARG;
    }

    Lock();

    HRESULT hr;

    if (pGraph == m_pUpStreamGraph)
    {
        hr = pGraph->RemoveFilter(m_pSinkFilter);

        m_pUpStreamGraph->Release();
        m_pUpStreamGraph = NULL;
    }
    else if (pGraph == m_pDownStreamGraph)
    {
        hr = pGraph->RemoveFilter(m_pSourceFilter);

        m_pDownStreamGraph->Release();
        m_pDownStreamGraph = NULL;
    }
    else
    {
        BGLOG((BG_TRACE, "%s, wrong graph pointer:%p", __fxName, pGraph));

        Unlock();
        return E_INVALIDARG;
    }

    if ( FAILED(hr) )
    {
        BGLOG((BG_ERROR, 
            "%s, remove filter from graph failed; returning hr=%x", 
            __fxName, hr));
    }

    m_TerminalState = TS_NOTINUSE;

    Unlock();

    BGLOG((BG_TRACE, "%s succeeded", __fxName));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test\bgcall.cpp ===
/*******************************************************************************

  Module: bgcall.cpp

  Author: Qianbo Huai

  Abstract:

    implements bridge call object

*******************************************************************************/

#include "stdafx.h"
#include "work.h"

#include <bridge.h>

// to change
const BSTR CLSID_String_BridgeTerminal = L"{581d09e5-0b45-11d3-a565-00c04f8ef6e3}";

/*//////////////////////////////////////////////////////////////////////////////
    constructor
////*/
CBridgeCall::CBridgeCall (CBridge *pBridge)
{
    m_pBridge = pBridge;
    m_pH323Call = NULL;
    m_pSDPCall = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
CBridgeCall::~CBridgeCall ()
{
    Clear ();
    m_pBridge = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    select terminals and connect the call
////*/
HRESULT
CBridgeCall::BridgeCalls ()
{
    HRESULT hr;

    hr = SelectBridgeTerminals ();
    if (FAILED(hr))
        return hr;

    hr = SetupParticipantInfo ();
	if (FAILED(hr))
        return hr;

    hr = SetMulticastMode ();
	if (FAILED(hr))
        return hr;

    // connect h323 call
    hr = m_pH323Call->Answer ();
    if (FAILED(hr))
        return hr;

    // connect sdp call
    hr = m_pSDPCall->Connect (VARIANT_TRUE);
    if (FAILED(hr))
    {
        m_pH323Call->Disconnect (DC_NORMAL);
        return hr;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeCall::SelectBridgeTerminals ()
{
    HRESULT hr;
    ITAddress *pAddress = NULL;
    ITMSPAddress *pMSPAddress = NULL;
    ITTerminal *pH323ToSDPVideoBT = NULL;
    ITTerminal *pH323ToSDPAudioBT = NULL;
    ITTerminal *pSDPToH323VideoBT = NULL;
    ITTerminal *pSDPToH323AudioBT = NULL;

    ITStreamControl *pStreamControl = NULL;
    IEnumStream *pEnumStreams = NULL;
    ITStream *pStream = NULL;

    // get SDP address
    hr = m_pBridge->GetSDPAddress (&pAddress);
    if (FAILED(hr))
        return hr;

    // get MSP address
    hr = pAddress->QueryInterface (IID_ITMSPAddress, (void**)&pMSPAddress);
    if (FAILED(hr))
        return hr;

    IConfBridge *pBridge = NULL;
    // create CConfBridge
    hr = CoCreateInstance (
        __uuidof(ConfBridge),
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IConfBridge,
        (LPVOID *)&pBridge
        );
    if (FAILED(hr))
        return hr;

    // create terminal: video H323->SDP
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_VIDEO,
//        TD_RENDER, // not used
        &pH323ToSDPVideoBT
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio H323->SDP
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_AUDIO,
//        TD_RENDER, // not used
        &pH323ToSDPAudioBT
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: video SDP->H323
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_VIDEO,
//        TD_RENDER, // not used
        &pSDPToH323VideoBT
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio SDP->H323
    hr = pBridge->CreateBridgeTerminal (
//        (MSP_HANDLE)pMSPAddress,
//        CLSID_String_BridgeTerminal,
        TAPIMEDIATYPE_AUDIO,
//        TD_RENDER, // not used
        &pSDPToH323AudioBT
        );
    if (FAILED(hr))
        goto Error;

    pMSPAddress->Release ();
    pMSPAddress = NULL;

    pAddress->Release ();
    pAddress = NULL;

    pBridge->Release ();
    pBridge = NULL;

    // get stream control on H323
    hr = m_pH323Call->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        goto Error;

    // get enum stream on H323
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    if (FAILED(hr))
        goto Error;

    pStreamControl->Release ();
    pStreamControl = NULL;

    // iterate each stream on H323, select terminals
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
        {
            // video: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPVideoBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
        {
            // video: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323VideoBT);
            if (FAILED(hr))
                goto Error;

            IKeyFrameControl* pIKeyFrameControl;
            hr = pStream->QueryInterface(&pIKeyFrameControl);
            if (SUCCEEDED(hr))
            {
                hr = pIKeyFrameControl->PeriodicUpdatePicture(TRUE, 5);
                pIKeyFrameControl->Release();
            }


        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
        {
            // audio: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPAudioBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
        {
            // video: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323AudioBT);
            if (FAILED(hr))
                goto Error;
        }
        pStream->Release ();
        pStream = NULL;
    }

    if (pStream)
    {
        pStream->Release ();
        pStream = NULL;
    }

    pEnumStreams->Release ();
    pEnumStreams = NULL;

    // get stream control on SDP
    hr = m_pSDPCall->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        goto Error;

    // get enum stream on SDP
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    if (FAILED(hr))
        goto Error;

    pStreamControl->Release ();
    pStreamControl = NULL;

    // iterate each stream on SDP, select terminals
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
        {
            // video: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323VideoBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
        {
            // video: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPVideoBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
        {
            // audio: sdp to h323
            hr = pStream->SelectTerminal (pSDPToH323AudioBT);
            if (FAILED(hr))
                goto Error;
        }
        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
        {
            // video: h323 to sdp
            hr = pStream->SelectTerminal (pH323ToSDPAudioBT);
            if (FAILED(hr))
                goto Error;
        }
        pStream->Release ();
        pStream = NULL;
    }

Cleanup:
    // release streams
    if (pStream)
        pStream->Release ();
    if (pEnumStreams)
        pEnumStreams->Release ();
    if (pStreamControl)
        pStreamControl->Release ();
    
    // release terminals
    if (pH323ToSDPVideoBT)
        pH323ToSDPVideoBT->Release ();
    if (pH323ToSDPAudioBT)
        pH323ToSDPAudioBT->Release ();
    if (pSDPToH323VideoBT)
        pSDPToH323VideoBT->Release ();
    if (pSDPToH323AudioBT)
        pSDPToH323AudioBT->Release ();

    if (pBridge)
        pBridge->Release ();

    return hr;

Error:
    goto Cleanup;
}
        
HRESULT
CBridgeCall::SetupParticipantInfo ()
{
    HRESULT hr = S_OK;

    ITCallInfo *pCallInfo = NULL;
    BSTR CallerIDName = NULL;
    BSTR CallerIDNumber = NULL;
    
    ITLocalParticipant *pLocalParticipant = NULL;
    BSTR CName = NULL;

    // get the caller info from the H323 side.
    hr = m_pH323Call->QueryInterface(&pCallInfo);
    if (FAILED(hr)) goto cleanup;
    
    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNAME, &CallerIDName);
    if (FAILED(hr)) goto cleanup;

    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNUMBER, &CallerIDNumber);
    if (FAILED(hr)) goto cleanup;

    
    // construct the CName for the SDP side.
    CName = SysAllocStringLen(NULL, 
        SysStringLen(CallerIDName) + SysStringLen(CallerIDNumber) + 2);

    wsprintfW(CName, L"%ws@%ws", CallerIDName, CallerIDNumber);


    // set the CName on the SDP side.
    hr = m_pSDPCall->QueryInterface(&pLocalParticipant);
    if (FAILED(hr)) goto cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_CANONICALNAME, CName
        );
    if (FAILED(hr)) goto cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_NAME, CallerIDName
        );

    if (FAILED(hr)) goto cleanup;


cleanup:
    if (pCallInfo) pCallInfo->Release();
    if (CallerIDName) SysFreeString(CallerIDName);
    if (CallerIDNumber) SysFreeString(CallerIDNumber);
    
    if (pLocalParticipant) pLocalParticipant->Release();
    if (CName) SysFreeString(CName);

    return hr;
}

HRESULT
CBridgeCall::SetMulticastMode ()
{
    IMulticastControl * pIMulticastControl = NULL;
    
    HRESULT hr = m_pSDPCall->QueryInterface(&pIMulticastControl);
    if (FAILED(hr)) return hr;

    hr = pIMulticastControl->put_LoopbackMode(MM_SELECTIVE_LOOPBACK);

    pIMulticastControl->Release();

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    clear calls, return to initial state
////*/
void
CBridgeCall::Clear ()
{
    if (m_pH323Call)
    {
        m_pH323Call->Disconnect (DC_NORMAL);
        m_pH323Call->Release ();
        m_pH323Call = NULL;
    }
    if (m_pSDPCall)
    {
        m_pSDPCall->Disconnect (DC_NORMAL);
        m_pSDPCall->Release ();
        m_pSDPCall = NULL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL CBridgeCall::IsStream (
    ITStream *pStream,
    long lMediaType,
    TERMINAL_DIRECTION tdDirection
    )
{
    long mediatype;
    TERMINAL_DIRECTION direction;

    if (FAILED (pStream->get_Direction(&direction)))
        return false;
    if (FAILED (pStream->get_MediaType(&mediatype)))
        return false;
    return ((direction == tdDirection) &&
           (mediatype == lMediaType));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test\event.cpp ===
/*******************************************************************************

  Module: event.cpp

  Author: Qianbo Huai

  Abstract:

    implements methods for class CTAPIEventNotification

*******************************************************************************/

#include "stdafx.h"
#include "work.h"

extern HWND ghDlg;

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::QueryInterface (
    REFIID iid,
    void **ppvObj
    )
{
    if (iid==IID_ITTAPIEventNotification)
    {
        AddRef ();
        *ppvObj = (void *)this;
        return S_OK;
    }
    if (iid==IID_IUnknown)
    {
        AddRef ();
        *ppvObj = (void *)this;
    }
    return E_NOINTERFACE;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::AddRef ()
{
    ULONG l = InterlockedIncrement (&m_dwRefCount);
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::Release ()
{
    ULONG l = InterlockedDecrement (&m_dwRefCount);
    if (0 == l)
    {
        delete this;
    }
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event (
    TAPI_EVENT TapiEvent,
    IDispatch * pEvent
    )
{
    // Addref the event so it doesn't go away.
    pEvent->AddRef();

    // Post a message to our own UI thread.
    PostMessage(
        ghDlg,
        WM_PRIVATETAPIEVENT,
        (WPARAM) TapiEvent,
        (LPARAM) pEvent
        );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Work.rc
//
#define IDD_MAINDLG                     101
#define IDC_DISCONNECT                  1000
#define IDC_EXIT                        1001
#define IDC_STATUS                      1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <objbase.h>
#include <winsock2.h>
#include <tapi3.h>
#include <control.h>
#include <strmif.h>
#include <confpriv.h>
#include <h323priv.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test\work.cpp ===
/*******************************************************************************

  Module: work.cpp

  Author: Qianbo Huai

  Abstract:

    implements the main function of the bridge test application

*******************************************************************************/

#include "stdafx.h"
#include <stdio.h>
#include "work.h"

// command line
LPSTR glpCmdLine = NULL;

// dialog
HWND ghDlg = NULL;

// true: exit button on dialog was clicked
bool gfExitButton = false;

// bridge
CBridge *gpBridge = NULL;

// callback func in dialog
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

// func to deal with TAPI events
HRESULT
OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent,
    LPWSTR *ppszMessage
    );

// set status message on dialog
void
SetStatusMessage (LPWSTR pszMessage);

/*//////////////////////////////////////////////////////////////////////////////
    WinMain
////*/
int
WINAPI
WinMain (
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    // init com
    if (FAILED (CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        return 0;
    }

    // keep command line which determines which SDP to join
    glpCmdLine = lpCmdLine;

    // init CBridge
    gpBridge = new CBridge ();
    if (gpBridge==NULL)
    {
        printf ("Failed to init CBridge\n");
        return 0;
    }

    // init TAPI and H323 call listen
    if (FAILED(gpBridge->InitTapi()))
    {
        printf ("Failed to init TAPI\n");
        return 0;
    }
    
    // start dialog box
    if (!DialogBox (hInst, MAKEINTRESOURCE(IDD_MAINDLG), NULL, MainDialogProc))
    {
        printf ("Failed to init dialog\n");
    }

    // dialog finished
    gpBridge->ShutdownTapi ();
    delete gpBridge;

    CoUninitialize ();

    return 1;
}

/*//////////////////////////////////////////////////////////////////////////////
    Callback for dialog
////*/
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPWSTR pszMessage;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            ghDlg = hDlg;
            SetStatusMessage (L"Waiting for incoming H323 call");

            // disable disconnect button
            SendDlgItemMessage (
                ghDlg,
                IDC_DISCONNECT,
                BM_SETSTYLE,
                BS_PUSHBUTTON,
                0
                );
            EnableWindow (
                GetDlgItem (ghDlg, IDC_DISCONNECT),
                FALSE
                );

            return 0;
        }
    case WM_PRIVATETAPIEVENT:
        {
            if (FAILED(OnTapiEvent ((TAPI_EVENT)wParam, (IDispatch *)lParam, &pszMessage)))
            {
                DoMessage (pszMessage);
            }
            return 0;
        }
    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_EXIT:
                {
                    gpBridge->Clear ();

                    gfExitButton = true;

                    // check if in connection
                    if (!IsWindowEnabled (GetDlgItem (ghDlg, IDC_DISCONNECT)))
                    {
                        // not in connection
                        EndDialog (ghDlg, 0);
                    }
                    // else
                        // remember exit button is clicked
                        // do not call EndDialog because a disconnect event is to come

                    return 1;
                }
            case IDC_DISCONNECT:
                {
                    gpBridge->Clear ();

                    SetStatusMessage (L"Waiting for incoming H323 call");

                    // disable disconnect button
                    SendDlgItemMessage (
                        ghDlg,
                        IDC_DISCONNECT,
                        BM_SETSTYLE,
                        BS_PUSHBUTTON,
                        0
                        );
                    EnableWindow (
                        GetDlgItem (ghDlg, IDC_DISCONNECT),
                        FALSE
                        );

                    // check if exit button is clicked
                    if (gfExitButton)
                        EndDialog (ghDlg, 0);

                    return 1;
                }
            }
            return 0;
        }
    default:
        return 0;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    Popup message box
////*/
WCHAR gMsgBoxTitle[] = L"TAPI 3.0 Bridge Test Application";

void
DoMessage (LPWSTR pszMessage)
{
    MessageBox (
        ghDlg,
        pszMessage,
        gMsgBoxTitle,
        MB_OK
        );
}

/*//////////////////////////////////////////////////////////////////////////////
    Status message
////*/
void
SetStatusMessage (LPWSTR pszMessage)
{
    SetDlgItemText (ghDlg, IDC_STATUS, pszMessage);
}

/*//////////////////////////////////////////////////////////////////////////////
    Deals with TAPI events
////*/
HRESULT OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent,
    LPWSTR *ppszMessage
    )
{
    HRESULT hr = S_OK;

    switch (TapiEvent)
    {
    case TE_CALLNOTIFICATION:
        {
            // if h323 call and to us, init h323 call
            hr = gpBridge->CreateH323Call (pEvent);
            if (FAILED(hr))
                *ppszMessage = L"H323 not created";
            break;
        }
    case TE_CALLSTATE:
        {
            CALL_STATE cs;
            ITCallStateEvent *pCallStateEvent = NULL;

            *ppszMessage = L"Call state failed";

            // get call state event
            hr = pEvent->QueryInterface (
                IID_ITCallStateEvent,
                (void **)&pCallStateEvent
                );
            if (FAILED(hr)) break;

            // get call state
            hr = pCallStateEvent->get_State (&cs);
            pCallStateEvent->Release ();
            if (FAILED(hr)) break;

            // if offering, connect
            if (CS_OFFERING == cs)
            {
                // check if h323 call created successful
                if (!gpBridge->HasH323Call ())
                {
                    hr = S_OK;
                    break;
                }
                // create sdp call
                hr = gpBridge->CreateSDPCall ();
                if (FAILED(hr)) {
                    gpBridge->Clear ();
                    *ppszMessage = L"Failed to create SDP call";
                    break;
                }

                // bridge call
                hr = gpBridge->BridgeCalls ();
                if (FAILED(hr)) {
                    gpBridge->Clear ();
                    *ppszMessage = L"Failed to bridge calls";
                    break;
                }

                SetStatusMessage (L"In call ...");

                // enable disconnect button
                SendDlgItemMessage (
                    ghDlg,
                    IDC_DISCONNECT,
                    BM_SETSTYLE,
                    BS_DEFPUSHBUTTON,
                    0
                    );
                EnableWindow (
                    GetDlgItem (ghDlg, IDC_DISCONNECT),
                    TRUE
                    );
                SetFocus (GetDlgItem (ghDlg, IDC_DISCONNECT));
            }
            // if disconnect
            else if (CS_DISCONNECTED == cs)
            {
                PostMessage (ghDlg, WM_COMMAND, IDC_DISCONNECT, 0);
                hr = S_OK;
            }
            break;
        }
    case TE_CALLMEDIA:
        {
            CALL_MEDIA_EVENT cme;
            ITCallMediaEvent *pCallMediaEvent;

            // get call media event
            hr = pEvent->QueryInterface (
                IID_ITCallMediaEvent,
                (void **)&pCallMediaEvent
                );
            if (FAILED(hr)) break;

            // get the event
            hr = pCallMediaEvent->get_Event (&cme);
            if (FAILED(hr)) break;

            // check media event
            switch (cme)
            {
                case CME_STREAM_FAIL:
                    hr = E_FAIL;
                    DoMessage( L"Stream failed");
                    break; 
                case CME_TERMINAL_FAIL:
                    hr = E_FAIL;
                    DoMessage( L"Terminal failed");
                    break;
                default:
                    break;
            }

            // we no longer need this interface.
            pCallMediaEvent->Release();
            break;
        }
    default:
        break;
    }

    pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test\bridge.cpp ===
/*******************************************************************************

  Module: bridge.cpp

  Author: Qianbo Huai

  Abstract:
  
    implements the class CBridge

*******************************************************************************/

#include "stdafx.h"
#include "work.h"

extern LPSTR glpCmdLine;

/*//////////////////////////////////////////////////////////////////////////////
    hard coded SDP
////*/
const WCHAR * const MySDP = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 0 4\n\
";

const WCHAR * const MySDP2 = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf2\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 3\n\
";

/*//////////////////////////////////////////////////////////////////////////////
    initiates tapi and listens at h323 address
////*/
HRESULT
CBridge::InitTapi ()
{
    HRESULT hr;

    // init members
    m_pTapi = NULL;
    m_pH323Addr = NULL;
    m_pSDPAddr = NULL;
    m_pBridgeCall = new CBridgeCall (this);

    // create tapi
    hr = CoCreateInstance (
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&m_pTapi
        );
    if (FAILED(hr))
        return hr;

    // tapi initiate
    hr = m_pTapi->Initialize ();
    if (FAILED(hr))
        return hr;

    // associate event with listener
    CTAPIEventNotification *pEventNotif = NULL;
    IConnectionPointContainer *pContainer = NULL;
    IConnectionPoint *pPoint = NULL;
    IH323LineEx *pIH323LineEx = NULL;
    ULONG ulTapiEventAdvise;
    long lCallNotif;
    BSTR bstrAddrName = NULL;

    // create event notification
    pEventNotif = new CTAPIEventNotification;
    if (!pEventNotif)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    
    // get pointer container from tapi  
    hr = m_pTapi->QueryInterface (
        IID_IConnectionPointContainer,
        (void **)&pContainer
        );
    if (FAILED(hr))
        goto Error;

    // get connection point from container
    hr = pContainer->FindConnectionPoint (
        IID_ITTAPIEventNotification,
        &pPoint
        );
    if (FAILED(hr))
        goto Error;

    // advise event notification on connection pointer
    hr = pPoint->Advise (
        pEventNotif,
        &ulTapiEventAdvise
        );
    if (FAILED(hr))
        goto Error;

    // put event filter on tapi
    hr = m_pTapi->put_EventFilter (
        TE_CALLNOTIFICATION |
        TE_CALLSTATE |
        TE_CALLMEDIA |
        TE_PRIVATE
        );
    if (FAILED(hr))
        goto Error;

    // find h323 address
    bstrAddrName = SysAllocString (L"H323 Line");
    hr = FindAddress (
        0,
        bstrAddrName,
        TAPIMEDIATYPE_AUDIO,
        &m_pH323Addr
        );
    SysFreeString (bstrAddrName);
    if (FAILED(hr))
        goto Error;

    // check if it supports video
    BOOL fSupportsVideo;

    if (AddressSupportsMediaType (m_pH323Addr, TAPIMEDIATYPE_VIDEO))
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO;

    hr = m_pH323Addr->QueryInterface(&pIH323LineEx);
    if (SUCCEEDED(hr))
    {
        hr = pIH323LineEx->SetExternalT120Address(TRUE, INADDR_ANY, 1503);

        H245_CAPABILITY Capabilities[] = 
            {HC_G711, HC_G723, HC_H263QCIF, HC_H261QCIF};
        DWORD Weights[] = {200, 100, 100, 0};

        hr = pIH323LineEx->SetDefaultCapabilityPreferrence(
            4, Capabilities, Weights
            );
    }

    // register call notification
    hr = m_pTapi->RegisterCallNotifications (
        m_pH323Addr,
        VARIANT_TRUE,
        VARIANT_TRUE,
        m_lH323MediaType,
        ulTapiEventAdvise,
        &lCallNotif
        );
    if (FAILED(hr))
        goto Error;

    // find sdp address
    hr = FindAddress (
        LINEADDRESSTYPE_SDP,
        NULL,
        TAPIMEDIATYPE_AUDIO,
        &m_pSDPAddr
        );
    if (FAILED(hr))
        return hr;
    
    // check if it supports video
    if (AddressSupportsMediaType (m_pSDPAddr, TAPIMEDIATYPE_VIDEO))
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO;

Cleanup:
    if (pEventNotif)
        pEventNotif->Release ();
    if (pPoint)
        pPoint->Release ();
    if (pContainer)
        pContainer->Release ();
    if (pIH323LineEx)
        pIH323LineEx->Release ();

    return hr;

Error:
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
        m_pH323Addr = NULL;
    }
    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
        m_pSDPAddr = NULL;
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
        m_pTapi = NULL;
    }
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
void
CBridge::ShutdownTapi ()
{
    if (m_pBridgeCall)
    {
        delete m_pBridgeCall;
        m_pBridgeCall = NULL;
    }

    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
        m_pSDPAddr = NULL;
    }
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
        m_pH323Addr = NULL;
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
        m_pTapi = NULL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    create h323 call from event
////*/
HRESULT
CBridge::CreateH323Call (IDispatch *pEvent)
{
    HRESULT hr;

    ITCallNotificationEvent *pNotify = NULL;
    CALL_PRIVILEGE privilege;
    ITCallInfo *pCallInfo = NULL;
    ITBasicCallControl *pCall = NULL;

    // get call event interface
    hr = pEvent->QueryInterface (
        IID_ITCallNotificationEvent,
        (void **)&pNotify
        );
    if (FAILED(hr))
        return hr;

    // get call info
    hr = pNotify->get_Call (&pCallInfo);
    if (FAILED(hr))
        goto Error;

    // if we own the call
    hr = pCallInfo->get_Privilege (&privilege);
    if (FAILED(hr))
        goto Error;

    if (CP_OWNER!=privilege)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // get basic call control
    hr = pCallInfo->QueryInterface (
        IID_ITBasicCallControl,
        (void **)&pCall
        );
    if (FAILED(hr))
        goto Error;

    m_pBridgeCall->SetH323Call (pCall);

Cleanup:
    if (pCall)
    {
        pCall->Release ();
        pCall = NULL;
    }
    if (pCallInfo)
    {
        pCallInfo->Release ();
        pCallInfo = NULL;
    }
    if (pNotify)
    {
        pNotify->Release ();
        pNotify = NULL;
    }
    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridge::HasH323Call ()
{
    return m_pBridgeCall->HasH323Call ();
}

/*//////////////////////////////////////////////////////////////////////////////
    iterates through tapi, find an address and create a sdp call
////*/
HRESULT
CBridge::CreateSDPCall ()
{
    HRESULT hr;

    // create call, ignore bstrDestAddr, hardcode it here
    ITBasicCallControl *pCall = NULL;
    BSTR bstrFixedDest;
    
    if (glpCmdLine[0] == '\0')
        bstrFixedDest = SysAllocString (MySDP);
    else
        bstrFixedDest = SysAllocString (MySDP2);

    hr = m_pSDPAddr->CreateCall (
        bstrFixedDest, // bstrDestAddr,
        LINEADDRESSTYPE_SDP,
        m_lSDPMediaType,
        &pCall
        );
    SysFreeString (bstrFixedDest);

    if (FAILED(hr))
        return hr;

    m_pBridgeCall->SetSDPCall (pCall);
    pCall->Release ();

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    bridges h323 and sdp calls
////*/
HRESULT
CBridge::BridgeCalls ()
{
    HRESULT hr;

    return m_pBridgeCall->BridgeCalls ();
}

/*//////////////////////////////////////////////////////////////////////////////
    returns to same state as just initializing tapi
////*/
void
CBridge::Clear ()
{
    m_pBridgeCall->Clear ();
}

/*//////////////////////////////////////////////////////////////////////////////
    if the address type is given, find an address based on
        address type and media type
    else if address name is given, find an address based on
        address name and media type
    else
        return E_FAIL
////*/
HRESULT
CBridge::FindAddress (
    long dwAddrType,
    BSTR bstrAddrName,
    long lMediaType,
    ITAddress **ppAddr
    )
{
    HRESULT hr;
    IEnumAddress *pEnumAddr = NULL;
    ITAddress *pAddr = NULL;
    ITAddressCapabilities *pAddrCaps = NULL;

    BOOL fFound = false;
    long lTypeFound;
    BSTR bstrAddrNameFound = NULL;

    // clear output address
    if ((*ppAddr))
    {
        (*ppAddr)->Release ();
        (*ppAddr) = NULL;
    }
    
    // enumerate the address
    hr = m_pTapi->EnumerateAddresses (&pEnumAddr);
    if (FAILED(hr))
    {
        DoMessage (L"Failed to enumerate address");
        goto Error;
    }
    // loop to find the right address
    while (!fFound)
    {
        // next address
        if (pAddr)
        {
            pAddr->Release ();
            pAddr = NULL;
        }
        hr = pEnumAddr->Next (1, &pAddr, NULL);
        if (S_OK != hr)
            break;

        if (dwAddrType != 0) 
        {
            // addr type is valid, ignore addr name
            if (pAddrCaps)
            {
                pAddrCaps->Release ();
                pAddrCaps = NULL;
            }
            hr = pAddr->QueryInterface (
                IID_ITAddressCapabilities,
                (void **)&pAddrCaps
                );
            if (FAILED(hr))
            {
                DoMessage (L"Failed to retrieve address capabilities");
                goto Error;
            }

            // find address type supported
            hr = pAddrCaps->get_AddressCapability (AC_ADDRESSTYPES, &lTypeFound);
            if (FAILED(hr))
            {
                DoMessage (L"Failed to get address type");
                goto Error;
            }

            // check if the type we wanted
            if (dwAddrType != lTypeFound)
                continue;
        }
        else if (bstrAddrName != NULL)
        {
            hr = pAddr->get_AddressName (&bstrAddrNameFound);
            if (FAILED(hr))
            {
                DoMessage (L"Failed to get address name");
                goto Error;
            }
            if (wcscmp(bstrAddrName, bstrAddrNameFound) != 0)
                continue;
        }
        else
        {
            DoMessage (L"Both address type and name are null. Internal error");
            hr = E_UNEXPECTED;
            goto Error;
        }

        // now check media type
        if (AddressSupportsMediaType (pAddr, lMediaType))
            fFound = true;
    } // end of while (!fFound)

    if (fFound)
    {
        (*ppAddr) = pAddr;
        (*ppAddr)->AddRef ();
    }

Cleanup:
    if (pAddrCaps)
        pAddrCaps->Release ();
    if (pAddr)
        pAddr->Release ();
    if (pEnumAddr)
        pEnumAddr->Release ();
    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
    checks if the address supports the media type
////*/
BOOL
CBridge::AddressSupportsMediaType (ITAddress *pAddr, long lMediaType)
{
    VARIANT_BOOL vbSupport = VARIANT_FALSE;
    ITMediaSupport * pMediaSupport;

    if (SUCCEEDED(pAddr->QueryInterface (IID_ITMediaSupport, (void**)&pMediaSupport)))
    {
        pMediaSupport->QueryMediaType (lMediaType, &vbSupport);
        pMediaSupport->Release ();
    }
    return (vbSupport==VARIANT_TRUE);
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridge::GetSDPAddress (ITAddress **ppAddress)
{
    HRESULT hr;

    if (*ppAddress)
    {
        (*ppAddress)->Release ();
        *ppAddress = NULL;
    }

    *ppAddress = m_pSDPAddr;
    m_pSDPAddr->AddRef ();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test\work.h ===
/*******************************************************************************

  Module: work.h

  Author: Qianbo Huai

  Abstract:

    defines all the classes for the bridge test application

*******************************************************************************/

#ifndef _WORK_H
#define _WORK_H

#include "resource.h"

// H323 call listener sends event to dialog box
#define WM_PRIVATETAPIEVENT   WM_USER+101

// helper
void DoMessage (LPWSTR pszMessage);

class CBridge;
class CBridgeCall;
class CTAPIEventNotification;

class CBridge
/*//////////////////////////////////////////////////////////////////////////////
  encapsulates methods operated on ITTAPI, ITAddress.
  contains the bridge call object
////*/
{
public:
    CBridge () {};
    ~CBridge () {};

    // helper
    HRESULT FindAddress (long dwAddrType, BSTR bstrAddrName, long lMediaType, ITAddress **ppAddr);
    BOOL AddressSupportsMediaType (ITAddress *pAddr, long lMediaType);

    // methods related with tapi
    HRESULT InitTapi ();
    void ShutdownTapi ();

    // methods related with terminal support
    HRESULT GetSDPAddress (ITAddress **ppAddress);

    // methods related with calls
    HRESULT CreateH323Call (IDispatch *pEvent);
    HRESULT CreateSDPCall ();
    HRESULT BridgeCalls ();

    void Clear ();

    BOOL HasH323Call ();

private:
    ITTAPI *m_pTapi;

    ITAddress *m_pH323Addr;
    ITAddress *m_pSDPAddr;
    
    long m_lH323MediaType;
    long m_lSDPMediaType;

    CBridgeCall *m_pBridgeCall;
};

/*//////////////////////////////////////////////////////////////////////////////
  encapsulates methods operated on ITBasicCallControl
////*/
class CBridgeCall
{
public:
    CBridgeCall (CBridge *pBridge);
    ~CBridgeCall ();

    void SetH323Call (ITBasicCallControl *pCall)
    {
        pCall->AddRef ();
        m_pH323Call = pCall;
    }
    void SetSDPCall (ITBasicCallControl *pCall)
    {
        pCall->AddRef ();
        m_pSDPCall = pCall;
    }
    BOOL HasH323Call ()
    {
        return (m_pH323Call!=NULL);
    }

    HRESULT SelectBridgeTerminals ();
    HRESULT SetupParticipantInfo ();
    HRESULT SetMulticastMode ();
    HRESULT BridgeCalls ();

    void Clear ();

private:
    BOOL IsStream (ITStream *pStream, long lMediaType, TERMINAL_DIRECTION tdDirection);

private:
    CBridge *m_pBridge;

    ITBasicCallControl *m_pH323Call;
    ITBasicCallControl *m_pSDPCall;
};

/*//////////////////////////////////////////////////////////////////////////////
  used by ITTAPI to notify event coming
////*/
class CTAPIEventNotification
:public ITTAPIEventNotification
{
public:
    CTAPIEventNotification ()
    {
        m_dwRefCount = 1;
    }
    ~CTAPIEventNotification () {}

    // IUnknow stuff
    HRESULT STDMETHODCALLTYPE QueryInterface (REFIID iid, void **ppvObj);

    ULONG STDMETHODCALLTYPE AddRef ();

    ULONG STDMETHODCALLTYPE Release ();

    HRESULT STDMETHODCALLTYPE Event (TAPI_EVENT TapiEvent, IDispatch *pEvent);

private:
    long m_dwRefCount;
};

#endif // _WORK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgevent.cpp ===
/*******************************************************************************

Module:

    bgevent.cpp

Abstract:

    Class implementing TAPI event

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#include "stdafx.h"

extern HWND ghDlg;

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::QueryInterface (
    REFIID iid,
    void **ppvObj
    )
{
    if (iid==IID_ITTAPIEventNotification)
    {
        AddRef ();
        *ppvObj = (void *)this;
        return S_OK;
    }
    if (iid==IID_IUnknown)
    {
        AddRef ();
        *ppvObj = (void *)this;
    }
    return E_NOINTERFACE;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::AddRef ()
{
    ULONG l = InterlockedIncrement (&m_dwRefCount);
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
ULONG
STDMETHODCALLTYPE
CTAPIEventNotification::Release ()
{
    ULONG l = InterlockedDecrement (&m_dwRefCount);
    if (0 == l)
    {
        delete this;
    }
    return l;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
STDMETHODCALLTYPE
CTAPIEventNotification::Event (
    TAPI_EVENT TapiEvent,
    IDispatch * pEvent
    )
{
    // Addref the event so it doesn't go away.
    pEvent->AddRef();

    // Post a message to our own UI thread.
    PostMessage(
        ghDlg,
        WM_PRIVATETAPIEVENT,
        (WPARAM) TapiEvent,
        (LPARAM) pEvent
        );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgapp.h ===
/*******************************************************************************

Module Name:

    bgapp.h

Abstract:

    Defines CBridgeApp class

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#ifndef _BGAPP_H
#define _BGAPP_H

/*//////////////////////////////////////////////////////////////////////////////
////*/
class CBridgeApp
{
public:
    // init tapi objects
    CBridgeApp (HRESULT *phr);
    // release tapi objects
    ~CBridgeApp ();

    // create h323 call
    HRESULT CreateH323Call (IDispatch *pEvent);
    // create sdp call
    HRESULT CreateSDPCall (CBridgeItem *pItem);
    // bridge calls
    HRESULT BridgeCalls (CBridgeItem *pItem);

    // get h323 call if exists
    HRESULT HasH323Call (IDispatch *pEvent, CBridgeItem **ppItem);
    HRESULT HasCalls ();

    // disconnect one call
    HRESULT DisconnectCall (CBridgeItem *pItem, DISCONNECT_CODE);
    // disconnect all calls
    HRESULT DisconnectAllCalls (DISCONNECT_CODE);
    HRESULT RemoveCall (CBridgeItem *pItem);

    // alter a substream to display
    HRESULT NextSubStream ();
    // show specified participant
    HRESULT ShowParticipant (ITBasicCallControl *pSDPCall, ITParticipant *pPartcipant);

private:
    // create bridge terminals
    HRESULT CreateBridgeTerminals (CBridgeItem *pItem);
    // get streams from call
    HRESULT GetStreams (CBridgeItem *pItem);
    // select bridge terminals
    HRESULT SelectBridgeTerminals (CBridgeItem *pItem);

    HRESULT SetupParticipantInfo (CBridgeItem *pItem);
    HRESULT SetMulticastMode (CBridgeItem *pItem);

    // helper
    HRESULT FindAddress (
        long dwAddrType,
        BSTR bstrAddrName,
        long lMediaType,
        ITAddress **ppAddr
        );
    BOOL AddressSupportsMediaType (ITAddress *pAddr, long lMediaType);
    BOOL IsStream (
        ITStream *pStream,
        long lMediaType,
        TERMINAL_DIRECTION tdDirection
        );

private:
    ITTAPI *m_pTapi;

    ITAddress *m_pH323Addr;
    ITAddress *m_pSDPAddr;
    
    long m_lH323MediaType;
    long m_lSDPMediaType;

    CBridgeItemList *m_pList;
};

#endif // _BGAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgdebug.h ===
/*++

Module Name

    bgdebug.h

Description

    Defines functions used for debugging

Note

    Revised based on msplog.h which is not available to bridge test app

--*/

#ifndef _BGDEBUG_H
#define _BGDEBUG_H

    typedef enum EVENT_TYPE
    {
        BG_TE,
        BG_CS,
        BG_CME,
        BG_PE
    }EVENT_TYPE;

    #define BG_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define BG_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define BG_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define BG_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define BG_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL BGLogRegister(LPCTSTR szName);
    void BGLogDeRegister();
    void BGLogPrint(DWORD dwDbgLevel, LPCSTR DbgMessage, ...);
    void BGLogEvent (EVENT_TYPE EventType, int event);

#ifdef BGDEBUG

    #define BGLOGREGISTER(arg) BGLogRegister(arg)
    #define BGLOGDEREGISTER() BGLogDeRegister()
    #define LOG(arg) BGLogPrint arg
    #define LOGEvent(arg) BGLogEvent arg

#else // BGDEBUG

    #define BGLOGREGISTER(arg)
    #define BGLOGDEREGISTER()
    #define LOG(arg)
    #define LOGEvent(arg)

#endif // BGDEBUG

#endif // _BGDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgevent.h ===
/*******************************************************************************

Module Name:

    bgevent.h

Abstract:

    Defines event class used by TAPI to notify event coming.

Author:

    Qianbo Huai (qhuai) Jan 27 2000
*******************************************************************************/

#ifndef _BGEVENT_H
#define _BGEVENT_H

class CTAPIEventNotification
:public ITTAPIEventNotification
{
public:
    CTAPIEventNotification ()
    {
        m_dwRefCount = 1;
    }
    ~CTAPIEventNotification () {}

    HRESULT STDMETHODCALLTYPE QueryInterface (REFIID iid, void **ppvObj);

    ULONG STDMETHODCALLTYPE AddRef ();

    ULONG STDMETHODCALLTYPE Release ();

    HRESULT STDMETHODCALLTYPE Event (TAPI_EVENT TapiEvent, IDispatch *pEvent);

private:
    long m_dwRefCount;
};

#endif // _BGEVENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgapp.cpp ===
/*******************************************************************************

Module Name:

    bgapp.cpp

Abstract:
  
    Implements class CBridgeApp

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#include "stdafx.h"
#include <bridge.h>

extern LPSTR glpCmdLine;

/*//////////////////////////////////////////////////////////////////////////////
    hard coded SDP
////*/
const WCHAR * const MySDP = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 0 4\n\
";

const WCHAR * const MySDP2 = L"\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=BridgeTestConf2\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
m=audio 20040 RTP/AVP 3\n\
";

WCHAR *SelfAlias = L"Conference";

/*//////////////////////////////////////////////////////////////////////////////
    initiates tapi and listens at h323 address
////*/
CBridgeApp::CBridgeApp (HRESULT *phr)
{
    ENTER_FUNCTION ("CBridgeApp::CBridgeApp");
    LOG ((BG_TRACE, "%s entered", __fxName));

    *phr = S_OK;

    // init members
    m_pTapi = NULL;
    m_pH323Addr = NULL;
    m_pSDPAddr = NULL;
    m_pList = new CBridgeItemList ();
    if (NULL == m_pList)
    {
        *phr = E_FAIL;
        return;
    }

    // create tapi
    *phr = CoCreateInstance (
        CLSID_TAPI,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTAPI,
        (LPVOID *)&m_pTapi
        );
    if (FAILED(*phr))
        return;

    // tapi initiate
    *phr = m_pTapi->Initialize ();
    if (FAILED(*phr))
        return;

    // associate event with listener
    CTAPIEventNotification *pEventNotif = NULL;
    IConnectionPointContainer *pContainer = NULL;
    IConnectionPoint *pPoint = NULL;
    IH323LineEx *pIH323LineEx = NULL;
    ULONG ulTapiEventAdvise;
    long lCallNotif;
    BSTR bstrAddrName = NULL;

    // create event notification
    pEventNotif = new CTAPIEventNotification;
    if (!pEventNotif)
    {
        *phr = E_OUTOFMEMORY;
        goto Error;
    }
    
    // get pointer container from tapi  
    *phr = m_pTapi->QueryInterface (
        IID_IConnectionPointContainer,
        (void **)&pContainer
        );
    if (FAILED(*phr))
        goto Error;

    // get connection point from container
    *phr = pContainer->FindConnectionPoint (
        IID_ITTAPIEventNotification,
        &pPoint
        );
    if (FAILED(*phr))
        goto Error;

    // advise event notification on connection pointer
    *phr = pPoint->Advise (
        pEventNotif,
        &ulTapiEventAdvise
        );
    if (FAILED(*phr))
        goto Error;

    // put event filter on tapi
    *phr = m_pTapi->put_EventFilter (
        TE_CALLNOTIFICATION |
        TE_CALLSTATE |
        TE_CALLMEDIA |
        TE_PRIVATE
        );
    if (FAILED(*phr))
        goto Error;

    // find h323 address
    bstrAddrName = SysAllocString (L"H323 Line");
    *phr = FindAddress (
        0,
        bstrAddrName,
        TAPIMEDIATYPE_AUDIO,
        &m_pH323Addr
        );
    SysFreeString (bstrAddrName);
    if (FAILED(*phr))
        goto Error;

    // check if it supports video
    BOOL fSupportsVideo;

    if (AddressSupportsMediaType (m_pH323Addr, TAPIMEDIATYPE_VIDEO))
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lH323MediaType = TAPIMEDIATYPE_AUDIO;

    *phr = m_pH323Addr->QueryInterface(&pIH323LineEx);
    if (SUCCEEDED(*phr))
    {
        *phr = pIH323LineEx->SetExternalT120Address(TRUE, INADDR_ANY, 1503);

        H245_CAPABILITY Capabilities[] = 
            {HC_G711, HC_G723, HC_H263QCIF, HC_H261QCIF};
        DWORD Weights[] = {200, 100, 100, 0};

        *phr = pIH323LineEx->SetDefaultCapabilityPreferrence(
            4, Capabilities, Weights
            );

        *phr = pIH323LineEx->SetAlias (SelfAlias, wcslen (SelfAlias));
    }

    // register call notification
    *phr = m_pTapi->RegisterCallNotifications (
        m_pH323Addr,
        VARIANT_TRUE,
        VARIANT_TRUE,
        m_lH323MediaType,
        ulTapiEventAdvise,
        &lCallNotif
        );
    if (FAILED(*phr))
        goto Error;

    // find sdp address
    *phr = FindAddress (
        LINEADDRESSTYPE_SDP,
        NULL,
        TAPIMEDIATYPE_AUDIO,
        &m_pSDPAddr
        );
    if (FAILED(*phr))
        goto Error;
    
    // check if it supports video
    if (AddressSupportsMediaType (m_pSDPAddr, TAPIMEDIATYPE_VIDEO))
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO;
    else
        m_lSDPMediaType = TAPIMEDIATYPE_AUDIO;

Cleanup:
    if (pEventNotif)
        pEventNotif->Release ();
    if (pPoint)
        pPoint->Release ();
    if (pContainer)
        pContainer->Release ();
    if (pIH323LineEx)
        pIH323LineEx->Release ();

    LOG ((BG_TRACE, "%s returns", __fxName));
    return;

Error:
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
        m_pH323Addr = NULL;
    }
    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
        m_pSDPAddr = NULL;
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
        m_pTapi = NULL;
    }
    if (m_pList)
    {
        delete m_pList;
    }

    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
CBridgeApp::~CBridgeApp ()
{
    if (m_pList)
    {
        // all calls should already been disconnected
        delete m_pList;
    }
    if (m_pSDPAddr)
    {
        m_pSDPAddr->Release ();
    }
    if (m_pH323Addr)
    {
        m_pH323Addr->Release ();
    }
    if (m_pTapi)
    {
        m_pTapi->Release ();
    }
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::CreateH323Call (IDispatch *pEvent)
{
    ENTER_FUNCTION ("CBridgeApp::CreateH323Call");
    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;
    BSTR bstrID = NULL;
    BSTR bstrName = NULL;
    BSTR CallerIDNumber = NULL;

    ITCallNotificationEvent *pNotify = NULL;
    ITCallInfo *pCallInfo = NULL;
    ITBasicCallControl *pCallControl = NULL;
    IUnknown *pIUnknown = NULL;

    CBridgeItem *pItem = NULL;

    // check privilege
    CALL_PRIVILEGE privilege;

    // get call event interface
    hr = pEvent->QueryInterface (
        IID_ITCallNotificationEvent,
        (void **)&pNotify
        );
    if (FAILED(hr))
        return hr;

    // get call info
    hr = pNotify->get_Call (&pCallInfo);
    if (FAILED(hr))
        goto Error;

    // if we own the call
    hr = pCallInfo->get_Privilege (&privilege);
    if (FAILED(hr))
        goto Error;

    if (CP_OWNER != privilege)
    {
        hr = E_UNEXPECTED;
        goto Error;
    }

    // get call info string
    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNAME, &bstrName);
    if (FAILED (hr))
        goto Error;

    hr = pCallInfo->get_CallInfoString(CIS_CALLERIDNUMBER, &CallerIDNumber);
    if (FAILED(hr))
        goto Error;

    // construct the caller id
    bstrID = SysAllocStringLen(NULL, 
        SysStringLen(bstrName) + SysStringLen(CallerIDNumber) + 2);

    wsprintfW(bstrID, L"%ws@%ws", bstrName, CallerIDNumber);

    hr = pCallInfo->QueryInterface (
        IID_ITBasicCallControl,
        (void **)&pCallControl
        );
    if (FAILED(hr))
        goto Error;

    // check if there is an item with same id
    if (FAILED (hr = pCallInfo->QueryInterface (IID_IUnknown, (void**)&pIUnknown)))
        goto Error;
    pItem = m_pList->FindByH323 (pIUnknown);
    pIUnknown->Release ();
    pIUnknown = NULL;

    if (NULL != pItem)
    {
        // @@ we are already in a call from the same ID
        // @@ should have some debug info and feedback?
        hr = pCallControl->Disconnect (DC_REJECTED);
        // don't care the return value of diconnect

        hr = E_ABORT;
        goto Error;
    }

    // everything is right, store the call
    pItem = new CBridgeItem;
    if (NULL == pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pItem->bstrID = bstrID;
    pItem->bstrName = bstrName;
    pItem->pCallH323 = pCallControl;

    m_pList->Append (pItem);

Cleanup:
    if (pNotify) pNotify->Release ();
    if (pCallInfo) pCallInfo->Release();
    if (CallerIDNumber) SysFreeString(CallerIDNumber);

    LOG ((BG_TRACE, "%s returns, %x", __fxName, hr));
    return hr;

Error:
    if (bstrID) SysFreeString (bstrID);
    if (bstrName) SysFreeString (bstrName);
    if (pCallControl) pCallControl->Release ();

    goto Cleanup;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::CreateSDPCall (CBridgeItem *pItem)
{
    ENTER_FUNCTION ("CBridgeApp::CreateSDPCall");
    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;

    // create call, ignore bstrDestAddr, hardcode it here
    ITBasicCallControl *pCall = NULL;
    BSTR bstrFixedDest;
    
    if (glpCmdLine[0] == '\0')
        bstrFixedDest = SysAllocString (MySDP);
    else
        bstrFixedDest = SysAllocString (MySDP2);

    hr = m_pSDPAddr->CreateCall (
        bstrFixedDest, // bstrDestAddr,
        LINEADDRESSTYPE_SDP,
        m_lSDPMediaType,
        &pCall
        );
    SysFreeString (bstrFixedDest);

    if (FAILED(hr))
        return hr;

    // store the call
    pItem->pCallSDP = pCall;

    LOG ((BG_TRACE, "%s returns", __fxName));
    return hr;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::BridgeCalls (CBridgeItem *pItem)
{
    ENTER_FUNCTION ("CBridgeApp::BridgeCalls");
    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr;

    hr = SetupParticipantInfo (pItem);
	if (FAILED(hr))
        return hr;

    hr = SetMulticastMode (pItem);
	if (FAILED(hr))
        return hr;

    if (FAILED (hr = CreateBridgeTerminals (pItem)))
        return hr;

    if (FAILED (hr = GetStreams (pItem)))
        return hr;

    if (FAILED (hr = SelectBridgeTerminals (pItem)))
        return hr;

    // connect h323 call
    if (FAILED (hr = pItem->pCallH323->Answer ()))
        return hr;

    // connect sdp call
    if (FAILED (hr = pItem->pCallSDP->Connect (VARIANT_TRUE)))
    {
        pItem->pCallH323->Disconnect (DC_NORMAL);
        return hr;
    }

    LOG ((BG_TRACE, "%s returns", __fxName));
    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::DisconnectCall (CBridgeItem *pItem, DISCONNECT_CODE dc)
{
    // disconnect
    if (pItem->pCallH323)
        pItem->pCallH323->Disconnect (dc);
    if (pItem->pCallSDP)
        pItem->pCallSDP->Disconnect (dc);

    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::DisconnectAllCalls (DISCONNECT_CODE dc)
{
    // i should have a better way to traverse each call
    CBridgeItem ** pItemArray;
    int num, i;

    // out of memory
    if (!m_pList->GetAllItems (&pItemArray, &num))
        return E_OUTOFMEMORY;

    // no calls
    if (num == 0)
        return S_OK;

    for (i=0; i<num; i++)
    {
        // disconnect each call
        if (pItemArray[i]->pCallH323)
            pItemArray[i]->pCallH323->Disconnect (dc);
        if (pItemArray[i]->pCallSDP)
            pItemArray[i]->pCallSDP->Disconnect (dc);
        // do not delete item
    }

    free (pItemArray);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::RemoveCall (CBridgeItem *pItem)
{
    m_pList->TakeOut (pItem);
    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::HasH323Call (IDispatch *pEvent, CBridgeItem **ppItem)
{
    HRESULT hr;

    ITCallStateEvent *pState = NULL;
    ITCallInfo *pCallInfo = NULL;

    IUnknown * pIUnknown = NULL;

    // ignore null checking
    if (*ppItem)
    {
        delete *ppItem;
        *ppItem = NULL;
    }

    // get call state event
    hr = pEvent->QueryInterface (
        IID_ITCallStateEvent,
        (void **)&pState
        );
    if (FAILED(hr))
        return hr;

    // check privilege
    CALL_PRIVILEGE privilege;

    // get call event interface
    hr = pState->get_Call (&pCallInfo);
    if (FAILED(hr))
        return hr;

    // if we own the call
    hr = pCallInfo->get_Privilege (&privilege);
    if (FAILED(hr))
        goto Error;

    if (CP_OWNER != privilege)
    {
        hr = E_UNEXPECTED;
        goto Error;
    }

    // get IUnknown
    if (FAILED (hr = pCallInfo->QueryInterface (IID_IUnknown, (void **)&pIUnknown)))
        goto Error;
    *ppItem = m_pList->FindByH323 (pIUnknown);

Cleanup:
    if (pCallInfo) pCallInfo->Release ();
    if (pIUnknown) pIUnknown->Release ();
    if (pState) pState->Release ();

    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::HasCalls ()
{
    if (m_pList->IsEmpty ())
        return S_FALSE;
    else
        return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::CreateBridgeTerminals (CBridgeItem *pItem)
{
    HRESULT hr;
    IConfBridge *pConfBridge = NULL;

    // create CConfBridge
    hr = CoCreateInstance (
        __uuidof(ConfBridge),
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IConfBridge,
        (LPVOID *)&pConfBridge
        );
    if (FAILED(hr))
        return hr;

    // create terminal: video H323->SDP
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_VIDEO,
        &(pItem->pTermHSVid)
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio H323->SDP
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_AUDIO,
        &(pItem->pTermHSAud)
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: video SDP->H323
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_VIDEO,
        &(pItem->pTermSHVid)
        );
    if (FAILED(hr))
        goto Error;

    // create terminal: audio SDP->H323
    hr = pConfBridge->CreateBridgeTerminal (
        TAPIMEDIATYPE_AUDIO,
        &(pItem->pTermSHAud)
        );
    if (FAILED(hr))
        goto Error;

Cleanup:
    pConfBridge->Release ();
    pConfBridge = NULL;

    return hr;

Error:
    goto Cleanup;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::GetStreams (CBridgeItem *pItem)
{
    ITStreamControl *pStreamControl = NULL;
    IEnumStream *pEnumStreams = NULL;
    ITStream *pStream = NULL;

    // get stream control on H323
    HRESULT hr = pItem->pCallH323->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        return hr;

    // get enum stream on H323
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    pStreamControl->Release ();
    pStreamControl = NULL;

    if (FAILED(hr))
        return hr;

    // iterate each stream on H323
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
            pItem->pStreamHVidCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
        {
            pItem->pStreamHVidRen = pStream;

            IKeyFrameControl* pIKeyFrameControl = NULL;
            hr = pStream->QueryInterface(&pIKeyFrameControl);
            if (SUCCEEDED(hr))
            {
                hr = pIKeyFrameControl->PeriodicUpdatePicture(TRUE, 5);
                pIKeyFrameControl->Release();
            }
        }

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
            pItem->pStreamHAudCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
            pItem->pStreamHAudRen = pStream;

        else
        {
            pEnumStreams->Release ();
            // @@ IsStream doesn't return hresult
            return E_FAIL;
        }
    }

    // don't release pStream, it's stored in pItem
    pEnumStreams->Release ();
    pEnumStreams = NULL;

    //========================================

    // get stream control on SDP
    hr = pItem->pCallSDP->QueryInterface (
        IID_ITStreamControl,
        (void **)&pStreamControl
        );
    if (FAILED(hr))
        return hr;

    // get enum stream on SDP
    hr = pStreamControl->EnumerateStreams (&pEnumStreams);
    pStreamControl->Release ();
    pStreamControl = NULL;

    if (FAILED(hr))
        return hr;

    // iterate each stream on SDP
    while (S_OK == pEnumStreams->Next (1, &pStream, NULL))
    {
        if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_CAPTURE))
            pItem->pStreamSVidCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_VIDEO, TD_RENDER))
            pItem->pStreamSVidRen = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_CAPTURE))
            pItem->pStreamSAudCap = pStream;

        else if (IsStream (pStream, TAPIMEDIATYPE_AUDIO, TD_RENDER))
            pItem->pStreamSAudRen = pStream;

        else
        {
            pEnumStreams->Release ();
            // @@ IsStream doesn't return hresult
            return E_FAIL;
        }
    }

    // don't release pStream, it's stored in pItem
    pEnumStreams->Release ();
    pEnumStreams = NULL;

    return S_OK;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::SelectBridgeTerminals (CBridgeItem *pItem)
{
    HRESULT hr;

    // sdp->h323 audio pair
    if (FAILED (hr = pItem->pStreamHAudCap->SelectTerminal (pItem->pTermSHAud)))
        return hr;
    if (FAILED (hr = pItem->pStreamSAudRen->SelectTerminal (pItem->pTermSHAud)))
        return hr;

    // h323->sdp audio pair
    if (FAILED (hr = pItem->pStreamSAudCap->SelectTerminal (pItem->pTermHSAud)))
        return hr;
    if (FAILED (hr = pItem->pStreamHAudRen->SelectTerminal (pItem->pTermHSAud)))
        return hr;

    // sdp->h323 video pair
    if (FAILED (hr = pItem->pStreamHVidCap->SelectTerminal (pItem->pTermSHVid)))
        return hr;
    if (FAILED (hr = pItem->pStreamSVidRen->SelectTerminal (pItem->pTermSHVid)))
        return hr;

    // h323->sdp video pair
    if (FAILED (hr = pItem->pStreamSVidCap->SelectTerminal (pItem->pTermHSVid)))
        return hr;
    if (FAILED (hr = pItem->pStreamHVidRen->SelectTerminal (pItem->pTermHSVid)))
        return hr;

    return S_OK;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::SetupParticipantInfo (CBridgeItem *pItem)
{
    HRESULT hr = S_OK;
    ITLocalParticipant *pLocalParticipant = NULL;

    // set the CName on the SDP side.
    hr = pItem->pCallSDP->QueryInterface(&pLocalParticipant);
    if (FAILED(hr)) goto Cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_CANONICALNAME, pItem->bstrID
        );
    if (FAILED(hr)) goto Cleanup;

    hr = pLocalParticipant->put_LocalParticipantTypedInfo(
        PTI_NAME, pItem->bstrName
        );

    if (FAILED(hr)) goto Cleanup;

Cleanup:
    if (pLocalParticipant) pLocalParticipant->Release();

    return hr;
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::SetMulticastMode (CBridgeItem *pItem)
{
    IMulticastControl * pIMulticastControl = NULL;
    
    HRESULT hr = pItem->pCallSDP->QueryInterface(&pIMulticastControl);
    if (FAILED(hr)) return hr;

    hr = pIMulticastControl->put_LoopbackMode(MM_SELECTIVE_LOOPBACK);

    pIMulticastControl->Release();

    return hr;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::FindAddress (long dwAddrType, BSTR bstrAddrName, long lMediaType, ITAddress **ppAddr)
{
    HRESULT hr;
    IEnumAddress *pEnumAddr = NULL;
    ITAddress *pAddr = NULL;
    ITAddressCapabilities *pAddrCaps = NULL;

    BOOL fFound = false;
    long lTypeFound;
    BSTR bstrAddrNameFound = NULL;

    // clear output address
    if ((*ppAddr))
    {
        (*ppAddr)->Release ();
        (*ppAddr) = NULL;
    }
    
    // enumerate the address
    hr = m_pTapi->EnumerateAddresses (&pEnumAddr);
    if (FAILED(hr))
    {
        // @@ should have some debug info here
        goto Error;
    }
    // loop to find the right address
    while (!fFound)
    {
        // next address
        if (pAddr)
        {
            pAddr->Release ();
            pAddr = NULL;
        }
        hr = pEnumAddr->Next (1, &pAddr, NULL);
        if (S_OK != hr)
            break;

        if (dwAddrType != 0) 
        {
            // addr type is valid, ignore addr name
            if (pAddrCaps)
            {
                pAddrCaps->Release ();
                pAddrCaps = NULL;
            }
            hr = pAddr->QueryInterface (
                IID_ITAddressCapabilities,
                (void **)&pAddrCaps
                );
            if (FAILED(hr))
            {
                // @@ debug info here
                // DoMessage (L"Failed to retrieve address capabilities");
                goto Error;
            }

            // find address type supported
            hr = pAddrCaps->get_AddressCapability (AC_ADDRESSTYPES, &lTypeFound);
            if (FAILED(hr))
            {
                // DoMessage (L"Failed to get address type");
                goto Error;
            }

            // check if the type we wanted
            if (dwAddrType != lTypeFound)
                continue;
        }
        else if (bstrAddrName != NULL)
        {
            hr = pAddr->get_AddressName (&bstrAddrNameFound);
            if (FAILED(hr))
            {
                // DoMessage (L"Failed to get address name");
                goto Error;
            }
            if (wcscmp(bstrAddrName, bstrAddrNameFound) != 0)
                continue;
        }
        else
        {
            // DoMessage (L"Both address type and name are null. Internal error");
            hr = E_UNEXPECTED;
            goto Error;
        }

        // now check media type
        if (AddressSupportsMediaType (pAddr, lMediaType))
            fFound = true;
    } // end of while (!fFound)

    if (fFound)
    {
        (*ppAddr) = pAddr;
        (*ppAddr)->AddRef ();
    }

Cleanup:
    if (pAddrCaps)
        pAddrCaps->Release ();
    if (pAddr)
        pAddr->Release ();
    if (pEnumAddr)
        pEnumAddr->Release ();
    return hr;

Error:
    goto Cleanup;
}


/*///////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeApp::AddressSupportsMediaType (ITAddress *pAddr, long lMediaType)
{
    VARIANT_BOOL vbSupport = VARIANT_FALSE;
    ITMediaSupport * pMediaSupport;

    if (SUCCEEDED(pAddr->QueryInterface (IID_ITMediaSupport, (void**)&pMediaSupport)))
    {
        pMediaSupport->QueryMediaType (lMediaType, &vbSupport);
        pMediaSupport->Release ();
    }
    return (vbSupport==VARIANT_TRUE);
}

/*///////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeApp::IsStream (ITStream *pStream, long lMediaType, TERMINAL_DIRECTION tdDirection)
{
    long mediatype;
    TERMINAL_DIRECTION direction;

    if (FAILED (pStream->get_Direction(&direction)))
        return false;
    if (FAILED (pStream->get_MediaType(&mediatype)))
        return false;
    return ((direction == tdDirection) &&
           (mediatype == lMediaType));
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::NextSubStream ()
{
    HRESULT hr = S_OK;

    CBridgeItem **ItemArray = NULL;
    int num, i;

    ITSubStreamControl *pSubControl = NULL;
    IEnumSubStream *pEnumSub = NULL;
    ULONG fetched;
    ITSubStream *pSubStream = NULL;
    BOOL fActive = FALSE; // if active stream found
    ITSubStream *pSubInactive = NULL;
    ITSubStream *pSubFirstInactive = NULL;

    IEnumTerminal *pEnumTerminal = NULL;
    ITParticipantSubStreamControl *pSwitcher = NULL;

    // get all stored call items
    if (FAILED (hr = m_pList->GetAllItems (&ItemArray, &num)))
        return hr;

    if (num == 0)
        return S_OK;

    // for each call item
    for (i=0; i<num; i++)
    {
        // get substream control
        if (NULL == ItemArray[i]->pStreamSVidRen)
            continue;
        if (FAILED (hr = ItemArray[i]->pStreamSVidRen->QueryInterface (&pSubControl)))
            goto Error;

        // get substreams on sdp video render
        if (FAILED (hr = pSubControl->EnumerateSubStreams (&pEnumSub)))
            goto Error;

        pSubControl->Release ();
        pSubControl = NULL;

        // for each substream, if !(both active & inactive substream stored)
        // the algo tries to be as fair as possible in switching.
        // it switches the inactive substream just after the active one
        // if the active one is the last in the enum, the first inactive one is chosen
        while (!pSubInactive &&
               (S_OK == (hr = pEnumSub->Next (1, &pSubStream, &fetched)))
              )
        {
            // get terminal enumerator
            if (FAILED (hr = pSubStream->EnumerateTerminals (&pEnumTerminal)))
                goto Error;

            // if the substream active, store the substream
            if (S_OK == pEnumTerminal->Skip (1))
            {
                if (fActive)
                    ;
                //    printf ("oops, another active substream on SDP video render stream");
                else
                    fActive = TRUE;
            }
            else
            {
                // if inactive, store the substream
                if (!pSubFirstInactive)
                {
                    // the first inactive substream
                    pSubFirstInactive = pSubStream;
                    pSubFirstInactive->AddRef ();
                }
                else
                {
                    // store the inactive only if the active was found
                    if (fActive)
                    {
                        pSubInactive = pSubStream;
                        pSubInactive->AddRef ();
                    }
                }
            }

            // release
            pEnumTerminal->Release ();
            pEnumTerminal = NULL;

            pSubStream->Release ();
            pSubStream = NULL;
        }

        pEnumSub->Release ();
        pEnumSub = NULL;

        // if only first inactive is found
        if (pSubFirstInactive && !pSubInactive)
        {
            pSubInactive = pSubFirstInactive;
            pSubFirstInactive = NULL;
        }

        // if not found two substreams, do nothing
        if (pSubInactive && ItemArray[i]->pStreamSVidRen && ItemArray[i]->pTermSHVid)
        {
            if (FAILED (hr = ItemArray[i]->pStreamSVidRen->QueryInterface (&pSwitcher)))
                goto Error;

            // switch terminal on substream
            if (FAILED (hr = pSwitcher->SwitchTerminalToSubStream
                                 (ItemArray[i]->pTermSHVid, pSubInactive)))
                goto Error;

            pSwitcher->Release ();
            pSwitcher = NULL;
        }

        if (pSubFirstInactive)
        {
            pSubFirstInactive->Release ();
            pSubFirstInactive = NULL;
        }
        if (pSubInactive)
        {
            pSubInactive->Release ();
            pSubInactive = NULL;
        }
    }

Cleanup:
    if (ItemArray) free (ItemArray);
    return hr;

Error:
    if (pSubControl) pSubControl->Release ();
    if (pEnumSub) pEnumSub->Release ();

    if (pSubStream) pSubStream->Release ();
    if (pSubInactive) pSubInactive->Release ();
    if (pSubFirstInactive) pSubFirstInactive->Release ();

    if (pEnumTerminal) pEnumTerminal->Release ();
    if (pSwitcher) pSwitcher->Release ();

    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CBridgeApp::ShowParticipant (ITBasicCallControl *pSDPCall, ITParticipant *pParticipant)
{
    ENTER_FUNCTION ("CBridgeApp::ShowParticipant");

    HRESULT hr;
    IUnknown *pIUnknown = NULL;
    CBridgeItem *pItem = NULL;
    ITParticipantSubStreamControl *pSwitcher = NULL;
    ITSubStream *pSubStream = NULL;

    // get IUnknown
    if (FAILED (hr = pSDPCall->QueryInterface (IID_IUnknown, (void**)&pIUnknown)))
    {
        LOG ((BG_ERROR, "%s failed to query interface IUnknown, %x", __fxName, hr));
        return hr;
    }

    // find the item matches pSDPCall
    pItem = m_pList->FindBySDP (pIUnknown);
    pIUnknown->Release ();
    pIUnknown = NULL;

    // oops, no match
    if (NULL == pItem)
        return S_FALSE;

    // get participant substream control interface
    if (NULL == pItem->pStreamSVidRen)
        return S_OK;
    if (FAILED (hr = pItem->pStreamSVidRen->QueryInterface (&pSwitcher)))
    {
        LOG ((BG_ERROR, "%s failed to query interface ITParticipantSubStreamControl, %x", __fxName, hr));
        return hr;
    }

    // get substream from participant
    if (FAILED (hr = pSwitcher->get_SubStreamFromParticipant (pParticipant, &pSubStream)))
    {
        pSwitcher->Release ();
        pSwitcher = NULL;
        LOG ((BG_WARN, "%s failed to get substream from participant, %x", __fxName, hr));
        // stream from h323 side does not have substream, report false
        return S_FALSE;
    }

    // switch
    if (pItem->pTermSHVid)
        hr = pSwitcher->SwitchTerminalToSubStream (pItem->pTermSHVid, pSubStream);
    
    pSubStream->Release ();
    pSubStream = NULL;

    pSwitcher->Release ();
    pSwitcher = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgdebug.cpp ===
/*++

Module Name

    bgdebug.cpp

Description

    Implements functions used for debugging

Note

    Revised based on msplog.cpp which is not available to bridge test app

--*/

#include "stdafx.h"
#include <stdio.h>

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwDebuggerMask      = 0;


BOOL BGLogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
		DWORD      dwDataSize = sizeof (DWORD);
		DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

void BGLogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void BGLogPrint(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    static char * message[24] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        switch(dwDbgLevel)
        {
        case BG_ERROR: dwIndex = 0; break;
        case BG_WARN:  dwIndex = 1; break;
        case BG_INFO:  dwIndex = 2; break;
        case BG_TRACE: dwIndex = 3; break;
        case BG_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        va_list arglist;
        va_start(arglist, lpszFormat);
        TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
        va_end(arglist);
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    don't assume enum value doesn't change
////*/
// the order should be the same as event type enum
char* gsaType[] =
{
    "Tapi Event",
    "Call State",
    "Call Media",
    "Participant Event"
};

typedef struct
{
    int id;
    char *str;
}EVENT_ITEM;

//========================================
EVENT_ITEM gaTE[]=
{
    TE_TAPIOBJECT,          "Tapi Object",
    TE_ADDRESS,             "Address",
    TE_CALLNOTIFICATION,    "Call Notification",
    TE_CALLSTATE,           "Call State",
    TE_CALLMEDIA,           "Call Media",
    TE_CALLHUB,             "Call Hub",
    TE_CALLINFOCHANGE,      "Call Info Change",
    TE_PRIVATE,             "Private",
    TE_REQUEST,             "Request",
    TE_AGENT,               "Agent",
    TE_AGENTSESSION,        "Agent Session",
    TE_QOSEVENT,            "QoS Event",
    TE_AGENTHANDLER,        "Agent Handler",
    TE_ACDGROUP,            "ACD Group",
    TE_QUEUE,               "Queue",
    TE_DIGITEVENT,          "Digit Event",
    TE_GENERATEEVENT,       "Generate Event"
};

int giaTENum = sizeof (gaTE) / sizeof (EVENT_ITEM);

//========================================
EVENT_ITEM gaCS[] =
{
    CS_IDLE,            "IDLE",
    CS_INPROGRESS,      "In Progress",
    CS_CONNECTED,       "Connected",
    CS_DISCONNECTED,    "Disconnected",
    CS_OFFERING,        "Offering",
    CS_HOLD,            "Hold",
    CS_QUEUED,          "Queued"
};

int giaCSNum = sizeof (gaCS) / sizeof (EVENT_ITEM);

//========================================
EVENT_ITEM gaCME[] =
{
    CME_NEW_STREAM,         "New Stream",
    CME_STREAM_FAIL,        "Stream Fail",
    CME_TERMINAL_FAIL,      "Terminal Fail",
    CME_STREAM_NOT_USED,    "Stream Not Used",
    CME_STREAM_ACTIVE,      "Stream Active",
    CME_STREAM_INACTIVE,    "Stream Inactive"
};

int giaCMENum = sizeof (gaCME) / sizeof (EVENT_ITEM);

//========================================
EVENT_ITEM gaPE[] =
{
    PE_NEW_PARTICIPANT,         "New Participant",
    PE_INFO_CHANGE,             "Info Change",
    PE_PARTICIPANT_LEAVE,       "Participant Leave",

    PE_NEW_SUBSTREAM,           "New Substream",
    PE_SUBSTREAM_REMOVED,       "Substream Removed",

    PE_SUBSTREAM_MAPPED,        "Substream Mapped",
    PE_SUBSTREAM_UNMAPPED,      "SubStream Unmapped",

    PE_PARTICIPANT_TIMEOUT,     "Participant Timeout",
    PE_PARTICIPANT_RECOVERED,   "Participant Recovered",

    PE_PARTICIPANT_ACTIVE,      "Participant Active",
    PE_PARTICIPANT_INACTIVE,    "Participant Inactive",

    PE_LOCAL_TALKING,           "Local Talking",
    PE_LOCAL_SILENT,            "Local Silent"
};

int giaPENum = sizeof (gaPE) / sizeof (EVENT_ITEM);

/*//////////////////////////////////////////////////////////////////////////////
////*/
void BGLogEvent (EVENT_TYPE EventType, int event)
{
    EVENT_ITEM *aEvent;
    int i, num;

    switch (EventType)
    {
    case BG_TE:
        aEvent = gaTE;
        num = giaTENum;
        break;
    case BG_CS:
        aEvent = gaCS;
        num = giaCSNum;
        break;
    case BG_CME:
        aEvent = gaCME;
        num = giaCMENum;
        break;
    case BG_PE:
        aEvent = gaPE;
        num = giaPENum;
        break;
    default:
        LOG ((BG_ERROR, "Unsupported event type (%d, %d)", EventType, event));
        return;
        break;
    }

    // search the event index string
    for (i=0; i<num; i++)
    {
        if (event != aEvent[i].id)
            continue;

        // match
        LOG ((BG_EVENT, "%s: %s (%d, %d)",
            gsaType[EventType], aEvent[i].str, EventType, event));
        return;
    }

    // not found
    LOG ((BG_ERROR, "Event string not found (%d, %d)", EventType, event));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgitem.cpp ===
/*******************************************************************************

Module Name:

    bgitem.cpp

Abstract:

    Implements CBridgeItem and CBridgeItemList

Author:

    Qianbo Huai (qhuai) Jan 28 2000

*******************************************************************************/

#include "stdafx.h"

/*///////////////////////////////////////////////////////////////////////////////
    constructs CBridgeItem
////*/
CBridgeItem::CBridgeItem ()
    :next (NULL)
    ,prev (NULL)

    ,bstrID (NULL)
    ,bstrName (NULL)

    ,pCallH323 (NULL)
    ,pCallSDP (NULL)

    ,pTermHSAud (NULL)
    ,pTermHSVid (NULL)
    ,pTermSHAud (NULL)
    ,pTermSHVid (NULL)

    ,pStreamHAudCap (NULL)
    ,pStreamHAudRen (NULL)
    ,pStreamHVidCap (NULL)
    ,pStreamHVidRen (NULL)

    ,pStreamSAudCap (NULL)
    ,pStreamSAudRen (NULL)
    ,pStreamSVidCap (NULL)
    ,pStreamSVidRen (NULL)
{
}

/*//////////////////////////////////////////////////////////////////////////////
    destructs CBridgeItem
////*/
CBridgeItem::~CBridgeItem ()
{
    // free BSTR
    if (bstrID)
    {
        SysFreeString (bstrID);
        bstrID = NULL;
    }
    if (bstrName)
    {
        SysFreeString (bstrName);
        bstrName = NULL;
    }

    // free terminals
    if (pTermHSAud)
    {
        pTermHSAud->Release ();
        pTermHSAud = NULL;
    }
    if (pTermHSVid)
    {
        pTermHSVid->Release ();
        pTermHSVid = NULL;
    }
    if (pTermSHAud)
    {
        pTermSHAud->Release ();
        pTermSHAud = NULL;
    }
    if (pTermSHVid)
    {
        pTermSHVid->Release ();
        pTermSHVid = NULL;
    }

    // free streams on H323
    if (pStreamHAudCap)
    {
        pStreamHAudCap->Release ();
        pStreamHAudCap = NULL;
    }
    if (pStreamHAudRen)
    {
        pStreamHAudRen->Release ();
        pStreamHAudRen = NULL;
    }
    if (pStreamHVidCap)
    {
        pStreamHVidCap->Release ();
        pStreamHVidCap = NULL;
    }
    if (pStreamHVidRen)
    {
        pStreamHVidRen->Release ();
        pStreamHVidRen = NULL;
    }

    // free streams on SDP
    if (pStreamSAudCap)
    {
        pStreamSAudCap->Release ();
        pStreamSAudCap = NULL;
    }
    if (pStreamSAudRen)
    {
        pStreamSAudRen->Release ();
        pStreamSAudRen = NULL;
    }
    if (pStreamSVidCap)
    {
        pStreamSVidCap->Release ();
        pStreamSVidCap = NULL;
    }
    if (pStreamSVidRen)
    {
        pStreamSVidRen->Release ();
        pStreamSVidRen = NULL;
    }

    // free calls
    if (pCallH323)
    {
        pCallH323->Release ();
        pCallH323 = NULL;
    }
    if (pCallSDP)
    {
        pCallSDP->Release ();
        pCallSDP = NULL;
    }

}

/*//////////////////////////////////////////////////////////////////////////////
    constructs CBridgeItemList
////*/
CBridgeItemList::CBridgeItemList ()
{
    // create a head for the double linked list
    m_pHead = new CBridgeItem;
    if (NULL == m_pHead)
    {
        // @@ severe error, outof memory? put some debug info here?
        return;
    }

    m_pHead->next = m_pHead;
    m_pHead->prev = m_pHead;
}

/*//////////////////////////////////////////////////////////////////////////////
    destructs CBridgeItemList
////*/
CBridgeItemList::~CBridgeItemList ()
{
    // app should already disconnected all calls
    // i just release the com objects here
    CBridgeItem *pItem = NULL;

    while (NULL != (pItem = DeleteFirst ()))
    {
        delete pItem;
        pItem = NULL;
    }

    delete m_pHead;
    m_pHead = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
#define FIND_BY_H323 1
#define FIND_BY_SDP 2

CBridgeItem *
CBridgeItemList::Find (int flag, IUnknown *pIUnknown)
{
    // transfer through the list, stop at the first matches
    HRESULT hr;
    IUnknown *pStore = NULL;
    CBridgeItem *pItem = m_pHead;

    while (m_pHead != (pItem = pItem->next))
    {
        // @@ should report error info if failed
        if (flag == FIND_BY_H323)
            hr = pItem->pCallH323->QueryInterface (IID_IUnknown, (void**)&pStore);
        else
            hr = pItem->pCallSDP->QueryInterface (IID_IUnknown, (void**)&pStore);

        if (FAILED (hr))
            return NULL;

        if (pIUnknown == pStore)
        {
            pStore->Release ();
            return pItem;
        }
        if (pStore)
        {
            pStore->Release ();
            pStore = NULL;
        }
    }

    return NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    finds a bridge item based on IUnknown of H323 call
////*/
CBridgeItem *
CBridgeItemList::FindByH323 (IUnknown *pIUnknown)
{
    return Find (FIND_BY_H323, pIUnknown);
}

/*//////////////////////////////////////////////////////////////////////////////
    finds a bridge item based on IUnknown of sdp call
////*/
CBridgeItem *
CBridgeItemList::FindBySDP (IUnknown *pIUnknown)
{
    return Find (FIND_BY_SDP, pIUnknown);
}

/*//////////////////////////////////////////////////////////////////////////////
    takes the item out of the list
////*/
void
CBridgeItemList::TakeOut (CBridgeItem *pItem)
{
    // ignore to check if pItem is really in the list
    pItem->next->prev = pItem->prev;
    pItem->prev->next = pItem->next;

    pItem->next = NULL;
    pItem->prev = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    deletes from the list and returns the first item if the list is not empty
////*/
CBridgeItem *
CBridgeItemList::DeleteFirst ()
{
    CBridgeItem *pItem = m_pHead->next;
    
    // if list empty
    if (pItem == m_pHead)
        return NULL;

    // adjust list
    TakeOut (pItem);

    return pItem;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeItemList::GetAllItems (CBridgeItem ***pItemArray, int *pNum)
{
    // ignore checking pointers
    int num = 0;
    CBridgeItem *pItem = m_pHead;

    while (m_pHead != (pItem = pItem->next))
        num ++;

    // no call found
    if (num == 0)
    {
        *pItemArray == NULL;
        *pNum = 0;
        return true;
    }

    *pItemArray = (CBridgeItem**)malloc (num * sizeof (CBridgeItem*));
    *pNum = num;

    if (NULL == *pItemArray)
    {
        return false;
    }

    // copy items pointers
    pItem = m_pHead;
    num = 0;
    while (m_pHead != (pItem = pItem->next))
        (*pItemArray)[num++] = pItem;

    return true;
}

/*//////////////////////////////////////////////////////////////////////////////
    appends an item to the end of the list
////*/
void
CBridgeItemList::Append (CBridgeItem *pItem)
{
    pItem->next = m_pHead;
    pItem->prev = m_pHead->prev;
    pItem->next->prev = pItem;
    pItem->prev->next = pItem;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
BOOL
CBridgeItemList::IsEmpty ()
{
    if (m_pHead->next == m_pHead)
        return true;
    else
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by work.rc
//
#define IDD_MAINDLG                     101
#define IDC_DISCONNECT                  1000
#define IDC_EXIT                        1001
#define IDC_STATUS                      1002
#define IDC_NEXTSUBSTREAM               1006
#define IDC_REJECT                      1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <objbase.h>
#include <winsock2.h>
#include <tapi3.h>
#include <control.h>
#include <strmif.h>
#include <confpriv.h>
#include <h323priv.h>
#include <rtutils.h>

#include "bgdebug.h"
#include "resource.h"
#include "bgevent.h"
#include "bgitem.h"
#include "bgapp.h"

// H323 call listener sends event to dialog box
#define WM_PRIVATETAPIEVENT   WM_USER+101

// use log functions by msp
#ifdef BGDEBUG
    #define ENTER_FUNCTION(s) \
        const CHAR __fxName[] = s
#else
    #define ENTER_FUNCTION(s)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\inc\confpdu.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confpdu.h

Abstract:

    Declaration of the data structures used in the communication between
    the IPconf tsp and the ipconf msp.

Author:
    
    Mu Han (muhan) 5-September-1998

--*/

#ifndef __CONFPDU_H_
#define __CONFPDU_H_

typedef enum 
{
    // sent from TSP to MSP to start a call
    CALL_START,
             
    // sent from TSP to MSP to stop a call
    CALL_STOP,
     
    // sent from MSP to TSP to notify that the call is connected.
    CALL_CONNECTED,    

    // sent from MSP to TSP to notify that the call is disconnected.
    CALL_DISCONNECTED,

    // sent from MSP to TSP to notify that the call is disconnected.
    CALL_QOS_EVENT

} TSP_MSP_COMMAND;

typedef struct _MSG_CALL_START 
{
    DWORD dwAudioQOSLevel;
    DWORD dwVideoQOSLevel;
    
    DWORD dwSDPLen;    // number of wchars in the string.
    WCHAR szSDP[1];

} MSG_CALL_START, *PMSG_CALL_START;

typedef struct _MSG_CALL_DISCONNECTED 
{
    DWORD dwReason;

} MSG_CALL_DISCONNECTED, *PMSG_CALL_DISCONNECTED;

typedef struct _MSG_QOSEVENT
{
    DWORD dwEvent;
    DWORD dwMediaMode;

} MSG_QOS_EVENT, *PMSG_QOS_EVENT;

typedef struct _TSPMSPDATA 
{
    TSP_MSP_COMMAND command;

    union 
    {
        MSG_CALL_START          CallStart;
        MSG_CALL_DISCONNECTED   CallDisconnected;
        MSG_QOS_EVENT           QosEvent;
    };

} MSG_TSPMSPDATA, *PMSG_TSPMSPDATA;
      

#endif //__CONFPDU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\work.cpp ===
/*******************************************************************************

Module Name:

    work.cpp

Abstract:

    Implements main function of the bridge test application

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#include "stdafx.h"

// command line
LPSTR glpCmdLine = NULL;

// dialog
HWND ghDlg = NULL;

// true: exit button on dialog was clicked
bool gfExitButton = false;

// bridge
CBridgeApp *gpBridgeApp = NULL;

// callback func in dialog
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

// func to deal with TAPI events
HRESULT
OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent
    );

HRESULT
OnPrivateEvent (IDispatch *pEvent);

// set status message on dialog
void SetStatusMessage (LPWSTR pszMessage);
void DoMessage (LPWSTR pszMessage);
void EnableDisconnectButton (BOOL fYes);

/*//////////////////////////////////////////////////////////////////////////////
    WinMain
////*/
int
WINAPI
WinMain (
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    // init com
    if (FAILED (CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        return 0;

    // init debug
    BGLOGREGISTER (L"work");

    // keep command line which determines which SDP to join
    glpCmdLine = lpCmdLine;

    // init CBridgeApp
    HRESULT hr;
    gpBridgeApp = new CBridgeApp (&hr);
    if (gpBridgeApp==NULL || FAILED (hr))
    {
        LOG ((BG_ERROR, "Failed to init CBridgeApp"));
        return 0;
    }
    
    // start dialog box
    if (!DialogBox (hInst, MAKEINTRESOURCE(IDD_MAINDLG), NULL, MainDialogProc))
    {
        LOG ((BG_TRACE, "Dialog ends"));
    }

    // dialog finished
    delete gpBridgeApp;

    BGLOGDEREGISTER ();
    CoUninitialize ();

    return 1;
}

/*//////////////////////////////////////////////////////////////////////////////
    Callback for dialog
////*/
BOOL
CALLBACK
MainDialogProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            ghDlg = hDlg;
            EnableDisconnectButton (false);
            return 0;
        }
    case WM_PRIVATETAPIEVENT:
        {
            OnTapiEvent ((TAPI_EVENT)wParam, (IDispatch *)lParam);
            return 0;
        }
    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_EXIT:
                {
                    gfExitButton = true;
                    gpBridgeApp->DisconnectAllCalls (DC_NORMAL);

                    // check if in connection
                    if (!IsWindowEnabled (GetDlgItem (ghDlg, IDC_DISCONNECT)))
                    {
                        // not in connection
                        EndDialog (ghDlg, 0);
                    }
                    // else
                        // remember exit button is clicked
                        // do not call EndDialog because a disconnected event is to come

                    return 1;
                }
            case IDC_DISCONNECT:
                {
                    gpBridgeApp->DisconnectAllCalls (DC_NORMAL);

                    // disable disconnect button
                    EnableDisconnectButton (false);
                    return 1;
                }
            }
            case IDC_NEXTSUBSTREAM:
                {
                    gpBridgeApp->NextSubStream ();
                    return 1;
                }

            return 0;
        }
    default:
        return 0;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    Deals with TAPI events
////*/
HRESULT OnTapiEvent (
    TAPI_EVENT TapiEvent,
    IDispatch *pEvent
    )
{
    HRESULT hr = S_OK;

//    LOGEvent ((BG_TE, TapiEvent));

    switch (TapiEvent)
    {
    case TE_CALLNOTIFICATION:
        {
            if (BST_CHECKED != IsDlgButtonChecked (ghDlg, IDC_REJECT))
            {
                // if h323 call and to us, init h323 call
                if (FAILED (hr = gpBridgeApp->CreateH323Call (pEvent)));
                    LOG ((BG_ERROR, "Failed to create h323 call, %x", hr));
            }
            break;
        }
    case TE_CALLSTATE:
        {
            CALL_STATE cs;
            ITCallStateEvent *pCallStateEvent = NULL;

            // get call state event
            hr = pEvent->QueryInterface (
                IID_ITCallStateEvent,
                (void **)&pCallStateEvent
                );
            if (FAILED(hr)) break;

            // get call state
            hr = pCallStateEvent->get_State (&cs);
            pCallStateEvent->Release ();
            if (FAILED(hr)) break;

//            LOGEvent ((BG_CS, cs));

            // if offering, connect
            if (CS_OFFERING == cs)
            {
                CBridgeItem *pItem = NULL;

                // check if h323 call created successful
                hr = gpBridgeApp->HasH323Call (pEvent, &pItem);
                if (S_OK != hr || NULL == pItem)
                {
                    LOG ((BG_ERROR, "Failed to check h323 call, %x", hr));
                    hr = S_OK;
                    break;
                }

                // create sdp call
                if (FAILED (hr = gpBridgeApp->CreateSDPCall (pItem)))
                {
                    gpBridgeApp->DisconnectCall (pItem, DC_REJECTED);

                    // delete pItem;
                    LOG ((BG_ERROR, "Failed to create SDP call, %x", hr));
                    break;
                }

                // bridge call
                if (FAILED (hr = gpBridgeApp->BridgeCalls (pItem)))
                {
                    gpBridgeApp->DisconnectCall (pItem, DC_REJECTED);

                    // delete pItem;
                    LOG ((BG_ERROR, "Failed to bridge calls, %x", hr));
                    break;
                }

                // enable disconnect button
                EnableDisconnectButton (true);
            }
            // if disconnect
            else if (CS_DISCONNECTED == cs)
            {
                CBridgeItem *pItem = NULL;

                // check if h323 call created successful
                hr = gpBridgeApp->HasH323Call (pEvent, &pItem);
                if (S_OK == hr && NULL != pItem)
                {
                    // the call already disconnected
                    // call disconnect here only to remove pItem from the list
                    gpBridgeApp->RemoveCall (pItem);
                    delete pItem;
                }

                // if exit button is clicked and all call disconnected
                if (gfExitButton)
                {
                    if (S_OK != gpBridgeApp->HasCalls ())
                        EndDialog (ghDlg, 0);
                }
                else
                {
                    if (S_OK != gpBridgeApp->HasCalls ())
                        EnableDisconnectButton (false);
                }                
            }
            break;
        }
    case TE_CALLMEDIA:
        {
            CALL_MEDIA_EVENT cme;
            ITCallMediaEvent *pCallMediaEvent;

            // get call media event
            hr = pEvent->QueryInterface (
                IID_ITCallMediaEvent,
                (void **)&pCallMediaEvent
                );
            if (FAILED(hr)) break;

            // get the event
            hr = pCallMediaEvent->get_Event (&cme);
            if (FAILED(hr)) break;

//            LOGEvent ((BG_CME, cme));

            // check media event
            switch (cme)
            {
                case CME_STREAM_FAIL:
                    hr = E_FAIL;
                    LOG ((BG_ERROR, "Stream failed"));
                    break; 
                case CME_TERMINAL_FAIL:
                    hr = E_FAIL;
                    LOG ((BG_ERROR, "Terminal failed"));
                    break;
                default:
                    break;
            }

            // we no longer need this interface.
            pCallMediaEvent->Release();
            break;
        }
    case TE_PRIVATE:
        hr = OnPrivateEvent (pEvent);
        break;
    default:
        break;
    }

    pEvent->Release(); // we addrefed it CTAPIEventNotification::Event()
    
    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT OnPrivateEvent (
    IDispatch *pEvent
    )
{
    ENTER_FUNCTION ("OnPrivateEvent");
//    LOG ((BG_TRACE, "%s entered", __fxName));

    HRESULT hr = S_OK;

    ITPrivateEvent *pPrivateEvent = NULL;
    IDispatch *pDispatch = NULL;
    ITParticipantEvent *pPartEvent = NULL;
    ITParticipant *pParticipant = NULL;
    PARTICIPANT_EVENT event;

    ITCallInfo *pCallInfo = NULL;
    ITBasicCallControl *pCallControl = NULL;

    // get private event interface
    if (FAILED (hr = pEvent->QueryInterface (&pPrivateEvent)))
    {
        LOG ((BG_ERROR, "%s failed to query ITPrivateEvent", __fxName));
        return hr;
    }

    // get event interface
    if (FAILED (hr = pPrivateEvent->get_EventInterface (&pDispatch)))
    {
        LOG ((BG_ERROR, "%s failed to query event interface", __fxName));
        goto Error;
    }

    // get participant event interface
    hr = pDispatch->QueryInterface (&pPartEvent);
    pDispatch->Release ();
    pDispatch = NULL;

    if (FAILED (hr))
    {
        LOG ((BG_ERROR, "%s failed to query participant interface", __fxName));
        goto Error;
    }

    // get event
    if (FAILED (hr = pPartEvent->get_Event (&event)))
    {
        LOG ((BG_ERROR, "%s failed to get event", __fxName));
        goto Error;
    }

//    LOGEvent ((BG_PE, event));

    // check the event
    switch (event)
    {
        case PE_PARTICIPANT_ACTIVE:
            {
                // get call info
                if (FAILED (hr = pPrivateEvent->get_Call (&pCallInfo)))
                {
                    LOG ((BG_ERROR, "%s failed to get call info", __fxName));
                    goto Error;
                }

                // get call control
                if (FAILED (hr = pCallInfo->QueryInterface (&pCallControl)))
                {
                    LOG ((BG_ERROR, "%s failed to get call control", __fxName));
                    goto Error;
                }

                // get participant interface
                if (FAILED (hr = pPartEvent->get_Participant (&pParticipant)))
                {
                    LOG ((BG_ERROR, "%s failed to get participant", __fxName));
                    goto Error;
                }

                // show participant
                hr = gpBridgeApp->ShowParticipant (pCallControl, pParticipant);
                if (FAILED (hr))
                {
                    LOG ((BG_ERROR, "%s failed to show participant, %x", __fxName, hr));
                }

                if (S_FALSE == hr)
                {
                    hr = S_OK;
                    // *ppszMessage = L"Participant active but call not found in list";
                    // or no substream found on the stream
                }
            }
            break;
        default:
            break;

    }
Cleanup:
    if (pCallInfo) pCallInfo->Release ();
    if (pCallControl) pCallControl->Release ();
    if (pPrivateEvent) pPrivateEvent->Release ();
    if (pPartEvent) pPartEvent->Release ();
    if (pParticipant) pParticipant->Release ();

//    LOG ((BG_TRACE, "%s exits", __fxName));
    return hr;

Error:
    goto Cleanup;
}

/*//////////////////////////////////////////////////////////////////////////////
    Popup message box
////*/
WCHAR gMsgBoxTitle[] = L"TAPI 3.0 Bridge Test Application";

void
DoMessage (LPWSTR pszMessage)
{
#if POPUP_MESSAGE
    MessageBox (
        ghDlg,
        pszMessage,
        gMsgBoxTitle,
        MB_OK
        );
#endif
}

/*//////////////////////////////////////////////////////////////////////////////
    Status message
////*/
void
SetStatusMessage (LPWSTR pszMessage)
{
    SetDlgItemText (ghDlg, IDC_STATUS, pszMessage);
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
void
EnableDisconnectButton (BOOL fYes)
{
    if (fYes)
    {
        // enable
        SetStatusMessage (L"Bridging calls ...");

        SendDlgItemMessage (
            ghDlg,
            IDC_NEXTSUBSTREAM,
            BM_SETSTYLE,
            BS_DEFPUSHBUTTON,
            0
            );
        SendDlgItemMessage (
            ghDlg,
            IDC_DISCONNECT,
            BM_SETSTYLE,
            BS_DEFPUSHBUTTON,
            0
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_NEXTSUBSTREAM),
            TRUE
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_DISCONNECT),
            TRUE
            );
        SetFocus (GetDlgItem (ghDlg, IDC_DISCONNECT));
    }
    else
    {
        // disable
        SetStatusMessage (L"Waiting for calls ...");

        SendDlgItemMessage (
            ghDlg,
            IDC_NEXTSUBSTREAM,
            BM_SETSTYLE,
            BS_PUSHBUTTON,
            0
            );
        SendDlgItemMessage (
            ghDlg,
            IDC_DISCONNECT,
            BM_SETSTYLE,
            BS_PUSHBUTTON,
            0
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_NEXTSUBSTREAM),
            FALSE
            );
        EnableWindow (
            GetDlgItem (ghDlg, IDC_DISCONNECT),
            FALSE
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\bridge\test2\bgitem.h ===
/*******************************************************************************

Module Name:

    bgitem.h

Abstract:

    Defines CBridgeItem and CBridgeItemList for storing info for bridge objects

Author:

    Qianbo Huai (qhuai) Jan 27 2000

*******************************************************************************/

#ifndef _BGITEM_H
#define _BGITEM_H

class CBridgeItem
{
public:
    CBridgeItem ();
    ~CBridgeItem ();

    // forward link
    CBridgeItem *next;
    // backward link
    CBridgeItem *prev;

    // caller identity
    BSTR bstrID;
    BSTR bstrName;

    // call controls
    ITBasicCallControl *pCallH323;
    ITBasicCallControl *pCallSDP;

    // terminals
    ITTerminal *pTermHSAud;
    ITTerminal *pTermHSVid;
    ITTerminal *pTermSHAud;
    ITTerminal *pTermSHVid;

    // h323 side streams
    ITStream *pStreamHAudCap;
    ITStream *pStreamHAudRen;
    ITStream *pStreamHVidCap;
    ITStream *pStreamHVidRen;

    // sdp side streams
    ITStream *pStreamSAudCap;
    ITStream *pStreamSAudRen;
    ITStream *pStreamSVidCap;
    ITStream *pStreamSVidRen;
};

class CBridgeItemList
{
public:
    CBridgeItemList ();
    ~CBridgeItemList ();

    CBridgeItem *FindByH323 (IUnknown *pIUnknown);
    CBridgeItem *FindBySDP (IUnknown *pIUnknown);
    void TakeOut (CBridgeItem *pItem);
    CBridgeItem *DeleteFirst ();
    void Append (CBridgeItem *pItem);
    BOOL GetAllItems (CBridgeItem ***pItemArray, int *pNum);
    BOOL IsEmpty ();

private:
    CBridgeItem *Find (int flag, IUnknown *pIUnknown);
    CBridgeItem *m_pHead;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confaddr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confaddr.cpp 

Abstract:

    This module contains implementation of CIPConfMSP.

Author:
    
    Mu Han (muhan)   5-September-1997

--*/
#include "stdafx.h"

#include <initguid.h>
DEFINE_GUID(CLSID_IPConfMSP, 0x0F1BE7F7, 0x45CA, 0x11d2,
            0x83, 0x1F, 0x0, 0xA0, 0x24, 0x4D, 0x22, 0x98);

#ifdef USEIPADDRTABLE

#include <iprtrmib.h>

typedef DWORD (WINAPI * PFNGETIPADDRTABLE)(
                OUT    PMIB_IPADDRTABLE pIPAddrTable,
                IN OUT PDWORD           pdwSize,
                IN     BOOL             bOrder
                );

#define IPHLPAPI_DLL        L"IPHLPAPI.DLL"

#define GETIPADDRTABLE      "GetIpAddrTable"    

#define IsValidInterface(_dwAddr_) \
    (((_dwAddr_) != 0) && \
     ((_dwAddr_) != htonl(INADDR_LOOPBACK)))

#endif

#define IPCONF_WINSOCKVERSION     MAKEWORD(2,0)

HRESULT CIPConfMSP::FinalConstruct()
{
    // initialize winsock stack
    WSADATA wsaData;
    if (WSAStartup(IPCONF_WINSOCKVERSION, &wsaData) != 0)
    {
        LOG((MSP_ERROR, "WSAStartup failed with:%x", WSAGetLastError()));
        return E_FAIL;
    }

    // allocate control socket
    m_hSocket = WSASocket(
        AF_INET,            // af
        SOCK_DGRAM,         // type
        IPPROTO_IP,         // protocol
        NULL,               // lpProtocolInfo
        0,                  // g
        0                   // dwFlags
        );

    // validate handle
    if (m_hSocket == INVALID_SOCKET) {

        LOG((
            MSP_ERROR,
            "error %d creating control socket.\n",
            WSAGetLastError()
            ));

        // failure
		WSACleanup();
     
        return E_FAIL;
    }

    HRESULT hr = CMSPAddress::FinalConstruct();

	if (hr != S_OK)
	{
		// close socket
		closesocket(m_hSocket);

		// shutdown
		WSACleanup();
	}
	
	return hr;
}

void CIPConfMSP::FinalRelease()
{
    CMSPAddress::FinalRelease();

    if (m_hDxmrtp)
    {
        FreeLibrary(m_hDxmrtp);
        m_hDxmrtp = NULL;
    }

    if (m_hSocket != INVALID_SOCKET)
    {
        // close socket
        closesocket(m_hSocket);
    }

    // shutdown
    WSACleanup();
}

DWORD CIPConfMSP::FindLocalInterface(DWORD dwIP)
{

    SOCKADDR_IN DestAddr;
    DestAddr.sin_family         = AF_INET;
    DestAddr.sin_port           = 0;
    DestAddr.sin_addr.s_addr    = htonl(dwIP);

    SOCKADDR_IN LocAddr;

    // query for default address based on destination

    DWORD dwStatus;
    DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
    DWORD dwNumBytesReturned = 0;

    if ((dwStatus = WSAIoctl(
		    m_hSocket, // SOCKET s
		    SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
		    &DestAddr,           // LPVOID lpvInBuffer
		    sizeof(SOCKADDR_IN), // DWORD cbInBuffer
		    &LocAddr,            // LPVOID lpvOUTBuffer
		    dwLocAddrSize,       // DWORD cbOUTBuffer
		    &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
		    NULL, // LPWSAOVERLAPPED lpOverlapped
		    NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
	    )) == SOCKET_ERROR) 
    {

	    dwStatus = WSAGetLastError();

	    LOG((MSP_ERROR, "WSAIoctl failed: %d (0x%X)", dwStatus, dwStatus));

        return INADDR_NONE;
    } 

    DWORD dwAddr = ntohl(LocAddr.sin_addr.s_addr);

    if (dwAddr == 0x7f000001)
    {
        // it is loopback address, just return none.
        return INADDR_NONE;
    }

    return dwAddr;
}

HRESULT LoadTapiAudioFilterDLL(
    IN  const TCHAR * const strDllName,
    IN OUT HMODULE * phModule,
    IN  const char * const strAudioGetDeviceInfo,
    IN  const char * const strAudioReleaseDeviceInfo,
    OUT PFNAudioGetDeviceInfo * ppfnAudioGetDeviceInfo,
    OUT PFNAudioReleaseDeviceInfo * ppfnAudioReleaseDeviceInfo
    )
/*++

Routine Description:

    This method enumerate loads the tapi video capture dll.

Arguments:

    str DllName - The name of the dll.

    phModule - memory to store returned module handle.

    ppfnAudioGetDeviceInfo - memory to store the address of AudioGetDeviceInfo
        function.

    ppfnAudioReleaseDeviceInfo - memory to store the address of 
        AudioReleaseDeviceInfo function.
    
Return Value:

    S_OK    - success.
    E_FAIL  - failure.

--*/
{
    ENTER_FUNCTION("CIPConfMSP::LoadTapiAudioFilterDLL");

    // dynamically load the video capture filter dll.
    if (*phModule == NULL)
    {
        *phModule = LoadLibrary(strDllName);
    }

    // validate handle
    if (*phModule == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not load %s., error:%d", 
            __fxName, strDllName, GetLastError()));

        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo 
        = (PFNAudioGetDeviceInfo)GetProcAddress(
                *phModule, strAudioGetDeviceInfo
                );

    // validate function pointer
    if (pfnAudioGetDeviceInfo == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strAudioGetDeviceInfo, GetLastError()));

        // failure
        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo 
        = (PFNAudioReleaseDeviceInfo)GetProcAddress(
                *phModule, strAudioReleaseDeviceInfo
                );

    // validate function pointer
    if (pfnAudioReleaseDeviceInfo == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strAudioReleaseDeviceInfo, GetLastError()));

        // failure
        return E_FAIL;
    }

    *ppfnAudioGetDeviceInfo = pfnAudioGetDeviceInfo;
    *ppfnAudioReleaseDeviceInfo = pfnAudioReleaseDeviceInfo;
    
    return S_OK;
}

HRESULT CIPConfMSP::CreateAudioCaptureTerminals()
/*++

Routine Description:

    This method creates audio capture terminals. It uses DShow devenum to 
    enumerate all the wavein capture devices first. Then it will enumerate
    all the DSound capture devices and match them up by name.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    const TCHAR * const strAudioCaptureDll = TEXT("DXMRTP");

    ENTER_FUNCTION("CIPConfMSP::CreateAudioCaptureTerminals");

    // dynamically load the audio capture filter dll.
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo;
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo;

    HRESULT hr = LoadTapiAudioFilterDLL(
        strAudioCaptureDll,
        &m_hDxmrtp,
        "AudioGetCaptureDeviceInfo",
        "AudioReleaseCaptureDeviceInfo", 
        &pfnAudioGetDeviceInfo,
        &pfnAudioReleaseDeviceInfo
        );

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwNumDevices;
    AudioDeviceInfo *pDeviceInfo;

    hr = (*pfnAudioGetDeviceInfo)(&dwNumDevices, &pDeviceInfo);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, AudioGetDeviceInfo failed. hr=%x", __fxName, hr));

        return hr;
    }

    // for each devie, create a terminal.
    for (DWORD i = 0; i < dwNumDevices; i ++)
    {
        ITTerminal *pTerminal;

        hr = CIPConfAudioCaptureTerminal::CreateTerminal(
            &pDeviceInfo[i],
            (MSP_HANDLE) this,
            &pTerminal
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, CreateTerminal for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        if (!m_Terminals.Add(pTerminal))
        {
            hr = E_OUTOFMEMORY;
            LOG((MSP_ERROR, "%s, out of mem in adding a terminal", __fxName));
            break;
        }
    }

    // release the device info
    (*pfnAudioReleaseDeviceInfo)(pDeviceInfo);

    return hr;
}


HRESULT CIPConfMSP::CreateAudioRenderTerminals()
/*++

Routine Description:

    This method enumerate all the audio render devices and creates a 
    terminal for each of them.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION("CIPConfMSP::CreateAudioRenderTerminals");
    const TCHAR * const strAudioRenderDll = TEXT("DXMRTP");

    // dynamically load the audio render filter dll.
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo;
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo;

    HRESULT hr = LoadTapiAudioFilterDLL(
        strAudioRenderDll,
        &m_hDxmrtp,
        "AudioGetRenderDeviceInfo",
        "AudioReleaseRenderDeviceInfo",
        &pfnAudioGetDeviceInfo,
        &pfnAudioReleaseDeviceInfo
        );

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwNumDevices;
    AudioDeviceInfo *pDeviceInfo;

    hr = (*pfnAudioGetDeviceInfo)(&dwNumDevices, &pDeviceInfo);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, AudioGetDeviceInfo failed. hr=%x", __fxName, hr));

        return hr;
    }

    // for each devie, create a terminal.
    for (DWORD i = 0; i < dwNumDevices; i ++)
    {
        ITTerminal *pTerminal;

        hr = CIPConfAudioRenderTerminal::CreateTerminal(
            &pDeviceInfo[i],
            (MSP_HANDLE) this,
            &pTerminal
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, CreateTerminal for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        if (!m_Terminals.Add(pTerminal))
        {
            hr = E_OUTOFMEMORY;
            LOG((MSP_ERROR, "%s, out of mem in adding a terminal", __fxName));
            break;
        }
    }

    // release the device info
    (*pfnAudioReleaseDeviceInfo)(pDeviceInfo);

    return hr;
}

HRESULT LoadTapiVideoCaptureDLL(
    IN OUT HMODULE * phModule,
    OUT PFNGetNumCapDevices * ppfnGetNumCapDevices,
    OUT PFNGetCapDeviceInfo * ppfnGetCapDeviceInfo
    )
/*++

Routine Description:

    This method enumerate loads the tapi video capture dll.

Arguments:

    phModule - memory to store returned module handle.

    ppfnGetNumCapDevices - memory to store the address of GetNumCapDevices
        function.

    ppfnGetCapDeviceInfo - memory to store the address of GetCapDeviceInfo 
        function.
    
Return Value:

    S_OK    - success.
    E_FAIL  - failure.

--*/
{
    const TCHAR * const strVideoCaptureDll = TEXT("DXMRTP");
    const char * const strGetNumCapDevices = "GetNumVideoCapDevices";
    const char * const strGetCapDeviceInfo = "GetVideoCapDeviceInfo";

    ENTER_FUNCTION("CIPConfMSP::LoadTapiVideoCaptureDLL");

    // dynamically load the video capture filter dll.
    if (*phModule == NULL)
    {
        *phModule = LoadLibrary(strVideoCaptureDll);
    }

    // validate handle
    if (*phModule == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not load %s., error:%d", 
            __fxName, strVideoCaptureDll, GetLastError()));

        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNGetNumCapDevices pfnGetNumCapDevices 
        = (PFNGetNumCapDevices)GetProcAddress(*phModule, strGetNumCapDevices);

    // validate function pointer
    if (pfnGetNumCapDevices == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strGetNumCapDevices, GetLastError()));

        // failure
        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNGetCapDeviceInfo pfnGetCapDeviceInfo 
        = (PFNGetCapDeviceInfo)GetProcAddress(*phModule, strGetCapDeviceInfo);

    // validate function pointer
    if (pfnGetCapDeviceInfo == NULL) 
    {
        LOG((MSP_ERROR, "%s, could not resolve %s, error:%d", 
            __fxName, strGetCapDeviceInfo, GetLastError()));

        // failure
        return E_FAIL;
    }

    *ppfnGetNumCapDevices = pfnGetNumCapDevices;
    *ppfnGetCapDeviceInfo = pfnGetCapDeviceInfo;
    
    return S_OK;
}

HRESULT CIPConfMSP::CreateVideoCaptureTerminals()
/*++

Routine Description:

    This method is called by UpdateTerminalList to create all the video
    capture terminals. It loads the video capture dll and calls its device
    enumeration code to enumerate the devices.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION("CIPConfMSP::CreateVideoCaptureTerminals");

    // dynamically load the video capture filter dll.
    PFNGetNumCapDevices pfnGetNumCapDevices;
    PFNGetCapDeviceInfo pfnGetCapDeviceInfo;

    HRESULT hr = LoadTapiVideoCaptureDLL(
        &m_hDxmrtp,
        &pfnGetNumCapDevices,
        &pfnGetCapDeviceInfo
        );

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwNumDevices = 0;
    hr = (*pfnGetNumCapDevices)(&dwNumDevices);

    // we have to check against S_OK because the function returns S_FALSE when
    // there is no device.
    if (hr != S_OK)  
    {
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, GetNumCapDevices failed. hr=%x", __fxName, hr));
        }
        else 
        {
            LOG((MSP_WARN, "%s, There is no video device. hr=%x", __fxName, hr));
        }

        return hr;
    }

    for (DWORD i = 0; i < dwNumDevices; i ++)
    {
        VIDEOCAPTUREDEVICEINFO DeviceInfo;
        hr = (*pfnGetCapDeviceInfo)(i, &DeviceInfo);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, GetNumCapDevices for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        ITTerminal * pTerminal;

        hr = CIPConfVideoCaptureTerminal::CreateTerminal(
            DeviceInfo.szDeviceDescription,
            i, 
            (MSP_HANDLE) this,
            &pTerminal
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, CreateTerminal for device %d failed. hr=%x",
                __fxName, i, hr));
            break;
        }

        if (!m_Terminals.Add(pTerminal))
        {
            hr = E_OUTOFMEMORY;
            LOG((MSP_ERROR, "%s, out of mem in adding a terminal", __fxName));
            break;
        }
    }

    return hr;
}

HRESULT CIPConfMSP::UpdateTerminalList(void)
/*++

Routine Description:

    This method is called by the base class when it first tries to enumerate
    all the static terminals. We override this function to create our own
    terminals that use our own filters.

Arguments:

    nothing
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION("CIPConfMSP::UpdateTerminalList");

    // the failure of one category of terminals doesn't prevent the enumeration
    // of other categories. So we ignore the return code here. If all 
    // categories fail, the app will get an empty list.

    CreateAudioCaptureTerminals();
    CreateAudioRenderTerminals();
    CreateVideoCaptureTerminals();

    //
    // Our list is now complete.
    //
    m_fTerminalsUpToDate = TRUE;
    
    LOG((MSP_TRACE, "%s, exit S_OK", __fxName));

    return S_OK;
}

HRESULT CIPConfMSP::UpdateTerminalListForPnp(IN BOOL bDeviceArrival)
/*++

Routine Description:

    This method is called by the base class when it receives pnp event
    and needs to recreate static terminal list. We override this function
    to create our own terminals that use our own filters. terminal list
    locks was acquired when calling this method.
    
Return Value:

S_OK

--*/
{
    ENTER_FUNCTION ("CIPConfMSP::UpdateTerminalListForPnp");

    LOG ((MSP_TRACE, "%s (%d) entered", __fxName, bDeviceArrival));

    HRESULT hr;
    
    // variables for keeping old terminal info
    INT i, iout, iin, count;
    TERMINAL_DIRECTION *ptd = NULL, td;
    LONG *pmedia = NULL, media;
    BSTR *pbstr = NULL, bstr=NULL;
    ITTerminal **ppterminal = NULL;

    BOOL bmatch;
    MSPEVENTITEM *pevent = NULL;

    count = m_Terminals.GetSize ();
    
    if (count > 0)
    {
        ptd = new TERMINAL_DIRECTION[count];
        pmedia = new LONG[count];
        pbstr = new BSTR[count];
        ppterminal = new ITTerminal* [count];

        if (ptd == NULL || pmedia == NULL || pbstr == NULL || ppterminal == NULL)
        {
            LOG ((MSP_ERROR, "%s out of memory", __fxName));
            hr = E_OUTOFMEMORY;

            if (ptd) delete [] ptd;
            if (pmedia) delete [] pmedia;
            if (pbstr) delete [] pbstr;
            if (ppterminal) delete [] ppterminal;

            return hr;
        }

        memset (pbstr, 0, count * sizeof(BSTR));
        memset (ppterminal, 0, count * sizeof(ITTerminal*));
        
    }

    // for each old terminal, record
    for (i = 0; i < count; i++)
    {
        if (FAILED (hr = m_Terminals[i]->get_Direction (&ptd[i])))
        {
            LOG ((MSP_ERROR, "%s failed to get terminal direction. %x", __fxName, hr));
            goto Cleanup;
        }

        if (FAILED (hr = m_Terminals[i]->get_MediaType (&pmedia[i])))
        {
            LOG ((MSP_ERROR, "%s failed to get terminal mediatype. %x", __fxName, hr));
            goto Cleanup;
        }

        if (FAILED (hr = m_Terminals[i]->get_Name (&pbstr[i])))
        {
            LOG ((MSP_ERROR, "%s failed to get terminal name. %x", __fxName, hr));
            goto Cleanup;
        }

        m_Terminals[i]->AddRef ();
        ppterminal[i] = m_Terminals[i];
    }

    // if we release terminal inside previous loop: recording info
    // we would only release some terminals if there is an error
    for (i = 0; i < count; i++)
    {
        m_Terminals[i]->Release ();
    }
    m_Terminals.RemoveAll ();

    // update terminal list
    /*
    if (FAILED (hr = UpdateTerminalList ()))
    {
        LOG ((MSP_ERROR, "%s failed to update terminal list. %x", __fxName, hr));
        goto Cleanup;
    }
    */

    // copy UpdateTerminalList () here
    CreateAudioCaptureTerminals();
    CreateAudioRenderTerminals();
    CreateVideoCaptureTerminals();

    m_fTerminalsUpToDate = TRUE;

    // fire event to tapi app
    if (bDeviceArrival)
    {
        // outer loop each new terminal
        for (iout = 0; iout < m_Terminals.GetSize (); iout++)
        {
            if (FAILED (hr = m_Terminals[iout]->get_Direction (&td)))
            {
                LOG ((MSP_ERROR, "%s failed to get terminal direction. %x", __fxName, hr));
                goto Cleanup;
            }

            if (FAILED (hr = m_Terminals[iout]->get_MediaType (&media)))
            {
                LOG ((MSP_ERROR, "%s failed to get terminal type. %x", __fxName, hr));
                goto Cleanup;
            }

            if (FAILED (hr = m_Terminals[iout]->get_Name (&bstr)))
            {
                LOG ((MSP_ERROR, "%s failed to get terminal name. %x", __fxName, hr));
                goto Cleanup;
            }

            // inner loop check if the terminal is new
            for (iin = 0, bmatch = FALSE; iin < count; iin ++)
            {
                if (td == ptd[iin] && 
                    media == pmedia[iin] &&
                    0 == wcscmp (bstr, pbstr[iin]))
                {
                    bmatch = TRUE;
                    break;
                }
            }
            
            // fire event if not match
            if (!bmatch)
            {
                LOG ((MSP_TRACE, "%s: new device found. name %ws, td %d, media %d",
                      __fxName, bstr, td, media));

                pevent = AllocateEventItem();
                if (pevent == NULL)
                {
                    LOG ((MSP_ERROR, "%s failed to new msp event item", __fxName));
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                m_Terminals[iout]->AddRef ();
                
                pevent->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
                pevent->MSPEventInfo.Event = ME_ADDRESS_EVENT;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.Type = ADDRESS_TERMINAL_AVAILABLE;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal = m_Terminals[iout];

                if (FAILED (hr = PostEvent (pevent)))
                {
                    LOG ((MSP_ERROR, "%s failed to post event. %x", __fxName, hr));
                    
                    m_Terminals[iout]->Release ();
                    FreeEventItem(pevent);
                    pevent = NULL;

                    // we don't return, try next device
                }                
            } // outer loop
            
            SysFreeString (bstr);
            bstr = NULL;
        }
    }
    else // if (bDeviceArrival)
    {
        // outer loop each old device
        for (iout = 0; iout < count; iout++)
        {
            // inner loop check if the device was removed
            for (iin = 0, bmatch = FALSE; iin < m_Terminals.GetSize (); iin++)
            {
                if (FAILED (hr = m_Terminals[iin]->get_Direction (&td)))
                {
                    LOG ((MSP_ERROR, "%s failed to get terminal direction. %x", __fxName, hr));
                    goto Cleanup;
                }
                
                if (FAILED (hr = m_Terminals[iin]->get_MediaType (&media)))
                {
                    LOG ((MSP_ERROR, "%s failed to get terminal type. %x", __fxName, hr));
                    goto Cleanup;
                }

                if (FAILED (hr = m_Terminals[iin]->get_Name (&bstr)))
                {
                    LOG ((MSP_ERROR, "%s failed to get terminal name. %x", __fxName, hr));
                    goto Cleanup;
                }
                    
                if (td == ptd[iout] && 
                    media == pmedia[iout] &&
                    0 == wcscmp (bstr, pbstr[iout]))
                {
                    SysFreeString (bstr);
                    bstr = NULL;
                        
                    bmatch = TRUE;
                    break;
                }
                    
                SysFreeString (bstr);
                bstr = NULL;
            }                
            
            // fire event if not match
            if (!bmatch)
            {
                LOG ((MSP_TRACE, "%s: device removed. name %ws, td %d, media %d",
                  __fxName, pbstr[iout], ptd[iout], pmedia[iout]));

                pevent = AllocateEventItem();
                if (pevent == NULL)
                {
                    LOG ((MSP_ERROR, "%s failed to new msp event item", __fxName));
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                ppterminal[iout]->AddRef ();
                
                pevent->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
                pevent->MSPEventInfo.Event = ME_ADDRESS_EVENT;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.Type = ADDRESS_TERMINAL_UNAVAILABLE;
                pevent->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal = ppterminal[iout];

                if (FAILED (hr = PostEvent (pevent)))
                {
                    LOG ((MSP_ERROR, "%s failed to post event. %x", __fxName, hr));
                    
                    ppterminal[iout]->Release ();
                    FreeEventItem(pevent);
                    pevent = NULL;

                    // we don't return, try next device
                }
            }
        } // outer loop
    }

Cleanup:
    if (bstr) SysFreeString (bstr);

    if (count > 0)
    {
        delete [] ptd;
        delete [] pmedia;
        
        for (i = 0; i < count; i++)
        {
            if (pbstr[i]) SysFreeString (pbstr[i]);
            if (ppterminal[i]) ppterminal[i]->Release ();
        }

        delete [] pbstr;
        delete [] ppterminal;
     }

    LOG ((MSP_TRACE, "%s returns", __fxName));

    return hr;
}

STDMETHODIMP CIPConfMSP::CreateTerminal(
    IN      BSTR                pTerminalClass,
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    OUT     ITTerminal **       ppTerminal
    )
/*++

Routine Description:

This method is called by TAPI3 to create a dynamic terminal. It asks the 
terminal manager to create a dynamic terminal. 

Arguments:

iidTerminalClass
    IID of the terminal class to be created.

dwMediaType
    TAPI media type of the terminal to be created.

Direction
    Terminal direction of the terminal to be created.

ppTerminal
    Returned created terminal object
    
Return Value:

S_OK

E_OUTOFMEMORY
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION
TAPI_E_INVALIDTERMINALCLASS

--*/
{
    ENTER_FUNCTION("CIPConfMSP::CreateTerminal");
    LOG((MSP_TRACE, "%s - enter", __fxName));

    //
    // Check if initialized.
    //

    // lock the event related data
    m_EventDataLock.Lock();

    if ( m_htEvent == NULL )
    {
        // unlock the event related data
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR,
            "%s, not initialized - returning E_UNEXPECTED", __fxName));
        return E_UNEXPECTED;
    }

    // unlock the event related data
    m_EventDataLock.Unlock();

    //
    // Get the IID from the BSTR representation.
    //

    HRESULT hr;
    IID     iidTerminalClass;

    hr = CLSIDFromString(pTerminalClass, &iidTerminalClass);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "%s, bad CLSID string", __fxName));
        return E_INVALIDARG;
    }

    //
    // Make sure we support the requested media type.
    // The terminal manager checks the terminal class, terminal direction, 
    // and return pointer.
    //

    //
    // we don't have any specific req's to terminal's media type. 
    // termmgr will check if the media type is valid at all.
    //

    //
    // Use the terminal manager to create the dynamic terminal.
    //

    _ASSERTE( m_pITTerminalManager != NULL );

    hr = m_pITTerminalManager->CreateDynamicTerminal(NULL,
                                                     iidTerminalClass,
                                                     (DWORD) lMediaType,
                                                     Direction,
                                                     (MSP_HANDLE) this,
                                                     ppTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s create dynamic terminal failed. hr=%x", __fxName, hr));

        return hr;
    }

    const DWORD dwAudioCaptureBitPerSample    = 16;  
    const DWORD dwAudioSampleRate             = 8000;  

    if ((iidTerminalClass == CLSID_MediaStreamTerminal)
        && (lMediaType == TAPIMEDIATYPE_AUDIO))
    {
        // Set the format of the audio to 8KHZ, 16Bit/Sample, MONO.
        hr = ::SetAudioFormat(
            *ppTerminal, 
            dwAudioCaptureBitPerSample, 
            dwAudioSampleRate
            );

        if (FAILED(hr))
        {
            LOG((MSP_WARN, "%s, can't set audio format, %x", __fxName, hr));
        }
    }

    LOG((MSP_TRACE, "%s - exit S_OK", __fxName));

    return S_OK;
}

STDMETHODIMP CIPConfMSP::CreateMSPCall(
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType,
    IN      IUnknown *          pOuterUnknown,
    OUT     IUnknown **         ppMSPCall
    )
/*++

Routine Description:

This method is called by TAPI3 before a call is made or answered. It creates 
a aggregated MSPCall object and returns the IUnknown pointer. It calls the
helper template function defined in mspaddress.h to handle the real creation.

Arguments:

htCall
    TAPI 3.0's identifier for this call.  Returned in events passed back 
    to TAPI.

dwReserved
    Reserved parameter.  Not currently used.

dwMediaType
    Media type of the call being created.  These are TAPIMEDIATYPES and more 
    than one mediatype can be selected (bitwise).

pOuterUnknown
    pointer to the IUnknown interface of the containing object.

ppMSPCall
    Returned MSP call that the MSP fills on on success.
    
Return Value:

    S_OK
    E_OUTOFMEMORY
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, 
        "CreateMSPCall entered. htCall:%x, dwMediaType:%x, ppMSPCall:%x",
        htCall, dwMediaType, ppMSPCall
        ));

    CIPConfMSPCall * pMSPCall = NULL;

    HRESULT hr = ::CreateMSPCallHelper(
        this, 
        htCall, 
        dwReserved, 
        dwMediaType, 
        pOuterUnknown, 
        ppMSPCall,
        &pMSPCall
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPCallHelper failed:%x", hr));
        return hr;
    }

    // this function doesn't return anything.
    pMSPCall->SetIPInterface(m_dwIPInterface);

    return hr;
}

STDMETHODIMP CIPConfMSP::ShutdownMSPCall(
    IN      IUnknown *   pUnknown
    )
/*++

Routine Description:

This method is called by TAPI3 to shutdown a MSPCall. It calls the helper
function defined in MSPAddress to to the real job.

Arguments:

pUnknown
    pointer to the IUnknown interface of the contained object. It is a
    CComAggObject that contains our call object.
    
Return Value:

    S_OK
    E_POINTER
    TAPI_E_INVALIDMEDIATYPE


--*/
{
    LOG((MSP_TRACE, "ShutDownMSPCall entered. pUnknown:%x", pUnknown));

    if (IsBadReadPtr(pUnknown, sizeof(VOID *) * 3))
    {
        LOG((MSP_ERROR, "ERROR:pUnknow is a bad pointer"));
        return E_POINTER;
    }

    
    CIPConfMSPCall * pMSPCall = NULL;
    HRESULT hr = ::ShutdownMSPCallHelper(pUnknown, &pMSPCall);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "ShutDownMSPCallhelper failed:: %x", hr));
        return hr;
    }

    return hr;
}

DWORD CIPConfMSP::GetCallMediaTypes(void)
{
    return IPCONFCALLMEDIATYPES;
}

ULONG CIPConfMSP::MSPAddressAddRef(void)
{
    return MSPAddRefHelper(this);
}

ULONG CIPConfMSP::MSPAddressRelease(void)
{
    return MSPReleaseHelper(this);
}

#ifdef USEIPADDRTABLE
PMIB_IPADDRTABLE GetIPTable()
/*++

Routine Description:

This method is used to get the table of local IP interfaces.

Arguments:

Return Value:

    NULL - failed.
    Pointer - a memory buffer that contains the IP interface table.


--*/
{
    // dynamically load iphlpapi.dll
    HMODULE hIPHLPAPI = LoadLibraryW(IPHLPAPI_DLL);

    // validate handle
    if (hIPHLPAPI == NULL) 
    {
        LOG((MSP_ERROR, "could not load %s.\n", IPHLPAPI_DLL));
        // failure
        return NULL;
    }

    PFNGETIPADDRTABLE pfnGetIpAddrTable = NULL;

    // retrieve function pointer to retrieve addresses
    pfnGetIpAddrTable = (PFNGETIPADDRTABLE)GetProcAddress(
                                                hIPHLPAPI, 
                                                GETIPADDRTABLE
                                                );

    // validate function pointer
    if (pfnGetIpAddrTable == NULL) 
    {
        LOG((MSP_ERROR, "could not resolve GetIpAddrTable.\n"));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure
        return NULL;
    }

    PMIB_IPADDRTABLE pIPAddrTable = NULL;
    DWORD dwBytesRequired = 0;
    DWORD dwStatus;

    // determine amount of memory needed for table
    dwStatus = (*pfnGetIpAddrTable)(pIPAddrTable, &dwBytesRequired, FALSE);

    // validate status is what we expect
    if (dwStatus != ERROR_INSUFFICIENT_BUFFER) 
    {
        LOG((MSP_ERROR, "error 0x%08lx calling GetIpAddrTable.\n", dwStatus));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load.
        return NULL;
    }
        
    // attempt to allocate memory for table
    pIPAddrTable = (PMIB_IPADDRTABLE)malloc(dwBytesRequired);

    // validate pointer
    if (pIPAddrTable == NULL) 
    {
        LOG((MSP_ERROR, "could not allocate address table.\n"));
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load.
        return NULL;
    }

    // retrieve ip address table from tcp/ip stack via utitity library
    dwStatus = (*pfnGetIpAddrTable)(pIPAddrTable, &dwBytesRequired, FALSE);    

    // validate status
    if (dwStatus != NOERROR) 
    {
        LOG((MSP_ERROR, "error 0x%08lx calling GetIpAddrTable.\n", dwStatus));
        // release table
        free(pIPAddrTable);
        // release
        FreeLibrary(hIPHLPAPI);
        // failure, but we need to return true to load. 
        return NULL;
    }
        
    // release library
    FreeLibrary(hIPHLPAPI);

    return pIPAddrTable;
}

BSTR IPToBstr(
    DWORD dwIP
    )
{
    struct in_addr Addr;
    Addr.s_addr = dwIP;
    
    // convert the interface to a string.
    CHAR *pChar = inet_ntoa(Addr);
    if (pChar == NULL)
    {
        LOG((MSP_ERROR, "bad IP address:%x", dwIP));
        return NULL;
    }

    // convert the ascii string to WCHAR.
    WCHAR szAddressName[MAXIPADDRLEN + 1];
    wsprintfW(szAddressName, L"%hs", pChar);

    // create a BSTR.
    BSTR bAddress = SysAllocString(szAddressName);
    if (bAddress == NULL)
    {
        LOG((MSP_ERROR, "out of mem in allocation address name"));
        return NULL;
    }

    return bAddress;
}

STDMETHODIMP CIPConfMSP::get_DefaultIPInterface(
    OUT     BSTR *         ppIPAddress
    )
{
    LOG((MSP_TRACE, "get_DefaultIPInterface, ppIPAddress:%p", ppIPAddress));

    if (IsBadWritePtr(ppIPAddress, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, 
            "get_DefaultIPInterface, ppIPAddress is bad:%p", ppIPAddress));
        return E_POINTER;
    }

    // get the current local interface.
    m_Lock.Lock();
    DWORD dwIP= m_dwIPInterface;
    m_Lock.Unlock();

    BSTR bAddress = IPToBstr(dwIP);

    if (bAddress == NULL)
    {
        return E_OUTOFMEMORY;
    }

    *ppIPAddress = bAddress;

    LOG((MSP_TRACE, "get_DefaultIPInterface, returning %ws", bAddress));

    return S_OK;
}

STDMETHODIMP CIPConfMSP::put_DefaultIPInterface(
    IN      BSTR            pIPAddress
    )
{
    LOG((MSP_TRACE, "put_DefaultIPInterface, pIPAddress:%p", pIPAddress));

    if (IsBadStringPtrW(pIPAddress, MAXIPADDRLEN))
    {
        LOG((MSP_ERROR, 
            "put_DefaultIPInterface, invalid pointer:%p", pIPAddress));
        return E_POINTER;
    }

    char buffer[MAXIPADDRLEN + 1];

    if (WideCharToMultiByte(
        GetACP(),
        0,
        pIPAddress,
        -1,
        buffer,
        MAXIPADDRLEN,
        NULL,
        NULL
        ) == 0)
    {
        LOG((MSP_ERROR, "put_DefaultIPInterface, can't covert:%ws", pIPAddress));
        return E_INVALIDARG;
    }

    DWORD dwAddr;
    if ((dwAddr = inet_addr(buffer)) == INADDR_NONE)
    {
        LOG((MSP_ERROR, "put_DefaultIPInterface, bad address:%s", buffer));
        return E_INVALIDARG;
    }

    // set the current local interface.
    m_Lock.Lock();
    m_dwIPInterface = dwAddr;
    m_Lock.Unlock();


    LOG((MSP_TRACE, "put_DefaultIPInterface, set to %s", buffer));

    return S_OK;
}

HRESULT CreateBstrCollection(
    IN  BSTR  *     pBstr,
    IN  DWORD       dwCount,
    OUT VARIANT *   pVariant
    )
{
    //
    // create the collection object - see mspcoll.h
    //

    CComObject<CTapiBstrCollection> * pCollection;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( dwCount,
                                  pBstr,
                                  pBstr + dwCount);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "get_IPInterfaces - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "get_IPInterfaces - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "get_IPInterfaces - exit S_OK"));
 
    return S_OK;
}


STDMETHODIMP CIPConfMSP::get_IPInterfaces(
    OUT     VARIANT *       pVariant
    )
{
    PMIB_IPADDRTABLE pIPAddrTable = GetIPTable();

    if (pIPAddrTable == NULL)
    {
        return E_FAIL;
    }

    BSTR *Addresses = 
        (BSTR *)malloc(sizeof(BSTR *) * pIPAddrTable->dwNumEntries);
    
    if (Addresses == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    DWORD dwCount = 0;

    // loop through the interfaces and find the valid ones.
    for (DWORD i = 0; i < pIPAddrTable->dwNumEntries; i++) 
    {
        if (IsValidInterface(pIPAddrTable->table[i].dwAddr))
        {
            DWORD dwIPAddr   = ntohl(pIPAddrTable->table[i].dwAddr);
            Addresses[i] = IPToBstr(dwIPAddr);
            if (Addresses[i] == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            dwCount ++;
        }
    }

    // release table memory 
    free(pIPAddrTable);

    if (FAILED(hr))
    {
        // release all the BSTRs and the array.
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    hr = CreateBstrCollection(Addresses, dwCount, pVariant);

    // if the collection is not created, release all the BSTRs.
    if (FAILED(hr))
    {
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
    }

    // delete the pointer array.
    free(Addresses);

    return hr;
}

HRESULT CreateBstrEnumerator(
    IN  BSTR *                  begin,
    IN  BSTR *                  end,
    OUT IEnumBstr **           ppIEnum
    )
{
typedef CSafeComEnum<IEnumBstr, &__uuidof(IEnumBstr), BSTR, _CopyBSTR>> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    IEnumBstr * pIEnum;

    // query for the __uuidof(IEnumDirectory) i/f
    hr = pEnum->_InternalQueryInterface(
        __uuidof(IEnumBstr),
        (void**)&pIEnum
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagTakeOwnership);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        pIEnum->Release();
        return hr;
    }

    *ppIEnum = pIEnum;

    return hr;
}

STDMETHODIMP CIPConfMSP::EnumerateIPInterfaces(
    OUT     IEnumBstr **   ppIEnumBstr
    )
{
    PMIB_IPADDRTABLE pIPAddrTable = GetIPTable();

    if (pIPAddrTable == NULL)
    {
        return E_FAIL;
    }

    BSTR *Addresses = 
        (BSTR *)malloc(sizeof(BSTR *) * pIPAddrTable->dwNumEntries);
    
    if (Addresses == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    DWORD dwCount = 0;

    // loop through the interfaces and find the valid ones.
    for (DWORD i = 0; i < pIPAddrTable->dwNumEntries; i++) 
    {
        if (IsValidInterface(pIPAddrTable->table[i].dwAddr))
        {
            DWORD dwIPAddr   = ntohl(pIPAddrTable->table[i].dwAddr);
            Addresses[i] = IPToBstr(dwIPAddr);
            if (Addresses[i] == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            dwCount ++;
        }
    }

    // release table memory 
    free(pIPAddrTable);

    if (FAILED(hr))
    {
        // release all the BSTRs and the array.
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    hr = CreateBstrEnumerator(Addresses, Addresses + dwCount, ppIEnumBstr);

    // if the collection is not created, release all the BSTRs.
    if (FAILED(hr))
    {
        for (i = 0; i < dwCount; i ++)
        {
            SysFreeString(Addresses[i]);
        }
        free(Addresses);
        return hr;
    }

    // the enumerator will destroy the bstr array eventually,
    // so no need to free anything here. Even if we tell it to hand
    // out zero objects, it will delete the array on destruction.

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confaud.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confaud.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFAUD_H_
#define __CONFAUD_H_

const DWORD MAX_MIX_CHANNELS = 5;

const long DEFUAT_AEC_STATUS = 0;
const long DEFUAT_AGC_STATUS = 1;

class ATL_NO_VTABLE CStreamAudioRecv : 
    public CIPConfMSPStream,
    public ITAudioSettings
{
BEGIN_COM_MAP(CStreamAudioRecv)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfMSPStream)
END_COM_MAP()

public:

    CStreamAudioRecv();
    ~CStreamAudioRecv();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController * pIAudioDuplexController
        );

    HRESULT ShutDown();

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

//
    //IInnerStreamQualityControl methods
    //
#if 0
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );
#endif

protected:
    HRESULT SetUpFilters();

    HRESULT ConfigureRTPFormats(
        IN  IBaseFilter *       pIRTPFilter,
        IN  IStreamConfig *     pIStreamConfig
        );

    HRESULT AddOneMixChannel(
        IN  IBaseFilter* pSourceFilter,
        IN  IPin *pPin,
        IN  DWORD dwChannelNumber
        );

    HRESULT SetUpInternalFilters(
        IN  IPin **ppPins,
        IN  DWORD dwNumPins
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ProcessTalkingEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessWasTalkingEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

protected:

    // a small buffer to queue up pin mapped events.
    CMSPArray <DWORD>       m_PendingSSRCs;

protected:
    IAudioDuplexController *m_pIAudioDuplexController;
    
    // need an array of IBitrateControl pointer for all the decoders.
    //IBitrateControl *       m_pRenderBitrateControl;
};

class ATL_NO_VTABLE CStreamAudioSend : 
    public CIPConfMSPStream,
    public ITAudioSettings,
    public ITAudioDeviceControl
{

BEGIN_COM_MAP(CStreamAudioSend)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY(ITAudioDeviceControl)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfMSPStream)
END_COM_MAP()

public:
    CStreamAudioSend();
    ~CStreamAudioSend();

    HRESULT ShutDown();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController *pIAudioDuplexController
        );

    //
    // ITAudioDeviceControl methods
    //
    STDMETHOD (GetRange) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioDeviceProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:

    HRESULT SetUpFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pPin
        );

    HRESULT ConfigureRTPFormats(
        IN  IBaseFilter *       pIRTPFilter,
        IN  IStreamConfig *     pIStreamConfig
        );

    HRESULT GetAudioCapturePin(
        IN   ITTerminalControl *    pTerminal,
        OUT  IPin **                ppIPin
        );

    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    void CleanupCachedInterface();

    HRESULT CacheAdditionalInterfaces(
        IN  IPin *                 pIPin
        );

protected:

    IPin *      m_pCapturePin;
    IStreamConfig*          m_pIStreamConfig;
    ISilenceControl *       m_pSilenceControl;
    IAMAudioInputMixer  *   m_pAudioInputMixer;
    IAudioDeviceControl *   m_pAudioDeviceControl;
    IAudioDuplexController *m_pIAudioDuplexController;
    IBitrateControl *       m_pCaptureBitrateControl;
    IBaseFilter *           m_pEncoder;
    long                    m_lAutomaticGainControl;
    long                    m_lAcousticEchoCancellation;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confaudt.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    IPConfaudt.cpp

Abstract:

    IPConfMSP implementation of audio capture terminal and render terminal

Author:

    Zoltan Szilagyi (zoltans) September 6,1998
    Mu Han (muhan) June 6, 1999
--*/

#include "stdafx.h"

#define MAX_LONG 0xefffffff

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CIPConfAudioCaptureTerminal::CIPConfAudioCaptureTerminal()
    : m_WaveID(0),
      m_DSoundGuid(GUID_NULL),
      m_pIAMAudioInputMixer(NULL)
{
    LOG((MSP_TRACE, "CIPConfAudioCaptureTerminal::CIPConfAudioCaptureTerminal"));
    m_TerminalClassID   = CLSID_MicrophoneTerminal;
    m_TerminalDirection = TD_CAPTURE;
    m_TerminalType      = TT_STATIC;
    m_TerminalState     = TS_NOTINUSE;
    m_dwMediaType       = TAPIMEDIATYPE_AUDIO;
}

CIPConfAudioCaptureTerminal::~CIPConfAudioCaptureTerminal()
{
    LOG((MSP_TRACE, "CIPConfAudioCaptureTerminal::~CIPConfAudioCaptureTerminal"));
    if (m_pIAMAudioInputMixer)
    {
        m_pIAMAudioInputMixer->Release();
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


HRESULT CIPConfAudioCaptureTerminal::CreateTerminal(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress,
    OUT ITTerminal      **ppTerm
    )
/*++

Routine Description:

    This method creates a terminal object base on the device info.

Arguments:

    pAudioDevieInfo - a pointer to an AudioDevieInfo data structure.

    htAddress - the handle to the address object.

    ppTerm - memory to store the returned terminal pointer.
    
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::CreateTerminal");
    LOG((MSP_TRACE, "%s, htAddress:%x", __fxName, htAddress));

    _ASSERT(!IsBadWritePtr(ppTerm, sizeof(ITTerminal *)));

    HRESULT hr;

    //
    // Create the terminal.
    //
    CMSPComObject<CIPConfAudioCaptureTerminal> *pTerminal = NULL;

    hr = ::CreateCComObjectInstance(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s can't create the terminal object hr = %8x", __fxName, hr));

        return hr;
    }


    // query for the ITTerminal interface
    ITTerminal *pITTerminal;
    hr = pTerminal->_InternalQueryInterface(__uuidof(ITTerminal), (void**)&pITTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, query terminal interface failed, %x", __fxName, hr));
        delete pTerminal;

        return hr;
    }

    // initialize the terminal 
    hr = pTerminal->Initialize(
            pAudioDevieInfo,
            htAddress
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s, Initialize failed; returning 0x%08x", __fxName, hr));

        pITTerminal->Release();
    
        return hr;
    }

    LOG((MSP_TRACE, "%s, Terminal %p(%ws) created", 
        __fxName, pITTerminal, pAudioDevieInfo->szDeviceDescription));

    *ppTerm = pITTerminal;

    return S_OK;
}

HRESULT CIPConfAudioCaptureTerminal::Initialize(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress
    )
{
    m_DSoundGuid = pAudioDevieInfo->DSoundGUID;
    m_WaveID = pAudioDevieInfo->WaveID;

    return CIPConfBaseTerminal::Initialize(
        pAudioDevieInfo->szDeviceDescription, htAddress
        );
}

HRESULT CIPConfAudioCaptureTerminal::CreateFilter(void)
/*++

Routine Description:

    This method creates the filter in this terminal. It creates the tapi audio
    capture filter and configures the device it uses.

Arguments:

    nothing.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::CreateFilter");
    LOG((MSP_TRACE, "%s, entered", __fxName));

    // This should only be called atmost once in the lifetime of this instance
    _ASSERT(m_pFilter == NULL);
    _ASSERT(m_pIAMAudioInputMixer == NULL);

    IBaseFilter *pICaptureFilter;

    // Create the filter.
    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIAudioCapture),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&pICaptureFilter
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, CoCreate filter failed, %x", __fxName, hr));
        return hr;
    }
    
    // get the config interface.
    IAudioDeviceConfig *pIAudioDeviceConfig;
    hr = pICaptureFilter->QueryInterface(
        __uuidof(IAudioDeviceConfig), 
        (void **)&pIAudioDeviceConfig
        );

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, can't get the IAudioDeviceConfig interface, %x", 
            __fxName, hr));
        return hr;
    }

    // tell the filter the device IDs.
    hr = pIAudioDeviceConfig->SetDeviceID(m_DSoundGuid, m_WaveID);
    pIAudioDeviceConfig->Release();

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, set device ID failed, %x", __fxName, hr));
        return hr;
    }

    // remember the filter, keep the refcount as well.
    m_pFilter = pICaptureFilter;

    // Get the basic audio (mixer) interface for the filter.
    IAMAudioInputMixer *pIAMAudioInputMixer;
    hr = m_pFilter->QueryInterface(
            __uuidof(IAMAudioInputMixer),
            (void **) &pIAMAudioInputMixer
            );

    if (FAILED(hr))
    {
        // The filter doesn't support the mixer interface. This is not catastrophic;
        // all it means is that subsequent mixer operations on the terminal will fail.
        LOG((MSP_WARN, "%s, mixer QI failed %x", __fxName, hr));  
        m_pIAMAudioInputMixer = NULL;
    }
    else
    {
        m_pIAMAudioInputMixer = pIAMAudioInputMixer;
    }

    LOG((MSP_TRACE, "%s succeeded", __fxName));
    return S_OK;
}

HRESULT CIPConfAudioCaptureTerminal::GetExposedPins(
    IN  IPin ** ppPins, 
    IN  DWORD dwNumPins
    )
/*++

Routine Description:

    This method returns the output pins of the audio capture filter.

Arguments:

    ppPins - memory buffer to store the returned pins.

    dwNumPins - the number pins asked.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::GetExposedPins");
    LOG((MSP_TRACE, "%s entered, dwNumPins:%d", __fxName, dwNumPins));

    _ASSERT(m_pFilter != NULL);
    _ASSERT(dwNumPins != 0);
    _ASSERT(!IsBadWritePtr(ppPins, sizeof (IPin*) * dwNumPins));

    // Get the enumerator of pins on the filter.
    IEnumPins * pIEnumPins;
    HRESULT hr = m_pFilter->EnumPins(&pIEnumPins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s enumerate pins on the filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    // TODO: get only the outptu pins.
    // get the pins.
    DWORD dwFetched;
    hr = pIEnumPins->Next(dwNumPins, ppPins, &dwFetched);

    pIEnumPins->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s IEnumPins->Next failed. hr=%x", __fxName, hr));
        return hr;
    }

    _ASSERT(dwFetched == dwNumPins);

    return S_OK;
}


STDMETHODIMP 
CIPConfAudioCaptureTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::DisconnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    Lock();

    HRESULT hr;
    hr = CIPConfBaseTerminal::DisconnectTerminal(pGraph, dwReserved);

    if (SUCCEEDED(hr))
    {
        if (m_pIAMAudioInputMixer)
        {
            m_pIAMAudioInputMixer->Release();
            m_pIAMAudioInputMixer = NULL;
        }
    }

    Unlock();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*                                                                         *//
//* NOTE: The input filter does not support IBasicAudio so we need to masage*//
//*       the parameters for the basic audio methods so that the will work  *//
//*       for IAMAudioInputMixer.                                           *//
//*                                                                         *//    
//*****************************************************************************
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CIPConfAudioCaptureTerminal::get_Volume(long * plVolume)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::get_Volume");
    LOG((MSP_TRACE, "%s entered", __fxName));

    // Check parameters.
    if ( IsBadWritePtr(plVolume, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s bad pointer, plVolume:%p", __fxName, plVolume));
        return E_POINTER;
    }

    Lock();
    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    double dVolume;
    hr = m_pIAMAudioInputMixer->get_MixLevel(&dVolume);
    
    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_MixLevel) failed, hr=%x", __fxName, hr));
        return hr;
    }

    //
    // Massage ranges to convert between disparate semantics.
    //
    _ASSERT(dVolume >= MIXER_MIN_VOLUME);
    _ASSERT(dVolume <= MIXER_MAX_VOLUME);
    
    // Convert the volume from whatever range of doubles the filter uses
    // to the range 0 - 1. Right now this does nothing but makes the code
    // more general.
    dVolume = ( dVolume                 - MIXER_MIN_VOLUME )
            / ( MIXER_MAX_VOLUME - MIXER_MIN_VOLUME );

    // Convert the volume from the range 0 - 1 to the API's range.
    *plVolume = MIN_VOLUME +
        (long) (( MAX_VOLUME - MIN_VOLUME ) * dVolume);

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::put_Volume(long lVolume)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::put_Volume");
    LOG((MSP_TRACE, "%s entered, lVolume:%d", __fxName, lVolume));

    // Our argument is a long in the range 0 - 0xFFFF. We need to convert it
    // to a double ranging from 0.0 to 1.0.
    if (lVolume < MIN_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d < %d; returning E_INVALIDARG",
            __fxName, lVolume, MIN_VOLUME));

        return E_INVALIDARG;
    }

    if (lVolume > MAX_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d > %d; returning E_INVALIDARG",
            __fxName, lVolume, MAX_VOLUME));

        return E_INVALIDARG;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    // Convert to the range 0 to 1.
    double dVolume =
               ( (double) ( lVolume             - MIN_VOLUME ) )
             / ( (double) ( MAX_VOLUME - MIN_VOLUME ) );

    // Convert the volume to whatever range of doubles the filter uses
    // from the range 0 - 1. Right now this does nothing but makes the code
    // more general.

    dVolume = MIXER_MIN_VOLUME +
        ( MIXER_MAX_VOLUME - MIXER_MIN_VOLUME ) * dVolume;

    hr = m_pIAMAudioInputMixer->put_MixLevel(dVolume);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::get_Balance(long * plBalance)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::get_Balance");
    LOG((MSP_TRACE, "%s entered, plBalance:%p", __fxName, plBalance));

    if ( IsBadWritePtr(plBalance, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    double dBalance;
    hr = m_pIAMAudioInputMixer->get_Pan(&dBalance);

    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_Pan) failed, hr=%x", __fxName, hr));
        return hr;
    }

    *plBalance = (LONG) (dBalance * MAX_LONG);

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::put_Balance(long lBalance)
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::put_Balance");
    LOG((MSP_TRACE, "%s entered, lBalance:%d", __fxName, lBalance));

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIAMAudioInputMixer->put_Pan(lBalance / MAX_LONG);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioCaptureTerminal::get_WaveId(
    OUT long * plWaveId
    )
{
    ENTER_FUNCTION("CIPConfAudioCaptureTerminal::get_WaveId");
    LOG((MSP_TRACE, "%s, plWaveId:%p", __fxName, plWaveId));

    if ( IsBadWritePtr(plWaveId, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s, bad pointer argument", __fxName));

        return E_POINTER;
    }

    *plWaveId = (LONG)m_WaveID;

    LOG((MSP_TRACE, "%s, returning wave id:%d", __fxName, m_WaveID));
    return S_OK;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  Audio Render Terminal
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CIPConfAudioRenderTerminal::CIPConfAudioRenderTerminal()
    : m_WaveID(0),
      m_DSoundGuid(GUID_NULL),
      m_pIBasicAudio(NULL)
{
    LOG((MSP_TRACE, "CIPConfAudioRenderTerminal::CIPConfAudioRenderTerminal"));
    m_TerminalClassID   = CLSID_SpeakersTerminal;
    m_TerminalDirection = TD_RENDER;
    m_TerminalType      = TT_STATIC;
    m_TerminalState     = TS_NOTINUSE;
    m_dwMediaType       = TAPIMEDIATYPE_AUDIO;
}

CIPConfAudioRenderTerminal::~CIPConfAudioRenderTerminal()
{
    LOG((MSP_TRACE, "CIPConfAudioRenderTerminal::~CIPConfAudioRenderTerminal"));
    if (m_pIBasicAudio)
    {
        m_pIBasicAudio->Release();
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


HRESULT CIPConfAudioRenderTerminal::CreateTerminal(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress,
    OUT ITTerminal      **ppTerm
    )
/*++

Routine Description:

    This method creates a terminal object base on the info in the moniker.

Arguments:

    pAudioDevieInfo - a pointer to an AudioDevieInfo data structure.

    htAddress - the handle to the address object.

    ppTerm - memory to store the returned terminal pointer.
    
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::CreateTerminal");
    LOG((MSP_TRACE, "%s, htAddress:%x", __fxName, htAddress));

    _ASSERT(!IsBadWritePtr(ppTerm, sizeof(ITTerminal *)));

    HRESULT hr;

    //
    // Create the filter.
    //
    CMSPComObject<CIPConfAudioRenderTerminal> *pTerminal = NULL;

    hr = ::CreateCComObjectInstance(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s can't create the terminal object hr = %8x", __fxName, hr));

        return hr;
    }

    // query for the ITTerminal interface
    ITTerminal *pITTerminal;
    hr = pTerminal->_InternalQueryInterface(__uuidof(ITTerminal), (void**)&pITTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, query terminal interface failed, %x", __fxName, hr));
        delete pTerminal;

        return hr;
    }

    // initialize the terminal 
    hr = pTerminal->Initialize(
            pAudioDevieInfo,
            htAddress
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s, Initialize failed; returning 0x%08x", __fxName, hr));

        pITTerminal->Release();
    
        return hr;
    }

    LOG((MSP_TRACE, "%s, Terminal %p(%ws) created", 
        __fxName, pITTerminal, pAudioDevieInfo->szDeviceDescription));

    *ppTerm = pITTerminal;

    return S_OK;
}

HRESULT CIPConfAudioRenderTerminal::Initialize(
    IN  AudioDeviceInfo *pAudioDevieInfo,
    IN  MSP_HANDLE      htAddress
    )
{
    m_DSoundGuid = pAudioDevieInfo->DSoundGUID;
    m_WaveID = pAudioDevieInfo->WaveID;

    return CIPConfBaseTerminal::Initialize(
        pAudioDevieInfo->szDeviceDescription, htAddress
        );
}

HRESULT CIPConfAudioRenderTerminal::CreateFilter(void)
/*++

Routine Description:

    This method creates the filter in this terminal. It creates the tapi audio
    render filter and configures the device it uses.

Arguments:

    nothing.
   
Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::CreateFilters");
    LOG((MSP_TRACE, "%s, entered", __fxName));

    // This should only be called atmost once in the lifetime of this instance
    _ASSERT(m_pFilter == NULL);

    IBaseFilter *pICaptureFilter;

    // Create the filter.
    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIAudioRender),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&pICaptureFilter
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, CoCreate filter failed, %x", __fxName, hr));
        return hr;
    }

    // get the config interface.
    IAudioDeviceConfig *pIAudioDeviceConfig;
    hr = pICaptureFilter->QueryInterface(
        __uuidof(IAudioDeviceConfig), 
        (void **)&pIAudioDeviceConfig
        );

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, can't get the IAudioDeviceConfig interface, %x", 
            __fxName, hr));
        return hr;
    }

    // tell the filter the device IDs.
    hr = pIAudioDeviceConfig->SetDeviceID(m_DSoundGuid, m_WaveID);
    pIAudioDeviceConfig->Release();

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, set device ID failed, %x", __fxName, hr));
        return hr;
    }

    // remember the filter, keep the refcount as well.
    m_pFilter = pICaptureFilter;

    // Get the basic audio interface for the filter.
    IBasicAudio *pIBasicAudio;
    hr = m_pFilter->QueryInterface(
            __uuidof(IBasicAudio),
            (void **) &pIBasicAudio
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, IBasicAudio QI failed 0x%08x", __fxName, hr));  
        m_pIBasicAudio = NULL;
    }
    else
    {
        m_pIBasicAudio = pIBasicAudio;
    }

    LOG((MSP_TRACE, "%s succeeded", __fxName));
    return S_OK;
}

HRESULT CIPConfAudioRenderTerminal::GetExposedPins(
    IN  IPin ** ppPins, 
    IN  DWORD dwNumPins
    )
/*++

Routine Description:

    This method returns the input pins of the audio render filter.

Arguments:

    ppPins - memory buffer to store the returned pins.

    dwNumPins - the number pins asked.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::GetExposedPins");
    LOG((MSP_TRACE, "%s entered, dwNumPins:%d", __fxName, dwNumPins));

    _ASSERT(m_pFilter != NULL);
    _ASSERT(dwNumPins != 0);
    _ASSERT(!IsBadWritePtr(ppPins, sizeof (IPin*) * dwNumPins));

    // Get the enumerator of pins on the filter.
    IEnumPins * pIEnumPins;
    HRESULT hr = m_pFilter->EnumPins(&pIEnumPins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s enumerate pins on the filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    // get the pins.
    DWORD dwFetched;
    hr = pIEnumPins->Next(dwNumPins, ppPins, &dwFetched);

    pIEnumPins->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s IEnumPins->Next failed. hr=%x", __fxName, hr));
        return hr;
    }

    _ASSERT(dwFetched == dwNumPins);

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// TODO: Fix the range
STDMETHODIMP CIPConfAudioRenderTerminal::get_Volume(long * plVolume)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::get_Volume");
    LOG((MSP_TRACE, "%s entered", __fxName));

    if ( IsBadWritePtr(plVolume, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s bad pointer, plVolume:%p", __fxName, plVolume));
        return E_POINTER;
    }

    Lock();
    
    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->get_Volume(plVolume);
    
    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_Volume) failed, hr=%x", __fxName, hr));
        return hr;
    }

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::put_Volume(long lVolume)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::put_Volume");
    LOG((MSP_TRACE, "%s entered, lVolume:%d", __fxName, lVolume));

    // Our argument is a long in the range 0 - 0xFFFF. We need to convert it
    // to a double ranging from 0.0 to 1.0.
    if (lVolume < MIN_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d < %d; returning E_INVALIDARG",
            __fxName, lVolume, MIN_VOLUME));

        return E_INVALIDARG;
    }

    if (lVolume > MAX_VOLUME)
    {
        LOG((MSP_ERROR, 
            "%s volume %d > %d; returning E_INVALIDARG",
            __fxName, lVolume, MAX_VOLUME));

        return E_INVALIDARG;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->put_Volume(lVolume);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::get_Balance(long * plBalance)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::get_Balance");
    LOG((MSP_TRACE, "%s entered, plBalance:%p", __fxName, plBalance));

    if ( IsBadWritePtr(plBalance, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->get_Balance(plBalance);

    Unlock();

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "%s (get_Balance) failed, hr=%x", __fxName, hr));
        return hr;
    }

    LOG((MSP_TRACE, "%s exits S_OK", __fxName));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::put_Balance(long lBalance)
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::put_Balance");
    LOG((MSP_TRACE, "%s entered, lBalance:%d", __fxName, lBalance));

    Lock();

    HRESULT hr;
    
    if (m_pFilter == NULL)
    {
        hr = CreateFilter();
    
        if ( FAILED(hr) )
        {
            Unlock();
            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        Unlock();
        return E_FAIL;
    }

    hr = m_pIBasicAudio->put_Balance(lBalance);

    Unlock();

    LOG((MSP_TRACE, "%s exits. hr=%x", __fxName, hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CIPConfAudioRenderTerminal::get_WaveId(
    OUT long * plWaveId
    )
{
    ENTER_FUNCTION("CIPConfAudioRenderTerminal::get_WaveId");
    LOG((MSP_TRACE, "%s, plWaveId:%p", __fxName, plWaveId));

    if ( IsBadWritePtr(plWaveId, sizeof(long)) )
    {
        LOG((MSP_ERROR, "%s, bad pointer argument", __fxName));
        return E_POINTER;
    }

    *plWaveId = (LONG)m_WaveID;

    LOG((MSP_TRACE, "%s, returning wave id:%d", __fxName, m_WaveID));
    return S_OK;
}


STDMETHODIMP 
CIPConfAudioRenderTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::DisconnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    Lock();

    HRESULT hr;
    hr = CIPConfBaseTerminal::DisconnectTerminal(pGraph, dwReserved);

    if (SUCCEEDED(hr))
    {
        if (m_pIBasicAudio)
        {
            m_pIBasicAudio->Release();
            m_pIBasicAudio = NULL;
        }
    }

    Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confaddr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confaddr.h

Abstract:

    Declaration of the CIPConfMSP

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __CONFADDR_H_
#define __CONFADDR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"

const DWORD IPCONFCALLMEDIATYPES = (TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO);
const DWORD MAXIPADDRLEN = 255;

extern const GUID CLSID_IPConfMSP;

/////////////////////////////////////////////////////////////////////////////
// CIPConfMSP
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CIPConfMSP : 
    public CMSPAddress,
    public CComCoClass<CIPConfMSP, &CLSID_IPConfMSP>,
    public CMSPObjectSafetyImpl
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_IPCONFMSP)
DECLARE_POLY_AGGREGATABLE(CIPConfMSP)

public:

    BEGIN_COM_MAP(CIPConfMSP)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_CHAIN(CMSPAddress)
    END_COM_MAP()

    CIPConfMSP() 
        : m_dwIPInterface(INADDR_ANY),
          m_hSocket(NULL),
          m_hDxmrtp(NULL)
    {}

    HRESULT FinalConstruct();
    void    FinalRelease();
    DWORD FindLocalInterface(DWORD dwIP);

    STDMETHOD (CreateTerminal) (
        IN      BSTR                pTerminalClass,
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        OUT     ITTerminal **       ppTerminal
        );

    STDMETHOD (CreateMSPCall) (
        IN      MSP_HANDLE      htCall,
        IN      DWORD           dwReserved,
        IN      DWORD           dwMediaType,
        IN      IUnknown *      pOuterUnknown,
        OUT     IUnknown **     ppMSPCall
        );

    STDMETHOD (ShutdownMSPCall) (
        IN      IUnknown *      pMSPCall
        );

    ULONG MSPAddressAddRef(void);

    ULONG MSPAddressRelease(void);

#ifdef USEIPADDRTABLE
    STDMETHOD (get_DefaultIPInterface) (
        OUT     BSTR *          ppIPAddress
        );
    
    STDMETHOD (put_DefaultIPInterface) (
        IN      BSTR            pIPAddress
        );

    STDMETHOD (get_IPInterfaces) (
        OUT     VARIANT *       pVariant
        );
    
    STDMETHOD (EnumerateIPInterfaces) (
        OUT     IEnumBstr **   ppIEnumBstr
        );
#endif

protected:

    DWORD GetCallMediaTypes(void);

    HRESULT CreateAudioCaptureTerminals();
    HRESULT CreateAudioRenderTerminals();
    HRESULT CreateVideoCaptureTerminals();

    HRESULT UpdateTerminalList(void);
    HRESULT UpdateTerminalListForPnp(IN BOOL bDeviceArrival);

protected:

    // the default interface to join the conference.
    DWORD   m_dwIPInterface;

    // the critical section to protect the local data.
    CMSPCritSection     m_Lock;

    SOCKET              m_hSocket;

    HMODULE             m_hDxmrtp;
};

#ifdef USEIPADDRTABLE
/////////////////////////////////////////////////////////////////////////////
// _CopyBSTR is used in creating BSTR enumerators.
/////////////////////////////////////////////////////////////////////////////
class _CopyBSTR
{
public:
    static void copy(BSTR *p1, BSTR *p2)
    {
            (*p1) = SysAllocString(*p2);
    }
    static void init(BSTR* p) {*p = NULL;}
    static void destroy(BSTR* p) { SysFreeString(*p);}
};
#endif

#endif //__CONFADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confcall.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confcall.h

Abstract:

    Declaration of the CIPConfMSPCall

Author:
    
    Mu Han (muhan) 5-September-1998

--*/

#ifndef __CONFCALL_H_
#define __CONFCALL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <confpdu.h>

const DWORD MAX_PAYLOAD_TYPES = 10;

typedef struct _STREAMSETTINGS
{
    DWORD   dwNumPayloadTypes;
    DWORD   PayloadTypes[MAX_PAYLOAD_TYPES];

    DWORD   dwMSPerPacket;    // milliseconds per packet.

    DWORD   dwQOSLevel;
    DWORD   dwTTL;
    DWORD   dwIPLocal;        // local interface to bind to.
    DWORD   dwIPRemote;       // remote IP address in host byte order.
    WORD    wRTPPortRemote;   // remote port number in host byte order.
    HANDLE *phRTPSession;     // the shared RTP session cookie

    BOOL    fCIF;             // if CIF is used for video.
    MULTICAST_LOOPBACK_MODE LoopbackMode;

    LONG    lBandwidth;

    WCHAR   *pApplicationID;
    WCHAR   *pApplicationGUID;
    WCHAR   *pSubIDs;

} STREAMSETTINGS, *PSTREAMSETTINGS;


/////////////////////////////////////////////////////////////////////////////
// CIPConfMSPCall
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CIPConfMSPCall : 
    public CMSPCallMultiGraph,
    public IDispatchImpl<ITParticipantControl, &__uuidof(ITParticipantControl), 
                            &LIBID_IPConfMSPLib>,
    public IDispatchImpl<ITLocalParticipant, &__uuidof(ITLocalParticipant), 
                            &LIBID_IPConfMSPLib>,
    public IDispatchImpl<IMulticastControl, &__uuidof(IMulticastControl), 
                            &LIBID_IPConfMSPLib>,
    public IDispatchImpl<ITQOSApplicationID, &__uuidof(ITQOSApplicationID), 
                            &LIBID_IPConfMSPLib>,
    public ITCallQualityControl,
    public IInnerCallQualityControl,
    public CMSPObjectSafetyImpl
{

public:

BEGIN_COM_MAP(CIPConfMSPCall)
    COM_INTERFACE_ENTRY(ITParticipantControl)
    COM_INTERFACE_ENTRY(ITLocalParticipant)
    COM_INTERFACE_ENTRY(IMulticastControl)
    COM_INTERFACE_ENTRY(ITQOSApplicationID)
    COM_INTERFACE_ENTRY2(IDispatch, ITStreamControl)
    COM_INTERFACE_ENTRY(ITCallQualityControl)
    COM_INTERFACE_ENTRY(IInnerCallQualityControl)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPCallMultiGraph)
END_COM_MAP()

    CIPConfMSPCall();
    ~CIPConfMSPCall();

// ITStreamControl methods, called by the app.
    STDMETHOD (CreateStream) (
        IN      long                lMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN OUT  ITStream **         ppStream
        );
    
    STDMETHOD (RemoveStream) (
        IN      ITStream *          pStream
        );                      

// ITParticipantControl methods, called by the app.
    STDMETHOD (EnumerateParticipants) (
        OUT     IEnumParticipant ** ppEnumParticipants
        );

    STDMETHOD (get_Participants) (
        OUT     VARIANT * pVariant
        );

// IMulticastControl methods, called by the app.
    STDMETHOD (get_LoopbackMode) (
        OUT MULTICAST_LOOPBACK_MODE * pMode
        );
    
    STDMETHOD (put_LoopbackMode) (
        IN MULTICAST_LOOPBACK_MODE mode
        );

// ITLocalParticipant methods, called by the app.
    STDMETHOD (get_LocalParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        OUT BSTR *                  ppInfo
        );

    STDMETHOD (put_LocalParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        IN  BSTR                    pInfo
        );

//ITQOSApplicationID methods, called by the app.
    STDMETHOD (SetQOSApplicationID) (
        IN  BSTR pApplicationID,
        IN  BSTR pApplicationGUID,
        IN  BSTR pSubIDs
        );

// methods called by the MSPAddress object.
    HRESULT Init(
        IN      CMSPAddress *       pMSPAddress,
        IN      MSP_HANDLE          htCall,
        IN      DWORD               dwReserved,
        IN      DWORD               dwMediaType
        );

    HRESULT ShutDown();

    HRESULT ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

// medthod called by the worker thread.
    static DWORD WINAPI WorkerCallbackDispatcher(VOID *pContext);

    virtual VOID HandleGraphEvent(
        IN      MSPSTREAMCONTEXT *  pContext
        );

    DWORD ProcessWorkerCallBack(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        );

    HRESULT InternalShutDown();
    
    DWORD MSPCallAddRef()
    {
        return MSPAddRefHelper(this);
    }

    DWORD MSPCallRelease()
    {
        return MSPReleaseHelper(this);
    }

// medthod called by the streams for participants
    HRESULT NewParticipant(
        IN  ITStream *              pITStream,
        IN  DWORD                   dwSSRC,
        IN  DWORD                   dwSendRecv,
        IN  DWORD                   dwMediaType,
        IN  WCHAR *                  szCName,
        OUT ITParticipant **        pITParticipant
        );

    HRESULT ParticipantLeft(
        IN ITParticipant *          pITParticipant
        );

    void SendParticipantEvent(
        IN  PARTICIPANT_EVENT       Event,
        IN  ITParticipant *         pITParticipant,
        IN  ITSubStream *           pITSubStream = NULL
        ) const;                          

    HRESULT SendTSPMessage(
        IN      TSP_MSP_COMMAND     command,
        IN      DWORD               dwParam1 = 0,
        IN      DWORD               dwParam2 = 0
        ) const;

    // this function is called at the call init time.
    void SetIPInterface(DWORD dwIPInterface)
    { m_dwIPInterface = dwIPInterface; }

    // ITCallQualityControl methods
    STDMETHOD (GetRange) (
        IN CallQualityProperty Property, 
        OUT long *plMin, 
        OUT long *plMax, 
        OUT long *plSteppingDelta, 
        OUT long *plDefault, 
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN CallQualityProperty Property, 
        OUT long *plValue, 
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN CallQualityProperty Property, 
        IN long lValue, 
        IN TAPIControlFlags lFlags
        );

    // IInnerCallQualityControl methods
    STDMETHOD_(ULONG, InnerCallAddRef) (VOID);

    STDMETHOD_(ULONG, InnerCallRelease) (VOID);

    STDMETHOD (RegisterInnerStreamQC) (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        );

    STDMETHOD (DeRegisterInnerStreamQC) (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        );

    STDMETHOD (ProcessQCEvent) (
        IN  QCEvent event,
        IN  DWORD dwParam
        );

protected:

    HRESULT InitializeLocalParticipant();
    
    virtual HRESULT CreateStreamObject(
        IN      DWORD               dwMediaType,
        IN      TERMINAL_DIRECTION  Direction,
        IN      IMediaEvent *       pGraph,
        IN      ITStream **         ppStream
        );

    HRESULT ProcessMediaItem(
        IN      ITMedia *           pITMedia,
        IN      DWORD               dwMediaTypeMask,
        OUT     DWORD *             pdwMediaType,
        OUT     WORD *              pwPort,
        OUT     DWORD *             pdwPayloadTypes,
        IN OUT  DWORD *             pdwNumPayLoadType
        );

    DWORD FindInterfaceByName(
        IN      WCHAR *             pMachineName
        );

    HRESULT CheckOrigin(
        IN      ITSdp *             pITSdp, 
        OUT     BOOL *              pFlag,
        OUT     DWORD *             pdwIP
        );

    HRESULT ConfigStreamsBasedOnSDP(
        IN      ITSdp *             pITSdp,
        IN      DWORD               dwAudioQOSLevel,
        IN      DWORD               dwVideoQOSLevel
        );

    HRESULT ParseSDP(
        IN      WCHAR *             pSDP,
        IN      DWORD               dwAudioQOSLevel,
        IN      DWORD               dwVideoQOSLevel
        );                          

    HRESULT CheckUnusedStreams();

    HRESULT InitFullDuplexControler();

protected:

    // The list of participant in the call.
    CParticipantList    m_Participants;

    // call quality control relay
    CCallQualityControlRelay *m_pCallQCRelay;

    // the information items for local participant. The index is the 
    // value of RTP_SDES_* - 1, see MSRTP.h.
    WCHAR *             m_InfoItems[NUM_SDES_ITEMS];
    BOOL                m_fLocalInfoRetrieved;

    // The critical section to protect the participant list.
    CMSPCritSection     m_ParticipantLock;

    BOOL                m_fShutDown;

    DWORD               m_dwIPInterface;

    HANDLE              m_hAudioRTPSession;
    HANDLE              m_hVideoRTPSession;
    IAudioDuplexController *    m_pIAudioDuplexController;
    MULTICAST_LOOPBACK_MODE     m_LoopbackMode;

    BOOL                m_fCallStarted;
    BSTR                m_pApplicationID;
    BSTR                m_pApplicationGUID;
    BSTR                m_pSubIDs;
    BOOL                m_fEnableAEC;
};

typedef struct _CALLWORKITEM
{
    CIPConfMSPCall  *pCall;
    DWORD           dwLen;
    BYTE            Buffer[1];

} CALLWORKITEM, *PCALLWORKITEM;

// some debug support
const char * const ParticipantEventString[] = 
{
    "NEW_PARTICIPANT",
    "INFO_CHANGE",
    "PARTICIPANT_LEAVE",
    "NEW_SUBSTREAM",
    "SUBSTREAM_REMOVED",
    "SUBSTREAM_MAPPED",
    "SUBSTREAM_UNMAPPED",
    "PARTICIPANT_TIMEOUT",
    "PARTICIPANT_RECOVERED",
    "PARTICIPANT_ACTIVE",
    "PARTICIPANT_INACTIVE",
    "LOCAL_TALKING",
    "LOCAL_SILENT"
};

#endif //__CONFCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confaud.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confaud.cpp

Abstract:

    This module contains implementation of the audio send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
//  Helper functions
//
/////////////////////////////////////////////////////////////////////////////
HRESULT ConfigureFullduplexControl(
    IN IPin * pIPin,
    IN IAudioDuplexController *pIAudioDuplexController
    )
/*++

Routine Description:
    
    This method sets the AudioDuplexController on the filter.

Arguments:
    
    pIPin - the pin that belongs to the filter.

    pIAudioDuplexController - the IAudioDuplexController interface.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("::ConfigureFullduplexControl");
    LOG((MSP_TRACE, "%s enters", __fxName));

    if (pIAudioDuplexController == NULL)
    {
        // we don't need to configure anything.
        return S_OK;
    }

    HRESULT hr;

    // find the filter behind the pin.
    PIN_INFO PinInfo;
    if (FAILED(hr = pIPin->QueryPinInfo(&PinInfo)))
    {
        LOG((MSP_ERROR, 
            "%s:can't get the capture filter, hr=%x", 
            __fxName, hr));

        return hr;
    }

    IAudioDeviceConfig *pIAudioDeviceConfig;

    // get the IAudioDeviceConfig interface.
    hr = PinInfo.pFilter->QueryInterface(&pIAudioDeviceConfig);

    PinInfo.pFilter->Release();
    
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture filter's pIAudioDeviceConfig failed, hr=%x", 
            __fxName, hr));

        return hr;
    }
    
    // tell the filter about the full-duplex controller.
    hr = pIAudioDeviceConfig->SetDuplexController(pIAudioDuplexController);

    pIAudioDeviceConfig->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s:set IAudioDuplexController failed, hr=%x", 
            __fxName, hr));

        return hr;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioRecv::CStreamAudioRecv()
    : CIPConfMSPStream(),
    m_pIAudioDuplexController(NULL)
{
    m_szName = L"AudioRecv";
}

CStreamAudioRecv::~CStreamAudioRecv()
{
    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->Release();
    }
}

// this method is called by the call object at init time.
void CStreamAudioRecv::SetFullDuplexController(
    IN IAudioDuplexController *pIAudioDuplexController
    )
{
    _ASSERT(pIAudioDuplexController);
    _ASSERT(m_pIAudioDuplexController == NULL);

    pIAudioDuplexController->AddRef();
    m_pIAudioDuplexController = pIAudioDuplexController;
}


STDMETHODIMP CStreamAudioRecv::GetRange(
    IN  AudioSettingsProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a audio setting property. Delegated to the renderfilter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::GetRange(AudioSettings)");

    if (IsBadWritePtr (plMin, sizeof (long)) ||
        IsBadWritePtr (plMax, sizeof (long)) ||
        IsBadWritePtr (plSteppingDelta, sizeof (long)) ||
        IsBadWritePtr (plDefault, sizeof (long)) ||
        IsBadWritePtr (plFlags, sizeof (TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s: bad write pointer", __fxName));
        return E_POINTER;
    }
    
    HRESULT hr;

    switch (Property)
    {
    case AudioSettings_SignalLevel:
        break;

    case AudioSettings_SilenceThreshold:
        break;

    case AudioSettings_Volume:
        break;

    case AudioSettings_Balance:
        break;

    case AudioSettings_Loudness:
        break;

    case AudioSettings_Treble:
        break;

    case AudioSettings_Bass:
        break;

    case AudioSettings_Mono:
        break;

    default:
        hr = E_INVALIDARG;

    }

    return E_NOTIMPL;
}

STDMETHODIMP CStreamAudioRecv::Get(
    IN  AudioSettingsProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a audio setting property. Delegated to the renderfilter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::Get(AudioSettings)");

    if (IsBadWritePtr (plValue, sizeof(long)) ||
        IsBadWritePtr (plFlags, sizeof(TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s received bad pointer.", __fxName));
        return E_POINTER;
    }

    return E_NOTIMPL;
}

STDMETHODIMP CStreamAudioRecv::Set(
    IN  AudioSettingsProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a audio setting property. Delegated to the renderfilter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::Set(AudioSettings)");

    return E_NOTIMPL;
}

//
// ITStreamQualityControl methods
//
STDMETHODIMP CStreamAudioRecv::Set (
    IN   StreamQualityProperty Property, 
    IN   long lValue, 
    IN   TAPIControlFlags lFlags
    )
{
    return E_NOTIMPL;
}

HRESULT CStreamAudioRecv::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioRecv::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL bFound = FALSE;
    for (DWORD dw = 0; dw < dwCount; dw ++)
    {
        // TODO, a new interface is needed to resolve RTP to MediaType.
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            dw, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    FindSampleRate(pMediaType),
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }
            }
        }
        MSPDeleteMediaType(pMediaType);
    }

    return S_OK;
}


HRESULT CStreamAudioRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the mixer to the audio render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv.ConnectTerminal, pITTerminal %p", pITTerminal));

    HRESULT hr;

    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            E_NOINTERFACE, 
            pITTerminal
            );
        
        return E_NOINTERFACE;
    }

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    // Get the pins.
    hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        return hr;
    }

    // the pin count should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return E_POINTER;
        }
    }

    // create filters and connect to the audio render terminal.
    hr = SetUpInternalFilters(Pins, dwNumPins);

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        CleanUpFilters();

        return hr;
    }
    
    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamAudioRecv::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

    If it is the capture terminal being disconnected, all the pins that the 
    stream cached need to be released too. 

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioRecv::DisconnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    HRESULT hr = CIPConfMSPStream::DisconnectTerminal(pITTerminal);

    CleanUpFilters();

    return hr;
}

HRESULT CStreamAudioRecv::AddOneMixChannel(
    IN  IBaseFilter* pSourceFilter,
    IN  IPin *pPin,
    IN  DWORD dwChannelNumber
    )
{
    ENTER_FUNCTION("AudioRecv::AddDecoder");
    LOG((MSP_TRACE, "%s enters", __fxName));

    CComPtr<IBaseFilter> pDecoderFilter;

    HRESULT hr;
    if (FAILED(hr = ::AddFilter(
        m_pIGraphBuilder,
        __uuidof(TAPIAudioDecoder), 
        L"Decoder", 
        &pDecoderFilter
        )))
    {
        LOG((MSP_ERROR, "%s add Codec filter. %x", __fxName, hr));
        return hr;
    }

#ifdef DYNGRAPH
	CComPtr <IGraphConfig> pIGraphConfig;

    hr = m_pIGraphBuilder->QueryInterface(
        __uuidof(IGraphConfig), 
        (void**)&pIGraphConfig
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s query IGraphConfig failed. hr=%x", __fxName, hr));
        return hr;
    }
    
    // this tell the graph that the filter can be removed during reconnect.
    hr = pIGraphConfig->SetFilterFlags(pDecoderFilter, AM_FILTER_FLAGS_REMOVABLE);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s set filter flag failed. hr=%x", __fxName, hr));
        return hr;
    }

/*  // if there is a plugin codec,this method can be use to add it.
	hr = pIGraphConfig->AddFilterToCache(pDecoderFilter);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, AddFilterToCache failed", __fxName));
        return hr;
    }
*/
#endif

    if (dwChannelNumber == 0)
    {
        // configure the formats for the RTP filter.

        CComPtr<IPin> pIPinInput;
        if (FAILED(hr = ::FindPin(pDecoderFilter, &pIPinInput, PINDIR_INPUT, TRUE)))
        {
            LOG((MSP_ERROR,
                "find input pin on pCodecFilter failed. hr=%x", hr));
            return hr;
        }

        CComPtr<IStreamConfig> pIStreamConfig;

        hr = pIPinInput->QueryInterface(&pIStreamConfig);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, query IStreamConfig failed", __fxName));
            return hr;
        }


        // configure the format info on the RTP filter
        if (FAILED(hr = ConfigureRTPFormats(pSourceFilter, pIStreamConfig)))
        {
            LOG((MSP_ERROR, "%s configure RTP formats. %x", __fxName, hr));
            return hr;
        }

        // give the render filter the full-duplex controller.
        ::ConfigureFullduplexControl(pPin, m_pIAudioDuplexController);

    }

    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        pSourceFilter, 
        pDecoderFilter
        )))
    {
        LOG((MSP_ERROR, "%s connect source and decoder filter. %x", __fxName, hr));
        return hr;
    }

    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        pDecoderFilter, 
        pPin
        )))
    {
        LOG((MSP_ERROR, "%s connect decoder filter and pin. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CStreamAudioRecv::SetUpInternalFilters(
    IN  IPin **ppPins,
    IN  DWORD dwNumPins
    )
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->Demux->RPH(->DECODER)->Mixer

Arguments:

    ppPin - the input pins of the audio render terminal.

    dwNumPins - the number of pins in the array.
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioRecv::SetUpInternalFilters");
    LOG((MSP_TRACE, "%s enters", __fxName));

    CComPtr<IBaseFilter> pSourceFilter;

    HRESULT hr;
    DWORD dw;

    if (m_pIRTPSession == NULL)
    {
        // create and add the source fitler.
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                __uuidof(MSRTPSourceFilter), 
                L"RtpSource", 
                &pSourceFilter)))
        {
            LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
            return hr;
        }

        // configure the address info on the RTP filter.
        if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
        {
            LOG((MSP_ERROR, "%s configure RTP source filter. %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        if (FAILED (hr = m_pIRTPSession->QueryInterface (&pSourceFilter)))
        {
            LOG ((MSP_ERROR, "%s failed to get filter from rtp session. %x", __fxName, hr));
            return hr;
        }

        if (FAILED (hr = m_pIGraphBuilder->AddFilter ((IBaseFilter *)pSourceFilter, L"RtpSource")))
        {
            LOG ((MSP_ERROR, "%s failed to add filter to graph. %x", __fxName, hr));
            return hr;
        }
    }

    // get the Demux interface pointer.
    CComPtr<IRtpDemux> pIRtpDemux;
    hr = pSourceFilter->QueryInterface(&pIRtpDemux);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s query IRtpDemux failed. %x", __fxName, hr));
        return hr;
    }

    // set the number of output pins we need.
    hr = pIRtpDemux->SetPinCount(MAX_MIX_CHANNELS, RTPDMXMODE_AUTO);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s SetPinCount failed. %x", __fxName, hr));
        return hr;
    }

    // if the render handles multichannel, use it.
    if (dwNumPins > 1)
    {
        for (dw = 0; dw < min(dwNumPins, MAX_MIX_CHANNELS); dw ++)
        {
            hr = AddOneMixChannel(pSourceFilter, ppPins[dw], dw);
            if (FAILED(hr))
            {
                break;
            }
        }
        return hr;
    }

    //if the render filter can't handle multichannel, insert a mixer;
    CComPtr<IBaseFilter> pMixer;
    if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            __uuidof(TAPIAudioMixer), 
            L"AudioMixer", 
            &pMixer)))
    {
        LOG((MSP_ERROR, "%s, adding audio Mixer filter. %x", __fxName, hr));
        return hr;
    }

    // Get the enumerator of pins on the mixer filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pMixer->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "%s, enum pins on the Mixer filter. %x", __fxName, hr));
        return hr;
    }

    DWORD dwFetched;
    IPin * MixerPins[MAX_MIX_CHANNELS];
    hr = pIEnumPins->Next(MAX_MIX_CHANNELS, MixerPins, &dwFetched);
    
    if (FAILED(hr) || dwFetched == 0)
    {
        LOG((MSP_ERROR, "%s, find pin on filter. %x", __fxName, hr));
        return E_FAIL;
    }

    // add the decoding channels.
    for (dw = 0; dw < dwFetched; dw ++)
    {
        hr = AddOneMixChannel(pSourceFilter, MixerPins[dw], dw);

        if (FAILED(hr))
        {
            break;
        }
    }
    
    // release the refcounts on the pins.
    for (dw = 0; dw < dwFetched; dw ++)
    {
        MixerPins[dw]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, add mix channel failed %x", __fxName, hr));
        return hr;
    }

    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        pMixer, 
        ppPins[0]
        )))
    {
        LOG((MSP_ERROR, "%s connect mixer filter and pin. %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioRecv SetupFilters entered."));
    HRESULT hr;

    // we only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    // Connect the mixer to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the mixer filter to terminal. %x", hr));

        return hr;
    }
    return hr;
}

HRESULT CStreamAudioRecv::ProcessTalkingEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    a SSRC is active, file a participant active event.

Arguments:

    dwSSRC - the SSRC of the participant.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Processes pin mapped event, pIPin: %p", m_szName, dwSSRC));
    
    CLock lock(m_lock);

    ITParticipant * pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
        }
    }

    // if the participant is not there yet, put the event in a queue and it
    // will be fired when we have the CName fo the participant.
    if (!pITParticipant)
    {
        LOG((MSP_INFO, "can't find a participant that has SSRC %x", dwSSRC));

        m_PendingSSRCs.Add(dwSSRC);
        
        LOG((MSP_INFO, "added the event to pending list, new list size:%d", 
            m_PendingSSRCs.GetSize()));

        return S_OK;
    }
   
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_ACTIVE, 
        pITParticipant
        );

    return S_OK;
}

HRESULT CStreamAudioRecv::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
/*++

Routine Description:

    A mapped event happended when we didn't have the participant's name so
    it was queued in a list. Now that we have a new participant, let's check
    if this is the same participant. If it is, we complete the mapped event
    by sending the app an notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Check pending mapped event, dwSSRC: %x", m_szName, dwSSRC));
    
    // look at the pending SSRC list and find out if this report
    // fits in the list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    if (i < 0)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));
        return S_OK;
    }
    
    // get rid of the peding SSRC.
    m_PendingSSRCs.RemoveAt(i);

    // complete the event.
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_ACTIVE, 
        pITParticipant
        );

    return S_OK;
}

HRESULT CStreamAudioRecv::ProcessWasTalkingEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    A SSRC just got unmapped by the demux. Notify the app that a participant
    becomes inactive.

Arguments:

    dwSSRC - the SSRC of the participant.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Processes SSRC unmapped event, pIPin: %p", m_szName, dwSSRC));
    
    CLock lock(m_lock);

    // look at the pending SSRC list and find out if it is in the pending list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    // if the SSRC is in the pending list, just remove it.
    if (i >= 0)
    {
        m_PendingSSRCs.RemoveAt(i);
        return S_OK;
    }

    ITParticipant *pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
        }
    }

    if (pITParticipant)
    {
        // fire an event to tell the app that the participant is inactive.
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_PARTICIPANT_INACTIVE, 
            pITParticipant
            );
    }
    return S_OK;
}

HRESULT CStreamAudioRecv::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessParticipantLeave, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    // look at the pending SSRC list and find out if it is in the pending list.
    int i = m_PendingSSRCs.Find(dwSSRC);

    // if the SSRC is in the pending list, remove it.
    if (i >= 0)
    {
        m_PendingSSRCs.RemoveAt(i);
    }

    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        pParticipant = (CParticipant *)m_Participants[i];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "%ws, can't find the SSRC %x", m_szName, dwSSRC));

        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[i];

    // fire an event to tell the app that the participant is in active.
    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_PARTICIPANT_INACTIVE, 
        pITParticipant
        );

    m_Participants.RemoveAt(i);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    pITParticipant->Release();

    return S_OK;
}

HRESULT CStreamAudioRecv::ShutDown()
/*++

Routine Description:

    Shut down the stream. Release our members and then calls the base class's
    ShutDown method.

Arguments:
    

Return Value:

S_OK
--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioRecv::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}


/////////////////////////////////////////////////////////////////////////////
//
//  CStreamAudioSend
//
/////////////////////////////////////////////////////////////////////////////

CStreamAudioSend::CStreamAudioSend()
    : CIPConfMSPStream(),
    m_pIStreamConfig(NULL),
    m_pAudioInputMixer(NULL),
    m_pSilenceControl(NULL),
    m_pAudioDeviceControl(NULL),
    m_pCaptureBitrateControl(NULL),
    m_pEncoder(NULL),
    m_pIAudioDuplexController(NULL),
    m_lAutomaticGainControl(DEFUAT_AGC_STATUS),
    m_lAcousticEchoCancellation(DEFUAT_AEC_STATUS)
{
      m_szName = L"AudioSend";
}

CStreamAudioSend::~CStreamAudioSend()
{
    CleanupCachedInterface();
}

// this method is called by the call object at init time.
void CStreamAudioSend::SetFullDuplexController(
    IN IAudioDuplexController *pIAudioDuplexController
    )
{
    _ASSERT(pIAudioDuplexController);
    _ASSERT(m_pIAudioDuplexController == NULL);

    pIAudioDuplexController->AddRef();
    m_pIAudioDuplexController = pIAudioDuplexController;
}

void CStreamAudioSend::CleanupCachedInterface()
{
    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    if (m_pSilenceControl) 
    {
        m_pSilenceControl->Release();
        m_pSilenceControl = NULL;
    }

    if (m_pCaptureBitrateControl) 
    {
        m_pCaptureBitrateControl->Release();
        m_pCaptureBitrateControl = NULL;
    }

    if (m_pAudioInputMixer) 
    {
        m_pAudioInputMixer->Release();
        m_pAudioInputMixer = NULL;
    }

    if (m_pAudioDeviceControl) 
    {
        m_pAudioDeviceControl->Release();
        m_pAudioDeviceControl = NULL;
    }

    if (m_pEncoder) 
    {
        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->Release();
        m_pIAudioDuplexController = NULL;
    }
}


HRESULT CStreamAudioSend::ShutDown()
/*++

Routine Description:

    Shut down the stream. Release our members and then calls the base class's
    ShutDown method.

Arguments:
    

Return Value:

S_OK
--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioSend::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    CleanupCachedInterface();

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}

HRESULT CStreamAudioSend::CacheAdditionalInterfaces(
    IN  IPin *                 pIPin
    )
{
    ENTER_FUNCTION("CStreamAudioSend::CacheAdditionalInterfaces");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    _ASSERT(m_pIStreamConfig == NULL);
    hr = pIPin->QueryInterface(&m_pIStreamConfig);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "%s, query IStreamConfig failed", __fxName));

        // this is a required interface.
        return hr;
    }

    // get the SilenceControl interface from the pin.
    _ASSERT(m_pSilenceControl == NULL);
    hr = pIPin->QueryInterface(&m_pSilenceControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's ISilenceControl failed, hr=%x", 
            __fxName, hr));

        // this is a required interface.
        return hr;
    }

    // get the BitrateControl interface.
    _ASSERT(m_pCaptureBitrateControl == NULL);
    hr = pIPin->QueryInterface(&m_pCaptureBitrateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's BitrateControl failed, hr=%x", 
            __fxName, hr));
    }

    // find the filter behind the pin.
    PIN_INFO PinInfo;
    if (SUCCEEDED(hr = pIPin->QueryPinInfo(&PinInfo)))
    {
        // get the AudioInputMixer interface.
        _ASSERT(m_pAudioInputMixer == NULL);
        hr = PinInfo.pFilter->QueryInterface(&m_pAudioInputMixer);
        if (FAILED(hr))
        {
            LOG((MSP_WARN, 
                "%s:query capture filter's IAMAudioInputMixer failed, hr=%x", 
                __fxName, hr));

        }

        // get the AudioDeviceControl interface.
        _ASSERT(m_pAudioDeviceControl == NULL);
        hr = PinInfo.pFilter->QueryInterface(&m_pAudioDeviceControl);
        PinInfo.pFilter->Release();

        if (FAILED(hr))
        {
            LOG((MSP_WARN, 
                "%s:query capture filter's AudioDeviceControl failed, hr=%x", 
                __fxName, hr));
        }
        else
        {
            hr = m_pAudioDeviceControl->Set(
                AudioDevice_AutomaticGainControl, 
                m_lAutomaticGainControl, 
                TAPIControl_Flags_None
                );
        
            if (FAILED(hr))
            {
                LOG((MSP_WARN, 
                    "%s:set AGC failed, hr=%x", 
                    __fxName, hr));
            }

            hr = m_pAudioDeviceControl->Set(
                AudioDevice_AcousticEchoCancellation, 
                m_lAcousticEchoCancellation, 
                TAPIControl_Flags_None
                );

            if (FAILED(hr))
            {
                LOG((MSP_WARN, 
                    "%s:set AEC failed, hr=%x", 
                    __fxName, hr));
            }
        }

    }
    else
    {
        LOG((MSP_ERROR, 
            "%s:can't get the capture filter, hr=%x", 
            __fxName, hr));
    }

    return S_OK;
}

HRESULT CStreamAudioSend::GetAudioCapturePin(
    IN      ITTerminalControl *     pTerminal,
    OUT     IPin **                 ppIPin
    )
/*++

Routine Description:

    This function gets a output pin from the capture terminal.

Arguments:
    
    pTerminal - An audio capture terminal.

    ppIPin - the address to hold the returned pointer to IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AudioSend configure audio capture terminal."));

    DWORD       dwNumPins   = 1;
    IPin *      Pins[1];

    // Get the pins from the terminal
    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_CAPTURE, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    // This stream needs only one pin from the terminal.
    _ASSERT(dwNumPins == 1);

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));
        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));
            return E_POINTER;
        }
    }

    // this pin carries a refcount
    *ppIPin = Pins[0];

    return hr;
}

HRESULT CStreamAudioSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the audio capture terminal to the stream.

Arguments:

    pITTerminal - The terminal to be connected.
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioSend::ConnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "%s, can't get Terminal Control interface", __fxName));
        
        SendStreamEvent(
            CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE,
            E_NOINTERFACE, 
            pITTerminal
            );

        return E_NOINTERFACE;
    }

    // find the output pin of the terminal.
    CComPtr<IPin>   pCaptureOutputPin;
    HRESULT hr = GetAudioCapturePin(pTerminal, &pCaptureOutputPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, configure audio capture termianl failed. %x", __fxName, hr));

        SendStreamEvent(
            CALL_TERMINAL_FAIL,
            CALL_CAUSE_BAD_DEVICE,
            hr, 
            pITTerminal
            );
        
        return hr;
    }

    CComPtr<IPin> PinToUse;

    hr = CacheAdditionalInterfaces(pCaptureOutputPin);

    if (SUCCEEDED(hr))
    {
        PinToUse = pCaptureOutputPin;

        // give the filter the full-duplex controller.
        ::ConfigureFullduplexControl(pCaptureOutputPin, m_pIAudioDuplexController);
    }
    else if (hr == E_NOINTERFACE)
    {
        // the capture filter doesn't support the needed interfaces.
        // we need to add our encoder here.
        
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                __uuidof(TAPIAudioEncoder), 
                L"AudioEncoder", 
                &m_pEncoder)))
        {
            LOG((MSP_ERROR, "%s, adding Encoder filter. %x", __fxName, hr));
            goto cleanup;
        }

        // This is a hack for legacy terminals. We have to tell the terminal what
        // format to use
        const WORD wBitsPerSample = 16;   // 16 bits samples.
        const DWORD dwSampleRate = 8000;  // 8KHz.
        hr = ::SetAudioFormat(
            pCaptureOutputPin, 
            wBitsPerSample, 
            dwSampleRate
            );

        if (FAILED(hr))
        {
            LOG((MSP_WARN, "%s, can't set format. %x", __fxName, hr));
        }
           

        // This is a hack for legacy terminals. We have to tell the terminal what
        // buffer size to allocate.
        const DWORD dwNumBuffers = 4;    // 4 buffers in the allocator.
        const DWORD dwBufferSize = 480;  // 30ms samples in each buffer.
        hr = ::SetAudioBufferSize(pCaptureOutputPin, dwNumBuffers, dwBufferSize);

        if (FAILED(hr))
        {
            LOG((MSP_WARN, 
                "%s, can't suggest allocator properties. %x", __fxName, hr));
        }
           
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IPin *)pCaptureOutputPin, 
            (IBaseFilter *)m_pEncoder
            )))
        {
            LOG((MSP_ERROR, 
                "%s, connect audio capture filter and encoder filter. %x", 
                __fxName, hr));
            goto cleanup;
        }

        CComPtr<IPin> pEncoderOutputPin;
        if (FAILED(hr = ::FindPin(
            m_pEncoder, &pEncoderOutputPin, PINDIR_OUTPUT, TRUE)))
        {
            LOG((MSP_ERROR,
                "%s, find input pin on pCodecFilter failed. hr=%x", 
                __fxName, hr));
            goto cleanup;
        }

        PinToUse = pEncoderOutputPin;

        hr = CacheAdditionalInterfaces(pEncoderOutputPin);

        _ASSERT(SUCCEEDED(hr));
    }
    else
    {
        LOG((MSP_ERROR, "%s, can't add codec to table. %x", __fxName, hr));
        
        goto cleanup;
    }

        // Create other filters to be use in the stream.
    hr = CreateSendFilters(PinToUse);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create audio send filters failed. %x", hr));

        goto cleanup;
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;

cleanup:

    CleanupCachedInterface();

    // clean up internal filters as well.
    CleanUpFilters();

    SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

    pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

    if (m_pEncoder) 
    {
        m_pIGraphBuilder->RemoveFilter(m_pEncoder);

        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

    return hr;
}

HRESULT CStreamAudioSend::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

    If it is the capture terminal being disconnected, all the pins that the 
    stream cached need to be released too. 

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::DisconnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    HRESULT hr = CIPConfMSPStream::DisconnectTerminal(pITTerminal);

    // release all the capture pins we cached.
    CleanupCachedInterface();

    CleanUpFilters();

    if (m_pEncoder) 
    {
        m_pIGraphBuilder->RemoveFilter(m_pEncoder);

        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

    return hr;
}
HRESULT CStreamAudioSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "AudioSend SetUpFilters"));

    // only support one terminal for this stream.
    if (m_Terminals.GetSize() != 1)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr;

    // Connect the terminal to the rest of the stream.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[0]
        )))
    {
        LOG((MSP_ERROR, "connect the terminal to the filters. %x", hr));

        return hr;
    }
    return hr;
}

HRESULT ConfigurePacketSize(
    IN const AM_MEDIA_TYPE *pMediaType, 
    IN DWORD dwMSPerPacket
    )
{
    WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;
    ASSERT(pWaveFormatEx != NULL);

    switch (pWaveFormatEx->wFormatTag)
    {
    case WAVE_FORMAT_ALAW:
    case WAVE_FORMAT_MULAW:
        _ASSERT(pMediaType->cbFormat >= sizeof(WAVEFORMATEX_RTPG711));
        
        ((WAVEFORMATEX_RTPG711 *)pWaveFormatEx)->wPacketDuration = (WORD)dwMSPerPacket;
        
        break;

    case WAVE_FORMAT_DVI_ADPCM:
        _ASSERT(pMediaType->cbFormat >= sizeof(WAVEFORMATEX_RTPDVI4));

        ((WAVEFORMATEX_RTPDVI4 *)pWaveFormatEx)->wPacketDuration = (WORD)dwMSPerPacket;

        break;

    case WAVE_FORMAT_GSM610:
        _ASSERT(pMediaType->cbFormat >= sizeof(WAVEFORMATEX_RTPGSM));

        ((WAVEFORMATEX_RTPGSM *)pWaveFormatEx)->wPacketDuration = (WORD)dwMSPerPacket;

        break;
    }

    return S_OK;
}

HRESULT CStreamAudioSend::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("AudioSend::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL bFound = FALSE;
    for (DWORD dw = 0; dw < dwCount; dw ++)
    {
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            dw, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                if (dw2 == 0)
                {
                // tell the encoder to use this format.
                // TODO, cache all the allowed mediatypes in the conference for
                // future enumerations. It would be nice that we can get the SDP blob
                // when the call object is created.

                    if (m_Settings.dwMSPerPacket)
                    {
                        hr = ConfigurePacketSize(pMediaType, m_Settings.dwMSPerPacket);
                        if (FAILED(hr))
                        {
                            MSPDeleteMediaType(pMediaType);

                            LOG((MSP_ERROR, "%s ConfigurePacketSize. hr=%x", __fxName, hr));
                            return hr;
                        }
                    }
                }

                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    FindSampleRate(pMediaType),
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }

                if (dw2 == 0)
                {
                    hr = pIStreamConfig->SetFormat(dwPayloadType, pMediaType);
                    if (FAILED(hr))
                    {
                        MSPDeleteMediaType(pMediaType);

                        LOG((MSP_ERROR, "%s SetFormat. %x", __fxName, hr));
                        return hr;
                    }
                }
            }
        }
        MSPDeleteMediaType(pMediaType);
    }

    return S_OK;
}

HRESULT CStreamAudioSend::CreateSendFilters(
    IN    IPin          *pPin
    )
/*++

Routine Description:

    Insert filters into the graph and connect to the capture pin.

    Capturepin->RTPRender

Arguments:
    
    pPin - The output pin on the capture filter.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::CreateSendFilters");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    // Create the RTP render filter and add it into the graph.
    CComPtr<IBaseFilter> pRenderFilter;

    if (m_pIRTPSession == NULL)
    {
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                __uuidof(MSRTPRenderFilter), 
                L"RtpRender", 
                &pRenderFilter)))
        {
            LOG((MSP_ERROR, "%s, adding render filter. %x", __fxName, hr));
            return hr;
        }

        // Set the address for the render fitler.
        if (FAILED(hr = ConfigureRTPFilter(pRenderFilter)))
        {
            LOG((MSP_ERROR, "%s, set destination address. %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        if (FAILED (hr = m_pIRTPSession->QueryInterface (&pRenderFilter)))
        {
            LOG ((MSP_ERROR, "%s failed to get filter from rtp session. %x", __fxName, hr));
            return hr;
        }

        if (FAILED (hr = m_pIGraphBuilder->AddFilter ((IBaseFilter *)pRenderFilter, L"RtpRender")))
        {
            LOG ((MSP_ERROR, "%s failed to add filter to graph. %x", __fxName, hr));
            return hr;
        }
    }

    _ASSERT(m_pIStreamConfig != NULL);

    // configure the format info on the RTP filter
    if (FAILED(hr = ConfigureRTPFormats(pRenderFilter, m_pIStreamConfig)))
    {
        LOG((MSP_ERROR, "%s, configure RTP formats. %x", __fxName, hr));
        return hr;
    }

        // Connect the capture filter with the RTP Render filter.
    if (FAILED(hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IPin *)pPin, 
        (IBaseFilter *)pRenderFilter
        )))
    {
        LOG((MSP_ERROR, 
            "%s, connect audio capture filter and RTP Render filter. %x",
            __fxName, hr));
        return hr;
    }

    return S_OK;
}

HRESULT CStreamAudioSend::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d", m_szName, lEventCode));

    switch (lEventCode)
    {
    case VAD_EVENTBASE + VAD_SILENCE:
        m_lock.Lock ();
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent (PE_LOCAL_SILENT, NULL);
        m_lock.Unlock ();
        break;

    case VAD_EVENTBASE + VAD_TALKING:
        m_lock.Lock ();
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent (PE_LOCAL_TALKING, NULL);
        m_lock.Unlock ();
        break;

    default:
        return CIPConfMSPStream::ProcessGraphEvent(
            lEventCode, lParam1, lParam2
            );
    }

    return S_OK;
}

STDMETHODIMP CStreamAudioSend::GetRange(
    IN  AudioDeviceProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::GetRange(AudioDeviceProperty)");

    if (IsBadWritePtr(plMin, sizeof(long)) || 
        IsBadWritePtr(plMax, sizeof(long)) ||
        IsBadWritePtr(plSteppingDelta, sizeof(long)) ||
        IsBadWritePtr(plDefault, sizeof(long)) ||
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr = E_NOTIMPL;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        break;

    case AudioDevice_AutomaticGainControl:
        *plMin = 0;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = DEFUAT_AGC_STATUS;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    case AudioDevice_AcousticEchoCancellation:
        *plMin = 0;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = DEFUAT_AEC_STATUS;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    default:
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CStreamAudioSend::Get(
    IN  AudioDeviceProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Get(AudioDeviceProperty)");

    if (IsBadWritePtr(plValue, sizeof(long)) || 
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    CLock lock(m_lock);

    HRESULT hr = E_NOTIMPL;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        break;

    case AudioDevice_AutomaticGainControl:
        *plValue = m_lAutomaticGainControl;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    case AudioDevice_AcousticEchoCancellation:
        *plValue = m_lAcousticEchoCancellation;
        *plFlags = TAPIControl_Flags_Auto;
        hr = S_OK;
        break;

    default:
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Set(
    IN  AudioDeviceProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Set(AudioDeviceProperty)");

    CLock lock(m_lock);

    HRESULT hr;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        return E_NOTIMPL;

    case AudioDevice_AutomaticGainControl:
        if (lValue !=0 && lValue != 1)
        {
            return E_INVALIDARG;
        }

        // check if we have the interface to delegate to.
        if (m_pAudioDeviceControl)
        {
            // set the value on the filter.
            hr = m_pAudioDeviceControl->Set(Property, lValue, lFlags);
            if (FAILED(hr))
            {
                return hr;
            }
        }

        m_lAutomaticGainControl = lValue;
        return S_OK;

    case AudioDevice_AcousticEchoCancellation:
        if (lValue !=0 && lValue != 1)
        {
            return E_INVALIDARG;
        }

        // check if we have the interface to delegate to.
        if (m_pAudioDeviceControl)
        {
            // set the value on the filter.
            hr = m_pAudioDeviceControl->Set(Property, lValue, lFlags);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        m_lAcousticEchoCancellation = lValue;
        return S_OK;
    }

    return E_INVALIDARG;
}

STDMETHODIMP CStreamAudioSend::GetRange(
    IN  AudioSettingsProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::GetRange(AudioSettings)");

    if (IsBadWritePtr(plMin, sizeof(long)) || 
        IsBadWritePtr(plMax, sizeof(long)) ||
        IsBadWritePtr(plSteppingDelta, sizeof(long)) ||
        IsBadWritePtr(plDefault, sizeof(long)) ||
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    CLock lock(m_lock);

    HRESULT hr = E_NOINTERFACE;

    switch (Property)
    {
    case AudioSettings_SignalLevel:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the range from the filter.
            hr = m_pSilenceControl->GetAudioLevelRange(plMin, plMax, plSteppingDelta);

            if (SUCCEEDED(hr))
            {
                *plDefault = *plMin;
                *plFlags = TAPIControl_Flags_None;
            }
        }

        break;

    case AudioSettings_SilenceThreshold:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the range from the filter.
            hr = m_pSilenceControl->GetSilenceLevelRange(
                plMin, 
                plMax, 
                plSteppingDelta, 
                plDefault, 
                plFlags
                );
        }
        break;

    case AudioSettings_Volume:

        *plMin = MIN_VOLUME;
        *plMax = MAX_VOLUME;
        *plSteppingDelta = 1;
        *plDefault = *plMin;
        *plFlags = TAPIControl_Flags_Manual;
        hr = S_OK;

        break;

    case AudioSettings_Balance:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Loudness:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Treble:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Bass:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Mono:

        *plMin = 1;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = 1;
        *plFlags = TAPIControl_Flags_Manual;
        hr = S_OK;

        break;

    default:
        hr = E_INVALIDARG;

    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Get(
    IN  AudioSettingsProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Get(AudioSettings)");

    if (IsBadWritePtr(plValue, sizeof(long)) || 
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    CLock lock(m_lock);

    HRESULT hr = E_NOINTERFACE;

    switch (Property)
    {
    case AudioSettings_SignalLevel:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the level from the filter.
            hr = m_pSilenceControl->GetAudioLevel(plValue);

            if (SUCCEEDED(hr))
            {
                *plFlags = TAPIControl_Flags_None;
            }
        }

        break;

    case AudioSettings_SilenceThreshold:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the level from the filter.
            hr = m_pSilenceControl->GetSilenceLevel(
                plValue, 
                plFlags
                );
        }
        break;

    case AudioSettings_Volume:

        if (m_pAudioInputMixer)
        {
            double dVolume;
            hr = m_pAudioInputMixer->get_MixLevel(&dVolume);
            
            if (SUCCEEDED(hr))
            {
                // Convert the volume from the range 0 - 1 to the API's range.
                *plValue = MIN_VOLUME + (long) (( MAX_VOLUME - MIN_VOLUME ) * dVolume);
                *plFlags = TAPIControl_Flags_Manual;
            }
        }

        break;

    case AudioSettings_Balance:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Loudness:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Treble:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Bass:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Mono:

        // we only support MONO for now.
        *plValue = 1;
        *plFlags = TAPIControl_Flags_Manual;
        hr = S_OK;

        break;

    default:
        hr = E_INVALIDARG;

    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Set(
    IN  AudioSettingsProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a audio setting property. Delegated to the capture filter.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Set(AudioSettings)");

    CLock lock(m_lock);

    HRESULT hr = E_NOINTERFACE;

    switch (Property)
    {
    case AudioSettings_SignalLevel:

        // this is a read only property.
        hr = E_FAIL;

        break;

    case AudioSettings_SilenceThreshold:

        // check if we have the interface to delegate to.
        if (m_pSilenceControl)
        {
            // get the range from the filter.
            hr = m_pSilenceControl->SetSilenceLevel(
                lValue, 
                lFlags
                );
        }
        break;

    case AudioSettings_Volume:

        if (m_pAudioInputMixer)
        {
            // Convert to the range 0 to 1.
            double dVolume = (lValue - MIN_VOLUME ) 
                    / ((double)(MAX_VOLUME - MIN_VOLUME));

            hr = m_pAudioInputMixer->put_MixLevel(dVolume);
        }
        
        break;

    case AudioSettings_Balance:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Loudness:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Treble:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Bass:

        hr = E_NOTIMPL;

        break;

    case AudioSettings_Mono:

        // we only support MONO for now.
        if (lValue == 1)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }

        break;

    default:
        hr = E_INVALIDARG;

    }

    return hr;
}

//
// ITStreamQualityControl methods
//
STDMETHODIMP CStreamAudioSend::Set (
    IN   StreamQualityProperty Property, 
    IN   long lValue, 
    IN   TAPIControlFlags lFlags
    )
{
    return E_NOTIMPL;
}

//    
// IInnerStreamQualityControl methods.
//
STDMETHODIMP CStreamAudioSend::GetRange(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plMin, 
    OUT LONG *plMax, 
    OUT LONG *plSteppingDelta, 
    OUT LONG *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a quality control property. Delegated to capture filter
    for now.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::GetRange (InnerStreamQualityControl)");

    HRESULT hr;
    static BOOL fReported = FALSE;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MaxBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->GetRange(
                BitrateControl_Maximum, plMin, plMax, plSteppingDelta, plDefault, plFlags, LAYERID
                );
        }

        break;

    case InnerStreamQuality_CurrBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->GetRange(
                BitrateControl_Current, plMin, plMax, plSteppingDelta, plDefault, plFlags, LAYERID
                );
        }

        break;

    default:
        hr = CIPConfMSPStream::GetRange (property, plMin, plMax, plSteppingDelta, plDefault, plFlags);
        break;
    }

    return hr;
}

STDMETHODIMP CStreamAudioSend::Get(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a quality control property. Delegated to the quality 
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamAudioSend::Get(QualityControl)");

    HRESULT hr;
    static BOOL fReported = FALSE;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MaxBitrate:

        if( m_pCaptureBitrateControl == NULL )
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->Get(BitrateControl_Maximum, plValue, plFlags, LAYERID);
        }

        break;

    case InnerStreamQuality_CurrBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->Get(BitrateControl_Current, plValue, plFlags, LAYERID);
        }
        break;

    default:
        hr = CIPConfMSPStream::Get (property, plValue, plFlags);
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confaudt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: IPConfaudt.h
//
// Description: Definition of the CIPConfAudioCaptureTerminal class and 
//     CIPConfAudioRenderTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IPConfAUDT_H_
#define _IPConfAUDT_H_

// the volume range for the API.
const long  MIN_VOLUME    = 0;      
const long  MAX_VOLUME    = 0xFFFF;

const long  BALANCE_LEFT  = -100;
const long  BALANCE_RIGHT = 100;

const long  BOOST_FACTOR = 100;

// the volume range of the IAMInputMixer
const double MIXER_MIN_VOLUME = 0.0;
const double MIXER_MAX_VOLUME = 1.0;


/////////////////////////////////////////////////////////////////////////////
// CIPConfAudioCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD AUDIO_CAPTURE_FILTER_NUMPINS = 1;

class CIPConfAudioCaptureTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &__uuidof(ITBasicAudioTerminal), &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &__uuidof(ITStaticAudioTerminal), &LIBID_TAPI3Lib>, 
    public CIPConfBaseTerminal
{

BEGIN_COM_MAP(CIPConfAudioCaptureTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfBaseTerminal)
END_COM_MAP()

public:
    CIPConfAudioCaptureTerminal();

    virtual ~CIPConfAudioCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    // ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

    // ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IAMAudioInputMixer *    m_pIAMAudioInputMixer;
};

/////////////////////////////////////////////////////////////////////////////
// CIPConfAudioRenderTerminal
/////////////////////////////////////////////////////////////////////////////

const DWORD AUDIO_RENDER_FILTER_NUMPINS = 5;

class CIPConfAudioRenderTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &__uuidof(ITBasicAudioTerminal), &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &__uuidof(ITStaticAudioTerminal), &LIBID_TAPI3Lib>, 
    public CIPConfBaseTerminal
{

BEGIN_COM_MAP(CIPConfAudioRenderTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfBaseTerminal)
END_COM_MAP()

public:
    CIPConfAudioRenderTerminal();

    virtual ~CIPConfAudioRenderTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    // ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

    // ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_RENDER_FILTER_NUMPINS;
    }

    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );
protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IBasicAudio *           m_pIBasicAudio;
};

#endif // _IPConfAUDT_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confcall.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confcall.cpp 

Abstract:

    This module contains implementation of CIPConfMSPCall.

Author:
    
    Mu Han (muhan)   5-September-1998

--*/
#include "stdafx.h"
#include <confpdu.h>

CIPConfMSPCall::CIPConfMSPCall()
    : m_fLocalInfoRetrieved(FALSE),
    m_fShutDown(FALSE),
    m_dwIPInterface(INADDR_ANY),
    m_LoopbackMode(MM_NO_LOOPBACK),
    m_hAudioRTPSession(NULL),
    m_hVideoRTPSession(NULL),
    m_pIAudioDuplexController(NULL),
    m_fCallStarted(FALSE),
    m_pApplicationID(NULL),
    m_pApplicationGUID(NULL),
    m_pSubIDs(NULL),
    m_pCallQCRelay(NULL)
{
    ZeroMemory(m_InfoItems, sizeof(m_InfoItems));
}

CIPConfMSPCall::~CIPConfMSPCall()
{
    if (m_pApplicationID)
    {
        SysFreeString(m_pApplicationID);
    }

    if (m_pApplicationGUID)
    {
        SysFreeString(m_pApplicationGUID);
    }

    if (m_pSubIDs)
    {
        SysFreeString(m_pSubIDs);
    }

    if (m_pCallQCRelay)
    {
        delete m_pCallQCRelay;
    }
}

STDMETHODIMP CIPConfMSPCall::CreateStream(
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
{
    // This MSP doesn't support creating new streams on the fly.
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CIPConfMSPCall::RemoveStream(
    IN      ITStream *          pStream
    )
{
    // This MSP doesn't support removing streams either.
    return TAPI_E_NOTSUPPORTED;
}

HRESULT CIPConfMSPCall::InitializeLocalParticipant()
/*++

Routine Description:

    This function uses the RTP filter to find out the local information that
    will be used in the call. The infomation is stored in a local participant 
    object.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    m_fLocalInfoRetrieved = FALSE;

    // Create the RTP fitler.
    IRtpSession *pIRtpSession;

    HRESULT hr = CoCreateInstance(
            __uuidof(MSRTPSourceFilter),
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            __uuidof(IRtpSession),
            (void **) &pIRtpSession
            );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't create RTP filter for local info. %x", hr));
        return hr;
    }

    // Get the available local SDES info from the filter.
    WCHAR Buffer[MAX_PARTICIPANT_TYPED_INFO_LENGTH + 1];

    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        DWORD dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH;
        
        hr = pIRtpSession->GetSdesInfo(
            RTPSDES_CNAME + i,
            Buffer,
            &dwLen,
            0           // local participant
            );
        
        if (SUCCEEDED(hr) && dwLen > 0)
        {
            _ASSERT(dwLen <= MAX_PARTICIPANT_TYPED_INFO_LENGTH);

            // allocate memory to store the string.
            m_InfoItems[i] = (WCHAR *)malloc((dwLen) * sizeof(WCHAR));
            if (m_InfoItems[i] == NULL)
            {
                LOG((MSP_ERROR, "out of mem for local info"));

                pIRtpSession->Release();
                return E_OUTOFMEMORY;
            }
    
            lstrcpynW(m_InfoItems[i], Buffer, dwLen);
        }
    }

    pIRtpSession->Release();

    m_fLocalInfoRetrieved = TRUE;

    return S_OK;
}


HRESULT CIPConfMSPCall::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
/*++

Routine Description:

    This method is called when the call is first created. It sets
    up the streams based on the mediatype specified.

Arguments:
    
    pMSPAddress - The pointer to the address object.

    htCall      - The handle to the Call in TAPI's space. 
                    Used in sending events.

    dwReserved  - Reserved.

    dwMediaType - The media type of this call.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "IPConfMSP call %x initialize entered,"
        " pMSPAddress:%x, htCall %x, dwMediaType %x",
        this, pMSPAddress, htCall, dwMediaType
        ));

#ifdef DEBUG_REFCOUNT
    if (g_lStreamObjects != 0)
    {
        LOG((MSP_ERROR, "Number of Streams alive: %d", g_lStreamObjects));
//        DebugBreak();
    }
#endif

    // initialize the participant array so that the array is not NULL.
    if (!m_Participants.Grow())
    {
        LOG((MSP_ERROR, "out of mem for participant list"));
        return E_OUTOFMEMORY;
    }

    // Call the base class's init.
    HRESULT hr= CMSPCallMultiGraph::Init(
        pMSPAddress, 
        htCall, 
        dwReserved, 
        dwMediaType
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "MSPCallMultiGraph init failed:%x", hr));
        return hr;
    }

    // create the quality control relay for this call.
    m_pCallQCRelay = new CCallQualityControlRelay ();
    if (NULL == m_pCallQCRelay)
    {
        LOG((MSP_ERROR, "call init: failed to create call quality control relay:%x", hr));
        return E_OUTOFMEMORY;
    }

    // initialize qc relay, a thread will be started
    if (FAILED (hr = m_pCallQCRelay->Initialize (this)))
    {
        LOG ((MSP_ERROR, "call init: failed to initialize qc relay. %x", hr));
        return hr;
    }

    // create streams based on the media types.
    if (dwMediaType & TAPIMEDIATYPE_AUDIO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_AUDIO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create audio capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }

    if (dwMediaType & TAPIMEDIATYPE_VIDEO)
    {
        ITStream * pStream;

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_RENDER, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video render stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();

        // create a stream object.
        hr = InternalCreateStream(TAPIMEDIATYPE_VIDEO, TD_CAPTURE, &pStream);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "create video capture stream failed:%x", hr));
            return hr;
        }

        // The stream is already in our array, we don't need this pointer.
        pStream->Release();
    }
    
    DWORD dwLoopback = 0;
    if (TRUE == ::GetRegValue(gszMSPLoopback, &dwLoopback) && dwLoopback != 0)
    {
        m_LoopbackMode = MULTICAST_LOOPBACK_MODE(dwLoopback);
    }

    m_fShutDown = FALSE;
    
    return S_OK;
}

HRESULT CIPConfMSPCall::ShutDown()
/*++

Routine Description:

    Shutdown the call. 

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    InternalShutDown();

    // acquire the lock on call.
    m_lock.Lock();

    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        if (m_InfoItems[i])
        {
            free(m_InfoItems[i]);
            m_InfoItems[i] = NULL;
        }
    }

    m_lock.Unlock();

    return S_OK;
}

HRESULT CIPConfMSPCall::InternalShutDown()
/*++

Routine Description:

    First call the base class's shutdown and then release all the participant
    objects.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "ConfMSPCall.InternalShutdown, entered"));

    // acquire the lock on the call.
    m_lock.Lock();

    if (m_fShutDown)
    {
        LOG((MSP_TRACE, "ConfMSPCall::InterShutdown, already shutdown"));
        m_lock.Unlock ();
        return S_OK;
    }

    m_fShutDown = TRUE;

    if (m_pCallQCRelay)    
    {
        m_pCallQCRelay->Shutdown ();
    }

	int i;

    // Shutdown all the streams
    for (i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        UnregisterWaitEvent(i);
        ((CMSPStream*)m_Streams[i])->ShutDown();
    }
    m_ThreadPoolWaitBlocks.RemoveAll();

    // release all the streams
    for (i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();

    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->Release();
        m_pIAudioDuplexController = NULL;	
    }

    m_lock.Unlock();

    // release all the participants
    m_ParticipantLock.Lock();

    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        m_Participants[i]->Release();
    }
    m_Participants.RemoveAll();

    m_ParticipantLock.Unlock();

    return S_OK;
}

template <class T>
HRESULT CreateStreamHelper(
    IN      T *                     pT,
    IN      HANDLE                  hAddress,
    IN      CIPConfMSPCall*         pMSPCall,
    IN      IMediaEvent *           pGraph,
    IN      DWORD                   dwMediaType,
    IN      TERMINAL_DIRECTION      Direction,
    OUT     ITStream **             ppITStream
    )
/*++

Routine Description:

    Create a stream object and initialize it. This method is called internally
    to create a stream object of different class.

Arguments:
    
    hAddress    - the handle to the address object.

    pCall       - the call object.

    pGraph      - the filter graph for this stream.

    dwMediaType - the media type of the stream. 

    Direction   - the direction of the steam.
    
    ppITStream  - the interface on this stream object.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CreateStreamHelper");

    CComObject<T> * pCOMMSPStream;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCOMMSPStream);

    if (NULL == pCOMMSPStream)
    {
        LOG((MSP_ERROR, "CreateMSPStream:could not create stream:%x", hr));
        return hr;
    }

    // get the interface pointer.
    hr = pCOMMSPStream->_InternalQueryInterface(
        __uuidof(ITStream), 
        (void **)ppITStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:QueryInterface failed: %x", hr));
        delete pCOMMSPStream;
        return hr;
    }

    // Initialize the object.
    hr = pCOMMSPStream->Init(
        hAddress,
        pMSPCall, 
        pGraph,
        dwMediaType,
        Direction
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPStream:call init failed: %x", hr));
        (*ppITStream)->Release();
        return hr;
    }

    // retrieve inner call quality control
    IInnerCallQualityControl * pIInnerCallQC;

    if (FAILED (hr = pMSPCall->_InternalQueryInterface (
        __uuidof (IInnerCallQualityControl),
        (void **)&pIInnerCallQC
        )))
    {
        LOG ((MSP_ERROR, "%s failed to retrieve inner call qc relay: %x", __fxName, hr));
        (*ppITStream)->Release ();
        return hr;
    }

    // retrieve inner stream quality control
    IInnerStreamQualityControl *pIInnerStreamQC;

    if (FAILED (hr = (*ppITStream)->QueryInterface (
        __uuidof (IInnerStreamQualityControl),
        (void **)&pIInnerStreamQC
        )))
    {
        LOG ((MSP_ERROR, "%s failed to retrieve inner stream qc relay: %x", __fxName, hr));
        pIInnerCallQC->Release ();
        (*ppITStream)->Release ();
        return hr;
    }

    // store inner call qc
    if (FAILED (hr = pIInnerStreamQC->LinkInnerCallQC (pIInnerCallQC)))
    {
        LOG ((MSP_ERROR, "%s failed to setup inner call qc on stream, %x", __fxName, hr));

        pIInnerCallQC->Release ();
        pIInnerStreamQC->Release ();
        (*ppITStream)->Release ();
        return hr;
    }

    // register inner stream qc on the call
    hr = pIInnerCallQC->RegisterInnerStreamQC (pIInnerStreamQC);
    pIInnerStreamQC->Release ();
    pIInnerCallQC->Release ();
    if (FAILED (hr))
    {
        LOG ((MSP_ERROR, "%s failed to register inner stream qc relay: %x", __fxName, hr));
        (*ppITStream)->Release ();
        return hr;
    }

    return S_OK;
}


HRESULT CIPConfMSPCall::CreateStreamObject(
    IN      DWORD               dwMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN      IMediaEvent *       pGraph,
    IN      ITStream **         ppStream
    )
/*++

Routine Description:

    Create a media stream object based on the mediatype and direction.

Arguments:
    
    pMediaType  - TAPI3 media type.

    Direction   - direction of this stream.

    IMediaEvent - The filter graph used in this stream.

    ppStream    - the return pointer of the stream interface

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CreateStreamObject, entered"));

    HRESULT      hr = S_OK;
    ITStream   * pIMSPStream = NULL;

    // Create a stream object based on the media type.
    if (dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamAudioRecv *pAudioRecv = NULL;
            hr = ::CreateStreamHelper(
                pAudioRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio receive:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }
            
            if (FAILED(hr = InitFullDuplexControler()))
            {
                LOG((MSP_ERROR, "Create full duplex controller failed. %x", hr));
            }
            else
            {
                ((CStreamAudioRecv *)pIMSPStream)->
                    SetFullDuplexController(m_pIAudioDuplexController);
            }
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamAudioSend *pAudioSend = NULL;
            hr = ::CreateStreamHelper(
                pAudioSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_AUDIO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create audio send:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }

            if (FAILED(hr = InitFullDuplexControler()))
            {
                LOG((MSP_ERROR, "Create full duplex controller failed. %x", hr));
            }
            else
            {
                ((CStreamAudioSend *)pIMSPStream)->
                    SetFullDuplexController(m_pIAudioDuplexController);
            }
        }
        else
        {
            return TAPI_E_INVALIDDIRECTION;
        }
    }
    else if (dwMediaType == TAPIMEDIATYPE_VIDEO)
    {
        if (Direction == TD_RENDER)
        {
            CStreamVideoRecv *pVideoRecv = NULL;
            hr = ::CreateStreamHelper(
                pVideoRecv,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_RENDER,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video Recv:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }
        }
        else if (Direction == TD_CAPTURE)
        {
            CStreamVideoSend *pVideoSend = NULL;
            hr = ::CreateStreamHelper(
                pVideoSend,
                m_pMSPAddress,
                this, 
                pGraph,
                TAPIMEDIATYPE_VIDEO,
                TD_CAPTURE,
                &pIMSPStream
                );
            LOG((MSP_TRACE, "create video send:%x, hr:%x", pIMSPStream,hr));

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "create stream failed. %x", hr));
                return hr;
            }
        }
        else
        {
            return TAPI_E_INVALIDDIRECTION;
        }
    }
    else
    {
        return TAPI_E_INVALIDMEDIATYPE;
    }

    *ppStream = pIMSPStream;

    return S_OK;
}

DWORD CIPConfMSPCall::FindInterfaceByName(IN WCHAR *pMachineName)
/*++

Routine Description:

    Given the machine name of the originator, find out which local interface
    can be used to reach that machine.

Arguments:
    
    pMachineName - The machine name of the originator.
    
Return Value:

    INADDR_NONE - nothing can be found.
    valid IP - succeeded.

--*/
{
    char buffer[MAXIPADDRLEN + 1];

    if (WideCharToMultiByte(
        GetACP(),
        0,
        pMachineName,
        -1,
        buffer,
        MAXIPADDRLEN,
        NULL,
        NULL
        ) == 0)
    {
        LOG((MSP_ERROR, "can't convert originator's address:%ws", pMachineName));

        return INADDR_NONE;
    }

    DWORD dwAddr;
    if ((dwAddr = inet_addr(buffer)) != INADDR_NONE)
    {
        dwAddr = ntohl(dwAddr);

        LOG((MSP_INFO, "originator's IP:%x", dwAddr));
        
        return ((CIPConfMSP *)m_pMSPAddress)->FindLocalInterface(dwAddr);
    }

    struct hostent * pHost;

    // attempt to lookup hostname
    pHost = gethostbyname(buffer);

    // validate pointer
    if (pHost == NULL) 
    {
        LOG((MSP_WARN, "can't resolve address:%s", buffer));
        return INADDR_NONE;

    }

    // for each of the addresses returned, find the local interface.
    for (DWORD i = 0; TRUE; i ++)
    {
        if (pHost->h_addr_list[i] == NULL)
        {
            break;
        }

        // retrieve host address from structure
        dwAddr = ntohl(*(unsigned long *)pHost->h_addr_list[i]);

        LOG((MSP_INFO, "originator's IP:%x", dwAddr));
        
        DWORD dwInterface = 
            ((CIPConfMSP *)m_pMSPAddress)->FindLocalInterface(dwAddr);

        if (dwInterface != INADDR_NONE)
        {
            return dwInterface;
        }
    }

    return INADDR_NONE;
}

HRESULT CIPConfMSPCall::CheckOrigin(
    IN      ITSdp *     pITSdp, 
    OUT     BOOL *      pFlag,
    OUT     DWORD *     pdwIP
    )
/*++

Routine Description:

    Check to see if the current user is the originator of the conference.
    If he is, he can send to a receive only conference.

Arguments:
    
    pITSdp  - a pointer to the ITSdp interface.

    pFlag   - The result.

    pdwIP   - The local IP interface that should be used to reach the originator.
    
Return Value:

    HRESULT.

--*/
{
    const DWORD MAXUSERNAMELEN = 127;
    DWORD dwUserNameLen = MAXUSERNAMELEN;
    WCHAR szUserName[MAXUSERNAMELEN+1];

    // determine the name of the current user
    if (!GetUserNameW(szUserName, &dwUserNameLen))
    {
        LOG((MSP_ERROR, "cant' get user name. %x", GetLastError()));
        return E_UNEXPECTED;
    }

    LOG((MSP_INFO, "current user: %ws", szUserName));

    // find out if the current user is the originator of the conference.
    BSTR Originator = NULL;
    HRESULT hr = pITSdp->get_Originator(&Originator);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "cant' get originator. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "originator: %ws", Originator));

    *pFlag = (_wcsnicmp(szUserName, Originator, lstrlenW(szUserName)) == 0);
    
    SysFreeString(Originator);
    
    // Get the machine IP address of the originator.
    BSTR MachineAddress = NULL;
    hr = pITSdp->get_MachineAddress(&MachineAddress);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "cant' get MachineAddress. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "MachineAddress: %ws", MachineAddress));

    DWORD dwIP = FindInterfaceByName(MachineAddress);

    SysFreeString(MachineAddress);

    *pdwIP = dwIP;

    LOG((MSP_INFO, "Interface to use:%x", *pdwIP));
    
    return S_OK;
}


HRESULT GetAddress(
    IN      IUnknown *          pIUnknown, 
    OUT     DWORD *             pdwAddress, 
    OUT     DWORD *             pdwTTL,
    OUT     BSTR *              ppKey,
    OUT     LONG *              plBandwidth,
    OUT     LONG *              plConfBandwidth = NULL
    )
/*++

Routine Description:

    Get the IP address and TTL value from a connection. It is a "c=" line
    in the SDP blob.

Arguments:
    
    pIUnknow    - an object that might contain connection information.

    pdwAddress  - the mem address to store the IP address.

    pdwTTL      - the mem address to store the TTL value.

    plBandwidth - maximum bandwidth
Return Value:

    HRESULT.

--*/
{
    // query for the ITConnection i/f
    CComPtr<ITConnection> pITConnection;
    HRESULT hr = pIUnknown->QueryInterface(__uuidof(ITConnection), (void **)&pITConnection);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get connection interface. %x", hr));
        return hr;
    }

    // clear 
    if (plConfBandwidth != NULL) *plConfBandwidth = QCDEFAULT_QUALITY_UNSET;

    // get bandwidth
    const WCHAR * const AS = L"AS";
    const WCHAR * const CT = L"CT";
    BSTR pModifier = NULL;
    DOUBLE bandwidth;

    if (FAILED (hr = pITConnection->get_BandwidthModifier (&pModifier)))
    {
        *plBandwidth = QCDEFAULT_QUALITY_UNSET;
        // bandwidth modifier may not be presented
        // LOG ((MSP_TRACE, "get bandwidth modifiler. %x", hr));
    }
    else if (_wcsnicmp (AS, pModifier, lstrlenW (AS)) != 0)
    {
        // if not application specific
        *plBandwidth = QCDEFAULT_QUALITY_UNSET;

        // check conference-wide bandwidth limit
        if (_wcsnicmp (CT, pModifier, lstrlenW (CT)) == 0)
        {
            if (plConfBandwidth)
            {
                if (FAILED (hr = pITConnection->get_Bandwidth (&bandwidth)))
                {
                    *plConfBandwidth = QCDEFAULT_QUALITY_UNSET;
                    LOG ((MSP_ERROR, "get conf bandwidth. %x", hr));
                }
                else
                    *plConfBandwidth = (LONG)(bandwidth * 1000);
            }
        }

    }
    else if (FAILED (hr = pITConnection->get_Bandwidth (&bandwidth)))
    {
        *plBandwidth = QCDEFAULT_QUALITY_UNSET;
        LOG ((MSP_ERROR, "get bandwidth. %x", hr));
    }
    else
        *plBandwidth = (LONG)(bandwidth * 1000);

    if (pModifier)
    {
        SysFreeString (pModifier);
        pModifier = NULL;
    }

    // get the start address,
    BSTR StartAddress = NULL;
    hr = pITConnection->get_StartAddress(&StartAddress);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "get start address. %x", hr));
        return hr;
    }
    
    // Get the IP address from the string.
    const DWORD MAXIPADDRLEN = 20;
    char Buffer[MAXIPADDRLEN+1];

    // first convert the string to ascii.
    Buffer[0] = '\0';
    if (!WideCharToMultiByte(
        CP_ACP, 
        0, 
        StartAddress, 
        -1, 
        Buffer, 
        MAXIPADDRLEN, 
        NULL, 
        NULL
        ))
    {
        LOG((MSP_ERROR, "converting address. %ws", StartAddress));
        SysFreeString(StartAddress);
        return E_UNEXPECTED;
    }

    SysFreeString(StartAddress);

    // convert the string to DWORD IP address.
    DWORD dwIP = ntohl(inet_addr(Buffer));
    if (dwIP == INADDR_NONE)
    {
        LOG((MSP_ERROR, "invalid IP address. %s", Buffer));
        return E_UNEXPECTED;
    }

    // get the TTL value.
    BYTE Ttl;
    hr = pITConnection->get_Ttl(&Ttl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get TTL."));
        return hr;
    }

    // get the Encryption key.
    const WCHAR * const CLEAR = L"clear";
    VARIANT_BOOL fKeyValid;
    BSTR bstrKeyType = NULL;

    if (*ppKey)
        SysFreeString (*ppKey);

    *ppKey = NULL;

    if (FAILED (hr = pITConnection->GetEncryptionKey (&bstrKeyType, &fKeyValid, ppKey)))
    {
        LOG((MSP_WARN, "can't get EncryptionKey. %x", hr));
    }
    else if (_wcsnicmp (CLEAR, bstrKeyType, lstrlenW (CLEAR)) != 0)
    {
        if (*ppKey)
        {
            SysFreeString (*ppKey);
            *ppKey = NULL;
        }
    }

    if (bstrKeyType)
        SysFreeString (bstrKeyType);

    *pdwAddress = dwIP;
    *pdwTTL     = Ttl;

    return S_OK;
}

HRESULT CheckAttributes(
    IN      IUnknown *  pIUnknown,
    OUT     BOOL *      pbSendOnly,
    OUT     BOOL *      pbRecvOnly,
    OUT     DWORD *     pdwMSPerPacket,
    OUT     BOOL *      pbCIF
    )
/*++

Routine Description:

    Check the direction of the media, find out if it is send only or 
    receive only.

Arguments:
    
    pIUnknow    - an object that might have a attribute list.

    pbSendOnly   - the mem address to store the returned BOOL.

    pbRecvOnly   - the mem address to store the returned BOOL.

    pbCIF        - if CIF is used for video. 
    
Return Value:

    HRESULT.

--*/
{
    // query for the ITAttributeList i/f
    CComPtr<ITAttributeList> pIAttList;
    HRESULT hr = pIUnknown->QueryInterface(__uuidof(ITAttributeList), (void **)&pIAttList);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get attribute interface. %x", hr));
        return hr;
    }

    // get the number of attributes
    long lCount;
    hr = pIAttList->get_Count(&lCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get attribute count. %x", hr));
        return hr;
    }

    *pbRecvOnly = FALSE;
    *pbSendOnly = FALSE;
    *pdwMSPerPacket = 0;
    *pbCIF      = FALSE;

    const WCHAR * const SENDONLY = L"sendonly";
    const WCHAR * const RECVONLY = L"recvonly";
    const WCHAR * const FORMAT  = L"fmtp";
    const WCHAR * const PTIME  = L"ptime:";
    const WCHAR * const CIF  = L" CIF=";

    for (long i = 1; i <= lCount; i ++)
    {

        // get the attributes and check if sendonly of recvonly is specified.
        BSTR Attribute = NULL;
        hr = pIAttList->get_Item(i, &Attribute);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get attribute item. %x", hr));
            return hr;
        }
        
        if (_wcsnicmp(SENDONLY, Attribute, lstrlen(SENDONLY)) == 0)
        {
            *pbSendOnly = TRUE;
        }
        else if (_wcsnicmp(RECVONLY, Attribute, lstrlen(RECVONLY)) == 0)
        {
            *pbRecvOnly = TRUE;
        }
        else if (_wcsnicmp(PTIME, Attribute, lstrlen(PTIME)) == 0)
        {
            // read the number of milliseconds per packet.
            *pdwMSPerPacket = (DWORD)_wtol(Attribute + lstrlen(PTIME));

            // RFC 1890 only requires an app to support 200ms packets.
            if (*pdwMSPerPacket > 200)
            {
                // invalid tag, we just use our default.
                *pdwMSPerPacket = 0;
            }

        }
        else if (_wcsnicmp(FORMAT, Attribute, lstrlen(FORMAT)) == 0)
        {
            if (wcsstr(Attribute, CIF))
            {
                *pbCIF = TRUE;
            }
        }

        SysFreeString(Attribute);
    }
    
    return S_OK;
}

HRESULT CIPConfMSPCall::ProcessMediaItem(
    IN      ITMedia *           pITMedia,
    IN      DWORD               dwMediaTypeMask,
    OUT     DWORD *             pdwMediaType,
    OUT     WORD *              pwPort,
    OUT     DWORD *             pdwPayloadTypes,
    IN OUT  DWORD *             pdwNumPayLoadType
    )
/*++

Routine Description:

    Process a "m=" line, find out the media type, port, and payload type.

Arguments:

    dwMediaTypeMask - the media type of this call.

    pdwMediaType    - return the media type of this media item.

    pwPort          - return the port number used for this media.

    pdwPayloadType  - an array to store the RTP payload types. 
    
    pdwNumPayLoadType -  The size of the above array. When return, it is the
        number of payload types read.

Return Value:

    HRESULT.

    S_FALSE - everything is all right but the media type is not needed.

--*/
{
    // get the name of the media.
    BSTR MediaName = NULL;
    HRESULT hr = pITMedia->get_MediaName(&MediaName);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get media name. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "media name: %ws", MediaName));

    // check if the media is audio or video.
    const WCHAR * const AUDIO = L"audio";
    const WCHAR * const VIDEO = L"video";
    const DWORD NAMELEN = 5;

    DWORD dwMediaType = 0;
    if (_wcsnicmp(AUDIO, MediaName, NAMELEN) == 0)
    {
        dwMediaType = TAPIMEDIATYPE_AUDIO;
    }
    else if (_wcsnicmp(VIDEO, MediaName, NAMELEN) == 0)
    {
        dwMediaType = TAPIMEDIATYPE_VIDEO;
    }

    SysFreeString(MediaName);

    // check if the call wants this media type.
    if ((dwMediaType & dwMediaTypeMask) == 0)
    {
        // We don't need this media type in this call.
        LOG((MSP_INFO, "media skipped."));
        return S_FALSE;
    }

    // get start port
    long  lStartPort;
    hr = pITMedia->get_StartPort(&lStartPort);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get start port. %x", hr));
        return hr;
    }

    // get the transport Protocol
    BSTR TransportProtocol = NULL;
    hr = pITMedia->get_TransportProtocol(&TransportProtocol);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get transport Protocol. %x", hr));
        return hr;
    }

    // varify that the protocol is RTP.
    const WCHAR * const RTP = L"RTP";
    const DWORD PROTOCOLLEN = 3;

    if (_wcsnicmp(RTP, TransportProtocol, PROTOCOLLEN) != 0)
    {
        LOG((MSP_ERROR, "wrong transport Protocol:%ws", TransportProtocol));
        SysFreeString(TransportProtocol);
        return S_FALSE;
    }

    SysFreeString(TransportProtocol);

    // get the format code list
    VARIANT Variant;
    VariantInit(&Variant);

    hr = pITMedia->get_FormatCodes(&Variant);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get format codes. %x", hr));
        return hr;
    }

    // Verify that the SafeArray is in proper shape.
    if(SafeArrayGetDim(V_ARRAY(&Variant)) != 1)
    {
        LOG((MSP_ERROR, "wrong dimension for the format code. %x", hr));
	    VariantClear(&Variant);
        return E_UNEXPECTED;
    }

    long lLowerBound;
    long lUpperBound;
    if (FAILED(hr = SafeArrayGetLBound(V_ARRAY(&Variant), 1, &lLowerBound))
     || FAILED(hr = SafeArrayGetUBound(V_ARRAY(&Variant), 1, &lUpperBound)))
    {
        LOG((MSP_ERROR, "Can't get the array bounds. %x", hr));
	    VariantClear(&Variant);
        return E_UNEXPECTED;
    }

    DWORD dwNumFormats = 0;
    for (long l = lLowerBound; l <= lUpperBound && dwNumFormats < *pdwNumPayLoadType; l ++)
    {
        BSTR Format = NULL;
        hr = SafeArrayGetElement(V_ARRAY(&Variant), &l, &Format);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get format code. %x", hr));
            continue;
        }

        LOG((MSP_INFO, "format code: %ws", Format));
        
        pdwPayloadTypes[dwNumFormats] = (DWORD)_wtoi(Format);

        // ignore unsupported codec, including G723
        if (IsPayloadSupported(pdwPayloadTypes[dwNumFormats]))
        {
            dwNumFormats ++;
        }

        SysFreeString(Format);
    }

    // clear the variant because we don't need it any more
    VariantClear(&Variant);


    *pdwMediaType   = dwMediaType;
    *pwPort         = (WORD)lStartPort;
    *pdwNumPayLoadType = dwNumFormats;

    return S_OK;
}

HRESULT CIPConfMSPCall::ConfigStreamsBasedOnSDP(
    IN  ITSdp *     pITSdp,
    IN  DWORD       dwAudioQOSLevel,
    IN  DWORD       dwVideoQOSLevel
    )
/*++

Routine Description:

    Configure the streams based on the information in the SDP blob.

Arguments:

    pITSdp  - the SDP object. It contains parsed information.

Return Value:

    HRESULT.

--*/
{
    // find out if the current user is the originator of the conference.
    BOOL fIsOriginator;
    DWORD dwLocalInterface = INADDR_NONE;

    HRESULT hr = CheckOrigin(pITSdp, &fIsOriginator, &dwLocalInterface);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "check origin. %x", hr));
        return hr;
    }
    
    LOG((MSP_INFO, "Local interface: %x", dwLocalInterface));

    // get the start IP address and TTL value from the connection.
    DWORD dwIPGlobal, dwTTLGlobal;
    BSTR bstrKeyGlobal = NULL;
    LONG lbandwidth, lConfBandwidth;
    hr = GetAddress(pITSdp, &dwIPGlobal, &dwTTLGlobal, &bstrKeyGlobal, &lbandwidth, &lConfBandwidth);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get global address. %x", hr));
        return hr;
    }

    CLock lock(m_lock);

    // store conference bandwidth
    if (FAILED (m_pCallQCRelay->SetConfBitrate (lConfBandwidth)))
    {
        LOG ((MSP_ERROR, "bandwidth is out of range %d", lConfBandwidth));
    }

    // find out if this conference is sendonly or recvonly.
    BOOL fSendOnlyGlobal = FALSE, fRecvOnlyGlobal = FALSE, fCIF = FALSE;
    DWORD dwMSPerPacket;
    hr = CheckAttributes(
        pITSdp, &fSendOnlyGlobal, &fRecvOnlyGlobal, &dwMSPerPacket, &fCIF);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "check global attributes. %x", hr));
        return hr;
    }

    // get the media information
    CComPtr<ITMediaCollection> pICollection;
    hr = pITSdp->get_MediaCollection(&pICollection);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get the media collection. %x", hr));
        return hr;
    }

    // find out how many media sessions are in the blobl.
    long lCount;
    hr = pICollection->get_Count(&lCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get number of media items. %x", hr));
        return hr;
    }

    if (lCount > 0)
    {
        // change the call into connected state since the SDP is OK.
        // We are going to set up each every streams next.
        SendTSPMessage(CALL_CONNECTED, 0);
    }

    DWORD dwNumSucceeded = 0;

    // for each media session, get info configure a stream.
    for(long i=1; i <= lCount; i++)
    {
        // get the media item first.
        ITMedia *pITMedia;
        hr = pICollection->get_Item(i, &pITMedia);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get media item. %x", hr));
            continue;
        }

        DWORD dwMediaType;
        STREAMSETTINGS Setting;

        ZeroMemory(&Setting, sizeof(STREAMSETTINGS));

        // find out the information about the media. Here we pass in the media
        // type of call so that we won't wasting time reading the attributes
        // for a media type we don't need.
        DWORD dwNumPayloadTypes = sizeof(Setting.PayloadTypes) 
            / sizeof(Setting.PayloadTypes[0]);

        hr = ProcessMediaItem(
            pITMedia,
            m_dwMediaType,
            &dwMediaType,
            &Setting.wRTPPortRemote,
            Setting.PayloadTypes,
            &dwNumPayloadTypes
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "process media. %x", hr));
            continue;
        }
        
        Setting.dwNumPayloadTypes = dwNumPayloadTypes;

        // if the return value is S_FALSE from the previous call, this media
        // type is not needed for the call.
        if (hr != S_OK || dwNumPayloadTypes == 0)
        {
            // the media is not needed.
            continue;
        }
        
        if (dwMediaType == TAPIMEDIATYPE_AUDIO)
        {
            Setting.dwQOSLevel = dwAudioQOSLevel;
            Setting.phRTPSession = &m_hAudioRTPSession;
        }
        else
        {
            Setting.dwQOSLevel = dwVideoQOSLevel;
            Setting.phRTPSession = &m_hVideoRTPSession;
        }

        // Get the local connect information.
        DWORD dwIP, dwTTL;
        BSTR bstrKey = NULL;

        hr = GetAddress(pITMedia, &dwIP, &dwTTL, &bstrKey, &lbandwidth);
        if (FAILED(hr))
        {
            LOG((MSP_WARN, "no local address, use global one", hr));
            Setting.dwIPRemote  = dwIPGlobal;
            Setting.dwTTL       = dwTTLGlobal;
            Setting.lBandwidth = QCDEFAULT_QUALITY_UNSET;
        }
        else
        {
            Setting.dwIPRemote  = dwIP;
            Setting.dwTTL       = dwTTL;
            Setting.lBandwidth = lbandwidth;
        }

        // find out if this media is sendonly or recvonly.
        BOOL fSendOnly = FALSE, fRecvOnly = FALSE, fCIF = FALSE;
        hr = CheckAttributes(
            pITMedia, &fSendOnly, &fRecvOnly, &dwMSPerPacket, &fCIF);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "check local attributes. %x", hr));
        }
        
        fSendOnly = fSendOnly || fSendOnlyGlobal;
        fRecvOnly = (fRecvOnly || fRecvOnlyGlobal) && (!fIsOriginator);
        Setting.dwMSPerPacket = dwMSPerPacket;
        Setting.fCIF = fCIF;

        // The media item is not needed after this point.
        pITMedia->Release();

        // Go through the existing streams and find out if any stream
        // can be configured.

        // Note: we are not creating any new streams now. We might want to 
        // do it in the future if we want to support two sessions of the
        // same media type.

        m_fCallStarted = TRUE;

        for (long j = 0; j < m_Streams.GetSize(); j ++)
        {
            CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];
        
            if ((pStream->MediaType() != dwMediaType)
                || pStream->IsConfigured()
                || (fSendOnly && pStream->Direction() == TD_RENDER)
                || (fRecvOnly && pStream->Direction() == TD_CAPTURE)
                )
            {
                // this stream should not be configured.
                continue;
            }

            // set the local interface that the call should bind to.
            Setting.dwIPLocal = m_dwIPInterface;

            if ((m_dwIPInterface == INADDR_ANY)
                && (dwLocalInterface != INADDR_NONE))
            {
                Setting.dwIPLocal = dwLocalInterface;
            }

            // set the loopback mode of the stream.
            Setting.LoopbackMode = m_LoopbackMode;

            // set the qos application IDS.
            Setting.pApplicationID = m_pApplicationID;
            Setting.pApplicationGUID = m_pApplicationGUID;
            Setting.pSubIDs = m_pSubIDs;

            // configure the stream, it will not be started.
            hr = pStream->Configure(Setting, (bstrKey) ? bstrKey : bstrKeyGlobal);
            if (FAILED(hr))
            {
               LOG((MSP_ERROR, "configure stream failed. %x", hr));
            }
        }

        SysFreeString(bstrKey);
    }

    SysFreeString(bstrKeyGlobal);

    // after configuring the streams, start them.
    for (int j = 0; j < m_Streams.GetSize(); j ++)
    {
        CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];

        // start the stream.
        hr = pStream->FinishConfigure();
        if (SUCCEEDED(hr))
        {
            dwNumSucceeded ++;
        }
    }

    if (dwNumSucceeded == 0)
    {
        LOG((MSP_ERROR, "No media succeeded."));
        return E_FAIL;
    }

    return S_OK;        
}

HRESULT CIPConfMSPCall::ParseSDP(
    IN  WCHAR * pSDP,
    IN  DWORD dwAudioQOSLevel,
    IN  DWORD dwVideoQOSLevel
    )
/*++

Routine Description:

    Parse the SDP string. The function uses the SdpConferenceBlob object
    to parse the string.

Arguments:

    pSDP  - the SDP string.
    dwAudioQOSLevel - the QOS requirement for audio.
    dwVideoQOSLevel - the QOS requirement for video.

Return Value:

    HRESULT.

--*/
{
    // co-create an sdp conference blob component
    // query for the ITConferenceBlob interface
    CComPtr<ITConferenceBlob>   pIConfBlob;   

    HRESULT hr = ::CoCreateInstance(
        CLSID_SdpConferenceBlob,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(ITConferenceBlob),
        (void **)&pIConfBlob
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "creating a SDPBlob object. %x", hr));
        return hr;
    }
    
    // conver the sdp into a BSTR to use the interface.
    BSTR bstrSDP = SysAllocString(pSDP);
    if (bstrSDP == NULL)
    {
        LOG((MSP_ERROR, "out of mem converting SDP to a BSTR."));
        return E_OUTOFMEMORY;
    }

    // Parse the SDP string.
    hr = pIConfBlob->Init(NULL, BCS_ASCII, bstrSDP);
    
    // the string is not needed any more.
    SysFreeString(bstrSDP);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "parse the SDPBlob object. %x", hr));
        return hr;
    }
    
    // Get the ITSdp interface.
    CComPtr<ITSdp>  pITSdp;
    hr = pIConfBlob->QueryInterface(__uuidof(ITSdp), (void **)&pITSdp);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get the ITSdp interface. %x", hr));
        return hr;
    }

    // check main sdp validity
    VARIANT_BOOL IsValid;
    hr = pITSdp->get_IsValid(&IsValid);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get the valid flag on the SDP %x", hr));
        return hr;
    }

    if (!IsValid)
    {
        LOG((MSP_ERROR, "the SDP is not valid %x", hr));
        return E_FAIL;
    }

    return ConfigStreamsBasedOnSDP(
        pITSdp,
        dwAudioQOSLevel,
        dwVideoQOSLevel
        );
}

HRESULT CIPConfMSPCall::SendTSPMessage(
    IN  TSP_MSP_COMMAND command,
    IN  DWORD           dwParam1,
    IN  DWORD           dwParam2
    ) const
/*++

Routine Description:

    Send the TSP a message from the MSP. 

Arguments:

    command     - the command to be sent.

    dwParam1    - the first DWORD used in the command.

    dwParam2    - the second DWORD used in the command.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "SendTSPMessage, command %d, dwParam1 %d, dwParam2", 
        command, dwParam1, dwParam2));

    // first allocate the memory.

    MSPEVENTITEM* pEventItem = AllocateEventItem(sizeof(MSG_TSPMSPDATA));

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data"));
        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = 
        sizeof(MSP_EVENT_INFO) + sizeof(MSG_TSPMSPDATA);
    pEventItem->MSPEventInfo.Event  = ME_TSP_DATA;
    pEventItem->MSPEventInfo.hCall  = m_htCall;

    // Fill in the data for the TSP.
    pEventItem->MSPEventInfo.MSP_TSP_DATA.dwBufferSize = sizeof(MSG_TSPMSPDATA);

    MSG_TSPMSPDATA *pData = (MSG_TSPMSPDATA *)
        pEventItem->MSPEventInfo.MSP_TSP_DATA.pBuffer;

    pData->command = command;
    switch (command)
    {

    case CALL_DISCONNECTED:
        pData->CallDisconnected.dwReason = dwParam1;
        break;

    case CALL_QOS_EVENT:
        pData->QosEvent.dwEvent = dwParam1;
        pData->QosEvent.dwMediaMode = dwParam2;
        break;

    case CALL_CONNECTED:
        break;

	default:
		
		LOG((MSP_ERROR, "Wrong command type for TSP"));

        FreeEventItem(pEventItem);
		return E_UNEXPECTED;
    }

    HRESULT hr = m_pMSPAddress->PostEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));

        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

HRESULT CIPConfMSPCall::CheckUnusedStreams()
/*++

Routine Description:

    Find out which streams are not used and send tapi events about them.

Arguments:

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CheckUnusedStreams"));

    CLock lock(m_lock);
    for (long j = 0; j < m_Streams.GetSize(); j ++)
    {
        CIPConfMSPStream* pStream = (CIPConfMSPStream*)m_Streams[j];
    
        if (pStream->IsConfigured())
        {
            // find the next.
            continue;
        }
        
        MSPEVENTITEM* pEventItem = AllocateEventItem();

        if (pEventItem == NULL)
        {
            LOG((MSP_ERROR, "No memory for the TSPMSP data"));

            return E_OUTOFMEMORY;
        }
    
        // Fill in the necessary fields for the event structure.
        pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);;
        pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;
        pEventItem->MSPEventInfo.hCall  = m_htCall;
    
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = CALL_STREAM_NOT_USED;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = CALL_CAUSE_REMOTE_REQUEST;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = m_Streams[j];
        
        // Addref to prevent it from going away.
        m_Streams[j]->AddRef();

        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = NULL;
        pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= 0;

        // send the event to tapi.
        HRESULT hr = m_pMSPAddress->PostEvent(pEventItem);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Post event failed %x", hr));
        
            FreeEventItem(pEventItem);
            return hr;
        }
    }
    return S_OK;
}

DWORD WINAPI CIPConfMSPCall::WorkerCallbackDispatcher(VOID *pContext)
/*++

Routine Description:

    Because Parsing the SDP and configure the streams uses a lot of COM
    stuff, we can't rely on the RPC thread the calls into the MSP to 
    receive the TSP data. So, we let our own working thread do the work.
    This method is the callback function for the queued work item. It 
    just gets the call object from the context structure and calls a method
    on the call object to handle the work item.

Arguments:

    pContext - A pointer to a CALLWORKITEM structure.

Return Value:

    HRESULT.

--*/
{
    _ASSERTE(!IsBadReadPtr(pContext, sizeof CALLWORKITEM));

    CALLWORKITEM *pItem = (CALLWORKITEM *)pContext;
    
    pItem->pCall->ProcessWorkerCallBack(pItem->Buffer, pItem->dwLen);
    pItem->pCall->MSPCallRelease();

    free(pItem);

    return NOERROR;
}

DWORD CIPConfMSPCall::ProcessWorkerCallBack(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    NOERROR.

--*/
{
    LOG((MSP_TRACE, "PreocessWorkerCallBAck"));

    _ASSERTE(!IsBadReadPtr(pBuffer, dwSize));

    MSG_TSPMSPDATA * pData = (MSG_TSPMSPDATA *)pBuffer;

    HRESULT hr;

    switch (pData->command)
    {
    case CALL_START:

        // Parse the SDP contained in the command block.
        hr = ParseSDP(pData->CallStart.szSDP, 
            pData->CallStart.dwAudioQOSLevel,
            pData->CallStart.dwVideoQOSLevel
            );

        if (FAILED(hr))
        {
            // disconnect the call if someting terrible happend.
            SendTSPMessage(CALL_DISCONNECTED, 0);

            LOG((MSP_ERROR, "parsing theSDPBlob object. %x", hr));
            return NOERROR;
        }

        // go through the streams and send events if they are not used.
        hr = CheckUnusedStreams();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "start the streams failed. %x", hr));
        }
        break;

    case CALL_STOP:
        InternalShutDown();
        break;
    }

    return NOERROR;
}

HRESULT CIPConfMSPCall::ReceiveTSPCallData(
    IN      PBYTE               pBuffer,
    IN      DWORD               dwSize
    )
/*++

Routine Description:

    This function handles the work item given by the TSP. 

Arguments:

    pBuffer - a buffer that contains a TSP_MSP command block.

    dwSize  - the size of the buffer.

Return Value:

    NOERROR.

--*/
{
    LOG((MSP_TRACE, 
        "ReceiveTSPCallData, pBuffer %x, dwSize %d", pBuffer, dwSize));

    MSG_TSPMSPDATA * pData = (MSG_TSPMSPDATA *)pBuffer;
    switch (pData->command)
    {
    case CALL_START:

        // make sure the string is valid.
        if ((IsBadReadPtr(pData->CallStart.szSDP, 
            (pData->CallStart.dwSDPLen + 1) * sizeof (WCHAR)))
            || (pData->CallStart.szSDP[pData->CallStart.dwSDPLen] != 0))
        {
            LOG((MSP_ERROR, "the TSP data is invalid."));
            return E_UNEXPECTED;
        }

        LOG((MSP_INFO, "SDP string\n%ws", pData->CallStart.szSDP));

        break;

    case CALL_STOP:
        break;

    default:
        LOG((MSP_ERROR, 
            "wrong command received from the TSP:%x", pData->command));
        return E_UNEXPECTED; 
    }

    // allocate a work item structure for our worker thread.
    CALLWORKITEM *pItem = (CALLWORKITEM *)malloc(sizeof(CALLWORKITEM) + dwSize);

    if (pItem == NULL)
    {
        // Disconnect the call because of out of memory.
        SendTSPMessage(CALL_DISCONNECTED, 0);

        LOG((MSP_ERROR, "out of memory for work item."));
        return E_OUTOFMEMORY;
    }

    this->MSPCallAddRef();
    pItem->pCall = this;
    pItem->dwLen = dwSize;
    CopyMemory(pItem->Buffer, pBuffer, dwSize);
    
    // post a work item to our worker thread.
    HRESULT hr = g_Thread.QueueWorkItem(
        WorkerCallbackDispatcher,           // the callback
        pItem,                              // the context.
        FALSE                               // sync (FALSE means asyn)
        );

    if (FAILED(hr))
    {
        if (pData->command == CALL_START)
        {
            // Disconnect the call because we can't handle the work.
            SendTSPMessage(CALL_DISCONNECTED, 0);
        }

        this->MSPCallRelease();
        free(pItem);

        LOG((MSP_ERROR, "queue work item failed."));
    }

    return hr;
}


STDMETHODIMP CIPConfMSPCall::EnumerateParticipants(
    OUT     IEnumParticipant **      ppEnumParticipant
    )
/*++

Routine Description:

    This method returns an enumerator to the participants. 

Arguments:
    ppEnumParticipant - the memory location to store the returned pointer.
  
Return Value:

S_OK
E_POINTER
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, 
        "EnumerateParticipants entered. ppEnumParticipant:%p", ppEnumParticipant));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumParticipant, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the Participant object list.
    //

    CLock lock(m_ParticipantLock);

    if (m_Participants.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //
    HRESULT hr = CreateParticipantEnumerator(
        m_Participants.GetData(),                        // the begin itor
        m_Participants.GetData() + m_Participants.GetSize(),  // the end itor,
        ppEnumParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::EnumerateParticipants - "
            "create enumerator object failed, %x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CIPConfMSPCall::EnumerateParticipants - exit S_OK"));

    return hr;
}

STDMETHODIMP CIPConfMSPCall::get_Participants(
    OUT     VARIANT *              pVariant
    )
{
    LOG((MSP_TRACE, "CIPConfMSPCall::get_Participants - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the Participant object list.
    //

    CLock lock(m_ParticipantLock);

    if (m_Participants.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //
    HRESULT hr = CreateParticipantCollection(
        m_Participants.GetData(),                        // the begin itor
        m_Participants.GetData() + m_Participants.GetSize(),  // the end itor,
        m_Participants.GetSize(),                        // the size
        pVariant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CIPConfMSPCall::get_Participants - "
            "create collection failed - exit 0x%08x", hr));
        
        return hr;
    }

    LOG((MSP_TRACE, "CIPConfMSPCall::get_Participants - exit S_OK"));
 
    return S_OK;
}

// IMulticastControl methods
STDMETHODIMP CIPConfMSPCall::get_LoopbackMode (
    OUT MULTICAST_LOOPBACK_MODE * pMode
    )
{
    if (pMode == NULL)
    {
        return E_INVALIDARG;
    }

    *pMode = m_LoopbackMode;

    return S_OK;
}
    
STDMETHODIMP CIPConfMSPCall::put_LoopbackMode (
    IN MULTICAST_LOOPBACK_MODE mode
    )
{
    if (mode < MM_NO_LOOPBACK || mode > MM_SELECTIVE_LOOPBACK)
    {
        return E_INVALIDARG;
    }

    m_LoopbackMode = mode;

    return S_OK;
}

// ITLocalParticipant methods, called by the app.
STDMETHODIMP CIPConfMSPCall::get_LocalParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    OUT BSTR *                  ppInfo
    )
/*++

Routine Description:

    Get a information item for the local participant. This information is
    sent out to other participants in the conference.

Arguments:
    
    InfoType - The type of the information asked.

    ppInfo  - the mem address to store a BSTR.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "CParticipant get info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "CParticipant get info - invalid type:%d", InfoType));
        return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppInfo, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CParticipant get info - exit E_POINTER"));
        return E_POINTER;
    }

    // check if we have that info.
    CLock lock(m_lock);
    
    if (!m_fLocalInfoRetrieved)
    {
        HRESULT hr = InitializeLocalParticipant();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    int index = (int)InfoType; 
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_INFO, "no local participant info item for %d", InfoType));
        return TAPI_E_NOITEMS;
    }

    // make a BSTR out of it.
    BSTR pName = SysAllocString(m_InfoItems[index]);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit out of mem"));
        return E_POINTER;
    }

    // return the BSTR.
    *ppInfo = pName;

    return S_OK; 
}

// ITLocalParticipant methods, called by the app.
STDMETHODIMP CIPConfMSPCall::put_LocalParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    IN  BSTR                    pInfo
    )
/*++

Routine Description:

    Set a information item for the local participant. This information is
    sent out to other participants in the conference.

Arguments:
    
    InfoType - The type of the information item.

    pInfo  - the information item.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "set local info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "set local info - invalid type:%d", InfoType));
        return E_INVALIDARG;
    }

    if (IsBadStringPtr(pInfo, MAX_PARTICIPANT_TYPED_INFO_LENGTH))
    {
        LOG((MSP_ERROR, "set local info, bad ptr:%p", pInfo));
        return E_POINTER;
    }

    DWORD dwStringLen = lstrlenW(pInfo);
    if (dwStringLen > MAX_PARTICIPANT_TYPED_INFO_LENGTH)
    {
        LOG((MSP_ERROR, "local info too long"));
        return E_INVALIDARG;
    }

    // check if we have that info.
    CLock lock(m_lock);

    if (m_fCallStarted)
    {
        return TAPI_E_INVALCALLSTATE;
    }
    
    if (!m_fLocalInfoRetrieved)
    {
        HRESULT hr = InitializeLocalParticipant();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    int index = (int)InfoType; 
    if (m_InfoItems[index] != NULL)
    {
        if (lstrcmpW(m_InfoItems[index], pInfo) == 0)
        {
            // The info is the same as what we are using.
            return S_OK;
        }

		// the infomation is different, release the old info.
		free(m_InfoItems[index]);
		m_InfoItems[index] = NULL;
    }

	// save the info.
    m_InfoItems[index] = (WCHAR *)malloc((dwStringLen + 1)* sizeof(WCHAR));
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_ERROR, "out of mem for local info"));

        return E_OUTOFMEMORY;
    }

    lstrcpynW(m_InfoItems[index], pInfo, dwStringLen + 1);

    //
    // The info is new, we need to set it on the streams.
    //

    for (int i = 0; i < m_Streams.GetSize(); i ++)
    {
        ((CIPConfMSPStream*)m_Streams[i])->SetLocalParticipantInfo(
            InfoType,
            m_InfoItems[index],
            dwStringLen
            );
    }

    return S_OK; 
}

STDMETHODIMP CIPConfMSPCall::SetQOSApplicationID (
    IN  BSTR pApplicationID,
    IN  BSTR pApplicationGUID,
    IN  BSTR pSubIDs
    )
/*++

Routine Description:
    
    This method is called by the App to set the QOS specific application ID.
    It can only be called before the call is connected.

Arguments:

    pApplicationID - the Application ID.

    pSubIDs - the SubIDs that will be appended to the end of policy locator.

Return Value:

S_OK
E_OUTOFMEMORY

--*/
{
    CLock lock(m_lock);

    if (m_fCallStarted)
    {
        return TAPI_E_INVALCALLSTATE;
    }

    if (pSubIDs!=NULL && lstrlenW(pSubIDs)>MAX_QOS_ID_LEN)
    {
        return E_INVALIDARG;
    }

    if (pApplicationID!=NULL && lstrlenW(pApplicationID)>MAX_QOS_ID_LEN)
    {
        return E_INVALIDARG;
    }

    try
    {
        if (m_pApplicationID) SysFreeString(m_pApplicationID);
        m_pApplicationID = SysAllocString(pApplicationID);
    }
    catch(...)
    {
        return E_POINTER;
    }
    
    if (m_pApplicationID == NULL)
    {
        return E_OUTOFMEMORY;
    }

    try
    {
        if (m_pApplicationGUID)
        {
            SysFreeString(m_pApplicationGUID);
            m_pApplicationGUID = NULL;
        }

        if (m_pSubIDs)
        {
            SysFreeString(m_pSubIDs);
            m_pSubIDs = NULL;
        }

        if (pApplicationGUID)
        {
            m_pApplicationGUID = SysAllocString(pApplicationGUID);
        }

        if (pSubIDs)
        {
            m_pSubIDs = SysAllocString(pSubIDs);
        }
    }
    catch(...)
    {
        SysFreeString(m_pApplicationID);
        m_pApplicationID = NULL;

        if (m_pApplicationGUID)
        {
            SysFreeString(m_pApplicationGUID);
        }
        m_pApplicationGUID = NULL;

        if (m_pSubIDs)
        {
            SysFreeString(m_pSubIDs);
        }
        m_pSubIDs = NULL;

        return E_POINTER;
    }

    if ((pApplicationGUID!=NULL && m_pApplicationGUID==NULL) ||
        (pSubIDs!=NULL && m_pSubIDs==NULL))
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CIPConfMSPCall::NewParticipant(
    IN  ITStream *          pITStream,
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  DWORD               dwMediaType,
    IN  WCHAR *              szCName,
    OUT ITParticipant **    ppITParticipant
    )
/*++

Routine Description:
    
    This method is called by a stream object when a new participant appears.
    It looks throught the call's participant list, if the partcipant is 
    already in the list, it returns the pointer to the object. If it is not
    found, a new object will be created and added into the list.

Arguments:

    pITStream - the stream object.

    dwSSRC - the SSRC of the participant in the stream.

    dwSendRecv - a sender or a receiver.
    
    dwMediaType - the media type of the stream.

    szCName - the canonical name of the participant.

    ppITParticipant - the address to store the returned pointer.

Return Value:

S_OK
E_OUTOFMEMORY

--*/
{
    CLock lock(m_ParticipantLock);

    HRESULT hr;

    // First check to see if the participant is in our list. If he is already
    // in the list, just return the object.
    int index;
    if (m_Participants.FindByCName(szCName, &index))
    {
        hr = ((CParticipant *)m_Participants[index])->
                AddStream(pITStream, dwSSRC, dwSendRecv, dwMediaType);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can not add a stream to a participant:%x", hr));
            return hr;
        }

        *ppITParticipant = m_Participants[index];
        (*ppITParticipant)->AddRef();

        return S_OK;
    }

    // create a new participant object.
    CComObject<CParticipant> * pCOMParticipant;

    hr = ::CreateCComObjectInstance(&pCOMParticipant);

    if (NULL == pCOMParticipant)
    {
        LOG((MSP_ERROR, "can not create a new participant:%x", hr));
        return hr;
    }

    ITParticipant* pITParticipant;

    // get the interface pointer.
    hr = pCOMParticipant->_InternalQueryInterface(
        __uuidof(ITParticipant), 
        (void **)&pITParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Participant QueryInterface failed: %x", hr));
        delete pCOMParticipant;
        return hr;
    }

    // Initialize the object.
    hr = pCOMParticipant->Init(
        szCName, pITStream, dwSSRC, dwSendRecv, dwMediaType
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create participant:call init failed: %x", hr));
        pITParticipant->Release();

        return hr;
    }

    // Add the Participant into our list of Participants.
    if (!m_Participants.InsertAt(index, pITParticipant))
    {
        pITParticipant->Release();

        LOG((MSP_ERROR, "out of memory in adding a Participant."));
        return E_OUTOFMEMORY;
    }

    // AddRef the interface pointer and return it.
    pITParticipant->AddRef(); 
    *ppITParticipant = pITParticipant;

    SendParticipantEvent(PE_NEW_PARTICIPANT, pITParticipant);

    return S_OK;
}

HRESULT CIPConfMSPCall::ParticipantLeft(
    IN  ITParticipant *     pITParticipant
    )
/*++

Routine Description:
    
    This method is called by a stream object when a participant left the
    conference.

Arguments:

    pITParticipant - the participant that left.

Return Value:

S_OK

--*/
{
    m_ParticipantLock.Lock();

    BOOL fRemoved = m_Participants.Remove(pITParticipant);

    m_ParticipantLock.Unlock();
    
    if (fRemoved)
    {
        SendParticipantEvent(PE_PARTICIPANT_LEAVE, pITParticipant);
        pITParticipant->Release();
    }
    else
    {
        LOG((MSP_ERROR, "can't remove Participant %p", pITParticipant));
    }

    return S_OK;
}

void CIPConfMSPCall::SendParticipantEvent(
    IN  PARTICIPANT_EVENT   Event,
    IN  ITParticipant *     pITParticipant,
    IN  ITSubStream *       pITSubStream
    ) const
/*++

Routine Description:
    
    This method is called by a stream object to send a participant related
    event to the app.

Arguments:

    Event - the event code.

    pITParticipant - the participant object.

    pITSubStream - the substream object, if any.

Return Value:

nothing.

--*/
{
    if (pITParticipant)
    {
        LOG((MSP_TRACE, "SendParticipantEvent, event %s, participant:%ws",
            ParticipantEventString[Event], 
            ((CParticipant*)pITParticipant)->Name()
            ));
    }
    else
    {
        LOG((MSP_TRACE, "SendParticipantEvent, event %s, participant: null (local)",
            ParticipantEventString[Event]
            ));
    }

    // Create a private event object.
    CComPtr<IDispatch> pEvent;
    HRESULT hr = CreateParticipantEvent(
        Event, 
        pITParticipant, 
        pITSubStream, 
        &pEvent
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create event returned: %x", hr));
        return;
    }


    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data"));

        return;
    }

    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);;
    pEventItem->MSPEventInfo.Event  = ME_PRIVATE_EVENT;
    pEventItem->MSPEventInfo.hCall  = m_htCall;
    
    pEventItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.pEvent = pEvent;
    pEventItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.lEventCode = Event;
    pEvent.p->AddRef();

    // send the event to tapi.
    hr = m_pMSPAddress->PostEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
    
        pEvent.Release();
        FreeEventItem(pEventItem);
    }
}

VOID CIPConfMSPCall::HandleGraphEvent(
    IN  MSPSTREAMCONTEXT * pContext
    )
{
    long     lEventCode;
    LONG_PTR lParam1, lParam2; // win64 fix

    HRESULT hr = pContext->pIMediaEvent->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can not get the actual event. %x", hr));
        return;
    }

    LOG((MSP_EVENT, "ProcessGraphEvent, code:%d param1:%x param2:%x",
        lEventCode, lParam1, lParam2));

    if (lEventCode == EC_PALETTE_CHANGED 
        || lEventCode == EC_VIDEO_SIZE_CHANGED)
    {
        LOG((MSP_EVENT, "event %d ignored", lEventCode));
        return;
    }

    //
    // Create an event data structure that we will pass to the worker thread.
    //

    MULTI_GRAPH_EVENT_DATA * pData;
    pData = new MULTI_GRAPH_EVENT_DATA;
    
    if (pData == NULL)
    {
        LOG((MSP_ERROR, "Out of memory for event data."));
        return;
    }
    
    pData->pCall      = this;
    pData->pITStream  = pContext->pITStream;
    pData->lEventCode = lEventCode;
    pData->lParam1    = lParam1;
    pData->lParam2    = lParam2;
 
     //
    // also pass an addref'ed pointer to IMediaEvent, so that whoever processes
    // the message has the opportunity to free event parameters
    //

    pData->pIMediaEvent = pContext->pIMediaEvent;
    pData->pIMediaEvent->AddRef();

   //
    // Make sure the call and stream don't go away while we handle the event.
    // but use our special inner object addref for the call
    //

    pData->pCall->MSPCallAddRef();
    pData->pITStream->AddRef();

    //
    // Queue an async work item to call ProcessGraphEvent.
    //

    hr = g_Thread.QueueWorkItem(AsyncMultiGraphEvent,
                                (void *) pData,
                                FALSE);  // asynchronous

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "QueueWorkItem failed, return code:%x", hr));

        pData->pCall->MSPCallRelease();
        pData->pITStream->Release();


        //
        // no one is going to free event params and release the IMediaEvent
        // pointer, so do it here
        //

        pContext->pIMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);
        pData->pIMediaEvent->Release();

        delete pData;
    }
}


HRESULT CIPConfMSPCall::InitFullDuplexControler()
/*++

Routine Description:

    This method creates the full-duplex controller object used to control
    audio devices.

Arguments:
    
    NONE

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPCall::InitFullDuplexControler");
    LOG((MSP_TRACE, "%s entered", __fxName));

    CLock lock(m_lock);

    if (m_pIAudioDuplexController != NULL)
    {
        return S_OK;
    }

    HRESULT hr;
    IAudioDuplexController *pIAudioDuplexController;

    if (FAILED(hr = CoCreateInstance(
            __uuidof(TAPIAudioDuplexController),
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            __uuidof(IAudioDuplexController),
            (void **) &pIAudioDuplexController
            )))
    {
        LOG((MSP_ERROR, "%s, create AudioDuplexController failed. hr=%x", 
            __fxName, hr));
        return hr;
    }
    
    m_pIAudioDuplexController = pIAudioDuplexController;

    return S_OK;
}

/*++

Routine Description:

    ITCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::GetRange (
    IN CallQualityProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
{
    return m_pCallQCRelay->GetRange (Property, plMin, plMax, plSteppingDelta, plDefault, plFlags);
}

/*++

Routine Description:

    ITCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::Get (
    IN CallQualityProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
{
    return m_pCallQCRelay->Get (Property, plValue, plFlags);
}

/*++

Routine Description:

    ITCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::Set (
    IN CallQualityProperty Property, 
    IN long lValue, 
    IN TAPIControlFlags lFlags
    )
{
    return m_pCallQCRelay->Set (Property, lValue, lFlags);
}

/*++

Routine Description:

    IInnerCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP_(ULONG)
CIPConfMSPCall::InnerCallAddRef (VOID)
{
    return this->MSPCallAddRef ();
}

STDMETHODIMP_(ULONG)
CIPConfMSPCall::InnerCallRelease (VOID)
{
    return this->MSPCallRelease ();
}

STDMETHODIMP
CIPConfMSPCall::RegisterInnerStreamQC (
    IN  IInnerStreamQualityControl *pIInnerStreamQC
    )
{
    return m_pCallQCRelay->RegisterInnerStreamQC (
        pIInnerStreamQC
        );
}

/*++

Routine Description:

    IInnerCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::DeRegisterInnerStreamQC (
    IN  IInnerStreamQualityControl *pIInnerStreamQC
    )
{
    return m_pCallQCRelay->DeRegisterInnerStreamQC (
        pIInnerStreamQC
        );
}

/*++

Routine Description:

    IInnerCallQualityControl method. Delegated to quality control relay

--*/
STDMETHODIMP
CIPConfMSPCall::ProcessQCEvent (
    IN  QCEvent event,
    IN  DWORD dwParam
    )
{
    return m_pCallQCRelay->ProcessQCEvent (event, dwParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confmsp.cpp ===
// ipconf.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f ipconfps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "confmsp_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IPConfMSP, CIPConfMSP)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        MSPLogRegister(_T("confmsp"));
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    { 
        _Module.Term();
        MSPLogDeRegister();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confpart.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confpart.h

Abstract:

    Definitions for participant related classes..

Author:

    Mu Han (muhan) 30-September-1998

--*/
#ifndef __CONFPART_H
#define __CONFPART_H

const DWORD PART_SEND = 0x0001;
const DWORD PART_RECV = 0x0002;

#define PESTREAM_FULLBITS 0xffffffff

typedef enum PESTREAM_STATE
{
    PESTREAM_RECOVER = 0x00000001,
    PESTREAM_TIMEOUT = 0x00000002

} PESTREAM_STATE;

typedef struct _STREAM_INFO
{
    DWORD       dwSSRC;
    DWORD       dwSendRecv;
    DWORD       dwState;

} STREAM_INFO;

#define NUM_SDES_ITEMS (RTPSDES_PRIV - RTPSDES_FIRST)

class ATL_NO_VTABLE CParticipant : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IDispatchImpl<ITParticipant, &__uuidof(ITParticipant), &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CParticipant)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITParticipant)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    CParticipant(); 

// methods of the CComObject
    virtual void FinalRelease();

// ITParticipant methods, called by the app.
    STDMETHOD (get_ParticipantTypedInfo) (
        IN  PARTICIPANT_TYPED_INFO  InfoType,
        OUT BSTR *                  ppInfo
        );

    STDMETHOD (get_MediaTypes) (
//        IN  TERMINAL_DIRECTION  Direction,
        OUT long *              plMediaTypes
        );

    STDMETHOD (put_Status) (
        IN  ITStream *          pITStream,
        IN  VARIANT_BOOL        fEnable
        );

    STDMETHOD (get_Status) (
        IN  ITStream *          pITStream,
        OUT VARIANT_BOOL *      pStatus
        );

    STDMETHOD (get_Streams) (
        OUT VARIANT * pVariant
        );

    STDMETHOD (EnumerateStreams) (
        OUT IEnumStream ** ppEnumStream
        );

// methods called by the call object.
    HRESULT Init(
        IN  WCHAR *             szCName,
        IN  ITStream *          pITStream, 
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  DWORD               dwMediaType
        );

    BOOL UpdateInfo(
        IN  int                 Type,
        IN  DWORD               dwLen,
        IN  WCHAR *             szInfo
        );

    BOOL UpdateSSRC(
        IN  ITStream *      pITStream, 
        IN  DWORD           dwSSRC,
        IN  DWORD           dwSendRecv
        );

    BOOL HasSSRC(
        IN  ITStream *      pITStream, 
        IN  DWORD           dwSSRC
        );

    BOOL GetSSRC(
        IN  ITStream *      pITStream, 
        OUT DWORD  *        pdwSSRC
        );

    HRESULT AddStream(
        IN  ITStream *          pITStream, 
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  DWORD               dwMediaType
        );

    HRESULT RemoveStream(
        IN  ITStream *          pITStream,
        IN  DWORD               dwSSRC,
        OUT BOOL *              pbLast
        );

    DWORD GetSendRecvStatus(
        IN  ITStream *          pITStream
        );

    HRESULT SetStreamState (
        IN ITStream *       pITStream,
        IN PESTREAM_STATE   state
        );

    HRESULT GetStreamState (
        IN ITStream *       pITStream,
        OUT DWORD *         pdwState
        );

    INT GetStreamCount (DWORD dwSendRecv);

    INT GetStreamTimeOutCount (DWORD dwSendRecv);

    int CompareCName(IN  const WCHAR *   szCName) const
    { return lstrcmpW(m_InfoItems[RTPSDES_CNAME - 1], szCName); }

    const WCHAR * Name() const
    { return m_InfoItems[RTPSDES_CNAME - 1]; }

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *                  m_pFTM;

    // The lock that protects the participant object. 
    CMSPCritSection             m_lock;

    // The list of streams that the participant is rendering on.
    CMSPArray <ITStream *>      m_Streams;

    // The list of SSRC for the partcipant in each stream.
    CMSPArray <STREAM_INFO>     m_StreamInfo;

    // the information items for this participant. The index is the 
    // value of RTP_SDES_* - 1, see MSRTP.h.
    WCHAR *                     m_InfoItems[NUM_SDES_ITEMS];

    // The media types that this participant is sending.
    DWORD                       m_dwSendingMediaTypes;

    // The media types that this participant is receiving.
    DWORD                       m_dwReceivingMediaTypes;
};

class CParticipantList : public CMSPArray<ITParticipant *>
{
public:
    BOOL HasSpace() const { return m_nSize < m_nAllocSize; }

    BOOL FindByCName(WCHAR *szCName, int *pIndex) const;

    BOOL InsertAt(int index, ITParticipant *pITParticipant);
};

class ATL_NO_VTABLE CParticipantEvent : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITParticipantEvent, &__uuidof(ITParticipantEvent), &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CParticipantEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITParticipantEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

    CParticipantEvent(); 

// methods of the CComObject
    virtual void FinalRelease();
    
    STDMETHOD (get_Event) (
        OUT PARTICIPANT_EVENT * pParticipantEvent
        );
    
    STDMETHOD (get_Participant) (
        OUT ITParticipant ** ppITParticipant
        );
    
    STDMETHOD (get_SubStream) (
        OUT ITSubStream** ppSubStream
        );

// methods called by the call object.
    HRESULT Init(
        IN  PARTICIPANT_EVENT   Event,
        IN  ITParticipant *     pITParticipant,
        IN  ITSubStream *       pITSubStream
        );

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;

    PARTICIPANT_EVENT   m_Event;

    ITParticipant *     m_pITParticipant;

    ITSubStream *       m_pITSubStream;
};


class CIPConfMSPCall;

HRESULT CreateParticipantEvent(
    IN  PARTICIPANT_EVENT       Event,
    IN  ITParticipant *         pITParticipant,
    IN  ITSubStream *           pITSubStream,
    OUT IDispatch **            pIDispatch
    );

HRESULT CreateParticipantEnumerator(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    OUT IEnumParticipant ** ppEnumParticipant
    );

HRESULT CreateParticipantCollection(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    IN  int                 nSize,
    OUT VARIANT *           pVariant
    );

#endif // __CONFPART_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confstrm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ConfStrm.h

Abstract:

    Definitions for CIPConfMSPStream class.

Author:

    Mu Han (muhan) 1-November-1997

--*/
#ifndef __CONFSTRM_H
#define __CONFSTRM_H

/////////////////////////////////////////////////////////////////////////////
// CIPConfMSPStream
/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG_REFCOUNT
extern LONG g_lStreamObjects;
#endif

class ATL_NO_VTABLE CIPConfMSPStream :
    public CMSPStream,
    public ITStreamQualityControl,
    public IInnerStreamQualityControl,
    public CMSPObjectSafetyImpl
{

BEGIN_COM_MAP(CIPConfMSPStream)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ITStreamQualityControl)
    COM_INTERFACE_ENTRY(IInnerStreamQualityControl)
    COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
END_COM_MAP()

public:

    CIPConfMSPStream();

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    DWORD   MediaType() const               { return m_dwMediaType; }
    TERMINAL_DIRECTION  Direction() const   { return m_Direction;   }
    
    BOOL IsConfigured();

    virtual HRESULT Configure(
        IN  STREAMSETTINGS &StreamSettings,
        IN  WCHAR *pszKey
        );

    HRESULT FinishConfigure();

    // CMSPStream methods.
    HRESULT ShutDown ();

     // ITStream
    STDMETHOD (get_Name) (
        OUT     BSTR *      ppName
        );

    STDMETHOD (StartStream) ();
    STDMETHOD (PauseStream) ();
    STDMETHOD (StopStream) ();

    STDMETHOD (SelectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   StreamQualityProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   StreamQualityProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // IInnerStreamQualityControl
    //
    STDMETHOD (LinkInnerCallQC) (
        IN  IInnerCallQualityControl *pIInnerCallQC
        );

    STDMETHOD (UnlinkInnerCallQC) (
        IN  BOOL fByStream
        );

    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN  InnerStreamQualityProperty property,
        IN  LONG  lValue1,
        IN  TAPIControlFlags lFlags
        );

    STDMETHOD (Get) (
        IN  InnerStreamQualityProperty property,
        OUT LONG *plValue,
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (TryLockStream)() { return m_lock.TryLock()?S_OK:S_FALSE; }

    STDMETHOD (UnlockStream)() { m_lock.Unlock(); return S_OK; }

    STDMETHOD (IsAccessingQC)() { return m_fAccessingQC?S_OK:S_FALSE; }

    // methods called by the MSPCall object.
    HRESULT Init(
        IN     HANDLE                   hAddress,
        IN     CMSPCallBase *           pMSPCall,
        IN     IMediaEvent *            pGraph,
        IN     DWORD                    dwMediaType,
        IN     TERMINAL_DIRECTION       Direction
        );

    HRESULT SetLocalParticipantInfo(
        IN      PARTICIPANT_TYPED_INFO  InfoType,
        IN      WCHAR *                 pInfo,
        IN      DWORD                   dwLen
        );

    // Called by stream and substream to send event to tapi.
    virtual HRESULT SendStreamEvent(
        IN      MSP_CALL_EVENT          Event,
        IN      MSP_CALL_EVENT_CAUSE    Cause,
        IN      HRESULT                 hrError,
        IN      ITTerminal *            pTerminal
        );

    // Called by the participant object.
    virtual HRESULT EnableParticipant(
        IN  DWORD   dwSSRC,
        IN  BOOL    fEnable
        );

    virtual HRESULT GetParticipantStatus(
        IN  DWORD   dwSSRC,
        IN  BOOL *  pfEnable
        );

protected:
    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    virtual HRESULT CheckTerminalTypeAndDirection(
        IN      ITTerminal *    pTerminal
        );

    virtual HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        ) = 0;

    virtual HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    virtual HRESULT SetUpFilters() = 0;
    virtual HRESULT CleanUpFilters();

    HRESULT EnableParticipantEvents(
        IN IRtpSession * pRtpSession
        );

    HRESULT EnableQOS(
        IN IRtpSession * pRtpSession
        );

    HRESULT EnableEncryption(
        IN IRtpSession * pRtpSession,
        IN WCHAR *pPassPhrase
        );

    HRESULT ConfigureRTPFilter(
        IN  IBaseFilter *   pIBaseFilter
        );

    virtual HRESULT ProcessParticipantTimeOutOrRecovered(
        IN  BOOL    fTimeOutOrRecovered,
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessSDESUpdate(
        IN  DWORD   dwInfoItem,
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessQOSEvent(
        IN  long    lEventCode
        );

    virtual HRESULT ProcessTalkingEvent(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessWasTalkingEvent(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessSilentEvent(
        IN  DWORD   dwSSRC
        );

    virtual HRESULT ProcessPinMappedEvent(
        IN  DWORD   dwSSRC,
        IN  IPin *  pIPin
        );

    virtual HRESULT ProcessPinUnmapEvent(
        IN  DWORD   dwSSRC,
        IN  IPin *  pIPin
        );

    virtual HRESULT ProcessNewParticipant(
        IN  int                 index,
        IN  DWORD               dwSSRC,
        IN  DWORD               dwSendRecv,
        IN  WCHAR *              szCName,
        OUT ITParticipant **    ppITParticipant
        );

    virtual HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

    virtual HRESULT SetLocalInfoOnRTPFilter(
        IN  IBaseFilter *   pRTPFilter
        );

protected:
    const WCHAR *       m_szName;

    BOOL                m_fIsConfigured;
    STREAMSETTINGS      m_Settings;

    IRtpDemux *         m_pIRTPDemux;
    IRtpSession *       m_pIRTPSession;
    IStreamConfig *     m_pIStreamConfig;

    // The list of participant in the stream.
    CParticipantList    m_Participants;

    // Callback interface to the quality controller.
    CStreamQualityControlRelay * m_pStreamQCRelay;

    // the local info needed to be set on the RTP filter.
    WCHAR *             m_InfoItems[NUM_SDES_ITEMS];
    WCHAR *             m_szKey;

    // flag will be set when stream is accessing quality control methods
    // that will in turn lock the stream list lock inside quality control.
    BOOL                m_fAccessingQC;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confpart.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confpart.cpp

Abstract:

    This module contains implementation of the participant classes.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"
#include "confpart.h"

#ifdef DEBUG_REFCOUNT

ULONG CParticipant::InternalAddRef()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();

    LOG((MSP_TRACE, "%p, %ws Addref, ref = %d", 
        this, (m_InfoItems[0]) ? m_InfoItems[0] : L"new participant", lRef));

    return lRef;
}

ULONG CParticipant::InternalRelease()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
    
    LOG((MSP_TRACE, "%p, %ws Release, ref = %d", 
        this, (m_InfoItems[0]) ? m_InfoItems[0] : L"new participant", lRef));

    return lRef;
}
#endif

CParticipant::CParticipant()
    : m_pFTM(NULL),
      m_dwSendingMediaTypes(0),
      m_dwReceivingMediaTypes(0)
{
    // initialize the info item array.
    ZeroMemory(m_InfoItems, sizeof(WCHAR *) * (NUM_SDES_ITEMS));
}

// methods called by the call object.
HRESULT CParticipant::Init(
    IN  WCHAR *             szCName,
    IN  ITStream *          pITStream, 
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  DWORD               dwMediaType
    )
/*++

Routine Description:

    Initialize the participant object.

Arguments:
    
    szCName - the canonical name of the participant.

    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    dwSendRecv - a sender or a receiver.

    dwMediaType - the media type of the participant.

Return Value:

    S_OK,
    E_OUTOFMEMORY.

--*/
{
    LOG((MSP_TRACE, "CParticipant::Init, name:%ws", szCName));

    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    m_InfoItems[0] = (WCHAR *)malloc((lstrlenW(szCName) + 1) * sizeof(WCHAR));
    if (m_InfoItems[0] == NULL)
    {
        LOG((MSP_ERROR, "out of mem for CName"));
        return E_OUTOFMEMORY;
    }

    lstrcpyW(m_InfoItems[0], szCName);

    // add the stream into out list.
    hr = AddStream(pITStream, dwSSRC, dwSendRecv, dwMediaType);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "failed to add stream %x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CParticipant: %ws, Init returns S_OK", szCName));
    return S_OK;
}

BOOL CParticipant::UpdateInfo(
    IN  int                 Type,
    IN  DWORD               dwLen,
    IN  WCHAR *             szInfo
    )
/*++

Routine Description:

    Update one item of the participant info.

Arguments:
    
    Type - the type of the INFO, 
    
    dwLen - the length of the information.

    szInfo - the information.

Return Value:

    TRUE - information changed.

    FALSE - the information is the same, no change was made.

--*/
{
    int index = Type - 1;

    // if we have an item already, find out if it is the same.
    if (m_InfoItems[index] != NULL)
    {
        if (lstrcmpW(m_InfoItems[index], szInfo) == 0)
        {
            return FALSE;
        }

        // if the item is new, free the old one
        free(m_InfoItems[index]);
    }

    // allocate memory and store it.
    m_InfoItems[index] = (WCHAR *)malloc((dwLen + 1) * sizeof(WCHAR));
    if (m_InfoItems[index] == NULL)
    {
        return FALSE;
    }

    lstrcpynW(m_InfoItems[index], szInfo, dwLen);

    return TRUE;
}

BOOL CParticipant::UpdateSSRC(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC,
    IN  DWORD           dwSendRecv
    )
/*++

Routine Description:

    Update the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    dwSSRC - the SSRC of the participant.

    dwSendRecv - the participant is a sender or a receiver.

Return Value:

    TRUE - information changed.

    FALSE - the stream is not found.

--*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        m_StreamInfo[index].dwSSRC  = dwSSRC;
        m_StreamInfo[index].dwSendRecv |= dwSendRecv;
        return TRUE;
    }

    return FALSE;
}

BOOL CParticipant::HasSSRC(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC
    )
/*++

Routine Description:

    find out if the participant has the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    dwSSRC - the SSRC of the participant.

Return Value:

    TRUE - the SSRC exists.

    FALSE - the SSRC does not exist.

--*/
{
    CLock lock(m_lock);

    int index = m_Streams.Find(pITStream);
    if (index >= 0)
    {
        return (m_StreamInfo[index].dwSSRC == dwSSRC);
    }

    return FALSE;
}

BOOL CParticipant::GetSSRC(
    IN  ITStream *      pITStream, 
    OUT DWORD  *        pdwSSRC
    )
/*++

Routine Description:

    Update the SSRC for a stream.

Arguments:
    
    pITStream - the stream that the participant is on.

    pdwSSRC - the address to store the SSRC of the participant.

Return Value:

    TRUE - the SSRC is found.

    FALSE - the SSRC is not found.

--*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        *pdwSSRC = m_StreamInfo[index].dwSSRC;
        return TRUE;
    }

    return FALSE;
}

DWORD CParticipant::GetSendRecvStatus(
    IN  ITStream *      pITStream
    )
/*++

Routine Description:

    find out the current send and recv status on a given stream.

Arguments:
    
    pITStream - the stream that the participant is on.

Return Value:

    A bit mask of send and receive status

--*/
{
    CLock lock(m_lock);

    int index = m_Streams.Find(pITStream);
    if (index >= 0)
    {
        return m_StreamInfo[index].dwSendRecv;
    }

    return 0;
}

void CParticipant::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CParticipant::FinalRelease, name %ws", m_InfoItems[0]));

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        if (m_InfoItems[i])
        {
            free(m_InfoItems[i]);
        }
    }

    for (i = 0; i < m_Streams.GetSize(); i ++)
    {
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();

    LOG((MSP_TRACE, "CParticipant::FinalRelease - exit"));
}


// ITParticipant methods, called by the app.
STDMETHODIMP CParticipant::get_ParticipantTypedInfo(
    IN  PARTICIPANT_TYPED_INFO  InfoType,
    OUT BSTR *                  ppInfo
    )
/*++

Routine Description:

    Get a information item for this participant.

Arguments:
    
    InfoType - The type of the information asked.

    ppInfo  - the mem address to store a BSTR.

Return Value:

    S_OK,
    E_INVALIDARG,
    E_POINTER,
    E_OUTOFMEMORY,
    TAPI_E_NOITEMS
*/
{
    LOG((MSP_TRACE, "CParticipant get info, type:%d", InfoType));
    
    if (InfoType > PTI_PRIVATE || InfoType < PTI_CANONICALNAME)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit invalid arg"));
        return E_INVALIDARG;
    }

    if (IsBadWritePtr(ppInfo, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CParticipant get info - exit E_POINTER"));
        return E_POINTER;
    }

    // check if we have that info.
    CLock lock(m_lock);
    
    int index = (int)InfoType; 
    if (m_InfoItems[index] == NULL)
    {
        LOG((MSP_INFO, "CParticipant get info - no item for %d", InfoType));
        return TAPI_E_NOITEMS;
    }

   // make a BSTR out of it.
    BSTR pName = SysAllocString(m_InfoItems[index]);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CParticipant get info - exit out of mem"));
        return E_OUTOFMEMORY;
    }

    // return the BSTR.
    *ppInfo = pName;

    return S_OK; 
}

STDMETHODIMP CParticipant::get_MediaTypes(
//    IN  TERMINAL_DIRECTION  Direction,
    OUT long *  plMediaTypes
    )
/*++

Routine Description:

    Get the media type of the participant

Arguments:
    
    plMediaType - the mem address to store a long.

Return Value:

    S_OK,
    E_POINTER,
*/
{
    LOG((MSP_TRACE, "CParticipant::get_MediaTypes - enter"));

    if (IsBadWritePtr(plMediaTypes, sizeof (long)))
    {
        LOG((MSP_ERROR, "CParticipant::get_MediaType - exit E_POINTER"));

        return E_POINTER;
    }

    CLock lock(m_lock);

#if 0
    if (Direction == TD_RENDER)
    {
        *plMediaTypes = (long)m_dwReceivingMediaTypes;
    }
    else
    {
        *plMediaTypes = (long)m_dwSendingMediaTypes;
    }
#endif

    *plMediaTypes = (long)(m_dwSendingMediaTypes | m_dwReceivingMediaTypes);

    LOG((MSP_TRACE, "CParticipant::get_MediaType:%x - exit S_OK", *plMediaTypes));

    return S_OK;
}


STDMETHODIMP CParticipant::put_Status(
    IN  ITStream *      pITStream,
    IN  VARIANT_BOOL    fEnable
    )
{
    ENTER_FUNCTION("CParticipant::put_Status");
    LOG((MSP_TRACE, "%s entered. %hs %ws for %p", 
        __fxName, fEnable ? "Enable" : "Disable", m_InfoItems[0], pITStream));

    HRESULT hr;

    // if the caller specified a stream, find the stream and use it.
    if (pITStream != NULL)
    {
        m_lock.Lock();

        int index;
        if ((index = m_Streams.Find(pITStream)) < 0)
        {
            m_lock.Unlock();
            
            LOG((MSP_ERROR, "%s stream %p not found", __fxName, pITStream));

            return E_INVALIDARG;
        }
        DWORD dwSSRC = m_StreamInfo[index].dwSSRC;

        // add ref so that it won't go away.
        pITStream->AddRef();

        m_lock.Unlock();

        hr = ((CIPConfMSPStream *)pITStream)->EnableParticipant(
            dwSSRC,
            fEnable
            );

        pITStream->Release();

        return hr;
    }

    // if the caller didn't specify a stream, set the status on all streams.
    m_lock.Lock();
    int nSize = m_Streams.GetSize();
    ITStream ** Streams = (ITStream **)malloc(sizeof(ITStream*) * nSize);

    if (Streams == NULL)
    {
        m_lock.Unlock();
        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    DWORD * pdwSSRCList = (DWORD *)malloc(sizeof(DWORD) * nSize);

    if (pdwSSRCList == NULL)
    {
        m_lock.Unlock();
        
        free(Streams);

        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    for (int i = 0; i < nSize; i ++)
    {
        Streams[i] = m_Streams[i];
        Streams[i]->AddRef();
        pdwSSRCList[i] = m_StreamInfo[i].dwSSRC;
    }
    m_lock.Unlock();

    for (i = 0; i < nSize; i ++)
    {
        hr = ((CIPConfMSPStream *)Streams[i])->
            EnableParticipant(pdwSSRCList[i], fEnable);

        if (FAILED(hr))
        {
            break;
        }
    }

    for (i = 0; i < nSize; i ++)
    {
        Streams[i]->Release();
    }

    free(Streams);
    free(pdwSSRCList);

    return hr;
}

STDMETHODIMP CParticipant::get_Status(
    IN  ITStream *      pITStream,
    OUT VARIANT_BOOL *  pfEnable
    )
{
    ENTER_FUNCTION("CParticipant::get_Status");
    LOG((MSP_TRACE, "%s entered. %ws %p", 
        __fxName, m_InfoItems[0], pITStream));

    if (IsBadWritePtr(pfEnable, sizeof(VARIANT_BOOL)))
    {
        LOG((MSP_ERROR, "%s bad pointer argument - exit E_POINTER", __fxName));

        return E_POINTER;
    }

    HRESULT hr;
    BOOL fEnable;

    // if the caller specified a stream, find the stream and use it.
    if (pITStream != NULL)
    {
        m_lock.Lock();

        int index;
        if ((index = m_Streams.Find(pITStream)) < 0)
        {
            m_lock.Unlock();
            
            LOG((MSP_ERROR, "%s stream %p not found", __fxName, pITStream));

            return E_INVALIDARG;
        }
        DWORD dwSSRC = m_StreamInfo[index].dwSSRC;

        // add ref so that it won't go away.
        pITStream->AddRef();

        m_lock.Unlock();

        hr = ((CIPConfMSPStream *)pITStream)->GetParticipantStatus(
            dwSSRC,
            &fEnable
            );

        pITStream->Release();

        *pfEnable = (fEnable) ? VARIANT_TRUE : VARIANT_FALSE;

        return hr;
    }

    // if the caller didn't specify a stream, get the status from all streams.
    m_lock.Lock();
    int nSize = m_Streams.GetSize();
    ITStream ** Streams = (ITStream **)malloc(sizeof(ITStream*) * nSize);

    if (Streams == NULL)
    {
        m_lock.Unlock();
        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    DWORD * pdwSSRCList = (DWORD *)malloc(sizeof(DWORD) * nSize);

    if (pdwSSRCList == NULL)
    {
        m_lock.Unlock();
        
        free(Streams);

        LOG((MSP_ERROR, "%s out of memory", __fxName));
        return E_OUTOFMEMORY;
    }

    for (int i = 0; i < nSize; i ++)
    {
        Streams[i] = m_Streams[i];
        Streams[i]->AddRef();
        pdwSSRCList[i] = m_StreamInfo[i].dwSSRC;
    }
    m_lock.Unlock();

    fEnable = FALSE;

    for (i = 0; i < nSize; i ++)
    {
        BOOL fEnabledOnStream;
        hr = ((CIPConfMSPStream *)Streams[i])->
            GetParticipantStatus(pdwSSRCList[i], &fEnabledOnStream);

        if (FAILED(hr))
        {
            break;
        }

        // as long as it is enabled on one stream, it is enabled.
        fEnable = fEnable || fEnabledOnStream;
    }

    for (i = 0; i < nSize; i ++)
    {
        Streams[i]->Release();
    }

    free(Streams);
    free(pdwSSRCList);

    *pfEnable = (fEnable) ? VARIANT_TRUE : VARIANT_FALSE;
    return hr;
}

STDMETHODIMP CParticipant::EnumerateStreams(
    OUT     IEnumStream **      ppEnumStream
    )
{
    LOG((MSP_TRACE, 
        "EnumerateStreams entered. ppEnumStream:%x", ppEnumStream));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //
    typedef _CopyInterface<ITStream> CCopy;
    typedef CSafeComEnum<IEnumStream, &__uuidof(IEnumStream), 
                ITStream *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the __uuidof(IEnumStream) i/f
    //

    hr = pEnum->_InternalQueryInterface(__uuidof(IEnumStream), (void**)ppEnumStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        m_Streams.GetData(),                        // the begin itor
        m_Streams.GetData() + m_Streams.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CParticipant::EnumerateStreams - "
            "init enumerator object failed, %x", hr));

        (*ppEnumStream)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CParticipant::EnumerateStreams - exit S_OK"));

    return hr;
}

STDMETHODIMP CParticipant::get_Streams(
    OUT     VARIANT *           pVariant
    )
{
    LOG((MSP_TRACE, "CParticipant::get_Streams - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //
    typedef CTapiIfCollection< ITStream * > StreamCollection;
    CComObject<StreamCollection> * pCollection;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_Streams.GetSize(),
                                  m_Streams.GetData(),
                                  m_Streams.GetData() + m_Streams.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CParticipant::get_Streams - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_INFO, "CParticipant::get_Streams - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CParticipant::get_Streams - exit S_OK"));
    return S_OK;
}

HRESULT CParticipant::AddStream(
    IN  ITStream *      pITStream, 
    IN  DWORD           dwSSRC,
    IN  DWORD           dwSendRecv,
    IN  DWORD           dwMediaType
    )
/*++

Routine Description:

    A participant might appear on more than one streams. This function adds
    a new stream and the SSRC into the participant's list.

Arguments:
    
    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    dwSendRecv - the participant is a sender or receiver in the stream.

    dwMediaType - the media type of the stream.

Return Value:

    S_OK,
    E_OUTOFMEMORY,
*/
{
    CLock lock(m_lock);

    // if the stream is already there, update the SSRC and return.
    int index = m_Streams.Find(pITStream);
    if ( index >= 0)
    {
        m_StreamInfo[index].dwSSRC = dwSSRC;
        m_StreamInfo[index].dwSendRecv |= dwSendRecv;
        return S_OK;
    }

    // add the stream.
    if (!m_Streams.Add(pITStream))
    {
        return E_OUTOFMEMORY;
    }
    
    // add the SSRC and sender flag.
    STREAM_INFO Info;
    Info.dwSSRC = dwSSRC;
    Info.dwSendRecv = dwSendRecv;
    Info.dwState = PESTREAM_RECOVER;

    if (!m_StreamInfo.Add(Info))
    {
        m_Streams.Remove(pITStream);

        return E_OUTOFMEMORY;
    }

    pITStream->AddRef();

    // update the mediatype.
    if (dwSendRecv & PART_SEND)
    {
        m_dwSendingMediaTypes |= dwMediaType;
    }
    if (dwSendRecv & PART_RECV)
    {
        m_dwReceivingMediaTypes |= dwMediaType;
    }

    return S_OK;
}

HRESULT CParticipant::RemoveStream(
    IN  ITStream *  pITStream,
    IN  DWORD       dwSSRC,
    OUT BOOL *      pbLast
    )
/*++

Routine Description:

    A participant might appear on more than one streams. This function remove
    a stream from the participant's list.

Arguments:
    
    pITStream - the stream that has the participant.

    dwSSRC - the SSRC of the participant in that stream.

    pbLast - the memory space to store a boolean value, specifying if the 
             stream removed was the last one in the list.

Return Value:

    S_OK,
    E_POINTER,
*/
{
    CLock lock(m_lock);
    
    // first find the stream.
    int index = m_Streams.Find(pITStream);

    if (index < 0)
    {
        return E_FAIL;
    }
    
    if (m_Streams.GetSize()  != m_StreamInfo.GetSize())
    {
        return E_UNEXPECTED;
    }

    // then check the SSRC.
    if (m_StreamInfo[index].dwSSRC != dwSSRC)
    {
        // this is not the participant being looking for.
        return E_FAIL;
    }

    // SSRC match, we found the participant. remove the stream and info.
    m_Streams.RemoveAt(index);
    m_StreamInfo.RemoveAt(index);

    // release the refcount we had in the list.
    pITStream->Release();

    // recalculate the media types.
    m_dwSendingMediaTypes = 0;
    m_dwReceivingMediaTypes = 0;
    
    for (int i = 0; i < m_Streams.GetSize(); i ++)
    {
        if (m_StreamInfo[i].dwSendRecv & PART_SEND)
        {
            m_dwSendingMediaTypes |= ((CIPConfMSPStream *)m_Streams[i])->MediaType();
        }

        if (m_StreamInfo[i].dwSendRecv & PART_RECV)
        {
            m_dwReceivingMediaTypes |= ((CIPConfMSPStream *)m_Streams[i])->MediaType();
        }
    }

    *pbLast = (m_Streams.GetSize() == 0);

    return S_OK;
}

HRESULT CParticipant::SetStreamState (
    IN ITStream *       pITStream,
    IN PESTREAM_STATE   state
    )
/*++

Routine Description:

    Sets the state on stream.

--*/
{
    CLock lock(m_lock);

    // first find the stream.
    int index = m_Streams.Find(pITStream);
    if (index < 0)
        return E_FAIL;
    
    if (m_Streams.GetSize()  != m_StreamInfo.GetSize())
        return E_UNEXPECTED;

    DWORD dw = m_StreamInfo[index].dwState;

    switch (state)
    {
    case PESTREAM_RECOVER:
        // set recover
        dw |= PESTREAM_RECOVER;
        // clear timeout bit
        dw |= PESTREAM_TIMEOUT;
        dw &= (PESTREAM_TIMEOUT ^ PESTREAM_FULLBITS);
        break;

    case PESTREAM_TIMEOUT:
        // set timeout
        dw |= PESTREAM_TIMEOUT;
        // clear recover bit
        dw |= PESTREAM_RECOVER;
        dw &= (PESTREAM_RECOVER ^ PESTREAM_FULLBITS);
        break;

    default:
        LOG ((MSP_ERROR, "unknown stream state. %x", state));
        return E_INVALIDARG;
    }

    m_StreamInfo[index].dwState = dw;
    return S_OK;
}

HRESULT CParticipant::GetStreamState (
    IN ITStream *       pITStream,
    OUT DWORD *         pdwState
    )
/*++

Routine Description:

    Gets the state on stream.

--*/
{
    CLock lock(m_lock);

    // first find the stream.
    int index = m_Streams.Find(pITStream);
    if (index < 0)
        return E_FAIL;
    
    if (m_Streams.GetSize()  != m_StreamInfo.GetSize())
        return E_UNEXPECTED;

    *pdwState = m_StreamInfo[index].dwState;

    return S_OK;
}

INT CParticipant::GetStreamCount (DWORD dwSendRecv)
{
    // this is called by ourself
    _ASSERTE ((dwSendRecv & PART_SEND) || (dwSendRecv & PART_RECV));

    CLock lock(m_lock);

    int i, count = 0;

    for (i=0; i<m_StreamInfo.GetSize (); i++)
    {
        if (m_StreamInfo[i].dwSendRecv & dwSendRecv)
            count ++;
    }

    return count;
}

INT CParticipant::GetStreamTimeOutCount (DWORD dwSendRecv)
{
    // this is called by ourself
    _ASSERTE ((dwSendRecv & PART_SEND) || (dwSendRecv & PART_RECV));

    CLock lock(m_lock);

    int i, count = 0;

    for (i=0; i<m_StreamInfo.GetSize (); i++)
    {
        if ((m_StreamInfo[i].dwSendRecv & dwSendRecv) &&
            (m_StreamInfo[i].dwState & PESTREAM_TIMEOUT))
            count ++;
    }

    return count;
}

BOOL CParticipantList::FindByCName(WCHAR *szCName, int *pIndex) const
/*++

Routine Description:

    Find a participant by its canonical name. If the function returns true,
    *pIndex contains the index of the participant. If the function returns
    false, *pIndex contains the index where the new participant should be
    inserted.

Arguments:
    
    szCName - the canonical name of the participant.

    pIndex - the memory address to store an integer.

Return Value:

    TRUE - the participant is found.

    FALSE - the participant is not in the list.
*/
{
    for(int i = 0; i < m_nSize; i++)
    {
        // This list is an ordered list based on dictionary order. We are using
        // a linear search here, it could be changed to a binary search.

        // CompareCName will return 0 if the name is the same, <0 if the szCName
        // is bigger, >0 if the szCName is smaller.
        int res = ((CParticipant *)m_aT[i])->CompareCName(szCName);
        if(res >= 0) 
        {
            *pIndex = i;
            return (res == 0);
        }
    }
    *pIndex = m_nSize;
    return FALSE;   // not found
}

BOOL CParticipantList::InsertAt(int nIndex, ITParticipant *pITParticipant)
/*++

Routine Description:

    Insert a participant into the list at a given index.

Arguments:
    
    nIndex - the location where the new object is inserted.

    pITParticipant - the object to be inserted.

Return Value:

    TRUE - the participant is inserted.

    FALSE - out of memory.
*/
{
    _ASSERTE(nIndex >= 0 && nIndex <= m_nSize);
    if(m_nSize == m_nAllocSize)
    {
        if (!Grow()) return FALSE;
    }

    memmove((void*)&m_aT[nIndex+1], (void*)&m_aT[nIndex], 
        (m_nSize - nIndex) * sizeof(ITParticipant *));

    m_nSize++;

    SetAtIndex(nIndex, pITParticipant);

    return TRUE;
}

CParticipantEvent::CParticipantEvent()
    : m_pFTM(NULL),
      m_pITParticipant(NULL),
      m_pITSubStream(NULL),
      m_Event(PE_NEW_PARTICIPANT)
{}

// methods called by the call object.
HRESULT CParticipantEvent::Init(
    IN  PARTICIPANT_EVENT   Event,
    IN  ITParticipant *     pITParticipant,
    IN  ITSubStream *       pITSubStream
    )
/*++

Routine Description:

    Initialize the ParticipantEvent object.

Arguments:
    
    Event - the event.

    pITParticipant - the participant.

    pITSubStream - the substream, can be NULL.

Return Value:

    S_OK,

--*/
{
    LOG((MSP_TRACE, "CParticipantEvent::Init"));

    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    m_Event             = Event;
    
    m_pITParticipant    = pITParticipant;
    if (m_pITParticipant) m_pITParticipant->AddRef();

    m_pITSubStream      = pITSubStream;
    if (m_pITSubStream) m_pITSubStream->AddRef();

    LOG((MSP_TRACE, "CParticipantEvent Init returns S_OK"));
    return S_OK;
}

void CParticipantEvent::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CParticipantEvent::FinalRelease - enter"));

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    if (m_pITParticipant) m_pITParticipant->Release();

    if (m_pITSubStream) m_pITSubStream->Release();

    LOG((MSP_TRACE, "CParticipantEvent::FinalRelease - exit"));
}

STDMETHODIMP CParticipantEvent::get_Event(
    OUT PARTICIPANT_EVENT * pParticipantEvent
    )
{
    if (IsBadWritePtr(pParticipantEvent, sizeof (PARTICIPANT_EVENT)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_Event - exit E_POINTER"));

        return E_POINTER;
    }

    *pParticipantEvent = m_Event;

    return S_OK;
}

STDMETHODIMP CParticipantEvent::get_Participant(
    OUT ITParticipant ** ppITParticipant
    )
{
    if (IsBadWritePtr(ppITParticipant, sizeof (void *)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_participant - exit E_POINTER"));

        return E_POINTER;
    }

    if (!m_pITParticipant)
    {
        // LOG((MSP_ERROR, "CParticipantevnt::get_Participant - exit no item"));
        return TAPI_E_NOITEMS;
    }

    m_pITParticipant->AddRef();
    *ppITParticipant = m_pITParticipant;

    return S_OK;
}

STDMETHODIMP CParticipantEvent::get_SubStream(
    OUT ITSubStream** ppSubStream
    )
{
    if (IsBadWritePtr(ppSubStream, sizeof (void *)))
    {
        LOG((MSP_ERROR, "CParticipantEvent::get_SubStream - exit E_POINTER"));

        return E_POINTER;
    }

    if (!m_pITSubStream)
    {
        LOG((MSP_WARN, "CParticipantevnt::get_SubStream - exit no item"));
        return TAPI_E_NOITEMS;
    }

    m_pITSubStream->AddRef();
    *ppSubStream = m_pITSubStream;

    return S_OK;
}

HRESULT CreateParticipantEvent(
    IN  PARTICIPANT_EVENT       Event,
    IN  ITParticipant *         pITParticipant,
    IN  ITSubStream *           pITSubStream,
    OUT IDispatch **            ppIDispatch
    )
{
    // create the object.
    CComObject<CParticipantEvent> * pCOMParticipantEvent;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCOMParticipantEvent);

    if (NULL == pCOMParticipantEvent)
    {
        LOG((MSP_ERROR, "could not create participant event:%x", hr));
        return hr;
    }

    IDispatch * pIDispatch;

    // get the interface pointer.
    hr = pCOMParticipantEvent->_InternalQueryInterface(
        __uuidof(IDispatch), 
        (void **)&pIDispatch
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create ParticipantEvent QueryInterface failed: %x", hr));
        delete pCOMParticipantEvent;
        return hr;
    }

    // Initialize the object.
    hr = pCOMParticipantEvent->Init(
        Event,
        pITParticipant,
        pITSubStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPParticipantEvent:call init failed: %x", hr));
        pIDispatch->Release();

        return hr;
    }

    *ppIDispatch = pIDispatch;
    
    return S_OK;
}

HRESULT CreateParticipantEnumerator(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    OUT IEnumParticipant ** ppEnumParticipant
    )
{
    //
    // Create an enumerator object.
    //

    typedef _CopyInterface<ITParticipant> CCopy;
    typedef CSafeComEnum<IEnumParticipant, &__uuidof(IEnumParticipant), 
                ITParticipant *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the __uuidof(IEnumParticipant) i/f
    //

    hr = pEnum->_InternalQueryInterface(
        __uuidof(IEnumParticipant), 
        (void**)ppEnumParticipant
        );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        begin,                        // the begin itor
        end,  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantEnumerator - "
            "init enumerator object failed, %x", hr));

        (*ppEnumParticipant)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CreateParticipantEnumerator - exit S_OK"));

    return hr;
}

HRESULT CreateParticipantCollection(
    IN  ITParticipant **    begin,
    IN  ITParticipant **    end,
    IN  int                 nSize,
    OUT VARIANT *           pVariant
    )
{
    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITParticipant * > ParticipantCollection;
    CComObject<ParticipantCollection> * pCollection;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateParticipantCollection - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateParticipantCollection - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize(nSize, begin, end);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateParticipantCollection- "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CreateParticipantCollection - exit S_OK"));
 
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confstrm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confstrm.cpp

Abstract:

    This module contains implementation of CMSPStream. The object represents
    one stream in the filter graph.

Author:

    Mu Han (muhan)   1-November-1997

--*/

#include "stdafx.h"

/*  State Transition Table


States:

RO   - Running whithout terminal. This is the initial state.
PO   - Paused without terminal
SO   - Stopped without terminal.
RT   - Runing with terminal.
PT   - Paused with termianl.
ST   - Stopped with terminal.

Actions:
S   - Stop graph.
P   - Pause graph.
C   - Change graph.
D   - Disonnect terminals.
F   - Free extra references to filters and terminals.
R   - Run Graph.
NIU - Not in use.

Note: the same graph operation can be called multiple times, the graph
just returns S_OK if it is already in desired state.

NOTE: if the stream is not configured, the transition will happen without
really doing anything to the graph.

CONFIG will only be called for NC streams.

        CONFIG  Select  Unselect    Run     Pause   Stop    ShutDown

RO      OK      C/R     FAIL        OK      OK      OK      F
        RO       RT      RO         RO      PO      SO      -

PO      OK      C/P     FAIL        OK      OK      OK      F
        PO       PT      PO         RO      PO      SO      -

SO      OK      C       FAIL        OK      OK      OK      F
        SO       ST      SO         RO      PO      SO      -

RT      C/R     S/C/R   S/C/(R)     R       P       S       S/D/F
        RT       RT     RT,RO       RT      PT      ST      -

PT      C/P     S/C/P   S/C/(P)     R       P       S       S/D/F
        PT       PT     PT,PO       RT      PT      ST      -

ST      C       C       C           R       P       S       D/F
        ST       ST     ST,SO       RT      PT      ST      -

*/

CIPConfMSPStream::CIPConfMSPStream()
    : CMSPStream(),
    m_szName(L""),
    m_fIsConfigured(FALSE),
    m_pIRTPSession(NULL),
    m_pIRTPDemux(NULL),
    m_pIStreamConfig(NULL),
    m_szKey(NULL),
    m_pStreamQCRelay(NULL),
    m_fAccessingQC(FALSE)
{
    // The default state is always running.
    m_dwState   = STRM_RUNNING;
    ZeroMemory(m_InfoItems, sizeof(m_InfoItems));
    ZeroMemory(&m_Settings, sizeof(m_Settings));
}

#ifdef DEBUG_REFCOUNT
LONG g_lStreamObjects = 0;

ULONG CIPConfMSPStream::InternalAddRef()
{
    InterlockedIncrement(&g_lStreamObjects);
    
    ULONG lRef = CMSPStream::InternalAddRef();
    
    LOG((MSP_TRACE, "%ws Addref, ref = %d", m_szName, lRef));

    return lRef;
}

ULONG CIPConfMSPStream::InternalRelease()
{
    InterlockedDecrement(&g_lStreamObjects);

    ULONG lRef = CMSPStream::InternalRelease();
    
    LOG((MSP_TRACE, "%ws Release, ref = %d", m_szName, lRef));

    return lRef;
}
#endif

BOOL CIPConfMSPStream::IsConfigured()
{
    CLock lock(m_lock);
    return m_fIsConfigured;
}

// methods called by the MSPCall object.
HRESULT CIPConfMSPStream::Init(
    IN     HANDLE                   hAddress,
    IN     CMSPCallBase *           pMSPCall,
    IN     IMediaEvent *            pGraph,
    IN     DWORD                    dwMediaType,
    IN     TERMINAL_DIRECTION       Direction
    )
/*++

Routine Description:
    Initialize the stream object.

Arguments:

    hAddress    - a handle to the address, used in identify terminals.

    pMSPCall    - the call object that owns the stream.

    pIGraphBuilder - the filter graph object.

    dwMediaType - the mediatype of this stream.

    Direction  - the direction of this stream.

Return Value:
    
    S_OK,
    E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream::Init - enter"));

    // initialize the participant array so that the array is not NULL.
    if (!m_Participants.Grow())
    {
        LOG((MSP_ERROR, "out of mem for participant list"));
        return E_OUTOFMEMORY;
    }

    return CMSPStream::Init(
        hAddress, pMSPCall, pGraph, dwMediaType, Direction
        );
}

HRESULT CIPConfMSPStream::SetLocalParticipantInfo(
    IN      PARTICIPANT_TYPED_INFO  InfoType,
    IN      WCHAR *                 pInfo,
    IN      DWORD                   dwStringLen
    )
/*++

Routine Description:

    Get the name of this stream.

Arguments:
    
    InfoType    - the type of the information item.

    pInfo       - the string containing the info.

    dwStringLen - the length of the string(not including EOS).

Return Value:

    HRESULT.
*/
{
    CLock lock(m_lock);

    //
    // Save the information localy first.
    //
    int index = (int)InfoType; 
    if (m_InfoItems[index] != NULL)
    {
        free(m_InfoItems[index]);
    }

    m_InfoItems[index] = (WCHAR *)malloc((dwStringLen + 1)* sizeof(WCHAR));

    if (m_InfoItems[index] == NULL)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpynW(m_InfoItems[index], pInfo, dwStringLen + 1);

    if (!m_pIRTPSession)
    {
        return S_OK;
    }

    //
    // if the RTP filter has been created, apply the change to the fitler.
    //

    HRESULT hr = m_pIRTPSession->SetSdesInfo(
            RTPSDES_CNAME + index,
            pInfo
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't set item:%s", m_szName, pInfo));
    }

    return hr;
}

STDMETHODIMP CIPConfMSPStream::get_Name(
    OUT     BSTR *                  ppName
    )
/*++

Routine Description:

    Get the name of this stream.

Arguments:
    
    ppName  - the mem address to store a BSTR.

Return Value:

    HRESULT.

*/
{
    LOG((MSP_TRACE, "CIPconfMSPStream::get_Name - enter"));
    
    if (IsBadWritePtr(ppName, sizeof(BSTR)))
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit E_POINTER"));
        return E_POINTER;
    }

    DWORD dwID;

    if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_AUDIO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_AUDIO_RENDER_STREAM;
        }
    }
    else
    {
        if (m_Direction == TD_CAPTURE)
        {
            dwID = IDS_VIDEO_CAPTURE_STREAM;
        }
        else
        {
            dwID = IDS_VIDEO_RENDER_STREAM;
        }
    }

    const int   BUFSIZE = 1024;
    WCHAR       wszName[BUFSIZE];

    if (LoadStringW( 
            _Module.GetModuleInstance(),
            dwID,
            wszName,
            BUFSIZE - 1 ) == 0)
    {
        *ppName = NULL;

        LOG((MSP_ERROR, "CMSPStream::get_Name - "
            "LoadString failed - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Convert to a BSTR and return the BSTR.
    //

    BSTR pName = SysAllocString(wszName);

    if (pName == NULL)
    {
        LOG((MSP_ERROR, "CMSPStream::get_Name - exit out of mem"));
        return E_OUTOFMEMORY;
    }

    *ppName = pName;

    return S_OK; 
}

HRESULT CIPConfMSPStream::SendStreamEvent(
    IN      MSP_CALL_EVENT          Event,
    IN      MSP_CALL_EVENT_CAUSE    Cause,
    IN      HRESULT                 hrError = 0,
    IN      ITTerminal *            pTerminal = NULL
    )
/*++

Routine Description:

    Send a event to the app.
*/
{
    CLock lock(m_lock);

    LOG((MSP_TRACE, "SendStreamEvent entered: stream %p, event %d, cause %d", this, Event, Cause));
    
    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    ITStream *  pITStream;
    HRESULT hr = this->_InternalQueryInterface(
        __uuidof(ITStream), 
        (void **)&pITStream
    );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "SendStreamEvent:QueryInterface failed: %x", hr));
        return hr;
    }

    MSPEVENTITEM* pEventItem = AllocateEventItem();

    if (pEventItem == NULL)
    {
        LOG((MSP_ERROR, "No memory for the TSPMSP data"));
        pITStream->Release();

        return E_OUTOFMEMORY;
    }
    
    // Fill in the necessary fields for the event structure.
    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
    pEventItem->MSPEventInfo.Event  = ME_CALL_EVENT;
    
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Type = Event;
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.Cause = Cause;

    // pITStream has a refcount becaust it was from QI.
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream = pITStream;

    // the terminal needs to be addrefed.
    if (pTerminal) pTerminal->AddRef();
    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal = pTerminal;

    pEventItem->MSPEventInfo.MSP_CALL_EVENT_INFO.hrError= hrError;

    hr = m_pMSPCall->HandleStreamEvent(pEventItem);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Post event failed %x", hr));
        
        if (pTerminal) pTerminal->Release();

        pITStream->Release();
        FreeEventItem(pEventItem);

        return hr;
    }
    return S_OK;
}

HRESULT CIPConfMSPStream::CleanUpFilters()
/*++

Routine Description:

    remove all the filters in the graph.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CleanUpFilters for %ws %p", m_szName, this));
   
    if (m_pIRTPDemux)
    {
        m_pIRTPDemux->Release();
        m_pIRTPDemux = NULL;
    }
/*
    if (m_pIRTPSession)
    {
        m_pIRTPSession->Release();
        m_pIRTPSession = NULL;
    }
*/
    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    for(;;)
    {
        // Because the enumerator is invalid after removing a filter from
        // the graph, we have to try to get all the filters in one shot.
        // If there are still more, we loop again.

        // Enumerate the filters in the graph.
        CComPtr<IEnumFilters>pEnum;
        HRESULT hr = m_pIGraphBuilder->EnumFilters(&pEnum);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "cleanup filters, enumfilters failed: %x", hr));
            return hr;
        }

        const DWORD MAXFILTERS = 40;
        IBaseFilter * Filters[MAXFILTERS];
        DWORD dwFetched;
    
        hr = pEnum->Next(MAXFILTERS, Filters, &dwFetched);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "get next filter failed: %x", hr));
            return hr;
        }

        for (DWORD i = 0; i< dwFetched; i ++)
        {
            m_pIGraphBuilder->RemoveFilter(Filters[i]);
            Filters[i]->Release();
        }

        if (hr != S_OK)
        {
            break;
        }
    }
    return S_OK;
}

HRESULT SetGraphClock(
    IGraphBuilder *pIGraphBuilder
    )
{
    HRESULT hr;

    // create the clock object first.
    CComObject<CMSPStreamClock> *pClock = NULL;

    hr = ::CreateCComObjectInstance(&pClock);

    if (pClock == NULL)
    {
        LOG((MSP_ERROR, 
            "SetGraphClock Could not create clock object, %x", hr));

        return hr;
    }

    IReferenceClock* pIReferenceClock = NULL;

    hr = pClock->_InternalQueryInterface(
        __uuidof(IReferenceClock), 
        (void**)&pIReferenceClock
        );
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "SetGraphClock query pIReferenceClock interface failed, %x", hr));

        delete pClock;
        return hr;
    }

    // Get the graph builder interface on the graph.
    IMediaFilter *pFilter;
    hr = pIGraphBuilder->QueryInterface(
            IID_IMediaFilter, (void **) &pFilter);

    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "get IFilter interface, %x", hr));
        pIReferenceClock->Release();
        return hr;
    }

    hr = pFilter->SetSyncSource(pIReferenceClock);

    pIReferenceClock->Release();
    pFilter->Release();

    LOG((MSP_TRACE, "SetSyncSource returned, %x", hr));
    
    return hr;
}

HRESULT CIPConfMSPStream::Configure(
    IN STREAMSETTINGS &StreamSettings,
    IN  WCHAR *pszKey
    )
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
    StreamSettings - The setting structure got from the SDP blob.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream configure entered."));

    CLock lock(m_lock);
    
    _ASSERTE(m_fIsConfigured == FALSE);

    // configure the graph with our own clock.
    SetGraphClock(m_pIGraphBuilder);

    if (pszKey != NULL)
    {
        m_szKey = (WCHAR *)malloc(sizeof(WCHAR) * (lstrlenW(pszKey) + 1));
        if (m_szKey == NULL)
        {
            LOG((MSP_ERROR, "stream %ws %p out of memeroy", m_szName, this));
            return E_OUTOFMEMORY;
        }

        lstrcpyW(m_szKey, pszKey);
    }

    m_Settings      = StreamSettings;
    m_fIsConfigured = TRUE;

    // setup maximum bandwidth
    HRESULT hr;
    if (m_Settings.lBandwidth != QCDEFAULT_QUALITY_UNSET)
    {
        if (FAILED (hr = Set (StreamQuality_MaxBitrate, m_Settings.lBandwidth, TAPIControl_Flags_None)))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to set maximum bitrate %d. %x", m_szName, this, m_Settings.lBandwidth, hr));
        }
    }

    // if there is no terminal selected, just return.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        return S_OK;
    }

    // set up the filters and the terminals.
    hr = SetUpFilters();

    if (FAILED(hr))
    {
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        LOG((MSP_ERROR, "stream %ws %p set up filters failed, %x", 
            m_szName, this, hr));
        return hr;
    }

    LOG((MSP_INFO, "stream %ws %p configure exit S_OK", m_szName, this));

    return S_OK;
}

HRESULT CIPConfMSPStream::FinishConfigure()
/*++

Routine Description:

    Configure the settings of this stream.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream FinishConfigure entered."));

    CLock lock(m_lock);
    
    if (m_fIsConfigured == FALSE)
    {
        // this stream hasn't been configured.
        return E_FAIL;
    }

    HRESULT hr;

    switch (m_dwState)
    {
    case STRM_RUNNING:
        // start the graph.
        hr = CMSPStream::StartStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
            return hr;
        }

        if (m_Terminals.GetSize() > 0)
        {
            SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_REMOTE_REQUEST);
        }

        LOG((MSP_INFO, "stream %ws %p started", m_szName, this));
        break;

    case STRM_PAUSED:
        // pause the graph.
        hr = CMSPStream::PauseStream();
        if (FAILED(hr))
        {
            // if the stream failed to start, let the app now.
            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
            return hr;
        }

        LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));
        break;

    case STRM_STOPPED:
        break;
    }

    LOG((MSP_INFO, "stream %ws %p configure exit S_OK", m_szName, this));

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::StartStream()
/*++

Routine Description:

    Start the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter Runing state. (RO)
        m_dwState = STRM_RUNNING; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter Runing state. (RO, RT)
        m_dwState = STRM_RUNNING; 

        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::StartStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
    LOG((MSP_INFO, "stream %ws %p started", m_szName, this));

    // Enter Runing state.(RT)
    m_dwState = STRM_RUNNING;

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::PauseStream()
/*++

Routine Description:

    Pause the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter paused state. (PO)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter paused state. (PO, PT)
        m_dwState = STRM_PAUSED; 
        
        return S_OK;
    }

    // Start the stream.
    HRESULT hr = CMSPStream::PauseStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
        return hr;
    }

    LOG((MSP_INFO, "stream %ws %p paused", m_szName, this));

    // Enter paused state.(PT)
    m_dwState = STRM_PAUSED;

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::StopStream()
/*++

Routine Description:

    Stop the stream. This is the basic state machine for all the derived 
    streams.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    CLock lock(m_lock);

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter stopped state. (SO)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter stopped state. (SO, ST)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    // Stop the graph.
    HRESULT hr = CMSPStream::StopStream();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));
        return hr;
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
    LOG((MSP_INFO, "stream %ws %p stopped", m_szName, this));

    // Enter stopped state.(ST)
    m_dwState = STRM_STOPPED; 

    return S_OK;
}

HRESULT CIPConfMSPStream::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    The implementation in this class checks to see if the terminal
    is th right type and direction and it only allows on terminal per
    stream.

Arguments:
    
    pTerminal - the terminal object.

*/
{
    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (Direction != TD_BIDIRECTIONAL && Direction != m_Direction)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // By default, only one terminal is supported per stream.
    if (m_Terminals.GetSize() > 0)
    {
        return TAPI_E_MAXTERMINALS;
    }

    return S_OK;
}

HRESULT CIPConfMSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    Select a terminal on the stream. The stream will start itself if it
    was in running state. See the state transition table at the beginning
    of this file.

Arguments:
    
    pTerminal - the terminal object.

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, "CMSPStream::SelectTerminal, %p", pTerminal));

    //
    // Check parameter.
    //
    if ( IsBadReadPtr(pTerminal, sizeof(ITTerminal) ) )
    {
        LOG((MSP_ERROR, "CIPconfMSPStream.SelectTerminal - exit E_POINTER"));

        return E_POINTER;
    }

    CLock lock(m_lock);

    // validate the terminal.
    HRESULT hr = CheckTerminalTypeAndDirection(pTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "wrong terminal. %x", hr));
        return hr;
    }

    // put the terminal into our list.
    hr = CMSPStream::SelectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "SelectTerminal on CMSPStream failed, %x", hr));
        return hr;
    }

    // At this point, the select terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));
        return S_OK;
    }

    //  Query IFilterChain
    CComPtr<IFilterChain> pIFilterChain;
    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }
    
//#ifdef DYNGRAPH
    OAFilterState FilterState;
    hr = m_pIMediaControl->GetState(0, &FilterState);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p GetState failed, %x", m_szName, this, hr));
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        return S_OK;
    }
//#endif

// #ifndef DYNGRAPH
    if (!(m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
          m_Direction == TD_RENDER &&
          pIFilterChain != NULL))
    {
        // stop the graph before making changes.
        hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

            SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            return S_OK;
        }

        // do not duplicate stream inactive if it is inactive
        //if (FilterState == State_Running)
        //{
            // no need to send stream inactive at all

            // SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        //}
    }        
// #endif

    // connect the new terminal into the graph. 
    // this method will send events if the terminal failed.
    hr = ConnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p connect to terminal failed, %x", 
            m_szName, this, hr));

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_CONNECT_FAIL, hr);

        return S_OK;
    }

    // if not video receive or no dynamic graph
    // after connecting the termanal, go back to the original state.
    switch  (m_dwState)
    {
    case STRM_RUNNING:
        {
            // if dynamic graph and was running, then do nothing
            if (m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
                m_Direction == TD_RENDER &&
                pIFilterChain != NULL &&
                FilterState == State_Running)
                break;

            // start the stream.
            hr = CMSPStream::StartStream();
    
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
                SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
                break;
            }

            SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        }
        break;

    case STRM_PAUSED:
        {
            // pause the stream.
            hr = CMSPStream::PauseStream();
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "stream %ws %p failed, %x", m_szName, this, hr));
                SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
            }

        }    
        break;
    }

    return S_OK;
}

STDMETHODIMP CIPConfMSPStream::UnselectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

  Unselect a terminal from the stream. It handles changing the graph and
  going back to the original state.

Arguments:
    

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, 
        "CIPConfMSPStream::UnselectTerminal, pTerminal %p", pTerminal));

    CLock lock(m_lock);
    int index;

    if ((index = m_Terminals.Find(pTerminal)) < 0)
    {
        LOG((MSP_ERROR, "UnselectTerminal - exit TAPI_E_INVALIDTERMINAL"));
    
        return TAPI_E_INVALIDTERMINAL;
    }

    HRESULT hr;

    //
    // Unregister the PTEventSink object
    //

    hr = UnregisterPluggableTerminalEventSink( pTerminal );

    if( FAILED(hr) )
    {
        LOG((MSP_TRACE, "stream %ws %p something wrong in UnregisterPluggableTerminalEventSink, %x",
             m_szName, this, hr));
    }

    // if the stream is not configured, just remove it and return.
    if (!m_fIsConfigured)
    {
        if (!m_Terminals.RemoveAt(index))
        {
            LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
                "exit E_UNEXPECTED"));
    
            return E_UNEXPECTED;
        }

        // release the refcount that was in our list.
        pTerminal->Release();

        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));
        return S_OK;
    }
    
//#ifdef DYNGRAPH
    OAFilterState FilterState;
    hr = m_pIMediaControl->GetState(0, &FilterState);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p GetState failed, %x", m_szName, this, hr));
        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
        return S_OK;
    }
//#endif

    CComPtr <IFilterChain> pIFilterChain;

    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }

// #ifndef DYNGRAPH
    if (!(m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
          m_Direction == TD_RENDER &&
          pIFilterChain != NULL))
    {
        // stop the graph before making changes.
        hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));

            return hr;
        }

        if (FilterState == State_Running)
        {
            SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST);
        }
    }    
// #endif
       
    // disconnect the terminal from the graph. 
    // this method will send events if the terminal failed.
    hr = DisconnectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "stream %ws %p disconnectTerminal failed, %x", 
            m_szName, this, hr));

        return hr;
    }

    if (!m_Terminals.RemoveAt(index))
    {
        LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
            "exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // release the refcount that was in our list.
    pTerminal->Release();

    // if there is no terminal selected, just return and wait for terminals.
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));
        return S_OK;
    }

    // At this point, the Unselect terminal opration succeeded. All the 
    // failure cases are handled by sending events after this.

    // after disconnecting the termanal, go back to the original state.

    if (!(m_dwMediaType == TAPIMEDIATYPE_VIDEO &&
          m_Direction == TD_RENDER &&
          pIFilterChain != NULL))
    {
        switch  (FilterState)
        {
        case State_Running:
            {
                // start the stream.
                hr = CMSPStream::StartStream();
                if (FAILED(hr))
                {
                    LOG((MSP_ERROR, "stream %ws %p failed to start, %x", m_szName, this, hr));
                    SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
                    break;
                }

                SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_LOCAL_REQUEST);
            }

            break;

        case State_Paused:
            {
                // pause the stream.
                hr = CMSPStream::PauseStream();
                if (FAILED(hr))
                {
                    LOG((MSP_ERROR, "stream %ws %p failed to pause, %x", m_szName, this, hr));
                    SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, hr);
                }
            }
            break;
        }
    }

    return S_OK;
}

HRESULT CIPConfMSPStream::ShutDown()
/*++

Routine Description:

    Shut down the stream. It release the filters and terminals.

Arguments:
    

Return Value:

S_OK

--*/
{
    LOG((MSP_TRACE, "CIPConfMSPStream::Shutdown %ws - enter", m_szName));

    CLock lock(m_lock);

    for (int j = 0; j < NUM_SDES_ITEMS; j ++)
    {
        if (m_InfoItems[j])
        {
            free(m_InfoItems[j]);
            m_InfoItems[j] = NULL;
        }
    }

    // unlink by stream
    HRESULT hr;
    if (FAILED (hr = UnlinkInnerCallQC (TRUE)))
        LOG ((MSP_ERROR, "CH323MSPStream::ShutDown failed to unlink on call qc, %x", hr));

    if (m_pMSPCall)
    {
        m_pMSPCall->MSPCallRelease();
        m_pMSPCall  = NULL;
    }

    // free the extra filter reference.
    if (m_pIRTPDemux)
    {
        m_pIRTPDemux->Release();
        m_pIRTPDemux = NULL;
    }

    if (m_pIRTPSession)
    {
        m_pIRTPSession->Release();
        m_pIRTPSession = NULL;
    }

    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    if (m_szKey)
    {
        free(m_szKey);
        m_szKey = NULL;
    }

    // If the stream is not configured, just free the terminals.
    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();

        return S_OK;
    }

    // if there are terminals and configured, we need to disconnect 
    // the terminals.
    if (m_Terminals.GetSize() > 0)
    {
        // Stop the graph before disconnecting the terminals.
        HRESULT hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "stream %ws %p failed to stop, %x", m_szName, this, hr));
            return hr;
        }

        for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
        {
            hr = DisconnectTerminal(m_Terminals[i]);
            LOG((MSP_TRACE, "Disconnect terminal returned %x", hr));

            m_Terminals[i]->Release();
        }
        m_Terminals.RemoveAll();
    }

    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        m_Participants[i]->Release();
    }
    m_Participants.RemoveAll();

    LOG((MSP_TRACE, "CIPConfMSPStream::Shutdown - exit S_OK"));

    return S_OK;
}

HRESULT CIPConfMSPStream::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminalControl(pITTerminal);
    if (pTerminalControl == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

    LOG((MSP_TRACE, "terminal %p is disonnected. hr:%x", pITTerminal, hr));

    return hr;
}

HRESULT CIPConfMSPStream::EnableParticipantEvents(
    IN IRtpSession * pRtpSession
    )
/*++

Routine Description:

    Enable participant information, such as join, leave, info change,
    talking, silence, etc.

Arguments:
    
    pRtpSession - The RTP sesion pointer.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableParticipantEvents");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    HRESULT hr;
    DWORD dwEnabledMask;   

    if (m_Direction == TD_RENDER)
    {
        // enable participant state events.
        DWORD dwParticipantInfoMask = 
            RTPPARINFO_MASK_STALL |
            RTPPARINFO_MASK_BYE |
            RTPPARINFO_MASK_DEL;

        if (m_dwMediaType == TAPIMEDIATYPE_AUDIO)
        {
            // watch for active talkers
            dwParticipantInfoMask |= 
                RTPPARINFO_MASK_TALKING |
                RTPPARINFO_MASK_WAS_TALKING;
        }
        else
        {
            // watch for video Senders
            dwParticipantInfoMask |= 
                RTPPARINFO_MASK_TALKING |
                RTPPARINFO_MASK_SILENT |
                RTPPARINFO_MASK_MAPPED |
                RTPPARINFO_MASK_UNMAPPED;
        }

        hr = pRtpSession->ModifySessionMask(
            RTPMASK_PINFOR_EVENTS,
            dwParticipantInfoMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify pinfo failed. %x", __fxName, hr));
            return hr;
        }

        // enable participant information events.
        DWORD dwSDESMask = 
            RTPSDES_MASK_CNAME |
            RTPSDES_MASK_NAME |
            RTPSDES_MASK_EMAIL |
            RTPSDES_MASK_PHONE |
            RTPSDES_MASK_LOC |
            RTPSDES_MASK_TOOL |
            RTPSDES_MASK_NOTE |
            RTPSDES_MASK_PRIV;

        // tell RTP to save these items for retrieval 
        hr = pRtpSession->ModifySessionMask(
            RTPMASK_SDES_REMMASK,
            dwSDESMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify sdes mask for receiver failed. %x",
                __fxName, hr));
            return hr;
        }

        // tell RTP to fire events when it gets these items.
        hr = pRtpSession->ModifySessionMask(
            RTPMASK_SDESRECV_EVENTS,
            dwSDESMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify sdes mask for receiver failed. %x",
                __fxName, hr));
            return hr;
        }
    }
    else
    {
        // enable the sending of local SDES information.
        DWORD dwLocalSDESMask = 
            RTPSDES_LOCMASK_CNAME |
            RTPSDES_LOCMASK_NAME |
            RTPSDES_LOCMASK_EMAIL |
            RTPSDES_LOCMASK_PHONE |
            RTPSDES_LOCMASK_LOC |
            RTPSDES_LOCMASK_TOOL |
            RTPSDES_LOCMASK_NOTE |
            RTPSDES_LOCMASK_PRIV;

        hr = pRtpSession->ModifySessionMask(
            RTPMASK_SDES_LOCMASK,
            dwLocalSDESMask,
            1,
            &dwEnabledMask
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, modify sdes mask for local SDES failed. %x", 
                __fxName, hr));
            return hr;
        }
    }

    return hr;
}

HRESULT CIPConfMSPStream::EnableQOS(
    IN IRtpSession * pRtpSession
    )
/*++

Routine Description:

    Enable qos reservation and qos events

Arguments:
    
    pRtpSession - The RTP sesion pointer.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableQOS");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    HRESULT hr;

    // set the QOS application IDs.
    if (m_Settings.pApplicationID ||
        m_Settings.pSubIDs ||
        m_Settings.pApplicationGUID)
    {
        if (FAILED(hr = pRtpSession->SetQosAppId(
            m_Settings.pApplicationID,
            m_Settings.pApplicationGUID,    
            m_Settings.pSubIDs
            )))
        {
            LOG((MSP_ERROR, "%s, set qos application id. %x", __fxName, hr));
            return hr;
        }
    }
    
    TCHAR * szQOSName;
    DWORD dwMaxParticipant = 5; // default to 5

    switch (m_Settings.PayloadTypes[0])
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        szQOSName       = RTPQOSNAME_G711;
        break;

    case PAYLOAD_GSM:
        szQOSName       = RTPQOSNAME_GSM6_10;
        break;

    case PAYLOAD_DVI4_8:
        szQOSName       = RTPQOSNAME_DVI4_8;
        break;

    case PAYLOAD_DVI4_16:
        szQOSName       = RTPQOSNAME_DVI4_16;
        break;

    case PAYLOAD_MSAUDIO:
        szQOSName       = RTPQOSNAME_MSAUDIO;
        break;

    case PAYLOAD_H261:
        szQOSName = (m_Settings.fCIF) ? RTPQOSNAME_H261CIF : RTPQOSNAME_H261QCIF;
        dwMaxParticipant = 40; // 40 for video
        break;

    case PAYLOAD_H263:
        szQOSName = (m_Settings.fCIF) ? RTPQOSNAME_H263CIF : RTPQOSNAME_H263QCIF;
        dwMaxParticipant = 40; // 40 for video
        break;

    default:
        LOG((MSP_WARN, "Don't know the QOS name for payload type: %d", 
            m_Settings.PayloadTypes[0]));
        return E_FAIL;
    }

    // use shared explicit for video. 
    DWORD dwStyle = (m_dwMediaType == TAPIMEDIATYPE_VIDEO)
        ? RTPQOS_STYLE_SE : RTPQOS_STYLE_DEFAULT;

    hr = pRtpSession->SetQosByName(
        szQOSName,
        dwStyle,
        dwMaxParticipant,           // start from 40 participant reservation.
        RTPQOSSENDMODE_REDUCED_RATE,
        m_Settings.dwMSPerPacket? m_Settings.dwMSPerPacket:~0
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetQosByName failed. %x", __fxName, hr));
        return hr;
    }

    // enable qos events.
    DWORD dwQOSEventMask = 
        RTPQOS_MASK_ADMISSION_FAILURE |
        RTPQOS_MASK_POLICY_FAILURE |
        RTPQOS_MASK_BAD_STYLE |
        RTPQOS_MASK_BAD_OBJECT |
        RTPQOS_MASK_TRAFFIC_CTRL_ERROR |
        RTPQOS_MASK_GENERIC_ERROR |
        RTPQOS_MASK_NOT_ALLOWEDTOSEND |
        RTPQOS_MASK_ALLOWEDTOSEND;

    DWORD dwEnabledMask;   
    hr = pRtpSession->ModifySessionMask(
        (m_Direction == TD_RENDER) ? RTPMASK_QOSRECV_EVENTS : RTPMASK_QOSSEND_EVENTS,
        dwQOSEventMask,
        1,
        &dwEnabledMask
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, modify qos event mask failed. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CIPConfMSPStream::EnableEncryption(
    IN IRtpSession * pRtpSession,
    IN WCHAR *pPassPhrase
    )
/*++

Routine Description:

    Enable RTP encryption.

Arguments:
    
    pRtpSession - The RTP sesion pointer.

    pPassPhrase - the pass phrase to generate the key.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableEncryption");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    // enable RTP payload encryption.
    HRESULT hr = pRtpSession->SetEncryptionMode(
        RTPCRYPTMODE_RTP,
        RTPCRYPT_SAMEKEY
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetEncryptionMode failed. %x", __fxName, hr));
        return hr;
    }

    // set the key
    hr = pRtpSession->SetEncryptionKey(
        pPassPhrase,
        NULL,   // default hash algorithm, MD5
        NULL,   // default encrypt algorithm, DES
        FALSE   // RTCP?
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetEncryptionKey. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CIPConfMSPStream::ConfigureRTPFilter(
    IN  IBaseFilter *   pIBaseFilter
    )
/*++

Routine Description:

    Configure the source RTP filter. Including set the address, port, TTL,
    QOS, thread priority, clcokrate, etc.

Arguments:
    
    pIBaseFilter - The RTP Filter.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::ConfigureRTPFilter");
    LOG((MSP_TRACE, "%s entered for %ws", __fxName, m_szName));

    _ASSERT (m_pIRTPSession == NULL);

    // get the session interface pointer.
    HRESULT hr = pIBaseFilter->QueryInterface(&m_pIRTPSession);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, query IRtpSession failed. hr=%x", __fxName, hr));
        return hr;
    }

    // Initialize the RTP session.
    DWORD dwFlags;
    
    switch(m_dwMediaType)
    {
    case TAPIMEDIATYPE_AUDIO:
        dwFlags = RTPINIT_CLASS_AUDIO;
        break;
    case TAPIMEDIATYPE_VIDEO:
        dwFlags = RTPINIT_CLASS_VIDEO;
        break;
    default:
        dwFlags = RTPINIT_CLASS_DEFAULT;
    }

    dwFlags |= RTPINIT_ENABLE_QOS;
    
    hr = m_pIRTPSession->Init(m_Settings.phRTPSession, dwFlags);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, Init RTP session failed. hr=%x", __fxName, hr));
        return hr;
    }

    // set the RTP/RTCP ports.
    hr = m_pIRTPSession->SetPorts(
        htons(m_Settings.wRTPPortRemote),   // local RTP port.
        htons(m_Settings.wRTPPortRemote),   // remote RTP port.
        htons(m_Settings.wRTPPortRemote + 1),   // local RTCP port.
        htons(m_Settings.wRTPPortRemote + 1)    // remote RTCP port.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, Set ports failed. hr=%x", __fxName, hr));
        return hr;
    }

    // set the destination address.
    hr = m_pIRTPSession->SetAddress(
        htonl(m_Settings.dwIPLocal),        // local IP.
        htonl(m_Settings.dwIPRemote)        // remote IP.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, Set Address failed. hr=%x", __fxName, hr));
        return hr;
    }

    // Set the TTL used in the filter.
    if (FAILED(hr = m_pIRTPSession->SetScope(m_Settings.dwTTL, 3)))
    {
        LOG((MSP_ERROR, "%s, SetScope failed. %x", __fxName, hr));
        return hr;
    }

    // Set the loopback mode used in the filter.
    DWORD dwRTPLoopbackMode;
    switch (m_Settings.LoopbackMode)
    {
    case MM_NO_LOOPBACK:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_NONE;
        break;
    case MM_FULL_LOOPBACK:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_FULL;
        break;
    case MM_SELECTIVE_LOOPBACK:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_PARTIAL;
        break;
    default:
        dwRTPLoopbackMode = RTPMCAST_LOOPBACKMODE_NONE;
        break;
    }

    if (FAILED(hr = m_pIRTPSession->SetMcastLoopback(dwRTPLoopbackMode, 0)))
    {
        LOG((MSP_ERROR, "set loopback mode failed. %x", hr));
        return hr;
    }

    // enable participant events
    if (FAILED(hr = EnableParticipantEvents(m_pIRTPSession)))
    {
        LOG((MSP_ERROR, "%s, EnableParticipantEvents failed. %x", __fxName, hr));
        return hr;
    }


    // Enable QOS.
    if (m_Settings.dwQOSLevel != QSL_BEST_EFFORT)
    {
        if (FAILED(hr = EnableQOS(m_pIRTPSession)))
        {
            LOG((MSP_ERROR, "%s, EnableQOS failed. %x", __fxName, hr));
            return hr;
        }
    }

    // Enable Encryption.
    if (m_szKey)
    {
        if (FAILED(hr = EnableEncryption(m_pIRTPSession, m_szKey)))
        {
            LOG((MSP_ERROR, "%s, EnableEncryption failed. %x", __fxName, hr));
            return hr;
        }
    }
    
    // Set local SDES info
    if (FAILED(hr = SetLocalInfoOnRTPFilter(NULL)))
    {
        LOG((MSP_ERROR, "%s, SetLocalInfoOnRTPFilter failed. %x", __fxName, hr));
        return hr;
    }
    
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessNewParticipant(
    IN  int                 index,
    IN  DWORD               dwSSRC,
    IN  DWORD               dwSendRecv,
    IN  WCHAR *             szCName,
    OUT ITParticipant **    ppITParticipant
    )
{
    if (!m_Participants.HasSpace())
    {
        if (!m_Participants.Grow())
        {
            LOG((MSP_ERROR, "Out of mem for participant list"));
    
            return E_OUTOFMEMORY;
        }
    }

    // create a new participant if it is not in the list.
    HRESULT hr = ((CIPConfMSPCall *)m_pMSPCall)->NewParticipant(
        (ITStream *)this,
        dwSSRC,
        dwSendRecv,
        m_dwMediaType,
        szCName,
        ppITParticipant
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "new participant returns %x", hr));
        
        return hr;
    }

    // insert the new participant at the index where the search
    // stopped. The list is ordered by CName. We know the list has
    // space, this function will not fail.
    m_Participants.InsertAt(index, *ppITParticipant);

    LOG((MSP_INFO, "%ws new participant %s", m_szName, szCName));

    (*ppITParticipant)->AddRef();

    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessSDESUpdate(
    IN  DWORD               dwInfoItem,
    IN  DWORD               dwSSRC
    )
/*++

Routine Description:

    Process SDES info updates, create a participant if necessary. If a new
    participant is created, a new participant event will be fired. If the
    participant already exists, the new report is compared with the current
    information, if anything changes, a info change event will be fired. 

Arguments:
    
    dwInfoItem - the info type. of this participant.

    dwSSRC - the SSRC of this participant.

    dwSendRecv - a sender report or a receiver report.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CIPConfMSPStream::ProcessSDESUpdate");
    LOG((MSP_TRACE, "%s entered for %ws, SSRC:%x", __fxName, m_szName, dwSSRC));

    if (dwInfoItem < RTPSDES_CNAME || RTPSDES_CNAME > RTPSDES_PRIV)
    {
        return E_INVALIDARG;
    }

    CLock Lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));

        return S_OK;
    }
    
    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "ProcessSDESUpdate RTP filter is NULL"));
        return E_UNEXPECTED;
    }

    // first get the CName of the participant.
    WCHAR Buffer[MAX_PARTICIPANT_TYPED_INFO_LENGTH + 1];
    DWORD dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH; 

    HRESULT hr = m_pIRTPSession->GetSdesInfo(
        RTPSDES_CNAME,
        Buffer,
        &dwLen,
        dwSSRC
        );

    if (FAILED(hr) || dwLen == 0)
    {
        LOG((MSP_ERROR, "can't get CName for ssrc:%x. %x", dwSSRC, hr));
        return hr;
    }

    ITParticipant * pITParticipant;
    BOOL fChanged = FALSE;
    BOOL fNewParticipant = FALSE;
    
    CParticipant * pParticipant;
        
    // find out if the participant is in our list.
    int index;
    if (m_Participants.FindByCName(Buffer, &index))
    {
        pITParticipant = m_Participants[index];

        // addref to keep it after unlock;
        pITParticipant->AddRef();

        pParticipant = (CParticipant *)pITParticipant;
    }
    else
    {
        hr = ProcessNewParticipant(
            index,
            dwSSRC,
            PART_RECV,
            Buffer,
            &pITParticipant
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "new participant returns %x", hr));
            return hr;
        }

        pParticipant = (CParticipant *)pITParticipant;
    
        // There might be things the stream needs to do with the new participant
        NewParticipantPostProcess(dwSSRC, pITParticipant);

        // a new stream is added into the participant's list
        // fire a info changed event.
        fChanged = TRUE;

        fNewParticipant = TRUE;
    }

    // update the information of the participant.

    // just in case the SSRC changed.
    pParticipant->UpdateSSRC(
        (ITStream *)this,
        dwSSRC,
        PART_RECV
        );

    if (dwInfoItem > RTPSDES_CNAME && dwInfoItem < RTPSDES_ANY)
    {
        dwLen = MAX_PARTICIPANT_TYPED_INFO_LENGTH;

        hr = m_pIRTPSession->GetSdesInfo(
            dwInfoItem,
            Buffer,
            &dwLen,
            dwSSRC
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get sdes data for ssrc:%x. %x", dwSSRC, hr));
            return hr;
        }

        fChanged = fChanged || pParticipant->UpdateInfo(
            dwInfoItem,
            dwLen,
            Buffer
            );
    }

    if(fChanged)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->
            SendParticipantEvent(PE_INFO_CHANGE, pITParticipant);
    }

    if (fNewParticipant &&
        (m_dwMediaType & TAPIMEDIATYPE_VIDEO))
    {
        // check if participant is talking
        DWORD dwState = 0;

        hr = m_pIRTPSession->GetParticipantState(dwSSRC, &dwState);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "Get participant state. %x", hr));
        }
        else
        {
            if (dwState == (DWORD)RTPPARINFO_TALKING)
            {
                // was talking
                ProcessTalkingEvent(dwSSRC);
            }
        }
    }

    pITParticipant->Release();
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    return E_NOTIMPL;
#if 0
    LOG((MSP_TRACE, "ProcessParticipantLeave, SSRC: %x", dwSSRC));
    
    m_lock.Lock();
    
    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        pParticipant = (CParticipant *)m_Participants[i];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "SSRC:%x had been removed.", dwSSRC));

        m_lock.Unlock();
        
        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[i];

    m_Participants.RemoveAt(i);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    m_lock.Unlock();

    pITParticipant->Release();

    return S_OK;
#endif
}

HRESULT CIPConfMSPStream::ProcessParticipantTimeOutOrRecovered(
    IN  BOOL    fTimeOutOrRecovered,
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When RTP detects a timeout for a certain participant, the msp needs to
    notify the app about it.

Arguments:
    
    dwSSRC - the SSRC of the participant that times out.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "ProcessParticipantTimeOutOrRecovered, SSRC: %x", dwSSRC));
    
    ITParticipant *pITParticipant = NULL;

    CLock Lock(m_lock);
    
    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            pITParticipant->AddRef();
            break;
        }
    }

    // if the participant is not found
    if (pITParticipant == NULL)
    {
        LOG((MSP_ERROR, "can't find the SSRC", dwSSRC));

        return S_OK;
    }

    // get stream state
    HRESULT hr;
    DWORD prevState;
    if (FAILED (hr = ((CParticipant *)m_Participants[i])->GetStreamState (
        (ITStream *)this, &prevState)))
    {
        LOG ((MSP_ERROR, "failed to get stream state. %x", hr));
        pITParticipant->Release ();
        return S_OK;
    }

    // check if we need to change state
    if (prevState & (fTimeOutOrRecovered ? PESTREAM_TIMEOUT : PESTREAM_RECOVER))
    {
        pITParticipant->Release ();
        return S_OK;
    }

    // set stream state
    hr = ((CParticipant *)m_Participants[i])->SetStreamState (
        (ITStream *)this,
        fTimeOutOrRecovered ? PESTREAM_TIMEOUT : PESTREAM_RECOVER);

    if (FAILED (hr))
    {
        LOG ((MSP_ERROR, "failed to set stream state, %x", hr));
        pITParticipant->Release ();
        return S_OK;
    }

    // check if we need to report to app
    INT iStreamCount = ((CParticipant *)m_Participants[i])->GetStreamCount (PART_SEND);

    INT iTimeOutCount = ((CParticipant *)m_Participants[i])->GetStreamTimeOutCount (PART_SEND);

    if ((fTimeOutOrRecovered && (iStreamCount == iTimeOutCount)) ||       // fire timeout event
        (!fTimeOutOrRecovered && (iStreamCount == iTimeOutCount + 1)))    // fire recover event
    {
        ((CIPConfMSPCall *)m_pMSPCall)->
            SendParticipantEvent(
                fTimeOutOrRecovered ? PE_PARTICIPANT_TIMEOUT : PE_PARTICIPANT_RECOVERED, 
                pITParticipant
                );
    }

    pITParticipant->Release();

    return S_OK;
}

HRESULT CIPConfMSPStream::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
{
    // This function does nothing. The derived class will do the work.
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessQOSEvent(
    IN  long lEventCode
    )
{
    CLock lock(m_lock);

    if (m_pMSPCall == NULL)
    {
        LOG((MSP_WARN, "The call has shut down the stream."));
        return S_OK;
    }

    switch (lEventCode)
    {
    case RTPQOS_EVENT_NOQOS:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_NOQOS, 
            m_dwMediaType
            );
        break;

    case RTPQOS_EVENT_RECEIVERS:
    case RTPQOS_EVENT_SENDERS:
    case RTPQOS_EVENT_NO_SENDERS:
    case RTPQOS_EVENT_NO_RECEIVERS:
        break;
    
    case RTPQOS_EVENT_REQUEST_CONFIRMED:
        break;
    
    case RTPQOS_EVENT_ADMISSION_FAILURE:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_ADMISSIONFAILURE, 
            m_dwMediaType
            );
        break;
    
    case RTPQOS_EVENT_POLICY_FAILURE:
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_POLICYFAILURE, 
            m_dwMediaType
            );
        break;

    case RTPQOS_EVENT_BAD_STYLE:
    case RTPQOS_EVENT_BAD_OBJECT:
    case RTPQOS_EVENT_TRAFFIC_CTRL_ERROR:
    case RTPQOS_EVENT_GENERIC_ERROR:
   
        ((CIPConfMSPCall*)m_pMSPCall)->SendTSPMessage(
            CALL_QOS_EVENT, 
            QE_GENERICERROR, 
            m_dwMediaType
            );
        break;
    
    case RTPQOS_EVENT_NOT_ALLOWEDTOSEND:
        m_pStreamQCRelay->m_fQOSAllowedToSend = FALSE;
        break;
    
    case RTPQOS_EVENT_ALLOWEDTOSEND:
        m_pStreamQCRelay->m_fQOSAllowedToSend = TRUE;
        break;
    }
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessTalkingEvent(
    IN  DWORD   dwSSRC
    )
{
    return S_OK;
}

HRESULT CIPConfMSPStream::ProcessWasTalkingEvent(
    IN  DWORD   dwSSRC
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessSilentEvent(
    IN  DWORD   dwSSRC
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessPinMappedEvent(
    IN  DWORD   dwSSRC,
    IN  IPin *  pIPin
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessPinUnmapEvent(
    IN  DWORD   dwSSRC,
    IN  IPin *  pIPin
    )
{
    return S_OK;
}


HRESULT CIPConfMSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_TRACE, "%ws ProcessGraphEvent %d 0x%x 0x%x", m_szName, lEventCode, lParam1, lParam2));

    switch (lEventCode)
    {

    // These events are designed to solve the problem of mapping video 
    // windows to incoming streams. The app needs to know which window 
    // should be painted. Whenever the rtp outpin maps an SSRC  to a pin to 
    // stream data, it sends a MAPPED event. The first parameter is the 
    // SSRC and the second parameter is the output pin of the demux.
    // When the demux stops using a pin, it sends a UNMAPPED event.

    case RTPPARINFO_EVENT_TALKING:

        ProcessParticipantTimeOutOrRecovered(FALSE, (DWORD)lParam1);
        ProcessTalkingEvent((DWORD)lParam1);

        break;

    case RTPPARINFO_EVENT_WAS_TALKING:
        
        ProcessWasTalkingEvent((DWORD)lParam1);

        break;

    case RTPPARINFO_EVENT_SILENT:

        ProcessSilentEvent((DWORD)lParam1);

        break;

    case RTPPARINFO_EVENT_MAPPED:
        
        ProcessPinMappedEvent((DWORD)lParam1, (IPin *)lParam2);

        break;

    case RTPPARINFO_EVENT_UNMAPPED:

        ProcessPinUnmapEvent((DWORD)lParam1, (IPin *)lParam2);

        break;

    case RTPPARINFO_EVENT_STALL:

        ProcessParticipantTimeOutOrRecovered(TRUE, (DWORD)lParam1);
        
        break;

    case RTPPARINFO_EVENT_BYE:
    case RTPPARINFO_EVENT_DEL:

        // lparam1 is the SSRC
        ProcessParticipantLeave((DWORD)lParam1);
        
        break;

    case EC_COMPLETE:
    case EC_USERABORT:

        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_UNKNOWN);
        
        break;

    case EC_ERRORABORT:
    case EC_STREAM_ERROR_STOPPED:
    case EC_STREAM_ERROR_STILLPLAYING:
    case EC_ERROR_STILLPLAYING:

        SendStreamEvent(CALL_STREAM_FAIL, CALL_CAUSE_UNKNOWN, (HRESULT) lParam1);
        break;
    
    case RTPSDES_EVENT_CNAME:
    case RTPSDES_EVENT_NAME:
    case RTPSDES_EVENT_EMAIL:
    case RTPSDES_EVENT_PHONE:
    case RTPSDES_EVENT_LOC:
    case RTPSDES_EVENT_TOOL:
    case RTPSDES_EVENT_NOTE:
    case RTPSDES_EVENT_PRIV:
    case RTPSDES_EVENT_ANY:
    
        ProcessSDESUpdate(lEventCode - RTPSDES_EVENTBASE, (DWORD)lParam1);
        break;

    case RTPQOS_EVENT_ALLOWEDTOSEND:

        m_lock.Lock();

        if (m_Terminals.GetSize() > 0)
        {
            SendStreamEvent(CALL_STREAM_ACTIVE, CALL_CAUSE_QUALITY_OF_SERVICE);
        }

        m_lock.Unlock();

        ProcessQOSEvent (lEventCode);

        break;

    case RTPQOS_EVENT_NOT_ALLOWEDTOSEND:

        m_lock.Lock();

        if (m_Terminals.GetSize() > 0)
        {
            SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_QUALITY_OF_SERVICE);
        }

        m_lock.Unlock();

        ProcessQOSEvent (lEventCode);

        break;

    default:
        if ((lEventCode >= RTPQOS_EVENT_NOQOS)
            && (lEventCode <= RTPQOS_EVENT_ALLOWEDTOSEND))
        {
            ProcessQOSEvent(lEventCode);
        }

        break;
    }

    LOG((MSP_TRACE, "TRACE:CIPConfMSPStream::ProcessGraphEvent - exit S_OK"));
    return S_OK;
}

HRESULT CIPConfMSPStream::SetLocalInfoOnRTPFilter(
    IN  IBaseFilter *   pRTPFilter
    )
{
    _ASSERT(m_pIRTPSession != NULL);

    HRESULT hr = S_OK;
    for (int i = 0; i < NUM_SDES_ITEMS; i ++)
    {
        if (m_InfoItems[i] != NULL)
        {
            hr = m_pIRTPSession->SetSdesInfo(
                    RTPSDES_CNAME + i,
                    m_InfoItems[i]
                    );

            if (FAILED(hr))
            {
                LOG((MSP_WARN, "%ls can't set item:%s", m_szName, m_InfoItems[i]));
            }
        }
    }

    return hr;
}

HRESULT CIPConfMSPStream::EnableParticipant(
    IN  DWORD   dwSSRC,
    IN  BOOL    fEnable
    )
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableParticipantEvents");
    LOG((MSP_TRACE, "%s entered, ssrc:%x", __fxName, dwSSRC));

    CLock Lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "%s RTP filter is NULL", __fxName));
        return E_UNEXPECTED;
    }

    HRESULT hr = m_pIRTPSession->SetMuteState(
            dwSSRC,
            fEnable
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetMuteState failed, hr=%x", __fxName, hr));
    }

    return hr;
}

HRESULT CIPConfMSPStream::GetParticipantStatus(
    IN  DWORD   dwSSRC,
    IN  BOOL *  pfEnable
    )
{
    ENTER_FUNCTION("CIPConfMSPStream::EnableParticipantEvents");
    LOG((MSP_TRACE, "%s entered, ssrc:%x", __fxName, dwSSRC));

    CLock Lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "%s RTP filter is NULL", __fxName));
        return E_UNEXPECTED;
    }

    HRESULT hr = m_pIRTPSession->GetMuteState(
            dwSSRC,
            pfEnable
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, SetMuteState failed, hr=%x", __fxName, hr));
    }

    return hr;
}

//    
// ITStreamQualityControl methods.
//
STDMETHODIMP CIPConfMSPStream::GetRange(
    IN  StreamQualityProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a quality control peroperty. Delegated to inner
    stream quality control

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CIPConfMSPStream::GetRange (StreamQualityProperty)");

    CLock lock(m_lock);

    if (IsBadWritePtr (plMin, sizeof (long)) ||
        IsBadWritePtr (plMax, sizeof (long)) ||
        IsBadWritePtr (plSteppingDelta, sizeof (long)) ||
        IsBadWritePtr (plDefault, sizeof (long)) ||
        IsBadWritePtr (plFlags, sizeof (TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s: bad write pointer", __fxName));
        return E_POINTER;
    }

    *plMin = *plMax = *plSteppingDelta = *plDefault = 0;
    *plFlags = TAPIControl_Flags_None;

    // pointers is to be check by inner stream qc
    InnerStreamQualityProperty prop;

    switch (Property)
    {
    case StreamQuality_MaxBitrate:
        prop = InnerStreamQuality_MaxBitrate;
        break;

    case StreamQuality_CurrBitrate:
        prop = InnerStreamQuality_CurrBitrate;
        break;

    case StreamQuality_MinFrameInterval:
        prop = InnerStreamQuality_MinFrameInterval;
        break;

    case StreamQuality_AvgFrameInterval:
        prop = InnerStreamQuality_AvgFrameInterval;
        break;

    default:
        LOG ((MSP_ERROR, "%s (%ws) received invalid property %d", __fxName, m_szName, Property));
        return E_INVALIDARG;
    }

    return (GetRange (prop, plMin, plMax, plSteppingDelta, plDefault, plFlags));
}

STDMETHODIMP CIPConfMSPStream::Get(
    IN  StreamQualityProperty Property, 
    OUT long *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a quality control peroperty. Delegated to the inner quality 
    control.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CIPConfMSPStream::Get (StreamQualityProperty)");

    CLock lock(m_lock);

    if (IsBadWritePtr (plValue, sizeof (long)) ||
        IsBadWritePtr (plFlags, sizeof (TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "%s: bad write pointer", __fxName));
        return E_POINTER;
    }

    *plValue = 0;
    *plFlags = TAPIControl_Flags_None;

    // pointers is to be check by inner stream qc
    InnerStreamQualityProperty prop;

    switch (Property)
    {
    case StreamQuality_MaxBitrate:
        prop = InnerStreamQuality_MaxBitrate;
        break;

    case StreamQuality_CurrBitrate:
        prop = InnerStreamQuality_CurrBitrate;
        break;

    case StreamQuality_MinFrameInterval:
        prop = InnerStreamQuality_MinFrameInterval;
        break;

    case StreamQuality_AvgFrameInterval:
        prop = InnerStreamQuality_AvgFrameInterval;
        break;

    default:
        LOG ((MSP_ERROR, "%s (%ws) received invalid property %d", __fxName, m_szName, Property));
        return E_INVALIDARG;
    }

    return (Get (prop, plValue, plFlags));
}

STDMETHODIMP CIPConfMSPStream::Set(
    IN  StreamQualityProperty Property, 
    IN  long lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a quality control peroperty. Delegated to the quality
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION ("CIPConfMSPStream::Set (StreamQualityProperty)");

    CLock lock(m_lock);

    // pointers is to be check by inner stream qc
    InnerStreamQualityProperty prop;

    switch (Property)
    {
    case StreamQuality_MaxBitrate:
        // request a prefered value
        prop = InnerStreamQuality_PrefMaxBitrate;
        break;

    case StreamQuality_MinFrameInterval:
        prop = InnerStreamQuality_PrefMinFrameInterval;
        break;

    default:
        LOG ((MSP_ERROR, "%s (%ws) received invalid property %d", __fxName, m_szName, Property));
        return E_NOTIMPL;
    }

    return (Set (prop, lValue, lFlags));
}

/*++

Routine Description:

    This method is called by the create stream helper. It creates stream qc
    relay, stores inner call qc in the relay if this method fails, the stream
    creation should also fail.

--*/
STDMETHODIMP
CIPConfMSPStream::LinkInnerCallQC (
    IN IInnerCallQualityControl *pIInnerCallQC
    )
{
    ENTER_FUNCTION ("CIPConfMSPStream::LinkInnerCallQC");

    CLock lock(m_lock);

    if (IsBadReadPtr (pIInnerCallQC, sizeof (IInnerCallQualityControl)))
    {
        LOG ((MSP_ERROR, "%s received bad read pointer", __fxName));
        return E_POINTER;
    }

    // m_pStreamQCRelay is created here.

    if (NULL != m_pStreamQCRelay)
    {
        LOG ((MSP_ERROR, "%s was called more than once", __fxName));
        return E_UNEXPECTED;
    }

    m_pStreamQCRelay = new CStreamQualityControlRelay ();
    
    if (NULL == m_pStreamQCRelay)
    {
        LOG ((MSP_ERROR, "%s failed to create qc relay", __fxName));
        return E_OUTOFMEMORY;
    }

    // store inner call qc in stream relay
    HRESULT hr = m_pStreamQCRelay->LinkInnerCallQC (pIInnerCallQC);
    if (FAILED (hr))
    {
        LOG ((MSP_ERROR, "%s failed to call setup on qc relay. %x", __fxName, hr));
        delete m_pStreamQCRelay;
        return hr;
    }

    return S_OK;
}

/*++

Routine Description:

    This method is called when the stream is shutdown. It destroys stream
    quality control relay.

--*/
STDMETHODIMP
CIPConfMSPStream::UnlinkInnerCallQC (
    IN BOOL fByStream
    )
{
    ENTER_FUNCTION ("CIPConfMSPStream::UnlinkInnerCallQC");

    CLock lock(m_lock);

    if (NULL == m_pStreamQCRelay)
    {
        LOG ((MSP_WARN, "%s: stream qc relay is null", __fxName));
        return S_OK; // ignore
    }

    HRESULT hr;

    if (!fByStream)
    {
        // if initiated by call
        m_fAccessingQC = TRUE;

        if (FAILED (hr = m_pStreamQCRelay->UnlinkInnerCallQC (NULL)))
            LOG ((MSP_ERROR, "%s failed to unlink by call. %x", __fxName, hr));

        m_fAccessingQC = FALSE;
    }
    else
    {
        // initiated by stream
        IInnerStreamQualityControl *pIInnerStreamQC;
        hr = this->_InternalQueryInterface (
            __uuidof (IInnerStreamQualityControl),
            (void **) &pIInnerStreamQC
            );
        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to query inner stream qc interface, %d", __fxName, hr));
            return hr;
        }

        m_fAccessingQC = TRUE;

        if (FAILED (hr = m_pStreamQCRelay->UnlinkInnerCallQC (pIInnerStreamQC)))
            LOG ((MSP_ERROR, "%s failed to unlink by stream. %x", __fxName, hr));

        m_fAccessingQC = FALSE;

        pIInnerStreamQC->Release ();
    }

    delete m_pStreamQCRelay;
    m_pStreamQCRelay = NULL;

    return hr;
}

/*++

Routine Description:

    This method is implemented by each specific stream class

--*/
STDMETHODIMP
CIPConfMSPStream::GetRange (
    IN  InnerStreamQualityProperty property,
    OUT LONG *plMin,
    OUT LONG *plMax,
    OUT LONG *plSteppingDelta,
    OUT LONG *plDefault,
    OUT TAPIControlFlags *plFlags
    )
{
    return E_NOTIMPL;
}

/*++

Routine Description:

    This method is implemented by each specific stream class

--*/
STDMETHODIMP
CIPConfMSPStream::Get(
    IN  InnerStreamQualityProperty property,
    OUT LONG *plValue,
    OUT TAPIControlFlags *plFlags
    )
{
    if (m_pStreamQCRelay)
        return m_pStreamQCRelay->Get (property, plValue, plFlags);

    return E_NOTIMPL;
}

/*++

Routine Description:

    This method is implemented by each specific stream class

--*/
STDMETHODIMP
CIPConfMSPStream::Set(
    IN  InnerStreamQualityProperty property,
    IN  LONG lValue,
    IN TAPIControlFlags lFlags
    )
{
    if (m_pStreamQCRelay)
        return m_pStreamQCRelay->Set (property, lValue, lFlags);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confterm.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    IPConfterm.h

Abstract:

    Definitions for the CIPConfBaseTerminal

Author:

    Zoltan Szilagyi (zoltans) September 6,1998

--*/

#ifndef _IPConfTERM_H_
#define _IPConfTERM_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CIPConfBaseTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CIPConfBaseTerminal : 
    virtual public CComObjectRootEx<CComMultiThreadModelNoCS>, // we have our own CS implementation
    public IDispatchImpl<ITTerminal, &__uuidof(ITTerminal), &LIBID_TAPI3Lib>,
    public ITTerminalControl,
    public CMSPObjectSafetyImpl
{

BEGIN_COM_MAP(CIPConfBaseTerminal)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTerminal)
    COM_INTERFACE_ENTRY(ITTerminalControl)
    COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
    COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

public:

    CIPConfBaseTerminal();
    HRESULT FinalConstruct();
    virtual ~CIPConfBaseTerminal();

public:
// ITTerminal -- COM interface for use by MSP or application
    STDMETHOD(get_TerminalClass)(OUT  BSTR *pVal);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pVal);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pVal);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);

// ITTerminalControl -- COM interface for use by MSP only

    STDMETHOD (get_AddressHandle) (
            OUT     MSP_HANDLE    * phtAddress
            );

    STDMETHOD (ConnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved,
            IN OUT  DWORD          * pdwNumPins,
            OUT     IPin          ** ppPins
            );

    STDMETHOD (CompleteConnectTerminal) (void);

    STDMETHOD (DisconnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    STDMETHOD (RunRenderFilter) (void);

    STDMETHOD (StopRenderFilter) (void);

public:
    HRESULT Initialize(
            IN  WCHAR *             strName,
            IN  MSP_HANDLE          htAddress
            );

    HRESULT Initialize(
            IN  char *              strName,
            IN  MSP_HANDLE          htAddress
            );

protected:
    void Lock()     { EnterCriticalSection(&m_CritSec); }
    void Unlock()   { LeaveCriticalSection(&m_CritSec); }

    virtual DWORD GetNumExposedPins() const = 0;

    virtual HRESULT CreateFilter() = 0;

    virtual HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        ) = 0;

    virtual HRESULT AddFilterToGraph(
        IN  IGraphBuilder *pGraph
        );

    virtual HRESULT RemoveFilterFromGraph(
        IN  IGraphBuilder *pGraph
        );

protected:
    // The lock that protects the data members.
    CRITICAL_SECTION    m_CritSec;
    BOOL                m_fCritSecValid;

    // these five numbers need to be set by the derived class.
    GUID                m_TerminalClassID;
    TERMINAL_DIRECTION  m_TerminalDirection;
    TERMINAL_TYPE       m_TerminalType;
    TERMINAL_STATE      m_TerminalState;
    DWORD               m_dwMediaType;

    WCHAR               m_szName[MAX_PATH + 1];
    MSP_HANDLE          m_htAddress;

    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;

    // stores the filter graph builder (derives from IFilterGraph)
    IGraphBuilder *     m_pGraph;
    IBaseFilter *       m_pFilter;
};


#endif // _IPConfTERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confterm.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mspterm.cpp

Abstract:

    Implementations for the CIPConfBaseTerminal, CSingleFilterTerminal, and various
    work item / worker thread classes.

Author:

    Zoltan Szilagyi (zoltans) September 6,1998

--*/

#include "stdafx.h"

CIPConfBaseTerminal::CIPConfBaseTerminal()
    : m_fCritSecValid(FALSE)
    , m_TerminalClassID(GUID_NULL)
    , m_TerminalDirection(TD_CAPTURE)
    , m_TerminalType(TT_STATIC)
    , m_TerminalState(TS_NOTINUSE)
    , m_dwMediaType(0)
    , m_pFTM(NULL)
    , m_htAddress(NULL)
    , m_pGraph(NULL)
    , m_pFilter(NULL)
{
    LOG((MSP_TRACE, "CIPConfBaseTerminal::CIPConfBaseTerminal() called"));
    m_szName[0] = '\0';
}

HRESULT CIPConfBaseTerminal::FinalConstruct()
/*++

Routine Description:

    Finish the initialization of the object. If anything fails, this object
    will be deleted.

Arguments:
    
    nothing.

Return Value:

    S_OK
    E_OUTOFMEMORY
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::FinalConstruct");
    LOG((MSP_TRACE, "%s entered", __fxName));

    m_fCritSecValid = TRUE;

    __try
    {
        InitializeCriticalSection(&m_CritSec);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        m_fCritSecValid = FALSE;
    }

    if (!m_fCritSecValid)
    {
        LOG((MSP_ERROR, "%s init critical section failed", __fxName));
        return E_OUTOFMEMORY;
    }

    HRESULT hr = CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pFTM
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "%s create ftm failed, hr=%x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

CIPConfBaseTerminal::~CIPConfBaseTerminal()
/*++

Routine Description:

    This is the destructor of the base terminal.

Arguments:
    
Return Value:

    S_OK
--*/
{
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    
    if (m_pFilter)
    {
        m_pFilter->Release();
    }

    if (m_pFTM)
    {
        m_pFTM->Release();
    }
    
    if (m_fCritSecValid)
    {
        DeleteCriticalSection(&m_CritSec);
    }
    
    LOG((MSP_TRACE, 
        "CIPConfBaseTerminal::~CIPConfBaseTerminal() for %ws finished", m_szName));
}

HRESULT CIPConfBaseTerminal::Initialize(
    IN  WCHAR *             strName,
    IN  MSP_HANDLE          htAddress
    )
/*++

Routine Description:

    This function sets the name and the address handle on the terminal.

Arguments:
    
    strName - The name of the terminal.

    htAddress - The handle that identifies the address object that this
                terminal belongs to.

Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::Initialize");
    LOG((MSP_TRACE, "%s entered", __fxName));

    m_htAddress         = htAddress;
    lstrcpynW(m_szName, strName, MAX_PATH);

    LOG((MSP_TRACE, "%s - exit S_OK", __fxName));
    return S_OK;
}

HRESULT CIPConfBaseTerminal::Initialize(
    IN  char *              strName,
    IN  MSP_HANDLE          htAddress
    )
/*++

Routine Description:

    This function sets the name and the address handle on the terminal. This
    function takes ascii string name.

Arguments:
    
    strName - The name of the terminal.

    htAddress - The handle that identifies the address object that this
                terminal belongs to.

Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::Initialize");
    LOG((MSP_TRACE, "%s entered", __fxName));

    m_htAddress         = htAddress;
    MultiByteToWideChar(
              GetACP(),
              0,
              strName,
              lstrlenA(strName)+1,
              m_szName,
              MAX_PATH
              );

    LOG((MSP_TRACE, "%s - exit S_OK", __fxName));
    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_Name(
    BSTR * pbsName
    )
/*++

Routine Description:

    This function return the name of the terminal.

Arguments:
    
    pbsName - A pointer to a BSTR to receive the terminal name.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_Name");

    if ( IsBadWritePtr( pbsName, sizeof(BSTR) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pbsName = SysAllocString(m_szName);

    if ( *pbsName == NULL )
    {
        LOG((MSP_ERROR, "%s, out of memory for name", __fxName)); 
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_State(
    TERMINAL_STATE * pVal
    )
/*++

Routine Description:

    This function return the state of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_STATE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_State");

    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_STATE) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalState;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalType(
    TERMINAL_TYPE * pVal
    )
/*++

Routine Description:

    This function return the type of the terminal.

Arguments:
    
    pVal - A pointer to a variable of type TERMINAL_TYPE.

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalType");
    
    if ( IsBadWritePtr( pVal, sizeof(TERMINAL_TYPE) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pVal = m_TerminalType;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_TerminalClass(
    BSTR * pbsClassID
    )
/*++

Routine Description:

    This function return the class of the terminal.

Arguments:
    
    pbsClassID - A pointer to a BSTR to receive the classID as a string.

Return Value:

    E_POINTER
    E_OUTOFMEMORY
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalClass");

    if ( IsBadWritePtr( pbsClassID, sizeof(BSTR) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    // Convert the CLSID to an string.
    WCHAR *pszName = NULL;
    
    HRESULT hr = ::StringFromCLSID(m_TerminalClassID, &pszName);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, failed to convert GUID, hr = %x", __fxName, hr));
        return hr;
    }

    // Put the string in a BSTR.
    BSTR bClassID = ::SysAllocString(pszName);

    // Free the OLE string.
    ::CoTaskMemFree(pszName);

    if (bClassID == NULL)
    {
        LOG((MSP_ERROR, "%s, out of mem for class ID", __fxName));
        return E_OUTOFMEMORY;
    }

    *pbsClassID = bClassID;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_Direction(
    OUT  TERMINAL_DIRECTION *pDirection
    )
/*++

Routine Description:

    This function return the direction of the terminal.

Arguments:
    
    pDirection - A pointer to a variable of type TERMINAL_DIRECTION

Return Value:

    E_POINTER
    S_OK
--*/
{   
    ENTER_FUNCTION("CIPConfBaseTerminal::get_TerminalClass");

    if ( IsBadWritePtr( pDirection, sizeof(TERMINAL_DIRECTION) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }

    *pDirection = m_TerminalDirection;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::get_MediaType(
    long * plMediaType
    )
/*++

Routine Description:

    This function return the media type of the terminal.

Arguments:
    
    plMediaType - A pointer to a variable of type long

Return Value:

    E_POINTER
    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::get_MediaType");

    if ( IsBadWritePtr(plMediaType, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName)); 
        return E_POINTER;
    }
    
    *plMediaType = (long) m_dwMediaType;

    return S_OK;
}


STDMETHODIMP CIPConfBaseTerminal::get_AddressHandle(
        OUT     MSP_HANDLE    * phtAddress
        )
/*++

Routine Description:

    This function return the handle of the address that created this terminal.

Arguments:
    
    phtAddress - A pointer to a variable of type MSP_HANDLE

Return Value:

    E_POINTER
    S_OK
--*/
{
    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadWritePtr(phtAddress, sizeof(MSP_HANDLE)));

    *phtAddress = m_htAddress;

    return S_OK;
}

STDMETHODIMP CIPConfBaseTerminal::ConnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved,
        IN OUT  DWORD          * pdwNumPins,
        OUT     IPin          ** ppPins
        )
/*++

Routine Description:

    This function is called by the MSP while trying to connect the filter in
    the terminal to the rest of the graph in the MSP. It adds the filter into
    the graph and returns the pins can be used by the MSP.

Arguments:
    
    pGraph - The filter graph.

    dwReserved - A reserved dword.

    pdwNumPins - The maxinum number of pins the msp wants.

    ppPins  - A pointer to the buffer that can store the IPin pointers. If it
              is NULL, only the actual number of pins will be returned.

Return Value:

S_OK
TAPI_E_NOTENOUGHMEMORY - the buffer is too small.
TAPI_E_TERMINALINUSE - the terminal is in use.
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::ConnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwREserved:%p", __fxName, pGraph, dwReserved));

    // this function is only called from the MSP, so only assert here.    
    _ASSERT(!IsBadReadPtr(pGraph, sizeof(IGraphBuilder)));
    _ASSERT(!IsBadWritePtr(pdwNumPins, sizeof(DWORD)));

    // find the number of exposed pins on the filter. 
    // This function doesn't fail.
    DWORD dwActualNumPins = GetNumExposedPins();

    //
    // If ppPins is NULL, just return the number of pins and don't try to
    // connect the terminal.
    //
    if ( ppPins == NULL )
    {
        LOG((MSP_TRACE, 
            "%s number of exposed pins:%d", __fxName, dwActualNumPins));
        *pdwNumPins = dwActualNumPins;
        return S_OK;
    }

    //
    // Otherwise, we have a pin return buffer. Check that the purported buffer
    // size is big enough and that the buffer is actually writable to the size
    // we need.
    //
    if ( *pdwNumPins < dwActualNumPins )
    {
        LOG((MSP_ERROR, 
            "%s not enough space to place pins.", __fxName));

        *pdwNumPins = dwActualNumPins;
        
        return TAPI_E_NOTENOUGHMEMORY;
    }

    if ( IsBadWritePtr(ppPins, dwActualNumPins * sizeof(IPin *) ) )
    {
        LOG((MSP_ERROR, 
            "%s, bad pins array pointer; exit E_POINTER", __fxName));

        return E_POINTER;
    }

    //
    // Check if we're already connected, and if so, change our state to
    // connected. Note that this makes sense for both core static terminals
    // and dynamic terminals. Also note that we need to protect this with
    // a critical section, but after this we can let go of the lock because
    // anyone who subsequently enters the critical section will bail at this
    // point.
    //

    Lock();

    //
    // check if already connected
    //

    if (TS_INUSE == m_TerminalState)
    {
        LOG((MSP_ERROR, 
            "%s, terminal already in use", __fxName));

        Unlock();
        return TAPI_E_TERMINALINUSE;
    }

    IPin * pTerminalPin;

    // add filter to the filter graph
    HRESULT hr = AddFilterToGraph(pGraph);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, can't add filters to graph", __fxName));

        Unlock();
        return hr;
    }

    //
    // Get the pins that our filter exposes. 
    //
    *pdwNumPins = dwActualNumPins;
    hr = GetExposedPins(ppPins, dwActualNumPins);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "%s, GetExposedPins returned hr=%x", __fxName, hr));

        // best effort attempt to disconnect - ignore error code
        RemoveFilterFromGraph(pGraph);
        
        Unlock();
        return hr;
    }

    m_pGraph        = pGraph;
    m_pGraph->AddRef();

    m_TerminalState = TS_INUSE;

    Unlock();

    LOG((MSP_TRACE, "CIPConfBaseTerminal::ConnectTerminal success"));
    return hr;
}

STDMETHODIMP 
CIPConfBaseTerminal::CompleteConnectTerminal(void)
/*++

Routine Description:

    This function is called after a successful ConnectTerminal so that the 
    terminal can do post-connection intitialization. 

Arguments:

    nothing    

Return Value:

S_OK
--*/
{
    return S_OK;
}


STDMETHODIMP 
CIPConfBaseTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
/*++

Routine Description:

    This function is called by the MSP while trying to disconnect the filter in
    the terminal from the rest of the graph in the MSP. It adds the removes the
    filter from the graph and set the terminal free.

Arguments:
    
    pGraph - The filter graph. It is used for validation, to make sure the 
             terminal is disconnected from the same graph that it was 
             originally connected to.

    dwReserved - A reserved dword.

Return Value:

S_OK
E_INVALIDARG - wrong graph.

--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::DisconnectTerminal");
    LOG((MSP_TRACE, 
        "%s entered, pGraph:%p, dwReserved:%d", __fxName, pGraph, dwReserved));

    Lock();

    //
    // If not in use, then there is nothing to be done.
    //
    if ( TS_INUSE != m_TerminalState ) 
    {
        _ASSERTE(m_pGraph == NULL);
        LOG((MSP_TRACE, "%s, success; not in use", __fxName));

        Unlock();
        return S_OK;
    }

    //
    // Check that we are being disconnected from the correct graph.
    //
    if (pGraph == NULL || m_pGraph != pGraph )
    {
        LOG((MSP_TRACE, "%s, wrong graph:%p", __fxName, pGraph));
        
        Unlock();
        return E_INVALIDARG;
    }


    HRESULT hr = S_OK;

    //
    // Remove filter from the graph, release our reference to the graph,
    // and set ourselves to notinuse state
    //
    hr = RemoveFilterFromGraph(m_pGraph);
    
    m_pGraph->Release();
    m_pGraph = NULL;
    
    m_TerminalState = TS_NOTINUSE;

    Unlock();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s, remove filters from graph failed; returning 0x%08x", 
            __fxName, hr));
    }
    else
    {
        LOG((MSP_TRACE, "%s succeeded", __fxName));
    }

    return hr;
}

STDMETHODIMP CIPConfBaseTerminal::RunRenderFilter(void)
/*++

Routine Description:

    start the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP CIPConfBaseTerminal::StopRenderFilter(void)
/*++

Routine Description:

    stops the rightmost render filter in the terminal
    (needed for dynamic filter graphs)

Arguments:
    
Return Value:

    E_NOTIMPL
--*/
{
    return E_NOTIMPL;
}

HRESULT CIPConfBaseTerminal::AddFilterToGraph(
    IN  IGraphBuilder *pGraph
    )
/*++

Routine Description:

    Add the internal filter into a graph.

Arguments:
    
    pGraph - the filter graph to add the filter to.

Return Value:

    HRESULT
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::AddFilterToGraph");
    LOG((MSP_TRACE, "%s entered, pGraph:%p", __fxName, pGraph));

    HRESULT hr;

    if (m_pFilter == NULL)
    {
        hr = CreateFilter();

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, Create filter failed. hr=%x", __fxName, hr));
            return hr;
        }
    }

    _ASSERT(pGraph != NULL);
    _ASSERT(m_pFilter != NULL);

    hr = pGraph->AddFilter(m_pFilter, NULL);

    return hr;
}


HRESULT CIPConfBaseTerminal::RemoveFilterFromGraph(
    IN  IGraphBuilder *pGraph
    )
/*++

Routine Description:

    Remove the internal filter from the graph it was added.

Arguments:
    
    pGraph - the filter graph to remove the filter from.

Return Value:

    S_FALSE - the internal filter doesn't exist.
--*/
{
    ENTER_FUNCTION("CIPConfBaseTerminal::RemoveFilterFromGraph");
    LOG((MSP_TRACE, "%s entered, pGraph:%p", __fxName, pGraph));

    if (m_pFilter == NULL)
    {
        LOG((MSP_TRACE, "%s, no filter to remove", __fxName));
        return S_FALSE;
    }

    // remove the filter from the graph
    _ASSERT(pGraph != NULL);
    HRESULT hr = pGraph->RemoveFilter(m_pFilter);

    m_pFilter->Release();
    m_pFilter = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confutil.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    MSPutil.cpp 

Abstract:

    This module contains implementation of msp utility functions.

Author:
    
    Mu Han (muhan)   1-November-1997

--*/
#include "stdafx.h"

BOOL
IsPayloadSupported(IN DWORD dwPT)
{
    switch (dwPT)
    {
        case PAYLOAD_G711U:
        case PAYLOAD_G711A:
        case PAYLOAD_GSM:
        case PAYLOAD_DVI4_8:
        case PAYLOAD_DVI4_16:
        case PAYLOAD_MSAUDIO:
        case PAYLOAD_H261:
        case PAYLOAD_H263:
            return TRUE;
        default:
            return FALSE;
    }
}

HRESULT
AddFilter(
    IN IGraphBuilder *      pIGraph,
    IN const CLSID &        Clsid,
    IN LPCWSTR              pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    )
/*++

Routine Description:

    Create a filter and add it into the filtergraph.

Arguments:
    
    pIGraph         - the filter graph.

    Clsid           - reference to the CLSID of the filter

    pwstrName       - The name of ther filter added.

    ppIBaseFilter   - pointer to a pointer that stores the returned IBaseFilter
                      interface pointer to the newly created filter.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "AddFilter %ws", pwstrName));

    _ASSERTE(ppIBaseFilter != NULL);

    HRESULT hr;

    if (FAILED(hr = CoCreateInstance(
            Clsid,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            __uuidof(IBaseFilter),
            (void **) ppIBaseFilter
            )))
    {
        LOG((MSP_ERROR, "create filter %x", hr));
        return hr;
    }

    if (FAILED(hr = pIGraph->AddFilter(*ppIBaseFilter, pwstrName)))
    {
        LOG((MSP_ERROR, "add filter. %x", hr));
        (*ppIBaseFilter)->Release();
        *ppIBaseFilter = NULL;
        return hr;
    }

    return S_OK;
}

HRESULT
PinSupportsMediaType (
    IN IPin *pIPin,
    IN const GUID & MediaType
    )
/*++

Return Value:

    S_OK - media type supported
    S_FALSE - no
    other HRESULT value - error code

--*/
{
    LOG ((MSP_TRACE, "Check if the media subtype supported on pin"));

    HRESULT hr;

    // get IEnumMediaTypes on pin
    IEnumMediaTypes *pEnum = NULL;
    if (FAILED (hr = pIPin->EnumMediaTypes (&pEnum)))
    {
        LOG ((MSP_ERROR, "Failed to get IEnumMediaTypes on pin"));
        return hr;
    }

    // retrieve one media type each time
    AM_MEDIA_TYPE *pMediaType = NULL;
    ULONG cFetched;
    while (S_OK == (hr = pEnum->Next (1, &pMediaType, &cFetched)))
    {
        if (IsEqualGUID(pMediaType->majortype, MediaType))
        {
            // media subtype matched
            MSPDeleteMediaType (pMediaType);
            pEnum->Release ();
            return S_OK;
        }

        MSPDeleteMediaType (pMediaType);
    }

    pEnum->Release ();
    return hr;
}

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    )
/*++

Routine Description:

    Set the address of a rtp stream

Arguments:
    
    pIBaseFilter    - an rtp source filters.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "EnableRTCPEvents"));

/*
    HRESULT hr;

    // Get the IRTCPStream interface pointer on the filter.
    CComQIPtr<IRTCPStream, 
        &__uuidof(IRTCPStream)> pIRTCPStream(pIBaseFilter);
    if (pIRTCPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTCP Stream interface"));
        return E_NOINTERFACE;
    }

    // enable events.
    if (FAILED(hr = pIRTCPStream->ModifyRTCPEventMask(  
            (1 << DXMRTP_NEW_SOURCE_EVENT) |
            (1 << DXMRTP_RECV_RTCP_SNDR_REPORT_EVENT) |
            (1 << DXMRTP_RECV_RTCP_RECV_REPORT_EVENT) |
            (1 << DXMRTP_TIMEOUT_EVENT) |
            (1 << DXMRTP_BYE_EVENT)   
            , 1
            )))
    {
        LOG((MSP_ERROR, "set Address. %x", hr));
        return hr;
    }

*/    return S_OK;
}


HRESULT
SetLoopbackOption(
    IN IBaseFilter *pIBaseFilter,
    IN MULTICAST_LOOPBACK_MODE  LoopbackMode
    )
/*++

Routine Description:

    Enable of disable loopback based on registry settings.

Arguments:
    
    pIBaseFilter    - rtp source filter.

    bLoopback       - enable loopback or not.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetLoopbackOption"));

    HRESULT hr;

/*
    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, 
        &__uuidof(IRTPStream)> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    _ASSERT(MM_NO_LOOPBACK == DXMRTP_NO_MULTICAST_LOOPBACK);
    _ASSERT(MM_FULL_LOOPBACK == DXMRTP_FULL_MULTICAST_LOOPBACK);
    _ASSERT(MM_SELECTIVE_LOOPBACK == DXMRTP_SELECTIVE_MULTICAST_LOOPBACK);

    // Set the loopback mode used in the filter.
    if (FAILED(hr = pIRTPStream->SetMulticastLoopBack(
            (DXMRTP_MULTICAST_LOOPBACK_MODE)LoopbackMode)))
    {
        LOG((MSP_ERROR, "set loopback. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "loopback enabled."));
    return hr;
*/
    return E_NOTIMPL;
}

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBitRate,
    IN BOOL             bFailIfNoQOS,
    IN BOOL             bReceive,
    IN DWORD            dwNumStreams,
    IN BOOL             bCIF
    )
/*++

Routine Description:

    Enable QOS.

Arguments:
    
    pIBaseFilter    - rtp source filter.

    dwPayloadType   - the rtp payload type of this stream.

    bFailIfNoQOS    - fail the stream is QOS is not available.

    bReceive        - if this stream is a receiving stream.

    dwNumStreams    - the number of streams reserved.

    bCIF            - CIF or QCIF.

Return Value:

    HRESULT

--*/
{
/*
    LOG((MSP_TRACE, "SetQOSOption"));

    char * szQOSName;
    DWORD fSharedStyle = DXMRTP_RESERVE_EXPLICIT;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711U:
    case PAYLOAD_G711A:
        szQOSName       = "G711";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;

        break;

    case PAYLOAD_GSM:
        
        szQOSName       = "GSM6.10";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;
        
        break;

    case PAYLOAD_G723:
        
        szQOSName       = "G723";
        fSharedStyle    = DXMRTP_RESERVE_WILCARD;

        break;

    case PAYLOAD_H261:
        szQOSName = (bCIF) ? "H261CIF" : "H261QCIF";
        break;

    case PAYLOAD_H263:
        szQOSName = (bCIF) ? "H263CIF" : "H263QCIF";
        break;

    default:
        LOG((MSP_WARN, "Don't know the QOS name for payload type: %d", 
            dwPayloadType));
        return S_FALSE;
    }

    // Get the IRTPStream interface pointer on the filter.
    CComQIPtr<IRTPStream, 
        &__uuidof(IRTPStream)> pIRTPStream(pIBaseFilter);
    if (pIRTPStream == NULL)
    {
        LOG((MSP_ERROR, "get RTP Stream interface"));
        return E_NOINTERFACE;
    }

    HRESULT hr;

    // Enable QOS, 
    if (FAILED(hr = pIRTPStream->SetQOSByName(szQOSName, bFailIfNoQOS)))
    {
        LOG((MSP_ERROR, "set QOS by name. %x", hr));
        return hr;
    }

    // Get the IRTPParticipant interface pointer on the filter.
    CComQIPtr<IRTPParticipant,
        &__uuidof(IRTPParticipant)> pIRTPParticipant(pIBaseFilter);
    if (pIRTPParticipant == NULL)
    {
        LOG((MSP_ERROR, "get RTP participant interface"));
        return E_NOINTERFACE;
    }

    if (FAILED(hr = pIRTPParticipant->SetMaxQOSEnabledParticipants(
            (bReceive) ? dwNumStreams : 1,
            dwMaxBitRate,
            fSharedStyle 
        )))
    {
        LOG((MSP_ERROR, "SetMaxQOSEnabledParticipants. %x", hr));
        return hr;
    }

    DWORD dwQOSEventMask = 
            (1 << DXMRTP_QOSEVENT_NOQOS) |
            (1 << DXMRTP_QOSEVENT_REQUEST_CONFIRMED) |
            (1 << DXMRTP_QOSEVENT_ADMISSION_FAILURE) |
            (1 << DXMRTP_QOSEVENT_POLICY_FAILURE) |
            (1 << DXMRTP_QOSEVENT_BAD_STYLE) |
            (1 << DXMRTP_QOSEVENT_BAD_OBJECT) |
            (1 << DXMRTP_QOSEVENT_TRAFFIC_CTRL_ERROR) |
            (1 << DXMRTP_QOSEVENT_GENERIC_ERROR);

    if (bReceive)
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_SENDERS) |
            (1 << DXMRTP_QOSEVENT_NO_SENDERS);
    }
    else
    {
        dwQOSEventMask |= 
            (1 << DXMRTP_QOSEVENT_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NO_RECEIVERS) |
            (1 << DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND) |
            (1 << DXMRTP_QOSEVENT_ALLOWEDTOSEND);
    }

    // enable events.
    if (FAILED(hr = pIRTPStream->ModifyQOSEventMask(dwQOSEventMask, 1)))
    {
        LOG((MSP_ERROR, "set QOSEventMask. %x", hr));
        return hr;
    }

    LOG((MSP_INFO, "enabled qos for %s.", szQOSName));
    return hr;
*/
    return E_NOTIMPL;
}

HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree
    )
/*++

Routine Description:

    Find a input pin or output pin on a filter.

Arguments:
    
    pIFilter    - the filter that has pins.

    ppIPin      - the place to store the returned interface pointer.

    direction   - PINDIR_INPUT or PINDIR_OUTPUT.

    bFree       - look for a free pin or not.

Return Value:

    HRESULT

--*/
{
    _ASSERTE(ppIPin != NULL);

    HRESULT hr;
    DWORD dwFeched;

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;
    if (FAILED(hr = pIFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    IPin * pIPin = NULL;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            LOG((MSP_ERROR, "find pin on filter."));
            return E_FAIL;
        }
        if (0 == dwFeched)
        {
            LOG((MSP_ERROR, "get 0 pin from filter."));
            return E_FAIL;
        }

        PIN_DIRECTION dir;
        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((MSP_ERROR, "query pin direction. %x", hr));
            pIPin->Release();
            return hr;
        }
        if (direction == dir)
        {
            if (!bFree)
            {
                break;
            }

            // Check to see if the pin is free.
            CComPtr<IPin> pIPinConnected;
            hr = pIPin->ConnectedTo(&pIPinConnected);
            if (pIPinConnected == NULL)
            {
                break;
            }
        }
        pIPin->Release();
    }

    *ppIPin = pIPin;

    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect the output pin of the first filter to the input pin of the
    second filter.

Arguments:

    pIGraph     - the filter graph.

    pIFilter1   - the filter that has the output pin.

    pIFilter2   - the filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;

    CComPtr<IPin> pIPinOutput;
    if (FAILED(hr = ::FindPin(pIFilter1, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find output pin on filter1. %x", hr));
        return hr;
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pIFilter2, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter2. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
 
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an output pin to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinInput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinInput, PINDIR_INPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }
    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect,
    IN AM_MEDIA_TYPE *  pmt
    )
/*++

Routine Description:

    Connect an filter to the input pin of a filter.

Arguments:
    
    pIGraph     - the filter graph.

    pIPinOutput - an output pin.

    pIFilter    - a filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "ConnectFilters"));

    HRESULT hr;
    CComPtr<IPin> pIPinOutput;

    if (FAILED(hr = ::FindPin(pIFilter, &pIPinOutput, PINDIR_OUTPUT)))
    {
        LOG((MSP_ERROR, "find input pin on filter. %x", hr));
        return hr;
    }

    if (fDirect)
    {
        if (FAILED(hr = pIGraph->ConnectDirect(pIPinOutput, pIPinInput, pmt))) 
        {
            LOG((MSP_ERROR, "connect pins direct failed: %x", hr));
            return hr;
        }
    }
    else
    {
        if (FAILED(hr = pIGraph->Connect(pIPinOutput, pIPinInput))) 
        {
            LOG((MSP_ERROR, "connect pins %x", hr));
            return hr;
        }
    }

    return S_OK;
}


void WINAPI MSPDeleteMediaType(AM_MEDIA_TYPE *pmt)
/*++

Routine Description:
    
    Delete a AM media type returned by the filters.

Arguments:

    pmt     - a pointer to a AM_MEDIA_TYPE structure.

Return Value:

    HRESULT

--*/
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    if (pmt->cbFormat != 0) {
        CoTaskMemFree((PVOID)pmt->pbFormat);

        // Strictly unnecessary but tidier
        pmt->cbFormat = 0;
        pmt->pbFormat = NULL;
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }

    CoTaskMemFree((PVOID)pmt);
}


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    )
/*++

Routine Description:

    Get a dword from the registry in the ipconfmsp key.

Arguments:
    
    szName  - The name of the value.

    pdwValue  - a pointer to the dword returned.

Return Value:

    TURE    - SUCCEED.

    FALSE   - MSP_ERROR

--*/
{
    HKEY  hKey;
    DWORD dwDataSize, dwDataType, dwValue;

    if (::RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszSDPMSPKey,
        0,
        KEY_READ,
        &hKey) != NOERROR)
    {
        return FALSE;
    }

    dwDataSize = sizeof(DWORD);
    if (::RegQueryValueExW(
        hKey,
        szName,
        0,
        &dwDataType,
        (LPBYTE) &dwValue,
        &dwDataSize) != NOERROR)
    {
        RegCloseKey (hKey);
        return FALSE;
    }

    *pdwValue = dwValue;

    RegCloseKey (hKey);
    
    return TRUE;
}


HRESULT
FindACMAudioCodec(
    IN DWORD dwPayloadType,
    OUT IBaseFilter **ppIBaseFilter
    )
/*++

Routine Description:

    Find the audio codec filter based on the payload type.

Arguments:
    
    dwPayloadType   - The rtp payload type.

    ppIBaseFilter   - The returned interface pointer.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "Find audio codec Called."));

    _ASSERTE(ppIBaseFilter != NULL);

    HRESULT hr;

    int AcmId;

    switch (dwPayloadType)
    {
    case PAYLOAD_G711A:
        AcmId = WAVE_FORMAT_ALAW;
        break;

    case PAYLOAD_G711U:
        AcmId = WAVE_FORMAT_MULAW;
        break;

    case PAYLOAD_GSM:
        AcmId = WAVE_FORMAT_GSM610;
        break;

    case PAYLOAD_MSAUDIO:
        AcmId = WAVE_FORMAT_MSAUDIO1;
        break;

    case PAYLOAD_G721:
        AcmId = WAVE_FORMAT_ADPCM;
        break;
    
    case PAYLOAD_DVI4_8:
        AcmId = WAVE_FORMAT_DVI_ADPCM;
        break;
    
    default:
        return E_FAIL;
    }

    //
    // Create the DirectShow Category enumerator Creator
    //
    CComPtr<ICreateDevEnum> pCreateDevEnum;
    CComPtr<IEnumMoniker> pCatEnum;

    hr = CoCreateInstance(
        CLSID_SystemDeviceEnum, 
        NULL, 
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(ICreateDevEnum), 
        (void**)&pCreateDevEnum);

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "Create system device enum - hr: %8x", hr));
        return hr;
    }

    hr = pCreateDevEnum->CreateClassEnumerator(
        CLSID_CAcmCoClassManager, 
        &pCatEnum, 
        0
        );

    if (hr != S_OK) 
    {
        LOG((MSP_ERROR, "CreateClassEnumerator - hr: %8x", hr));
        return hr;
    }

    // find the acm wrapper we want to use.
    for (;;)
    {
        ULONG cFetched;
        CComPtr<IMoniker> pMoniker;

        if (S_OK != (hr = pCatEnum->Next(1, &pMoniker, &cFetched)))
        {
            break;
        }

        // Get the ACMid for this filter out of the property bag.
        CComPtr<IPropertyBag> pBag;
        hr = pMoniker->BindToStorage(0, 0, __uuidof(IPropertyBag), (void **)&pBag);
        if (FAILED(hr)) 
        {
            LOG((MSP_ERROR, "get property bag - hr: %8x", hr));
            continue;
        }

        VARIANT var;
        var.vt = VT_I4;
        hr = pBag->Read(L"AcmId", &var, 0);
        if (FAILED(hr)) 
        {
            LOG((MSP_ERROR, "read acmid - hr: %8x", hr));
            continue;
        }

        if (AcmId == V_I4(&var))
        {
            // Now make the filter for this.
            hr = pMoniker->BindToObject(
                0, 
                0, 
                __uuidof(IBaseFilter), 
                (void**)ppIBaseFilter
                );

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "BindToObject - hr: %8x", hr));
            }
            break;
        }
    }

    return hr;
}

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    )
/*++

Routine Description:

    Get the IAMStreamConfig interface on the pin and config the
    audio format by using WAVEFORMATEX.

Arguments:
    
    pIUnknown - an object to configure.

    wBitPerSample  - the number of bits in each sample.

    dwSampleRate    - number of samples per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioFormat entered"));

    HRESULT hr;

    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        __uuidof(IAMStreamConfig),
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }

    AM_MEDIA_TYPE mt;
    WAVEFORMATEX wfx;

    wfx.wFormatTag          = WAVE_FORMAT_PCM;
    wfx.wBitsPerSample      = wBitPerSample;
    wfx.nChannels           = 1;
    wfx.nSamplesPerSec      = dwSampleRate;
    wfx.nBlockAlign         = wfx.wBitsPerSample * wfx.nChannels / 8;
    wfx.nAvgBytesPerSec     = ((DWORD) wfx.nBlockAlign * wfx.nSamplesPerSec);
    wfx.cbSize              = 0;

    mt.majortype            = MEDIATYPE_Audio;
    mt.subtype              = MEDIASUBTYPE_PCM;
    mt.bFixedSizeSamples    = TRUE;
    mt.bTemporalCompression = FALSE;
    mt.lSampleSize          = 0;
    mt.formattype           = FORMAT_WaveFormatEx;
    mt.pUnk                 = NULL;
    mt.cbFormat             = sizeof(WAVEFORMATEX);
    mt.pbFormat             = (BYTE*)&wfx;

    // set the format of the audio capture terminal.
    if (FAILED(hr = pIAMStreamConfig->SetFormat(&mt)))
    {
        LOG((MSP_ERROR, "SetFormat returns error: %8x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    )
/*++

Routine Description:

    Set the audio capture output pin's buffer size. The buffer size
    determins how many milliseconds worth of samples are contained 
    in a buffer.

Arguments:
    
    pIUnknown - an object to configure.

    dwNumBuffers - the number of buffers to be allocated. Too few buffers
    might cause starvation on the capture device.

    dwBufferSize - The size of each buffer.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetAudioBufferSize, dwNumBuffers %d, dwBuffersize %d",
        dwNumBuffers, dwBufferSize));

    _ASSERTE(dwNumBuffers != 0 && dwBufferSize != 0);

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            __uuidof(IAMBufferNegotiation),
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

    // Set the number of buffers.
    prop.cBuffers = dwNumBuffers;
    prop.cbBuffer = dwBufferSize;

    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetAudioBuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}

/* Init reference time */
void CMSPStreamClock::InitReferenceTime(void)
{
    m_lPerfFrequency = 0;

    /* NOTE The fact that having multiprocessor makes the
     * performance counter to be unreliable (in some machines)
     * unless I set the processor affinity, which I can not
     * because any thread can request the time, so use it only on
     * uniprocessor machines */
    /* MAYDO Would be nice to enable this also in multiprocessor
     * machines, if I could specify what procesor's performance
     * counter to read or if I had a processor independent
     * performance counter */

    /* Actually the error should be quite smaller than 1ms, making
     * this bug irrelevant for my porpuses, so alway use performance
     * counter if available */
    QueryPerformanceFrequency((LARGE_INTEGER *)&m_lPerfFrequency);

    if (m_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&m_lRtpRefTime);
        /* Arbitrarily start time not at zero but at 100ms */
        m_lRtpRefTime -= m_lPerfFrequency/10;
    }
    else
    {
        m_dwRtpRefTime = timeGetTime();
        /* Arbitrarily start time not at zero but at 100ms */
        m_dwRtpRefTime -= 100;
    }
}

/* Return time in 100's of nanoseconds since the object was
 * initialized */
HRESULT CMSPStreamClock::GetTimeOfDay(OUT REFERENCE_TIME *pTime)
{
    union {
        DWORD            dwCurTime;
        LONGLONG         lCurTime;
    };
    LONGLONG         lTime;

    if (m_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        lCurTime = lTime - m_lRtpRefTime;

        *pTime = (REFERENCE_TIME)(lCurTime * 10000000 / m_lPerfFrequency);
    }
    else
    {
        dwCurTime = timeGetTime() - m_dwRtpRefTime;
        
        *pTime = (REFERENCE_TIME)(dwCurTime * 10000);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confvidt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: IPConfvidt.h
//
// Description: Definition of the CIPConfVideoCaptureTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IPConfVIDT_H_
#define _IPConfVIDT_H_

/////////////////////////////////////////////////////////////////////////////
// CIPConfVideoCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD VIDEO_CAPTURE_FILTER_NUMPINS = 3;

interface DECLSPEC_UUID("4eb8cf35-0015-4260-83ee-1a179b05717c") DECLSPEC_NOVTABLE
IConfVideoDummy : public IUnknown
{
};

#define IID_IConfVideoDummy __uuidof(IConfVideoDummy)

class CIPConfVideoCaptureTerminal :
    public IConfVideoDummy,
    public CIPConfBaseTerminal
{

    // COM_INTERFACE_ENTRY_CHAIN is not allowed to the 1st one is a MAP
    // entry IConfVideoDummy is to make BEGIN_COM_MAP happy
BEGIN_COM_MAP(CIPConfVideoCaptureTerminal)
    COM_INTERFACE_ENTRY(IConfVideoDummy)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfBaseTerminal)
END_COM_MAP()

public:
    CIPConfVideoCaptureTerminal();

    virtual ~CIPConfVideoCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  char *          strDeviceName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  char *          strName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress
        );

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return VIDEO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT    m_VideoCaptureID;
};


#endif // _IPConfVIDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confvidt.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    IPConfvidt.cpp

Abstract:

    IPConf MSP implementation of vido capture terminal.

Author:

    Zoltan Szilagyi (zoltans) September 6,1998
    Mu Han (muhan) June 6, 1999

--*/

#include "stdafx.h"

CIPConfVideoCaptureTerminal::CIPConfVideoCaptureTerminal()
{
    LOG((MSP_TRACE, "CIPConfVideoCaptureTerminal::CIPConfVideoCaptureTerminal"));
    m_TerminalClassID   = CLSID_VideoInputTerminal;
    m_TerminalDirection = TD_CAPTURE;
    m_TerminalType      = TT_STATIC;
    m_TerminalState     = TS_NOTINUSE;
    m_dwMediaType       = TAPIMEDIATYPE_VIDEO;
}

CIPConfVideoCaptureTerminal::~CIPConfVideoCaptureTerminal()
{
    LOG((MSP_TRACE, "CIPConfVideoCaptureTerminal::~CIPConfVideoCaptureTerminal"));
}


HRESULT CIPConfVideoCaptureTerminal::CreateTerminal(
    IN  char *          strDeviceName,
    IN  UINT            VideoCaptureID,
    IN  MSP_HANDLE      htAddress,
    OUT ITTerminal      **ppTerm
    )
/*++

Routine Description:

    This method creates a terminal object base to identify a video capture 
    device. 

Arguments:

    strDeviceName - the name of the device.

    VideoCaptureID - the index of the device.

    htAddress - the handle to the address object.

    ppTerm - memory to store the returned terminal pointer.
    
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfVideoCaptureTerminal::CreateTerminal");
    LOG((MSP_TRACE, "%s, htAddress:%x", __fxName, htAddress));

    _ASSERT(!IsBadWritePtr(ppTerm, sizeof(ITTerminal *)));

    HRESULT hr;

    // Create the filter.
    CMSPComObject<CIPConfVideoCaptureTerminal> *pTerminal = NULL;

    hr = ::CreateCComObjectInstance(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s can't create the terminal object hr = %8x", __fxName, hr));

        return hr;
    }

    // query for the ITTerminal interface
    ITTerminal *pITTerminal;
    hr = pTerminal->_InternalQueryInterface(
        __uuidof(ITTerminal), (void**)&pITTerminal
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, query terminal interface failed, %x", __fxName, hr));
        delete pTerminal;

        return hr;
    }

    // initialize the terminal 
    hr = pTerminal->Initialize(
            strDeviceName,
            VideoCaptureID,
            htAddress
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, 
            "%s, Initialize failed; returning 0x%08x", __fxName, hr));

        pITTerminal->Release();
    
        return hr;
    }

    LOG((MSP_TRACE, "%s, %s created", __fxName, strDeviceName));

    *ppTerm = pITTerminal;

    return S_OK;
}

HRESULT CIPConfVideoCaptureTerminal::Initialize(
    IN  char *          strName,
    IN  UINT            VideoCaptureID,
    IN  MSP_HANDLE      htAddress
    )
/*++

Routine Description:

    This function sets the video capture device ID and then calls the 
    Initialize method of the base class.

Arguments:
    
    strName - The name of the terminal.

    VideoCaptureID - The ID of the video capture device. Later it will be used
        in creating the video capture filer.

    htAddress - The handle that identifies the address object that this
                terminal belongs to.

Return Value:

    S_OK
--*/
{
    m_VideoCaptureID = VideoCaptureID;
    return CIPConfBaseTerminal::Initialize(strName, htAddress);
}

HRESULT CIPConfVideoCaptureTerminal::CreateFilter(void)
/*++

Routine Description:

    This method creates the filter in this terminal. It creates the tapi video
    capture filter and configures the device it uses.

Arguments:

    nothing.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfVideoCaptureTerminal::CreateFilters");
    LOG((MSP_TRACE, "%s, entered", __fxName));

    // This should only be called atmost once in the lifetime of this instance
    if (m_pFilter != NULL)
    {
        return S_OK;
    }

    IBaseFilter *pICaptureFilter;

    // Create the filter.
    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIVideoCapture),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&pICaptureFilter
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, CoCreate filter failed, %x", __fxName, hr));
        return hr;
    }
    
    // get the config interface.
    IVideoDeviceControl *pIVideoDeviceControl;
    hr = pICaptureFilter->QueryInterface(
        __uuidof(IVideoDeviceControl), 
        (void **)&pIVideoDeviceControl
        );

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, can't get the IVideoDeviceControl interface, %x", 
            __fxName, hr));
        return hr;
    }

    // tell the filter the device IDs.
    hr = pIVideoDeviceControl->SetCurrentDevice(m_VideoCaptureID);
    pIVideoDeviceControl->Release();

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        LOG((MSP_ERROR, 
            "%s, set device ID failed, %x", __fxName, hr));
        return hr;
    }

    // remember the filter, keep the refcount as well.
    m_pFilter = pICaptureFilter;

    LOG((MSP_TRACE, "%s succeeded", __fxName));
    return S_OK;
}

HRESULT CIPConfVideoCaptureTerminal::GetExposedPins(
    IN  IPin ** ppPins, 
    IN  DWORD dwNumPins
    )
/*++

Routine Description:

    This method returns the output pins of the video capture filter.

Arguments:

    ppPins - memory buffer to store the returned pins.

    dwNumPins - the number pins asked.
   
Return Value:

    S_OK
--*/
{
    ENTER_FUNCTION("CIPConfVideoRenderTerminal::GetExposedPins");
    LOG((MSP_TRACE, "%s entered, dwNumPins:%d", __fxName, dwNumPins));

    _ASSERT(m_pFilter != NULL);
    _ASSERT(dwNumPins != 0);
    _ASSERT(!IsBadWritePtr(ppPins, sizeof (IPin*) * dwNumPins));

    // Get the enumerator of pins on the filter.
    IEnumPins * pIEnumPins;
    HRESULT hr = m_pFilter->EnumPins(&pIEnumPins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s enumerate pins on the filter failed. hr=%x", __fxName, hr));
        return hr;
    }

    // TODO: get only the outptu pins.
    // get the pins.
    DWORD dwFetched;
    hr = pIEnumPins->Next(dwNumPins, ppPins, &dwFetched);

    pIEnumPins->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s IEnumPins->Next failed. hr=%x", __fxName, hr));
        return hr;
    }

    _ASSERT(dwFetched == dwNumPins);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\qccall.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    qccall.cpp

Abstract:

    Implementation of CCallQualityControlRelay

Author:

    Qianbo Huai (qhuai) 03/10/2000

--*/

#include "stdafx.h"

HRESULT TypeStream (IUnknown *p, LONG *pMediaType, TERMINAL_DIRECTION *pDirection);

class CInnerStreamLock
{
private:

    // no refcount
    IInnerStreamQualityControl  *m_pQC;

public:

    CInnerStreamLock(IInnerStreamQualityControl *pQC, BOOL *pfLocked)
        :m_pQC(NULL)
    {
        DWORD dwCount = 0;

        *pfLocked = FALSE;

        do
        {
            // try lock
            if (S_OK == pQC->TryLockStream())
            {
                m_pQC = pQC;
                *pfLocked = TRUE;

                if (dwCount > 0)
                {
                    LOG((MSP_TRACE, "InnerStreamLock: Succeed after %d tries %p", dwCount, pQC));
                }

                return;
            }

            // check if stream is accessing QC
            if (S_OK == pQC->IsAccessingQC())
            {
                LOG((MSP_WARN, "InnerStreamLock: Giving up to avoid deadlock %p", pQC));
                return;
            }

            // try again
            if (dwCount++ == 10)
            {
                LOG((MSP_WARN, "InnerStreamLock: Giving up after 10 tries %p", pQC));
                return;
            }

            // sleep 10 ms, default callback threshold is 7000 ms
            SleepEx(10, TRUE);

        } while (TRUE);

        // should never hit this line
        return;
    }

    ~CInnerStreamLock()
    {
        if (m_pQC != NULL)
        {
            m_pQC->UnlockStream();
            m_pQC = NULL;
        }
    }
};

/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID NTAPI WaitOrTimerCallback (
    PVOID pCallQCRelay,
    BOOLEAN bTimerFired
    )
{
    ((CCallQualityControlRelay*)pCallQCRelay)->CallbackProc (bTimerFired);
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
CCallQualityControlRelay::CCallQualityControlRelay ()
    :m_fInitiated (FALSE)
    ,m_pCall (NULL)
    ,m_hWait (NULL)
    ,m_hQCEvent (NULL)
    ,m_dwControlInterval (QCDEFAULT_QUALITY_CONTROL_INTERVAL)
    ,m_fStop (FALSE)
    ,m_fStopAck (FALSE)
#ifdef DEBUG_QUALITY_CONTROL
    ,m_hQCDbg (NULL)
    ,m_fQCDbgTraceCPULoad (FALSE)
    ,m_fQCDbgTraceBitrate (FALSE)
#endif // DEBUG_QUALITY_CONTROL
    ,m_lConfBitrate (QCDEFAULT_QUALITY_UNSET)
    ,m_lPrefMaxCPULoad (QCDEFAULT_MAX_CPU_LOAD)
    ,m_lPrefMaxOutputBitrate (QCDEFAULT_QUALITY_UNSET)
{
    m_lCPUUpThreshold = m_lPrefMaxCPULoad + (LONG)(100 * QCDEFAULT_UP_THRESHOLD);
    if (m_lCPUUpThreshold > 100)
        m_lCPUUpThreshold = 100;

    m_lCPULowThreshold = m_lPrefMaxCPULoad - (LONG)(100 * QCDEFAULT_LOW_THRESHOLD);
    if (m_lCPULowThreshold < 0)
        m_lCPULowThreshold = 0;

    m_lOutBitUpThreshold = QCDEFAULT_QUALITY_UNSET;
    m_lOutBitLowThreshold = QCDEFAULT_QUALITY_UNSET;
}

CCallQualityControlRelay::~CCallQualityControlRelay ()
{
    ENTER_FUNCTION ("CCallQualityControlRelay::~CCallQualityControlRelay");

    HRESULT hr;

    // if not initialized, no resource has been allocated
    if (!m_fInitiated) return;    

    _ASSERT (m_fStopAck);

    CloseHandle (m_hQCEvent);
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    create event handle, create main thread, start cpu usage collection
////*/
HRESULT
CCallQualityControlRelay::Initialize (CIPConfMSPCall *pCall)
{
    ENTER_FUNCTION ("CCallQualityControlRelay::Initialize");

    CLock lock (m_lock_QualityData);

    LOG ((MSP_TRACE, "%s entered. call=%p", __fxName, pCall));

    // avoid re-entry
    if (m_fInitiated)
    {
        LOG ((MSP_WARN, "%s is re-entered", __fxName));
        return S_OK;
    }

    // create qc event
    m_hQCEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (NULL == m_hQCEvent)
    {
        LOG ((MSP_ERROR, "%s failed to create qc event", __fxName));
        return E_FAIL;
    }

    // keep a refcount on msp call
    pCall->MSPCallAddRef ();
    m_pCall = pCall;

#ifdef DEBUG_QUALITY_CONTROL
    QCDbgInitiate ();
#endif // DEBUG_QUALITY_CONTROL

    m_fInitiated = TRUE;

    // we want to distribute resources based on default value before graphs are running
    CallbackProc (TRUE);

    LOG ((MSP_TRACE, "%s returns. call=%p", __fxName, pCall));

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
Decription:
    stop main thread, close qc event handle, release stream qc helpers,
    stop cpu usage collection
////*/
HRESULT
CCallQualityControlRelay::Shutdown (VOID)
{
    ENTER_FUNCTION ("CCallQualityControlRelay::Shutdown");

    // quality data should alway be locked before inner stream qc
    CLock lock1 (m_lock_QualityData);
    CLock lock2 (m_lock_aInnerStreamQC);

    LOG ((MSP_TRACE, "%s entered. call=%p. init=%d. stop=%d",
          __fxName, m_pCall, m_fInitiated, m_fStop));

    if (!m_fInitiated) return S_OK;
    if (m_fStop) return S_OK;

    // set stop signal
    m_fStop = TRUE;

    if (!SetEvent (m_hQCEvent))
        LOG ((MSP_ERROR, "%s failed to set event, %d", __fxName, GetLastError ()));
        
    // release stream qc helper
    int i;
    for (i=0; i<m_aInnerStreamQC.GetSize (); i++)
    {
        // an false input to unlink inner call qc on stream
        // forces the stream to remove its pointer to call but not to call
        // deregister again.
        m_aInnerStreamQC[i]->UnlinkInnerCallQC (FALSE);
        m_aInnerStreamQC[i]->Release ();
    }
    m_aInnerStreamQC.RemoveAll ();

    //StopCPUUsageCollection ();

#ifdef DEBUG_QUALITY_CONTROL
    QCDbgShutdown ();
#endif // DEBUG_QUALITY_CONTROL

    LOG ((MSP_TRACE, "%s returns. call=%p", __fxName, m_pCall));

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    store conference-wide bandwidth
////*/
HRESULT
CCallQualityControlRelay::SetConfBitrate (
    LONG lConfBitrate
    )
{
    ENTER_FUNCTION ("CCallQualityControlRelay::SetConfBitrate");

    CLock lock (m_lock_QualityData);

    // check if the limit is valid
    if (lConfBitrate < QCLIMIT_MIN_CONFBITRATE)
    {
        return E_INVALIDARG;
    }

    m_lConfBitrate = lConfBitrate;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    return stored conference-wide bandwidth
////*/
LONG
CCallQualityControlRelay::GetConfBitrate ()
{
    CLock lock (m_lock_QualityData);

    if (m_lConfBitrate == QCDEFAULT_QUALITY_UNSET)
    {
        return 0;
    }

    return m_lConfBitrate;
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    store inner stream QC interface
////*/
HRESULT
CCallQualityControlRelay::RegisterInnerStreamQC (
    IN IInnerStreamQualityControl *pIInnerStreamQC
    )
{
    ENTER_FUNCTION ("CCallQualityControlRelay::RegisterInnerStreamQC");

    // check input pointer
    if (IsBadReadPtr (pIInnerStreamQC, sizeof (IInnerStreamQualityControl)))
    {
        LOG ((MSP_ERROR, "%s got bad read pointer", __fxName));
        return E_POINTER;
    }

    // store the pointer
    CLock lock (m_lock_aInnerStreamQC);
    if (m_aInnerStreamQC.Find (pIInnerStreamQC) > 0)
    {
        LOG ((MSP_ERROR, "%s already stored inner stream qc", __fxName));
        return E_INVALIDARG;
    }

    if (!m_aInnerStreamQC.Add (pIInnerStreamQC))
    {
        LOG ((MSP_ERROR, "%s failed to add inner stream QC", __fxName));
        return E_FAIL;
    }

    pIInnerStreamQC->AddRef ();
    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    remove the inner stream QC
////*/
HRESULT
CCallQualityControlRelay::DeRegisterInnerStreamQC (
    IN IInnerStreamQualityControl *pIInnerStreamQC
    )
{
    ENTER_FUNCTION ("CCallQualityControlRelay::DeRegisterInnerStreamQC");

    // check input pointer
    if (IsBadReadPtr (pIInnerStreamQC, sizeof (IInnerStreamQualityControl)))
    {
        LOG ((MSP_ERROR, "%s got bad read pointer", __fxName));
        return E_POINTER;
    }

    // remove the pointer
    CLock lock (m_lock_aInnerStreamQC);
    if (!m_aInnerStreamQC.Remove (pIInnerStreamQC))
    {
        LOG ((MSP_ERROR, "%s failed to remove inner stream QC, %x", __fxName, pIInnerStreamQC));
        return E_FAIL;
    }

    pIInnerStreamQC->Release ();
    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    this method might be supported in the future
////*/
HRESULT
CCallQualityControlRelay::ProcessQCEvent (
    IN QCEvent event,
    IN DWORD dwParam
    )
{
    return E_NOTIMPL;
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    set quality control related properies on a call
////*/
HRESULT
CCallQualityControlRelay::Set(
    IN  CallQualityProperty property, 
    IN  LONG lValue, 
    IN  TAPIControlFlags lFlags
    )
{
    ENTER_FUNCTION ("CCallQualityControlRelay::Set CallQualityProperty");

    HRESULT hr;

    CLock lock (m_lock_QualityData);
    switch (property)
    {
    case CallQuality_ControlInterval:
        // timeout for the thread
        if (lValue < QCLIMIT_MIN_QUALITY_CONTROL_INTERVAL ||
            lValue > QCLIMIT_MAX_QUALITY_CONTROL_INTERVAL)
        {
            LOG ((MSP_ERROR, "%s, control interval %d is out of range", __fxName, lValue));
            return E_INVALIDARG;
        }
        m_dwControlInterval = (DWORD)lValue;
        break;

    case CallQuality_MaxCPULoad:
        // perfered maximum cpu load
        if ((lValue < QCLIMIT_MIN_CPU_LOAD) ||
            (lValue > QCLIMIT_MAX_CPU_LOAD))
        {
            LOG ((MSP_ERROR, "%s got out-of-limit cpu load. %d", __fxName, lValue));
            return E_INVALIDARG;
        }
        m_lPrefMaxCPULoad = lValue;

        m_lCPUUpThreshold = lValue + (LONG)(100 * QCDEFAULT_UP_THRESHOLD);
        if (m_lCPUUpThreshold > 100)
            m_lCPUUpThreshold = 100;

        m_lCPULowThreshold = lValue - (LONG)(100 * QCDEFAULT_LOW_THRESHOLD);
        if (m_lCPULowThreshold < 0)
            m_lCPULowThreshold = 0;

        break;

    case CallQuality_MaxOutputBitrate:
        // prefered maximum bitrate for the call
        if (lValue < QCLIMIT_MIN_BITRATE)
        {
            LOG ((MSP_ERROR, "%s, bitrate %d is less than min limit", __fxName, lValue));
            return E_INVALIDARG;
        }
        m_lPrefMaxOutputBitrate = lValue;

        m_lOutBitUpThreshold = (LONG)(lValue * (1 + QCDEFAULT_UP_THRESHOLD));

        m_lOutBitLowThreshold = (LONG)(lValue * (1 - QCDEFAULT_LOW_THRESHOLD));
        if (m_lOutBitLowThreshold < QCLIMIT_MIN_BITRATE)
            m_lOutBitLowThreshold = QCLIMIT_MIN_BITRATE;

        break;

    default:
        LOG ((MSP_ERROR, "%s got invalid property %d", __fxName, property));
        return E_NOTIMPL;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    retrieve call quality control property
////*/
HRESULT
CCallQualityControlRelay::Get(
    IN  CallQualityProperty property, 
    OUT  LONG *plValue, 
    OUT  TAPIControlFlags *plFlags
    )
{
    ENTER_FUNCTION ("CCallQualityControlRelay::Get QCCall_e");

    // check input pointer
    if (IsBadWritePtr (plValue, sizeof (LONG)) ||
        IsBadWritePtr (plFlags, sizeof (LONG)))
    {
        LOG ((MSP_ERROR, "%s got bad write pointer", __fxName));
        return E_POINTER;
    }

    CLock lock (m_lock_QualityData);

    *plFlags = TAPIControl_Flags_None;
    *plValue = QCDEFAULT_QUALITY_UNSET;

    HRESULT hr = S_OK;

    switch (property)
    {
    case CallQuality_ControlInterval:
        *plValue = (LONG)m_dwControlInterval;
        break;

    case CallQuality_ConfBitrate:
        *plValue = GetConfBitrate ();
        break;

    case CallQuality_CurrCPULoad:

        DWORD dw;
        if (!GetCPUUsage (&dw))
        {
            LOG ((MSP_ERROR, "%s failed to retrieve CPU usage", __fxName));
            hr = E_FAIL;
        }

        *plValue = (LONG)dw;
        break;

    case CallQuality_CurrInputBitrate:
        // !!! BOTH locks are locked
        // !!! MUST: QualityData lock first, InnerStreamQC second

        m_lock_aInnerStreamQC.Lock ();

        if (FAILED (hr = GetCallBitrate (
            TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO, TD_RENDER, plValue)))

            LOG ((MSP_ERROR, "%s failed to compute input bitrate, %x", __fxName, hr));

        m_lock_aInnerStreamQC.Unlock ();
        break;

    case CallQuality_CurrOutputBitrate:
        // !!! BOTH locks are locked
        // !!! MUST: QualityData lock first, InnerStreamQC second

        m_lock_aInnerStreamQC.Lock ();

        if (FAILED (hr = GetCallBitrate (
            TAPIMEDIATYPE_AUDIO | TAPIMEDIATYPE_VIDEO, TD_CAPTURE, plValue)))

            LOG ((MSP_ERROR, "%s failed to compute output bitrate, %x", __fxName, hr));

        m_lock_aInnerStreamQC.Unlock ();
        break;

    default:
        LOG ((MSP_ERROR, "%s got invalid property %d", __fxName, property));
        hr = E_NOTIMPL;
    }

    return S_OK;
}

HRESULT CCallQualityControlRelay::GetRange (
    IN CallQualityProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
{
    // no need to lock

    if (IsBadWritePtr (plMin, sizeof (long)) ||
        IsBadWritePtr (plMax, sizeof (long)) ||
        IsBadWritePtr (plSteppingDelta, sizeof (long)) ||
        IsBadWritePtr (plDefault, sizeof (long)) ||
        IsBadWritePtr (plFlags, sizeof (TAPIControlFlags)))
    {
        LOG ((MSP_ERROR, "CCallQualityControlRelay::GetRange bad write pointer"));
        return E_POINTER;
    }

    HRESULT hr;
    switch (Property)
    {
    case CallQuality_ControlInterval:

        *plMin = QCLIMIT_MIN_QUALITY_CONTROL_INTERVAL;
        *plMax = QCLIMIT_MAX_QUALITY_CONTROL_INTERVAL;
        *plSteppingDelta = 1;
        *plDefault = QCDEFAULT_QUALITY_CONTROL_INTERVAL;
        *plFlags = TAPIControl_Flags_None;
        hr = S_OK;

        break;

    case CallQuality_MaxCPULoad:

        *plMin = QCLIMIT_MIN_CPU_LOAD;
        *plMax = QCLIMIT_MAX_CPU_LOAD;
        *plSteppingDelta = 1;
        *plDefault = QCDEFAULT_MAX_CPU_LOAD;
        *plFlags = TAPIControl_Flags_None;
        hr = S_OK;

        break;

    default:
        hr = E_NOTIMPL;
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID
CCallQualityControlRelay::CallbackProc (BOOLEAN bTimerFired)
{
    ENTER_FUNCTION ("CCallQualityControlRelay::CallbackProc");

    DWORD dwResult;

    // always lock quality data first
    m_lock_QualityData.Lock ();
    m_lock_aInnerStreamQC.Lock ();

    // set wait handle to null
    if (m_hWait) UnregisterWait (m_hWait);
    m_hWait = NULL;

    if (m_fStop) {
        LOG ((MSP_TRACE, "%s is being stopped. call=%p", __fxName, m_pCall));

        m_fStopAck = TRUE;

        m_lock_aInnerStreamQC.Unlock ();
        m_lock_QualityData.Unlock ();

        m_pCall->MSPCallRelease ();
        return;
    }

    if (!bTimerFired)
        LOG ((MSP_ERROR, "%s, QC events are not supported", __fxName));
    else
        ReDistributeResources ();

    BOOL fSuccess = RegisterWaitForSingleObject (
                        &m_hWait,
                        m_hQCEvent,
                        WaitOrTimerCallback,
                        (PVOID) this,
                        m_dwControlInterval,
                        WT_EXECUTEONLYONCE
                        );

    if (!fSuccess || NULL == m_hWait)
    {
        LOG ((MSP_ERROR, "%s failed to register wait, %d", __fxName, GetLastError ()));
        LOG ((MSP_TRACE, "%s self-stops. call=%p", __fxName, m_pCall));

        m_fStopAck = TRUE;

        m_hWait = NULL;

        m_lock_aInnerStreamQC.Unlock ();
        m_lock_QualityData.Unlock ();

        m_pCall->MSPCallRelease ();

        return;
    }

    m_lock_aInnerStreamQC.Unlock ();
    m_lock_QualityData.Unlock ();
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CCallQualityControlRelay::GetCallBitrate (
    LONG MediaType,
    TERMINAL_DIRECTION Direction,
    LONG *plValue
    )
{
    ENTER_FUNCTION ("CCallQualityControlRelay::GetCallBitrate");

    LONG sum = 0;
    LONG bitrate;
    TAPIControlFlags flags;
    HRESULT hr;

    *plValue = 0;
    ITStream *pStream;
    LONG mediatype;
    TERMINAL_DIRECTION direction;

    int i;
    for (i=0; i<m_aInnerStreamQC.GetSize (); i++)
    {
        if (FAILED (hr = m_aInnerStreamQC[i]->QueryInterface (
            __uuidof (ITStream), (void**)&pStream)))
        {
            LOG ((MSP_ERROR, "%s failed to get ITStream interface. %x", __fxName, hr));
            return hr;
        }

        hr = pStream->get_Direction (&direction);
        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to get stream direction. %x", __fxName, hr));
            pStream->Release ();
            return hr;
        }

        hr = pStream->get_MediaType (&mediatype);
        pStream->Release ();
        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to get stream media type. %x", __fxName, hr));
            return hr;
        }

        if (!(MediaType & mediatype) ||         // skip if mediatype not match
            !(direction == TD_BIDIRECTIONAL || Direction == direction))
           continue;
    
        // get bitrate from each stream
        hr = m_aInnerStreamQC[i]->Get (InnerStreamQuality_CurrBitrate, &bitrate, &flags);

        if (E_NOTIMPL == hr)
            continue;

        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to get bitrate from stream. %x", __fxName, hr));
            return hr;
        }

        sum += bitrate;
    }

    *plValue = sum;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID
CCallQualityControlRelay::ReDistributeResources (VOID)
{

#ifdef DEBUG_QUALITY_CONTROL
    // read quality settings from registry
    QCDbgRead ();
#endif // DEBUG_QUALITY_CONTROL

    ReDistributeBandwidth ();

    ReDistributeCPU ();
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID
CCallQualityControlRelay::ReDistributeCPU (VOID)
{
    ENTER_FUNCTION ("CCallQualityControlRelay::ReDistributeCPU");

    HRESULT hr;
    int i, num_manual=0, num_total=m_aInnerStreamQC.GetSize ();
    LONG framerate;
    TAPIControlFlags flag;

    // check each stream, if manual, adjust based on preferred value
    for (i=0; i<num_total; i++)
    {
        BOOL fStreamLocked = FALSE;

        CInnerStreamLock lock(m_aInnerStreamQC[i], &fStreamLocked);

        if (!fStreamLocked)
        {
            // abort re-distribute resources
            return;
        }

        if (FAILED (hr = m_aInnerStreamQC[i]->Get (InnerStreamQuality_PrefMinFrameInterval, &framerate, &flag)))
        {
            LOG ((MSP_ERROR, "%s failed to get pref max frame rate (unset) on stream, %x", __fxName, hr));
            continue;
        }

        if (flag == TAPIControl_Flags_Manual)
        {
            num_manual ++;

            // use preferred value
            hr = m_aInnerStreamQC[i]->Set (InnerStreamQuality_AdjMinFrameInterval, framerate, flag);

            if (E_NOTIMPL == hr)
                continue;

            if (FAILED (hr))
            {
                LOG ((MSP_ERROR, "%s failed to set adj max frame interval. %x", __fxName, hr));
                continue;
            }
        }
    }

    // if global cpu load out of range, just return
    // it should not happen but we have a back door in registry for debugging purpose
    // just be careful here
    if (QCLIMIT_MIN_CPU_LOAD > m_lPrefMaxCPULoad ||
        QCLIMIT_MAX_CPU_LOAD < m_lPrefMaxCPULoad)
        return;

    // compute current usage
    DWORD dw;
    if (!GetCPUUsage (&dw))
    {
        LOG ((MSP_ERROR, "%s failed to get CPU usage", __fxName));
        return;
    }
    LONG usage = (LONG)dw;

    // return if within thresholds
    if (usage >= m_lCPULowThreshold &&
        usage <= m_lCPUUpThreshold)
        return;

    // percent to be adjusted
    FLOAT percent = ((FLOAT)(m_lPrefMaxCPULoad - usage)) / m_lPrefMaxCPULoad;

#ifdef DEBUG_QUALITY_CONTROL

    if (m_fQCDbgTraceCPULoad)
        LOG ((MSP_TRACE, "QCTrace CPU: overall = %d, target = %d", usage, m_lPrefMaxCPULoad));

#endif //DEBUG_QUALITY_CONTROL

    for (i=0; i<num_total; i++)
    {
        BOOL fStreamLocked = FALSE;

        CInnerStreamLock lock(m_aInnerStreamQC[i], &fStreamLocked);

        if (!fStreamLocked)
        {
            // abort re-distribute resources
            return;
        }

        // get flag
        if (FAILED (hr = m_aInnerStreamQC[i]->Get (InnerStreamQuality_PrefMinFrameInterval, &framerate, &flag)))
        {
            LOG ((MSP_ERROR, "%s failed to get pref max frame rate (unset) on stream, %d", __fxName, hr));
            continue;
        }

        // if manual, skip
        if (flag == TAPIControl_Flags_Manual)
            continue;

        // get current frame rate on the stream
        if (E_NOTIMPL == (hr = m_aInnerStreamQC[i]->Get (InnerStreamQuality_AvgFrameInterval,
                                                         &framerate, &flag)))
            continue;

        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to get frame rate on stream, %x", __fxName, hr));
            continue;
        }

        // need to low cpu but interval is already maximum
        if (percent <0 && framerate >= QCLIMIT_MAX_FRAME_INTERVAL)
            continue;

#ifdef DEBUG_QUALITY_CONTROL

    if (m_fQCDbgTraceCPULoad)
    {
        ITStream *pStream = NULL;
        BSTR bstr = NULL;

        if (S_OK == m_aInnerStreamQC[i]->QueryInterface (__uuidof (ITStream), (void**)&pStream))
        {
            pStream->get_Name (&bstr);
            pStream->Release ();
        }
                
        LOG ((MSP_TRACE, "QCTrace CPU: %ws frameinterval = %d", bstr, framerate));

        if (bstr) SysFreeString (bstr);
    }

#endif //DEBUG_QUALITY_CONTROL

        // heuristic here is to take into consideration of stream not having been adjusted
        framerate -= (LONG) (framerate * percent * (1 + num_manual*0.2));

        if (framerate > QCLIMIT_MAX_FRAME_INTERVAL)
            framerate = QCLIMIT_MAX_FRAME_INTERVAL;
        if (framerate < QCLIMIT_MIN_FRAME_INTERVAL)
            framerate = QCLIMIT_MIN_FRAME_INTERVAL;

#ifdef DEBUG_QUALITY_CONTROL

    if (m_fQCDbgTraceCPULoad)
        LOG ((MSP_TRACE, "QCTrace CPU: target frameinterval = %d", framerate));

#endif //DEBUG_QUALITY_CONTROL

        // set new value
        if (FAILED (hr = m_aInnerStreamQC[i]->Set (InnerStreamQuality_AdjMinFrameInterval,
                                                   framerate, flag)))
        {
            LOG ((MSP_ERROR, "%s failed to set frame interval on stream, %x", __fxName, hr));
        }
    }
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID
CCallQualityControlRelay::ReDistributeBandwidth (VOID)
{
    ENTER_FUNCTION ("CCallQualityControlRelay::ReDistributeBandwidth");

    HRESULT hr;
    int i, num_manual=0, num_total=m_aInnerStreamQC.GetSize ();
    LONG bitrate;
    TAPIControlFlags flag;

    LONG mediatype;
    TERMINAL_DIRECTION direction;

    // video out bitrate based on conference-wide bitrate
    LONG vidoutbitrate = GetVideoOutBitrate ();

    // check each stream, if manual, adjust based on preferred value
    for (i=0; i<num_total; i++)
    {
        BOOL fStreamLocked = FALSE;

        CInnerStreamLock lock(m_aInnerStreamQC[i], &fStreamLocked);

        if (!fStreamLocked)
        {
            // abort re-distribute resources
            return;
        }

        if (FAILED (hr = m_aInnerStreamQC[i]->Get (InnerStreamQuality_PrefMaxBitrate, &bitrate, &flag)))
        {
            LOG ((MSP_ERROR, "%s failed to get pref max bitrate (unset) on stream, %d", __fxName, hr));
            continue;
        }

        if (flag == TAPIControl_Flags_Manual)
        {
            num_manual ++;

            // check stream type
            if (FAILED (::TypeStream (m_aInnerStreamQC[i], &mediatype, &direction)))
            {
                LOG ((MSP_ERROR, "%s failed to get stream type", __fxName));
                continue;
            }

            // if it is video out stream and conference-wide bitrate is set
            // and the limit on video out stream is smaller than preferred value
            if ((mediatype & TAPIMEDIATYPE_VIDEO) &&
                direction == TD_CAPTURE &&
                vidoutbitrate > QCLIMIT_MIN_BITRATE &&
                vidoutbitrate < bitrate)
            {
                bitrate = vidoutbitrate;
            }

            hr = m_aInnerStreamQC[i]->Set (InnerStreamQuality_AdjMaxBitrate, bitrate, flag);

            if (E_NOTIMPL == hr)
                continue;

            if (FAILED (hr))
            {
                LOG ((MSP_ERROR, "%s failed to set adj max bitrate. %d", __fxName, hr));
                continue;
            }
        }
    }

    // return if target is not set
    if (m_lPrefMaxOutputBitrate == QCDEFAULT_QUALITY_UNSET &&
        vidoutbitrate < QCLIMIT_MIN_CONFBITRATE)
        return;

    // compute bitrate target based on preferred value and conference-wide limit
    LONG usage;
    if (S_OK != (hr = GetCallBitrate (
        TAPIMEDIATYPE_VIDEO | TAPIMEDIATYPE_AUDIO, TD_CAPTURE, &usage)))
    {
        LOG ((MSP_ERROR, "%s failed to get bandwidth usage, %x", __fxName, hr));
        return;
    }

    // return if usage is within threshold
    FLOAT percent = 0;
    if (m_lPrefMaxOutputBitrate != QCDEFAULT_QUALITY_UNSET &&
        (usage > m_lOutBitUpThreshold || usage < m_lOutBitLowThreshold))
    {
        percent = ((FLOAT)(m_lPrefMaxOutputBitrate - usage)) / m_lPrefMaxOutputBitrate;
    }

#ifdef DEBUG_QUALITY_CONTROL

    if (m_fQCDbgTraceBitrate && m_lPrefMaxOutputBitrate != QCDEFAULT_QUALITY_UNSET)
        LOG ((MSP_TRACE, "QCTrace Bitrate: overall = %d, target = %d", usage, m_lPrefMaxOutputBitrate));

#endif //DEBUG_QUALITY_CONTROL

    for (i=0; i<num_total; i++)
    {
        BOOL fStreamLocked = FALSE;

        CInnerStreamLock lock(m_aInnerStreamQC[i], &fStreamLocked);

        if (!fStreamLocked)
        {
            // abort re-distribute resources
            return;
        }

        // get flag
        if (FAILED (hr = m_aInnerStreamQC[i]->Get (InnerStreamQuality_PrefMaxBitrate, &bitrate, &flag)))
        {
            LOG ((MSP_ERROR, "%s failed to get pref max bitrate (unset) on stream, %d", __fxName, hr));
            continue;
        }

        if (FAILED (::TypeStream (m_aInnerStreamQC[i], &mediatype, &direction)))
        {
            LOG ((MSP_ERROR, "%s failed to get stream type", __fxName));
            continue;
        }

        // return if render
        if (direction == TD_RENDER)
        {
            // only count manual for capture or bidirectional
            if (flag == TAPIControl_Flags_Manual)
                num_manual --;

            continue;
        }

        // if manual, skip
        if (flag == TAPIControl_Flags_Manual)
            continue;

        // we only deal with video capture stream
        if (!(TAPIMEDIATYPE_VIDEO & mediatype))
           continue;

        // get current bit rate on the stream
        if (E_NOTIMPL == (hr = m_aInnerStreamQC[i]->Get (InnerStreamQuality_CurrBitrate,
                                                         &bitrate, &flag)))
            continue;

        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to get bitrate on stream, %x", __fxName, hr));
            continue;
        }

        // need to low bandwidth but bitrate is already minimum
        if (percent <0 && bitrate <= QCLIMIT_MIN_BITRATE)
            continue;

#ifdef DEBUG_QUALITY_CONTROL

        if (m_fQCDbgTraceBitrate)
        {
            ITStream *pStream = NULL;
            BSTR bstr = NULL;

            if (S_OK == m_aInnerStreamQC[i]->QueryInterface (__uuidof (ITStream), (void**)&pStream))
            {
                pStream->get_Name (&bstr);
                pStream->Release ();
            }
                
            LOG ((MSP_TRACE, "QCTrace Bitrate: %ws bitrate = %d", bstr, bitrate));

            if (bstr) SysFreeString (bstr);
        }

#endif //DEBUG_QUALITY_CONTROL

        //
        // we are here because either m_lPrefMaxOutputBitrate is set by app,
        // and/or conference-wide bandwidth is specified.
        //
        if (m_lPrefMaxOutputBitrate != QCDEFAULT_QUALITY_UNSET)
        {
            // percent makes sense here
            // heuristic here is to take into consideration of stream not having been adjusted        
            bitrate += (LONG) (bitrate * percent * (1 + num_manual*0.3));

            if (vidoutbitrate > QCLIMIT_MIN_BITRATE)
                if (bitrate > vidoutbitrate)
                    bitrate = vidoutbitrate;
        }
        else
        {
            if (vidoutbitrate > QCLIMIT_MIN_BITRATE)
                bitrate = vidoutbitrate;
        }

        if (bitrate < QCLIMIT_MIN_BITRATE)
            bitrate = QCLIMIT_MIN_BITRATE;

        if (bitrate < QCLIMIT_MIN_BITRATE*10)
        {
            // we want very lower bitrate, try to decrease frame rate as well
            m_lPrefMaxCPULoad -= 5;

            if (m_lPrefMaxCPULoad < QCLIMIT_MIN_CPU_LOAD)
                m_lPrefMaxCPULoad = QCLIMIT_MIN_CPU_LOAD;
        }

#ifdef DEBUG_QUALITY_CONTROL

    if (m_fQCDbgTraceBitrate)
        LOG ((MSP_TRACE, "QCTrace Bitrate: target bitrate = %d", bitrate));

#endif //DEBUG_QUALITY_CONTROL

        // set new value
        if (E_NOTIMPL == (hr = m_aInnerStreamQC[i]->Set (InnerStreamQuality_AdjMaxBitrate,
                                                         bitrate, flag)))
            continue;

        if (FAILED (hr))
        {
            LOG ((MSP_ERROR, "%s failed to set bitrate on stream, %x", __fxName, hr));
        }
    }
}

#ifdef DEBUG_QUALITY_CONTROL
/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID
CCallQualityControlRelay::QCDbgInitiate (VOID)
{
    ENTER_FUNCTION ("CCallQualityControlRelay::QCDbgInitiate");

    if (ERROR_SUCCESS != RegOpenKeyEx (
                            HKEY_LOCAL_MACHINE,
                            _T("SOFTWARE\\Microsoft\\Tracing\\confqc"),
                            NULL,
                            KEY_READ,
                            &m_hQCDbg
        ))
    {
        LOG ((MSP_TRACE, "%s failed to open reg key", __fxName));
        m_hQCDbg = NULL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID
CCallQualityControlRelay::QCDbgRead (VOID)
{
    ENTER_FUNCTION ("CCallQualityControlRelay::QCDbgRead");

    m_fQCDbgTraceCPULoad = FALSE;
    m_fQCDbgTraceBitrate = FALSE;

    if (!m_hQCDbg)
        return;

    DWORD dwType, dwSize;
    LONG lValue;

    // if debug is enabled
    if (ERROR_SUCCESS == RegQueryValueEx (
                            m_hQCDbg,
                            _T("DebugEnabled"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lValue,
                            &dwSize))
    {
        if (REG_DWORD != dwType || 1 != lValue)
            return;
    }
    else
    {
        LOG ((MSP_WARN, "%s failed to query debug flag", __fxName));
        return;
    }

    // if print out trace info
    m_fQCDbgTraceCPULoad = FALSE;
    if (ERROR_SUCCESS == RegQueryValueEx (
                            m_hQCDbg,
                            _T("TraceCPULoad"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lValue,
                            &dwSize))
    {
        if (REG_DWORD == dwType && 1 == lValue)
            m_fQCDbgTraceCPULoad = TRUE;
    }

    m_fQCDbgTraceBitrate = FALSE;
    if (ERROR_SUCCESS == RegQueryValueEx (
                            m_hQCDbg,
                            _T("TraceBitrate"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lValue,
                            &dwSize))
    {
        if (REG_DWORD == dwType && 1 == lValue)
            m_fQCDbgTraceBitrate = TRUE;
    }

    // control interval
    if (ERROR_SUCCESS == RegQueryValueEx (
                            m_hQCDbg,
                            _T("ControlInterval"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lValue,
                            &dwSize))
    {
        if (REG_DWORD == dwType && lValue >= QCLIMIT_MIN_QUALITY_CONTROL_INTERVAL)
            m_dwControlInterval = (DWORD)lValue;
        else
            LOG ((MSP_ERROR, "%s: qeury control interval wrong type %d or wrong value %d", __fxName, dwType, lValue));
    }

    // max cpu load
    if (ERROR_SUCCESS == RegQueryValueEx (
                            m_hQCDbg,
                            _T("MaxCPULoad"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lValue,
                            &dwSize))
    {
        if (REG_DWORD == dwType && QCLIMIT_MIN_CPU_LOAD <= lValue && lValue <= QCLIMIT_MAX_CPU_LOAD)
            m_lPrefMaxCPULoad = lValue;
        else
            LOG ((MSP_ERROR, "%s: qeury max cpu load wrong type %d or wrong value %d", __fxName, dwType, lValue));

        // update threshold
        m_lCPUUpThreshold = m_lPrefMaxCPULoad + (LONG)(100 * QCDEFAULT_UP_THRESHOLD);
        if (m_lCPUUpThreshold > 100)
            m_lCPUUpThreshold = 100;

        m_lCPULowThreshold = m_lPrefMaxCPULoad - (LONG)(100 * QCDEFAULT_LOW_THRESHOLD);
        if (m_lCPULowThreshold < 0)
            m_lCPULowThreshold = 0;
    }

    // max call bitrate
    if (ERROR_SUCCESS == RegQueryValueEx (
                            m_hQCDbg,
                            _T("MaxOutputBitrate"),
                            NULL,
                            &dwType,
                            (LPBYTE)&lValue,
                            &dwSize))
    {
        if (REG_DWORD == dwType && QCLIMIT_MIN_BITRATE <= lValue)
            m_lPrefMaxOutputBitrate = lValue;
        else
            LOG ((MSP_ERROR, "%s: qeury max call bitrate wrong type %d or wrong value %d", __fxName, dwType, lValue));

        // update threshold
        m_lOutBitUpThreshold = (LONG)(lValue * (1 + QCDEFAULT_UP_THRESHOLD));

        m_lOutBitLowThreshold = (LONG)(lValue * (1 - QCDEFAULT_LOW_THRESHOLD));
        if (m_lOutBitLowThreshold < QCLIMIT_MIN_BITRATE)
            m_lOutBitLowThreshold = QCLIMIT_MIN_BITRATE;
    }

}

/*//////////////////////////////////////////////////////////////////////////////
////*/
VOID
CCallQualityControlRelay::QCDbgShutdown (VOID)
{
    if (m_hQCDbg)
    {
        RegCloseKey (m_hQCDbg);
        m_hQCDbg = NULL;
    }
}

#endif // DEBUG_QUALITY_CONTROL


#pragma warning( disable: 4244 )

BOOL CCallQualityControlRelay::GetCPUUsage(PDWORD pdwOverallCPUUsage) {

	SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
	static BOOL Initialized = FALSE;
	static SYSTEM_PERFORMANCE_INFORMATION PreviousPerfInfo;
	static SYSTEM_BASIC_INFORMATION BasicInfo;
    static FILETIME PreviousFileTime;
    static FILETIME CurrentFileTime;

	LARGE_INTEGER EndTime, BeginTime, ElapsedTime;
	int PercentBusy;

    *pdwOverallCPUUsage = 0;

	// 
	NTSTATUS Status =
		NtQuerySystemInformation(
            SystemPerformanceInformation,
            &PerfInfo,
            sizeof(PerfInfo),
            NULL
            );

	if (NT_ERROR(Status)) 
		return FALSE;


	// first-time query...
	if (!Initialized) {
	
		// Get basic info (number of CPU)
		Status =
			NtQuerySystemInformation(
				SystemBasicInformation,
				&BasicInfo,
				sizeof(BasicInfo),
				NULL
				);

		if (NT_ERROR(Status)) 
			return FALSE;

		GetSystemTimeAsFileTime(&PreviousFileTime);

		PreviousPerfInfo = PerfInfo;
		*pdwOverallCPUUsage = 0;
		Initialized = TRUE;

		return TRUE;
	}

	GetSystemTimeAsFileTime(&CurrentFileTime);

	LARGE_INTEGER TimeBetweenQueries;

	//TimeBetweenQueries.QuadPart = (LARGE_INTEGER)CurrentFileTime - (LARGE_INTEGER)PreviousFileTime;
	TimeBetweenQueries.HighPart = CurrentFileTime.dwHighDateTime - PreviousFileTime.dwHighDateTime;
	TimeBetweenQueries.LowPart = CurrentFileTime.dwLowDateTime - PreviousFileTime.dwLowDateTime;

	EndTime = *(PLARGE_INTEGER)&PerfInfo.IdleProcessTime;
	BeginTime = *(PLARGE_INTEGER)&PreviousPerfInfo.IdleProcessTime;

    ElapsedTime.QuadPart = EndTime.QuadPart - BeginTime.QuadPart;

    if (TimeBetweenQueries.QuadPart <= 0)
    {
        PercentBusy = 0;
        LOG ((MSP_WARN, "GetCPUUsage: TimeBetweenQueries.QuadPart, %d", TimeBetweenQueries.QuadPart));
    }
    else
    {
        PercentBusy = (int)
            (   ((TimeBetweenQueries.QuadPart - ElapsedTime.QuadPart) * 100) /
                (BasicInfo.NumberOfProcessors * TimeBetweenQueries.QuadPart)
            );
    }

    if ( PercentBusy > 100 ) 
             PercentBusy = 100;
	else if ( PercentBusy < 0 ) 
             PercentBusy = 0;

	PreviousFileTime =  CurrentFileTime;
	PreviousPerfInfo =  PerfInfo;

	*pdwOverallCPUUsage = (DWORD)PercentBusy;

	return TRUE;
}

/*//////////////////////////////////////////////////////////////////////////////

Description:

    Computes video out bitrate based on conference-wide bandwidth

////*/
LONG CCallQualityControlRelay::GetVideoOutBitrate ()
{
    //
    // compute
    //  number of video in sub streams
    //  audio stream bitrate
    //

    HRESULT hr;
    LONG videooutbps = QCDEFAULT_QUALITY_UNSET;
    LONG audiobps = 0;
    LONG bitrate = 0;
    INT numvideoin = 0;

    IEnumStream *pEnum = NULL;
    ITStream *pStream = NULL;
    ITStreamQualityControl *pStreamQC = NULL;

    ULONG fetched = 0;

    CStreamVideoRecv *pVideoRecv = NULL;

    LONG mediatype;
    TERMINAL_DIRECTION direction;
    TAPIControlFlags flag;

    ENTER_FUNCTION ("Relay::GetVideoOutBitrate");

    if (m_lConfBitrate < QCLIMIT_MIN_CONFBITRATE)
        return videooutbps;

    if (FAILED (hr = m_pCall->EnumerateStreams (&pEnum)))
    {
        LOG ((MSP_ERROR, "%s failed to get IEnumStream. %x", __fxName, hr));
        return videooutbps;
    }

    while (S_OK == pEnum->Next (1, &pStream, &fetched))
    {
        // check each stream
        if (FAILED (hr = ::TypeStream (pStream, &mediatype, &direction)))
        {
            LOG ((MSP_ERROR, "%s failed to type stream. %x", __fxName, hr));
            goto Cleanup;
        }

        // if audio out, get bitrate
        if ((mediatype & TAPIMEDIATYPE_AUDIO) &&
            direction == TD_CAPTURE)
        {
            if (FAILED (hr = pStream->QueryInterface (&pStreamQC)))
            {
                LOG ((MSP_ERROR, "%s failed to query stream quality control. %x", __fxName, hr));
                goto Cleanup;
            }

            if (FAILED (hr = pStreamQC->Get (StreamQuality_CurrBitrate, &bitrate, &flag)))
            {
                LOG ((MSP_ERROR, "%s failed to query bitrate. %x", __fxName, hr));
                goto Cleanup;
            }

            pStreamQC->Release ();
            pStreamQC = NULL;

            audiobps += bitrate;
        }

        // we only need video in here
        if (!(mediatype & TAPIMEDIATYPE_VIDEO) || direction != TD_RENDER)
        {
            pStream->Release ();
            pStream = NULL;
            continue;
        }

        pVideoRecv = dynamic_cast<CStreamVideoRecv *>(pStream);

        if (pVideoRecv != NULL)
            numvideoin += pVideoRecv->GetSubStreamCount ();

        pStream->Release ();
        pStream = NULL;
    }

    pEnum->Release ();
    pEnum = NULL;

    // compute
    numvideoin ++; // count self

    // assume on average there are 1.5 persons talking in the conference.
    // we ignore network overhead.
    videooutbps = (LONG)(((FLOAT)m_lConfBitrate - 1.5*audiobps) / numvideoin);

Return:

    return videooutbps;

Cleanup:

    if (pEnum) pEnum->Release ();
    if (pStream) pStream->Release ();
    if (pStreamQC) pStreamQC->Release ();

    goto Return;
}

HRESULT TypeStream (IUnknown *p, LONG *pMediaType, TERMINAL_DIRECTION *pDirection)
{
    HRESULT hr;

    // get ITStream interface
    ITStream *pStream = dynamic_cast<ITStream *>(p);

    if (pStream == NULL)
    {
        LOG ((MSP_ERROR, "TypeStream failed to cast ITStream"));
        return E_INVALIDARG;
    }

    // get stream direction
    if (FAILED (hr = pStream->get_Direction (pDirection)))
    {
        LOG ((MSP_ERROR, "TypeStream failed to get stream direction. %x", hr));
        return hr;
    }

    // get stream mediatype
    if (FAILED (hr = pStream->get_MediaType (pMediaType)))
    {
        LOG ((MSP_ERROR, "TypeStream failed to get stream media type. %x", hr));
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confvid.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    confvid.cpp

Abstract:

    This module contains implementation of the video send and receive
    stream implementations.

Author:

    Mu Han (muhan)   15-September-1999

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoRecv
//
/////////////////////////////////////////////////////////////////////////////

CStreamVideoRecv::CStreamVideoRecv()
    : CIPConfMSPStream()
{
      m_szName = L"VideoRecv";
}

HRESULT CStreamVideoRecv::Init(
    IN     HANDLE                   hAddress,
    IN     CMSPCallBase *           pMSPCall,
    IN     IMediaEvent *            pIGraphBuilder,
    IN     DWORD                    dwMediaType,
    IN     TERMINAL_DIRECTION       Direction
    )
/*++

Routine Description:
    Init our substream array and then call the base class' Init.

Arguments:

    hAddress    - a handle to the address, used in identify terminals.

    pMSPCall    - the call object that owns the stream.

    pIGraphBuilder - the filter graph object.

    dwMediaType - the mediatype of this stream.

    Direction  - the direction of this stream.

Return Value:
    
    S_OK,
    E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CStreamVideoRecvVideoSend::Init - enter"));

    // initialize the stream array so that the array is not NULL.
    if (!m_SubStreams.Grow())
    {
        LOG((MSP_TRACE, "CStreamVideoRecvVideoSend::Init - return out of memory"));
        return E_OUTOFMEMORY;
    }

    return CIPConfMSPStream::Init(
        hAddress, pMSPCall, pIGraphBuilder,dwMediaType, Direction
        );
}

HRESULT CStreamVideoRecv::ShutDown()
/*++

Routine Description:

    Shut down the stream. 

Arguments:
    

Return Value:

S_OK

--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioRecv::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    // if there are branches and configured, we need to disconnect 
    // the terminals and remove the branches.
    if (m_Branches.GetSize() > 0)
    {
        // Stop the graph before disconnecting the terminals.
        hr = CMSPStream::StopStream();
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "stream %ws %p failed to stop, %x", m_szName, this, hr));
            return hr;
        }

        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            RemoveOneBranch(&m_Branches[i]);
        }
        m_Branches.RemoveAll();
    }

    // release all the substream objects.
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        m_SubStreams[i]->Release();
    }
    m_SubStreams.RemoveAll();

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}

HRESULT CStreamVideoRecv::InternalCreateSubStream(
    OUT ITSubStream ** ppSubStream
    )
/*++

Routine Description:
    This method creat a substream object and add it into out list.
    
Arguments:
    ppSubStream - the memory location that will store the returned SubStream.
  
Return Value:

S_OK
E_OUTOFMEMORY
E_NOINTERFACE

--*/
{
    CComObject<CSubStreamVideoRecv> * pCOMSubStream;

    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCOMSubStream);

    if (NULL == pCOMSubStream)
    {
        LOG((MSP_ERROR, "could not create video recv sub stream:%x", hr));
        return hr;
    }

    ITSubStream* pSubStream;

    // get the interface pointer.
    hr = pCOMSubStream->_InternalQueryInterface(
        __uuidof(ITSubStream), 
        (void **)&pSubStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Create VideoRecv Substream QueryInterface failed: %x", hr));
        delete pCOMSubStream;
        return hr;
    }

    // Initialize the object.
    hr = pCOMSubStream->Init(this);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateMSPSubStream:call init failed: %x", hr));
        pSubStream->Release();

        return hr;
    }

    // Add the SubStream into our list of SubStreams. This takes a refcount.
    if (!m_SubStreams.Add(pSubStream))
    {
        pSubStream->Release();

        LOG((MSP_ERROR, "out of memory in adding a SubStream."));
        return E_OUTOFMEMORY;
    }
    
    // AddRef the interface pointer and return it.
    pSubStream->AddRef(); 
    *ppSubStream = pSubStream;

    return S_OK;
}

// ITStream method
STDMETHODIMP CStreamVideoRecv::StopStream ()
{
    ENTER_FUNCTION ("CStreamVideoRecv::StopStream");

    HRESULT hr;

    CLock lock (m_lock);

    // copy stopstream from ipconfmsp because 
    // we want to generate unmap event before stream inactive event

    // if there is no terminal selected
    if (m_Terminals.GetSize() == 0)
    {
        LOG((MSP_INFO, "stream %ws %p needs terminal", m_szName, this));

        // Enter stopped state. (SO)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    if (!m_fIsConfigured)
    {
        LOG((MSP_INFO, "stream %ws %p is not configured yet", m_szName, this));

        // Enter stopped state. (SO, ST)
        m_dwState = STRM_STOPPED; 
        
        return S_OK;
    }

    // Stop the graph.
    if (FAILED (hr = CMSPStream::StopStream()))
    {
        LOG((MSP_ERROR, "stream %ws %p failed to stop, %x", m_szName, this, hr));
        return hr;
    }

    // check if we have filter chain
    CComPtr <IFilterChain> pIFilterChain;

    //  Query IFilterChain
    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }

    if (pIFilterChain)
    {
        DWORD dwSSRC = 0;
        ITParticipant *pParticipant = NULL;
        INT count, next;

        next = m_SubStreams.GetSize ();
        // generate participant leave
        while ((count = next) > 0)
        {
            if (!((CSubStreamVideoRecv*)m_SubStreams[0])->GetCurrentParticipant (&dwSSRC, &pParticipant))
            {
                LOG ((MSP_ERROR, "%s failed to get current participant on %p", __fxName, m_SubStreams[0]));
                
                return E_UNEXPECTED;
            }

            pParticipant->Release ();

            if (FAILED (hr = ProcessParticipantLeave (dwSSRC)))
            {
                LOG ((MSP_ERROR, "%s failed to process participant leave. ssrc=%x, hr=%x", __fxName, dwSSRC, hr));

                return hr;
            }

            next = m_SubStreams.GetSize ();
            if (next >= count)
            {
                // no substream was removed. we have big trouble
                LOG ((MSP_ERROR, "%s: not substream was removed", __fxName));

                return E_UNEXPECTED;
            }
        }

        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (!m_Branches[i].pITSubStream) continue;

            if (FAILED (hr = ProcessPinUnmapEvent (
                m_Branches[i].dwSSRC, m_Branches[i].pIPin)))
            {
                LOG ((MSP_ERROR, "%s (%ws) failed to process pin unmap event. %x", __fxName, m_szName, hr));
            }
        }
    }

    SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    LOG((MSP_INFO, "stream %ws %p stopped", m_szName, this));

    // Enter stopped state.(ST)
    m_dwState = STRM_STOPPED; 

    return S_OK;
}

// ITSubStreamControl methods, called by the app.
STDMETHODIMP CStreamVideoRecv::CreateSubStream(
    IN OUT  ITSubStream **         ppSubStream
    )
/*++

Routine Description:
    This method creates a new substream on this video receive stream. Since
    the substreams are created based on the participants, this function
    returns only TAPI_E_NOTSUPPORTED.

Arguments:
    ppSubStream - the memory location that will store the returned SubStream.
  
Return Value:

TAPI_E_NOTSUPPORTED

--*/
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CStreamVideoRecv::RemoveSubStream(
    IN      ITSubStream *          pSubStream
    )
/*++

Routine Description:
    This method remove substream on this video receive stream. Since
    the substreams are created based on the participants, this function
    returns only TAPI_E_NOTSUPPORTED.

Arguments:
    pSubStream - the SubStream to be removed.
  
Return Value:

TAPI_E_NOTSUPPORTED
--*/
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CStreamVideoRecv::EnumerateSubStreams(
    OUT     IEnumSubStream **      ppEnumSubStream
    )
/*++

Routine Description:
    This method returns an enumerator of the substreams. 

Arguments:
    ppEnumSubStream - the memory location to store the returned pointer.
  
Return Value:

S_OK
E_POINTER
E_UNEXPECTED
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, 
        "EnumerateSubStreams entered. ppEnumSubStream:%x", ppEnumSubStream));

    //
    // Check parameters.
    //

    if (IsBadWritePtr(ppEnumSubStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the SubStream object list.
    //

    CLock lock(m_lock);

    if (m_SubStreams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //
    HRESULT hr;

    typedef _CopyInterface<ITSubStream> CCopy;
    typedef CSafeComEnum<IEnumSubStream, &__uuidof(IEnumSubStream), 
                ITSubStream *, CCopy> CEnumerator;
    CComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the __uuidof(IEnumSubStream) i/f
    //


    IEnumSubStream *      pEnumSubStream;
    hr = pEnum->_InternalQueryInterface(__uuidof(IEnumSubStream), (void**)&pEnumSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized array.
    //

    hr = pEnum->Init(
        m_SubStreams.GetData(),                        // the begin itor
        m_SubStreams.GetData() + m_SubStreams.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateSubStreams - "
            "init enumerator object failed, %x", hr));

        pEnumSubStream->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CMSPCallBase::EnumerateSubStreams - exit S_OK"));

    *ppEnumSubStream = pEnumSubStream;

    return hr;
}

STDMETHODIMP CStreamVideoRecv::get_SubStreams(
    OUT     VARIANT *              pVariant
    )
/*++

Routine Description:
    This method returns a collection of the substreams. 

Arguments:
    pVariant - a variant structure.
  
Return Value:

S_OK
E_POINTER
E_UNEXPECTED
E_OUTOFMEMORY

--*/
{
    LOG((MSP_TRACE, "CStreamVideoRecv::get_SubStreams - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the SubStream object list.
    //

    CLock lock(m_lock);

    if (m_SubStreams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITSubStream * > SubStreamCollection;
    CComObject<SubStreamCollection> * pCollection;
    HRESULT hr;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_SubStreams.GetSize(),
                                  m_SubStreams.GetData(),
                                  m_SubStreams.GetData() + m_SubStreams.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CStreamVideoRecv::get_SubStreams - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CStreamVideoRecv::get_SubStreams - exit S_OK"));
 
    return S_OK;
}

HRESULT CStreamVideoRecv::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:
    
    Check to see if the terminal is allowed on this stream. Only video 
    render terminal is allowed.

Arguments:

    pTerminal   - the terminal.

Return value:

    S_OK 
    TAPI_E_INVALIDTERMINAL
*/
{
    LOG((MSP_TRACE, "VideoRecv.CheckTerminalTypeAndDirection"));

    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (Direction != TD_BIDIRECTIONAL && Direction != m_Direction)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SubStreamSelectTerminal(
    IN  ITSubStream * pITSubStream, 
    IN  ITTerminal * pITTerminal
    )
/*++

Routine Description:

    handle terminals being selected on the sub streams. It gives the terminal
    to one free branch and then sets up a mapping between the branch and the
    substream, so that the participant in the substream is displayed on the
    terminal selected.

Arguments:
    
    pITSubStream - the Substream that got a terminal selected.

    pITTerminal - the terminal object.

Return Value:

S_OK

--*/
{
    LOG((MSP_TRACE, "VideoRecv SubStreamSelectTerminal"));

    HRESULT hr;

    CLock lock(m_lock);
    
    // Call the base class's select terminal first. The terminal will be put
    // into the terminal pool and a branch of filters will be created for it.
    hr = CIPConfMSPStream::SelectTerminal(pITTerminal);

    if (FAILED(hr))
    {
        return hr;
    }

    // Find out which branch got the terminal.
    int i;
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    _ASSERTE(i < m_Branches.GetSize());

    if (i >= m_Branches.GetSize())
    {
        return E_UNEXPECTED;
    }

    // Find out the participant on the SubStream.
    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    if ((static_cast<CSubStreamVideoRecv*>(pITSubStream))->GetCurrentParticipant(
        &dwSSRC,
        &pITParticipant
        ) == FALSE)
    {
        return E_UNEXPECTED;
    }

    pITParticipant->Release();

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "no demux filter"));
        return E_UNEXPECTED;
    }

    // map the pin to this SSRC only.
    hr = m_pIRTPDemux->SetMappingState(-1, m_Branches[i].pIPin, dwSSRC, TRUE);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "map SSRC %x to pin %p returned %x", 
            dwSSRC, m_Branches[i].pIPin, hr));
        return hr;
    }    

    _ASSERTE(m_Branches[i].pITSubStream == NULL);

    pITSubStream->AddRef();
    m_Branches[i].pITSubStream = pITSubStream;
    m_Branches[i].dwSSRC = dwSSRC;
    
    return hr;
}

HRESULT CStreamVideoRecv::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoRecv::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL fFound = FALSE;
    for (int i = dwCount - 1; i >= 0; i --)
    {
        // TODO, a new interface is needed to resolve RTP to MediaType.
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            i, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        BITMAPINFOHEADER *pHeader = HEADER(pMediaType->pbFormat);
        if (pHeader == NULL)
        {
            MSPDeleteMediaType(pMediaType);
            continue;
        }

        // check the image size
        if (m_Settings.fCIF)
        {
            if (pHeader->biWidth != CIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        else
        {
            if (pHeader->biWidth != QCIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        
        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    90000,      // default video clock rate.
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }
            }
        }
        MSPDeleteMediaType(pMediaType);
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SetUpInternalFilters()
/*++

Routine Description:

    set up the filters used in the stream.

    RTP->DECODER->Render terminal

    This function only creates the RTP and demux filter and the rest of the
    graph is connected in ConnectTerminal.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::SetUpInternalFilters");
    LOG((MSP_TRACE, "%s entered.", __fxName));

    HRESULT hr = S_OK;

    if (m_pIRTPDemux == NULL)
    {
        CComPtr<IBaseFilter> pSourceFilter;

        if (m_pIRTPSession == NULL)
        {
            // create and add the source fitler.
            if (FAILED(hr = ::AddFilter(
                    m_pIGraphBuilder,
                    __uuidof(MSRTPSourceFilter), 
                    L"RtpSource", 
                    &pSourceFilter)))
            {
                LOG((MSP_ERROR, "%s, adding source filter. %x", __fxName, hr));
                return hr;
            }

            if (FAILED(hr = ConfigureRTPFilter(pSourceFilter)))
            {
                LOG((MSP_ERROR, "%s, configure RTP source filter. %x", __fxName, hr));
                return hr;
            }

        }
        else
        {
            if (FAILED (hr = m_pIRTPSession->QueryInterface (&pSourceFilter)))
            {
                LOG ((MSP_ERROR, "%s failed to get filter from rtp session. %x", __fxName, hr));
                return hr;
            }

            if (FAILED (hr = m_pIGraphBuilder->AddFilter ((IBaseFilter *)pSourceFilter, L"RtpSource")))
            {
                LOG ((MSP_ERROR, "%s failed to add filter to graph. %x", __fxName, hr));
                return hr;
            }
        }

        // get the Demux interface pointer.
        hr = pSourceFilter->QueryInterface(&m_pIRTPDemux);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s query IRtpDemux failed. %x", __fxName, hr));
            return hr;
        }
    }

//  hr = m_pIRTPDemux->SetPinCount(m_Terminals.GetSize(), RTPDMXMODE_AUTO);

#define DEFAULT_PIN_SIZE 4

    int isize = m_Terminals.GetSize();
    if (isize < DEFAULT_PIN_SIZE)
    {
        isize = DEFAULT_PIN_SIZE;
    }

    hr = m_pIRTPDemux->SetPinCount(isize, RTPDMXMODE_AUTO);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s query IRtpDemux failed. %x", __fxName, hr));
        return hr;
    }

    return hr;
}

HRESULT CStreamVideoRecv::AddOneBranch(
    BRANCH * pBranch,
    BOOL fFirstBranch,
    BOOL fDirectRTP
    )
/*++

Routine Description:

    Create a new branch of filters off the demux.

Arguments:
    
    pBranch - a pointer to a structure that remembers the info about the branch.

    fFirstBranch - whether this is the first branch.

    fDirectRTP - whether to output RTP directly.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::AddOneBranch");
    LOG((MSP_TRACE, "%s entered.", __fxName));

    HRESULT hr;

    _ASSERT(m_pIRTPDemux != NULL);

    CComPtr<IBaseFilter> pRTPFilter;
    hr = m_pIRTPDemux->QueryInterface(
            __uuidof(IBaseFilter), (void**)&pRTPFilter);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, query IBaseFilter failed, %x", __fxName, hr));
        return hr;
    }

    // Find the next output pin on the demux fitler.
    CComPtr<IPin> pIPinOutput;
    
    if (FAILED(hr = ::FindPin(
            (IBaseFilter *)pRTPFilter,
            (IPin**)&pIPinOutput, 
            PINDIR_OUTPUT
            )))
    {
        LOG((MSP_ERROR, "%s, find free pin on demux, %x", __fxName, hr));
        return hr;
    }

    // create and add the video decoder filter.
    CComPtr<IBaseFilter> pCodecFilter;

    if (fDirectRTP)
    {
        // only create the decoder and ask questions
        if (FAILED(hr = CoCreateInstance(
                __uuidof(TAPIVideoDecoder),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &pCodecFilter
                )))
        {
            LOG((MSP_ERROR, "%s, create filter %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        // create the decoder and add it into the graph.
        if (FAILED(hr = ::AddFilter(
            m_pIGraphBuilder,
            __uuidof(TAPIVideoDecoder),
            L"codec", 
            &pCodecFilter
            )))
        {
            LOG((MSP_ERROR, "%s, add Codec filter. %x", __fxName, hr));
            return hr;
        }
    }

    CComPtr<IPin> pIPinInput;
    if (FAILED(hr = ::FindPin(pCodecFilter, &pIPinInput, PINDIR_INPUT, TRUE)))
    {
        LOG((MSP_ERROR,
            "%s, find input pin on pCodecFilter failed. hr=%x", __fxName, hr));
        return hr;
    }

    if (fFirstBranch)
    {
        CComPtr<IStreamConfig> pIStreamConfig;

        hr = pIPinInput->QueryInterface(&pIStreamConfig);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, query IStreamConfig failed", __fxName));
            return hr;
        }

        // configure the format info on the RTP filter
        if (FAILED(hr = ConfigureRTPFormats(pRTPFilter, pIStreamConfig)))
        {
            LOG((MSP_ERROR, "%s configure RTP formats. %x", __fxName, hr));
            return hr;
        }
    }

    if (!fDirectRTP)
    {
        // Connect the decoder to the output pin of the source filter.
        if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            (IPin *)pIPinOutput, 
            (IBaseFilter *)pCodecFilter
            )))
        {
            LOG((MSP_ERROR, "%s, connect RTP filter and codec. %x", __fxName, hr));
    
            m_pIGraphBuilder->RemoveFilter(pCodecFilter);

            return hr;
        }
        pBranch->pCodecFilter    = pCodecFilter;
        pBranch->pCodecFilter->AddRef();
    }

    pBranch->pIPin = pIPinOutput;
    pBranch->pIPin->AddRef();

    // retrieve IBitrateControl
    if (FAILED (hr = pIPinInput->QueryInterface (&(pBranch->pBitrateControl))))
    {
        LOG((MSP_ERROR, "%, query IBitrateControl failed. %x", __fxName, hr));
        pBranch->pBitrateControl = NULL;
        // return hr;
    }

    LOG((MSP_TRACE, "%s, AddOneBranch exits ok.", __fxName));
    return S_OK;
}

HRESULT CStreamVideoRecv::RemoveOneBranch(
    BRANCH * pBranch
    )
/*++

Routine Description:

    Remove all the filters in a branch and release all the pointers.
    the caller of this function should not use any member of this branch
    after this function call. 

Arguments:
    
    pBranch - a pointer to a structure that has the info about the branch.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoRecv::RemoveOneBranch");
    LOG((MSP_TRACE, "%s entered", __fxName));

    if (pBranch->pBitrateControl)
    {
        pBranch->pBitrateControl->Release();
    }

    if (pBranch->pIPin)
    {
        pBranch->pIPin->Release();
    }

    if (pBranch->pCodecFilter)
    {

    // #ifdef DYNGRAPH
        HRESULT hr;
        OAFilterState FilterState;
        CComPtr <IFilterChain> pIFilterChain;

        //  Query IFilterChain
        hr = m_pIMediaControl->QueryInterface(
            __uuidof(IFilterChain), 
            (void**)&pIFilterChain
            );

        if (FAILED (hr) && (hr != E_NOINTERFACE))
        {
            LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
            // return hr;
        }

        if (pIFilterChain)
        {
            hr = m_pIMediaControl->GetState(0, &FilterState);

            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "%s get filter graph state failed, %x", __fxName, hr));
            }
            else 
            {
                // stop the chain before removing filters.
                if (FilterState == State_Running)
                {
                    // stop the chain if the graph is in running state.
                    hr = pIFilterChain->StopChain(pBranch->pCodecFilter, NULL);
                    if (FAILED(hr))
                    {
                        LOG((MSP_ERROR, "%s stop chain failed. hr=%x", __fxName, hr));
                    }
                }
            }
        }
    // #endif

        m_pIGraphBuilder->RemoveFilter(pBranch->pCodecFilter);
        pBranch->pCodecFilter->Release();
    }

    if (pBranch->pITTerminal)
    {
        // get the terminal control interface.
        CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
            pTerminal(pBranch->pITTerminal);
        
        _ASSERTE(pTerminal != NULL);

        if (pTerminal != NULL)
        {
            HRESULT hr = pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
            LOG((MSP_TRACE, 
                "%s, terminal %p is disonnected. hr:%x", 
                __fxName, pBranch->pITTerminal, hr));
        }
        pBranch->pITTerminal->Release();
    }

    if (pBranch->pITSubStream)
    {
        ((CSubStreamVideoRecv*)pBranch->pITSubStream)->
            ClearCurrentTerminal();
        pBranch->pITSubStream->Release();
    }

    LOG((MSP_TRACE, "%s, RemoveOneBranch exits ok.", __fxName));
    return S_OK;
}

HRESULT CStreamVideoRecv::ConnectPinToTerminal(
    IN  IPin *  pOutputPin,
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Connect the codec filter to the render filter inside the terminal.

Arguments:
    
    pOutputPin - The last pin before the terminal.

    pITTerminal - the terminal object.

Return Value:

    HRESULT.

--*/
{
    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);
        
        return E_NOINTERFACE;
    }


    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_CONNECT_FAIL, hr, pITTerminal);
        
        return hr;
    }

    // the number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return E_POINTER;
        }
    }

    // Connect the codec filter to the video render terminal.
    hr = ::ConnectFilters(
        m_pIGraphBuilder,
        (IBaseFilter *)pOutputPin, 
        (IPin *)Pins[0],
        FALSE               // use Connect instead of ConnectDirect.
        );

    // release the refcounts on the pins.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "connect the pin to the terminal. %x", hr));

        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
	
        return hr;

    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return hr;
}

HRESULT CStreamVideoRecv::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect video render terminal.

Arguments:
    
    pITTerminal - The terminal to be connected.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoRecv::ConnectTerminal");
    LOG((MSP_TRACE, "%s enters, pTerminal %p", __fxName, pITTerminal));

    HRESULT hr;

    // #ifdef DYNGRAPH
    OAFilterState FilterState;
    CComPtr <IFilterChain> pIFilterChain;

    //  Query IFilterChain
    hr = m_pIMediaControl->QueryInterface(
        __uuidof(IFilterChain), 
        (void**)&pIFilterChain
        );

    if (FAILED (hr) && (hr != E_NOINTERFACE))
    {
        LOG ((MSP_ERROR, "stream %ws %p failted to get filter chain. %x", m_szName, this, hr));
        return hr;
    }

    hr = m_pIMediaControl->GetState(0, &FilterState);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s get filter graph state failed, %x", __fxName, hr));
        return hr;
    }
    // #endif

    hr = SetUpInternalFilters();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s Set up internal filter failed, %x", __fxName, hr));
        
        CleanUpFilters();

        return hr;
    }

    // get the terminal control interface.
    CComQIPtr<ITTerminalControl, &__uuidof(ITTerminalControl)> 
        pTerminal(pITTerminal);
    if (pTerminal == NULL)
    {
        LOG((MSP_ERROR, "can't get Terminal Control interface"));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);
        
        return E_NOINTERFACE;
    }

    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_CONNECT_FAIL, hr, pITTerminal);
        
        return hr;
    }

    // the number of pins should never be 0.
    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_UNEXPECTED;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));

        SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return E_POINTER;
    }

    DWORD i;
    for (i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));

            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
        
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

            return E_POINTER;
        }
    }

    // check the media type supported by input pin on terminal
    BOOL fDirectRTP = FALSE;
    if (S_OK == ::PinSupportsMediaType (
        Pins[0], __uuidof(MEDIATYPE_RTP_Single_Stream)
        ))
    {
        fDirectRTP = TRUE;
    }

    // first create the branch structure needed before the terminal.
    BRANCH aBranch;
    ZeroMemory(&aBranch, sizeof BRANCH);

    hr = AddOneBranch(&aBranch, (m_Branches.GetSize() == 0), fDirectRTP);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s Set up a new decode branch failed, %x", __fxName, hr));
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
        return hr;
    }

    CComPtr <IPin> pOutputPin;

    if (fDirectRTP)
    {
        // connect the RTP output pin to the terminal's input pin.
        hr = m_pIGraphBuilder->ConnectDirect(aBranch.pIPin, Pins[0], NULL);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s connecting codec to terminal failed, %x", __fxName, hr));
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
	
            goto cleanup;
        }
    }
    else
    {
        // connect the codec to the terminal
        hr = ConnectFilters(m_pIGraphBuilder, aBranch.pCodecFilter, Pins[0]);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s connecting codec to terminal failed, %x", __fxName, hr));
            pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
            goto cleanup;
        }
    }

    // #ifdef DYNGRAPH
    if (pIFilterChain)
    {
        if (FilterState == State_Running)
        {
            if (fDirectRTP)
            {
                hr = E_UNEXPECTED;
                LOG((MSP_ERROR, "%s can't support this. %x", __fxName, hr));
                goto cleanup;
            }

            hr = pIFilterChain->StartChain(aBranch.pCodecFilter, NULL);
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "%s start chain failed. hr=%x", __fxName, hr));
                goto cleanup;
            }
        }
    }
    // #endif

    pITTerminal->AddRef();
    aBranch.pITTerminal = pITTerminal;

    if (!m_Branches.Add(aBranch))
    {
        LOG((MSP_ERROR, "%s out of mem.", __fxName));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // release the refcounts on the pins.
    for (i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    //
    // Now we are actually connected. Update our state and perform postconnection
    // (ignore postconnection error code).
    //
    pTerminal->CompleteConnectTerminal();

    return S_OK;

cleanup:
    
    // release the refcounts on the pins.
    for (i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    // remove the added filters from the graph and disconnect the terminal.
    RemoveOneBranch(&aBranch);

    return hr;
}

HRESULT CStreamVideoRecv::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph. A branch of filters is also
    released.

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    for (int i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    if (i < m_Branches.GetSize())
    {
        RemoveOneBranch(&m_Branches[i]);
        m_Branches.RemoveAt(i);
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoRecv.SetUpFilters"));

    HRESULT hr = SetUpInternalFilters();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Set up internal filter failed, %x", hr));
        
        CleanUpFilters();

        return hr;
    }

    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        HRESULT hr = ConnectTerminal(m_Terminals[i]);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    return S_OK;
}

// ITParticipantSubStreamControl methods, called by the app.
STDMETHODIMP CStreamVideoRecv::get_SubStreamFromParticipant(
    IN  ITParticipant * pITParticipant,
    OUT ITSubStream ** ppITSubStream
    )
/*++

Routine Description:

    Find out which substream is rendering the participant. 

Arguments:

    pITParticipant - the participant.

    ppITSubStream - the returned sub stream.
    
Return Value:

    S_OK,
    TAPI_E_NOITEMS,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "get substream from participant:%p", pITParticipant));
    
    if (IsBadWritePtr(ppITSubStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppITSubStream is a bad pointer"));
        return E_POINTER;
    }

    CLock lock(m_lock);

    ITSubStream * pITSubStream = NULL;

    // find out which substream has the participant.
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant = NULL;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            pITSubStream = m_SubStreams[i];
            pITSubStream->AddRef();

            break;
        }
    }
    
    if (pITSubStream == NULL)
    {
        return TAPI_E_NOITEMS;
    }

    *ppITSubStream = pITSubStream;
    return S_OK;
}

STDMETHODIMP CStreamVideoRecv::get_ParticipantFromSubStream(
    IN  ITSubStream * pITSubStream,
    OUT ITParticipant ** ppITParticipant 
    )
/*++

Routine Description:

    Find out which participant the substream is rendering.

Arguments:

    pITSubStream - the sub stream.

    ppITParticipant - the returned participant
    
Return Value:

    S_OK,
    TAPI_E_NOITEMS,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "get participant from substream:%p", pITSubStream));
    
    if (IsBadWritePtr(ppITParticipant, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppITParticipant is a bad pointer"));
        return E_POINTER;
    }

    CLock lock(m_lock);

    int i;

    // check to see if the substream is in our list.
    if ((i = m_SubStreams.Find(pITSubStream)) < 0)
    {
        LOG((MSP_ERROR, "wrong SubStream handle %p", pITSubStream));
        return E_INVALIDARG;
    }

    ITParticipant *pITParticipant;
    DWORD dwSSRC;

    if (((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) == FALSE)
    {
        return TAPI_E_NOITEMS;
    }

    *ppITParticipant = pITParticipant;
    
    return S_OK;
}

STDMETHODIMP CStreamVideoRecv::SwitchTerminalToSubStream(
    IN  ITTerminal * pITTerminal,
    IN  ITSubStream * pITSubStream
    )
/*++

Routine Description:

    Switch terminal to a substream to display the participant that is on the
    substream.

Arguments:

    pITTerminal - the terminal.

    pITSubStream - the sub stream.
    
Return Value:

    S_OK,
    E_INVALIDARG,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "switch terminal %p to substream:%p", 
        pITTerminal, pITSubStream));
    
    CLock lock(m_lock);

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // first, find out which branch has the terminal now.
    for (int i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pITTerminal == pITTerminal)
        {
            break;
        }
    }

    if (i >= m_Branches.GetSize())
    {
        LOG((MSP_TRACE, "terminal %p doesn't exist", pITTerminal));
        return E_INVALIDARG;
    }

    // second, find out if the substream exists.
    if (m_SubStreams.Find(pITSubStream) < 0)
    {
        LOG((MSP_TRACE, "SubStream %p doesn't exist", pITSubStream));
        return E_INVALIDARG;
    }


    // thrid, find the participant on the substream and configure the demux
    // filter to render the participant on the chosen branch.
    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) ;

    _ASSERTE(pITParticipant != NULL);

    // we don't need the reference here.
    pITParticipant->Release();

    // map the pin to this SSRC only.
    HRESULT hr = m_pIRTPDemux->SetMappingState(
        -1, m_Branches[i].pIPin, dwSSRC, TRUE
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "map SSRC %x to pin %p returned %x", 
            dwSSRC, m_Branches[i].pIPin, hr));
        return hr;
    }    

    DWORD dwOldSSRC = 0;

    // Finally, set up the mappings among the branch, the substream and 
    // the terminal
    
    // release the refcount on the old branch that the substream was on.
    for (int j = 0; j < m_Branches.GetSize(); j ++)
    {
        if (m_Branches[j].pITSubStream == pITSubStream)
        {
            m_Branches[j].pITSubStream->Release();
            m_Branches[j].pITSubStream = NULL;
            break;
        }
    }

    if (m_Branches[i].pITSubStream != NULL)
    {
        ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)->
            ClearCurrentTerminal();

        m_Branches[i].pITSubStream->Release();
        dwOldSSRC = m_Branches[i].dwSSRC;
    }

    pITSubStream->AddRef();
    m_Branches[i].pITSubStream = pITSubStream;
    m_Branches[i].dwSSRC = dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal();
    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentTerminal(
        m_Branches[i].pITTerminal
        );


    // After all the steps, we still have to change QOS reservation.
    if (dwOldSSRC != 0)
    {
        // cancel QOS for the old participant.
        if (FAILED(hr = m_pIRTPSession->SetQosState(dwOldSSRC, FALSE)))
        {
            LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwOldSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "disabled video QOS for %x.", dwOldSSRC));
        }
    }
    
    // reserve QOS for the new participant.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
    {
        LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }

    return S_OK;
}


HRESULT CStreamVideoRecv::ProcessTalkingEvent(
    IN  DWORD dwSSRC
    )
/*++

Routine Description:

    A sender has just joined. A substream needs to be created for the
    participant. 
    
    A pin mapped event might have happended when we didn't have the 
    participant's name so it was queued in a list. Now that we have a new 
    participant, let's check if this is the same participant. If it is, 
    we complete the pin mapped event by sending the app an notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::ProcessTalkingEvent");

    LOG((MSP_TRACE, "%s entered. %x", __fxName, dwSSRC));

    CLock lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // first find out if this participant object exists.
    ITParticipant * pITParticipant = NULL;
    
    int i;
    // find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            break;
        }
    }

    // if the participant is not there yet, just return. It will be checked
    // later when CName is available.
    if (!pITParticipant)
    {
        LOG((MSP_TRACE, "%s participant not exist", __fxName));
    
        return S_OK;
    }

    // Find out if a substream has been created for this participant when we
    // processed PinMapped event and receiver reports.
    for (i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            // the participant has been created.
            return S_OK;
        }
    }

    ITSubStream * pITSubStream;
    HRESULT hr = InternalCreateSubStream(&pITSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
        return hr;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
        dwSSRC, pITParticipant
        );

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_NEW_SUBSTREAM, 
        pITParticipant,
        pITSubStream
        );

    // look at the pending SSRC list and find out if this report
    // fits in the list.
    IPin *pIPin = NULL;

    for (i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].dwSSRC == dwSSRC)
        {
            pIPin = m_PinMappedEvents[i].pIPin;
            break;
        }
    }
    
    if (!pIPin)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));

        pITSubStream->Release();
    
        return S_OK;;
    }

    // get rid of the peding event.
    m_PinMappedEvents.RemoveAt(i);

    // reserve QOS since we are rendering this sender.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
    {
        LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }

    // tell the app about the newly mapped sender.
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pIPin == pIPin)
        {
            if (m_Branches[i].pITSubStream != NULL)
            {
                ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)
                    ->ClearCurrentTerminal();

                m_Branches[i].pITSubStream->Release();
            }

            m_Branches[i].dwSSRC = dwSSRC;
            m_Branches[i].pITSubStream = pITSubStream;
            pITSubStream->AddRef();

            ((CSubStreamVideoRecv*)pITSubStream)->
                SetCurrentTerminal(m_Branches[i].pITTerminal);

            ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                PE_SUBSTREAM_MAPPED, 
                pITParticipant,
                pITSubStream
                );

            break;
        }
    }

    pITSubStream->Release();
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessSilentEvent(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessSilentEvent, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // first find out if this participant object exists.
    ITParticipant * pITParticipant = NULL;

    int i;
    // find the SSRC in our participant list.
    for (i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            break;
        }
    }

    // if the participant is not there, just return.
    if (!pITParticipant)
    {
        return S_OK;
    }

  
    HRESULT hr;
    // cancel QOS for this participant.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, FALSE)))
    {
        LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
    }
    
    // find out which substream is going away.
    ITSubStream * pITSubStream = NULL;
    for (i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        // Find out the participant on the SubStream.
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pTempParticipant == pITParticipant)
        {
            pITSubStream = m_SubStreams[i];
            break;
        }
    }

    if (pITSubStream)
    {
        // remove the mapping if the substream was mapped to a branch.
        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                // fire an event to tell the app that the substream is not used.
                ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                    PE_SUBSTREAM_UNMAPPED, 
                    pITParticipant,
                    pITSubStream
                    );

                break;
            }

        }
    
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_REMOVED, 
            pITParticipant,
            pITSubStream
            );

        if (m_SubStreams.Remove(pITSubStream))
        {
            pITSubStream->Release();
        }
    }

    return S_OK;
}

HRESULT CStreamVideoRecv::NewParticipantPostProcess(
    IN  DWORD dwSSRC, 
    IN  ITParticipant *pITParticipant
    )
/*++

Routine Description:

    A pin mapped event might have happended when we didn't have the 
    participant's name so it was queued in a list. Now that we have a new 
    participant, let's check if this is the same participant. If it is, 
    we complete the pin mapped event by creating a substream and send
    the app a notification.

Arguments:

    dwSSRC - the SSRC of the participant.

    pITParticipant - the participant object.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Check pending mapped event, dwSSRC: %x", m_szName, dwSSRC));
    
    // look at the pending SSRC list and find out if this report
    // fits in the list.
    IPin *pIPin = NULL;

    for (int i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].dwSSRC == dwSSRC)
        {
            pIPin = m_PinMappedEvents[i].pIPin;
            break;
        }
    }
    
    if (!pIPin)
    {
        // the SSRC is not in the list of pending PinMappedEvents.
        LOG((MSP_TRACE, "the SSRC %x is not in the pending list", dwSSRC));

        // Find out if the participant is talking.
        // if (ParticipantIsNotTalking)
        {
            return S_OK;;
        }
    }

    ITSubStream * pITSubStream;
    HRESULT hr = InternalCreateSubStream(&pITSubStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
        return hr;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
        dwSSRC, pITParticipant
        );

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_NEW_SUBSTREAM, 
        pITParticipant,
        pITSubStream
        );

    if (pIPin)
    {
        // we got here because we had a pending mapped event.

        // get rid of the peding event.
        m_PinMappedEvents.RemoveAt(i);

        if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
        {
            LOG((MSP_ERROR, "enabling video QOS for %x. hr:%x", dwSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
        }
    
        // Now we get the participant, the substream, and the pin. Establish a mapping
        // between the decoding branch and the substream.
        for (i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pIPin == pIPin)
            {
                if (m_Branches[i].pITSubStream != NULL)
                {
                    ((CSubStreamVideoRecv*)m_Branches[i].pITSubStream)
                        ->ClearCurrentTerminal();

                    m_Branches[i].pITSubStream->Release();
                }

                m_Branches[i].dwSSRC = dwSSRC;
                m_Branches[i].pITSubStream = pITSubStream;
                pITSubStream->AddRef();

                ((CSubStreamVideoRecv*)pITSubStream)->
                    SetCurrentTerminal(m_Branches[i].pITTerminal);

                ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                    PE_SUBSTREAM_MAPPED, 
                    pITParticipant,
                    pITSubStream
                    );

                break;
            }
        }
        _ASSERT(i < m_Branches.GetSize());
    }

    pITSubStream->Release();
   
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessPinMappedEvent(
    IN  DWORD   dwSSRC,
    IN  IPin *  pIPin
    )
/*++

Routine Description:

    A pin just got a new SSRC mapped to it. If the participant doesn't exist, 
    put the event in a pending queue and wait for a RTCP report that has the
    participant's name. If the participant exists, check to see if a SubStream
    has been created for the stream. If not, a SubStream is created. Then a
    Particiapnt substream event is fired.

Arguments:

    dwSSRC - the SSRC of the participant.

    pIPin - the output pin of the demux filter that just got a new SSRC.

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Process pin mapped event, pIPin: %p", m_szName, pIPin));
    
    CLock lock(m_lock);

    if (m_pIRTPDemux == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    for (int iBranch = 0; iBranch < m_Branches.GetSize(); iBranch ++)
    {
        if (m_Branches[iBranch].pIPin == pIPin)
        {
            break;
        }
    }

    LOG((MSP_INFO, "Branch %d has the pin", iBranch));

    if (iBranch >= m_Branches.GetSize())
    {
        LOG((MSP_ERROR, "Wrong pin is mapped. %p", pIPin));
        return E_UNEXPECTED;
    }

    // sometimes we might get a mapped event for branches that are still 
    // in use.
    if (m_Branches[iBranch].pITSubStream != NULL)
    {
        LOG((MSP_ERROR, "ProcessPinMappedEvent: Branch still in use"));

        // sometimes we might get duplicated map events
        if (m_Branches[iBranch].dwSSRC == dwSSRC)
        {
            // LOG((MSP_WARNING, "ProcessPinMappedEvent: Branch still in use"));

            LOG((MSP_ERROR, "The same pin mapped twice. %p", pIPin));
            return E_UNEXPECTED;
        }
        else
        {
            LOG((MSP_ERROR, "The branch is in use. Cleaning up."));

            ((CSubStreamVideoRecv*)m_Branches[iBranch].pITSubStream)->
                ClearCurrentTerminal();

            // cancel QOS for the old participant.
            m_pIRTPSession->SetQosState(m_Branches[iBranch].dwSSRC, FALSE);

            m_Branches[iBranch].pITSubStream->Release();
            m_Branches[iBranch].pITSubStream = NULL;
            m_Branches[iBranch].dwSSRC = 0;
        }
    }

    ITParticipant * pITParticipant = NULL;

    // find the SSRC in our participant list.
    for (int i = 0; i < m_Participants.GetSize(); i ++)
    {
        if (((CParticipant *)m_Participants[i])->
                HasSSRC((ITStream *)this, dwSSRC))
        {
            pITParticipant = m_Participants[i];
            break;
        }
    }

    // if the participant is not there yet, put the event in a queue and it
    // will be fired when we have the CName for the participant.
    if (!pITParticipant)
    {
        LOG((MSP_INFO, "can't find a participant that has SSRC %x", dwSSRC));

        PINMAPEVENT Event;
        Event.pIPin = pIPin;
        Event.dwSSRC = dwSSRC;

        m_PinMappedEvents.Add(Event);
        
        LOG((MSP_INFO, "added the event to pending list, new list size:%d", 
            m_PinMappedEvents.GetSize()));

        return S_OK;
    }

    HRESULT hr;

    // Enable QOS for the participant since it is being rendered.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, TRUE)))
    {
        LOG((MSP_ERROR, "enabling vidoe QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "enabled video QOS for %x.", dwSSRC));
    }
    
    // Find out if a substream has been created for this participant who might
    // have been a receiver only and hasn't got a substream.
    ITSubStream *   pITSubStream = NULL;
    for (i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pITParticipant == pTempParticipant)
        {
            pITSubStream = m_SubStreams[i];
            pITSubStream->AddRef();

            break;
        }
    }

    if (pITSubStream == NULL)
    {
        // we need to create a substream for this participant since he has 
        // started sending.
        hr = InternalCreateSubStream(&pITSubStream);
    
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%ls can't create a SubStream, %x", m_szName, hr));
            return hr;
        }

        ((CSubStreamVideoRecv*)pITSubStream)->SetCurrentParticipant(
            dwSSRC, pITParticipant
            );

        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_NEW_SUBSTREAM, 
            pITParticipant,
            pITSubStream
            );
    }

    if (((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal())
    {
        // The substrem has a terminal before. This is an error.
        // _ASSERT(!"SubStream has a terminal already");

        LOG((MSP_ERROR, "SubStream %p has already got a terminal", pITSubStream));

        // remove the mapping if the substream was mapped to a branch.
        for (i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                // cancel QOS for the old participant.
                m_pIRTPSession->SetQosState(m_Branches[i].dwSSRC, FALSE);

                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                LOG((MSP_ERROR, "SubStream %p was mapped to branch %d", i));
                break;
            }
        }
    }

    // Now we get the participant, the substream, and the pin. Establish a mapping
    // between the decoding branch and the substream.
    m_Branches[iBranch].dwSSRC = dwSSRC;
    m_Branches[iBranch].pITSubStream = pITSubStream;
    pITSubStream->AddRef();

    ((CSubStreamVideoRecv*)pITSubStream)->
        SetCurrentTerminal(m_Branches[iBranch].pITTerminal);

    ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
        PE_SUBSTREAM_MAPPED, 
        pITParticipant,
        pITSubStream
        );

    pITSubStream->Release();
   
    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessPinUnmapEvent(
    IN  DWORD   dwSSRCOnPin,
    IN  IPin *  pIPin
    )
/*++

Routine Description:

    A pin just got unmapped by the demux. Notify the app which substream
    is not going to have any data.

Arguments:

    dwSSRCOnPin - the SSRC of the participant.

    pIPin - the output pin of the demux filter

Return Value:

    S_OK,
    E_UNEXPECTED

--*/
{
    LOG((MSP_TRACE, "%ls Proces pin unmapped event, pIPin: %p", m_szName, pIPin));
    
    CLock lock(m_lock);

    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the demux filter doesn't exist."));
        return E_UNEXPECTED;
    }

    // look at the pending SSRC list and find out if the pin is in the 
    // pending list.
    for (int i = 0; i < m_PinMappedEvents.GetSize(); i ++)
    {
        if (m_PinMappedEvents[i].pIPin == pIPin)
        {
            break;
        }
    }

    // if the pin is in the pending list, just remove it.
    if (i < m_PinMappedEvents.GetSize())
    {
        m_PinMappedEvents.RemoveAt(i);
        return S_OK;
    }

    // find out which substream got unmapped.
    ITSubStream * pITSubStream = NULL;
    for (i = 0; i < m_Branches.GetSize(); i ++)
    {
        if (m_Branches[i].pIPin == pIPin)
        {
            pITSubStream = m_Branches[i].pITSubStream;

            if (pITSubStream)
            {
                // Don't release the ref until the end of this function.
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;
            }
            break;
        }
    }

    if (!pITSubStream)
    {
        LOG((MSP_ERROR, "can't find a substream that got unmapped."));
        return TAPI_E_NOITEMS;
    }

    ((CSubStreamVideoRecv*)pITSubStream)->ClearCurrentTerminal();

    ITParticipant *pITParticipant = NULL;
    DWORD dwSSRC;

    ((CSubStreamVideoRecv*)pITSubStream)->GetCurrentParticipant(
        &dwSSRC, &pITParticipant
        ) ;

    _ASSERTE(pITParticipant != NULL);

    if (dwSSRCOnPin != dwSSRC)
    {
        LOG((MSP_ERROR, "SSRCs don't match, pin's SSRC:%x, mine:%x", 
            dwSSRCOnPin, dwSSRC));
    }

    if (pITParticipant != NULL)
    {
        // fire an event to tell the app that the substream is not used.
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_UNMAPPED, 
            pITParticipant,
            pITSubStream
            );

        pITParticipant->Release();

        // cancel QOS for this participant.
        HRESULT hr = m_pIRTPSession->SetQosState(dwSSRC, FALSE);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "disabling QOS for %x. hr:%x", dwSSRC, hr));
        }
        else
        {
            LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
        }
    }

    pITSubStream->Release();

    return S_OK;
}

HRESULT CStreamVideoRecv::ProcessParticipantLeave(
    IN  DWORD   dwSSRC
    )
/*++

Routine Description:

    When participant left the session, remove the stream from the participant
    object's list of streams. If all streams are removed, remove the 
    participant from the call object's list too.

Arguments:
    
    dwSSRC - the SSRC of the participant left.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "%ls ProcessParticipantLeave, SSRC: %x", m_szName, dwSSRC));
    
    CLock lock(m_lock);
    
    if (m_pIRTPSession == NULL)
    {
        LOG((MSP_ERROR, "the network filter doesn't exist."));
        return E_UNEXPECTED;
    }

    CParticipant *pParticipant;
    BOOL fLast = FALSE;

    HRESULT hr = E_FAIL;

    // first try to find the SSRC in our participant list.
    for (int iParticipant = 0; 
        iParticipant < m_Participants.GetSize(); iParticipant ++)
    {
        pParticipant = (CParticipant *)m_Participants[iParticipant];
        hr = pParticipant->RemoveStream(
                (ITStream *)this,
                dwSSRC,
                &fLast
                );
        
        if (SUCCEEDED(hr))
        {
            break;
        }
    }

    // if the participant is not found
    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "SSRC:%x had been removed.", dwSSRC));
        return hr;
    }

    ITParticipant *pITParticipant = m_Participants[iParticipant];

    // cancel QOS for this participant.
    if (FAILED(hr = m_pIRTPSession->SetQosState(dwSSRC, FALSE)))
    {
        // the stream might already been stopped
        // so we just put a warning here
        LOG((MSP_WARN, "disabling QOS for %x. hr:%x", dwSSRC, hr));
    }
    else
    {
        LOG((MSP_INFO, "disabled video QOS for %x.", dwSSRC));
    }
    
    // find out which substream is going away.
    ITSubStream * pITSubStream = NULL;
    for (int i = 0; i < m_SubStreams.GetSize(); i ++)
    {
        // Find out the participant on the SubStream.
        ITParticipant *pTempParticipant;
        DWORD dwSSRC;

        ((CSubStreamVideoRecv*)m_SubStreams[i])->GetCurrentParticipant(
            &dwSSRC, &pTempParticipant
            );

        _ASSERTE(pTempParticipant != NULL);

        pTempParticipant->Release(); // we dont' need the ref here.

        if (pTempParticipant == pITParticipant)
        {
            pITSubStream = m_SubStreams[i];
            break;
        }
    }

    if (pITSubStream)
    {
        // remove the mapping if the substream was mapped to a branch.
        for (int i = 0; i < m_Branches.GetSize(); i ++)
        {
            if (m_Branches[i].pITSubStream == pITSubStream)
            {
                m_Branches[i].pITSubStream->Release();
                m_Branches[i].pITSubStream = NULL;
                m_Branches[i].dwSSRC = 0;

                // fire an event to tell the app that the substream is not used.
                ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
                    PE_SUBSTREAM_UNMAPPED, 
                    pITParticipant,
                    pITSubStream
                    );

                break;
            }

        }
    
        ((CIPConfMSPCall *)m_pMSPCall)->SendParticipantEvent(
            PE_SUBSTREAM_REMOVED, 
            pITParticipant,
            pITSubStream
            );

        if (m_SubStreams.Remove(pITSubStream))
        {
            pITSubStream->Release();
        }
    }

    
    m_Participants.RemoveAt(iParticipant);

    // if this stream is the last stream that the participant is on,
    // tell the call object to remove it from its list.
    if (fLast)
    {
        ((CIPConfMSPCall *)m_pMSPCall)->ParticipantLeft(pITParticipant);
    }

    pITParticipant->Release();

    return S_OK;
}

//
// ITStreamQualityControl methods
//
STDMETHODIMP CStreamVideoRecv::Set (
    IN   StreamQualityProperty Property, 
    IN   long lValue, 
    IN   TAPIControlFlags lFlags
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamVideoRecv::Get(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a quality control property. Delegated to the quality 
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoRecv::Get(QualityControl)");

    HRESULT hr;
    int i;
    LONG totalbps, bps;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MaxBitrate:

        bps = 0;
        totalbps = 0;

        for (i=0; i<m_Branches.GetSize (); i++)
        {
            if (NULL == m_Branches[i].pBitrateControl)
                continue;

            if (FAILED (hr = m_Branches[i].pBitrateControl->Get (BitrateControl_Maximum, &bps, plFlags, LAYERID)))
                LOG ((MSP_ERROR, "%s failed to get maximum bitrate, %x", __fxName, hr));
            else
                totalbps += bps;
        }

        *plValue = totalbps;

        hr = S_OK;
        break;

    case InnerStreamQuality_CurrBitrate:

        bps = 0;
        totalbps = 0;

        for (i=0; i<m_Branches.GetSize (); i++)
        {
            if (NULL == m_Branches[i].pBitrateControl)
                continue;

            if (FAILED (hr = m_Branches[i].pBitrateControl->Get (BitrateControl_Current, &bps, plFlags, LAYERID)))
                LOG ((MSP_ERROR, "%s failed to get current bitrate, %x", __fxName, hr));
            else
                totalbps += bps;
        }

        *plValue = totalbps;

        hr = S_OK;
        break;

    default:
        hr = CIPConfMSPStream::Get (property, plValue, plFlags);
        break;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CStreamVideoSend
//
/////////////////////////////////////////////////////////////////////////////
CStreamVideoSend::CStreamVideoSend()
    : CIPConfMSPStream(),
    m_pCaptureTerminal(NULL),
    m_pPreviewTerminal(NULL),
    m_pCaptureFilter(NULL),
    m_pCapturePin(NULL),
    m_pPreviewPin(NULL),
    m_pRTPPin(NULL),
    m_pCaptureBitrateControl(NULL),
    m_pCaptureFrameRateControl(NULL),
    m_pPreviewFrameRateControl(NULL)
{
      m_szName = L"VideoSend";
}

CStreamVideoSend::~CStreamVideoSend()
{
    CleanupCachedInterface();
}

void CStreamVideoSend::CleanupCachedInterface()
{
    if (m_pCaptureFilter) 
    {
        m_pCaptureFilter->Release();
        m_pCaptureFilter = NULL;
    }

    if (m_pCapturePin)
    {
        m_pCapturePin->Release();
        m_pCapturePin = NULL;
    }

    if (m_pIStreamConfig)
    {
        m_pIStreamConfig->Release();
        m_pIStreamConfig = NULL;
    }

    if (m_pPreviewPin) 
    {
        m_pPreviewPin->Release();
        m_pPreviewPin = NULL;
    }

    if (m_pRTPPin)
    {
        m_pRTPPin->Release();
        m_pRTPPin = NULL;
    }

    if (m_pCaptureFrameRateControl)
    {
        m_pCaptureFrameRateControl->Release();
        m_pCaptureFrameRateControl = NULL;
    }

    if (m_pCaptureBitrateControl)
    {
        m_pCaptureBitrateControl->Release();
        m_pCaptureBitrateControl = NULL;
    }

    if (m_pPreviewFrameRateControl)
    {
        m_pPreviewFrameRateControl->Release();
        m_pPreviewFrameRateControl = NULL;
    }
}

HRESULT CStreamVideoSend::ShutDown()
/*++

Routine Description:

    Shut down the stream. Release our members and then calls the base class's
    ShutDown method.

Arguments:
    

Return Value:

S_OK
--*/
{
    CLock lock(m_lock);

    // if there are terminals
    BOOL fHasTerminal = FALSE;
    if (m_Terminals.GetSize() > 0)
    {
        fHasTerminal = TRUE;
    }

    // if graph is running
    HRESULT hr;
    OAFilterState FilterState = State_Stopped;
    if (m_pIMediaControl)
    {
        if (FAILED (hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG ((MSP_ERROR, "CStreamAudioRecv::ShutDown failed to query filter state. %d", hr));
            FilterState = State_Stopped;
        }
    }

    if (m_pCaptureTerminal) 
    {
        m_pCaptureTerminal->Release();
        m_pCaptureTerminal = NULL;
    }

    if (m_pPreviewTerminal) 
    {
        m_pPreviewTerminal->Release();
        m_pPreviewTerminal = NULL;
    }

    CleanupCachedInterface();

    // fire event
    if (fHasTerminal && FilterState == State_Running)
    {
        SendStreamEvent(CALL_STREAM_INACTIVE, CALL_CAUSE_LOCAL_REQUEST, 0, NULL);
    }

    return CIPConfMSPStream::ShutDown();
}

HRESULT 
SetVideoFormat(
    IN      IUnknown *  pIUnknown,
    IN      BOOL        bCIF,
    IN      DWORD       dwFramesPerSecond
    )
/*++

Routine Description:

    Set the video format to be CIF or QCIF and also set the frames per second.

Arguments:
    
    pIUnknown - a capture terminal.

    bCIF                - CIF or QCIF.

    dwFramesPerSecond   - Frames per second.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "SetVideoFormat"));

    HRESULT hr;

    // first get eht IAMStreamConfig interface.
    CComPtr<IAMStreamConfig> pIAMStreamConfig;

    if (FAILED(hr = pIUnknown->QueryInterface(
        __uuidof(IAMStreamConfig),
        (void **)&pIAMStreamConfig
        )))
    {
        LOG((MSP_ERROR, "Can't get IAMStreamConfig interface.%8x", hr));
        return hr;
    }
    
    // get the current format of the video capture terminal.
    AM_MEDIA_TYPE *pmt;
    if (FAILED(hr = pIAMStreamConfig->GetFormat(&pmt)))
    {
        LOG((MSP_ERROR, "GetFormat returns error: %8x", hr));
        return hr;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
    if (pVideoInfo == NULL)
    {
        MSPDeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    BITMAPINFOHEADER *pHeader = HEADER(pmt->pbFormat);
    if (pHeader == NULL)
    {
        MSPDeleteMediaType(pmt);
        return E_UNEXPECTED;
    }

    LOG((MSP_INFO,
        "Video capture: Format BitRate: %d, TimePerFrame: %d",
        pVideoInfo->dwBitRate,
        pVideoInfo->AvgTimePerFrame));

    LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
        (DWORD)pHeader->biCompression & 0xff,
        ((DWORD)pHeader->biCompression >> 8) & 0xff,
        ((DWORD)pHeader->biCompression >> 16) & 0xff,
        ((DWORD)pHeader->biCompression >> 24) & 0xff,
        pHeader->biBitCount,
        pHeader->biWidth,
        pHeader->biHeight));

    // The time is in 100ns unit.
    pVideoInfo->AvgTimePerFrame = (DWORD) 1e7 / dwFramesPerSecond;
    
    if (bCIF)
    {
        pHeader->biWidth = CIFWIDTH;
        pHeader->biHeight = CIFHEIGHT;
    }
    else
    {
        pHeader->biWidth = QCIFWIDTH;
        pHeader->biHeight = QCIFHEIGHT;
    }

#if defined(ALPHA)
    // update bmiSize with new Width/Height
    pHeader->biSizeImage = DIBSIZE( ((VIDEOINFOHEADER *)pmt->pbFormat)->bmiHeader );
#endif

    if (FAILED(hr = pIAMStreamConfig->SetFormat(pmt)))
    {
        LOG((MSP_ERROR, "putMediaFormat returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO,
            "Video capture: Format BitRate: %d, TimePerFrame: %d",
            pVideoInfo->dwBitRate,
            pVideoInfo->AvgTimePerFrame));

        LOG((MSP_INFO, "Video capture: Format Compression:%c%c%c%c %dbit %dx%d",
            (DWORD)pHeader->biCompression & 0xff,
            ((DWORD)pHeader->biCompression >> 8) & 0xff,
            ((DWORD)pHeader->biCompression >> 16) & 0xff,
            ((DWORD)pHeader->biCompression >> 24) & 0xff,
            pHeader->biBitCount,
            pHeader->biWidth,
            pHeader->biHeight));
    }

    MSPDeleteMediaType(pmt);

    return hr;
}

HRESULT 
SetVideoBufferSize(
    IN IUnknown *pIUnknown
    )
/*++

Routine Description:

    Set the video capture terminal's buffersize.

Arguments:
    
    pIUnknown - a capture terminal.

Return Value:

    HRESULT

--*/
{
// The number of capture buffers is four for now.
#define NUMCAPTUREBUFFER 4

    LOG((MSP_TRACE, "SetVideoBufferSize"));

    HRESULT hr;

    CComPtr<IAMBufferNegotiation> pBN;
    if (FAILED(hr = pIUnknown->QueryInterface(
            __uuidof(IAMBufferNegotiation),
            (void **)&pBN
            )))
    {
        LOG((MSP_ERROR, "Can't get buffer negotiation interface.%8x", hr));
        return hr;
    }

    ALLOCATOR_PROPERTIES prop;

#if 0   // Get allocator property is not working.
    if (FAILED(hr = pBN->GetAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "GetAllocatorProperties returns error: %8x", hr));
        return hr;
    }

    // Set the number of buffers.
    if (prop.cBuffers > NUMCAPTUREBUFFER)
    {
        prop.cBuffers = NUMCAPTUREBUFFER;
    }
#endif
    
    DWORD dwBuffers = NUMCAPTUREBUFFER;
    GetRegValue(gszNumVideoCaptureBuffers, &dwBuffers);

    prop.cBuffers = dwBuffers;
    prop.cbBuffer = -1;
    prop.cbAlign  = -1;
    prop.cbPrefix = -1;

    if (FAILED(hr = pBN->SuggestAllocatorProperties(&prop)))
    {
        LOG((MSP_ERROR, "SuggestAllocatorProperties returns error: %8x", hr));
    }
    else
    {
        LOG((MSP_INFO, 
            "SetVidedobuffersize"
            " buffers: %d, buffersize: %d, align: %d, Prefix: %d",
            prop.cBuffers,
            prop.cbBuffer,
            prop.cbAlign,
            prop.cbPrefix
            ));
    }
    return hr;
}

HRESULT CStreamVideoSend::FindPreviewInputPin(
    IN  ITTerminalControl*  pTerminal,
    OUT IPin **             ppIPin
    )
/*++

Routine Description:

    Find the input pin on a preview terminal.

Arguments:
    
    pTerminal - a video render terminal.

    ppIPin  - the address to store a pointer to a IPin interface.

Return Value:

    HRESULT

--*/
{
    LOG((MSP_TRACE, "VideoSend.FindPreviewInputPin, pTerminal %x", pTerminal));

/*
    // try to disable DDraw because we want to use DDraw for receive stream.
    HRESULT hr2; 
    IDrawVideoImage *pIDrawVideoImage;
    hr2 = pTerminal->QueryInterface(__uuidof(IDrawVideoImage), (void **)&pIDrawVideoImage); 
    if (SUCCEEDED(hr2))
    {
        hr2 = pIDrawVideoImage->DrawVideoImageBegin();
        if (FAILED(hr2))
        {
            LOG((MSP_WARN, "Can't disable DDraw. %x", hr2));
        }
        else
        {
            LOG((MSP_INFO, "DDraw disabled."));
        }
        
        pIDrawVideoImage->Release();
    }
    else
    {
        LOG((MSP_WARN, "Can't get IDrawVideoImage. %x", hr2));
    }
*/

    // Get the pins from the first terminal because we only use on terminal
    // on this stream.
    const DWORD MAXPINS     = 8;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_RENDER, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't connect to terminal, %x", hr));
        return hr;
    }

    if (dwNumPins == 0)
    {
        LOG((MSP_ERROR, "terminal has no pins."));
        return hr;
    }

    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));
        return E_POINTER;
    }

    for (DWORD i = 0; i < dwNumPins; i++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));
            return E_POINTER;
        }
    }

    // Save the first pin and release the others.
    CComPtr <IPin> pIPin = Pins[0];
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        Pins[i]->Release();
    }

    pIPin.p->AddRef();
    *ppIPin = pIPin;

    return hr;
}

HRESULT CStreamVideoSend::CheckTerminalTypeAndDirection(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:
    
    Check if the terminal is allowed on this stream.
    VideoSend allows both a capture terminal and a preivew terminal.

Arguments:

    pTerminal   - the terminal.

Return value:

    HRESULT.
    S_OK means the terminal is OK.
*/
{
    LOG((MSP_TRACE, "VideoSend.CheckTerminalTypeAndDirection"));

    // This stream only support one capture + one preview terminal
    if (m_Terminals.GetSize() > 1)
    {
        return TAPI_E_MAXTERMINALS;
    }

    // check the media type of this terminal.
    long lMediaType;
    HRESULT hr = pTerminal->get_MediaType(&lMediaType);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal media type. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if ((DWORD)lMediaType != m_dwMediaType)
    {
        return TAPI_E_INVALIDTERMINAL;
    }

    // check the direction of this terminal.
    TERMINAL_DIRECTION Direction;
    hr = pTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
        return TAPI_E_INVALIDTERMINAL;
    }

    if (m_Terminals.GetSize() > 0)
    {
        // check the direction of this terminal.
        TERMINAL_DIRECTION Direction2;
        hr = m_Terminals[0]->get_Direction(&Direction2);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            return TAPI_E_INVALIDTERMINAL;
        }
        if (Direction == Direction2)
        {
            LOG((MSP_ERROR, 
                "can't have two terminals with the same direction. %x", hr));
            return TAPI_E_MAXTERMINALS;
        }
    }
    return S_OK;
}

HRESULT CStreamVideoSend::SetUpFilters()
/*++

Routine Description:

    Insert filters into the graph and connect to the terminals.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "VideoSend.SetUpFilters"));

    // we only support one capture terminal and one preview 
    // window on this stream.
    if (m_Terminals.GetSize() > 2)
    {
        return E_UNEXPECTED;
    }

    int iCaptureIndex = -1, iPreviewIndex = -1;

    // Find out which terminal is capture and which is preview.
    HRESULT hr;
    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        TERMINAL_DIRECTION Direction;
        hr = m_Terminals[i]->get_Direction(&Direction);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "can't get terminal direction. %x", hr));
            SendStreamEvent(CALL_TERMINAL_FAIL, CALL_CAUSE_BAD_DEVICE, hr, m_Terminals[i]);
        
            return hr;
        }

        if (Direction == TD_CAPTURE || Direction == TD_BIDIRECTIONAL)
        {
            iCaptureIndex = i;
        }
        else
        {
            iPreviewIndex = i;
        }
    }

    // the stream will not work without a capture terminal.
    if (iCaptureIndex == -1)
    {
        LOG((MSP_ERROR, "no capture terminal selected."));
        return E_UNEXPECTED;
    }

    // Connect the capture filter to the terminal.
    if (FAILED(hr = ConnectTerminal(
        m_Terminals[iCaptureIndex]
        )))
    {
        LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

        return hr;
    }

    if (iPreviewIndex != -1)
    {
        // Connect the preview filter to the terminal.
        if (FAILED(hr = ConnectTerminal(
            m_Terminals[iPreviewIndex]
            )))
        {
            LOG((MSP_ERROR, "connect the codec filter to terminal. %x", hr));

            return hr;
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::GetVideoCapturePins(
    IN  ITTerminalControl*  pTerminal,
    OUT BOOL *pfDirectRTP
    )
/*++

Routine Description:

    Given a video capture terminal, find all the pins we need, which will be
    the capture pin, preview pin, and the RTP packetization pin.

    Side effect: It changes the m_pCapturePin, m_pPreviewPin, m_pRTPPin
    members, which needs to be cleaned up if the terminal is disconnected.

Arguments:
    
    pTerminal - a pointer to the ITTerminalControl interface.

    pfDirectRTP - whether this terminal support RTP directly.

Return Value:

    HRESULT

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::GetVideoCapturePins");
    LOG((MSP_TRACE, "%s enters", __fxName));

    const DWORD MAXPINS     = 4;
    
    DWORD       dwNumPins   = MAXPINS;
    IPin *      Pins[MAXPINS];

    HRESULT hr = pTerminal->ConnectTerminal(
        m_pIGraphBuilder, TD_CAPTURE, &dwNumPins, Pins
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s, can't connect to terminal, hr=%x", __fxName, hr));
        return hr;
    }

    _ASSERT(m_pCapturePin == NULL && m_pPreviewPin == NULL && m_pRTPPin == NULL);
    
    if (IsBadReadPtr (Pins, dwNumPins * sizeof (IPin*)))
    {
        LOG((MSP_ERROR, "terminal returned bad pin array"));
        return E_POINTER;
    }


    // find the pins we need.
    for (DWORD i = 0; i < dwNumPins; i ++)
    {
        if (IsBadReadPtr (Pins[i], sizeof (IPin)))
        {
            LOG((MSP_ERROR, "terminal returned bad pin. # %d", i));
            hr = E_POINTER;
            break;
        }

        PIN_INFO PinInfo;
        hr = Pins[i]->QueryPinInfo(&PinInfo);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, can't get pin info, hr=%x", __fxName, hr));
            break;
        }
        
        if (lstrcmpW(PinInfo.achName, PNAME_CAPTURE) == 0)
        {
            m_pCapturePin = Pins[i];
            
            // remember the capture filter as well.
            m_pCaptureFilter = PinInfo.pFilter;
            m_pCaptureFilter->AddRef();

        }
        else if (lstrcmpW(PinInfo.achName, PNAME_PREVIEW) == 0)
        {
            m_pPreviewPin = Pins[i];
        }
        else if (lstrcmpW(PinInfo.achName, PNAME_RTPPD) == 0)
        {
            m_pRTPPin = Pins[i];
        }
        else if (PinInfo.dir == PINDIR_OUTPUT)
        {
            // this must be the capture filter of some third party terminal.
            m_pCapturePin = Pins[i];
            
            // remember the capture filter as well.
            m_pCaptureFilter = PinInfo.pFilter;
            m_pCaptureFilter->AddRef();

        }
        else
        {
            Pins[i]->Release();
        }

        // we don't need the filter here.
        PinInfo.pFilter->Release();
    }


    // check if we have got all the pins we need.
    if (m_pCapturePin == NULL || 
        m_pPreviewPin == NULL || 
        m_pRTPPin == NULL)
    {
        if ((m_pCapturePin != NULL) 
            && (hr = ::PinSupportsMediaType(
                m_pCapturePin, __uuidof(MEDIATYPE_RTP_Single_Stream))) == S_OK)
        {
            // This terminal generates RTP directly.
            *pfDirectRTP = TRUE;
            return S_OK;
        }

        LOG((MSP_ERROR, 
            "%s, can't find all the pins, Capture:%p, Preview:%p, RTP:%P", 
            __fxName, m_pCapturePin, m_pPreviewPin, m_pRTPPin));

        hr = E_UNEXPECTED;
    }

    if (hr != S_OK)
    {
        // something is wrong, clean up
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);
        
        CleanupCachedInterface();

        return hr;
    }

    // now get the optional video interfaces.
    _ASSERT(m_pIStreamConfig == NULL);

    hr = m_pCapturePin->QueryInterface(&m_pIStreamConfig);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, "%s, queryinterface failed", __fxName));
    }

    hr = m_pCapturePin->QueryInterface(&m_pCaptureFrameRateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's IFrameRateControl failed, hr=%x", 
            __fxName, hr));
    }

    hr = m_pCapturePin->QueryInterface(&m_pCaptureBitrateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query capture pin's IBitRateControl failed, hr=%x", 
            __fxName, hr));
    }

    hr = m_pPreviewPin->QueryInterface(&m_pPreviewFrameRateControl);
    if (FAILED(hr))
    {
        LOG((MSP_WARN, 
            "%s:query preview pin's IFrameRateControl failed, hr=%x", 
            __fxName, hr));
    }

    return S_OK;
}

HRESULT CStreamVideoSend::ConnectCaptureTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:
    
    The stream needs its capture pin, preview pin,  and RTP packetization pin. 
    
    The capture pin and the preview pin are connected to the RTP sink filter 
    and the preview pin is connected to the preivew terminal. If the preview 
    terminal doesn't exist yet, the preview pin is remembered and used later
    when the preview terminal is selected.

Arguments:
    
    pITTerminal - the terminal being connected.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectCaptureTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    // Get the TerminalControl interface on the terminal
    CComPtr<ITTerminalControl> pTerminal;
    HRESULT hr = pITTerminal->QueryInterface(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't get Terminal Control interface", __fxName));
        
        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);

        return E_NOINTERFACE;
    }

    // Find the pins on the capture terminal. The pins will be stored in 
    // m_pCapturePin, m_pPreviewPin, m_pRTPPin
    BOOL fDirectRTP = FALSE;
    hr = GetVideoCapturePins(pTerminal, &fDirectRTP);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, Get capture pins failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
    
        return hr;
    }

    hr = CreateSendFilters(m_pCapturePin, m_pRTPPin, fDirectRTP);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, Create video send filters failed. hr=%x", __fxName, hr));

        goto cleanup;
    }

    //
    // Now we are actually connected. Update our state and perform 
    // postconnection.
    //
    hr = pTerminal->CompleteConnectTerminal();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, Create video send filters failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

        goto cleanup;

    }

    if (m_pPreviewTerminal != NULL)
    {
        // errors will be fired as events.
        ConnectPreviewTerminal(m_pPreviewTerminal);
    }

    return S_OK;

cleanup:
    // disconnect the terminal.
    pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

    CleanupCachedInterface();
    
    // clean up internal filters as well.
    CleanUpFilters();

    return hr;
}

HRESULT CStreamVideoSend::ConnectPreviewTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:
    
    If the capture terminal has been connected, this function connects the
    capture terminal's preview pin with the preview terminal. Otherwise, the
    preview terminal is just remembered and wait for the capture terminal.

Arguments:
    
    pITTerminal - the terminal being connected.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectPreviewTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    if (!m_pCapturePin)
    {
        LOG ((MSP_TRACE, "%s capture pin is null.", __fxName));
        return E_FAIL;
    }

    if (!m_pPreviewPin)
    {
        // the capture terminal is not selected yet. We will just wait.
        LOG((MSP_TRACE, "%s, capture is not ready yet.", __fxName));
        return S_OK;
    }

    // Get the TerminalControl interface on the terminal
    CComPtr<ITTerminalControl> pTerminal;
    HRESULT hr = pITTerminal->QueryInterface(&pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't get Terminal Control interface", __fxName));
        
        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, E_NOINTERFACE, pITTerminal);

        return E_NOINTERFACE;
    }

    // find the input pin on the preview window.
    CComPtr<IPin>   pPreviewInputPin;

    hr = FindPreviewInputPin(pTerminal, &pPreviewInputPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, find preview input pin failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

        return hr;
    }

    // connect the pins together.
    hr = m_pIGraphBuilder->Connect(m_pPreviewPin, pPreviewInputPin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, connect preview pins failed. hr=%x", __fxName, hr));
        return hr;
    }

    //
    // Now we are actually connected, perform postconnection.
    //
    hr = pTerminal->CompleteConnectTerminal();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, complete connect terminal failed. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);

        // disconnect the terminal.
        pTerminal->DisconnectTerminal(m_pIGraphBuilder, 0);

        return hr;
    }

    return S_OK;
}

HRESULT CStreamVideoSend::ConnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    connect the video terminals to the stream.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    // Find out the direction of the terminal.
    TERMINAL_DIRECTION Direction;
    HRESULT hr = pITTerminal->get_Direction(&Direction);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't get terminal direction. hr=%x", __fxName, hr));

        SendStreamEvent(CALL_TERMINAL_FAIL, 
            CALL_CAUSE_BAD_DEVICE, hr, pITTerminal);
    
        return hr;
    }

    if (Direction != TD_RENDER)
    {
        hr = ConnectCaptureTerminal(pITTerminal);

        if (SUCCEEDED(hr))
        {
            // save the capture terminal.
            _ASSERT(m_pCaptureTerminal == NULL);

            m_pCaptureTerminal = pITTerminal;
            m_pCaptureTerminal->AddRef();
        }
    }
    else
    {
        hr = ConnectPreviewTerminal(pITTerminal);

        if (SUCCEEDED(hr))
        {
            // save the preview terminal.
            _ASSERT(m_pPreviewTerminal == NULL);

            m_pPreviewTerminal = pITTerminal;
            m_pPreviewTerminal->AddRef();
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::DisconnectTerminal(
    IN  ITTerminal *   pITTerminal
    )
/*++

Routine Description:

    Disconnect a terminal. It will remove its filters from the graph and
    also release its references to the graph.

    If it is the capture terminal being disconnected, all the pins that the 
    stream cached need to be released too. 

Arguments:
    
    pITTerminal - the terminal.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::DisconnectTerminal");
    LOG((MSP_TRACE, "%s enters, pITTerminal:%p", __fxName, pITTerminal));

    HRESULT hr = CIPConfMSPStream::DisconnectTerminal(pITTerminal);

    if (pITTerminal == m_pCaptureTerminal)
    {
        // release all the capture pins we cached.
        CleanupCachedInterface();
    
        m_pCaptureTerminal->Release();
        m_pCaptureTerminal = NULL;

        CleanUpFilters ();

        // disconnect preview term as well
        // when we connect capture,
        // we always try to connect preview if one is available

        if (m_pPreviewTerminal)
        {
            CIPConfMSPStream::DisconnectTerminal(m_pPreviewTerminal);
        }
    }
    else if (pITTerminal == m_pPreviewTerminal)
    {
        m_pPreviewTerminal->Release();
        m_pPreviewTerminal = NULL;
    }


    return hr;
}

HRESULT CStreamVideoSend::ConnectRTPFilter(
    IN  IGraphBuilder *pIGraphBuilder,
    IN  IPin          *pCapturePin,
    IN  IPin          *pRTPPin,
    IN  IBaseFilter   *pRTPFilter
    )
{
    ENTER_FUNCTION("CStreamVideoSend::ConnectRTPFilters");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    // find the capture pin on the RTP filter.
    CComPtr <IPin> pRTPCapturePin; 
    hr = pRTPFilter->FindPin(PNAME_CAPTURE, &pRTPCapturePin);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, find capture pin on rtp filter. %x", __fxName, hr));
        return hr;
    }

    // Connect the capture pin of the video capture filter with the capture pin
    // of the rTP filter.
    hr = pIGraphBuilder->ConnectDirect(pCapturePin, pRTPCapturePin, NULL);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "%s, can't connect capture pins. %x", __fxName, hr));
        return hr;
    }

    if (pRTPPin)
    {
        // find the packetization pin on the RTP filter.
        CComPtr <IPin> pRTPRTPPin; 
        hr = pRTPFilter->FindPin(PNAME_RTPPD, &pRTPRTPPin);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "%s, find capture pin on rtp filter. %x", __fxName, hr));

            pIGraphBuilder->Disconnect(pRTPPin);

            return hr;
        }

        // Connect the RTP pin of the video capture filter with the RTP pin
        // of the rTP filter.
        hr = pIGraphBuilder->ConnectDirect(pRTPPin, pRTPRTPPin, NULL);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, 
                "%s, can't connect capture pins. %x", __fxName, hr));

            pIGraphBuilder->Disconnect(pRTPPin);

            return hr;
        }
    }

    return hr;
}

HRESULT CStreamVideoSend::ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    )
/*++

Routine Description:

    Configure the RTP filter with RTP<-->AM media type mappings.

Arguments:
    
    pIRTPFilter - The source RTP Filter.

    pIStreamConfig - The stream config interface that has the media info.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("VideoSend::ConfigureRTPFormats");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    CComPtr<IRtpMediaControl> pIRtpMediaControl;
    hr = pIRTPFilter->QueryInterface(&pIRtpMediaControl);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s adding source filter. %x", __fxName, hr));
        return hr;
    }

    // find the number of capabilities supported.
    DWORD dwCount;
    hr = pIStreamConfig->GetNumberOfCapabilities(&dwCount);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "%s GetNumberOfCapabilities. %x", __fxName, hr));
        return hr;
    }

    BOOL fFound = FALSE;
    BOOL fFormatSet = FALSE;

    for (DWORD dw = 0; dw < dwCount; dw ++)
    {
        // TODO, a new interface is needed to resolve RTP to MediaType.
        AM_MEDIA_TYPE *pMediaType;
        DWORD dwPayloadType;

        hr = pIStreamConfig->GetStreamCaps(
            dw, &pMediaType, NULL, &dwPayloadType
            );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s GetStreamCaps. %x", __fxName, hr));
            return hr;
        }

        BITMAPINFOHEADER *pHeader = HEADER(pMediaType->pbFormat);
        if (pHeader == NULL)
        {
            MSPDeleteMediaType(pMediaType);
            continue;
        }

        // check the image size
        if (m_Settings.fCIF)
        {
            if (pHeader->biWidth != CIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        else
        {
            if (pHeader->biWidth != QCIFWIDTH)
            {
                MSPDeleteMediaType(pMediaType);
                continue;
            }
        }
        
        for (DWORD dw2 = 0; dw2 < m_Settings.dwNumPayloadTypes; dw2 ++)
        {
            if (dwPayloadType == m_Settings.PayloadTypes[dw2])
            {
                hr = pIRtpMediaControl->SetFormatMapping(
                    dwPayloadType,
                    90000,      // default video clock rate.
                    pMediaType
                    );

                if (FAILED(hr))
                {
                    MSPDeleteMediaType(pMediaType);

                    LOG((MSP_ERROR, "%s SetFormatMapping. %x", __fxName, hr));
                    return hr;
                }
                else
                {
                    LOG((MSP_INFO, "%s Configured payload:%d", __fxName, dwPayloadType));
                }

                if (dw2 == 0 && !fFormatSet)
                {
                // tell the encoder to use this format.
                // TODO, cache all the allowed mediatypes in the conference for
                // future enumerations. It would be nice that we can get the SDP blob
                // when the call object is created.
                    hr = pIStreamConfig->SetFormat(dwPayloadType, pMediaType);
                    if (FAILED(hr))
                    {
                        MSPDeleteMediaType(pMediaType);

                        LOG((MSP_ERROR, "%s SetFormat. %x", __fxName, hr));
                        return hr;
                    }
                    fFormatSet = TRUE;
                }
            }
        }
        MSPDeleteMediaType(pMediaType);
    }

    return S_OK;
}

HRESULT CStreamVideoSend::CreateSendFilters(
    IN   IPin          *pCapturePin,
    IN   IPin          *pRTPPin,
    IN   BOOL           fDirectRTP
    )
/*++

Routine Description:

    Insert filters into the graph and connect to the capture pin.

    Capturepin->[Encoder]->RTPRender
 
Arguments:
    
    pCapturePin - the capture pin on the capture filter.

    pRTPPin - the RTP packetization pin.

    fDirectRTP - the capture pin supports RTP directly.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::CreateSendFilters");
    LOG((MSP_TRACE, "%s enters", __fxName));

    HRESULT hr;

    // Create the RTP render filter and add it into the graph.
    CComPtr<IBaseFilter> pRenderFilter;

    if (m_pIRTPSession == NULL)
    {
        if (FAILED(hr = ::AddFilter(
                m_pIGraphBuilder,
                __uuidof(MSRTPRenderFilter), 
                L"RtpRender", 
                &pRenderFilter)))
        {
            LOG((MSP_ERROR, "%s, adding render filter. hr=%x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = ConfigureRTPFilter(pRenderFilter)))
        {
            LOG((MSP_ERROR, "%s, configure RTP render filter failed. %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        if (FAILED (hr = m_pIRTPSession->QueryInterface (&pRenderFilter)))
        {
            LOG ((MSP_ERROR, "%s failed to get filter from rtp session. %x", __fxName, hr));
            return hr;
        }

        if (FAILED (hr = m_pIGraphBuilder->AddFilter ((IBaseFilter *)pRenderFilter, L"RtpRender")))
        {
            LOG ((MSP_ERROR, "%s failed to add filter to graph. %x", __fxName, hr));
            return hr;
        }
    }

    if (!fDirectRTP)
    {
        CComPtr<IStreamConfig> pIStreamConfig;
        hr = pCapturePin->QueryInterface(&pIStreamConfig);
        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "%s, query IStreamConfig. %x", __fxName, hr));
            return hr;
        }

        // configure the format info on the RTP filter
        if (FAILED(hr = ConfigureRTPFormats(pRenderFilter, pIStreamConfig)))
        {
            LOG((MSP_ERROR, "%s, configure RTP formats. %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        // configure RTP_SINGLE_STREAM to on the RTP filter.
    }

    if (FAILED(hr = ConnectRTPFilter(
        m_pIGraphBuilder,
        pCapturePin, 
        pRTPPin,
        pRenderFilter
        )))
    {
        LOG((MSP_ERROR, 
            "%s, connect capture pin and the Render filter. %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

//    
// IInnerStreamQualityControl methods.
//
STDMETHODIMP CStreamVideoSend::GetRange(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plMin, 
    OUT LONG *plMax, 
    OUT LONG *plSteppingDelta, 
    OUT LONG *plDefault, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the range for a quality control property. Delegated to capture filter
    for now.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::GetRange (InnerStreamQualityControl)");

    HRESULT hr;
    static BOOL fReported = FALSE;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MinFrameInterval:
        
        if (m_pCaptureFrameRateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureFrameRateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureFrameRateControl->GetRange(
                FrameRateControl_Maximum, plMin, plMax, plSteppingDelta, plDefault, plFlags
                );
        }

        break;

    case InnerStreamQuality_AvgFrameInterval:
        
        if (m_pCaptureFrameRateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureFrameRateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureFrameRateControl->GetRange(
                FrameRateControl_Current, plMin, plMax, plSteppingDelta, plDefault, plFlags
                );
        }

        break;

    case InnerStreamQuality_MaxBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->GetRange(
                BitrateControl_Maximum, plMin, plMax, plSteppingDelta, plDefault, plFlags, LAYERID
                );

                    if (S_OK == hr)
            {
                if (*plMax < QCLIMIT_MIN_BITRATE)
                {
                    LOG ((MSP_WARN, "%s: max bitrate %d too low", __fxName, *plMax));
                    hr = E_UNEXPECTED;
                }
                else
                {
                    // adjust the min and default value
                    if (*plMin < QCLIMIT_MIN_BITRATE)
                        *plMin = QCLIMIT_MIN_BITRATE;
                    if (*plDefault < QCLIMIT_MIN_BITRATE)
                        *plDefault = QCLIMIT_MIN_BITRATE;
                }
            }
        }

        break;

    case InnerStreamQuality_CurrBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->GetRange(
                BitrateControl_Current, plMin, plMax, plSteppingDelta, plDefault, plFlags, LAYERID
                );

            if (S_OK == hr)
            {
                if (*plMax < QCLIMIT_MIN_BITRATE)
                {
                    LOG ((MSP_WARN, "%s: max bitrate %d too low", __fxName, *plMax));
                    hr = E_UNEXPECTED;
                }
                else
                {
                    // adjust the min and default value
                    if (*plMin < QCLIMIT_MIN_BITRATE)
                        *plMin = QCLIMIT_MIN_BITRATE;
                    if (*plDefault < QCLIMIT_MIN_BITRATE)
                        *plDefault = QCLIMIT_MIN_BITRATE;
                }
            }
        }

        break;

    default:
        hr = CIPConfMSPStream::GetRange (property, plMin, plMax, plSteppingDelta, plDefault, plFlags);
        break;
    }

    return hr;
}

STDMETHODIMP CStreamVideoSend::Get(
    IN  InnerStreamQualityProperty property, 
    OUT LONG *plValue, 
    OUT TAPIControlFlags *plFlags
    )
/*++

Routine Description:
    
    Get the value for a quality control property. Delegated to the quality 
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::Get(QualityControl)");

    HRESULT hr;
    static BOOL fReported = FALSE;

    CLock lock(m_lock);

    switch (property)
    {
    case InnerStreamQuality_MinFrameInterval:
        
        if (m_pCaptureFrameRateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureFrameRateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureFrameRateControl->Get(FrameRateControl_Maximum, plValue, plFlags);
        }

        break;

    case InnerStreamQuality_AvgFrameInterval:
        
        if (m_pCaptureFrameRateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureFrameRateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureFrameRateControl->Get(FrameRateControl_Current, plValue, plFlags);
        }

        break;

    case InnerStreamQuality_MaxBitrate:

        if( m_pCaptureBitrateControl == NULL )
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pICaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->Get(BitrateControl_Maximum, plValue, plFlags, LAYERID);
        }

        break;

    case InnerStreamQuality_CurrBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, m_pCaptureBitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
        }
        else
        {
            hr = m_pCaptureBitrateControl->Get(BitrateControl_Current, plValue, plFlags, LAYERID);
        }
        break;

    default:
        hr = CIPConfMSPStream::Get (property, plValue, plFlags);
        break;
    }

    return hr;
}

STDMETHODIMP CStreamVideoSend::Set(
    IN  InnerStreamQualityProperty property,
    IN  LONG lValue, 
    IN  TAPIControlFlags lFlags
    )
/*++

Routine Description:
    
    Set the value for a quality control property. Delegated to the quality
    controller.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CStreamVideoSend::Set(InnerStreamQualityControl)");

    CLock lock(m_lock);

    HRESULT hr;
    LONG l;
    static BOOL fReported = FALSE;

    LONG min, max, delta, Default;
    TAPIControlFlags flags;

    switch (property)
    {
       // adjusted frame rate by call qc
    case InnerStreamQuality_AdjMinFrameInterval:
        
        if (m_pCaptureFrameRateControl == NULL &&
            m_pPreviewFrameRateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, Capture/Preview FrameRateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
            break;
        }

        // set capture frame rate control
        if (m_pCaptureFrameRateControl)
        {
            // get valid range
            if (FAILED (hr = m_pCaptureFrameRateControl->GetRange (
                            FrameRateControl_Current,
                            &min, &max, &delta, &Default, &flags)))
            {
                LOG ((MSP_ERROR, "%s failed to getrange on capture frame rate control. %x", __fxName, hr));
            }
            else
            {
                // adjust value
                l = lValue;
                // use current value - max - if input value not set
                if (l==QCDEFAULT_QUALITY_UNSET) l = max;
                else if (l<min) l = min;
                else if (l>max) l = max;

                // remember the value
                m_pStreamQCRelay->Set (property, l, lFlags);

                if (FAILED (hr = m_pCaptureFrameRateControl->Set(FrameRateControl_Maximum, l, lFlags)))
                {
                    LOG ((MSP_ERROR, "%s failed to set on capture frame rate control. value %d, hr %x", __fxName, l, hr));
                }
            }
        }

        // set Preview frame rate control
        if (m_pPreviewFrameRateControl)
        {
            // get valid range
            if (FAILED (hr = m_pPreviewFrameRateControl->GetRange (
                            FrameRateControl_Current,
                            &min, &max, &delta, &Default, &flags)))
            {
                LOG ((MSP_ERROR, "%s failed to getrange on Preview frame rate control. %x", __fxName, hr));
            }
            else
            {
                // adjust value
                l = lValue;
                // use current value - max - if input value not set
                if (l==QCDEFAULT_QUALITY_UNSET) l = max;
                else if (l<min) l = min;
                else if (l>max) l = max;

                // remember the value
                m_pStreamQCRelay->Set (property, l, lFlags);

                if (FAILED (hr = m_pPreviewFrameRateControl->Set(FrameRateControl_Maximum, l, lFlags)))
                {
                    LOG ((MSP_ERROR, "%s failed to set on Preview frame rate control. value %d, hr %x", __fxName, l, hr));
                }
            }
        }

        break;

        // adjusted bitrate by call qc
    case InnerStreamQuality_AdjMaxBitrate:

        if (m_pCaptureBitrateControl == NULL)
        {
            if (!fReported)
            {
                LOG((MSP_WARN, "%s, Capture BitrateControl is NULL", __fxName));
                fReported = TRUE;
            }
            hr = E_NOTIMPL;
            break;
        }

        // set capture bitrate control
        if (m_pCaptureBitrateControl)
        {
            // get valid range
            if (FAILED (hr = m_pCaptureBitrateControl->GetRange (
                            BitrateControl_Current,
                            &min, &max, &delta, &Default, &flags, LAYERID)))
            {
                LOG ((MSP_ERROR, "%s failed to getrange on capture bitrate control. %x", __fxName, hr));
            }
            else
            {
                // adjust value
                l = lValue;
                if (!m_pStreamQCRelay->m_fQOSAllowedToSend)
                    if (l > QCLIMIT_MAX_QOSNOTALLOWEDTOSEND)
                        l = QCLIMIT_MAX_QOSNOTALLOWEDTOSEND;
                // use current value - max - if input value not set
                if (l==QCDEFAULT_QUALITY_UNSET) l = max;
                else if (l<min) l = min;
                else if (l>max) l = max;

                // remember the value
                m_pStreamQCRelay->Set (property, l, lFlags);

                if (FAILED (hr = m_pCaptureBitrateControl->Set(BitrateControl_Maximum, l, lFlags, LAYERID)))
                {
                    LOG ((MSP_ERROR, "%s failed to set on capture bit rate control. value %d, hr %x", __fxName, l, hr));
                }
            }
        }

        break;

    case InnerStreamQuality_PrefMaxBitrate:

        // check input value
        if (m_pCaptureBitrateControl)
        {
            // get valid range
            if (FAILED (hr = m_pCaptureBitrateControl->GetRange (
                            BitrateControl_Current,
                            &min, &max, &delta, &Default, &flags, LAYERID)))
            {
                LOG ((MSP_ERROR, "%s failed to getrange on capture bitrate control. %x", __fxName, hr));
            }
            else
            {
                if (lValue < min || lValue > max)
                    return E_INVALIDARG;
            }
        }
        else
        {
            LOG((MSP_WARN, "%s no bitratecontrol to check bitrate input.", __fxName));
        }

        hr = CIPConfMSPStream::Set (property, lValue, lFlags);

        break;

    case InnerStreamQuality_PrefMinFrameInterval:

        // check input value
        if (m_pCaptureFrameRateControl)
        {
            // get valid range
            if (FAILED (hr = m_pCaptureFrameRateControl->GetRange (
                            FrameRateControl_Current,
                            &min, &max, &delta, &Default, &flags)))
            {
                LOG ((MSP_ERROR, "%s failed to getrange on capture frame rate control. %x", __fxName, hr));
            }
            else
            {
                if (lValue < min || lValue > max)
                    return E_INVALIDARG;
            }
        }
        else
        {
            LOG((MSP_WARN, "%s no framerate cntl to check input.", __fxName));
        }

        hr = CIPConfMSPStream::Set (property, lValue, lFlags);

        break;

    default:
        hr = CIPConfMSPStream::Set (property, lValue, lFlags);
        break;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//  CSubStreamVideoRecv
//
/////////////////////////////////////////////////////////////////////////////

CSubStreamVideoRecv::CSubStreamVideoRecv()
    : m_pFTM(NULL),
      m_pStream(NULL),
      m_pCurrentParticipant(NULL)
{
}

// methods called by the videorecv object.
HRESULT CSubStreamVideoRecv::Init(
    IN  CStreamVideoRecv *       pStream
    )
/*++

Routine Description:

    Initialize the substream object.

Arguments:
    
    pStream - The pointer to the stream that owns this substream.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "CSubStreamVideoRecv::Init, pStream %p", pStream));

    // This method is called only once when the object is created. No other
    // method will be called until this function succeeds. No need to lock.
    _ASSERTE(m_pStream == NULL);

    // initialize the terminal array so that the array is not NULL. Used for
    // generating an empty enumerator if no terminal is selected.
    if (!m_Terminals.Grow())
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::Init - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }
    
    // create the marshaler.
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    // save the stream reference.
    m_pStream = pStream;
    (pStream->GetControllingUnknown())->AddRef();

    LOG((MSP_TRACE, "CSubStreamVideoRecv::Init returns S_OK"));

    return S_OK;
}

#ifdef DEBUG_REFCOUNT
ULONG CSubStreamVideoRecv::InternalAddRef()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalAddRef();
    
    LOG((MSP_TRACE, "SubStreamVideoRecv %p Addref, ref = %d", this, lRef));

    return lRef;
}

ULONG CSubStreamVideoRecv::InternalRelease()
{
    ULONG lRef = CComObjectRootEx<CComMultiThreadModelNoCS>::InternalRelease();
    
    LOG((MSP_TRACE, "SubStreamVideoRecv %p Release, ref = %d", this, lRef));

    return lRef;
}
#endif

void CSubStreamVideoRecv::FinalRelease()
/*++

Routine Description:

    release everything before being deleted. 

Arguments:
    
Return Value:

--*/
{
    LOG((MSP_TRACE, "CSubStreamVideoRecv::FinalRelease - enter"));

    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->Release();
    }

    for ( int i = 0; i < m_Terminals.GetSize(); i ++ )
    {
        m_Terminals[i]->Release();
    }
    m_Terminals.RemoveAll(); 

    if (m_pStream)
    {
        (m_pStream->GetControllingUnknown())->Release();
    }

    if (m_pFTM)
    {
        m_pFTM->Release();
    }

    LOG((MSP_TRACE, "CSubStreamVideoRecv::FinalRelease - exit"));
}

STDMETHODIMP CSubStreamVideoRecv::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

    Select a terminal on this substream. This method calls the same method
    on the stream object to handle that.

Arguments:
    pTerminal - the terminal to be selected.
  
Return Value:

--*/
{
    LOG((MSP_TRACE, 
        "CSubStreamVideoRecv::SelectTerminal, pTerminal %p", pTerminal));

    HRESULT hr;
    
    m_lock.Lock();
    if (m_Terminals.GetSize() > 0)
    {
        m_lock.Unlock();
        return TAPI_E_MAXTERMINALS;
    }

    BOOL bFlag = m_Terminals.Add(pTerminal);

    _ASSERTE(bFlag);

    m_lock.Unlock();

    if (!bFlag)
    {
        return E_OUTOFMEMORY;
    }

    // This is the refcount for the pointer in m_Terminals.
    pTerminal->AddRef();

    // Call the stream's select terminal to handle the state changes and also
    // make sure that locking happens only from the stream to substream.
    hr = m_pStream->SubStreamSelectTerminal(this, pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CSubStreamVideoRecv::SelectTerminal failed, hr:%x", hr));
    
        m_lock.Lock();

        m_Terminals.Remove(pTerminal);
        pTerminal->Release();
        
        m_lock.Unlock();

    }
    return hr;
}

STDMETHODIMP CSubStreamVideoRecv::UnselectTerminal(
    IN     ITTerminal *             pTerminal
    )
/*++

Routine Description:

    Unselect a terminal on this substream. This method calls the same method
    on the stream object to handle that.

Arguments:
    pTerminal - the terminal to be unselected.
  
Return Value:

--*/
{
    LOG((MSP_TRACE, 
        "CSubStreamVideoRecv::UnSelectTerminal, pTerminal %p", pTerminal));

    m_lock.Lock();
    if (!m_Terminals.Remove(pTerminal))
    {
        m_lock.Unlock();
        LOG((MSP_ERROR, "SubStreamVideoRecv::UnselectTerminal, invalid terminal."));

        return TAPI_E_INVALIDTERMINAL;
    }
    pTerminal->Release();

    m_lock.Unlock();

    HRESULT hr;
    
    // Call the stream's unselect terminal to handle the state changes and also
    // make sure that locking happens only from the stream to substream.
    hr = m_pStream->UnselectTerminal(pTerminal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CSubStreamVideoRecv::UnSelectTerminal failed, hr:%x", hr));
    }
    return hr;
}

STDMETHODIMP CSubStreamVideoRecv::EnumerateTerminals(
    OUT     IEnumTerminal **        ppEnumTerminal
    )
{
    LOG((MSP_TRACE, 
        "EnumerateTerminals entered. ppEnumTerminal:%x", ppEnumTerminal));

    if (IsBadWritePtr(ppEnumTerminal, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppEnumTerminal is a bad pointer"));
        return E_POINTER;
    }

    // acquire the lock before accessing the Terminal object list.
    CLock lock(m_lock);

    if (m_Terminals.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::EnumerateTerminals - "
            "stream appears to have been shut down - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    typedef _CopyInterface<ITTerminal> CCopy;
    typedef CSafeComEnum<IEnumTerminal, &__uuidof(IEnumTerminal), 
                ITTerminal *, CCopy> CEnumerator;

    HRESULT hr;

    CMSPComObject<CEnumerator> *pEnum = NULL;

    hr = ::CreateCComObjectInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    // query for the __uuidof(IEnumTerminal) i/f
    IEnumTerminal *        pEnumTerminal;
    hr = pEnum->_InternalQueryInterface(__uuidof(IEnumTerminal), (void**)&pEnumTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    // The CSafeComEnum can handle zero-sized array.
    hr = pEnum->Init(
        m_Terminals.GetData(),                        // the begin itor
        m_Terminals.GetData() + m_Terminals.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        pEnumTerminal->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CSubStreamVideoRecv::EnumerateTerminals - exit S_OK"));

    *ppEnumTerminal = pEnumTerminal;

    return hr;
}

STDMETHODIMP CSubStreamVideoRecv::get_Terminals(
    OUT     VARIANT *               pVariant
    )
{
    LOG((MSP_TRACE, "CSubStreamVideoRecv::get_Terminals - enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this stream has been shut down. Acquire the lock before accessing
    // the terminal object list.
    //

    CLock lock(m_lock);

    if (m_Terminals.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "stream appears to have been shut down - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }


    //
    // create the collection object - see mspcoll.h
    //

    HRESULT hr;
    typedef CTapiIfCollection< ITTerminal * > TerminalCollection;
    CComObject<TerminalCollection> * pCollection;

    hr = ::CreateCComObjectInstance(&pCollection);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_Terminals.GetSize(),
                                  m_Terminals.GetData(),
                                  m_Terminals.GetData() + m_Terminals.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "CSubStreamVideoRecv::get_Terminals - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CSubStreamVideoRecv::get_Terminals - exit S_OK"));
 
    return S_OK;
}

STDMETHODIMP CSubStreamVideoRecv::get_Stream (
    OUT     ITStream **             ppITStream
    )
{
    LOG((MSP_TRACE, 
        "VideoRecvSubStream.get_Stream, ppITStream %x", ppITStream));
 
    if (IsBadWritePtr(ppITStream, sizeof (VOID *)))
    {
        LOG((MSP_ERROR, "Bad pointer, ppITStream:%x",ppITStream));
        return E_POINTER;
    }

    ITStream *  pITStream;
    HRESULT hr = m_pStream->_InternalQueryInterface(
        __uuidof(ITStream), 
        (void **)&pITStream
    );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_Stream:QueryInterface failed: %x", hr));
        return hr;
    }

    *ppITStream = pITStream;

    return S_OK;
}

STDMETHODIMP CSubStreamVideoRecv::StartSubStream()
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CSubStreamVideoRecv::PauseSubStream()
{
    return TAPI_E_NOTSUPPORTED;
}

STDMETHODIMP CSubStreamVideoRecv::StopSubStream()
{
    return TAPI_E_NOTSUPPORTED;
}

BOOL CSubStreamVideoRecv::GetCurrentParticipant(
    DWORD * pdwSSRC,
    ITParticipant** ppITParticipant 
    )
{
    CLock lock(m_lock);
    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->AddRef();
        *ppITParticipant = m_pCurrentParticipant;
        
        ((CParticipant *)m_pCurrentParticipant)->GetSSRC(
            (ITStream*)m_pStream,
            pdwSSRC
            );

        return TRUE;
    }  
    return FALSE;
}

VOID CSubStreamVideoRecv::SetCurrentParticipant(
    DWORD dwSSRC,
    ITParticipant * pParticipant
    )
{
    CLock lock(m_lock);
    
    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->Release();
    }

    m_pCurrentParticipant = pParticipant;

    if (m_pCurrentParticipant)
    {
        m_pCurrentParticipant->AddRef();
    }
}

BOOL CSubStreamVideoRecv::ClearCurrentTerminal()
{
    CLock lock(m_lock);

    if (m_Terminals.GetSize() > 0)
    {
        m_Terminals[0]->Release();
        m_Terminals.RemoveAt(0);

        return TRUE;
    }
    
    return FALSE;
}

BOOL CSubStreamVideoRecv::SetCurrentTerminal(ITTerminal * pTerminal)
{
    CLock lock(m_lock);
    
    if (m_Terminals.GetSize() > 0)
    {
        _ASSERTE(FALSE);
        return FALSE;
    }

    BOOL bFlag = m_Terminals.Add(pTerminal);

    // This should never fail since the terminal array has been grown
    // at the init time.
    _ASSERTE(bFlag);

    if (bFlag)
    {
        pTerminal->AddRef();
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confutil.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    MSPCall.h

Abstract:

    Definitions for MSP utililty functions. There are all related to 
    active movie filter manipulation.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __MSPUTIL_H
#define __MSPUTIL_H

const DWORD PAYLOAD_G711U   = 0;
const DWORD PAYLOAD_G721    = 2;
const DWORD PAYLOAD_GSM     = 3;
const DWORD PAYLOAD_G723    = 4;
const DWORD PAYLOAD_DVI4_8  = 5;
const DWORD PAYLOAD_DVI4_16 = 6;
const DWORD PAYLOAD_G711A   = 8;
const DWORD PAYLOAD_MSAUDIO = 66;
const DWORD PAYLOAD_H261    = 31;
const DWORD PAYLOAD_H263    = 34;

const WCHAR gszMSPLoopback[] = L"Loopback";
const WCHAR gszAEC[] = L"AEC";
const WCHAR gszNumVideoCaptureBuffers[] = L"NumVideoCaptureBuffers";

const TCHAR gszSDPMSPKey[]   =
   _T("Software\\Microsoft\\Windows\\CurrentVersion\\IPConfMSP\\");

BOOL
IsPayloadSupported(IN DWORD dwPT);

HRESULT
FindPin(
    IN  IBaseFilter *   pIFilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE
    );

HRESULT
PinSupportsMediaType(
    IN IPin *           pIPin,
    IN const GUID &     MediaType
    );

HRESULT
AddFilter(
    IN  IGraphBuilder *     pIGraph,
    IN  const CLSID &       Clsid,
    IN  LPCWSTR             pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    );

HRESULT
SetLoopbackOption(
    IN IBaseFilter *pIBaseFilter,
    IN MULTICAST_LOOPBACK_MODE  LoopbackMode
    );

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBitRate,
    IN BOOL             bFailIfNoQOS,
    IN BOOL             bReceive = FALSE,
    IN DWORD            dwNumStreams = 1,
    IN BOOL             bCIF = FALSE
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter1, 
    IN IBaseFilter *    pIFilter2,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pIFilter,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pIFilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter
    );

void WINAPI MSPDeleteMediaType(AM_MEDIA_TYPE *pmt);


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    );

HRESULT
FindACMAudioCodec(
    IN DWORD dwPayloadType,
    OUT IBaseFilter **ppIBaseFilter
    );

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    );

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    );

template <class T>
HRESULT CreateCComObjectInstance (
    CComObject<T> **ppObject
    )
/*++

Create a new CComObject instance. Use try/except to catch exception.

--*/
{
    HRESULT hr;

    __try
    {
        hr = CComObject<T>::CreateInstance(ppObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *ppObject = NULL;
        return E_OUTOFMEMORY;
    }

    return hr;
}

inline DWORD FindSampleRate(AM_MEDIA_TYPE *pMediaType)
{
    _ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (pMediaType->majortype == MEDIATYPE_Audio &&
            pMediaType->formattype == FORMAT_WaveFormatEx &&
            pMediaType->pbFormat != NULL &&
            pMediaType->cbFormat != 0)
    {
        WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;
        return pWaveFormatEx->nSamplesPerSec;
    }

    return 90000;      // default media clock rate, including video.
}

class ATL_NO_VTABLE CMSPStreamClock : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IReferenceClock
{
private:
    LONGLONG         m_lPerfFrequency;
    union {
        LONGLONG         m_lRtpRefTime;
        DWORD            m_dwRtpRefTime;
    };

public:

BEGIN_COM_MAP(CMSPStreamClock)
    COM_INTERFACE_ENTRY(IReferenceClock)
END_COM_MAP()

    void InitReferenceTime(void);

    HRESULT GetTimeOfDay(OUT REFERENCE_TIME *pTime);

    CMSPStreamClock()
    {
        InitReferenceTime();
    }

    STDMETHOD (GetTime) (
            OUT REFERENCE_TIME *pTime
        )
    {
        return(GetTimeOfDay(pTime));
    }

    STDMETHOD (AdviseTime) (
        IN REFERENCE_TIME baseTime,        // base reference time
        IN REFERENCE_TIME streamTime,      // stream offset time
        IN HEVENT hEvent,                  // advise via this event
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdviseTime is called");
        return E_NOTIMPL;
    }

    STDMETHOD (AdvisePeriodic) (
        IN REFERENCE_TIME StartTime,       // starting at this time
        IN REFERENCE_TIME PeriodTime,      // time between notifications
        IN HSEMAPHORE hSemaphore,          // advise via a semaphore
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdvisePeriodic is called");
        return E_NOTIMPL;
    }

    STDMETHOD (Unadvise) (
        IN DWORD_PTR dwAdviseCookie
        )
    {
        _ASSERT(!"Unadvise is called");
        return E_NOTIMPL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\confvid.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confvid.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFVID_H_
#define __CONFVID_H_

// if there is no data for five senconds, the pin can be reused.
const DWORD g_dwVideoPinTimeOut     = 5000; 

const DWORD g_dwVideoThreadPriority = THREAD_PRIORITY_NORMAL;
const DWORD g_dwVideoChannels       = 20;  
const BOOL  g_fCIF                  = FALSE;  
const DWORD g_dwVideoSampleRate     = 7;  

const int CIFWIDTH      = 0x160;
const int CIFHEIGHT     = 0x120;

const int QCIFWIDTH     = 0xb0;
const int QCIFHEIGHT    = 0x90;

const DWORD LAYERID = 0;

typedef struct _PINMAPEVENT
{
    IPin *  pIPin;
    DWORD   dwSSRC;

} PINMAPEVENT;

// This data structure keeps the information for on brach of filters off one
// demux output pin.
typedef struct _BRANCH
{
    IPin *          pIPin;
    DWORD           dwSSRC;
    IBaseFilter *   pCodecFilter;
    ITTerminal *    pITTerminal;
    ITSubStream *   pITSubStream;
    IBitrateControl *pBitrateControl;

} BRANCH;

class ATL_NO_VTABLE CStreamVideoRecv : 
    public CIPConfMSPStream,
    public IDispatchImpl<ITSubStreamControl, 
        &__uuidof(ITSubStreamControl), &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITParticipantSubStreamControl, 
        &__uuidof(ITParticipantSubStreamControl), &LIBID_IPConfMSPLib>
    {
public:
    CStreamVideoRecv();

BEGIN_COM_MAP(CStreamVideoRecv)
    COM_INTERFACE_ENTRY(ITSubStreamControl)
    COM_INTERFACE_ENTRY(ITParticipantSubStreamControl)
    COM_INTERFACE_ENTRY2(IDispatch, ITStream)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfMSPStream)
END_COM_MAP()

// ITStream
    STDMETHOD (StopStream) ();

// ITSubStreamControl methods, called by the app.
    STDMETHOD (CreateSubStream) (
        IN OUT  ITSubStream **         ppSubStream
        );
    
    STDMETHOD (RemoveSubStream) (
        IN      ITSubStream *          pSubStream
        );

    STDMETHOD (EnumerateSubStreams) (
        OUT     IEnumSubStream **      ppEnumSubStream
        );

    STDMETHOD (get_SubStreams) (
        OUT     VARIANT *              pSubStreams
        );

// ITParticipantSubStreamControl methods, called by the app.
    STDMETHOD (get_SubStreamFromParticipant) (
        IN  ITParticipant * pITParticipant,
        OUT ITSubStream ** ppITSubStream
        );

    STDMETHOD (get_ParticipantFromSubStream) (
        IN  ITSubStream * pITSubStream,
        OUT ITParticipant ** ppITParticipant 
        );

    STDMETHOD (SwitchTerminalToSubStream) (
        IN  ITTerminal * pITTerminal,
        IN  ITSubStream * pITSubStream
        );

// method called by the MSPCall object.
    virtual HRESULT Init(
        IN     HANDLE                   hAddress,
        IN     CMSPCallBase *           pMSPCall,
        IN     IMediaEvent *            pGraph,
        IN     DWORD                    dwMediaType,
        IN     TERMINAL_DIRECTION       Direction
        );

    HRESULT SubStreamSelectTerminal(
        IN  ITSubStream * pITSubStream, 
        IN  ITTerminal * pITTerminal
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    // method called by quality controller
    INT GetSubStreamCount () { return m_SubStreams.GetSize (); }

protected:
    HRESULT CheckTerminalTypeAndDirection(
        IN  ITTerminal *            pTerminal
        );

    HRESULT ShutDown();
    
    HRESULT SetUpFilters();

    HRESULT SetUpInternalFilters();

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConfigureRTPFormats(
        IN  IBaseFilter *       pIRTPFilter,
        IN  IStreamConfig *     pIStreamConfig
        );

    HRESULT InternalCreateSubStream(
        OUT  ITSubStream **         ppITSubStream
        );

    HRESULT ProcessTalkingEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessSilentEvent(
        IN  DWORD   dwSSRC
        );

    HRESULT ProcessPinMappedEvent(
        IN  DWORD   dwSSRC,
        IN  IPin *  pIPin
        );

    HRESULT ProcessPinUnmapEvent(
        IN  DWORD   dwSSRC,
        IN  IPin *  pIPin
        );

    HRESULT ProcessParticipantLeave(
        IN  DWORD   dwSSRC
        );

    HRESULT NewParticipantPostProcess(
        IN  DWORD dwSSRC, 
        IN  ITParticipant *pITParticipant
        );

    HRESULT AddOneBranch(
        BRANCH * pBranch,
        BOOL fFirstBranch,
        BOOL fDirectRTP
        );

    HRESULT RemoveOneBranch(
        BRANCH * pBranch
        );

    HRESULT ConnectPinToTerminal(
        IN  IPin *  pOutputPin,
        IN  ITTerminal *   pITTerminal
        );

protected:
    CMSPArray <ITSubStream *>   m_SubStreams;

    // This array store information about all the branches off the demux
    CMSPArray <BRANCH>          m_Branches;

    CMSPArray <PINMAPEVENT>     m_PinMappedEvents;   
};

class ATL_NO_VTABLE CStreamVideoSend : 
	public CIPConfMSPStream
{
BEGIN_COM_MAP(CStreamVideoSend)
    COM_INTERFACE_ENTRY_CHAIN(CIPConfMSPStream)
END_COM_MAP()

public:
    CStreamVideoSend();
    ~CStreamVideoSend();

    HRESULT ShutDown ();

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   InnerStreamQualityProperty property,
        IN   LONG lValue, 
        IN   TAPIControlFlags lFlags
        );

protected:
    HRESULT CheckTerminalTypeAndDirection(
        IN  ITTerminal *            pTerminal
        );

    HRESULT SetUpFilters();

    HRESULT GetVideoCapturePins(
        IN  ITTerminalControl*  pTerminal,
        OUT BOOL *pfDirectRTP
        );

    HRESULT ConnectCaptureTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConnectPreviewTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pCapturePin,
        IN   IPin          *pRTPPin,
        IN   BOOL           fDirectRTP
        );

    HRESULT FindPreviewInputPin(
        IN  ITTerminalControl*  pTerminal,
        OUT IPin **             ppIpin
        );

    HRESULT ConnectRTPFilter(
        IN  IGraphBuilder *pIGraphBuilder,
        IN  IPin          *pCapturePin,
        IN  IPin          *pRTPPin,
        IN  IBaseFilter   *pRTPFilter
        );

    HRESULT ConfigureRTPFormats(
        IN  IBaseFilter *       pIRTPFilter,
        IN  IStreamConfig *     pIStreamConfig
        );

    void CleanupCachedInterface();

protected:

    DWORD               m_dwFrameRate;

    ITTerminal *        m_pCaptureTerminal;
    ITTerminal *        m_pPreviewTerminal;
                        
    IBaseFilter *       m_pCaptureFilter;

    IPin *              m_pCapturePin;
    IFrameRateControl * m_pCaptureFrameRateControl;
    IBitrateControl *   m_pCaptureBitrateControl;
    IPin *              m_pPreviewPin;
    IFrameRateControl * m_pPreviewFrameRateControl;

    IPin *              m_pRTPPin;
};

class ATL_NO_VTABLE CSubStreamVideoRecv : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IDispatchImpl<ITSubStream, &__uuidof(ITSubStream), &LIBID_IPConfMSPLib>,
    public CMSPObjectSafetyImpl
{
public:

BEGIN_COM_MAP(CSubStreamVideoRecv)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITSubStream)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(__uuidof(IMarshal), m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    CSubStreamVideoRecv(); 

// methods of the CComObject
    virtual void FinalRelease();

// ITSubStream methods, called by the app.
    STDMETHOD (SelectTerminal) (
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal) (
        IN     ITTerminal *             pTerminal
        );

    STDMETHOD (EnumerateTerminals) (
        OUT     IEnumTerminal **        ppEnumTerminal
        );

    STDMETHOD (get_Terminals) (
        OUT     VARIANT *               pTerminals
        );

    STDMETHOD (get_Stream) (
        OUT     ITStream **             ppITStream
        );

    STDMETHOD (StartSubStream) ();

    STDMETHOD (PauseSubStream) ();

    STDMETHOD (StopSubStream) ();

// methods called by the videorecv object.
    virtual HRESULT Init(
        IN  CStreamVideoRecv *  pStream
        );

    BOOL GetCurrentParticipant(
        DWORD *pdwSSRC,
        ITParticipant ** ppParticipant
        );

    VOID SetCurrentParticipant(
        DWORD dwSSRC,
        ITParticipant * pParticipant
        );

    BOOL ClearCurrentTerminal();
    BOOL SetCurrentTerminal(ITTerminal * pTerminal);

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *                  m_pFTM;

    // The list of terminal objects in the substream.
    CMSPArray <ITTerminal *>    m_Terminals;

    // The lock that protects the substream object. The stream object 
    // should never acquire the lock and then call a MSPCall method 
    // that might lock. This is protected by having a const pointer 
    // to the call object.
    CMSPCritSection             m_lock;

    CStreamVideoRecv  *         m_pStream;

    ITParticipant *             m_pCurrentParticipant;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\qcinner.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    qcinner.h

Abstract:

    Declaration of interfaces
    IInnerCallQualityControl and IInnerStreamQualityControl

Author:

    Qianbo Huai (qhuai) 03/10/2000

--*/

#ifndef __QCINNER_H_
#define __QCINNER_H_

interface IInnerCallQualityControl;
interface IInnerStreamQualityControl;

// properties set on streams by a call or app
typedef enum tagInnerStreamQualityProperty
{
    InnerStreamQuality_StreamState,

    InnerStreamQuality_MaxBitrate,          // read only
    InnerStreamQuality_CurrBitrate,         // read only
    InnerStreamQuality_PrefMaxBitrate,      // by app
    InnerStreamQuality_AdjMaxBitrate,       // by call qc

    InnerStreamQuality_MinFrameInterval,        // read only
    InnerStreamQuality_AvgFrameInterval,       // read only
    InnerStreamQuality_PrefMinFrameInterval,    // by app
    InnerStreamQuality_AdjMinFrameInterval      // by call qc

} InnerStreamQualityProperty;

// events initiated from streams
typedef enum tagQCEvent
{
    QCEVENT_STREAM_STATE,

} QCEvent;

// stream states
typedef enum tagQCStreamState
{
    QCSTREAM_ACTIVE =     0x00000001,
    QCSTREAM_INACTIVE =   0x00000002,
    QCSTREAM_SILENT =     0x00000004,
    QCSTREAM_NOT_SILENT = 0x00000008

} QCStreamState;

/*//////////////////////////////////////////////////////////////////////////////

Description:
    interface designed for stream quality control to coordinate with call
    quality control

////*/

interface DECLSPEC_UUID("D405A342-38C0-11d3-A230-00105AA20660")  DECLSPEC_NOVTABLE
IInnerCallQualityControl : public IUnknown
{
    STDMETHOD_(ULONG, InnerCallAddRef) (VOID) PURE;

    STDMETHOD_(ULONG, InnerCallRelease) (VOID) PURE;

    STDMETHOD (RegisterInnerStreamQC) (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        ) PURE;

    STDMETHOD (DeRegisterInnerStreamQC) (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        ) PURE;

    STDMETHOD (ProcessQCEvent) (
        IN  QCEvent event,
        IN  DWORD dwParam
        ) PURE;
};
#define IID_IInnerCallQualityControl (__uuidof(IInnerCallQualityControl))

/*//////////////////////////////////////////////////////////////////////////////

Description:
    interface designed for call quality control to coordinate with stream
    quality control

////*/
interface DECLSPEC_UUID("c3f699ce-3bb1-11d3-a230-00105aa20660")  DECLSPEC_NOVTABLE
IInnerStreamQualityControl : public IUnknown
{
    STDMETHOD (LinkInnerCallQC) (
        IN  IInnerCallQualityControl *pIInnerCallQC
        ) PURE;

    STDMETHOD (UnlinkInnerCallQC) (
        IN  BOOL fByStream
        ) PURE;

    STDMETHOD (GetRange) (
        IN  InnerStreamQualityProperty property,
        OUT LONG *plMin,
        OUT LONG *plMax,
        OUT LONG *plSteppingDelta,
        OUT LONG *plDefault,
        OUT TAPIControlFlags *plFlags
        ) PURE;

    STDMETHOD (Set) (
        IN  InnerStreamQualityProperty property,
        IN  LONG  lValue,
        IN  TAPIControlFlags lFlags
        ) PURE;

    STDMETHOD (Get) (
        IN  InnerStreamQualityProperty property,
        OUT LONG *lValue,
        OUT TAPIControlFlags *plFlags
        ) PURE;

    STDMETHOD (TryLockStream)() PURE;

    STDMETHOD (UnlockStream)() PURE;

    STDMETHOD (IsAccessingQC)() PURE;
};
#define IID_IInnerStreamQualityControl (__uuidof(IInnerStreamQualityControl))

#endif // __QCINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\resource.h ===
#ifndef __RESOURCE_h_
#define __RESOURCE_h_

#define IDS_PROJNAME                  100
#define IDR_IPCONFMSP                 101

#define IDS_AUDIO_CAPTURE_STREAM      102
#define IDS_AUDIO_RENDER_STREAM       103
#define IDS_VIDEO_CAPTURE_STREAM      104
#define IDS_VIDEO_RENDER_STREAM       105

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\audrecp.h ===
/****************************************************************************
 *  @doc INTERNAL CAUDRECPCLASS
 *
 *  @module CaptureP.h | Header file for the <c CAudRecProperty>
 *    class used to implement a property page to test the TAPI control
 *    interfaces <i ITFormatControl>, <i ITQualityControl> and 
 *    <i ITAudioSettings>.
 ***************************************************************************/

#define NUM_AUDREC_CONTROLS		    6
#define IDC_Record_Bitrate			    0
#define IDC_Record_Volume			    1
#define IDC_Record_AudioLevel    	    2
#define IDC_Record_SilenceLevel		    3
#define IDC_Record_SilenceDetection     4
#define IDC_Record_SilenceCompression  	5

typedef struct _CONTROL_DESCRIPTION
{
    ULONG IDLabel; 
    ULONG IDMinControl; 
    ULONG IDMaxControl; 
    ULONG IDDefaultControl; 
    ULONG IDStepControl; 
    ULONG IDEditControl; 
    ULONG IDTrackbarControl; 
    ULONG IDProgressControl; 
    ULONG IDProperty; 
    ITStreamQualityControl *pITQualityControl;
    ITAudioSettings *pITAudioSettings;

} CONTROL_DESCRIPTION;

/****************************************************************************
 *  @doc INTERNAL CAUDRECPCLASS
 *
 *  @class CAudRecProperty | This class implements handling of a
 *    single audio recording property in a property page.
 *
 *  @mdata int | CAudRecProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControl* | CAudRecProperty | m_pITQualityControl | Pointer
 *    to the <i ITQualityControl> interface.
***************************************************************************/
class CAudRecProperty : public CPropertyEditor 
{
	public:
	CAudRecProperty(
        HWND hDlg,
        CONTROL_DESCRIPTION &ControlDescription
        );
	~CAudRecProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();

	private:
	ITStreamQualityControl *m_pITQualityControl;
    ITAudioSettings *m_pITAudioSettings;
};

/****************************************************************************
 *  @doc INTERNAL CAUDRECPCLASS
 *
 *  @class CAudRecProperties | This class implements a property page
 *    to test the new TAPI control interfaces <i ITFormatControl>,
 *    <i ITQualityControl> and <i ITAudioSettings>
 *
 *  @mdata int | CAudRecProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControl* | CAudRecProperties | m_pITQualityControl | Pointer
 *    to the <i ITQualityControl> interface.
 *
 *  @mdata ITFormatControl* | CAudRecProperties | m_pITFormatControl | Pointer
 *    to the <i ITFormatControl> interface.
 *
 *  @mdata ITAudioSettings * | CAudRecProperties | m_pITAudioSettings | Pointer
 *    to the <i ITAudioSettings> interface.
 *
 *  @mdata CAudRecProperty* | CAudRecProperties | m_Controls[NUM_AUDREC_CONTROLS] | Array
 *    of capture properties.
***************************************************************************/
class CAudRecProperties
{
	public:
	CAudRecProperties();
	~CAudRecProperties();

	HPROPSHEETPAGE OnCreate();

	HRESULT OnConnect(ITStream *pStream);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();

	private:

	void SetDirty();

	// Format manipulation methods
	HRESULT InitialRangeScan();
	HRESULT OnFormatChanged();
	HRESULT GetCurrentMediaType(void);
	HRESULT DeleteAMMediaType(AM_MEDIA_TYPE *pAMMT);

	BOOL						m_bInit;
	HWND						m_hDlg;
	int							m_NumProperties;
	ITAudioSettings             *m_pITAudioSettings;
	ITStreamQualityControl			*m_pITQualityControl;
	ITFormatControl				*m_pITFormatControl;
	DWORD   					m_RangeCount;
	TAPI_STREAM_CONFIG_CAPS	    m_RangeCaps;
	GUID						*m_SubTypeList;
	GUID						m_SubTypeCurrent;
	AM_MEDIA_TYPE				*m_CurrentMediaType;
	HWND						m_hWndFormat;
	DWORD 						m_CurrentFormat;
	DWORD    					m_OriginalFormat;

	CAudRecProperty *m_Controls[NUM_AUDREC_CONTROLS];

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\qcstream.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    qcstream.cpp

Abstract:

    Implementation of CStreamQualityControlRelay

    Data stored in this class can be, and better, kept in stream object itself,
    because other members in stream need to be accessed to either set or get
    properties related to stream quality control. Most of these access methods
    are specific to each particular kind of stream class.

    This class is used as a data store.

Author:

    Qianbo Huai (qhuai) 03/10/2000

--*/

#include "stdafx.h"

/*//////////////////////////////////////////////////////////////////////////////
////*/
CStreamQualityControlRelay::CStreamQualityControlRelay ()
    :m_pIInnerCallQC (NULL)

    ,m_PrefFlagBitrate (TAPIControl_Flags_Auto)
    ,m_lPrefMaxBitrate (QCDEFAULT_QUALITY_UNSET)
    ,m_lAdjMaxBitrate (QCDEFAULT_QUALITY_UNSET)

    ,m_PrefFlagFrameInterval (TAPIControl_Flags_Auto)
    ,m_lPrefMinFrameInterval (QCDEFAULT_QUALITY_UNSET)
    ,m_lAdjMinFrameInterval (QCDEFAULT_QUALITY_UNSET)

    ,m_fQOSAllowedToSend (TRUE)
    ,m_dwState (NULL)
{
}

/*//////////////////////////////////////////////////////////////////////////////
Description:

    destructor. deregister relay
////*/
CStreamQualityControlRelay::~CStreamQualityControlRelay ()
{
    ENTER_FUNCTION ("CStreamQualityControlRelay::~CStreamQualityControlRelay");

    if (m_pIInnerCallQC)
    {
        LOG ((MSP_ERROR, "!!! %s destructed before unnlink. call keeps stream qc"));

        // access to m_pIInnerCallQC is locked in this method
        UnlinkInnerCallQC (NULL);
    }
}

/*//////////////////////////////////////////////////////////////////////////////
Description:
    store call controller
////*/
HRESULT
CStreamQualityControlRelay::LinkInnerCallQC (
    IN IInnerCallQualityControl *pIInnerCallQC
    )
{
    ENTER_FUNCTION ("CStreamQualityControlRelay::LinkInnerCallQC");

    // check pointer
    if (IsBadReadPtr (pIInnerCallQC, sizeof (IInnerCallQualityControl)))
    {
        LOG ((MSP_ERROR, "%s got bad read pointer", __fxName));
        return E_POINTER;
    }

    // check if call controller already set
    if (NULL != m_pIInnerCallQC)
    {
        LOG ((MSP_WARN, "%s already set call controller", __fxName));
        return E_UNEXPECTED;
    }

    m_pIInnerCallQC = pIInnerCallQC;
    m_pIInnerCallQC->InnerCallAddRef ();

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CStreamQualityControlRelay::UnlinkInnerCallQC (
    IN  IInnerStreamQualityControl *pIInnerStreamQC
    )
{
    ENTER_FUNCTION ("CStreamQualityControlRelay::UnlinkInnerCallQC");

    if (!m_pIInnerCallQC)
    {
        LOG ((MSP_WARN, "%s tried unlink while inner call qc is null", __fxName));
        return S_OK;
    }

    if (NULL != pIInnerStreamQC)
    {
        HRESULT hr;

        // release is initiated by stream, need to remove the link on call
        if (FAILED (hr = m_pIInnerCallQC->DeRegisterInnerStreamQC (pIInnerStreamQC)))
            LOG ((MSP_ERROR, "%s failed to deregister from call qc, %x", __fxName, hr));
    }

    m_pIInnerCallQC->InnerCallRelease ();
    m_pIInnerCallQC = NULL;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CStreamQualityControlRelay::Get(
    IN  InnerStreamQualityProperty property,
    OUT LONG *plValue,
    OUT TAPIControlFlags *plFlags
    )
{
    ENTER_FUNCTION ("CStreamQualityControlRelay::Get");

    HRESULT hr;

    hr = S_OK;

    switch (property)
    {
    case InnerStreamQuality_PrefMaxBitrate:
        *plValue = m_lPrefMaxBitrate;
        *plFlags = m_PrefFlagBitrate;
        break;

    case InnerStreamQuality_AdjMaxBitrate:
        *plValue = m_lAdjMaxBitrate;
        *plFlags = m_PrefFlagBitrate;
        break;

    case InnerStreamQuality_PrefMinFrameInterval:
        *plValue = m_lPrefMinFrameInterval;
        *plFlags = m_PrefFlagFrameInterval;
        break;

    case InnerStreamQuality_AdjMinFrameInterval:
        *plValue = m_lAdjMinFrameInterval;
        *plFlags = m_PrefFlagFrameInterval;
        break;

    default:
        hr = E_NOTIMPL;
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
HRESULT
CStreamQualityControlRelay::Set(
    IN  InnerStreamQualityProperty property, 
    IN  LONG lValue, 
    IN  TAPIControlFlags lFlags
    )
{
    ENTER_FUNCTION ("CStreamQualityControlRelay::Set");

    HRESULT hr;

    hr = S_OK;

    switch (property)
    {
    case InnerStreamQuality_PrefMaxBitrate:
        if (lValue < QCLIMIT_MIN_BITRATE)
        {
            LOG ((MSP_ERROR, "%s: pref max bitrate %d is too small", __fxName, lValue));
            hr = E_INVALIDARG;
        }
        else
        {
            m_lPrefMaxBitrate = lValue;
            m_PrefFlagBitrate = lFlags;
        }
        break;

    case InnerStreamQuality_AdjMaxBitrate:
        if (lValue < QCLIMIT_MIN_BITRATE)
        {
            LOG ((MSP_ERROR, "%s: adjusted max bitrate %d is too small", __fxName, lValue));
            hr = E_INVALIDARG;
        }
        else
            m_lAdjMaxBitrate = lValue;
        break;

    case InnerStreamQuality_PrefMinFrameInterval:
        if (lValue < QCLIMIT_MIN_FRAME_INTERVAL || lValue > QCLIMIT_MAX_FRAME_INTERVAL)
        {
            LOG ((MSP_ERROR, "%s: pref max frame interval %d is out of range", __fxName, lValue));
            hr = E_INVALIDARG;
        }
        else
        {
            m_lPrefMinFrameInterval = lValue;
            m_PrefFlagFrameInterval = lFlags;
        }
        break;

    case InnerStreamQuality_AdjMinFrameInterval:
        if (lValue < QCLIMIT_MIN_FRAME_INTERVAL || lValue > QCLIMIT_MAX_FRAME_INTERVAL)
        {
            LOG ((MSP_ERROR, "%s: adjusted max frame interval %d is out of range", __fxName, lValue));
            hr = E_INVALIDARG;
        }
        else
            m_lAdjMinFrameInterval = lValue;
        break;

    default:
        hr = E_NOTIMPL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\qcobj.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    qcobj.h

Abstract:

    Declaration of classes
    CCallQualityControlRelay and CStreamQualityControlRelay

Author:

    Qianbo Huai (qhuai) 03/10/2000

--*/

#ifndef __QCOBJ_H_
#define __QCOBJ_H_

class CIPConfMSPCall;

// default values
#define QCDEFAULT_QUALITY_UNSET       -1

#define QCDEFAULT_MAX_CPU_LOAD        85
#define QCDEFAULT_MAX_CALL_BITRATE    QCDEFAULT_QUALITY_UNSET
#define QCDEFAULT_MAX_STREAM_BITRATE  QCDEFAULT_QUALITY_UNSET
#define QCDEFAULT_MAX_VIDEO_BITRATE   95000L // 95k bps

#define QCDEFAULT_UP_THRESHOLD     0.05   // above target value
#define QCDEFAULT_LOW_THRESHOLD     0.20   // below target value

#define QCDEFAULT_QUALITY_CONTROL_INTERVAL 7000

// limited values
#define QCLIMIT_MIN_QUALITY_CONTROL_INTERVAL  2000
#define QCLIMIT_MAX_QUALITY_CONTROL_INTERVAL  60000
#define QCLIMIT_MAX_CPU_LOAD  100
#define QCLIMIT_MIN_CPU_LOAD  5
#define QCLIMIT_MIN_BITRATE   1000L // 1k bps
#define QCLIMIT_MIN_CONFBITRATE 4000L // 4k bps
#define QCLIMIT_MIN_FRAME_INTERVAL 333333L
#define QCLIMIT_MAX_FRAME_INTERVAL 10000000L

#define QCLIMIT_MAX_QOSNOTALLOWEDTOSEND 8000L

/*//////////////////////////////////////////////////////////////////////////////
////*/

typedef CMSPArray <IInnerStreamQualityControl *> InnerStreamQCArray;

class CCallQualityControlRelay
{
public:

    CCallQualityControlRelay ();
    ~CCallQualityControlRelay ();

    HRESULT Initialize (CIPConfMSPCall *pCall);
    HRESULT Shutdown (VOID);

    HRESULT SetConfBitrate (LONG lConfBitrate);
    LONG GetConfBitrate ();

    // main callback
    VOID CallbackProc (BOOLEAN bTimerFired);

    // methods called by inner call quality control
    HRESULT RegisterInnerStreamQC (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        );

    HRESULT DeRegisterInnerStreamQC (
        IN  IInnerStreamQualityControl *pIInnerStreamQC
        );

    HRESULT ProcessQCEvent (
        IN  QCEvent event,
        IN  DWORD dwParam
        );

    // methods called by ITCallQualityControl
    HRESULT Get (
        IN  CallQualityProperty property, 
        OUT LONG *plValue, 
        OUT TAPIControlFlags *plFlags
        );

    HRESULT Set(
        IN  CallQualityProperty property, 
        IN  LONG lValue, 
        IN  TAPIControlFlags lFlags
        );

    HRESULT GetRange (
        IN CallQualityProperty Property, 
        OUT long *plMin, 
        OUT long *plMax, 
        OUT long *plSteppingDelta, 
        OUT long *plDefault, 
        OUT TAPIControlFlags *plFlags
        );

private:

    BOOL GetCPUUsage (PDWORD pdwOverallCPUUsage);

    HRESULT GetCallBitrate (LONG MediaType, TERMINAL_DIRECTION Direction, LONG *plValue);
    LONG GetVideoOutBitrate ();

    VOID ReDistributeResources (VOID);
    VOID ReDistributeCPU (VOID);
    VOID ReDistributeBandwidth (VOID);

private:
    CIPConfMSPCall *m_pCall;

    // inner stream quality control
    CMSPCritSection    m_lock_aInnerStreamQC;
    InnerStreamQCArray m_aInnerStreamQC;

    BOOL    m_fInitiated;
    HANDLE  m_hWait;

    // used by callback to wait
    HANDLE  m_hQCEvent;
    DWORD   m_dwControlInterval;

    // notify callback to stop
    BOOL    m_fStop;
    BOOL    m_fStopAck;

    // lock when access quality data
    CMSPCritSection m_lock_QualityData;

    // note: should design a structure if we have complicated algorithms

    // conference-wide bandwidth
    LONG m_lConfBitrate;

    // prefered maximum cpu load
    LONG m_lPrefMaxCPULoad;
    LONG m_lCPUUpThreshold;
    LONG m_lCPULowThreshold;

    // prefered maximum output bitrate on call
    LONG m_lPrefMaxOutputBitrate;
    LONG m_lOutBitUpThreshold;
    LONG m_lOutBitLowThreshold;

#ifdef DEBUG_QUALITY_CONTROL

private:
    VOID QCDbgInitiate (VOID);
    VOID QCDbgRead (VOID);
    VOID QCDbgShutdown (VOID);

    HKEY m_hQCDbg;
    BOOL m_fQCDbgTraceCPULoad;
    BOOL m_fQCDbgTraceBitrate;

#endif // DEBUG_QUALITY_CONTROL
};

/*//////////////////////////////////////////////////////////////////////////////
////*/
class CStreamQualityControlRelay
{
public:

    CStreamQualityControlRelay ();
    ~CStreamQualityControlRelay ();

    HRESULT ProcessQCEvent (
        IN QCEvent event,
        IN DWORD   dwParam
        )
    {
        return S_OK;
    }

    // methods called by inner stream control
    HRESULT LinkInnerCallQC (
        IN IInnerCallQualityControl *pIInnerCallQC
        );

    HRESULT UnlinkInnerCallQC (
        IN IInnerStreamQualityControl *pIInnerStreamQC
        );

    HRESULT Get(
        IN  InnerStreamQualityProperty property,
        OUT LONG *plValue,
        OUT TAPIControlFlags *plFlags
        );

    HRESULT Set(
        IN  InnerStreamQualityProperty property, 
        IN  LONG lValue, 
        IN  TAPIControlFlags lFlags
        );

    // qos, actually, all variables should be public
    BOOL m_fQOSAllowedToSend;
    
private:

    // call quality controller
    IInnerCallQualityControl *m_pIInnerCallQC;

    // note: quality related data better be stored in a structure
    // if we have a complicated algorithm
    TAPIControlFlags m_PrefFlagBitrate;
    LONG m_lPrefMaxBitrate;
    LONG m_lAdjMaxBitrate;

    TAPIControlFlags m_PrefFlagFrameInterval;
    LONG m_lPrefMinFrameInterval;
    LONG m_lAdjMinFrameInterval;
    
    // not used
    DWORD m_dwState;
};

#endif // __QCOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\msp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED_)
#define AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#ifdef STRICT
#undef STRICT
#endif

#include <mspbase.h>
#include <winsock2.h>
#include <sdpblb.h>

#include <streams.h>    // for amvideo stuff
#include <mmreg.h>      // for WAVEFORMATEX

#include "confmsp.h"

#include <tapivid.h>
#include <tapiaud.h>
#include <tapirtp.h>

#ifdef MSPLOG
#define ENTER_FUNCTION(s) \
    static const CHAR * const __fxName = s
#else
#define ENTER_FUNCTION(s)
#endif

#ifdef DBG   // checked build
#ifndef _DEBUG // DEBUG_CRT is not enabled.
#undef _ASSERT
#undef _ASSERTE
#define _ASSERT(expr)  do { if (!(expr)) DebugBreak(); } while (0)
#define _ASSERTE(expr)  do { if (!(expr)) DebugBreak(); } while (0)
#endif
#endif

#include "confterm.h"
#include "confaudt.h"
#include "confvidt.h"
#include "confaddr.h"
#include "confpart.h"
#include "qcinner.h"
#include "qcobj.h"
#include "confcall.h"
#include "confstrm.h"
#include "confaud.h"
#include "confvid.h"
#include "confutil.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\audrecp.cpp ===
/****************************************************************************
 *  @doc INTERNAL AudRecP
 *
 *  @module CaptureP.cpp | Source file for the <c CAudRecProperty>
 *    class used to implement a property page to test the TAPI control
 *    interfaces <i ITFormatControl> and <i ITQualityControl>.
 ***************************************************************************/

#include "Precomp.h"

extern HINSTANCE ghInst;


/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc void | CAudRecProperty | CAudRecProperty | This
 *    method is the constructor for bitrate property object. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    pointers to the <i ITQualityControl> interfaces.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ITQualityControl* | pITQualityControl | Specifies a pointer to the
 *    <i ITQualityControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CAudRecProperty::CAudRecProperty(
    HWND hDlg, 
    CONTROL_DESCRIPTION &ControlDescription
    )
: CPropertyEditor(
    hDlg, 
    ControlDescription.IDLabel, 
    ControlDescription.IDMinControl, 
    ControlDescription.IDMaxControl, 
    ControlDescription.IDDefaultControl, 
    ControlDescription.IDStepControl, 
    ControlDescription.IDEditControl, 
    ControlDescription.IDTrackbarControl, 
    ControlDescription.IDProgressControl, 
    ControlDescription.IDProperty, 
    0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CAudRecProperty::CAudRecProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointers are NULL, we'll grey the
	// associated items in the property page
	m_pITQualityControl = ControlDescription.pITQualityControl;
    m_pITAudioSettings = ControlDescription.pITAudioSettings;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc void | CAudRecProperty | ~CAudRecProperty | This
 *    method is the destructor for capture property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CAudRecProperty::~CAudRecProperty()
{
	FX_ENTRY("CAudRecProperty::~CAudRecProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	TAPIControlFlags CurrentFlag;
	LONG Mode;

	FX_ENTRY("CAudRecProperty::GetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{									
		case IDC_Record_Bitrate:
/*
			if (m_pITQualityControl)
            {
                Hr = m_pITQualityControl->Get(Quality_MaxBitrate, &m_CurrentValue, &CurrentFlag);
            }
*/
			break;

		case IDC_Record_Volume:
			if (m_pITAudioSettings)
            {
                Hr = m_pITAudioSettings->Get(AudioSettings_Volume, &m_CurrentValue, (TAPIControlFlags*)&CurrentFlag);
            }
            break;

        case IDC_Record_AudioLevel:
			if (m_pITAudioSettings)
            {
                Hr = m_pITAudioSettings->Get(AudioSettings_SignalLevel, &m_CurrentValue, (TAPIControlFlags*)&CurrentFlag);
            }
            break;

        case IDC_Record_SilenceLevel:
			if (m_pITAudioSettings)
            {
                Hr = m_pITAudioSettings->Get(AudioSettings_SilenceThreshold, &m_CurrentValue, (TAPIControlFlags*)&CurrentFlag);
            }
            break;

        case IDC_Record_SilenceDetection:
            m_CurrentValue = 1;
            CurrentFlag = TAPIControl_Flags_None;
            break;

        case IDC_Record_SilenceCompression:
            m_CurrentValue = 0;
            CurrentFlag = TAPIControl_Flags_None;
			break;

		default:
			Hr = E_UNEXPECTED;
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;

	FX_ENTRY("CAudRecProperty::SetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case IDC_Record_Bitrate:
/*
			if (m_pITQualityControl)
            {
                Hr = m_pITQualityControl->Set(Quality_MaxBitrate, m_CurrentValue, TAPIControl_Flags_None);
            }
*/
			break;

		case IDC_Record_Volume:
			if (m_pITAudioSettings)
            {
                Hr = m_pITAudioSettings->Set(AudioSettings_Volume, m_CurrentValue, TAPIControl_Flags_None);
            }
            break;

        case IDC_Record_AudioLevel:
            Hr = S_OK;
            break;

        case IDC_Record_SilenceLevel:
			if (m_pITAudioSettings)
            {
                Hr = m_pITAudioSettings->Set(AudioSettings_SilenceThreshold, m_CurrentValue, TAPIControl_Flags_None);
            }
            break;

        case IDC_Record_SilenceDetection:
            // TODO: enable silence suppression.
            Hr = S_OK;
            break;

        case IDC_Record_SilenceCompression:
            // TODO: enable silence compression.
            Hr = S_OK;
			break;

        default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown capture property"), _fx_));
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;
	LONG Flags;

	FX_ENTRY("CAudRecProperty::GetRange")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{
		case IDC_Record_Bitrate:
/*
			if (m_pITQualityControl)
            {
			    Hr = m_pITQualityControl->GetRange(Quality_MaxBitrate, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags);
            }
*/
			break;

		case IDC_Record_Volume:
			if (m_pITAudioSettings)
            {
			    Hr = m_pITAudioSettings->GetRange(AudioSettings_Volume, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags);
            }
            break;

        case IDC_Record_AudioLevel:
			if (m_pITAudioSettings)
            {
                Hr = m_pITAudioSettings->GetRange(AudioSettings_SignalLevel, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags);
            }
            break;

        case IDC_Record_SilenceLevel:
			if (m_pITAudioSettings)
            {
			    Hr = m_pITAudioSettings->GetRange(AudioSettings_SilenceThreshold, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags);
            }
            break;

        case IDC_Record_SilenceDetection:
            Hr = S_OK;
            break;

        case IDC_Record_SilenceCompression:
            Hr = S_OK;
			break;

		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown capture property"), _fx_));
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CAudRecProperties | OnCreate | This
 *    method creates a new page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CAudRecProperties::OnCreate()
{
    PROPSHEETPAGE psp;
    
	psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = ghInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_RecordFormatProperties);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc void | CAudRecProperties | CAudRecProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CAudRecProperties::CAudRecProperties()
{
	FX_ENTRY("CAudRecProperties::CAudRecProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	m_pITQualityControl = NULL;
	m_pITQualityControl = NULL;
	m_pITFormatControl = NULL;
	m_NumProperties = NUM_AUDREC_CONTROLS;
	m_hWndFormat = m_hDlg = NULL;
	m_RangeCount = 0;
	m_SubTypeList = NULL;
	m_CurrentMediaType = NULL;
	m_CurrentFormat = 0;
	m_OriginalFormat = 0;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc void | CAudRecProperties | ~CAudRecProperties | This
 *    method is the destructor for the capture pin property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CAudRecProperties::~CAudRecProperties()
{
	int		j;

	FX_ENTRY("CAudRecProperties::~CAudRecProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	if (m_SubTypeList)
		delete[] m_SubTypeList, m_SubTypeList = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | OnConnect | This
 *    method is called when the property page is connected to a TAPI object.
 *
 *  @parm ITStream* | pStream | Specifies a pointer to the <i ITStream>
 *    interface. It is used to QI for the <i ITQualityControl> and
 *    <i ITFormatControl> interfaces.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::OnConnect(ITStream *pStream)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CAudRecProperties::OnConnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!pStream)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the quality control interface
	if (SUCCEEDED (Hr = pStream->QueryInterface(__uuidof(ITStreamQualityControl), (void **)&m_pITQualityControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITQualityControl=0x%08lX"), _fx_, m_pITQualityControl));
	}
	else
	{
		m_pITQualityControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	// Get the format control interface
	if (SUCCEEDED (Hr = pStream->QueryInterface(__uuidof(ITFormatControl), (void **)&m_pITFormatControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITFormatControl=0x%08lX"), _fx_, m_pITFormatControl));
	}
	else
	{
		m_pITFormatControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	// Get the audio settings interface
	if (SUCCEEDED (Hr = pStream->QueryInterface(__uuidof(ITAudioSettings), (void **)&m_pITAudioSettings)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITAudioSettings=0x%08lX"), _fx_, m_pITAudioSettings));
	}
	else
	{
		m_pITAudioSettings = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device
	Hr = NOERROR;

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::OnDisconnect()
{
	FX_ENTRY("CAudRecProperties::OnDisconnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pITQualityControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITQualityControl->Release();
		m_pITQualityControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITQualityControl"), _fx_));
	}

	if (!m_pITFormatControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITFormatControl->Release();
		m_pITFormatControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITFormatControl"), _fx_));
	}

	if (!m_pITAudioSettings)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITAudioSettings->Release();
		m_pITAudioSettings = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITFormatControl"), _fx_));
	}

	// Release format memory
	if (m_CurrentMediaType)
	{
		DeleteAMMediaType(m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	if (m_SubTypeList)
		delete[] m_SubTypeList, m_SubTypeList = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::OnActivate()
{
	HRESULT	Hr = NOERROR;
	DWORD   dw;
    int     j;

	FX_ENTRY("CAudRecProperties::OnActivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Initialize format control structures
	m_hWndFormat = GetDlgItem(m_hDlg, IDC_FORMAT_Compression);

	// Disable everything if we didn't initialize correctly
	if (!m_pITFormatControl || (FAILED (Hr = InitialRangeScan())))
	{
		EnableWindow(m_hWndFormat, FALSE);
	}
	else
	{
		// Update the content of the format combo box
		ComboBox_ResetContent(m_hWndFormat);
		for (dw = 0; dw < m_RangeCount; dw++)
		{
			CMediaType *pmt = NULL;
			BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

			Hr = m_pITFormatControl->GetStreamCaps(dw, (AM_MEDIA_TYPE **)&pmt, &m_RangeCaps, &fEnabled);

            if (FAILED(Hr))
            {
                break;
            }

			DeleteAMMediaType(pmt);

			ComboBox_AddString(m_hWndFormat, m_RangeCaps.AudioCap.Description);

			if (m_CurrentMediaType->subtype == m_SubTypeList[dw])
			{
				ComboBox_SetCurSel(m_hWndFormat, dw);
				m_SubTypeCurrent = m_SubTypeList[dw];
			}
		}

		// Update current format
		OnFormatChanged();

		// Remember the original format
		m_OriginalFormat = m_CurrentFormat;
	}


    CONTROL_DESCRIPTION Controls[NUM_AUDREC_CONTROLS] = 
    {
        {
            IDC_BitrateControl_Label, 
            IDC_BitrateControl_Minimum, 
            IDC_BitrateControl_Maximum, 
            IDC_BitrateControl_Default, 
            IDC_BitrateControl_Stepping, 
            IDC_BitrateControl_Edit, 
            IDC_BitrateControl_Slider,
            0,
            IDC_Record_Bitrate,
            m_pITQualityControl,
            m_pITAudioSettings,
        },
        {
            IDC_VolumeLevel_Label,
            IDC_VolumeLevel_Minimum,
            IDC_VolumeLevel_Maximum,
            IDC_VolumeLevel_Default,
            IDC_VolumeLevel_Stepping,
            IDC_VolumeLevel_Edit,
            IDC_VolumeLevel_Slider,
            IDC_VolumeLevel_Meter,
            IDC_Record_Volume, 
            m_pITQualityControl,
            m_pITAudioSettings,
        },
        {
            IDC_AudioLevel_Label, 
            IDC_AudioLevel_Minimum, 
            IDC_AudioLevel_Maximum, 
            IDC_AudioLevel_Default, 
            IDC_AudioLevel_Stepping, 
            IDC_AudioLevel_Edit, 
            IDC_AudioLevel_Slider, 
            IDC_AudioLevel_Meter, 
            IDC_Record_AudioLevel, 
            m_pITQualityControl,
            m_pITAudioSettings,
        },
        {
            IDC_SilenceLevel_Label, 
            IDC_SilenceLevel_Minimum, 
            IDC_SilenceLevel_Maximum, 
            IDC_SilenceLevel_Default, 
            IDC_SilenceLevel_Stepping, 
            IDC_SilenceLevel_Edit, 
            IDC_SilenceLevel_Slider, 
            IDC_SilenceLevel_Meter, 
            IDC_Record_SilenceLevel, 
            m_pITQualityControl,
            m_pITAudioSettings,
        },
        {
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            IDC_Record_SilenceDetection, 
            m_pITQualityControl,
            m_pITAudioSettings,
        },
        {
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            IDC_Record_SilenceCompression, 
            m_pITQualityControl,
            m_pITAudioSettings,
        }
    };

    for (int i = 0; i < NUM_AUDREC_CONTROLS; i ++)
    {
        m_Controls[i] = new CAudRecProperty(m_hDlg, Controls[i]);

        if (m_Controls[i] == NULL)
        {
            for (int j = 0; j < i; j ++)
            {
                delete m_Controls[j];
                m_Controls[j] = NULL;
            }
    		
            DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Out of memory"), _fx_));

			Hr = E_OUTOFMEMORY;
			goto MyExit;
        }
    }


	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CAudRecProperties::OnDeactivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | GetCurrentMediaType | This
 *    method is used to retrieve the current media format used by the pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::GetCurrentMediaType(void)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CAudRecProperties::GetCurrentMediaType")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	if (m_CurrentMediaType)
	{
		DeleteAMMediaType(m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	if (FAILED (Hr = m_pITFormatControl->GetCurrentFormat((AM_MEDIA_TYPE **)&m_CurrentMediaType)))
	{
		// Otherwise, just get the first enumerated media type
		TAPI_STREAM_CONFIG_CAPS RangeCaps;
		BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

		if (FAILED (Hr = m_pITFormatControl->GetStreamCaps(0, (AM_MEDIA_TYPE **)&m_CurrentMediaType, &RangeCaps, &fEnabled)))
		{
			m_CurrentMediaType = NULL;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | DeleteAMMediaType | This
 *    method is used to delete a task-allocated AM_MEDIA_TYPE structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 *
 *  @comm There is a DShow DeleteMediaType, but it'd be pretty dumb to link to
 *    strmbase.lib just for this little guy, would it?
 ***************************************************************************/
HRESULT CAudRecProperties::DeleteAMMediaType(AM_MEDIA_TYPE *pAMMT)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CAudRecProperties::DeleteAMMediaType")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

    if (pAMMT)
	{
		if (pAMMT->cbFormat != 0 && pAMMT->pbFormat)
		{
			CoTaskMemFree((PVOID)pAMMT->pbFormat);
		}
		if (pAMMT->pUnk != NULL)
		{
			pAMMT->pUnk->Release();
		}
	}

    CoTaskMemFree((PVOID)pAMMT);

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | OnFormatChanged | This
 *    method is used to retrieve the format selected by the user.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::OnFormatChanged()
{
	HRESULT	Hr = E_UNEXPECTED;
	DWORD dw;

	FX_ENTRY("CAudRecProperties::OnFormatChanged")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	if (!m_pITFormatControl)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Associate the current compression index with the right range index
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	if (m_CurrentFormat < m_RangeCount)
	{
		m_SubTypeCurrent = m_SubTypeList[m_CurrentFormat];

		for (dw = 0; dw < m_RangeCount; dw++)
		{
			if (m_SubTypeList[dw] == m_SubTypeCurrent)
			{
				CMediaType *pmt = NULL;
				BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

				Hr = m_pITFormatControl->GetStreamCaps(dw, (AM_MEDIA_TYPE **)&pmt, &m_RangeCaps, &fEnabled);

				DeleteAMMediaType(pmt);
			}
		}
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | InitialRangeScan | This
 *    method is used to retrieve the list of supported formats on the stream.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::InitialRangeScan()
{
	HRESULT			Hr = NOERROR;
	DWORD           dw;
	AM_MEDIA_TYPE	*pmt = NULL;

	FX_ENTRY("CAudRecProperties::InitialRangeScan")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	if (!m_pITFormatControl)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	Hr = m_pITFormatControl->GetNumberOfCapabilities(&m_RangeCount);
	if (!SUCCEEDED(Hr))
	{
		Hr = E_FAIL;
		goto MyExit;
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   NumberOfRanges=%d"), _fx_, m_RangeCount));

	if (!(m_SubTypeList = new GUID [m_RangeCount]))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s: ERROR: new failed"), _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	for (dw = 0; dw < m_RangeCount; dw++)
	{
		pmt = NULL;
		BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

		Hr = m_pITFormatControl->GetStreamCaps(dw, (AM_MEDIA_TYPE **)&pmt, &m_RangeCaps, &fEnabled);

		m_SubTypeList[dw] = pmt->subtype;

		DeleteAMMediaType(pmt);
	}

	// Get default format
	Hr = GetCurrentMediaType();

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc HRESULT | CAudRecProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CAudRecProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;
	int		j;
	CMediaType *pmt = NULL;
	BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

	FX_ENTRY("CAudRecProperties::OnApplyChanges")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Apply format changes on video stream
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	
	// Only apply change if the format is different
	if (m_CurrentFormat != m_OriginalFormat)
	{
		if (SUCCEEDED (Hr = m_pITFormatControl->GetStreamCaps(m_CurrentFormat, (AM_MEDIA_TYPE **) &pmt, &m_RangeCaps, &fEnabled)))
		{
//			if (FAILED(Hr = m_pITFormatControl->SetPreferredFormat(pmt)))
			{
				// Why did you mess with the format that was returned to you?
			}

			// Free some memory that was allocated by GetStreamCaps
			if (pmt)
				DeleteAMMediaType(pmt);

			// Update our copy of the current format
			GetCurrentMediaType();
		}
	}

	// Apply settings on the stream.
	for (j = 0; j < NUM_AUDREC_CONTROLS; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc BOOL | CAudRecProperties | BaseDlgProc | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
INT_PTR CALLBACK CAudRecProperties::BaseDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    CAudRecProperties *pSV = (CAudRecProperties*)GetWindowLong(hDlg, DWL_USER);

	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)lParam;
				pSV = (CAudRecProperties*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg, DWL_USER, (LPARAM)pSV);
				pSV->m_bInit = FALSE;
				//pSV->OnActivate();
				//pSV->m_bInit = TRUE;
				return TRUE;
			}
			break;

		case WM_TIMER:
			if (pSV && pSV->m_bInit)
			{
				// Update the Vu-Meters
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j]->GetProgressHWnd())
					{
						pSV->m_Controls[j]->UpdateProgress();
						pSV->SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the Trackbar messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						pSV->SetDirty();
					}
				}
				// pSV->OnApplyChanges();
			}
			break;

		case WM_COMMAND:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the auto checkbox messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < pSV->m_NumProperties; j++)
						{
							if (pSV->m_Controls[j])
								pSV->m_Controls[j]->OnDefault();
						}
						break;

					case IDC_FORMAT_Compression:
						if (HIWORD(wParam) == CBN_SELCHANGE)
						{
							pSV->OnFormatChanged();
						}
						break;

					default:
						break;
				}

				//pSV->OnApplyChanges();
			}
			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->OnActivate();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						pSV->OnApplyChanges();
						break;

					case PSN_QUERYCANCEL:    
						// return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CAUDRECPMETHOD
 *
 *  @mfunc BOOL | CAudRecProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CAudRecProperties::SetDirty()
{
	PropSheet_Changed(GetParent(m_hDlg), m_hDlg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\cameracp.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.cpp | Source file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the control interface
 *    <i ITCameraControl>.
 ***************************************************************************/

#include "Precomp.h"

extern HINSTANCE ghInst; 

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | CCameraControlProperty | This
 *    method is the constructor for camera control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i ITCameraControl> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ITCameraControl* | pInterface | Specifies a pointer to the
 *    <i ITCameraControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ITCameraControl *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CCameraControlProperty::CCameraControlProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | ~CCameraControlProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::~CCameraControlProperty()
{
	FX_ENTRY("CCameraControlProperty::~CCameraControlProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get((TAPICameraControlProperty)m_IDProperty, &m_CurrentValue, (TAPIControlFlags*)&m_CurrentFlags)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld"), _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: m_pITCameraControl->Get failed Hr=0x%08lX"), _fx_, Hr));
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::SetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set((TAPICameraControlProperty)m_IDProperty, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld"), _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: m_pITCameraControl->Set failed Hr=0x%08lX"), _fx_, Hr));
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetRange")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange((TAPICameraControlProperty)m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags*)&m_CapsFlags)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: m_pITCameraControl->GetRange failed Hr=0x%08lX"), _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CCameraControlProperties | OnCreate | This
 *    method creates a new page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CCameraControlProperties::OnCreate(LPWSTR pszTitle)
{
    PROPSHEETPAGE psp;
    
	psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT | PSP_USETITLE;
    psp.hInstance     = ghInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_CameraControlProperties);
    psp.pszTitle      = pszTitle;
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | CCameraControlProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::CCameraControlProperties()
{
	FX_ENTRY("CCameraControlProperties::CCameraControlProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	m_pITCameraControl = NULL;
	m_NumProperties = NUM_CAMERA_CONTROLS;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | ~CCameraControlProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::~CCameraControlProperties()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::~CCameraControlProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnConnect | This
 *    method is called when the property page is connected to a TAPI object.
 *
 *  @parm ITStream* | pStream | Specifies a pointer to the <i ITStream>
 *    interface. It is used to QI for the <i ITCameraControl> interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnConnect(ITStream *pStream)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnConnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!pStream)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the camera control interface
	if (SUCCEEDED (Hr = pStream->QueryInterface(&m_pITCameraControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITCameraControl=0x%08lX"), _fx_, m_pITCameraControl));
	}
	else
	{
		m_pITCameraControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDisconnect()
{
	FX_ENTRY("CCameraControlProperties::OnDisconnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pITCameraControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITCameraControl->Release();
		m_pITCameraControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITCameraControl"), _fx_));
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CCameraControlProperties::OnActivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CCameraControlProperty(m_hDlg, IDC_Pan_Label, IDC_Pan_Minimum, IDC_Pan_Maximum, IDC_Pan_Default, IDC_Pan_Stepping, IDC_Pan_Edit, IDC_Pan_Slider, 0, TAPICameraControl_Pan, IDC_Pan_Auto, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_Pan] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_Pan]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CCameraControlProperty(m_hDlg, IDC_Tilt_Label, IDC_Tilt_Minimum, IDC_Tilt_Maximum, IDC_Tilt_Default, IDC_Tilt_Stepping, IDC_Tilt_Edit, IDC_Tilt_Slider, 0, TAPICameraControl_Tilt, IDC_Tilt_Auto, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_Tilt] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_Tilt]=0x%08lX"), _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CCameraControlProperty(m_hDlg, IDC_Roll_Label, IDC_Roll_Minimum, IDC_Roll_Maximum, IDC_Roll_Default, IDC_Roll_Stepping, IDC_Roll_Edit, IDC_Roll_Slider, 0, TAPICameraControl_Roll, IDC_Roll_Auto, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_Roll] failed - Out of memory"), _fx_));
		goto MyError1;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_Roll]=0x%08lX"), _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CCameraControlProperty(m_hDlg, IDC_Zoom_Label, IDC_Zoom_Minimum, IDC_Zoom_Maximum, IDC_Zoom_Default, IDC_Zoom_Stepping, IDC_Zoom_Edit, IDC_Zoom_Slider, 0, TAPICameraControl_Zoom, IDC_Zoom_Auto, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_Zoom] failed - Out of memory"), _fx_));
		goto MyError2;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_Zoom]=0x%08lX"), _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CCameraControlProperty(m_hDlg, IDC_Exposure_Label, IDC_Exposure_Minimum, IDC_Exposure_Maximum, IDC_Exposure_Default, IDC_Exposure_Stepping, IDC_Exposure_Edit, IDC_Exposure_Slider, 0, TAPICameraControl_Exposure, IDC_Exposure_Auto, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_Exposure] failed - Out of memory"), _fx_));
		goto MyError3;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_Exposure]=0x%08lX"), _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CCameraControlProperty(m_hDlg, IDC_Iris_Label, IDC_Iris_Minimum, IDC_Iris_Maximum, IDC_Iris_Default, IDC_Iris_Stepping, IDC_Iris_Edit, IDC_Iris_Slider, 0, TAPICameraControl_Iris, IDC_Iris_Auto, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_Iris] failed - Out of memory"), _fx_));
		goto MyError4;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_Iris]=0x%08lX"), _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CCameraControlProperty(m_hDlg, IDC_Focus_Label, IDC_Focus_Minimum, IDC_Focus_Maximum, IDC_Focus_Default, IDC_Focus_Stepping, IDC_Focus_Edit, IDC_Focus_Slider, 0, TAPICameraControl_Focus, IDC_Focus_Auto, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_Focus] failed - Out of memory"), _fx_));
		goto MyError5;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_Focus]=0x%08lX"), _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CCameraControlProperty(m_hDlg, 0, 0, 0, 0, 0, IDC_FlipVertical_Edit, 0, 0, TAPICameraControl_FlipVertical, 0, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_FlipVertical] failed - Out of memory"), _fx_));
		goto MyError6;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_FlipVertical]=0x%08lX"), _fx_, m_Controls[7]));
	}

	if (!(m_Controls[8] = new CCameraControlProperty(m_hDlg, 0, 0, 0, 0, 0, IDC_FlipHorizontal_Edit, 0, 0, TAPICameraControl_FlipHorizontal, 0, m_pITCameraControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[TAPICameraControl_FlipHorizontal] failed - Out of memory"), _fx_));
		goto MyError7;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[TAPICameraControl_FlipHorizontal]=0x%08lX"), _fx_, m_Controls[8]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError7:
	if (m_Controls[7])
		delete m_Controls[7], m_Controls[7] = NULL;
MyError6:
	if (m_Controls[6])
		delete m_Controls[6], m_Controls[6] = NULL;
MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::OnDeactivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnApplyChanges")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | BaseDlgProc | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
INT_PTR CALLBACK CCameraControlProperties::BaseDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    CCameraControlProperties *pSV = (CCameraControlProperties*)GetWindowLong(hDlg, DWL_USER);

	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)lParam;
				pSV = (CCameraControlProperties*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg, DWL_USER, (LPARAM)pSV);
				pSV->m_bInit = FALSE;
				pSV->OnActivate();
				pSV->m_bInit = TRUE;
				return TRUE;
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the Trackbar messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						pSV->SetDirty();
					}
				}
				pSV->OnApplyChanges();
			}
			break;

		case WM_COMMAND:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the auto checkbox messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < pSV->m_NumProperties; j++)
						{
							if (pSV->m_Controls[j])
								pSV->m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

				pSV->OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CCameraControlProperties::SetDirty()
{
	PropSheet_Changed(GetParent(m_hDlg), m_hDlg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\cameracp.h ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.h | Header file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the control interface
 *    <i ITCameraControl>.
 ***************************************************************************/

#define NUM_CAMERA_CONTROLS 9

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperty | This class implements handling of a
 *    single camera control property in a property page.
 *
 *  @mdata int | CCameraControlProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITCameraControl * | CCameraControlProperty | m_pInterface | Pointer
 *    to the <i ITCameraControl> interface.
***************************************************************************/
class CCameraControlProperty : public CPropertyEditor 
{
	public:
	CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ITCameraControl *pInterface);
	~CCameraControlProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();

	private:
	ITCameraControl *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperties | This class runs a property page to test
 *    the TAPI VfW Capture Filter <i ITCameraControl> implementation.
 *
 *  @mdata int | CCameraControlProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITCameraControl * | CCameraControlProperties | m_pITCameraControl | Pointer
 *    to the <i ITCameraControl> interface.
 *
 *  @mdata CCameraControlProperty * | CCameraControlProperties | m_Controls[NUM_CAMERA_CONTROLS] | Array
 *    of camera control properties.
***************************************************************************/
class CCameraControlProperties
{
	public:
	CCameraControlProperties();
	~CCameraControlProperties();

	HPROPSHEETPAGE OnCreate(LPWSTR pszTitle);

	HRESULT OnConnect(ITStream *pStream);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();

	private:

	void SetDirty();

	BOOL				m_bInit;
	HWND				m_hDlg;
	int					m_NumProperties;
	ITCameraControl		*m_pITCameraControl;
	CCameraControlProperty *m_Controls[NUM_CAMERA_CONTROLS];

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\precomp.h ===
/****************************************************************************
 *  @doc INTERNAL PRECOMP
 *
 *  @module Precomp.h | Master header file.
 ***************************************************************************/

#define UNICODE
#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <tapi3.h>
#include <strmif.h>
#include <control.h>
#include <commctrl.h>
#include <confpriv.h>
#include <h323priv.h>

#ifdef DbgLog
#undef DbgLog
#endif
#define DbgLog(s)

#ifdef FX_ENTRY
#undef FX_ENTRY
#endif
#define FX_ENTRY(s)
#ifdef _fx_
#undef _fx_
#endif
#define _fx_

#include "PropEdit.h"
#include "ProcAmpP.h"
#include "CameraCP.h"
#include "CaptureP.h"
#include "AudRecP.h"
#include "VDeviceP.h"
#include "NetworkP.h"
#include "SystemP.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\networkp.h ===
/****************************************************************************
 *  @doc INTERNAL NETWORKP
 *
 *  @module CaptureP.h | Header file for the <c CNetworkProperty>
 *    class used to implement a property page to test the TAPI control
 *    interface <i ITQualityControl>.
 ***************************************************************************/

#define NUM_NETWORK_CONTROLS			10
#define IDC_VideoOut_RTT				0
#define IDC_VideoOut_LossRate			1
#define IDC_VideoIn_RTT					2
#define IDC_VideoIn_LossRate			3
#define IDC_AudioOut_RTT				4
#define IDC_AudioOut_LossRate			5
#define IDC_AudioIn_RTT					6
#define IDC_AudioIn_LossRate			7
#define IDC_Video_PlayoutDelay			8
#define IDC_Audio_PlayoutDelay			9

/****************************************************************************
 *  @doc INTERNAL CNETWORKPCLASS
 *
 *  @class CNetworkProperty | This class implements handling of a
 *    single network property in a property page.
 *
 *  @mdata int | CNetworkProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControl* | CNetworkProperty | m_pITQualityControl | Pointer
 *    to the <i ITQualityControl> interface.
***************************************************************************/
class CNetworkProperty : public CPropertyEditor 
{
	public:
	CNetworkProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ITStreamQualityControl *pITQualityControl);
	~CNetworkProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();

	private:
	ITStreamQualityControl *m_pITQualityControl;
};

/****************************************************************************
 *  @doc INTERNAL CNETWORKPCLASS
 *
 *  @class CNetworkProperties | This class implements a property page
 *    to test the new TAPI control interface <i ITQualityControl>.
 *
 *  @mdata int | CNetworkProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControl* | CNetworkProperties | m_pITQualityControl | Pointer
 *    to the <i ITQualityControl> interface.
 *
 *  @mdata CNetworkProperty* | CNetworkProperties | m_Controls[NUM_NETWORK_CONTROLS] | Array
 *    of capture properties.
***************************************************************************/
class CNetworkProperties
{
	public:
	CNetworkProperties();
	~CNetworkProperties();

	HPROPSHEETPAGE OnCreate();

	HRESULT OnConnect(ITStream *pVideoInStream, ITStream *pVideoOutStream, ITStream *pAudioInStream, ITStream *pAudioOutStream);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();

	private:

	void SetDirty();

	BOOL						m_bInit;
	HWND						m_hDlg;
	int							m_NumProperties;
	ITStreamQualityControl			*m_pVideoInITQualityControl;
	ITStreamQualityControl			*m_pVideoOutITQualityControl;
	ITStreamQualityControl			*m_pAudioInITQualityControl;
	ITStreamQualityControl			*m_pAudioOutITQualityControl;

	CNetworkProperty *m_Controls[NUM_NETWORK_CONTROLS];

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\capturep.h ===
/****************************************************************************
 *  @doc INTERNAL CAPTUREP
 *
 *  @module CaptureP.h | Header file for the <c CCaptureProperty>
 *    class used to implement a property page to test the TAPI control
 *    interfaces <i ITFormatControl> and <i ITQualityControl>.
 ***************************************************************************/

#define NUM_CAPTURE_CONTROLS			4
#define IDC_Capture_Bitrate				0
#define IDC_Capture_FrameRate			1
#define IDC_Capture_CurrentBitrate		2
#define IDC_Capture_CurrentFrameRate	3

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPCLASS
 *
 *  @class CCaptureProperty | This class implements handling of a
 *    single capture property in a property page.
 *
 *  @mdata int | CCaptureProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControl* | CCaptureProperty | m_pITQualityControl | Pointer
 *    to the <i ITQualityControl> interface.
***************************************************************************/
class CCaptureProperty : public CPropertyEditor 
{
	public:
	CCaptureProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ITStreamQualityControl *pITQualityControl);
	~CCaptureProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();

	private:
	ITStreamQualityControl *m_pITQualityControl;
};

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPCLASS
 *
 *  @class CCaptureProperties | This class implements a property page
 *    to test the new TAPI control interfaces <i ITFormatControl> and
 *    <i ITQualityControl>.
 *
 *  @mdata int | CCaptureProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControl* | CCaptureProperties | m_pITQualityControl | Pointer
 *    to the <i ITQualityControl> interface.
 *
 *  @mdata ITFormatControl* | CCaptureProperties | m_pITFormatControl | Pointer
 *    to the <i ITFormatControl> interface.
 *
 *  @mdata CCaptureProperty* | CCaptureProperties | m_Controls[NUM_CAPTURE_CONTROLS] | Array
 *    of capture properties.
***************************************************************************/
class CCaptureProperties
{
	public:
	CCaptureProperties();
	~CCaptureProperties();

	HPROPSHEETPAGE OnCreate();

	HRESULT OnConnect(ITStream *pStream);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();

	private:

	void SetDirty();

	// Format manipulation methods
	HRESULT InitialRangeScan();
	HRESULT OnFormatChanged();
	HRESULT GetCurrentMediaType(void);
	HRESULT DeleteAMMediaType(AM_MEDIA_TYPE *pAMMT);

	BOOL						m_bInit;
	HWND						m_hDlg;
	int							m_NumProperties;
	ITStreamQualityControl			*m_pITQualityControl;
	ITFormatControl				*m_pITFormatControl;
	DWORD						m_dwRangeCount;
	TAPI_STREAM_CONFIG_CAPS		*m_CapsList;
	AM_MEDIA_TYPE				**m_FormatList;
	AM_MEDIA_TYPE				*m_CurrentMediaType;
	HWND						m_hWndFormat;
	DWORD						m_CurrentFormat;
	DWORD						m_OriginalFormat;

	CCaptureProperty *m_Controls[NUM_CAPTURE_CONTROLS];

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\capturep.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAPTUREP
 *
 *  @module CaptureP.cpp | Source file for the <c CCaptureProperty>
 *    class used to implement a property page to test the TAPI control
 *    interfaces <i ITFormatControl> and <i ITQualityControl>.
 ***************************************************************************/

#include "Precomp.h"

extern HINSTANCE ghInst;

// Returns the address of the BITMAPINFOHEADER from the VIDEOINFOHEADER
//#define HEADER(pVideoInfo) (&(((VIDEOINFOHEADER *) (pVideoInfo))->bmiHeader))

// Video subtypes
const GUID MEDIASUBTYPE_H263_V1 = {0x33363248L, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};
const GUID MEDIASUBTYPE_H261 = {0x31363248L, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};
const GUID MEDIASUBTYPE_H263_V2 = {0x3336324EL, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperty | CCaptureProperty | This
 *    method is the constructor for bitrate and frame rate property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    pointers to the <i ITQualityControl> interfaces.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ITQualityControl* | pITQualityControl | Specifies a pointer to the
 *    <i ITQualityControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperty::CCaptureProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ITStreamQualityControl *pITQualityControl)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, 0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CCaptureProperty::CCaptureProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointers are NULL, we'll grey the
	// associated items in the property page
	m_pITQualityControl = pITQualityControl;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperty | ~CCaptureProperty | This
 *    method is the destructor for capture property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperty::~CCaptureProperty()
{
	FX_ENTRY("CCaptureProperty::~CCaptureProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	TAPIControlFlags CurrentFlag;
	LONG Mode;

	FX_ENTRY("CCaptureProperty::GetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
	{									
		case IDC_Capture_FrameRate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Get(Quality_MaxStreamFrameRate, &CurrentValue, &CurrentFlag)))
			{
				// Displayed as fps
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentFrameRate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Get(Quality_CurrStreamFrameRate, &CurrentValue, &CurrentFlag)))
			{
				// Displayed as fps
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pAvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Capture_Bitrate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Get(Quality_MaxBitrate, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxBitrate=%ld, dwLayerId=0"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentBitrate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Get(Quality_CurrBitrate, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwCurrentBitrate=%ld, dwLayerId=0"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown capture property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;

	FX_ENTRY("CCaptureProperty::SetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
	{
		case IDC_Capture_FrameRate:
			// Displayed as fps
			if (m_CurrentValue)
				CurrentValue = 10000000 / m_CurrentValue;
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Set(Quality_MaxStreamFrameRate, CurrentValue, TAPIControl_Flags_None)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: AvgTimePerFrame=%ld"), _fx_, CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Capture_Bitrate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Set(Quality_MaxBitrate, m_CurrentValue, TAPIControl_Flags_None)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: dwMaxBitrate=%ld, dwLayerId=0"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentBitrate:
		case IDC_Capture_CurrentFrameRate:
			// This is a read-only property. Don't do anything.
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown capture property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;
	TAPIControlFlags CapsFlags;

	FX_ENTRY("CCaptureProperty::GetRange")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
	{
		case IDC_Capture_FrameRate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->GetRange(Quality_MaxStreamFrameRate, &Min, &Max, &SteppingDelta, &Default, &CapsFlags)))
			{
				// Displayed as fps
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentFrameRate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->GetRange(Quality_CurrStreamFrameRate, &Min, &Max, &SteppingDelta, &Default, &CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (LONG)(10000000 / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld"), _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Capture_Bitrate:
		case IDC_Capture_CurrentBitrate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->GetRange(Quality_MaxBitrate, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld, dwLayerId=0"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown capture property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CCaptureProperties | OnCreate | This
 *    method creates a new page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CCaptureProperties::OnCreate()
{
    PROPSHEETPAGE psp;
    
	psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = ghInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_CaptureFormatProperties);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperties | CCaptureProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperties::CCaptureProperties()
{
	FX_ENTRY("CCaptureProperties::CCaptureProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	m_pITQualityControl = NULL;
	m_pITFormatControl = NULL;
	m_NumProperties = NUM_CAPTURE_CONTROLS;
	m_hWndFormat = m_hDlg = NULL;
	m_dwRangeCount = 0;
	m_FormatList = NULL;
	m_CapsList = NULL;
	m_CurrentMediaType = NULL;
	m_CurrentFormat = 0;
	m_OriginalFormat = 0;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperties | ~CCaptureProperties | This
 *    method is the destructor for the capture pin property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperties::~CCaptureProperties()
{
	int		j;

	FX_ENTRY("CCaptureProperties::~CCaptureProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	// Free the list of formats
	if (m_FormatList)
	{
		for (DWORD dw=0; dw<m_dwRangeCount; dw++)
		{
			if (m_FormatList[dw])
			{
				// Release the memory allocated for the format structures
				DeleteAMMediaType(m_FormatList[dw]);
			}
		}
		delete[] m_FormatList, m_FormatList = NULL;
	}

	// Free the list of caps
	if (m_CapsList)
		delete[] m_CapsList, m_CapsList = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnConnect | This
 *    method is called when the property page is connected to a TAPI object.
 *
 *  @parm ITStream* | pStream | Specifies a pointer to the <i ITStream>
 *    interface. It is used to QI for the <i ITQualityControl> and
 *    <i ITFormatControl> interfaces.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnConnect(ITStream *pStream)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCaptureProperties::OnConnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!pStream)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the quality control interface
	if (SUCCEEDED (Hr = pStream->QueryInterface(__uuidof(ITStreamQualityControl), (void **)&m_pITQualityControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITQualityControl=0x%08lX"), _fx_, m_pITQualityControl));
	}
	else
	{
		m_pITQualityControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	// Get the format control interface
	if (SUCCEEDED (Hr = pStream->QueryInterface(__uuidof(ITFormatControl), (void **)&m_pITFormatControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITFormatControl=0x%08lX"), _fx_, m_pITFormatControl));
	}
	else
	{
		m_pITFormatControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device
	Hr = NOERROR;

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnDisconnect()
{
	FX_ENTRY("CCaptureProperties::OnDisconnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pITQualityControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITQualityControl->Release();
		m_pITQualityControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITQualityControl"), _fx_));
	}

	if (!m_pITFormatControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITFormatControl->Release();
		m_pITFormatControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITFormatControl"), _fx_));
	}

	// Release format memory
	if (m_CurrentMediaType)
	{
		DeleteAMMediaType(m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	// Free the list of formats
	if (m_FormatList)
	{
		for (DWORD dw=0; dw<m_dwRangeCount; dw++)
		{
			if (m_FormatList[dw])
			{
				// Release the memory allocated for the format structures
				DeleteAMMediaType(m_FormatList[dw]);
			}
		}
		delete[] m_FormatList, m_FormatList = NULL;
	}

	// Free the list of caps
	if (m_CapsList)
		delete[] m_CapsList, m_CapsList = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnActivate()
{
	HRESULT	Hr = NOERROR;
	DWORD	dw;
    int		i;
	TCHAR	buf[280];

	FX_ENTRY("CCaptureProperties::OnActivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Initialize format control structures
	m_hWndFormat = GetDlgItem(m_hDlg, IDC_FORMAT_Compression);

	// Disable everything if we didn't initialize correctly
	if (!m_pITFormatControl || (FAILED (Hr = InitialRangeScan())))
	{
		EnableWindow(m_hWndFormat, FALSE);
	}
	else
	{
		// Update the content of the format combo box
		ComboBox_ResetContent(m_hWndFormat);
		for (dw = 0; dw < m_dwRangeCount; dw++)
		{
			wsprintf(buf, L"%ls %ldx%ld", &m_CapsList[dw].VideoCap.Description, HEADER(m_FormatList[dw]->pbFormat)->biWidth, HEADER(m_FormatList[dw]->pbFormat)->biHeight);

			ComboBox_AddString(m_hWndFormat, buf);

			if (m_CurrentMediaType->subtype == m_FormatList[dw]->subtype && HEADER(m_CurrentMediaType->pbFormat)->biWidth == HEADER(m_FormatList[dw]->pbFormat)->biWidth  && HEADER(m_CurrentMediaType->pbFormat)->biHeight == HEADER(m_FormatList[dw]->pbFormat)->biHeight)
			{
				ComboBox_SetCurSel(m_hWndFormat, dw);
			}
		}

		// Update current format
		OnFormatChanged();

		// Remember the original format
		m_OriginalFormat = m_CurrentFormat;
	}

	// Create the controls for the properties
	if (m_Controls[0] = new CCaptureProperty(m_hDlg, IDC_BitrateControl_Label, IDC_BitrateControl_Minimum, IDC_BitrateControl_Maximum, IDC_BitrateControl_Default, IDC_BitrateControl_Stepping, IDC_BitrateControl_Edit, IDC_BitrateControl_Slider, 0, IDC_Capture_Bitrate, m_pITQualityControl))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[0]=0x%08lX"), _fx_, m_Controls[0]));

		if (m_Controls[1] = new CCaptureProperty(m_hDlg, IDC_FrameRateControl_Label, IDC_FrameRateControl_Minimum, IDC_FrameRateControl_Maximum, IDC_FrameRateControl_Default, IDC_FrameRateControl_Stepping, IDC_FrameRateControl_Edit, IDC_FrameRateControl_Slider, 0, IDC_Capture_FrameRate, m_pITQualityControl))
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[1]=0x%08lX"), _fx_, m_Controls[1]));

			if (m_Controls[2] = new CCaptureProperty(m_hDlg, 0, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, IDC_Capture_CurrentFrameRate, m_pITQualityControl))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[2]=0x%08lX"), _fx_, m_Controls[2]));

				if (m_Controls[3] = new CCaptureProperty(m_hDlg, 0, 0, 0, 0, 0, IDC_BitrateControl_Actual, 0, IDC_BitrateControl_Meter, IDC_Capture_CurrentBitrate, m_pITQualityControl))
				{
					DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[3]=0x%08lX"), _fx_, m_Controls[3]));
				}
				else
				{
					DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Out of memory"), _fx_));
					delete m_Controls[0], m_Controls[0] = NULL;
					delete m_Controls[1], m_Controls[1] = NULL;
					delete m_Controls[2], m_Controls[2] = NULL;
					Hr = E_OUTOFMEMORY;
					goto MyExit;
				}
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Out of memory"), _fx_));
				delete m_Controls[0], m_Controls[0] = NULL;
				delete m_Controls[1], m_Controls[1] = NULL;
				Hr = E_OUTOFMEMORY;
				goto MyExit;
			}
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Out of memory"), _fx_));
			delete m_Controls[0], m_Controls[0] = NULL;
			Hr = E_OUTOFMEMORY;
			goto MyExit;
		}
	}
	else
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Out of memory"), _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (i = 0; i < m_NumProperties; i++)
	{
		if (m_Controls[i]->Init())
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, i));
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, i));
		}
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CCaptureProperties::OnDeactivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | GetCurrentMediaType | This
 *    method is used to retrieve the current media format used by the pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::GetCurrentMediaType(void)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCaptureProperties::GetCurrentMediaType")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	if (m_CurrentMediaType)
	{
		DeleteAMMediaType(m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	if (FAILED (Hr = m_pITFormatControl->GetCurrentFormat((AM_MEDIA_TYPE **)&m_CurrentMediaType)))
	{
		// Otherwise, just get the first enumerated media type
		TAPI_STREAM_CONFIG_CAPS RangeCaps;
		BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

		if (FAILED (Hr = m_pITFormatControl->GetStreamCaps(0, (AM_MEDIA_TYPE **)&m_CurrentMediaType, &RangeCaps, &fEnabled)))
		{
			m_CurrentMediaType = NULL;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | DeleteAMMediaType | This
 *    method is used to delete a task-allocated AM_MEDIA_TYPE structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 *
 *  @comm There is a DShow DeleteMediaType, but it'd be pretty dumb to link to
 *    strmbase.lib just for this little guy, would it?
 ***************************************************************************/
HRESULT CCaptureProperties::DeleteAMMediaType(AM_MEDIA_TYPE *pAMMT)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCaptureProperties::DeleteAMMediaType")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

    if (pAMMT)
	{
		if (pAMMT->cbFormat != 0 && pAMMT->pbFormat)
		{
			CoTaskMemFree((PVOID)pAMMT->pbFormat);
		}
		if (pAMMT->pUnk != NULL)
		{
			pAMMT->pUnk->Release();
		}
	}

    CoTaskMemFree((PVOID)pAMMT