**************************************************************************

BOOL CUntypedValue::StoreToCVar(CType Type, CVar& Var, CFastHeap* pHeap, BOOL fOptimize /* = FALSE */)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    int nActual = Type.GetActualType();
    if(Type.IsArray())
    {
        Type_t nBasicType = Type.GetBasic();

        // Find array on the heap
        // ======================

        CUntypedArray* pArray = (CUntypedArray*)pHeap->ResolveHeapPointer(
            AccessPtrData());

        // Have array store itself (making copies of all but strings)
        // into the vector
        // ==========================================================

        CVarVector* pVector = pArray->CreateCVarVector(nBasicType, pHeap);

        if ( NULL != pVector )
        {
            Var.SetVarVector(pVector, TRUE); // acquires the pointer
        }

        return ( NULL != pVector );
    }
    else if(nActual == CIM_STRING || nActual == CIM_REFERENCE ||
        nActual == CIM_DATETIME)
    {
        CCompressedString* pString = pHeap->ResolveString(AccessPtrData());

		if ( fOptimize )
		{
			BSTR	bstr = pString->CreateBSTRCopy();

			if ( NULL != bstr )
			{
				Var.SetRaw( VT_BSTR, (void*) &bstr, sizeof(BSTR) );
				Var.SetCanDelete( FALSE );
			}
			else
			{
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return pString->StoreToCVar(Var);
		}
    }
    else if(nActual == CIM_OBJECT)
    {
        // No allocations performed here so we should be ok
        CEmbeddedObject* pObj = (CEmbeddedObject*)pHeap->ResolveHeapPointer(
            AccessPtrData());
        pObj->StoreToCVar(Var);
        return TRUE;
    }
    else if(nActual == CIM_SINT64)
    {
        // Max size is 20 chars plus 1 for NULL terminator
        WCHAR wsz[22];

        // NULL terminate in case not enough characters
        _snwprintf(wsz, 21, L"%I64d", *(UNALIGNED WBEM_INT64*)GetRawData());
        wsz[21] = L'\0';

		if ( fOptimize )
		{
			BSTR	bstr = SysAllocString( wsz );

			if ( NULL != bstr )
			{
				Var.SetRaw( VT_BSTR, (void*) &bstr, sizeof(BSTR) );
				Var.SetCanDelete( FALSE );
			}
			else
			{
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return Var.SetBSTR(wsz);
		}
    }
    else if(nActual == CIM_UINT64)
    {
        // Max size is 20 chars plus 1 for NULL terminator
        WCHAR wsz[22];

        // NULL terminate in case not enough characters
        _snwprintf(wsz, 21, L"%I64u", *(UNALIGNED WBEM_INT64*)GetRawData());
        wsz[21] = L'\0';
		if ( fOptimize )
		{
			BSTR	bstr = SysAllocString( wsz );

			if ( NULL != bstr )
			{
				Var.SetRaw( VT_BSTR, (void*) &bstr, sizeof(BSTR) );
				Var.SetCanDelete( FALSE );
			}
			else
			{
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return Var.SetBSTR(wsz);
		}
    }
    else if(nActual == CIM_UINT16)
    {
        Var.SetLong(*(UNALIGNED unsigned short*)GetRawData());
        return TRUE;
    }
    else if(nActual == CIM_SINT8)
    {
        Var.SetShort(*(char*)GetRawData());
        return TRUE;
    }
    else if(nActual == CIM_UINT32)
    {
        Var.SetLong(*(UNALIGNED unsigned long*)GetRawData());
        return TRUE;
    }
    else if(nActual == CIM_CHAR16)
    {
        Var.SetShort(*(UNALIGNED short*)GetRawData());
        return TRUE;
    }
    else
    {
        // At first glance it doesn't appear memory is allocated here
        Var.SetRaw(Type.GetVARTYPE(), (void*)GetRawData(), Type.GetLength());
        return TRUE;
    }
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
HRESULT CUntypedValue::LoadFromCVar(CPtrSource* pThis, CVar& Var,
                                    CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld)
{
    return LoadFromCVar(pThis, Var, Var.GetOleType(), pHeap, nReturnType, bUseOld);
}

BOOL CUntypedValue::DoesTypeNeedChecking(Type_t nInherentType)
{
    switch(nInherentType)
    {
    case CIM_UINT8:
    case CIM_SINT16:
    case CIM_SINT32:
    case CIM_REAL32:
    case CIM_REAL64:
    case CIM_STRING:
    case CIM_REFERENCE:
    case CIM_OBJECT:
        return FALSE;
    default:
        return TRUE;
    }
}

BOOL CUntypedValue::CheckCVar(CVar& Var, Type_t nInherentType)
{
    // Check the type
    // ==============

    if(Var.IsNull())
        return TRUE;

    if(nInherentType == 0)
        nInherentType = CType::VARTYPEToType( (VARTYPE) Var.GetOleType());
    if(!CType::DoesCIMTYPEMatchVARTYPE(nInherentType, (VARTYPE) Var.GetOleType()))
    {
        // Attempt coercion
        // ================

        // Special case: if the type is CIM_CHAR16, we coerce strings
        // differently!
        // ==========================================================

        // Special case: if the type is CIM_UINT32, we coerce strings
        // as a VT_UI4 or we lose half the possible values (our
        // VARType is actually VT_I4
        // ==========================================================

        // This could throw an exception
        try
        {
            if(CType::GetBasic(nInherentType) == CIM_CHAR16)
            {
                if(!Var.ToSingleChar())
                    return FALSE;
            }
            else if(CType::GetBasic(nInherentType) == CIM_UINT32)
            {
                if(!Var.ToUI4())
                    return FALSE;
            }
            else
            {
                if(!Var.ChangeTypeTo(CType::GetVARTYPE(nInherentType)))
                    return FALSE;
            }
        }
        catch(...)
        {
            return FALSE;
        }
    }

    if(Var.GetType() == VT_EX_CVARVECTOR)
    {
        return CUntypedArray::CheckCVarVector(*Var.GetVarVector(),
                                                nInherentType);
    }
    else if(Var.GetType() == VT_LPWSTR || Var.GetType() == VT_BSTR)
    {
        if(nInherentType == CIM_SINT64)
        {
            __int64 i64;
            if(!ReadI64(Var.GetLPWSTR(), i64))
                return FALSE;
        }
        else if(nInherentType == CIM_UINT64)
        {
            unsigned __int64 ui64;
            if(!ReadUI64(Var.GetLPWSTR(), ui64))
            {
                // give last chance with signed
                //__int64 i64;
	            //if(!ReadI64(Var.GetLPWSTR(), i64))
    	            return FALSE;                
            }
        }
        else if(nInherentType == CIM_UINT32)
        {
            __int64 i64;
            if(!ReadI64(Var.GetLPWSTR(), i64))
                return FALSE;

            if(i64 < 0 || i64 > 0xFFFFFFFF)
                return FALSE;
        }
    }
    else if(Var.GetType() == VT_EMBEDDED_OBJECT)
    {
    }
    else if(nInherentType == CIM_SINT8)
    {
        if(Var.GetShort() > 127 || Var.GetShort() < -128)
              return FALSE;
    }
    else if(nInherentType == CIM_UINT16)
    {
        if(Var.GetLong() >= (1 << 16) || Var.GetLong() < 0)
            return FALSE;
    }
    else if(nInherentType == CIM_UINT32)
    {
    }
    else if(nInherentType == CIM_BOOLEAN)
    {
        // GetBool() MUST return 0, -1 or 1
        if ( Var.GetBool() != VARIANT_FALSE && Var.GetBool() != VARIANT_TRUE
            && -(Var.GetBool()) != VARIANT_TRUE )
            return FALSE;

    }
    else if( nInherentType == CIM_DATETIME )
    {
#ifdef UNICODE
        if ( !CDateTimeParser::CheckDMTFDateTimeFormat( Var.GetLPWSTR() ) )
        {
            return CDateTimeParser::CheckDMTFDateTimeInterval( Var.GetLPWSTR() );
        }
#else
        char *pStr = NULL;
        if ( !AllocWCHARToMBS( Var.GetLPWSTR(), &pStr ) )
            return FALSE;
        CDeleteMe<char> delMe(pStr);

        if ( !CDateTimeParser::CheckDMTFDateTimeFormat( pStr ) )
        {
            return CDateTimeParser::CheckDMTFDateTimeInterval( pStr );
        }
#endif
        else
        {
            return TRUE;
        }
    }
    else if(nInherentType == CIM_CHAR16)
    {
    }
    else
    {
        // Normal data
        // ===========
    }

    return TRUE;
}

BOOL CUntypedValue::CheckIntervalDateTime(CVar& Var)
{

    if(Var.GetType() == VT_EX_CVARVECTOR)
    {
        return CUntypedArray::CheckIntervalDateTime( *Var.GetVarVector() );
    }

    if ( Var.GetType() == VT_LPWSTR || Var.GetType() == VT_BSTR )
    {
#ifdef UNICODE
        return CDateTimeParser::CheckDMTFDateTimeInterval( Var.GetLPWSTR() );
#else
        char *pStr = NULL;
        if ( !AllocWCHARToMBS( Var.GetLPWSTR(), &pStr ) )
            return FALSE;
        CDeleteMe<char> delMe(pStr);

        return CDateTimeParser::CheckDMTFDateTimeInterval( pStr );
#endif
    }

    return FALSE;
}

HRESULT CUntypedValue::LoadFromCVar(CPtrSource* pThis, CVar& Var,
                                    Type_t nInherentType,
                                    CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    if(Var.GetType() == VT_EX_CVARVECTOR)
    {
        // Examine the vector
        // ==================

        CVarVector* pVector = Var.GetVarVector();
        int nArrayLen = CUntypedArray::CalculateNecessarySpaceByType(
            CType::MakeNotArray(nInherentType), pVector->Size());

        // Allocate appropriate array on the heap
        // ======================================

        heapptr_t ptrArray;
        if(bUseOld)
        {
            CUntypedArray* pArray =
              (CUntypedArray*)pHeap->ResolveHeapPointer(pThis->AccessPtrData());

            // Check for allocation failure
            if ( !pHeap->Reallocate(pThis->AccessPtrData(),
                          pArray->GetLengthByType(CType::MakeNotArray(nInherentType)),
                          nArrayLen,
                          ptrArray) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            // Check for allocation failure
            if ( !pHeap->Allocate(nArrayLen, ptrArray) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

		// A boy and his virtual functions.  This is what makes everything work in case
		// the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
		// overloaded so we can always fix ourselves up to the underlying BLOB.

        CHeapPtr ArrayPtr(pHeap, ptrArray);

        // Copy data
        // =========

        // Check for failures along the way
        Type_t  nType;
        HRESULT hr = CUntypedArray::LoadFromCVarVector(&ArrayPtr, *pVector,
                        nInherentType, pHeap, nType, bUseOld);
        if ( FAILED( hr ) )
        {
            return hr;
        }

        pThis->AccessPtrData() = ptrArray;
        nReturnType = CType::MakeArray(nType);
        return WBEM_S_NO_ERROR;
    }
    else if(Var.GetType() == VT_LPWSTR || Var.GetType() == VT_BSTR)
    {
        if(nInherentType == CIM_SINT64)
        {
            if(!ReadI64(Var.GetLPWSTR(), *(UNALIGNED __int64*)pThis->GetPointer()))
            {
                nReturnType = CIM_ILLEGAL;
            }
            else
            {
                nReturnType = CIM_SINT64;
            }
            return WBEM_S_NO_ERROR;
        }
        else if(nInherentType == CIM_UINT64)
        {
            if(!ReadUI64(Var.GetLPWSTR(),
                    *(UNALIGNED unsigned __int64*)pThis->GetPointer()))
            {
				// last chance
                //if(!ReadI64(Var.GetLPWSTR(),
                //    *(UNALIGNED __int64*)pThis->GetPointer()))
                //{                
                    nReturnType = CIM_ILLEGAL;
                //}
                //else
                //{
                //    nReturnType = CIM_UINT64;
                //}
            }
            else
            {
                nReturnType = CIM_UINT64;
            }
            return WBEM_S_NO_ERROR;
        }
        else if(nInherentType == CIM_UINT32)
        {
            __int64 i64;
            if(!ReadI64(Var.GetLPWSTR(), i64))
            {
                nReturnType = CIM_ILLEGAL;
            }
            else if(i64 < 0 || i64 > 0xFFFFFFFF)
            {
                nReturnType = CIM_ILLEGAL;
            }
            else
            {
                *(UNALIGNED DWORD*)pThis->GetPointer() = (DWORD)i64;
                nReturnType = CIM_UINT32;
            }
            return WBEM_S_NO_ERROR;
        }
        else if(nInherentType == CIM_DATETIME)
        {
            // Don't let it through if it doesn't match the proper format
#ifdef UNICODE
            if ( !CDateTimeParser::CheckDMTFDateTimeFormat( Var.GetLPWSTR() ) )
            {
                if ( !CDateTimeParser::CheckDMTFDateTimeInterval( Var.GetLPWSTR() ) )
#else
            char *pStr = NULL;
            if ( !AllocWCHARToMBS( Var.GetLPWSTR(), &pStr ) )
                return FALSE;
            CDeleteMe<char> delMe(pStr);

            if ( !CDateTimeParser::CheckDMTFDateTimeFormat( pStr ) )
            {
                if ( !CDateTimeParser::CheckDMTFDateTimeInterval( pStr ) )
#endif
                {
                    nReturnType = CIM_ILLEGAL;
                    return WBEM_E_TYPE_MISMATCH;
                }
            }
        }

        // Create compressed string on the heap
        // ====================================

        if(bUseOld && !pHeap->IsFakeAddress(pThis->AccessPtrData()))
        {
            // Check if there is enough space in the old location
            // ==================================================

            CCompressedString* pcsOld =
                pHeap->ResolveString(pThis->AccessPtrData());
            if(pcsOld->GetLength() >=
                CCompressedString::ComputeNecessarySpace(Var.GetLPWSTR()))
            {
                // Reuse old location
                // ==================

                pcsOld->SetFromUnicode(Var.GetLPWSTR());
                nReturnType = nInherentType;
                return WBEM_S_NO_ERROR;
            }
            else
            {
                // Since we were asked to reuse, it is our job to Free
                // ===================================================

                pHeap->FreeString(pThis->AccessPtrData());
            }
        }

        // Check for allocation failure here
        heapptr_t ptrTemp;
        if ( !pHeap->AllocateString(Var.GetLPWSTR(), ptrTemp ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pThis->AccessPtrData() = ptrTemp;
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
    else if(Var.GetType() == VT_EMBEDDED_OBJECT)
    {
		// Don't store anything here
		if ( nInherentType == CIM_IUNKNOWN )
		{
			nReturnType = nInherentType;
			return WBEM_S_NO_ERROR;
		}

		// If we can't get a WbemObject out of here, we give up
		IUnknown*	pUnk = Var.GetUnknown();
		CReleaseMe	rm(pUnk);

		CWbemObject*	pWbemObject = NULL;
		HRESULT	hr = CWbemObject::WbemObjectFromCOMPtr( pUnk, &pWbemObject );
		CReleaseMe	rm2( (_IWmiObject*) pWbemObject);
		if ( FAILED( hr ) )
		{
			return hr;
		}

        length_t nLength = CEmbeddedObject::EstimateNecessarySpace( pWbemObject );
        heapptr_t ptrTemp;
        if(bUseOld)
        {
            CEmbeddedObject* pOldObj =
                (CEmbeddedObject*)pHeap->ResolveHeapPointer(
                                                pThis->AccessPtrData());
            length_t nOldLength = pOldObj->GetLength();

            // Check for allocation failure
            if ( !pHeap->Reallocate(pThis->AccessPtrData(), nOldLength,
                            nLength, ptrTemp) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            // Check for allocation failure
            if ( !pHeap->Allocate(nLength, ptrTemp) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        CEmbeddedObject* pObj =
            (CEmbeddedObject*)pHeap->ResolveHeapPointer(ptrTemp);
        pObj->StoreEmbedded(nLength, pWbemObject);
        pThis->AccessPtrData() = ptrTemp;
        nReturnType = CIM_OBJECT;
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_SINT8)
    {
        if(Var.GetShort() > 127 || Var.GetShort() < -128)
        {
            nReturnType = CIM_ILLEGAL;
        }
        else
        {
            *(char*)pThis->GetPointer() = (char)Var.GetShort();
            nReturnType = nInherentType;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_UINT16)
    {
        if(Var.GetLong() >= (1 << 16) || Var.GetLong() < 0)
        {
            nReturnType = CIM_ILLEGAL;
        }
        else
        {
            *(UNALIGNED unsigned short*)pThis->GetPointer() = (unsigned short)Var.GetLong();
            nReturnType = nInherentType;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_UINT32)
    {
        *(UNALIGNED unsigned long*)pThis->GetPointer() = Var.GetLong();
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_BOOLEAN)
    {
        // GetBool() MUST return 0, -1 or 1
        if ( Var.GetBool() != VARIANT_FALSE && Var.GetBool() != VARIANT_TRUE
            && -(Var.GetBool()) != VARIANT_TRUE )
        {
            nReturnType = CIM_ILLEGAL;
        }
        else
        {
            *(UNALIGNED VARIANT_BOOL*)pThis->GetPointer() =
                (Var.GetBool() ? VARIANT_TRUE : VARIANT_FALSE);
            nReturnType = nInherentType;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_CHAR16)
    {
        *(UNALIGNED short*)pThis->GetPointer() = Var.GetShort();
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
    else
    {
        // Normal data
        // ===========

		LPVOID	pData = pThis->GetPointer();
		LPVOID	pNewData = Var.GetRawData();
		int		nLength = CType::GetLength(Var.GetType());

        memcpy(pThis->GetPointer(), Var.GetRawData(),
            CType::GetLength(Var.GetType()));
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
}

// Loads a user supplied buffer with a CVar
HRESULT CUntypedValue::LoadUserBuffFromCVar( Type_t type, CVar* pVar, ULONG uBuffSize,
											ULONG* puBuffSizeUsed, LPVOID pBuff )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( CType::IsNonArrayPointerType( type ) )
	{
		if ( CType::IsStringType( type ) )
		{
			ULONG	uLength = ( wcslen( (LPWSTR) *pVar )  + 1 ) * 2;

			// Store the required size
			*puBuffSizeUsed = uLength;

			// Copy the string if we've got the room
			if ( uBuffSize >= uLength && NULL != pBuff )
			{
				wcscpy( (LPWSTR) pBuff, (LPWSTR) *pVar );
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
		}
		else
		{

			ULONG	uLength = sizeof(IUnknown*);

			// Store the required size
			*puBuffSizeUsed = uLength;

			// Copy the value if we've got the room
			if ( uBuffSize >= uLength && NULL != pBuff )
			{
				*((IUnknown**) pBuff) = pVar->GetUnknown();
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
		} 
	}
	else
	{
    	if(CIM_SINT64 == type)
        {
			ULONG	uLength = sizeof(__int64);
			*puBuffSizeUsed = uLength;

			if ( uBuffSize >= uLength && NULL != pBuff )
			{
                __int64 i64;
                if(!ReadI64(pVar->GetLPWSTR(), i64))
                    hr = WBEM_E_ILLEGAL_OPERATION;
                else
				  *((__int64 *)pBuff) = i64;
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
        }
        else if(CIM_UINT64 == type)
        {
			ULONG	uLength = sizeof(unsigned __int64);
			*puBuffSizeUsed = uLength;

			if ( uBuffSize >= uLength && NULL != pBuff )
			{
                unsigned __int64 ui64;
                if(!ReadUI64(pVar->GetLPWSTR(), ui64))
                    hr = WBEM_E_ILLEGAL_OPERATION;
                else
				  *((unsigned __int64 *)pBuff) = ui64;
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}        
        }		
        else
        {
			ULONG	uLength = CType::GetLength( type );

			// Store the required size
			*puBuffSizeUsed = uLength;

			if ( uBuffSize >= uLength && NULL != pBuff )
			{
				// Copy the raw bytes and we're done
				CopyMemory( pBuff, pVar->GetRawData(), uLength );
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
        }
	}	// It's a basic type

	return hr;
}

HRESULT CUntypedValue::FillCVarFromUserBuffer( Type_t type, CVar* pVar, ULONG uBuffSize, LPVOID pData )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// We don't support setting arrays, unless the property is being NULLed out
	if ( CType::IsArray( type ) && NULL != pData  )
	{
		hr = WBEM_E_ILLEGAL_OPERATION;
	}
	else
	{
		CVar	var;

		// Setup the CVar 
		if ( NULL == pData )
		{
			pVar->SetAsNull();
		}
		else if ( CType::IsStringType( type ) )
		{
			// The number of bytes must be divisible by 2, >= 2 and
			// the character in the buffer at the end must be a NULL.
			// This will be faster than doing an lstrlen.

			if (    ( uBuffSize < 2 ) ||
					( uBuffSize % 2 ) ||
					( ((LPWSTR) pData)[uBuffSize/2 - 1] != 0 ) )
				return WBEM_E_INVALID_PARAMETER;

			pVar->SetLPWSTR( (LPWSTR) pData );
		}
		else if ( CIM_OBJECT == type )
		{
			// Validate the buffer seize
			if ( uBuffSize != sizeof(_IWmiObject*) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			pVar->SetUnknown( *((IUnknown**) pData) );
		}
		else if ( CIM_UINT64 == type ||
				CIM_SINT64 == type )
		{
			// Validate the buffer size
			if ( uBuffSize != sizeof(__int64) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			// We need to convert to a string and set the LPWSTR value
			WCHAR*	pwcsTemp = new WCHAR[128];

			if ( NULL != pwcsTemp )
			{
				if ( CIM_SINT64 == type )
				{
					swprintf( pwcsTemp, L"%I64d", *((__int64*) pData) );
				}
				else
				{
					swprintf( pwcsTemp, L"%I64u", *((unsigned __int64*) pData) );
				}

				// This will delete the array  when it is cleared
				pVar->SetLPWSTR( pwcsTemp, TRUE );
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else if ( CIM_SINT8 == type )
		{
			// Validate the buffer size
			if ( uBuffSize != CType::GetLength( type ) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			// We must fake up two bytes or subsequent checks may fail
			// If the value is negative we need to add an extra FF

			BYTE	bTemp[2];
			bTemp[0] = *((LPBYTE) pData);

			if ( bTemp[0] > 0x8F )
			{
				bTemp[1] = 0xFF;
			}
			else
			{
				bTemp[1] = 0;
			}

			pVar->SetRaw( VT_I2, bTemp, 2 );
		}
		else
		{
			// Validate the buffer size
			if ( uBuffSize != CType::GetLength( type ) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			pVar->SetRaw( CType::GetVARTYPE( type ), pData, CType::GetLength( type ) );
		}

	}

	return hr;
}


//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************

BOOL CUntypedValue::TranslateToNewHeap(CPtrSource* pThis,
                                              CType Type, CFastHeap* pOldHeap,
                                              CFastHeap* pNewHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    if(Type.IsArray())
    {
        // Check for allocation failure
        heapptr_t ptrTemp;
        if ( !CUntypedArray::CopyToNewHeap(
                  pThis->AccessPtrData(), Type.GetBasic(), pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        pThis->AccessPtrData() = ptrTemp;
    }
    else if(Type.GetBasic() == CIM_STRING ||
        Type.GetBasic() == CIM_DATETIME || Type.GetBasic() == CIM_REFERENCE)
    {
        // Check for allocation failures
        heapptr_t ptrTemp;

        if ( !CCompressedString::CopyToNewHeap(
                pThis->AccessPtrData(), pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        pThis->AccessPtrData() = ptrTemp;
    }
    else if(Type.GetBasic() == CIM_OBJECT)
    {
        // Check for allocation failures
        heapptr_t ptrTemp;

        if ( !CEmbeddedObject::CopyToNewHeap(
                pThis->AccessPtrData(), pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        pThis->AccessPtrData() = ptrTemp;
    }

    return TRUE;
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
BOOL CUntypedValue::CopyTo(CPtrSource* pThis, CType Type,
                                  CPtrSource* pDest,
                                  CFastHeap* pOldHeap, CFastHeap* pNewHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    memcpy(pDest->GetPointer(), pThis->GetPointer(), Type.GetLength());
    if(pOldHeap != pNewHeap)
    {
        // Check for allocation problems.
        return CUntypedValue::TranslateToNewHeap(pDest, Type, pOldHeap, pNewHeap);
    }

    // Old Heap and New Heap are the same so we "succeeded"
    return TRUE;
}

//*****************************************************************************
//*****************************************************************************
//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
 int CTypedValue::Compare(VARIANT* pVariant, CFastHeap* pHeap)
{
    if(Type.GetVARTYPE() != V_VT(pVariant)) return 0x7FFFFFFF;

    if(Type.IsArray())
    {
        // Comparison of arrays: TBD!!!!
        // =============================
        return 0x7FFFFFFF;
    }

    switch(Type.GetActualType())
    {
    case CIM_STRING:
        return pHeap->ResolveString(AccessPtrData())->
            Compare(V_BSTR(pVariant));
    case CIM_SINT64:
        return 0x7FFFFFFF; // TBD!!!!
    case CIM_UINT64:
        return 0x7FFFFFFF; // TBD!!!!
    case CIM_SINT32:
        return *(UNALIGNED long*)GetRawData() - V_I4(pVariant);
    case CIM_UINT32:

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We now treat all values
        // as __int64, and explicitly return 32-bit values.
        
        return ( (__int64)*(UNALIGNED DWORD*)GetRawData() - (__int64)(DWORD)V_I4(pVariant) < 0 ? -1
            : (__int64)*(UNALIGNED DWORD*)GetRawData() - (__int64)(DWORD)V_I4(pVariant) == 0 ? 0 : 1 );

    case CIM_SINT16:
    case CIM_CHAR16:
        return *(short*)GetRawData() - V_I2(pVariant);
    case CIM_UINT16:
        return (int)*(unsigned short*)GetRawData() -
                (int)(unsigned short)V_I2(pVariant);
    case CIM_UINT8:
        return (int)*(unsigned char*)GetRawData() - (int)V_UI1(pVariant);
    case CIM_SINT8:
        return (int)*(unsigned char*)GetRawData() - (char)V_UI1(pVariant);
    case CIM_REAL32:
        // DEVNOTE:TODO:SJS - Can this ever return 0?
        return (*(UNALIGNED float*)GetRawData() - V_R4(pVariant) < 0)?-1:1;
    case CIM_REAL64:
        // DEVNOTE:TODO:SJS - Can this ever return 0?
        return (*(UNALIGNED double*)GetRawData() - V_R8(pVariant) < 0)?-1:1;
    case CIM_OBJECT:
        return 0x7FFFFFFF; // compare embedded: TBD!!!
    }
    return 0x7FFFFFFF;
}




//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
CVarVector* CUntypedArray::CreateCVarVector(CType Type, CFastHeap* pHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.

    CVarVector* pVector = NULL;

    // Allocate CVarVector of the right type and length
    // ================================================

    try
    {
        // Allocation failure will throw an exception
        pVector = new CVarVector();
		
        if ( NULL != pVector )
        {
			// We want the pVector to sit directly on top of a SAFEARRAY, hence it
			// will be optimized.

			VARTYPE	vartype = Type.GetVARTYPE();

			if ( pVector->MakeOptimized( vartype, GetNumElements() ) )
			{
				int nSize = Type.GetLength();
				LPMEMORY pCurrentElement = GetElement(0, nSize);

				// if this is a non-pointer, non-BOOL, non __int64 type, we can do a direct
				// memory copy if the element size and the storage size are the same
				if ( !Type.IsPointerType() &&
					vartype != VT_BSTR &&
					vartype != VT_BOOL &&
					pVector->GetElementSize() == nSize )	// Make sure the storage size and the returned
															// size are the same
				{
					// Set the array directly

					HRESULT	hr = pVector->SetRawArrayData( pCurrentElement, GetNumElements(), nSize );

					if ( FAILED( hr ) )
					{
						delete pVector;
						return NULL;
					}

				}
				else	// We need to go through 1 element at a time
				{
					HRESULT	hr = WBEM_S_NO_ERROR;
					void*	pvData = NULL;
					CUnaccessVarVector	uvv;

					// We'll use direct array access for BSTRs
					// and Embedded Objects
					if ( vartype == VT_BSTR ||
						vartype == VT_UNKNOWN )
					{
						hr = pVector->AccessRawArray( &pvData );
						if ( FAILED( hr ) )
						{
							delete pVector;
							return NULL;
						}
						uvv.SetVV( pVector );
					}

					// For each element, get the CVar, which will perform the
					// appropriate conversions and then place the data in the
					// array using the most appropriate means.

					for(int i = 0; i < GetNumElements(); i++)
					{
						// Cast our element into an untyped value
						// ======================================

						CUntypedValue* pValue = (CUntypedValue*)pCurrentElement;

						// Create a corresponding CVar and add it to the vector
						// ====================================================

						CVar	var;
                
						try
						{
							// When we store to the CVar, since we are using var
							// as a pass-through, we only need to access the data
							// in pass-through fashion, so we will ask for the function
							// to optimize for us.

							// By asking for Optimized Data, we are forcing BSTRs to be allocated directly
							// from Compressed strings so that we can SPLAT them directly into a safe array
							// If this is done properly, the safe array will cleanup the BSTRs when it is
							// deleted.

							if ( !pValue->StoreToCVar(Type, var, pHeap, TRUE) )
							{
								uvv.Unaccess();
								delete pVector;
								pVector = NULL;
								break;
							}

							// We manually splat BSTRs, when the array is destroyed, the
							// BSTR will get freed.
							if ( vartype == VT_BSTR )
							{
								// 
								((BSTR*)pvData)[i] = var.GetLPWSTR();
							}
							else if ( vartype == VT_UNKNOWN )
							{
								// We manually splat Unknown pointers, when the array is destroyed, the
								// object will be released.
								((IUnknown**)pvData)[i] = var.GetUnknown();
							}
							else
							{
								// This will return an error if allocation fails
								if ( pVector->Add( var ) != CVarVector::no_error )
								{
									uvv.Unaccess();
									delete pVector;
									pVector = NULL;
									break;
								}
							}

							// Advance the current element
							// ===========================

							pCurrentElement += nSize;
						}
						catch (...)
						{
							// Cleanup pVector and rethrow the exception
							uvv.Unaccess();
							delete pVector;
							pVector = NULL;

							throw;
						}

						var.Empty();

					}	// FOR enum elements

					// No point in continuing if pVetor is NULL
					if ( NULL != pVector )
					{
						// For Strings and Objects, we need to set the max
						// array size.

						if (	vartype == VT_BSTR ||
								vartype == VT_UNKNOWN )
						{
							pVector->SetRawArraySize( GetNumElements() );
						}

					}	// IF NULL != pVector

				}	// else element by element copy

			}	// IF MakeOptimized
			else
			{
				delete pVector;
				pVector = NULL;
			}

        }   // IF NULL != pVector

        return pVector;
    }
    catch (...)
    {

        // Cleanup the allocated vector
        if ( NULL != pVector )
        {
            delete pVector;
        }

        return NULL;
    }

}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************

LPMEMORY CUntypedArray::GetElement(int nIndex, int nSize)
{
    return LPMEMORY(this) + sizeof(m_nNumElements) + nSize*nIndex;
}

BOOL CUntypedArray::CheckCVarVector(CVarVector& vv, Type_t nInherentType)
{
    if(!CType::IsArray(nInherentType))
        return FALSE;

    if(vv.Size() == 0)
        return TRUE;

    Type_t nBasic = CType::GetBasic(nInherentType);

    // Since all variables in our array are of the same type, we can use the
    // type of the first one to see if any checking is required
    // =====================================================================

	CVar	v;
	vv.FillCVarAt( 0, v );

    if(CType::DoesCIMTYPEMatchVARTYPE(nBasic, (VARTYPE) v.GetOleType()) &&
        !CUntypedValue::DoesTypeNeedChecking(nBasic))
    {
        return TRUE; // no type-checking required
    }

    for(int i = 0; i < vv.Size(); i++)
    {
		CVar	vTemp;
		vv.FillCVarAt( i, vTemp );

        if(!CUntypedValue::CheckCVar(vTemp, nBasic))
            return FALSE;
    }

    return TRUE;
}

BOOL CUntypedArray::CheckIntervalDateTime( CVarVector& vv )
{
    if(vv.Size() == 0)
        return FALSE;

    // Check each value in the array
    for(int i = 0; i < vv.Size(); i++)
    {
		CVar	v;
		vv.FillCVarAt( i, v );

        if(!CUntypedValue::CheckIntervalDateTime(v))
        {
            return FALSE;
        }
    }

    return TRUE;
}

HRESULT CUntypedArray::LoadFromCVarVector(CPtrSource* pThis,
                                                CVarVector& vv,
                                                Type_t nInherentType,
                                                CFastHeap* pHeap,
                                                Type_t& nReturnType,
                                                BOOL bUseOld)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    // Obtain the type and the data size
    // =================================

    int nNumElements = vv.Size();
    CType Type = CType::MakeNotArray(nInherentType);
    int nSize = Type.GetLength();
	VARTYPE vartype = Type.GetVARTYPE();

	// if this is a numeric, non-BOOL type, the types are the same, and this is an optimized
	// array, we can make a direct memory copy

	if ( vartype == vv.GetType() &&
		!Type.IsPointerType() &&
		vartype != VT_BOOL &&
		vv.IsOptimized() &&
		CType::IsMemCopyAble(vartype,Type) &&
		Type.GetLength() == vv.GetElementSize() )
	{
		void*	pvData = NULL;

        CShiftedPtr ElementPtr( pThis, GetHeaderLength() );

		HRESULT	hr = vv.GetRawArrayData( ElementPtr.GetPointer(), nSize * nNumElements );

		if ( FAILED( hr ) )
		{
			return hr;
		}

	}
	else
	{
		CVar	vTemp;
		CUnaccessVarVector	uav;

		HRESULT hr = WBEM_S_NO_ERROR;
		
		// We will use direct access to the array if the vector is optimized
		if ( vv.IsOptimized() )
		{
			hr = vv.InternalRawArrayAccess();

			if ( SUCCEEDED( hr ) )
			{
				uav.SetVV( &vv );
			}
		}

		if ( SUCCEEDED( hr ) )
		{
			for(int i = 0; i < nNumElements; i++)
			{
				// IMPORTANT: this POINTER CAN CHANGE At ANY TIME IN THIS LOOP DUE
				// TO HEAP RELOCATION!!!!!
				// ===============================================================

				// Load it from CVar
				// =================

				CShiftedPtr ElementPtr(pThis, GetHeaderLength() + i*nSize);

				// Check for failures during this operation
				Type_t  nType;

				vv.FillCVarAt( i, vTemp );

				hr = CUntypedValue::LoadFromCVar(&ElementPtr, vTemp, Type, pHeap, nType,
							(bUseOld && i < GetPointer(pThis)->m_nNumElements));
				if ( FAILED( hr ) )
				{
					return hr;
				}

				vTemp.Empty();
			}

		}	// IF we did a raw array access

	}	// Else do element by element copy

    GetPointer(pThis)->m_nNumElements = nNumElements;
    nReturnType = Type;

    return WBEM_S_NO_ERROR;
}

HRESULT CUntypedArray::ReallocArray( CPtrSource* pThis, length_t nLength, CFastHeap* pHeap,
										ULONG uNumNewElements, ULONG* puNumOldElements,
										ULONG* puTotalNewElements, heapptr_t* pNewArrayPtr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// "Discover" the old array so we can make it a new array
	heapptr_t	ptrOldArray = pThis->AccessPtrData();

	// If this is an Invalid pointer, the array was NULL, so don't just blindly jump
	// in and access the array.
	*puNumOldElements = 0;
	int nOldArrayLength = 0;

	if ( INVALID_HEAP_ADDRESS != ptrOldArray )
	{
		// Initialize the values properly
		CHeapPtr	OldArrayPtr( pHeap, ptrOldArray );

		CUntypedArray*	pArray = (CUntypedArray*) OldArrayPtr.GetPointer();;
		*puNumOldElements = pArray->GetNumElements();
		nOldArrayLength = pArray->GetLengthByActualLength( nLength );
	}

	// First up, we need to allocate space for a new array
	// --- we'll need space for the old array plus the new elements
	*puTotalNewElements = *puNumOldElements + uNumNewElements;

    int nNewArrayLen = CUntypedArray::CalculateNecessarySpaceByLength( nLength, *puTotalNewElements );

	// Allocate or Realloc as appropriate
	if ( INVALID_HEAP_ADDRESS != ptrOldArray )
	{
		if ( !pHeap->Reallocate(ptrOldArray, nOldArrayLength, nNewArrayLen,  *pNewArrayPtr) )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		if ( !pHeap->Allocate( nNewArrayLen,  *pNewArrayPtr ) )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

// Verifies that the supplied buffer size will hold the elements required.
HRESULT CUntypedArray::CheckRangeSizeForGet( Type_t nInherentType, length_t nLength, ULONG uNumElements,
											ULONG uBuffSize, ULONG* pulBuffRequired )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If it's an object datatype is an IUnknown*, otherwise we need to know how much data to copy into
	// the buffer.

	if ( CIM_OBJECT == nInherentType )
	{
		// We should have uNumElement pointers (We ignore this if only one comes in)
		*pulBuffRequired = uNumElements * sizeof(CWbemObject*);

		if ( *pulBuffRequired > uBuffSize )
		{
			hr = WBEM_E_BUFFER_TOO_SMALL;
		}
	}
	else if ( !CType::IsStringType( nInherentType ) )	// We can't do strings until we get them
	{

		// Buffer Size must account for uNumElements of the appropriate length
		*pulBuffRequired = uNumElements * nLength;

		if ( *pulBuffRequired > uBuffSize )
		{
			hr = WBEM_E_BUFFER_TOO_SMALL;
		}

	}
	else
	{
		// Initialize to 0
		*pulBuffRequired = 0;
	}

	return hr;
}

// Verifies that the specified range and the number of elements correspond to the buffer
// size that was passed into us
HRESULT CUntypedArray::CheckRangeSize( Type_t nInherentType, length_t nLength, ULONG uNumElements,
									  ULONG uBuffSize, LPVOID pData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If it's an object pData is an IUnknown*, otherwise we need to know how much data to copy into
	// the buffer.

	if ( CType::IsStringType( nInherentType ) )
	{
		// Calculate the total buffer length based on the number of strings
		// passed in:

		ULONG	uTotalSize = 0;
		LPWSTR	pwszTemp = (LPWSTR) pData;

		for ( ULONG	x = 0; x < uNumElements; x++ )
		{
			// Account for the NULL terminator
			ULONG	uLen = wcslen( pwszTemp ) + 1;

			//. Adjust size and then the poin=ter
			uTotalSize += ( uLen * 2 );
			pwszTemp += uLen;
		}

		if ( uTotalSize != uBuffSize )
		{
			hr = WBEM_E_TYPE_MISMATCH;
		}
	}
	else if ( CIM_OBJECT == nInherentType )
	{
		// We should have uNumElement pointers (We ignore this if only one comes in)
		if ( uNumElements != 1 && uNumElements * sizeof(CWbemObject*) != uBuffSize )
		{
			hr = WBEM_E_TYPE_MISMATCH;
		}
	}
	else
	{

		// Buffer Size must account for uNumElements of the appropriate length
		ULONG	uRequiredLength = nLength * uNumElements;

		// Sending us an invalid buffer size
		if ( uBuffSize != uRequiredLength )
		{
			hr = WBEM_E_TYPE_MISMATCH;
		}

	}

	return hr;
}

// Gets a range of elements from an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings are converted to WCHAR and separated by NULLs.  Object properties
// are returned as an array of _IWmiObject pointers.  The range MUST be within the bounds
// of the current array
HRESULT CUntypedArray::GetRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
								CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								ULONG* puBuffSizeUsed, LPVOID pData )
{
	// Verify the range data size
	HRESULT	hr = CheckRangeSizeForGet( nInherentType, nLength, uNumElements, uBuffSize, puBuffSizeUsed );

	if ( SUCCEEDED( hr ) )
	{

		CUntypedArray*	pArray = (CUntypedArray*) pThis->GetPointer();
		ULONG			uLastIndex = uStartIndex + uNumElements - 1;

		// Make sure our range is within the bounds of our array
		if ( uStartIndex < pArray->GetNumElements() && uLastIndex < pArray->GetNumElements() )
		{

			// If this is a pointer type, use a CVar to reset values
			if ( CType::IsNonArrayPointerType( nInherentType ) )
			{
				if ( NULL != pData || CType::IsStringType( nInherentType ) )
				{
					LPMEMORY	pbTemp = (LPMEMORY) pData;
					BOOL		fTooSmall = FALSE;

					// Iterate through each element of the range and use a CVar
					// to get these guys onto the heap.
					for ( ULONG uIndex = uStartIndex; SUCCEEDED( hr ) && uIndex <= uLastIndex; uIndex++ )
					{
						// Establishes a pointer to the storage for heap pointer in the
						// array
						CShiftedPtr ElementPtr(pThis, GetHeaderLength() + ( uIndex * nLength) );

						// Set the pointer, and let the magic of fastheap kick in.
						if ( CIM_OBJECT == nInherentType )
						{
							CEmbeddedObject* pEmbedding =
									(CEmbeddedObject*) pHeap->ResolveHeapPointer( ElementPtr.AccessPtrData() );

							CWbemObject*	pObj = pEmbedding->GetEmbedded();

							if ( NULL != pObj )
							{
								*((CWbemObject**) pbTemp) = pObj;
								pbTemp += sizeof(CWbemObject*);
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
						}
						else
						{
							// Make sure we dereference from the proper heap
							CCompressedString* pcs =
								pHeap->ResolveString( ElementPtr.AccessPtrData() );

							ULONG	uLength = ( pcs->GetLength() + 1 ) * 2;

							// Grow the required buffer size
							*puBuffSizeUsed += uLength;

							// Make sure the buffer is big enough
							if ( *puBuffSizeUsed > uBuffSize )
							{
								fTooSmall = TRUE;
							}

							// Now copy out as unicode and jump the pointer
							// past the string
							if ( NULL != pbTemp )
							{
								pcs->ConvertToUnicode( (LPWSTR) pbTemp );
								pbTemp += uLength;
							}
						}

					}	// FOR enum elements

					// Record the fact that the buffer was too small if we were dealing with
					// strings
					if ( fTooSmall )
					{
						hr = WBEM_E_BUFFER_TOO_SMALL;
					}

				}	// IF pData is non-NULL or the data type is String
				
			}
			else if ( NULL != pData )
			{
				// Establishes a pointer to the storage for heap pointer in the
				// array
				CShiftedPtr ElementPtr(pThis, GetHeaderLength() + ( uStartIndex * nLength) );

				// Splats data directly from the caller's buffer into our array
				CopyMemory( pData, ElementPtr.GetPointer(), *puBuffSizeUsed );

			}

		}	// If the index is valid
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

	}	// If proper buffer size

	return hr;
}

// Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
// of the current array
HRESULT CUntypedArray::SetRange( CPtrSource* pThis, long lFlags, Type_t nInherentType, length_t nLength,
								CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								LPVOID pData )
{
	// Verify the range data size
	HRESULT	hr = CheckRangeSize( nInherentType, nLength, uNumElements, uBuffSize, pData );

	if ( SUCCEEDED( hr ) )
	{
		BOOL		fReallocArray = FALSE;

		if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
		{
			ULONG	uNumOldElements = 0,
					uNumNewElements = 0;

			if ( 0 == uStartIndex )
			{
				heapptr_t	ptrArray = pThis->AccessPtrData();

				// If the old array is smaller, we need to realloc.
				if ( INVALID_HEAP_ADDRESS == ptrArray )
				{
					fReallocArray = TRUE;
				}
				else
				{
					CUntypedArray*	pArray = (CUntypedArray*) pHeap->ResolveHeapPointer( ptrArray );
					uNumOldElements = pArray->GetNumElements();

					fReallocArray = ( uNumElements > uNumOldElements );
				}

				// Reallocate, and then if the inherent type implies heap pointers, fill the
				// trailing data with 0xFF bytes, so we don't free string data below
				if ( fReallocArray )
				{
					heapptr_t	ptrNewArray = 0;
					hr = ReallocArray( pThis, nLength, pHeap, uNumElements, &uNumOldElements,
							&uNumNewElements, &ptrNewArray );

					if ( SUCCEEDED( hr ) )
					{
						if ( CType::IsNonArrayPointerType( nInherentType ) )
						{
							CHeapPtr	NewArray( pHeap, ptrNewArray );
							CShiftedPtr ElementPtr(&NewArray, GetHeaderLength() +
									( uNumOldElements * sizeof(heapptr_t)) );

							FillMemory( ElementPtr.GetPointer(), uNumElements * sizeof(heapptr_t), 0xFF );
						}

						// Fixup to the new array
						pThis->AccessPtrData() = ptrNewArray;
					}

				}
				else
				{
					uNumNewElements = uNumElements;

					// Shrink the array 
					if ( uNumNewElements < uNumOldElements )
					{
						CHeapPtr	OldArray( pHeap, pThis->AccessPtrData() );

						hr = RemoveRange( &OldArray, nInherentType, nLength, pHeap, uNumNewElements,
											( uNumOldElements - uNumNewElements ) );
					}
				}
			}
			else
			{
				hr = WBEM_E_INVALID_PARAMETER;
			}
		}

		// Now that we've alloced and realloced as necessary
		if ( SUCCEEDED( hr ) )
		{
			CHeapPtr	CurrentArray( pHeap, pThis->AccessPtrData() );

			CUntypedArray*	pArray = GetPointer(&CurrentArray);
			ULONG			uLastIndex = uStartIndex + uNumElements - 1;

			// Make sure our range is within the bounds of our array.  If the realloc flag
			// is TRUE, then we know we allocated space to store the array - no new data
			// will have been set.  We wait until we store everything before we actually set
			// the num elements in case something fails during the operation
			if ( fReallocArray ||
				( uStartIndex < pArray->GetNumElements() && uLastIndex < pArray->GetNumElements() ) )
			{
				CType Type(nInherentType);

				// If this is a pointer type, use a CVar to reset values
				if ( CType::IsNonArrayPointerType( nInherentType ) )
				{
					// Iterate through each element of the range and use a CVar
					// to get these guys onto the heap.
					for ( ULONG uIndex = uStartIndex; SUCCEEDED( hr ) && uIndex <= uLastIndex; uIndex++ )
					{
						// Establishes a pointer to the storage for heap pointer in the
						// array
						CShiftedPtr ElementPtr(&CurrentArray, GetHeaderLength() + ( uIndex * nLength) );

						CVar	var;

						// Set the pointer, and let the magic of fastheap kick in.
						if ( CIM_OBJECT == nInherentType )
						{
							var.SetEmbeddedObject( *((IUnknown**) pData) );
						}
						else
						{
							var.SetLPWSTR( (LPWSTR) pData );
						}

						// Check for failures during this operation
						Type_t  nType;

						// This will properly set the element even if additional storage is required
						hr = CUntypedValue::LoadFromCVar(&ElementPtr, var, Type, pHeap, nType, TRUE );

						if ( SUCCEEDED( hr ) )
						{
							// Point to the next element
							LPMEMORY	pbTemp = (LPMEMORY) pData;

							if ( CIM_OBJECT == nInherentType )
							{
								// Just jump the size of a pointer
								pbTemp += sizeof( LPVOID);
							}
							else
							{
								// Jumps to the next string
								pbTemp += ( ( wcslen((LPWSTR) pData) + 1 ) * 2 );
							}

							// Cast back - why do I feel like I'm fishing?
							pData = pbTemp;
						}

					}	// IF IsNonArrayPointerType
					
				}
				else
				{
					// Establishes a pointer to the storage for heap pointer in the
					// array
					CShiftedPtr ElementPtr(&CurrentArray, GetHeaderLength() + ( uStartIndex * nLength) );

					// Splats data directly from the caller's buffer into our array
					CopyMemory( ElementPtr.GetPointer(), pData, uBuffSize );

				}

				// If we were setting all elements, then we need to reflect the
				// elements in the array.
				if ( SUCCEEDED( hr ) && ( lFlags & WMIARRAY_FLAG_ALLELEMENTS ) )
				{
					GetPointer(&CurrentArray)->m_nNumElements = uNumElements;
				}

			}	// If the index is valid
			else
			{
				hr = WBEM_E_INVALID_OPERATION;
			}

		}	// IF array is of proper allocation length

	}	// If proper buffer size

	return hr;
}

// Appends a range of elements to the array.  Can cause the array to be reallocated.
// pThis in this case should be a CDataTablePtr
HRESULT CUntypedArray::AppendRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
										CFastHeap* pHeap, ULONG uNumElements, ULONG uBuffSize, LPVOID pData )
{
	HRESULT	hr = CheckRangeSize( nInherentType, nLength, uNumElements, uBuffSize, pData );

	// We're OKAY!
	if ( SUCCEEDED( hr ) )
	{

		// If this is an Invalid pointer, the array was NULL, so don't just blindly jump
		// in and access the array.
		ULONG	uOldNumElements = 0,
				nNewArrayNumElements = 0;

		heapptr_t	ptrNewArray = 0;

		hr = ReallocArray( pThis, nLength, pHeap, uNumElements, &uOldNumElements,
							&nNewArrayNumElements, &ptrNewArray );


        if ( SUCCEEDED( hr ) )
		{
			CHeapPtr	NewArrayPtr( pHeap, ptrNewArray );

			// Load it from CVar
			// =================

			// If this is a pointer type, use a CVar to deal with this
			if ( CType::IsNonArrayPointerType( nInherentType ) )
			{
				CType Type(nInherentType);

				for ( ULONG uIndex = uOldNumElements;
						SUCCEEDED( hr ) && uIndex < nNewArrayNumElements; uIndex++ )
				{

					CShiftedPtr ElementPtr(&NewArrayPtr, GetHeaderLength() + ( uIndex * nLength) );

					CVar	var;

					// Set the pointer, and let the magic of fastheap kick in.
					if ( CIM_OBJECT == nInherentType )
					{
						var.SetEmbeddedObject( *((IUnknown**) pData) );
					}
					else
					{
						var.SetLPWSTR( (LPWSTR) pData );
					}

					// Check for failures during this operation
					Type_t  nType;

					// This will properly set the element even if additional storage is required
					// Don't reuse any values here.
					hr = CUntypedValue::LoadFromCVar(&ElementPtr, var, Type, pHeap, nType, FALSE );

					// Point to the next element
					LPMEMORY	pbTemp = (LPMEMORY) pData;

					if ( CIM_OBJECT == nInherentType )
					{
						// Just jump the size of a pointer
						pbTemp += sizeof( LPVOID);
					}
					else
					{
						// Jumps to the next string
						pbTemp += ( ( wcslen((LPWSTR) pData) + 1 ) * 2 );
					}

					// Cast back - why do I feel like I'm fishing?
					pData = pbTemp;
				}
			}
			else
			{
				// Now splat the data at the end of the new array
				CShiftedPtr ElementPtr(&NewArrayPtr, GetHeaderLength() + ( uOldNumElements * nLength ) );

				CopyMemory( ElementPtr.GetPointer(), pData, nLength * uNumElements );
			}

			if ( SUCCEEDED( hr ) )
			{
				// Set the new nummber of elements
				GetPointer(&NewArrayPtr)->m_nNumElements = nNewArrayNumElements;

				// Now store the new array pointer and we are done
				pThis->AccessPtrData() = ptrNewArray;
			}
		}

	}	// If proper buffer size

	return hr;
}

// Removes a range of elements inside an array.  The range MUST fit within the bounds
// of the current array
HRESULT CUntypedArray::RemoveRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
								CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements )
{
	// Verify the range data size
	HRESULT	hr = WBEM_S_NO_ERROR;

	CUntypedArray*	pArray = (CUntypedArray*) pThis->GetPointer();
	ULONG			uLastIndex = uStartIndex + uNumElements - 1;
	ULONG			uOldNumElements = pArray->GetNumElements();

	// Make sure our range is within the bounds of our array
	if ( uStartIndex < uOldNumElements && uLastIndex < uOldNumElements )
	{
		CType Type(nInherentType);

		// If this is a pointer type, use a CVar to reset values
		if ( CType::IsNonArrayPointerType( nInherentType ) )
		{
			// Iterate through each element of the range and free each heap element
			for ( ULONG uIndex = uStartIndex; uIndex <= uLastIndex; uIndex++ )
			{
				// Establishes a pointer to the storage for heap pointer in the
				// array
				CShiftedPtr ElementPtr(pThis, GetHeaderLength() + ( uIndex * nLength) );

				CVar	var;

				// Set the pointer, and let the magic of fastheap kick in.
				if ( CIM_OBJECT == nInherentType )
				{
					CEmbeddedObject* pOldObj =
						(CEmbeddedObject*)pHeap->ResolveHeapPointer(
														ElementPtr.AccessPtrData());
					length_t nOldLength = pOldObj->GetLength();

					pHeap->Free( ElementPtr.AccessPtrData(), nOldLength );
				}
				else
				{
					pHeap->FreeString( ElementPtr.AccessPtrData() );
				}

			}	// FOR iterate elements in the requested Remove range
			
		}

		// Now we need to copy elements over the ones we want to axe
		if ( SUCCEEDED( hr ) )
		{
			// Reestablish this
			pArray = (CUntypedArray*) pThis->GetPointer();
			ULONG	uEndOfArrayIndex = pArray->GetNumElements() - 1;

			if ( uLastIndex < uEndOfArrayIndex )
			{
				CShiftedPtr StartIndexPtr(pThis, GetHeaderLength() + ( uStartIndex * nLength) );
				CShiftedPtr MoveIndexPtr(pThis, GetHeaderLength() + ( ( uLastIndex + 1 ) * nLength) );

				// Difference between the end of array index and the last index covers how
				// many elements we actually want to move.
				MoveMemory( StartIndexPtr.GetPointer(), MoveIndexPtr.GetPointer(),
							( uEndOfArrayIndex - uLastIndex ) * nLength );
			}

			// Now subtract the number of removed elements from the total number of
			// elements in the array.

			GetPointer( pThis )->m_nNumElements = uOldNumElements - uNumElements;
		}

	}	// If the index is valid
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}


//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
 void CUntypedArray::Delete(CType Type, CFastHeap* pHeap)
{
    // NOTE: ARRAYS OF ARRAYS ARE NOT SUPPORTED!!!!
    // ============================================

    if(Type.GetBasic() == CIM_STRING || Type.GetBasic() == CIM_DATETIME ||
        Type.GetBasic() == CIM_REFERENCE)
    {
        // Have to delete every pointer
        // ===============================

        PHEAPPTRT pptrCurrent = (PHEAPPTRT)GetElement(sizeof(heapptr_t), 0);
        for(int i = 0; i < GetNumElements(); i++)
        {
            pHeap->FreeString(*pptrCurrent);
            pptrCurrent++;
        }
    }
    else if(Type.GetBasic() == CIM_OBJECT)
    {
        // Have to delete every pointer
        // ===============================

        PHEAPPTRT pptrCurrent = (PHEAPPTRT)GetElement(sizeof(heapptr_t), 0);
        for(int i = 0; i < GetNumElements(); i++)
        {
            CEmbeddedObject* pObj = (CEmbeddedObject*)
                pHeap->ResolveHeapPointer(*pptrCurrent);
            pHeap->Free(*pptrCurrent, pObj->GetLength());
            pptrCurrent++;
        }
    }
}


//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
BOOL CUntypedArray::TranslateToNewHeap(CPtrSource* pThis, CType Type,
                                   CFastHeap* pOldHeap, CFastHeap* pNewHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    // NOTE: ARRAYS OF ARRAYS ARE NOT SUPPORTED!!!!
    // ============================================

    if(Type.GetBasic() == CIM_STRING || Type.GetBasic() == CIM_DATETIME ||
        Type.GetBasic() == CIM_REFERENCE)
    {
        // Have to translate every pointer
        // ===============================

        int nOffset = GetHeaderLength();
        int nNumElements = GetPointer(pThis)->GetNumElements();
        for(int i = 0; i < nNumElements; i++)
        {
            heapptr_t ptrOldString =
                *(PHEAPPTRT)(pThis->GetPointer() + nOffset);

            // Check for allocation failure
            heapptr_t ptrNewString;

            if ( !CCompressedString::CopyToNewHeap(
                    ptrOldString, pOldHeap, pNewHeap, ptrNewString) )
            {
                return FALSE;
            }

            *(PHEAPPTRT)(pThis->GetPointer() + nOffset) = ptrNewString;

            nOffset += sizeof(heapptr_t);
        }
    }
    else if(Type.GetBasic() == CIM_OBJECT)
    {
        // Have to translate every pointer
        // ===============================

        int nOffset = GetHeaderLength();
        int nNumElements = GetPointer(pThis)->GetNumElements();
        for(int i = 0; i < nNumElements; i++)
        {
            heapptr_t ptrOldObj =
                *(PHEAPPTRT)(pThis->GetPointer() + nOffset);

            // Check for allocation failure
            heapptr_t ptrNewObj;

            if ( !CEmbeddedObject::CopyToNewHeap(
                    ptrOldObj, pOldHeap, pNewHeap, ptrNewObj) )
            {
                return FALSE;
            }

            *(PHEAPPTRT)(pThis->GetPointer() + nOffset) = ptrNewObj;

            nOffset += sizeof(heapptr_t);
        }
    }
    
    return TRUE;
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
BOOL CUntypedArray::CopyToNewHeap(heapptr_t ptrOld, CType Type,
                                CFastHeap* pOldHeap, CFastHeap* pNewHeap, UNALIGNED heapptr_t& ptrResult)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    // Calculate the length
    // ====================

    CUntypedArray* pArray =
        (CUntypedArray*)pOldHeap->ResolveHeapPointer(ptrOld);

    int nLength = pArray->GetLengthByType(Type.GetBasic());

    // Allocate room on the new heap and memcopy the whole thing
    // =========================================================

    // Check for allocation failure
    heapptr_t ptrNew;
    if ( !pNewHeap->Allocate(nLength, ptrNew) )
    {
        return FALSE;
    }

    pArray = NULL; /* pointer may have been invalidated!!! */

    memcpy(pNewHeap->ResolveHeapPointer(ptrNew),
        pOldHeap->ResolveHeapPointer(ptrOld), nLength);

    // Translate all the data (e.g., copy strings)
    // ===========================================

    CHeapPtr NewArray(pNewHeap, ptrNew);

    // Check for allocation failure
    if ( !CUntypedArray::TranslateToNewHeap(&NewArray, Type, pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    ptrResult = ptrNew;
    return TRUE;
}

HRESULT CUntypedArray::IsArrayValid( CType Type, CFastHeap* pHeap )
{
    // Get the heap data start
    LPMEMORY    pHeapStart = pHeap->GetHeapData();
    LPMEMORY    pHeapEnd = pHeap->GetStart() + pHeap->GetLength();

    if ( CType::IsPointerType( Type.GetBasic() ) )
    {
        int nSize = Type.GetLength();
        LPMEMORY pCurrentElement = GetElement(0, nSize);

        LPMEMORY pEndArray = pCurrentElement + ( m_nNumElements * nSize );

        // Make sure the end of the array is within our heap bounds.
        if ( !( pEndArray >= pHeapStart && pEndArray <= pHeapEnd ) )
        {
            OutputDebugString(__TEXT("Winmgmt: Untyped Array past end of heap!"));
            FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Untyped Array past end of heap!") );
            return WBEM_E_FAILED;
        }

        for ( int n = 0; n < m_nNumElements; n++ )
        {
            CUntypedValue* pValue = (CUntypedValue*)pCurrentElement;
            LPMEMORY pData = pHeap->ResolveHeapPointer( pValue->AccessPtrData() );

            if ( !( pData >= pHeapStart && pData < pHeapEnd ) )
            {
                OutputDebugString(__TEXT("Winmgmt: Bad heap pointer in array element!"));
                FASTOBJ_ASSERT( 0, __TEXT("Winmgmt: Bad heap pointer in array element!") );
                return WBEM_E_FAILED;
            }

            // Advance the current element
            // ===========================

            pCurrentElement += nSize;

        }   // FOR enum elements

    }   // Only if this is a pointer type

    return WBEM_S_NO_ERROR;
}

CType CType::VARTYPEToType(VARTYPE vt)
{
    Type_t nType;
    switch(vt & ~VT_ARRAY)
    {
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_BSTR:
        nType = CIM_STRING;
        break;
    case VT_UI1:
        nType = CIM_UINT8;
        break;
    case VT_I2:
        nType = CIM_SINT16;
        break;
    case VT_I4:
        nType = CIM_SINT32;
        break;
    case VT_BOOL:
        nType = CIM_BOOLEAN;
        break;
    case VT_R4:
        nType = CIM_REAL32;
        break;
    case VT_R8:
        nType = CIM_REAL64;
        break;
    case VT_EMBEDDED_OBJECT:
        nType = CIM_OBJECT;
        break;
    default:
        nType = CIM_ILLEGAL;
        break;
    }

    if(vt & VT_ARRAY) nType |= CIM_FLAG_ARRAY;

    return nType;
}
VARTYPE CType::GetVARTYPE(Type_t nType)
{
    VARTYPE vt;
    switch(GetBasic(nType))
    {
    case CIM_STRING:
    case CIM_DATETIME:
    case CIM_REFERENCE:
        vt = VT_BSTR;
        break;
    case CIM_OBJECT:
        vt = VT_EMBEDDED_OBJECT;
        break;
    case CIM_SINT64:
    case CIM_UINT64:
        vt = VT_BSTR;
        break;
    case CIM_UINT32:
    case CIM_SINT32:
    case CIM_UINT16:
        vt = VT_I4;
        break;
    case CIM_SINT16:
    case CIM_SINT8:
    case CIM_CHAR16:
        vt = VT_I2;
        break;
    case CIM_UINT8:
        vt = VT_UI1;
        break;
    case CIM_REAL32:
        vt = VT_R4;
        break;
    case CIM_REAL64:
        vt = VT_R8;
        break;
    case CIM_BOOLEAN:
        vt = VT_BOOL;
        break;
    case CIM_IUNKNOWN:
        vt = VT_UNKNOWN;
        break;
    }

    if(IsArray(nType))
        return vt | VT_ARRAY;
    else
        return vt;
}


BOOL CType::CanBeKey(Type_t nType)
{
        Type_t nActual = GetActualType(nType);
        return nActual == CIM_SINT32 || nActual == CIM_SINT16 ||
            nActual == CIM_UINT8 || nActual == CIM_BOOLEAN ||
            nActual == CIM_STRING || nActual == CIM_REFERENCE ||
            nActual == CIM_DATETIME || nActual == CIM_UINT32 ||
            nActual == CIM_UINT16 || nActual == CIM_SINT8 ||
            nActual == CIM_UINT64 || nActual == CIM_SINT64 ||
            nActual == CIM_CHAR16;
}

LPWSTR CType::GetSyntax(Type_t nType)
{
        switch(GetBasic(nType))
        {
            case CIM_SINT32: return L"sint32";
            case CIM_SINT16: return L"sint16";
            case CIM_UINT8: return L"uint8";
            case CIM_UINT32: return L"uint32";
            case CIM_UINT16: return L"uint16";
            case CIM_SINT8: return L"sint8";
            case CIM_UINT64: return L"uint64";
            case CIM_SINT64: return L"sint64";
            case CIM_REAL32: return L"real32";
            case CIM_REAL64: return L"real64";
            case CIM_BOOLEAN: return L"boolean";
            case CIM_OBJECT: return L"object";
            case CIM_STRING: return L"string";
            case CIM_REFERENCE: return L"ref";
            case CIM_DATETIME: return L"datetime";
            case CIM_CHAR16: return L"char16";
			case CIM_IUNKNOWN: return L"IUnknown";
            default: return NULL;
        }
}

void CType::AddPropertyType(WString& wsText, LPCWSTR wszSyntax)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    if(!wbem_wcsicmp(wszSyntax, L"ref"))
    {
        wsText += L"object ref";
    }
    else if(!wbem_wcsicmp(wszSyntax, L"object"))
    {
        wsText += L"object";
    }
    else if(!wbem_wcsnicmp(wszSyntax, L"ref:", 4))
    {
        wsText += wszSyntax + 4;
        wsText += L" ref";
    }
    else if(!wbem_wcsnicmp(wszSyntax, L"object:", 7))
    {
        wsText += wszSyntax + 7;
    }
    else
    {
        wsText += wszSyntax;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastval.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTVAL.H

Abstract:

  This file defines the classes related to value representation

  Classes defined: 
      CType               Representing property type
      CUntypedValue       A value with otherwise known type.
      CTypedValue         A value with stored type.
      CUntypedArray       Array of values of otherwise known type.

History:

  2/21/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_VALUES__H_
#define __FAST_VALUES__H_

#include "corepol.h"
#include "faststr.h"
#include "fastheap.h"
#include "fastembd.h"

#pragma pack(push, 1)

#define CIMTYPE_EX_ISNULL 0x8000
#define CIMTYPE_EX_PARENTS 0x4000
#define CIMTYPE_BASIC_MASK 0xFFF
#define CIMTYPE_TYPE_MASK  (CIMTYPE_BASIC_MASK | CIM_FLAG_ARRAY)

//*****************************************************************************
//*****************************************************************************
//
//  class CType
//
//  This class encapsulates the notion of a value type. It is based on CIMTYPE
//  but with its higher-order bits (unused by CIMTYPE types) are used to
//  store other information, making the whole thing very ugly, but concise.
//
//  Most member functions of this class exist in two forms: static and 
//  non-static. Since the data store for CType is simply a CIMTYPE it is 
//  convinient to invoke the member functions giving the CIMTYPE (referred to
//  as Type_t) as the first parameter, rather than casting it to CType and then
//  calling the function.
//
//  We document only non-static versions, since the static ones are simply
//  C-versions of same.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns the length of data for this particular type. For instance, for
//  a short integer (CIM_SINT16) the answer is 2, and for a string (CIM_STRING) the
//  answer is 4, since only the pointer is stored. Similarily, arrays take
//  4, since only the pointer is stored.
//
//  Returns:
//
//      length_t
//
//*****************************************************************************
//
//  GetActualType
//
//  Strips the extra information stored in the higher bits and returns the
//  actual CIM_xx value.
//
//  Returns:
//
//      Type_t
//
//*****************************************************************************
//
//  GetBasic
//
//  For arrays, returns the type of the element. For non-arrays, synonimous 
//  with GetActualType.
//
//  Returns:
//
//      Type_t
//
//*****************************************************************************
//
//  IsArray
//
//  Checks if this type represents an array
//
//  Returns:
//
//      BOOL:   TRUE if it is an array
//
//*****************************************************************************
//
//  static MakeArray
//
//  Converts a basic type into the type for array of such types.
//
//  Parameters:
//
//      Type_t nType        Basic type to convert.
//
//  Returns:
//
//      Type_t: resulting array type.
//
//*****************************************************************************
//
//  static MakeNotArray
//
//  Retrieves the element type from an array type.
//
//  Parameters:
//
//      Type_t nType        Array type.
//
//  Returns:
//
//      Type_t: element type.
//
//*****************************************************************************
//
//  IsPointerType
//
//  Checks if the data for this type is represented as a pointer, rather than
//  the data itself (e.g., CIM_STRING, arrays).
//
//  Returns:
//
//      BOOL
//
//*****************************************************************************
//
//  static VARTYPEToType
//
//  Converts an actual VARTYPE to our own type (CIMTYPE)
//
//  Parameters:
//
//      VARTYPE vt      The type to convert.
//
//  Returns:
//
//      Type_t: converted type.
//
//*****************************************************************************
//
//  static CVarToType
//
//  Helper function that extracts *our* type from CVar (using VARTYPEToType).
//
//  Parameters:
//
//      [in, readonly] CVar& v      The CVar to get the type from
//  
//  Returns:
//
//      Type_t: converted type.
//
//*****************************************************************************
//
//  GetVARTYPE
//
//  Creates a type for the VARIANT with which our type can be represented.
//
//  Returns:
//
//      VARTYPE: proper type for a VARIANT.
//
//*****************************************************************************
//
//  CanBeKey
//
//  Determines if a property of this type can serve as a key for a class (for
//  instance, floating point properties may not).
//
//  Returns:
//
//      TRUE if it can, FALSE if it can't.
//
//*****************************************************************************
//
//  IsParents
//
//  Test one of those higher bits in which the information on the property
//  origin is stored. Namely, the bit is set if the property came from a parent
//  class, as opposed to being defined in this class. It is set even if the
//  property is overriden in this class.
//
//  Returns:
//
//      BOOL
//
//*****************************************************************************
//
//  static MakeParents
//
//  Ensures that the "came from parent" bit is set in the type.
//
//  Parameters:
//
//      [in] Type_t nType       Original type.
//
//  Returns:
//
//      Type_t with the parent's bit set.
//
//*****************************************************************************
//
//  static MakeLocal
//
//  Ensures that the "came from parent" bit is not set in the type.
//
//  Parameters:
//
//      [in] Type_t nType       Original type.
//
//  Returns:
//
//      Type_t with the parent's bit reset.
//
//*****************************************************************************

#define MAXIMUM_FIXED_DATA_LENGTH 20


class COREPROX_POLARITY CType
{
private:

protected:
    Type_t m_nType;
public:
    inline CType() : m_nType(CIM_EMPTY) {}
    inline CType(Type_t nType) : m_nType(nType){}
    inline operator Type_t() {return m_nType;}

    static length_t GetLength(Type_t nType);
    inline length_t GetLength() {return GetLength(m_nType);}

    static inline Type_t GetBasic(Type_t nType) {return nType & CIMTYPE_BASIC_MASK;}
    inline Type_t GetBasic() {return GetBasic(m_nType);}

    static inline BOOL IsArray(Type_t nType) {return nType & CIM_FLAG_ARRAY;}
    inline BOOL IsArray() {return IsArray(m_nType);}
    static inline Type_t MakeArray(Type_t nType) {return nType | CIM_FLAG_ARRAY;}
    static inline Type_t MakeNotArray(Type_t nType) {return nType & ~CIM_FLAG_ARRAY;}

    static inline BOOL IsParents(Type_t nType) {return nType & CIMTYPE_EX_PARENTS;}
    inline BOOL IsParents() {return IsParents(m_nType);}
    static inline Type_t MakeParents(Type_t nType) 
        {return nType | CIMTYPE_EX_PARENTS;}
    static inline Type_t MakeLocal(Type_t nType) 
        {return nType & ~CIMTYPE_EX_PARENTS;}

    static BOOL IsPointerType(Type_t nType);
    BOOL IsPointerType() {return IsPointerType(m_nType);}

    static BOOL IsNonArrayPointerType(Type_t nType);
    BOOL IsNonArrayPointerType() {return IsNonArrayPointerType(m_nType);}

    static BOOL IsStringType(Type_t nType);
    BOOL IsStringType() {return IsStringType(m_nType);}

    static inline Type_t GetActualType(Type_t nType) 
        {return nType & CIMTYPE_TYPE_MASK;}
    inline Type_t GetActualType() {return GetActualType(m_nType);}

    static BOOL IsValidActualType(Type_t nType);

    static CType VARTYPEToType(VARTYPE vt);

    static inline CType CVarToType(CVar& v)
    {
        if(v.GetType() == VT_EX_CVARVECTOR)
        {
            return VARTYPEToType( (VARTYPE) v.GetVarVector()->GetType() ) | CIM_FLAG_ARRAY;
        }
        else return VARTYPEToType( (VARTYPE) v.GetType() );
    }

    static VARTYPE GetVARTYPE(Type_t nType);
    
    inline VARTYPE GetVARTYPE()
        {return GetVARTYPE(m_nType);}

    static BOOL DoesCIMTYPEMatchVARTYPE(CIMTYPE ct, VARTYPE vt);

    static BOOL IsMemCopyAble(VARTYPE vtFrom, CIMTYPE ctTo);

    static BOOL CanBeKey(Type_t nType);

    static LPWSTR GetSyntax(Type_t nType);
    inline LPWSTR GetSyntax()
        {return GetSyntax(m_nType);}

    static void AddPropertyType(WString& wsText, LPCWSTR wszSyntax);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CUntypedValue
//
//  This class represents a value whose type is known by external means and is
//  not stores with the value. An example would be the value of a property in
//  an instance --- its type is known from the class definition.
//
//  All values are represented by a fixed number of bytes, determined by the
//  type. Variable length types (like strings and arrays) are allocated on the
//  heap (CFastHeap) and only the heap pointer is stored in a CUntypedValue.
//
//  CUntypedValue is another one of those classes where 'this' pointer points 
//  to the actual data. As such, it has no data members, just the knowledge 
//  that 'this' is where the data starts.
//
//*****************************************************************************
//
//  GetRawData
//
//  Returns a pointer to the beginning of the data.
//
//  Returns:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  AccessPtrData
//
//  Helper function for those types that store a heap pointer in the value and
//  the actual data on the heap. 
//
//  Returns:
//
//      heapptr_t&: a reference to the heapptr_t stored in the value, i.e., the
//                  first 4 bytes after 'this'.
//
//*****************************************************************************
//
//  StoreToCVar
//
//  Transfers its contents into a CVar.
//
//  Parameters:
//
//      [in] CType Type                 The type of the data stored here. 
//      [in, modified] CVar& Var,       Destination.
//      [in, readonly] CFastHeap* pHeap The heap where the actual data may 
//                                      reside (if we contain a heap pointer).
//
//*****************************************************************************
//
//  static LoadFromCVar
//
//  This static function loads the data from a CVar into the specified 
//  CUntypedValue. The reason it is static is weird:
//
//      While transfering the data, we may need to allocate something on the 
//      heap. If there is not enough space, the heap may grow, causing the 
//      whole object to reallocate. But our 'this' pointer points to our data,
//      so if our data moves, our 'this' pointer will have to be changed!!!
//      That's impossible, thus this function is static, and takes a pointer
//      source instead of a pointer.
//
//  Parameters:
//
//      [in] CPtrSource* pThis          The source (see fastsprt.h) of the  
//                                      data pointer. The C value of the data
//                                      pointer may change during the execution
//                                      of this functioin, hence the source.
//      [in, readonly] CVar& Var        Destination.
//      [in, modified] CFastHeap* pHeap The heap where any extra data (like 
//                                      strings or arrays) needs to be
//                                      allocated.
//      [in] BOOL bUseOld               If TRUE, the function will attempt to 
//                                      reuse old memory on the heap. For
//                                      instance, if the data contained a
//                                      string and the new string is shorter
//                                      that the old one, than no new heap
//                                      allocations will be necessary.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  If the data contained in this value is heap-related (strings, arrays), this
//  function copies those pieces of data from one heap to another and changes
//  the pointer stored in it. It does not copy its own data (the one after 
//  'this' pointer) (see CopyTo for that). It does not Free the data on the old
//  heap (see Delete for that).
//
//  For the reason why this function is static, see LoadFromCVar above.
//
//  Parameters:
//
//      [in] CPtrSource* pThis          The source (see fastsprt.h) of the 
//                                      data pointer. The C value of the data
//                                      pointer may change during the execution
//                                      of this functioin, hence the source.
//      [in] CType Type                 The type of the value.
//      [in, readonly] 
//          CFastHeap* pOldHeap         The heap where the data currently is.
//      [in, modified]
//          CFastHeap* pNewHeap         The heap where the data should go to.
//      
//*****************************************************************************
//
//  static CopyTo
//
//  Copies untyped value from one location to another. For an explanation why
//  this function is static, see LoadFromCVar. Note; in addition to copying
//  its own data, the function will also move any related heap data to the new
//  heap (see TranslateToNewHeap).
//
//  Parameters:
//
//      [in] CPtrSource* pThis          The source (see fastsprt.h) of the 
//                                      data pointer. The C value of the data
//                                      pointer may change during the execution
//                                      of this functioin, hence the source.
//      [in] CType Type                 The type of the value.
//      [in] CPtrSource* pDest          The source of the destination data 
//                                      pointer. The C value of this pointer
//                                      may also change, hence the source.
//      [in, readonly] 
//          CFastHeap* pOldHeap         The heap where the related heap data 
//                                      currently resides
//      [in, modified]
//          CFastHeap* pNewHeap         The heap where the related heap data 
//                                      should go to.
//      
//*****************************************************************************
//
//  Delete
//
//  Frees any related data on the heap (strings, arrays).
//
//  Parameters:
//
//      CType Type          the type of the value
//      CFastHeap* pHeap    the heap where the related heap data is.
//
//*****************************************************************************

class CUntypedValue
{
protected:
    BYTE m_placeholder[MAXIMUM_FIXED_DATA_LENGTH];
public:
     CUntypedValue(){}
     LPMEMORY GetRawData() {return (LPMEMORY)this;}
     UNALIGNED heapptr_t& AccessPtrData() {return *(UNALIGNED heapptr_t*)GetRawData();}
public:
     BOOL StoreToCVar(CType Type, CVar& Var, CFastHeap* pHeap, BOOL fOptimize = FALSE);
     static HRESULT LoadFromCVar(CPtrSource* pThis,
        CVar& Var, Type_t nType, CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld = FALSE);
     static HRESULT LoadFromCVar(CPtrSource* pThis,
        CVar& Var, CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld = FALSE);

	 static HRESULT LoadUserBuffFromCVar( Type_t type, CVar* pVar, ULONG uBuffSize, ULONG* puBuffSizeUsed,
			LPVOID pBuff );
	static HRESULT FillCVarFromUserBuffer( Type_t type, CVar* pVar, ULONG uBuffSize, LPVOID pData );

public:
     static BOOL TranslateToNewHeap(CPtrSource* pThis,
        CType Type, CFastHeap* pOldHeap, CFastHeap* pNewHeap);
     static BOOL CopyTo(CPtrSource* pThis, CType Type, CPtrSource* pDest,
                        CFastHeap* pOldHeap, CFastHeap* pNewHeap);
     void Delete(CType Type, CFastHeap* pHeap);
    static BOOL CheckCVar(CVar& Var, Type_t nInherentType);
    static BOOL CheckIntervalDateTime(CVar& Var);
    static BOOL DoesTypeNeedChecking(Type_t nInherentType);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CTypedValue
//
//  CTypedValue is exactly the same as CUntypedValue (above) except that the
//  type of the value is stored with the value itself (in fact, the type comes
//  first, followed by the value). This kind of values is used where the type 
//  is not otherwise known, as in the case of qualifiers.
//
//  Most CTypedValue methods are the same as their CUntypedValue counterparts
//  but without the Type parameter.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY:   the address of the memory block of the value.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t:   the lenght of the block of the value (type and data).
//
//*****************************************************************************
//
//  Skip
//
//  Returns:
//
//      LPMEMORY:   points to the first byte after this value's memory block.
//
//*****************************************************************************
//
//  GetType
//
//  Returns:
//
//      CType&:     reference to the type informtation.
//
//*****************************************************************************
//
//  GetRawData
//
//  Returns:
//
//      LPMEMORY:   the pointer to the raw data in the value, i.e., the first
//                  byte of the data.
//
//*****************************************************************************
//
//  AccessPtrData
//
//  Helper function that assumes that the type is one of the pointer types, i.e
//  that the data contains a heap pointer.
//
//  Returns:
//
//      heapptr_t&: the data in the value interpreted as a heapptr_t.
//
//*****************************************************************************
//
//  GetBool
//
//  Helper function that assumes that the type is CIM_BOOLEAN and gets the 
//  boolean value.
//
//  Returns:
//
//      VARIANT_BOOL:   the data in the value interpreted as VARIANT_BOOL.
//
//*****************************************************************************
//
//  TranslateToNewHeap
//
//  Translates the contents of a typed value to use a different heap. Namely, 
//  if the data in the value represents a heap pointer (as with strings or
//  arrays) the data on the heap is copied to the new heap and the heap pointer
//  is replaced with the new value.
//
//  The reason this function is static can be found in 
//  CUntypedValue::LoacFromCVar comment.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to this typed value.
//                              The C value of the pointer can change as we
//                              execute, hence the source is used.
//      CFastHeap* pOldHeap     The heap where the current heap data is found.
//      CFastHeap* pNewHeap     The heap where the heap data should move to.
//
//*****************************************************************************
//
//  CopyTo
//
//  Copies this value to another location. 
//  NOTE: UNLIKE OTHER CopyTo FUNCTIONS, HEAP TRANSLATEION IS NOT PERFORMED.
//  For that, see TranslteToNewHeap. 
//
//  Parameters:
//
//      CTypedValue* pDestination   Destination. Since no heap operations
//                                  occur, this pointer cannot move, and so
//                                  sourcing is not necessary.
//
//*****************************************************************************
//
//  StoreToCVar
//
//  Transfers the contents of a value into a CVar. See 
//  CUntypedValue::StoreToCVar for more information.
//
//  Parameters:
//
//      [in, modified] CVar& Var,       Destination.
//      [in, readonly] CFastHeap* pHeap The heap where the actual data may 
//                                      reside (if we contain a heap pointer).
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the size of the memory block needed to hold a typed value
//  representing a given CVar. That size does not include any data that will
//  go on the heap.
//
//  Parameters:
//
//      CVar& Var       The CVar containing the value.
//
//  Returns:
//
//      lenght_t:   the length required for a CTypedValue.
//
//*****************************************************************************
//
//  static LoadFromCVar
//
//  This function loads a CTypedValue from a CVar. For the explanation of why
//  it has to be static, see CUntypedValue::LoadFromCVar.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the CTypedValue pointer to load
//                              into. Its C value may change during execution,
//                              hence the sourcing.
//      CVar& Var               The CVar to load from.
//      CFastHeap* pHeap        The heap to store extra data (strings, arrays)
//
//*****************************************************************************
//
//  Delete
//
//  Frees whatever data this value has on the heap.
//
//  Parameters:
//
//      CFastHeap* pHeap        The heap where this value stores its extra data
//                              (strings, arrays).
//
//*****************************************************************************
//
//  Compare
//
//  Compares the value stored to a VARIANT.
//
//  Parameters:
//
//      VARIANT* pVariant       The VARIANT to compare to.
//      CFastHeap* pHeap        the heap where this value keeps its extra data
//                              (strings, arrays).
//  Returns:
//
//      0               if the values are the same.
//      0x7FFFFFFF      if the values are incomparable (different types)
//      < 0             if our value is smaller.
//      > 0             if the VARIANT's value is smaller.
//
//*****************************************************************************

class CTypedValue
{
    CType Type;
    CUntypedValue Value; 

public:
     CTypedValue(){}

	 CTypedValue( Type_t nType, LPMEMORY pbData ) : Type( nType )
	 {	CopyMemory( &Value, pbData, Type.GetLength() ); }


     LPMEMORY GetStart() {return (LPMEMORY)this;}
     length_t GetLength() {return sizeof(CType) + Type.GetLength();}
     LPMEMORY Skip() {return GetStart() + GetLength();}

    static  CTypedValue* GetPointer(CPtrSource* pSource)
        {return (CTypedValue*)pSource->GetPointer();}
public:
     LPMEMORY GetRawData() {return Value.GetRawData();}
     UNALIGNED heapptr_t& AccessPtrData() {return Value.AccessPtrData();}
     CType& GetType() {return Type;}

     VARIANT_BOOL GetBool() {return *(UNALIGNED VARIANT_BOOL*)GetRawData();}
public:
     static BOOL TranslateToNewHeap(CPtrSource* pThis,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
        CShiftedPtr Shifted(pThis, sizeof(CType));
        return CUntypedValue::TranslateToNewHeap(&Shifted, 
				CTypedValue::GetPointer(pThis)->Type, pOldHeap, pNewHeap);
    }
    
     void CopyTo(CTypedValue* pNewLocation) 
    {
        memcpy((LPVOID)pNewLocation, this, GetLength());
    }
    
     void Delete(CFastHeap* pHeap) {Value.Delete(Type, pHeap);}

public:
    BOOL StoreToCVar(CVar& Var, CFastHeap* pHeap)
    {
        return Value.StoreToCVar(Type, Var, pHeap);
    }
    static  length_t ComputeNecessarySpace(CVar& Var)
    {
        return CType::GetLength(Var.GetType()) + sizeof(CTypedValue); 
    }
     static HRESULT LoadFromCVar(CPtrSource* pThis, CVar& Var, 
        CFastHeap* pHeap)
    {
        CShiftedPtr Shifted(pThis, sizeof(CType));

		// Check for allocation failures
        Type_t nType;
		HRESULT hr = CUntypedValue::LoadFromCVar(&Shifted, Var, pHeap, nType);

		if ( FAILED(hr) )
		{
			return hr;
		}

		// Unable to load because of a type mismatch
        if(nType == CIM_ILLEGAL)
		{
			return WBEM_E_TYPE_MISMATCH;
		}

        ((CTypedValue*)(pThis->GetPointer()))->Type = nType;
        return hr;
    }

public:
    int Compare(VARIANT* pVariant, CFastHeap* pHeap);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CUntypedArray
//
//  This class represents an array of values of a type that is otherwise known.
//  All the items in the array are of the same type and the type is not stored
//  anywhere. In effect, this class is simply an array of CUntypedValues. Since
//  all the values are of the same type and all our types are fixed length 
//  (variable-length data such as strings is stored on the heap), access to any
//  given element is O(1).
//
//  The in-memory layout of the array (pointed to by its 'this' pointer) is:
//
//  int: number of elements
//  followed by that many elements,
//
//*****************************************************************************
//
//  GetNumElements
//
//  Returns:
//
//      int:    the number of elements in the array.
//
//*****************************************************************************
//
//  static GetHeaderLength
//
//  Returns the amount of space taken up by the array's header (currently, the
//  header contains just the number of elements).
//
//*****************************************************************************
//
//  GetElement
//
//  Finds an element of the array by its index.
//
//  Parameters:
//
//      int nIndex      The index of the element to read.
//      int nSize       The size of each element in the array (see 
//                          CType::GetLength to get it).
//
//*****************************************************************************
//
//  GetLength
//
//  Returns the length of the array in bytes.
//
//  Parameters:
//
//      CType Type      Type of elements in the array (it doesn't know).
//
//  Returns:
//
//      length_t: number of bytes.
//
//*****************************************************************************
//
//  CreateCVarVector
//
//  Allocates a new CVarVector (see var.h) and initializes it with the data in
//  the array.
//
//  Parameters:
//
//      CType Type          The type of elements in the array.
//      CFastHeap* pHeap    The heap where extra data (strings) is kept.
//
//  Returns:
//
//      CVarVector*: newely allocated and initialized. The called must delete
//                      this pointer when done.
//
//*****************************************************************************
//
//  static CalculateNecessarySpace
//
//  Calculates the amount of space required for an CUntypedArray with a given
//  number of elements of a given type.
//
//  Parameters:
//
//      VARTYPE vt      The type of elements.
//      int nElements   The numbed of elements.
//
//  Returns:
//
//      length_t: the number of bytes required for such an array.
//
//*****************************************************************************
//
//  LoadFromCVarVector
//
//  Loads the array with data from a CVarVector. Assumes that the array has
//  already been allocated with enough room for all. For explanation of why
//  this function must be static, see CUntypedValue::LoadFromCVar
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the CUntypedArray
//                              to load the data into. The C value of this
//                              pointer can change, hence the sourcing.
//      CVarVector& vv          The CVarVector to load from.
//      CFastHeap* pHeap        The heap where additional data (strings) should
//                              be kept.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  If this array contains heap pointers (as in the case of strings), this
//  function will allocate all the related data on the new heap and adjust all 
//  the data in the array to reflect the new heap pointers. The data on the 
//  old heap is NOT freed.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the CUntypedArray
//                              to translate. The C value of this pointer can
//                              change, hence the sourcing.
//      CType Type              The type of elements in our array.
//      CFastHeap* pOldHeap     The heap where all extra data for this array
//                              is currently stored.
//      CFastHeap* pNewHeap     The heap to which the data should be moved.
//
//*****************************************************************************
//
//  static CopyToNewHeap
//
//  Takes a heap pointer pointing to a CUntypedArray and copies this array to 
//  another heap, returning the heap pointer to the copy. In addition to 
//  copying the array's memory block, it also translates all its internal heap
//  pointers (as in the case of an array of strings) to the new heap (see also
//  TranslateToNewHeap). It is assumed that the extra data for the array is 
//  located on the same heap as the array itself.
//
//  Parameters:
//
//      heapptr_t ptrOld        The heap pointer to the array (on the pOldHeap)
//      CType Type              The type of elements in our array.
//      CFastHeap* pOldHeap     The heap where all extra data for this array
//                              is currently stored.
//      CFastHeap* pNewHeap     The heap to which the data should be moved.
//
//*****************************************************************************

class COREPROX_POLARITY CUntypedArray
{
    int m_nNumElements;
protected:

	// Verifies that the supplied buffer size will hold the elements required.
	static HRESULT CheckRangeSizeForGet( Type_t nInherentType, length_t nLength, ULONG uNumElements,
										ULONG uBuffSize, ULONG* pulBuffRequired );

	// Requires a heap pointer
	static HRESULT ReallocArray( CPtrSource* pThis, Type_t nInherentType, CFastHeap* pHeap,
										ULONG uNumNewElements, ULONG* puNumOldElements,
										ULONG* puTotalNewElements, heapptr_t* pNewArrayPtr );

public:
    int GetNumElements() {return m_nNumElements;}
    static length_t GetHeaderLength() {return sizeof(int);}
#pragma optimize("", off)
     LPMEMORY GetElement(int nIndex, int nSize);

	// Checks that a supplied range is proper for the supplied buffer
	static HRESULT CheckRangeSize( Type_t nInherentType, length_t nLength, ULONG uNumElements,
									ULONG uBuffSize, LPVOID pData );

	// Send a datatable pointer in here.	The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit
	// in the current array
	 static HRESULT SetRange( CPtrSource* pThis, long lFlags, Type_t nInherentType, length_t nLength,
							CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
							LPVOID pData );

	// Gets a range of elements from an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings are converted to WCHAR and separated by NULLs.  Object properties
	// are returned as an array of _IWmiObject pointers.  The range MUST be within the bounds
	// of the current array. Send a heap pointer in here
	static HRESULT GetRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
						CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
						ULONG* puBuffSizeUsed, LPVOID pData );

	 // Send a heap pointer in here
	static HRESULT RemoveRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
							CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements );

	 // Send a Datatable pointer in here
	static HRESULT AppendRange( CPtrSource* pThis, Type_t nType, length_t nLength,
								CFastHeap* pHeap, ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
#pragma optimize("", on)
     length_t GetLengthByType(CType Type)
    {
        return sizeof(m_nNumElements) + Type.GetLength() * m_nNumElements;
    }

     length_t GetLengthByActualLength(int nLength)
    {
        return sizeof(m_nNumElements) + nLength * m_nNumElements;
    }

    static  CUntypedArray* GetPointer(CPtrSource* pThis)
        { return (CUntypedArray*)(pThis->GetPointer());}

     CVarVector* CreateCVarVector(CType Type, CFastHeap* pHeap);
    static  HRESULT LoadFromCVarVector(CPtrSource* pThis,
        CVarVector& vv, Type_t nType, CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld);
    static  length_t CalculateNecessarySpaceByType(CType Type, int nElements)
    {
        return sizeof(int) + nElements * Type.GetLength();
    }
    static  length_t CalculateNecessarySpaceByLength( int nLength, int nElements)
    {
        return sizeof(int) + nElements * nLength;
    }
public:
     void Delete(CType Type, CFastHeap* pHeap);
     static BOOL TranslateToNewHeap(CPtrSource* pThis, 
        CType Type, CFastHeap* pOldHeap, CFastHeap* pNewHeap);
     static BOOL CopyToNewHeap(heapptr_t ptrOld, CType Type, 
                           CFastHeap* pOldHeap, CFastHeap* pNewHeap,
						   UNALIGNED heapptr_t& ptrResult);

    static BOOL CheckCVarVector(CVarVector& vv, Type_t nInherentType);
    static BOOL CheckIntervalDateTime(CVarVector& vv);

	HRESULT IsArrayValid( CType Type, CFastHeap* pHeap );
};

#pragma pack(pop)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\hiperfenum.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    HIPERFENUM.H

Abstract:

    Hi-Perf Enumerators

History:

--*/

#ifndef __HIPERFENUM_H__
#define __HIPERFENUM_H__

#include "hiperflock.h"

//
//	Classes CHiPerfEnumData, CHiPerfEnum
//
//	CHiPerfEnumData:
//	This is a simple data holder class that contains data that is manipulated
//	by the CHiPerfEnum class.
//
//	CHiPerfEnum:
//	This class provides an implementation of the IWbemHiPerfEnum interface.
//	It is passed to Refreshers when a client requests a refreshable enumeration.
//	This class provides a repository of data which is copied into an implementation
//	of IEnumWbemClassObject so a client can walk a refreshed enumeration.
//
//

// Holds data for the HiPerfEnum implementation
class COREPROX_POLARITY CHiPerfEnumData
{

public:
	CHiPerfEnumData( long lId = 0, IWbemObjectAccess* pObj = NULL )
		:	m_lId( lId ),
			m_pObj( pObj )
	{
		if ( NULL != m_pObj )
		{
			m_pObj->AddRef();
		}
	}

	~CHiPerfEnumData()
	{
		if ( NULL != m_pObj )
		{
			m_pObj->Release();
		}
	}

	void Clear( void )
	{
		if ( NULL != m_pObj ) m_pObj->Release();
		m_pObj = NULL;
		m_lId = 0;
	}

	void SetData( long lId, IWbemObjectAccess* pObj )
	{
		// Enusures AddRef/Release all happens
		SetObject( pObj );
		m_lId = lId;
	}

	// Accessors
	void SetObject( IWbemObjectAccess* pObj )
	{
		if ( NULL != pObj ) pObj->AddRef();
		if ( NULL != m_pObj ) m_pObj->Release();
		m_pObj = pObj;
	}

	void SetId( long lId )
	{
		m_lId = lId;
	}

	long GetId( void )
	{
		return m_lId;
	}

	IWbemObjectAccess* GetObject( void )
	{
		if ( NULL != m_pObj ) m_pObj->AddRef();
		return m_pObj;
	}

	IWbemObjectAccess*	m_pObj;
	long				m_lId;

};

// The next two classes will perform all of the garbage
// collection we need.  If we need to implement our own
// arrays we can do so here as well.

#define HPENUMARRAY_ALL_ELEMENTS	0xFFFFFFFF
#define HPENUMARRAY_GC_DEFAULT		0xFFFFFFFF

// This guy does all the garbage collection
class COREPROX_POLARITY CGarbageCollectArray : public CFlexArray
{
protected:

	int		m_nNumElementsPending;
	int		m_nNumElementsExpired;
	BOOL	m_fClearFromFront;

public:

	// Do we garbage collect from front or back?
	CGarbageCollectArray( BOOL fClearFromFront ) :
		CFlexArray(), m_nNumElementsPending( 0 ), m_nNumElementsExpired( 0 ), m_fClearFromFront( fClearFromFront )
	{};
	virtual ~CGarbageCollectArray()
	{
		Empty();
	}

	BOOL GarbageCollect( int nNumToGarbageCollect = HPENUMARRAY_GC_DEFAULT );

	void ClearExpiredElements( void )
	{
		Clear( m_nNumElementsExpired );
		m_nNumElementsExpired = 0;
	}

	void Clear( int nNumToClear = HPENUMARRAY_ALL_ELEMENTS );

	// pure
	virtual void ClearElements( int nNumToClear ) = 0;

};

// All we need to do is implement ClearElements.
class COREPROX_POLARITY CHPEnumDataArray : public CGarbageCollectArray
{
public:
	CHPEnumDataArray() :
		CGarbageCollectArray( TRUE )
	{};
	~CHPEnumDataArray()
	{
	}

	void ClearElements( int nNumToClear );

};

class COREPROX_POLARITY CHiPerfEnum : public IWbemHiPerfEnum
{
public:

	CHiPerfEnum();
	virtual ~CHiPerfEnum();

	//	IUnknown implementations

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

	/* IWbemHiPerfEnum */
	STDMETHOD(AddObjects)( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj );
	STDMETHOD(RemoveObjects)( long lFlags, ULONG uNumObjects, long* apIds );
	STDMETHOD(GetObjects)( long lFlags, ULONG uNumObjects, IWbemObjectAccess** papObj, ULONG* plNumReturned );
	STDMETHOD(RemoveAll)( long lFlags );

	// Access to the instance template
	HRESULT SetInstanceTemplate( CWbemInstance* pInst );

	CWbemInstance* GetInstanceTemplate( void )
	{
		if ( NULL != m_pInstTemplate )
		{
			m_pInstTemplate->AddRef();
		}

		return m_pInstTemplate;
	}

protected:

	CHPEnumDataArray	m_aIdToObject;
	CHPEnumDataArray	m_aReusable;
	CWbemInstance*	m_pInstTemplate;
	CHiPerfLock		m_Lock;

	CHiPerfEnumData* GetEnumDataPtr( long lId, IWbemObjectAccess* pObj );
	HRESULT	InsertElement( CHiPerfEnumData* pData );
	HRESULT	RemoveElement( long lId );
	void ClearArray( void );

	long			m_lRefCount;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\frfoobj.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FRFOOBJ.CPP

Abstract:

  CWmiFreeFormObject implementation.

  Implements the _IWmiFreeFormObject interface.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "frfoobj.h"
#include <corex.h>
#include "strutils.h"

//***************************************************************************
//
//  CWmiFreeFormObject::~CWmiFreeFormObject
//
//***************************************************************************
// ok
CWmiFreeFormObject::CWmiFreeFormObject( CLifeControl* pControl, IUnknown* pOuter )
:	CWmiObjectWrapper( pControl, pOuter ),
	m_XFreeFormObject( this ),
	m_InstanceProperties(),
	m_PropertyOrigins(),
	m_MethodOrigins()
{
	ObjectCreated( OBJECT_TYPE_FREEFORM_OBJ, this );
}
    
//***************************************************************************
//
//  CWmiFreeFormObject::~CWmiFreeFormObject
//
//***************************************************************************
// ok
CWmiFreeFormObject::~CWmiFreeFormObject()
{
	ObjectDestroyed( OBJECT_TYPE_FREEFORM_OBJ, this );
}


// Helper functions
HRESULT CWmiFreeFormObject::Init( CWbemObject* pObj )
{

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL == pObj )
	{
		// We always start out as a Class
		pObj = new CWbemClass;

		if ( NULL != pObj )
		{
			try
			{
				// This will throw a memory exception if it fails.
				// We ask for the extra size so that we can limit
				// the number of potential reallocations that occur.
				hr = ((CWbemClass*) pObj)->InitEmpty( FREEFORM_OBJ_EXTRAMEM );
			}
			catch( CX_MemoryException )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			catch(...)
			{
				hr = WBEM_E_FAILED;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}

	}

	if ( SUCCEEDED( hr ) )
	{
		// Cleanup the old object
		if ( NULL != m_pObj )
		{
			m_pObj->Release();
		}

		// Finally, set the "wrapped" object
		m_pObj = pObj;
		m_pObj->AddRef();
	}

	return hr;
}

CWmiObjectWrapper* CWmiFreeFormObject::CreateNewWrapper( BOOL fClone )
{
	CWmiFreeFormObject*	pNewObj = new CWmiFreeFormObject( m_pControl, m_pOuter );

	if ( NULL != pNewObj )
	{
		if ( !SUCCEEDED( pNewObj->Copy( *this ) ) )
		{
			delete pNewObj;
			pNewObj = NULL;
		}
	}

	return pNewObj;
}

// Copy the property bags
HRESULT CWmiFreeFormObject::Copy( const CWmiFreeFormObject& source )
{
	HRESULT	hr = m_InstanceProperties.Copy( source.m_InstanceProperties );

	if ( SUCCEEDED( hr ) )
	{
		hr = m_PropertyOrigins.Copy( source.m_PropertyOrigins );

		if ( SUCCEEDED( hr ) )
		{
			hr = m_MethodOrigins.Copy( source.m_MethodOrigins );
		}
	}

	return hr;
}

/*	IUnknown Methods */

void* CWmiFreeFormObject::GetInterface(REFIID riid)
{
	if ( riid == IID_IUnknown || riid == IID__IWmiFreeFormObject )
	{
		return &m_XFreeFormObject;
	}
	else if ( riid == IID__IWmiObject )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID__IWmiObjectAccessEx )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IWbemObjectAccess )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IWbemClassObject )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IMarshal )
	{
		return &m_XObjectMarshal;
	}
    return NULL;
}

/*_IWmiFreeFormObject Pass-thrus */
// Specifies a property origin (in case we have properties originating in classes
// which we know nothing about).
STDMETHODIMP CWmiFreeFormObject::XFreeFormObject::SetPropertyOrigin( long lFlags, LPCWSTR pszPropName, LPCWSTR pszClassName )
{
	//Pass through to the wrapper
	return m_pObject->SetPropertyOrigin( lFlags, pszPropName, pszClassName );
}

// Specifies a method origin (in case we have methods originating in classes
// which we know nothing about).
STDMETHODIMP CWmiFreeFormObject::XFreeFormObject::SetMethodOrigin( long lFlags, LPCWSTR pszMethodName, LPCWSTR pszClassName )
{
	//Pass through to the wrapper
	return m_pObject->SetMethodOrigin( lFlags, pszMethodName, pszClassName );

}

// Specifies the inheritance chain - Only valid while object is a class and class name has
// NOT been set.  This will cause a derived class to be generated.  All properties and
// classes must have been set prior to setting the actual class name.  The class in the
// last position will be set as the current class name, and the remainder will be set as the
// actual chain and then a derived class will be spawned.
STDMETHODIMP CWmiFreeFormObject::XFreeFormObject::SetDerivation( long lFlags, ULONG uNumClasses, LPCWSTR pwszInheritanceChain )
{
	//Pass through to the wrapper
	return m_pObject->SetDerivation( lFlags, uNumClasses, pwszInheritanceChain );

}

// Specifies the class name - Only valid while object is a class and no pevious name has
// been set.
STDMETHODIMP CWmiFreeFormObject::XFreeFormObject::SetClassName( long lFlags, LPCWSTR pszClassName )
{
	//Pass through to the wrapper
	return m_pObject->SetClassName( lFlags, pszClassName );
}

// Converts the current object into an instance.  If it is already an instance, this will
// fail.  Writes properties assigned to instance during AddProperty operations
STDMETHODIMP CWmiFreeFormObject::XFreeFormObject::MakeInstance( long lFlags )
{
	//Pass through to the wrapper
	return m_pObject->MakeInstance( lFlags );
}

// Assumes caller knows prop type; Supports all CIMTYPES.
// Strings MUST be null-terminated wchar_t arrays.
// Objects are passed in as _IWmiObject pointers
// Using a NULL buffer will set the property to NULL
// Array properties must conform to array guidelines.
// Only works when the object is not an instance.
// If WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE is set
// then property will only be added and the value will
// be assigned when MakeInstance() is called
STDMETHODIMP CWmiFreeFormObject::XFreeFormObject::AddProperty( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
												CIMTYPE uCimType, LPVOID pUserBuf )
{
	//Pass through to the wrapper
	return m_pObject->AddProperty( pszPropName, lFlags, uBufSize, uNumElements, uCimType, pUserBuf );

}

// Reverts to a clean state
STDMETHODIMP CWmiFreeFormObject::XFreeFormObject::Reset( long lFlags )
{
	return m_pObject->Reset( lFlags );
}

/* IWbemClassObject method overrides */
HRESULT CWmiFreeFormObject::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// First check the lookaside.  If that fails, then get the real origin
	CIMTYPE	ct;
	ULONG	uDataSize;
	ULONG	uNumElements;
	LPCWSTR	pwszClassName;

	HRESULT hr = m_PropertyOrigins.Get( wszProperty, &ct, &uDataSize, &uNumElements, (LPVOID*) &pwszClassName );

	if ( SUCCEEDED( hr ) )
	{
		// Allocate an origin for the caller
		*pstrClassName = SysAllocString( pwszClassName );

		if ( NULL == *pstrClassName )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		hr = m_pObj->GetPropertyOrigin( wszProperty, pstrClassName );
	}

	return hr;
}

HRESULT CWmiFreeFormObject::GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// First check the lookaside.  If that fails, then get the real origin
	CIMTYPE	ct;
	ULONG	uDataSize;
	ULONG	uNumElements;
	LPCWSTR	pwszClassName;

	HRESULT hr = m_MethodOrigins.Get( wszMethodName, &ct, &uDataSize, &uNumElements, (LPVOID*) &pwszClassName );

	if ( SUCCEEDED( hr ) )
	{
		// Allocate an origin for the caller
		*pstrClassName = SysAllocString( pwszClassName );

		if ( NULL == *pstrClassName )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		hr = m_pObj->GetMethodOrigin( wszMethodName, pstrClassName );
	}

	return hr;
}

/* _IWmiFreeFormObject Methods */

// Specifies a property origin (in case we have properties originating in classes
// which we know nothing about).
HRESULT CWmiFreeFormObject::SetPropertyOrigin( long lFlags, LPCWSTR pszPropName, LPCWSTR pszClassName )
{
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock(this);

	HRESULT	hr = WBEM_S_NO_ERROR;

	//First, see if it's in the object
	classindex_t	nIndex = m_pObj->GetClassIndex( pszClassName );

	if ( -1 != nIndex )
	{
		hr = m_pObj->SetPropertyOrigin( pszPropName, nIndex );
	}
	else
	{
		// No, so add it into our little list
		hr = m_PropertyOrigins.Add( pszPropName, CIM_STRING,
				( wcslen( pszClassName ) + 1 ) * 2, 0L, (LPVOID) pszClassName );
	}

	return hr;
}

// Specifies a method origin (in case we have methods originating in classes
// which we know nothing about).
HRESULT CWmiFreeFormObject::SetMethodOrigin( long lFlags, LPCWSTR pszMethodName, LPCWSTR pszClassName )
{
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock(this);

	HRESULT	hr = WBEM_S_NO_ERROR;

	//First, see if it's in the object
	classindex_t	nIndex = m_pObj->GetClassIndex( pszClassName );

	if ( -1 != nIndex )
	{
		hr = m_pObj->SetMethodOrigin( pszMethodName, nIndex );
	}
	else
	{
		// No, so add it into our little list
		hr = m_MethodOrigins.Add( pszMethodName, CIM_STRING,
				( wcslen( pszClassName ) + 1 ) * 2, 0L, (LPVOID) pszClassName );
	}

	return hr;
}

// Specifies the inheritance chain - Only valid while object is a class and class name has
// NOT been set.  This will cause a derived class to be generated.  All properties and
// classes must have been set prior to setting the actual class name.  The class in the
// last position will be set as the current class name, and the remainder will be set as the
// actual chain and then a derived class will be spawned.
HRESULT CWmiFreeFormObject::SetDerivation( long lFlags, ULONG uNumClasses, LPCWSTR pwszInheritanceChain )
{
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock(this);

	// Temporary storage - we will allocate if needed
	LPCWSTR		awszHierarchy[32];
	LPCWSTR*	apwszHierarchy = awszHierarchy;

	if ( uNumClasses > 32 )
	{
		apwszHierarchy = new LPCWSTR[uNumClasses];

		if ( NULL == apwszHierarchy )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

	// Now walk the hierarchy and set the pointers in the array
	LPCWSTR	pwstrCurr = pwszInheritanceChain;
	for (	ULONG x = 0;
			x < uNumClasses;
			x++,
			pwstrCurr += ( wcslen(pwstrCurr) + 1 ) )	// Points to the next class
	{
		apwszHierarchy[x] = pwstrCurr;
	}

	// If it is empty, we are able to set the classname to the superclassname, then we will 
	// go ahead and then spawn a derived class.  All properties and methods must have
	// been set previously.

	HRESULT	hr = SetClassName( lFlags, apwszHierarchy[uNumClasses-1] );

	if ( SUCCEEDED( hr ) )
	{
		// Set the inheritance chain to contain the rest of the classes.
		// If this succeeds, then we are in business
		if ( uNumClasses > 1 )
		{
			hr = m_pObj->SetInheritanceChain( uNumClasses - 1, (LPWSTR*) apwszHierarchy );
		}

		if ( SUCCEEDED( hr ) )
		{
			CWbemClass*	pNewClass = NULL;

			// Lock and unlock around the BLOB.  The next call will workaround the fact that
			// the underlying object is not necessarily decorated
			m_pObj->Lock( 0L );
			hr = ((CWbemClass*) m_pObj)->CreateDerivedClass( &pNewClass );
			m_pObj->Unlock( 0L );

			if ( SUCCEEDED( hr ) )
			{
				// Clean up the old object and store the new
				// class.

				m_pObj->Release();
				m_pObj = pNewClass;

			}	// IF Spawned a derived class

		}	// IF inheritance properly set up

	}	// IF Wrote Class name
	else
	{
		hr = WBEM_E_ACCESS_DENIED;
	}

	// Cleanup memory if we allocated any
	if ( apwszHierarchy != awszHierarchy )
	{
		delete apwszHierarchy;
	}

	return hr;
}

// Specifies the class name - Only valid while object is a class and no pevious name has
// been set.
HRESULT CWmiFreeFormObject::SetClassName( long lFlags, LPCWSTR pszClassName )
{
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock(this);

	// Get the class name.  If it is empty, then we will allow the current class name to be set

	CVar	v;
	HRESULT	hr = m_pObj->GetClassName( &v );

	if ( SUCCEEDED( hr ) && v.IsNull() )
	{
		hr = m_pObj->WriteProp( L"__CLASS", 0L, ( wcslen(pszClassName) + 1 ) * 2, 0,
								CIM_STRING, (void*) pszClassName );
	}
	else
	{
		hr = WBEM_E_ACCESS_DENIED;
	}

	return hr;
}

// Converts the current object into an instance.  If it is already an instance, this will
// fail.  Writes properties assigned to instance during AddProperty operations
HRESULT CWmiFreeFormObject::MakeInstance( long lFlags )
{
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock(this);

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( !m_pObj->IsInstance() )
	{
		CWbemObject*	pInstance = NULL;

		hr = m_pObj->SpawnInstance( lFlags, (IWbemClassObject**) &pInstance );

		if ( SUCCEEDED( hr ) )
		{
			// Enumerate the properties in the property bag and assign them
			// to the new instance.

			int	nNumProps = m_InstanceProperties.Size();

			for ( int x = 0; SUCCEEDED( hr ) && x < nNumProps; x++ )
			{
				LPCWSTR	pwszPropName;
				ULONG uBufSize;
				ULONG uNumElements;
				CIMTYPE uCimType;
				LPVOID pUserBuf;

				// Get the actual values, then write the new value
				hr = m_InstanceProperties.Get( x, &pwszPropName, &uCimType, &uBufSize, &uNumElements,
												&pUserBuf );

				if ( SUCCEEDED( hr ) )
				{
					hr = pInstance->WriteProp( pwszPropName, 0L, uBufSize, uNumElements, uCimType, pUserBuf );
				}
			}	// FOR enum properties

			// Check if we got thrugh this okay
			if ( SUCCEEDED( hr ) )
			{
				unsigned __int64	i64Flags = 0L;

				hr = m_pObj->QueryObjectFlags( 0L, WMIOBJECT_GETOBJECT_LOFLAG_DECORATED, &i64Flags );

				// If the original object was decorated, we need to propagate the decoration
				// to the instance
				if ( SUCCEEDED( hr ) && ( i64Flags & WMIOBJECT_GETOBJECT_LOFLAG_DECORATED ) )
				{
					CVar	vServer;
					CVar	vNamespace;

					hr = m_pObj->GetServer( &vServer );
					
					if ( SUCCEEDED( hr ) )
					{
						hr = m_pObj->GetNamespace( &vNamespace );

						if ( SUCCEEDED( hr ) )
						{
							// Decorate the object using server and namespace
							hr = pInstance->SetDecoration( vServer.GetLPWSTR(), vNamespace.GetLPWSTR() );
						}	// IF GetNamespace

					}	// IF GetServer

				}	// IF IsDecorated

				// IF we're still okay, we need to replace the underlying object
				if ( SUCCEEDED( hr ) )
				{
					m_pObj->Release();
					m_pObj = pInstance;
					m_pObj->AddRef();
				}

			}

		}	// IF we spawned the instance

	}	// IF the object is not an Instance
	else
	{
		hr = WBEM_E_ACCESS_DENIED;
	}

	return hr;
}

// Assumes caller knows prop type; Supports all CIMTYPES.
// Strings MUST be null-terminated wchar_t arrays.
// Objects are passed in as _IWmiObject pointers
// Using a NULL buffer will set the property to NULL
// Array properties must conform to array guidelines.
// Only works when the object is not an instance.
// If WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE is set
// then property will only be added and the value will
// be assigned when MakeInstance() is called
HRESULT CWmiFreeFormObject::AddProperty( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
												CIMTYPE uCimType, LPVOID pUserBuf )
{
	if ( lFlags & ~WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock(this);

	// We don't do this operation if we're an instance
	if ( m_pObj->IsInstance() )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	// Store whether or not we should write the property into the instance property bag
	BOOL	fWriteToInstance = lFlags & WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE;

	CVar	var;
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If we're saving the value for the instance, then we'll just set a NULL property
	// in the class
	if ( fWriteToInstance )
	{
		hr = m_pObj->WriteProp( pszPropName, 0L, 0, 0, uCimType, NULL );

		if ( SUCCEEDED( hr ) )
		{
			hr = m_InstanceProperties.Add( pszPropName, uCimType, uBufSize, uNumElements, pUserBuf );
		}
	}
	else
	{
		// Write values in directly
		hr = m_pObj->WriteProp( pszPropName, 0L, uBufSize, uNumElements, uCimType, pUserBuf );
	}

	return hr;
}

// Reverts to a clean state
HRESULT CWmiFreeFormObject::Reset( long lFlags )
{
	if ( 0L != lFlags )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CLock	lock(this);

	// Call Init to cleanup the object.  If this succeeds, when we need to
	// empty the property bags.

	HRESULT	hr = Init( NULL );

	if ( SUCCEEDED( hr ) )
	{
		// Dump the property bags - they're meaningless now
		m_InstanceProperties.RemoveAll();
		m_PropertyOrigins.RemoveAll();
		m_MethodOrigins.RemoveAll();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mrshbase.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MRSHBASE.CPP

Abstract:

    Marshaling base classes.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "mrshbase.h"
#include <fastall.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CBaseProxyBuffer::CBaseProxyBuffer
//  ~CBaseProxyBuffer::CBaseProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CBaseProxyBuffer::CBaseProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter, REFIID riid)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
       m_pChannel(NULL), m_pOldProxy( NULL ), m_riid( riid ), m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
}

CBaseProxyBuffer::~CBaseProxyBuffer()
{
    // Derived class will destruct first, so it should have cleaned up the
    // old interface pointer by now.

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pControl->ObjectDestroyed(this);

}

ULONG STDMETHODCALLTYPE CBaseProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CBaseProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CBaseProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == m_riid)
    {
        *ppv = GetInterface( riid );
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  STDMETHODIMP CBaseProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CBaseProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    IPSFactoryBuffer*   pIPS;
    HRESULT             hr = S_OK;

    if( NULL == m_pChannel )
    {

        // Establish the marshaling context
        DWORD   dwCtxt = 0;
        pChannel->GetDestCtx( &dwCtxt, NULL );

        m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

        // This is tricky -- All WBEM Interface Proxy/Stubs are still available
        // in WBEMSVC.DLL, but the CLSID for the PSFactory is the same as
        // IID_IWbemObjectSink.

        // get a pointer to the old interface which is in WBEMSVC.DLL  this allows
        // for backward compatibility

        hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                        NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

        // We aggregated it --- WE OWN IT!
        
        if ( SUCCEEDED( hr ) )
        {
            hr = pIPS->CreateProxy( this, m_riid, &m_pOldProxy, GetOldProxyInterfacePtr() );

            if ( SUCCEEDED( hr ) )
            {
                // Save a reference to the channel

                hr = m_pOldProxy->Connect( pChannel );

                m_pChannel = pChannel;
                if(m_pChannel)
                    m_pChannel->AddRef();
            }

            pIPS->Release();
        }

    }
    else
    {
        hr = E_UNEXPECTED;
    }


    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CBaseProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CBaseProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old interfaces MUST be released first.

    ReleaseOldProxyInterface();

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

/*
**  Stub Buffer Code
*/

CBaseStublet::CBaseStublet(CBaseStubBuffer* pObj, REFIID riid) 
    : CImpl<IRpcStubBuffer, CBaseStubBuffer>(pObj), m_lConnections( 0 ), m_riid( riid )
{
}

CBaseStublet::~CBaseStublet() 
{
    // The server pointer will have been cleaned up by the derived class

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CBaseStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject sink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CBaseStublet::Connect(IUnknown* pUnkServer)
{
    // Something is wrong
    if( GetServerInterface() )
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface( m_riid, GetServerPtr() );
    if(FAILED(hres))
        return E_NOINTERFACE;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    IPSFactoryBuffer*   pIPS;

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

    if ( SUCCEEDED( hr ) )
    {
        hr = pIPS->CreateStub( m_riid, GetServerInterface(), &m_pObject->m_pOldStub );

        if ( SUCCEEDED( hr ) )
        {
            // Successful connection
            m_lConnections++;
        }

        pIPS->Release();

    }

    return hr;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CBaseStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemObjectSink
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CBaseStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    ReleaseServerPointer();

    // Successful disconnect
    m_lConnections--;

}

STDMETHODIMP CBaseStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( NULL != m_pObject->m_pOldStub )
    {
        return m_pObject->m_pOldStub->Invoke( pMessage, pChannel );
    }
    else
    {
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;
    }
}

IRpcStubBuffer* STDMETHODCALLTYPE CBaseStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == m_riid)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CBaseStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CBaseStublet::DebugServerQueryInterface(void** ppv)
{
    *ppv = GetServerInterface();

    if ( NULL == *ppv )
    {
        return E_UNEXPECTED;
    }

    return S_OK;
}

void STDMETHODCALLTYPE CBaseStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\frfoobj.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FRFOOBJ.H

Abstract:

  CWmiFreeForObject Definition.

  Standard definition for _IWmiFreeFormObject.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _FRFOOBJ_H_
#define _FRFOOBJ_H_

#include "corepol.h"
#include <arena.h>
#include "wrapobj.h"
#include "fastprbg.h"

#define FREEFORM_OBJ_EXTRAMEM	4096

//***************************************************************************
//
//  class CWmiFreeFormObject
//
//  Implementation of _IWmiFreeFormObject Interface
//
//***************************************************************************

class COREPROX_POLARITY CWmiFreeFormObject : public CWmiObjectWrapper
{

public:

	CFastPropertyBag	m_InstanceProperties;

	// We'll make double duty from this class
	CFastPropertyBag	m_PropertyOrigins;
	CFastPropertyBag	m_MethodOrigins;

    CWmiFreeFormObject(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWmiFreeFormObject(); 

	// Special overloaded IWbemClassObject Functions
    HRESULT GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName);
    HRESULT GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName);

	// _IWmiFreeFormObject Methods

    class COREPROX_POLARITY XFreeFormObject : public CImpl<_IWmiFreeFormObject, CWmiFreeFormObject>
    {
    public:
        XFreeFormObject(CWmiFreeFormObject* pObject) : 
            CImpl<_IWmiFreeFormObject, CWmiFreeFormObject>(pObject)
        {}

		STDMETHOD(SetPropertyOrigin)( long lFlags, LPCWSTR pszPropName, LPCWSTR pszClassName );
		STDMETHOD(SetMethodOrigin)( long lFlags, LPCWSTR pszMethodName, LPCWSTR pszClassName );
		STDMETHOD(SetDerivation)( long lFlags, ULONG uNumClasses, LPCWSTR awszInheritanceChain );
		STDMETHOD(SetClassName)( long lFlags, LPCWSTR pszClassName );
		STDMETHOD(MakeInstance)( long lFlags );
		STDMETHOD(AddProperty)( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
								CIMTYPE uCimType, LPVOID pUserBuf );

		STDMETHOD(Reset)( long lFlags );
		// Resets the object to a clean state

    } m_XFreeFormObject;
    friend XFreeFormObject;
	
    virtual HRESULT SetPropertyOrigin( long lFlags, LPCWSTR pszPropName, LPCWSTR pszClassName );
	// Specifies a property origin (in case we have properties originating in classes
	// which we know nothing about).

	virtual HRESULT SetMethodOrigin( long lFlags, LPCWSTR pszMethodName, LPCWSTR pszClassName );
	// Specifies a method origin (in case we have methods originating in classes
	// which we know nothing about).

    virtual HRESULT SetDerivation( long lFlags, ULONG uNumClasses, LPCWSTR awszInheritanceChain );
	// Specifies the inheritance chain - Only valid while object is a class and class name has
	// NOT been set.  This will cause a derived class to be generated.  All properties and
	// classes must have been set prior to setting the actual class name.  The class in the
	// zero position will be set as the current class name, and the remainder will be set as the
	// actual chain and then a derived class will be spawned.  The classes are passed in as
	// an array of pointers to class names

	virtual HRESULT SetClassName( long lFlags, LPCWSTR pszClassName );
	// Specifies the class name - Only valid while object is a class.  If Superclass has been set
	// this will cause a derived class to be created

    virtual HRESULT MakeInstance( long lFlags );
	// Converts the current object into an instance.  If it is already an instance, this will
	// fail.  Writes properties assigned to instance during AddProperty operations

	virtual HRESULT AddProperty( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
							CIMTYPE uCimType, LPVOID pUserBuf );
    // Assumes caller knows prop type; Supports all CIMTYPES.
	// Strings MUST be null-terminated wchar_t arrays.
	// Objects are passed in as _IWmiObject pointers
	// Using a NULL buffer will set the property to NULL
	// Array properties must conform to array guidelines.
	// Only works when the object is not an instance.
	// If WMIOBJECT_FREEFORM_FLAG_WRITE_TO_INSTANCE is set
	// then property will only be added and the value will
	// be assigned when MakeInstance() is called

	virtual HRESULT Reset( long lFlags );
	// Resets the object to a clean state

public:
	
	// Helper function to initialize the wrapper (we need something to wrap).
	HRESULT Init( CWbemObject* pObj );

	// Creates a new wrapper object to wrap any objects we may return
	CWmiObjectWrapper*	CreateNewWrapper( BOOL fClone );

protected:
    void* GetInterface(REFIID riid);

	HRESULT Copy( const CWmiFreeFormObject& sourceobj );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastval.inc ===
//=============================================================================
//
//                              FASTVAL.INC
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  This file contains inline function implementations for the classes related 
//  to value representation. It is included from fastval.h.
//  The non-inline functions for these classes are implemented in fastval.cpp
//
//  See fastval.h for all documentation
//
//  Classes implemented: 
//      CType               Representing property type
//      CUntypedValue       A value with otherwise known type.
//      CTypedValue         A value with stored type.
//      CUntypedArray       Array of values of otherwise known type.
//
//  History:
//
//      2/21/97     a-levn  Fully documented
//
//=============================================================================

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\hiperflock.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    HIPERFLOCK.H

Abstract:

    HiPerf Spinlock

History:


--*/

#ifndef __HIPERF_LOCK__H_
#define __HIPERF_LOCK__H_

//
//	Classes CHiPerfLock
//
//	CHiPerfLock:
//	This is a simple spinlock we are using for hi performance synchronization of
//	IWbemHiPerfProvider, IWbemHiPerfEnum, IWbemRefresher and IWbemConfigureRefresher
//	interfaces.  The important thing here is that the Lock uses InterlockedIncrement()
//	and InterlockedDecrement() to handle its lock as opposed to a critical section.
//	It does have a timeout, which currently defaults to 10 seconds.
//


#define	HIPERF_UNLOCKED	-1

// 10 Second default timeout
#define	HIPERF_DEFAULT_TIMEOUT	10000

class COREPROX_POLARITY CHiPerfLock
{
public:
	CHiPerfLock()
	:	m_lLock( HIPERF_UNLOCKED ),
		m_dwThreadId( 0 ),
		m_lLockCount( 0 )
	{
	}

	~CHiPerfLock() {};

	BOOL Lock( DWORD dwTimeout = HIPERF_DEFAULT_TIMEOUT )
	{
		DWORD	dwFirstTick = 0;

        int		nSpin = 0;
		BOOL	fAcquiredLock = FALSE,
				fIncDec = FALSE;

		// Only do this once
		DWORD	dwCurrentThreadId = GetCurrentThreadId();

		// Check if we are the current owning thread.  We can do this here because
		// this test will ONLY succeed in the case where we have a Nested Lock(),
		// AND because we are zeroing out the thread id when the lock count hits
		// 0.

		if( dwCurrentThreadId == m_dwThreadId )
		{
			// It's us - Bump the lock count
			// =============================

			// Don't need to use InterlockedInc/Dec here because
			// this will ONLY happen on pData->m_dwThreadId.

			++m_lLockCount;
			return TRUE;
		}


        while( !fAcquiredLock )
        {

			// We only increment/decrement when pData->m_lLock is -1
			if ( m_lLock == HIPERF_UNLOCKED )
			{
				fIncDec = TRUE;

				// Since only one thread will get the 0, it is this thread that
				// actually acquires the lock.
				fAcquiredLock = ( InterlockedIncrement( &m_lLock ) == 0 );
			}
			else
			{

				fIncDec = FALSE;
			}

			// Only spins if we don't acquire the lock
			if ( !fAcquiredLock )
			{

				// Clean up our Incremented value only if we actually incremented
				// it to begin with
				if ( fIncDec )
					InterlockedDecrement( &m_lLock );

				// to spin or not to spin
				if(nSpin++ == 10000)
				{

					// Check for timeout
					// DEVNOTE:TODO:SANJ - What if tick count rollsover??? a timeout will occur.
					// not too critical.
					if ( dwFirstTick != 0 )
					{
						if ( ( GetTickCount() - dwFirstTick ) > dwTimeout )
						{
							return FALSE;	// Timed Out
						}
					}
					else
					{
						dwFirstTick = GetTickCount();
					}

					// We've been spinning long enough --- yield
					// =========================================
					Sleep(0);
					nSpin = 0;
				}

			}	// IF !fAcquiredLock

        }	// WHILE !fAcquiredLock

		// We got the lock so increment the lock count.  Again, we are not
		// using InterlockedInc/Dec since this should all only occur on a
		// single thread.

		++m_lLockCount;
        m_dwThreadId = dwCurrentThreadId;

        return TRUE;

	}

	BOOL Unlock( void )
	{

		// SINCE we assume this is happening on a single thread, we can do this
		// without calling InterlockedInc/Dec.  When the value hits zero, at that
		// time we are done with the lock and can zero out the thread id and
		// decrement the actual lock test value.

		if ( --m_lLockCount == 0 )
		{
			m_dwThreadId = 0;
			InterlockedDecrement( &m_lLock );
		}

		return TRUE;
	}

private:

	long	m_lLock;
	long	m_lLockCount;
	DWORD	m_dwThreadId;
};


// Helper class to control access to a HiPerfLock object using scoping to maintain
// the Lock/Unlock access.

class CHiPerfLockAccess
{
public:

	CHiPerfLockAccess( CHiPerfLock* pLock = NULL, DWORD dwTimeout = HIPERF_DEFAULT_TIMEOUT )
		:	m_pLock( pLock ), m_bIsLocked( FALSE )
	{
		if ( NULL != m_pLock )
		{
			m_bIsLocked = m_pLock->Lock( dwTimeout );
		}
	}

	~CHiPerfLockAccess()
	{
		if ( IsLocked() )
		{
			m_pLock->Unlock();
		}
	}

	BOOL IsLocked( void )
	{
		return m_bIsLocked;
	}

private:

	CHiPerfLock*	m_pLock;
	BOOL			m_bIsLocked;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\hiperfenum.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    HIPERFENUM.CPP

Abstract:

    Hi-Perf Enumerators

History:

--*/

#include "precomp.h"
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "hiperfenum.h"

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::CHiPerfEnum
//
//  Purpose:
//      Class Constructor
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      None.
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CHiPerfEnum::CHiPerfEnum()
:   m_aIdToObject(),
    m_aReusable(),
    m_pInstTemplate(NULL),
    m_lRefCount(0),
    m_Lock()
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::~CHiPerfEnum
//
//  Purpose:
//      Class Destructor
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      None.
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CHiPerfEnum::~CHiPerfEnum()
{
    ClearArray();

    // Cleanup the instance
    if ( NULL != m_pInstTemplate )
    {
        m_pInstTemplate->Release();
    }
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::QueryInterface
//
//  Purpose:
//      Standard IUnknown Method
//
//  Inputs:
//      REFIID          riid    -   Interface Id
//
//  Outputs:
//      LPVOID FAR*     ppvObj  -   Returned interface pointer
//
//  Returns:
//      S_OK if successful.
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

SCODE CHiPerfEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemHiPerfEnum == riid)
    {
        *ppvObj = (IWbemHiPerfEnum*)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::AddRef
//
//  Purpose:
//      Increments Ref Count
//
//  Inputs:
//      None.
//
//  Outputs:
//      None
//
//  Returns:
//      New Ref Count
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

ULONG CHiPerfEnum::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::Relese
//
//  Purpose:
//      Decrements Ref Count
//
//  Inputs:
//      None.
//
//  Outputs:
//      None
//
//  Returns:
//      New Ref Count
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

ULONG CHiPerfEnum::Release()
{
//    _ASSERT(m_lRefCount > 0, "Release() called with no matching AddRef()");
    long lRef = InterlockedDecrement(&m_lRefCount);
        
    if (0 != lRef)
        return lRef;

    delete this;
    return 0;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::AddObjects
//
//  Purpose:
//      Adds new objects to the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//      IWbemObjectAccess** apObj   -   Array of object pointers
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Duplicate Ids is an error
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfEnum::AddObjects( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get through the lock first
    if ( m_Lock.Lock() )
    {

        // Enum supplied data, allocating data objects and inserting them in order
        // into the array.

        for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < uNumObjects; dwCtr++ )
        {
            CHiPerfEnumData*    pData = GetEnumDataPtr( apIds[dwCtr], apObj[dwCtr] );
            
            if ( NULL != pData )
            {
                // Insert the new element.  Cleanup the object
                // if this fails.

                hr = InsertElement( pData );

                if ( FAILED( hr ) )
                {
                    delete pData;
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        m_Lock.Unlock();

    }   // IF m_Lock.Lock()
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::Remove
//
//  Purpose:
//      Removes specified objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Invalid Ids is not an error
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfEnum::RemoveObjects( long lFlags, ULONG uNumObjects, long* apIds )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Enum supplied ids and remove them from the array.

    // Get through the lock first
    if ( m_Lock.Lock() )
    {
        for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < uNumObjects; dwCtr++ )
        {
            hr = RemoveElement( apIds[dwCtr] );
        }

        m_Lock.Unlock();
    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::GetObjects
//
//  Purpose:
//      Retrieves objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects to get
//      IWbemObjectAccess** apObj   -   Array for pointer storage
//
//  Outputs:
//      ULONG*          puNumReturned - Number of objects returned
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      If not enough space, returns an error, with required
//      array size in puNumReturned.
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfEnum::GetObjects( long lFlags, ULONG uNumObjects, IWbemObjectAccess** apObj, ULONG* puNumReturned )
{

    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get through the lock first
    if ( m_Lock.Lock() )
    {
        // Store how many objects we have
        *puNumReturned = m_aIdToObject.Size();

        // Make sure we have storage for our elements
        if ( uNumObjects >= m_aIdToObject.Size() )
        {
            DWORD   dwCtr = 0;

            // Write the objects out to the array
            for ( dwCtr = 0; dwCtr < m_aIdToObject.Size(); dwCtr++ )
            {
                apObj[dwCtr] = ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->GetObject();
            }

        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

        m_Lock.Unlock();
    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }


    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::RemoveAll
//
//  Purpose:
//      Removes all objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Empty list is not an error
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfEnum::RemoveAll( long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Enum supplied ids and remove them from the array.

    // Get through the lock first
    if ( m_Lock.Lock() )
    {
        // Clear each pointer in the array and move it to the
        // reusable array
        for ( DWORD dwCtr = 0; dwCtr < m_aIdToObject.Size(); dwCtr++ )
        {
            // Delete non-NULL elements
            if ( NULL != m_aIdToObject[dwCtr] )
            {
                ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->Clear();
                m_aReusable.Add( m_aIdToObject[dwCtr] );
            }
        }

        m_aIdToObject.Empty();

        m_Lock.Unlock();
    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::InsertElement
//
//  Purpose:
//      Searches for proper location in array and inserts new
//      element into the array.
//
//  Inputs:
//      CHiPerfEnumData*    pData - Pointer to Obj/Id data
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Performs a binary search
//      
/////////////////////////////////////////////////////////////////

HRESULT CHiPerfEnum::InsertElement( CHiPerfEnumData* pData )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD   dwLowIndex = 0,
            dwHighIndex = m_aIdToObject.Size();

    // If the id of the object we are hunting for is > the id 
    // of the last id in the array, we can insert at the end

    // Only set pLastData if the high index is greater than 0.  If it is not, then we will
    // automatically pass the following test ( 0 == dwHighIndex ).

    CHiPerfEnumData*    pLastData = ( dwHighIndex > 0 ? (CHiPerfEnumData*) m_aIdToObject[dwHighIndex - 1] : NULL );

    if ( 0 == dwHighIndex || pLastData->GetId() > pData->GetId() )
    {
        // Binary search of the ids to find an index at which to insert
        // If we find our element, this is a failure.

        while ( SUCCEEDED( hr ) && dwLowIndex < dwHighIndex )
        {
            DWORD   dwMid = (dwLowIndex + dwHighIndex) / 2;

            if ( ((CHiPerfEnumData*) m_aIdToObject[dwMid])->GetId() < pData->GetId() )
            {
                dwLowIndex = dwMid + 1;
            }
            else if ( ((CHiPerfEnumData*) m_aIdToObject[dwMid])->GetId() > pData->GetId() )
            {
                dwHighIndex = dwMid;
            }
            else
            {
                // Index already exists
                hr = WBEM_E_FAILED;
            }
        }   // WHILE looking for index
    }
    else if ( 0 != dwHighIndex && pLastData->GetId() == pData->GetId() )
    {
        hr = WBEM_E_FAILED;
    }
    else
    {
        dwLowIndex = dwHighIndex;
    }

    // Stick it in
    if ( SUCCEEDED( hr ) )
    {
        if ( m_aIdToObject.InsertAt( dwLowIndex, pData ) != CFlexArray::no_error )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::RemoveElement
//
//  Purpose:
//      Searches for specified id in array and removes the element.
//
//  Inputs:
//      long            lId - Id of element to remove
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Performs a binary search
//      
/////////////////////////////////////////////////////////////////

HRESULT CHiPerfEnum::RemoveElement( long lId )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD   dwLowIndex = 0,
            dwHighIndex = m_aIdToObject.Size() - 1;

    // Don't continue if no elements
    if ( m_aIdToObject.Size() > 0 )
    {
        // Binary search of the ids to find the index at which the
        // object should exist.

        while ( SUCCEEDED( hr ) && dwLowIndex < dwHighIndex )
        {
            DWORD   dwMid = (dwLowIndex + dwHighIndex) / 2;

            if ( ((CHiPerfEnumData*) m_aIdToObject[dwMid])->GetId() < lId )
            {
                dwLowIndex = dwMid + 1;
            }
            else
            {
                dwHighIndex = dwMid;
            }
        }   // WHILE looking for index

        // If it doesn't exist, it doesn't get removed.  Not a failure condition
        if ( SUCCEEDED( hr ) )
        {
            if ( ((CHiPerfEnumData*) m_aIdToObject[dwLowIndex])->GetId() == lId )
            {
                // Clear and move to the reusable array
                ((CHiPerfEnumData*) m_aIdToObject[dwLowIndex])->Clear();

                if ( m_aReusable.Add( m_aIdToObject[dwLowIndex] ) != CFlexArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    m_aIdToObject.RemoveAt( dwLowIndex );
                }

            }
        }

    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::ClearArray
//
//  Purpose:
//      Empties out our array
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      None
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

void CHiPerfEnum::ClearArray( void )
{

    // Clear out the all the elements
    m_aIdToObject.Clear();
    m_aReusable.Clear();

    // Now empty the arrays
    m_aIdToObject.Empty();
    m_aReusable.Empty();

}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::GetEnumDataPtr
//
//  Purpose:
//      Retrieves an HPEnumData pointer from the reusable array
//      or allocates one as necessary.
//
//  Inputs:
//      long                lId - ID of the object
//      IWbemObjectAccess*  pObj - Object to put in data.
//
//  Outputs:
//      None.
//
//  Returns:
//      CHiPerfEnumData*    pData - NULL if error
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CHiPerfEnumData* CHiPerfEnum::GetEnumDataPtr( long lId, IWbemObjectAccess* pObj )
{

    CHiPerfEnumData*    pData = NULL;

    if ( 0 != m_aReusable.Size() )
    {
        pData = (CHiPerfEnumData*) m_aReusable[ m_aReusable.Size() - 1 ];
        m_aReusable.RemoveAt( m_aReusable.Size() - 1 );
        pData->SetData( lId, pObj );
    }
    else
    {
        pData = new CHiPerfEnumData( lId, pObj );
    }

    return pData;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::SetInstanceTemplate
//
//  Purpose:
//      Saves the instance template we'll use for cloning.
//
//  Inputs:
//      CWbemInstanc*   pInst = NULL.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      We will change to a shared class part to conserve
//      memory usage.
//      
/////////////////////////////////////////////////////////////////

HRESULT CHiPerfEnum::SetInstanceTemplate( CWbemInstance* pInst )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We convert to a merged instance first to help conserve memory if we use it.
    if ( NULL != pInst )
    {
        hr = pInst->ConvertToMergedInstance();

        if ( SUCCEEDED( hr ) )
        {
            pInst->AddRef();
        }
    }

    // Now, if everything's okay, reset the template
    if ( SUCCEEDED(hr) )
    {
        if ( NULL != m_pInstTemplate )
        {
            m_pInstTemplate->Release();
        }

        m_pInstTemplate = pInst;
    }

    return hr;
}

// Because we insert and remove elements from the end of the array, the elements
// at the beginning represent the least-recently-used (lru) elements.  Our algorithm
// for cleanup is as follows:

// Cleanup the expired elements (this will be the elements at the front of the array)
// Get the number of elements remaining 
// The number of pending elements becomes the number of expired elements
// subtract the number of pending elements from the number of elements remaining
// the difference is now the number of pending elements.

BOOL CGarbageCollectArray::GarbageCollect( int nNumToGarbageCollect /*= HPENUMARRAY_GC_DEFAULT*/ )
{
    // Make sure our params are okay

    if ( m_fClearFromFront )
    {
        if ( nNumToGarbageCollect != HPENUMARRAY_GC_DEFAULT )
        {
            _ASSERT(0,"Must be default for garbage collection!" );
            return FALSE;
        }

        nNumToGarbageCollect = m_nSize;
    }
    else if ( nNumToGarbageCollect < 0 )
    {
        _ASSERT(0,"Negative number of elements to garbage collect!" );
        return FALSE;
    }

    // This will tell us how many elements were in the array last time
    // we went through this
    int nLastTotal = m_nNumElementsExpired + m_nNumElementsPending;

    // If we had more elements last time than the number free this time,
    // we clear out expired elements, and if any pending elements are
    // left, we move them to expired
    if ( nLastTotal > nNumToGarbageCollect )
    {
        // Get rid of expired elements
        if ( m_nNumElementsExpired > 0 )
        {
            int nNumExpired = min( m_nNumElementsExpired, nNumToGarbageCollect );

            m_nNumElementsExpired = nNumExpired;
            ClearExpiredElements();
            nNumToGarbageCollect -= nNumExpired;
        }

        // The new number of expired elements is the minimum of the number
        // to garbage collect anf the number of remaining elements to
        // garbage collect.
        m_nNumElementsExpired = min( m_nNumElementsPending, nNumToGarbageCollect );

        // Since there were less elements this time than before, we will
        // assume that everything has been accounted for.
        m_nNumElementsPending = 0;
    }
    else
    {
        // Get rid of expired elements 
        ClearExpiredElements();

        // Use the current garbage collection size
        int nNumElToUpdate = nNumToGarbageCollect;

        // If we already have pending elements, these are now expired.
        if ( m_nNumElementsPending > 0 )
        {
            m_nNumElementsExpired = m_nNumElementsPending;
            nNumElToUpdate -= m_nNumElementsPending;
        }

        // The number of elements remaining after we accounted
        // for expired elements is now the number of pending
        // elements.

        m_nNumElementsPending = nNumElToUpdate;
    }

    return TRUE;
}

void CGarbageCollectArray::Clear( int nNumToClear /*= HPENUMARRAY_ALL_ELEMENTS*/ )
{
    nNumToClear = ( nNumToClear == HPENUMARRAY_ALL_ELEMENTS ?
                        m_nSize : nNumToClear );

    // Perform the proper per Element cleanup
    ClearElements( nNumToClear );

    // If we cleared all the elements, set the size to 0
    // otherwise, we'll need to do a fancy memory move
    if ( nNumToClear == m_nSize )
    {
        m_nSize = 0;
    }
    else
    {
        // If we garbage collect from the front, we need to move the memory block, otherwise,
        // we just drop the size.

        if ( m_fClearFromFront )
        {
            // Just shift everything over by nNumToClear elements
            MoveMemory( &m_pArray[0], &m_pArray[nNumToClear], ( ( m_nSize - nNumToClear ) * sizeof(void *) ) );
        }
        m_nSize -= nNumToClear;
    }
}

// Walks the array and cleans up the specified number of elements
void CHPEnumDataArray::ClearElements( int nNumToClear )
{

    for ( int nCtr = 0; nCtr < nNumToClear; nCtr++ )
    {
        CHiPerfEnumData*    pData = (CHiPerfEnumData*) GetAt(nCtr);

        _ASSERT( NULL != pData, "Tried to clear a NULL Element!" );
        if ( NULL != pData )
        {
            delete pData;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    MTGTMRSH.CPP

Abstract:

    Multi Target Marshaling.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "mtgtmrsh.h"
#include <fastall.h>
#include <cominit.h>

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CMultiTargetFactoryBuffer::XEnumFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetFactoryBuffer::XEnumFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemMultiTarget)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CMultiTargetProxyBuffer* pProxy = new CMultiTargetProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CMultiTargetFactoryBuffer::XEnumFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemMultiTarget 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CMultiTargetFactoryBuffer::XEnumFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemMultiTarget)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CMultiTargetStubBuffer* pStub = new CMultiTargetStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CMultiTargetFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XEnumFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CMultiTargetProxyBuffer::CMultiTargetProxyBuffer
//  ~CMultiTargetProxyBuffer::CMultiTargetProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CMultiTargetProxyBuffer::CMultiTargetProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
        m_XMultiTargetFacelet(this), m_pChannel(NULL), m_pOldProxy( NULL ), m_pOldProxyMultiTarget( NULL ),
        m_fTriedSmartEnum( FALSE ), m_fUseSmartMultiTarget( FALSE ), m_hSmartNextMutex( INVALID_HANDLE_VALUE ),
        m_pSmartMultiTarget( NULL ), m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
    InitializeCriticalSection( &m_cs );
//    m_StubType = UNKNOWN;

}

CMultiTargetProxyBuffer::~CMultiTargetProxyBuffer()
{
    if ( NULL != m_pSmartMultiTarget )
    {
        m_pSmartMultiTarget->Release();
    }

    // This MUST be released before releasing
    // the Proxy pointer
    if ( NULL != m_pOldProxyMultiTarget )
    {
        m_pOldProxyMultiTarget->Release();
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();

    // Cleanup the mutex
    if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
    {
        CloseHandle( m_hSmartNextMutex );
    }

    m_pControl->ObjectDestroyed(this);

    DeleteCriticalSection( &m_cs );

}

ULONG STDMETHODCALLTYPE CMultiTargetProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CMultiTargetProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemMultiTarget)
    {
        *ppv = (IWbemMultiTarget*)&m_XMultiTargetFacelet;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return our security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
    // may have to go remote

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );

    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

        // Make sure we have a smart enumerator and that we are going to
        // be using it.  If so, make sure the values applied to us are also
        // applied to it's proxy

        if ( SUCCEEDED( m_pObject->InitSmartMultiTarget( TRUE, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities ) ) && m_pObject->m_fUseSmartMultiTarget )
        {
            // Now repeat the above operation for the smart enumerator
            // Ignore the IUnknown if we are not remoting
            hr = WbemSetProxyBlanket(  m_pObject->m_pSmartMultiTarget, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_pObject->m_fRemote );

        }   // If initialized smart enumerator

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//////////////////////////////////////////////
//////////////////////////////////////////////

//  IWbemMultiTarget Methods -- Pass Thrus for now

//////////////////////////////////////////////
//////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
DeliverEvent(DWORD dwNumEvents, IWbemClassObject** apEvents, WBEM_REM_TARGETS* aTargets,
           long lSDLength, BYTE* pSD)
{
    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartMultiTarget();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartMultiTarget && NULL != m_pObject->m_pSmartMultiTarget )
    {

        // Function MUST be thread safe
        CInCritSec ics(&m_pObject->m_cs);

        // Calculate data length first 
        DWORD dwLength;

        try
        {
            // Allocate arrays for the guid and the flags
            GUID*	pGUIDs = new GUID[dwNumEvents];
            BOOL*	pfSendFullObject = new BOOL[dwNumEvents];

			CVectorDeleteMe<GUID> vdmGUID( pGUIDs );
			CVectorDeleteMe<BOOL> vdmBOOL( pfSendFullObject );

			// Check allocations
			if ( NULL != pGUIDs && NULL != pfSendFullObject )
			{
				CWbemMtgtDeliverEventPacket packet;
				hr = packet.CalculateLength(dwNumEvents, apEvents, &dwLength, 
						m_ClassToIdMap, pGUIDs, pfSendFullObject );

				if ( SUCCEEDED( hr ) )
				{

					// As we could be going cross process/machine, use the
					// COM memory allocator
					LPBYTE pbData = (LPBYTE) CoTaskMemAlloc( dwLength );

					if ( NULL != pbData )
					{

						// Write the objects out to the buffer
						hr = packet.MarshalPacket( pbData, dwLength, dwNumEvents, 
													apEvents, pGUIDs, pfSendFullObject);

						// Copy the values, we're golden.
						if ( SUCCEEDED( hr ) )
						{
							// Now we can send the data to the stub
							hr = m_pObject->m_pSmartMultiTarget->DeliverEvent( dwNumEvents, dwLength, pbData, aTargets, lSDLength, pSD );
						}

						// Because the buffer is an [in] parameter, it lies on our heads
						// to free it up.
						CoTaskMemFree( pbData );
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

	            }   // IF CalculateLength()

			}	// IF allocated arrays
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
        }
        catch (CX_MemoryException)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        catch(...)
        {
            hr = WBEM_E_FAILED;
        }

    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyMultiTarget->DeliverEvent(dwNumEvents, apEvents, aTargets, lSDLength, pSD );
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
DeliverStatus( long lFlags, HRESULT hresStatus, LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
            WBEM_REM_TARGETS* pTargets, long lSDLength, BYTE* pSD)
{
    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyMultiTarget->DeliverStatus( lFlags, hresStatus, wszStatus, pErrorObj, pTargets, lSDLength, pSD );
}

/*
HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
      Next(long lTimeout, ULONG uCount, IWbemClassObject** apObj, ULONG FAR* puReturned)
{

    // At this point we will Query for the new, improved IEnumWCOSmartNext interface.
    // If we get it, we will maintain a pointer to that interface and
    // pass through to that interface.  We will also call CoCreateGuid() so
    // we get a unique identifier on the other end for sending wbem objects
    // back and forth cleanly.

    // The interface will have a single method IEnumWCOSmartNext::Next
    // This will take a GUID identifying this proxy, lTimeout, uCount,
    // puReturned, then dwBuffSize and BYTE**.

    // The other end will allocate memory via CoTaskMemAlloc and this side will
    // Free it via CoTaskMemFree.

    // The other side will Marshal returned objects into the memory block.
    // This side will Unmarshal it (and then free the block).

    //
    //  SAMPLE IDL:
    //  IEnumWCOSmartNext::Next(    [in] GUID proxyGUID,
    //                              [in] LONG lTimeout,
    //                              [in] unsigned long uCount,
    //                              [in, out] DWORD* puReturned,
    //                              [in, out] DWORD* pdwBuffSize,
    //                              [in, out, size_is[,*pdwBuffSize] BYTE** pBuffer
    //

    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure the timeout value makes sense
    if ( lTimeout < 0 && lTimeout != WBEM_INFINITE )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartMultiTarget();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartMultiTarget && NULL != m_pObject->m_pSmartMultiTarget )
    {
        DWORD   dwOldTick = GetTickCount();
        DWORD   dwReturn = WaitForSingleObject( m_pObject->m_hSmartNextMutex, lTimeout );

        if (  WAIT_OBJECT_0 == dwReturn )
        {
            BYTE*   pBuffer = NULL;
            ULONG   uSizeOfBuffer = 0;

            // Adjust timeout (if it was > 0) for any milliseconds we may
            // have just been waiting.

            if ( lTimeout > 0 )
            {
                // Get the current tick count.  Be aware that a tick count will
                // rollover every 30 some odd days, so trap for this case by
                // checking that the new tick count >= the old one
                
                DWORD   dwCurrTick = GetTickCount();
                dwCurrTick = ( dwCurrTick >= dwOldTick ? dwCurrTick : dwOldTick );

                // Adjust the timeout, but don't let it fall below 0
                lTimeout -= ( dwCurrTick - dwOldTick );
                lTimeout = ( lTimeout < 0 ? 0 : lTimeout );
            }

            // Ask the server for objects
            hr = m_pObject->m_pSmartMultiTarget->Next( m_pObject->m_guidSmartEnum, lTimeout, uCount, puReturned, &uSizeOfBuffer, &pBuffer );

            // Only need to unmarshal if objects are in the buffer
            if ( SUCCEEDED( hr ) && *puReturned > 0 )
            {

                CWbemSmartEnumNextPacket packet( (LPBYTE) pBuffer, uSizeOfBuffer );
                long lObjectCount; 
                IWbemClassObject ** pObjArray;
                hr = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

                if ( SUCCEEDED( hr ) )
                {
                    // Copy *puReturned pointers from the allocated pObjArray into apObj.
                    CopyMemory( apObj, pObjArray, ( *puReturned * sizeof(IWbemClassObject*) ) );

                    // Clean up pObjArray  It is the caller's responsibility to free
                    // the IWbemClassObject* pointers.
                    delete [] pObjArray;

                }   // IF UnmarshalPacket

                // Free the memory buffer (allocated by WinMgmt via CoTaskMemAlloc)
                CoTaskMemFree( pBuffer );

            }   // IF Next

            ReleaseMutex( m_pObject->m_hSmartNextMutex );

        }   // IF WAIT_OBJECT_0
        else if ( WAIT_TIMEOUT == dwReturn )
        {
            // Timed out on the mutex
            hr = WBEM_S_TIMEDOUT;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyMultiTarget->Next( lTimeout, uCount, apObj, puReturned );
    }

    return hr;

}
*/

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    // get a pointer to the old sink which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // Establish the marshaling context
    DWORD   dwCtxt = 0;
    pChannel->GetDestCtx( &dwCtxt, NULL );

    m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

	if ( SUCCEEDED( hr ) )
	{
		// We aggregated it --- WE OWN IT!
    
		hr = pIPS->CreateProxy( this, IID_IWbemMultiTarget, &m_pOldProxy, (void**) &m_pOldProxyMultiTarget );
		pIPS->Release();

		if ( SUCCEEDED( hr ) )
		{
			// Connect the old proxy to the channel
			hr = m_pOldProxy->Connect( pChannel );

			if ( SUCCEEDED( hr ) )
			{
				// Save an internal reference to the channel
				if(m_pChannel)
					return E_UNEXPECTED;
    
				m_pChannel = pChannel;
				if(m_pChannel)
					m_pChannel->AddRef();

			}	// IF Connect

		}	// IF CreateProxy

	}	// IF CoGetClassObject

    return hr;
}

//***************************************************************************
//
//  HRESULT CMultiTargetProxyBuffer::InitSmartMultiTarget(void)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  This function sets up
//  the smart enumerator pointer so we can perform intelligent marshaling.
//  This cannot be called during a Connect operation.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CMultiTargetProxyBuffer::InitSmartMultiTarget( BOOL fSetBlanket, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Function MUST be thread safe
    CInCritSec ics(&m_cs);

    // If we haven't tried to estalish smart enumeration, do so now

    // If we haven't tried to get a smart enumerator, try to get one.  If
    // we are able to get one, initialize member data we will use in all
    // operations from this proxy.

    if ( NULL == m_pSmartMultiTarget )
    {

        // We'll only get this interface pointer if the server is a new
        // version that understands this interface.  If it does, the pointer
        // will be marshaled through for us.  To get to this pointer,
        // we go directly through our punkOuter.  From the "fetcher" interface
        // we will then get the actual smart enumerator.  We can then free up
        // the fetcher and release it's lock on the proxy manager.  The
        // smart enumerator will be handled on its own.

        IWbemFetchSmartMultiTarget* pFetchSmartMultiTarget;

        hr = m_pUnkOuter->QueryInterface( IID_IWbemFetchSmartMultiTarget, (void**) &pFetchSmartMultiTarget );

        // Generate a GUID to identify us when we call the smart enumerator
        if ( SUCCEEDED( hr ) )
        {

            // If we need to, set the blanket on the proxy, otherwise, the call to GetSmartEnum
            // may fail.
            if ( fSetBlanket )
            {
                // Ignore the IUnknown if we are not remoting
                hr = WbemSetProxyBlanket( pFetchSmartMultiTarget, AuthnSvc, AuthzSvc, pServerPrincName,
                            AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_fRemote );
            }

            if ( SUCCEEDED( hr ) )
            {

                hr = pFetchSmartMultiTarget->GetSmartMultiTarget( &m_pSmartMultiTarget );

                if ( SUCCEEDED( hr ) )
                {
                    // We need a GUID
                    hr = CoCreateGuid( &m_guidSmartEnum );

                    if ( SUCCEEDED( hr ) )
                    {
                        // We'll also need a Mutex (so we can timeout) here

                        m_hSmartNextMutex = CreateMutex( NULL, FALSE, NULL );

                        if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
                        {
                            // We have everything we need to do things smartly
                            m_fUseSmartMultiTarget = TRUE;
                        }
                    }   // IF CoCreateGuid

                }   // IF got Smart MultiTarget

            }   // IF security OK
            
            // Done with the fetcher interface
            pFetchSmartMultiTarget->Release();

        }   // IF QueryInterface
        else
        {
            hr = WBEM_S_NO_ERROR;
        }

    }   // IF NULL == m_pSmartMultiTarget

    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CMultiTargetProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old Proxy Enum MUST be released first.

    if ( NULL != m_pOldProxyMultiTarget )
    {
        m_pOldProxyMultiTarget->Release();
        m_pOldProxyMultiTarget = NULL;
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CMultiTargetFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CMultiTargetStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XMultiTargetStublet;
    else
        return NULL;
}

CMultiTargetStubBuffer::XMultiTargetStublet::XMultiTargetStublet(CMultiTargetStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CMultiTargetStubBuffer>(pObj), m_pServer(NULL), m_lConnections( 0 )
{
}

CMultiTargetStubBuffer::XMultiTargetStublet::~XMultiTargetStublet() 
{
    if(m_pServer)
        m_pServer->Release();

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject sink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemMultiTarget, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // get a pointer to the old stub which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );
    if (FAILED(hr))
    	return hr;

    hr = pIPS->CreateStub( IID_IWbemMultiTarget, m_pServer, &m_pObject->m_pOldStub );
    pIPS->Release();
    if (FAILED(hr))
    	return hr;    

    // Successful connection

    m_lConnections++;
    return S_OK;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemMultiTarget
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    if(m_pServer)
    {
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Successful disconnect
    m_lConnections--;

}


//***************************************************************************
//
//  STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer
    return m_pObject->m_pOldStub->Invoke( pMessage, pChannel );
}

IRpcStubBuffer* STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemMultiTarget)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    MTGTMRSH.H

Abstract:

    Multi Target Marshaling.

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include "wbemclasscache.h"
#include "wbemclasstoidmap.h"
#include "mtgtpckt.h"

//***************************************************************************
//
//  class CMultiTargetFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CMultiTargetFactoryBuffer : public CUnkInternal
{

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XEnumFactory : public CImpl<IPSFactoryBuffer, CMultiTargetFactoryBuffer>
    {
    public:
        XEnumFactory(CMultiTargetFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CMultiTargetFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XEnumFactory;
public:
    CMultiTargetFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_XEnumFactory(this), m_pLifeControl( pControl )
    {
    }
    ~CMultiTargetFactoryBuffer()
    {
    }
    

    void* GetInterface(REFIID riid);

	friend XEnumFactory;
};

//***************************************************************************
//
//  class CMultiTargetProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CMultiTargetProxyBuffer : public IRpcProxyBuffer
{
private:
	IRpcProxyBuffer*		m_pOldProxy;
	IWbemMultiTarget*		m_pOldProxyMultiTarget;
    BOOL					m_fTriedSmartEnum;
    BOOL					m_fUseSmartMultiTarget;
	HANDLE					m_hSmartNextMutex;
	GUID					m_guidSmartEnum;
	IWbemSmartMultiTarget*	m_pSmartMultiTarget;
	CRITICAL_SECTION		m_cs;
	bool				m_fRemote;

protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XMultiTargetFacelet : public IWbemMultiTarget, IClientSecurity
    {
    protected:
        CMultiTargetProxyBuffer*	m_pObject;
	    CWbemClassToIdMap			m_ClassToIdMap;

    public:
        XMultiTargetFacelet(CMultiTargetProxyBuffer* pObject) : m_pObject(pObject){};
        ~XMultiTargetFacelet(){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

		// IWbemMultiTarget Methods
		STDMETHOD(DeliverEvent)(
            /*[in]*/ DWORD dwNumEvents,
			/*[in]*/ IWbemClassObject** apEvents,
			/*[in]*/ WBEM_REM_TARGETS* aTargets,
            /*[in]*/ long lSDLength,
            /*[in, size_is(lSDLength)]*/ BYTE* pSD);

		STDMETHOD(DeliverStatus)(
			/*[in]*/ long lFlags,
			/*[in]*/ HRESULT hresStatus,
			/*[in, string]*/ LPCWSTR wszStatus,
			/*[in]*/ IWbemClassObject* pErrorObj,
			/*[in]*/ WBEM_REM_TARGETS* pTargets,
            /*[in]*/ long lSDLength,
            /*[in, size_is(lSDLength)]*/ BYTE* pSD);

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XMultiTargetFacelet;
    friend XMultiTargetFacelet;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

	// Initialize the smart enumerator
	HRESULT InitSmartMultiTarget( BOOL fSetBlanket = FALSE, DWORD AuthnSvc = RPC_C_AUTHN_WINNT,
			DWORD AuthzSvc = RPC_C_AUTHZ_NONE, OLECHAR* pServerPrincName = NULL,
			DWORD AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT, DWORD ImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE,
			void* pAuthInfo = NULL, DWORD Capabilities = EOAC_NONE );

public:
    CMultiTargetProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CMultiTargetProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CMultiTargetStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CMultiTargetStubBuffer : public CUnk
{
private:

	IRpcStubBuffer*	m_pOldStub;

protected:
    class XMultiTargetStublet : public CImpl<IRpcStubBuffer, CMultiTargetStubBuffer>
    {
        IWbemObjectSink* m_pServer;
		LONG			m_lConnections;

    public:
        XMultiTargetStublet(CMultiTargetStubBuffer* pObj);
        ~XMultiTargetStublet();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
	private:

        friend CMultiTargetStubBuffer;
    } m_XMultiTargetStublet;
    friend XMultiTargetStublet;

public:
    CMultiTargetStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XMultiTargetStublet(this), m_pOldStub( NULL )
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtpckt.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MTGTPCKT.H

Abstract:

   MultiTarget Packet class

History:

--*/
#ifndef __MULTITARGETPACKET_H__
#define __MULTITARGETPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemMultiTarget::DeliverEvent() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT;

typedef WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT* PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemMtgtDeliverEventPacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemMultiTarget::DeliverEvent() operation.  The data structure of this
//	packet is described above.  It makes use of CWbemObjectPacket,
//	CWbemInstancePacket, CWbemClassPacket and CWbemClasslessInstancePacket
//	to walk and analyze data for each of the IWbemClassObjects that
//	are indicated into the Sink.
//

class COREPROX_POLARITY CWbemMtgtDeliverEventPacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT	m_pObjSinkIndicate;

public:

	CWbemMtgtDeliverEventPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemMtgtDeliverEventPacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemMtgtDeliverEventPacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mrshbase.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MRSHBASE.H

Abstract:

    Marshaling base classes.

History:

--*/

#ifndef __MRSHBASE_H__
#define __MRSHBASE_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <objindpacket.h>

//***************************************************************************
//
//  class CBaseProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides a base class implementation for an IRpcProxyBuffer.  As
//	the code necessary for performing this operation isn't necessarily so
//	obvious, but we use it in several places, this encapsulation is intended
//	to try and keep all of this maintainable.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CBaseProxyBuffer : public IRpcProxyBuffer
{
protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
	IRpcProxyBuffer*	m_pOldProxy;
    long m_lRef;
	REFIID m_riid;
	bool		m_fRemote;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

	virtual void*	GetInterface( REFIID riid ) = 0;
	virtual void**	GetOldProxyInterfacePtr( void ) = 0;
	virtual void	ReleaseOldProxyInterface( void ) = 0;

public:
    CBaseProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter, REFIID riid);
    virtual ~CBaseProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CBaseStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

// Forward the definition
class CBaseStublet;

class CBaseStubBuffer : public CUnk
{
    friend CBaseStublet;

protected:

	IRpcStubBuffer*	m_pOldStub;

protected:

public:
    CBaseStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_pOldStub( NULL )
    {}

};

class CBaseStublet : public CImpl<IRpcStubBuffer, CBaseStubBuffer>
{
protected:
	REFIID	m_riid;
	long	m_lConnections;

protected:

	virtual IUnknown*	GetServerInterface( void ) = 0;
	virtual void**	GetServerPtr( void ) = 0;
	virtual void	ReleaseServerPointer( void ) = 0;

	IRpcStubBuffer*	GetOldStub( void )
	{	return m_pObject->m_pOldStub; }

public:
    CBaseStublet(CBaseStubBuffer* pObj, REFIID riid);
    ~CBaseStublet();

    STDMETHOD(Connect)(IUnknown* pUnkServer);
    STDMETHOD_(void, Disconnect)();
    STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
    STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
    STDMETHOD_(ULONG, CountRefs)();
    STDMETHOD(DebugServerQueryInterface)(void** ppv);
    STDMETHOD_(void, DebugServerRelease)(void* pv);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objarraypacket.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OBJARRAYPACKET.H

Abstract:

   Object Array Packet class

History:

--*/

#ifndef __OBJARRAYPACKET_H__
#define __OBJARRAYPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemClassObject Array Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECT_ARRAY
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwNumObjects;	// Number of objects in the array
} WBEM_DATAPACKET_OBJECT_ARRAY;

typedef WBEM_DATAPACKET_OBJECT_ARRAY* PWBEM_DATAPACKET_OBJECT_ARRAY;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemObjectArrayPacket
//
//	This class is designed to wrapper an array of IWbemClassObjects.
//	The objects are written out to and read in from a byte array which
//	is supplied to this class by an outside source.
//

class COREPROX_POLARITY CWbemObjectArrayPacket
{
private:
	HRESULT GetClassObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj );
	HRESULT GetInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache );
	HRESULT GetClasslessInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache );

protected:

	PWBEM_DATAPACKET_OBJECT_ARRAY	m_pObjectArrayHeader;
	DWORD							m_dwPacketLength;

public:

	CWbemObjectArrayPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemObjectArrayPacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	virtual void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemObjectArrayPacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objarraypacket.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OBJARRAYPACKET.CPP

Abstract:

   Object Array Packet class

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::CWbemObjectArrayPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjectArrayPacket::CWbemObjectArrayPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   m_pObjectArrayHeader( (PWBEM_DATAPACKET_OBJECT_ARRAY) pDataPacket ),
    m_dwPacketLength( dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::~CWbemObjectArrayPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemObjectArrayPacket::~CWbemObjectArrayPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Initial length is the size of this header
    DWORD   dwLength = sizeof( WBEM_DATAPACKET_OBJECT_ARRAY );

    // We'll need these in the loop
    CWbemObjectPacket   objectPacket;
    DWORD               dwObjectLength = 0;

    // This is so we only allocate buffers as we need them, and not for every
    // call to GetClassId and AssignClassId.
    CMemBuffer          buff;

    for (   LONG lCtr = 0;
            lCtr < lObjectCount
            && SUCCEEDED( hr );
            lCtr++ )
    {
        CWbemObject*    pWbemObject = (CWbemObject*) apClassObjects[lCtr];

        if ( pWbemObject->IsObjectInstance() == WBEM_S_NO_ERROR )
        {
            // Send the object to the map first trying to get an appropriate
            // class id, and if that fails, then to add the object to the map.

            hr = classtoidmap.GetClassId( pWbemObject, &pguidClassIds[lCtr], &buff );

            if ( FAILED( hr ) )
            {
                hr = classtoidmap.AssignClassId( pWbemObject, &pguidClassIds[lCtr], &buff );
                pfSendFullObject[lCtr] = TRUE;
            }
            else
            {
                // Got an id, so this instance is partial
                pfSendFullObject[lCtr] = FALSE;
            }

        }   // IF IsObjectInstance()
        else
        {
            // It's a class
            pfSendFullObject[lCtr] = TRUE;
            hr = WBEM_S_NO_ERROR;
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = objectPacket.CalculatePacketLength( apClassObjects[lCtr], &dwObjectLength, pfSendFullObject[lCtr]  );

            if ( SUCCEEDED( hr ) )
            {
                dwLength += dwObjectLength;
            }
        }   // IF GOT Length

    }
    
    if ( SUCCEEDED( hr ) )
    {
        *pdwLength = dwLength;
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // We must have a buffer to work with

    if ( NULL != m_pObjectArrayHeader )
    {
        // Fill out the array Header
        m_pObjectArrayHeader->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);
        m_pObjectArrayHeader->dwDataSize = m_dwPacketLength - sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);
        m_pObjectArrayHeader->dwNumObjects = lObjectCount;

        // Only makes sense if the object count is greater than 0
        if ( 0 < lObjectCount )
        {
            // Now, setup pbData and dwLength so we can walk through our buffer
            // Account for the header when we do this

            LPBYTE  pbData      =   ((LPBYTE) m_pObjectArrayHeader + m_pObjectArrayHeader->dwSizeOfHeader);
            DWORD   dwLength    =   m_dwPacketLength - m_pObjectArrayHeader->dwSizeOfHeader;

            DWORD                           dwObjectLength = 0;
            CWbemObjectPacket               objectPacket;
            CWbemClassPacket                classPacket;
            CWbemInstancePacket             instancePacket;
            CWbemClasslessInstancePacket    classlessInstancePacket;

            for (   LONG    lCtr = 0;
                    SUCCEEDED( hr ) &&  lCtr < lObjectCount;
                    lCtr++,
                    pbData += dwObjectLength,
                    dwLength -= dwObjectLength )
            {
                CWbemObject* pWbemObject = (CWbemObject*) apClassObjects[lCtr];

                // Send to the appropriate object for streaming
                if ( pWbemObject->IsObjectInstance() == WBEM_S_NO_ERROR )
                {
                    // Either full or classless instance
                    if ( pfSendFullObject[lCtr] )
                    {
                        hr = instancePacket.WriteToPacket( pbData, dwLength, apClassObjects[lCtr], paguidClassIds[lCtr], &dwObjectLength );
                    }
                    else
                    {
                        hr = classlessInstancePacket.WriteToPacket( pbData, dwLength, apClassObjects[lCtr], paguidClassIds[lCtr], &dwObjectLength );
                    }
                }
                else
                {
                    // A class on its own
                    hr = classPacket.WriteToPacket( pbData, dwLength, apClassObjects[lCtr], &dwObjectLength );
                }

            }

        }   // IF lObjectCount

    }   // IF SetupDataPacketHeader
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LPBYTE  pbData = (LPBYTE) m_pObjectArrayHeader;

    // Set the array to NULL.
    apClassObjects = NULL;

    // Make sure we have a pointer
    if ( NULL != m_pObjectArrayHeader )
    {
        // Store how many objects follow
        lObjectCount = m_pObjectArrayHeader->dwNumObjects;

        if ( lObjectCount > 0 )
        {
            apClassObjects = new IWbemClassObject*[lObjectCount];

            if ( NULL != apClassObjects )
            {
                // Count unmarshaled objects so if an error occurs, we release any objects
                // we did marshal.

                LONG    lUnmarshaledObjects = 0;

                // Points us at the first object
                pbData += sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);

                for (   LONG lCtr = 0;
                        SUCCEEDED( hr ) && lCtr < lObjectCount;
                        lCtr++ )
                {
                    CWbemObjectPacket   objectPacket( pbData );

                    switch ( objectPacket.GetObjectType() )
                    {
                        case WBEMOBJECT_CLASS_FULL:
                        {
                            hr = GetClassObject( objectPacket, &apClassObjects[lCtr] );
                        }
                        break;

                        case WBEMOBJECT_INSTANCE_FULL:
                        {
                            hr = GetInstanceObject( objectPacket, &apClassObjects[lCtr], classCache );
                        }
                        break;

                        case WBEMOBJECT_INSTANCE_NOCLASS:
                        {
                            hr = GetClasslessInstanceObject( objectPacket, &apClassObjects[lCtr], classCache );
                        }
                        break;

                        default:
                        {
                            // What is this?
                            hr = WBEM_E_UNKNOWN_OBJECT_TYPE;
                        }
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        // Go to the next object, so account for header size and
                        // the actual packet size

                        pbData += sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
                        pbData += objectPacket.GetDataSize();
                        lUnmarshaledObjects++;
                    }

                }   // FOR enum objects

                // IF we failed unmarshaling, make sure we release any marshaled
                // objects.

                if ( FAILED( hr ) )
                {
                    for ( lCtr = 0; lCtr < lUnmarshaledObjects; lCtr++ )
                    {
                        apClassObjects[lCtr]->Release();
                    }

                    // Clean up the array
                    delete [] apClassObjects;
                    apClassObjects = NULL;

                }   // IF unmarshaling failed

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF lObjectCount

    }   // IF m_pObjectArrayHeader
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::GetClassObject
//  
//  Unmarshals a class object from the supplid buffer.
//
//  Inputs:
//              CWbemObjectPacket&  objectPacket - Object Packet containing data.
//
//  Outputs:
//              IWbemClassObject**  ppObj - Pointer to unmarshaled object.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   Object is AddRefed, so it is up to caller to Release it.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::GetClassObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj )
{
    CWbemClassPacket    classPacket( objectPacket );
    CWbemClass*         pClass = NULL;

    HRESULT hr = classPacket.GetWbemClassObject( &pClass );

    if ( SUCCEEDED( hr ) )
    {
        *ppObj = (IWbemClassObject*) pClass;
    }
    
    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::GetInstanceObject
//  
//  Unmarshals a full instance object from the supplied buffer.
//
//  Inputs:
//              CWbemObjectPacket&  objectPacket - Object Packet containing data.
//
//  Outputs:
//              IWbemClassObject**  ppObj - Pointer to unmarshaled object.
//              CWbemClassCache&    classCache - Store full instances here.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   Object is AddRefed, so it is up to caller to Release it.
//              Full Instances are added to the supplied  cache.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::GetInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache )
{
    CWbemInstancePacket instancePacket( objectPacket );
    CWbemInstance*      pInstance = NULL;
    GUID                guidClassId;

    HRESULT hr = instancePacket.GetWbemInstanceObject( &pInstance, guidClassId );

    if ( SUCCEEDED( hr ) )
    {

        // Now, we need to actually separate out the class part from the
        // instance and place it in its own object so the outside world
        // cannot touch the object.

        DWORD   dwClassObjectLength = 0;

        // Get length should fail with a buffer too small error
        hr = pInstance->GetObjectParts( NULL, 0,
                WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwClassObjectLength );

        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            DWORD   dwTempLength;
            LPBYTE  pbData = CBasicBlobControl::sAllocate(dwClassObjectLength);

            if ( NULL != pbData )
            {

                hr = pInstance->GetObjectParts( pbData, dwClassObjectLength,
                        WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwTempLength );

                if ( SUCCEEDED( hr ) )
                {
                    // Allocate an object to hold the class data and then
                    // stuff in the binary data.

                    CWbemInstance*  pClassData = new CWbemInstance;

                    if ( NULL != pClassData )
                    {
                        pClassData->SetData( pbData, dwClassObjectLength,
                            WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART |
                            WBEM_OBJ_CLASS_PART_INTERNAL );

                        // Add the class data object to the cache
                        hr = classCache.AddObject( guidClassId, pClassData );

                        if ( SUCCEEDED( hr ) )
                        {
                            // Merge the full instance with this object
                            // and we're done

                            hr = pInstance->MergeClassPart( pClassData );

                            if ( SUCCEEDED( hr ) )
                            {
                                *ppObj = (IWbemClassObject*) pInstance;
                            }
                        }

                        // There will be one additional addref on the class data,
                        // object, so release it here.  If the object wasn't
                        // added into the map, this will free it.
                        pClassData->Release();

                    }   // IF pClassData
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }

                }   // IF GetObjectParts

            }   // IF pbData
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }


        }   // IF GetObjectParts

        // Clean up the instance if something went wrong
        if ( FAILED( hr ) )
        {
            pInstance->Release();
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::GetClasslessInstanceObject
//  
//  Unmarshals a classless instance object from the supplied buffer.
//
//  Inputs:
//              CWbemObjectPacket&  objectPacket - Object Packet containing data.
//
//  Outputs:
//              IWbemClassObject**  ppObj - Pointer to unmarshaled object.
//              CWbemClassCache&    classCache - Hook up instances here.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   Object is AddRefed, so it is up to caller to Release it.
//              Classless Instances are wired up using data from the
//              the supplied cache.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::GetClasslessInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache )
{
    CWbemClasslessInstancePacket    classlessinstancePacket( objectPacket );
    CWbemInstance*                  pInstance = NULL;
    GUID                            guidClassId;

    HRESULT hr = classlessinstancePacket.GetWbemInstanceObject( &pInstance, guidClassId );


    if ( SUCCEEDED( hr ) )
    {
        IWbemClassObject*   pObj = NULL;

        // Causes an AddRef
        hr = classCache.GetObject( guidClassId, &pObj );

        if ( SUCCEEDED( hr ) )
        {
            // merge the class part and we're done
            hr = pInstance->MergeClassPart( pObj );

            if ( SUCCEEDED( hr ) )
            {
                *ppObj = (IWbemClassObject*) pInstance;
            }

            // Done with this object
            pObj->Release();
        }

        // Clean up the instance if anything went wrong above
        if ( FAILED( hr ) )
        {
            pInstance->Release();
        }

    }   // IF GotInstance

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemObjectArrayPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // This is our packet (no offset calculations necessary)
    m_pObjectArrayHeader = (PWBEM_DATAPACKET_OBJECT_ARRAY) pDataPacket;
    m_dwPacketLength = dwPacketLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objindpacket.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

   OBJINDPACKET.CPP

Abstract:

   Object Sink Indicate packet.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "objindpacket.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::CWbemObjSinkIndicatePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjSinkIndicatePacket::CWbemObjSinkIndicatePacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pObjSinkIndicate( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_OBJECTSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::~CWbemObjSinkIndicatePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemObjSinkIndicatePacket::~CWbemObjSinkIndicatePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkIndicatePacket::CalculateLength( LONG lObjectCount, 
                                                                                     IWbemClassObject** apClassObjects, 
                                                                                     DWORD* pdwLength, 
                                                                                     CWbemClassToIdMap& classtoidmap, 
                                                                                     GUID* pguidClassIds, 
                                                                                     BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwLength = 0;

    // Now get the size of the objects as described by the object array
    CWbemObjectArrayPacket  arrayPacket;

    hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwLength, classtoidmap, pguidClassIds, pfSendFullObject );

    // Store the length if we're okey-dokey
    if ( SUCCEEDED( hr ) )
    {
        // Account for the header sizes
        *pdwLength = ( dwLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_OBJECTSINK_INDICATE ) );
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkIndicatePacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE, 0 );

    if ( SUCCEEDED( hr ) )
    {
        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pObjSinkIndicate;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the Indicate Header
        m_pObjSinkIndicate->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);
        m_pObjSinkIndicate->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);

        // Now use the array packet class to marshal the objects into the buffer
        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkIndicatePacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pObjSinkIndicate;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and use the object array to unmarshal the
        // objects from the buffer

        // Points us at the first object
        pbData += sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);

        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemObjSinkIndicatePacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_OBJECTSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pObjSinkIndicate = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtpckt.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MTGTPCKT.CPP

Abstract:

   MultiTarget Packet class

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "mtgtpckt.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::CWbemMtgtDeliverEventPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemMtgtDeliverEventPacket::CWbemMtgtDeliverEventPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pObjSinkIndicate( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::~CWbemMtgtDeliverEventPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemMtgtDeliverEventPacket::~CWbemMtgtDeliverEventPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemMtgtDeliverEventPacket::CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwLength = 0;

    // Now get the size of the objects as described by the object array
    CWbemObjectArrayPacket  arrayPacket;

    hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwLength, classtoidmap, pguidClassIds, pfSendFullObject );

    // Store the length if we're okey-dokey
    if ( SUCCEEDED( hr ) )
    {
        // Account for the header sizes
        *pdwLength = ( dwLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT ) );
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemMtgtDeliverEventPacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT, 0 );

    if ( SUCCEEDED( hr ) )
    {
        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pObjSinkIndicate;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the Indicate Header
        m_pObjSinkIndicate->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);
        m_pObjSinkIndicate->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);
        dwLength -= sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);

        // Now use the array packet class to marshal the objects into the buffer
        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemMtgtDeliverEventPacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pObjSinkIndicate;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and use the object array to unmarshal the
        // objects from the buffer

        // Points us at the first object
        pbData += sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);
        dwLength -= sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);

        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemMtgtDeliverEventPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pObjSinkIndicate = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADDRESLV.H

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPROX_POLARITY __declspec( dllexport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ocstrcls.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  OCSTRCLS.CPP

Abstract:

  COctetStringClass Definition.

  Defines a class object from which instances can be spawned
  so we can model an octet string.

History:

  22-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include "arrtempl.h"
#include "ocstrcls.h"

//***************************************************************************
//
//  COctetStringClass::~COctetStringClass
//
//***************************************************************************
// ok
COctetStringClass::COctetStringClass()
:	CWbemClass(),
	m_fInitialized( FALSE )
{
}
    
//***************************************************************************
//
//  COctetStringClass::~COctetStringClass
//
//***************************************************************************
// ok
COctetStringClass::~COctetStringClass()
{
}


HRESULT	COctetStringClass::Init( void )
{
	CLock	lock(this);

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( !m_fInitialized )
	{
		try
		{
			// Initialize then add the properties
			hr = InitEmpty();

			if ( SUCCEEDED( hr ) )
			{
				CVar	var( L"uint8Array", TRUE );
				var.SetCanDelete( FALSE );

				hr = m_CombinedPart.m_ClassPart.SetClassName( &var );
				
				if ( SUCCEEDED( hr ) )
				{
					hr = WriteProp( L"values", 0L, 0L, 0L, CIM_UINT8 | CIM_FLAG_ARRAY, NULL );

					if ( SUCCEEDED( hr ) )
					{
						hr = WriteProp( L"numberOfValues", 0L, 0L, 0L, CIM_UINT32, NULL );

						m_fInitialized = SUCCEEDED(hr);

					}	// IF Wrote values

				}	// IF SetClassName

			}	// IF InitEmpty

		}
		catch( CX_MemoryException )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		catch(...)
		{
			hr = WBEM_E_CRITICAL_ERROR;
		}

	}	// IF !Initialized

	return hr;
}

HRESULT COctetStringClass::GetInstance( PUMI_OCTET_STRING pOctetStr, _IWmiObject** pNewInst )
{
	CLock	lock(this);

	HRESULT	hr = Init();

	if ( SUCCEEDED( hr ) )
	{
		hr = SpawnInstance( 0L, (IWbemClassObject**) pNewInst );
		CReleaseMe	rm(*pNewInst);

		if ( SUCCEEDED( hr ) )
		{
			// Set the two properties
			hr = (*pNewInst)->WriteProp( L"values", 0L, pOctetStr->uLength, pOctetStr->uLength,
									CIM_UINT8 | CIM_FLAG_ARRAY, pOctetStr->lpValue );

			if ( SUCCEEDED( hr ) )
			{
				hr = (*pNewInst)->WriteProp( L"numberOfValues", 0L, sizeof(pOctetStr->uLength), 0L,
								CIM_UINT32, &pOctetStr->uLength );

				if ( SUCCEEDED( hr ) )
				{
					(*pNewInst)->AddRef();
				}

			}	// IF Wrote values
		}
	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT COctetStringClass::FillOctetStr( _IWmiObject* pNewInst, PUMI_OCTET_STRING pOctetStr )
{
	CLock	lock(this);

	DWORD	dwBuffSizeUsed = 0,
			dwBuffSize = 0;
	BOOL	fIsNull = 0;
	WCHAR	wcsClassName[11];	// Bug enough to hold the proper name

	HRESULT hr = pNewInst->ReadProp( L"__CLASS", 0L, sizeof(wcsClassName), NULL, NULL, &fIsNull, &dwBuffSizeUsed, wcsClassName );

	// If we can't get the classname, something is badly wrong
	if ( SUCCEEDED( hr ) )
	{
		if ( !fIsNull && wbem_wcsicmp( wcsClassName, L"uint8Array" ) == 0 )
		{
			// We'll use a _IWmiArray for this
			_IWmiArray*	pWmiArray = NULL;

			hr = pNewInst->ReadProp( L"values", 0L, sizeof(_IWmiArray*), NULL, NULL, &fIsNull, &dwBuffSizeUsed, &pWmiArray );
			CReleaseMe	rm(pWmiArray);

			if ( SUCCEEDED(hr) )
			{
				if ( !fIsNull )
				{

					// First get the number of values, then get the value
					ULONG	uNumElements = 0;

					hr = pWmiArray->GetAt( WMIARRAY_FLAG_ALLELEMENTS, 0, 0, 0, &uNumElements, &dwBuffSize, NULL );

					if ( WBEM_E_BUFFER_TOO_SMALL == hr )
					{

						LPBYTE	pbData = new BYTE[dwBuffSize];

						if ( NULL != pbData )
						{
							hr = pWmiArray->GetAt( WMIARRAY_FLAG_ALLELEMENTS, 0, 0, dwBuffSize, &uNumElements, &dwBuffSizeUsed, pbData );

							if ( SUCCEEDED( hr ) )
							{
								pOctetStr->uLength = uNumElements;
								pOctetStr->lpValue = pbData;
							}
							else
							{
								delete [] pbData;
							}
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
						
					}	// IF got proper error
					else
					{
						hr = WBEM_E_INVALID_OPERATION;
					}

				}	// IF fIsNUll
				else
				{
					pOctetStr->uLength = 0;
					pOctetStr->lpValue = NULL;
				}

			}	// IF ReadProp
			else
			{
				hr = WBEM_E_INVALID_OPERATION;
			}
		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\olewrap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.CPP

Abstract:

    Wrapper classes for COM data type functions.  

    If a COM data function is required to allocate memory and fails to do 
    so, then a CX_MemoryException exception is thrown.  All COM data type 
    functions are wrapped, regardless if they allocate memory, for the sake  
    of completeness.

History:

    a-dcrews    19-Mar-99   Created.

--*/

#include "precomp.h"
#include <corex.h>
#include <oleauto.h>

#include "OleWrap.h"
#include "genutils.h"

//***************************************************************************
//
//  SafeArray wrappers
//
//***************************************************************************


HRESULT COleAuto::_SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData)
{
    return SafeArrayAccessData(psa, ppvData);
}

HRESULT COleAuto::_SafeArrayAllocData(SAFEARRAY FAR* psa)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayAllocData(psa);
    return hRes;
}

HRESULT COleAuto::_SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY FAR* FAR* ppsaOut)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayAllocDescriptor(cDims, ppsaOut);
    return hRes;
}

HRESULT COleAuto::_SafeArrayCopy(SAFEARRAY FAR* psa, SAFEARRAY FAR* FAR* ppsaOut)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayCopy(psa, ppsaOut);
    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SafeArrayCopyData(SAFEARRAY FAR* psaSource, SAFEARRAY FAR* psaTarget)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayCopyData(psaSource, psaTarget);
    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

SAFEARRAY* COleAuto::_SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND FAR* rgsabound)
{
    SAFEARRAY*  psa;

    psa = SafeArrayCreate(vt, cDims, rgsabound);
    if (NULL == psa)
    {
        throw CX_MemoryException();
    }

    return psa;
}

SAFEARRAY* COleAuto::_SafeArrayCreateVector(VARTYPE vt, long lLbound, unsigned int cElements)
{
    SAFEARRAY*  psa;

    psa = SafeArrayCreateVector(vt, lLbound, cElements);
    if (NULL == psa)
    {
        throw CX_MemoryException();
    }

    return psa;
}

HRESULT COleAuto::_SafeArrayDestroy(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroy(psa);
}

HRESULT COleAuto::_SafeArrayDestroyData(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroyData(psa);
}

HRESULT COleAuto::_SafeArrayDestroyDescriptor(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroyDescriptor(psa);
}

UINT COleAuto::_SafeArrayGetDim(SAFEARRAY FAR* psa)
{
    return SafeArrayGetDim(psa);
}

HRESULT COleAuto::_SafeArrayGetElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayGetElement(psa, rgIndices, pv);
}

UINT COleAuto::_SafeArrayGetElemsize(SAFEARRAY FAR* psa)
{
    return SafeArrayGetElemsize(psa);
}

HRESULT COleAuto::_SafeArrayGetLBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plLbound)
{
    return SafeArrayGetLBound(psa, nDim, plLbound);
}

HRESULT COleAuto::_SafeArrayGetUBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plUbound)
{
    return SafeArrayGetUBound(psa, nDim, plUbound);
}

HRESULT COleAuto::_SafeArrayLock(SAFEARRAY FAR* psa)
{
    return SafeArrayLock(psa);
}

HRESULT COleAuto::_SafeArrayPtrOfIndex(SAFEARRAY FAR* psa, long FAR* rgIndices, void HUGEP* FAR* ppvData)
{
    return SafeArrayPtrOfIndex(psa, rgIndices, ppvData);
}

HRESULT COleAuto::_SafeArrayPutElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayPutElement(psa, rgIndices, pv);
}

HRESULT COleAuto::_SafeArrayRedim(SAFEARRAY FAR* psa, SAFEARRAYBOUND FAR* psaboundNew)
{
    return SafeArrayRedim(psa, psaboundNew);
}

HRESULT COleAuto::_SafeArrayUnaccessData(SAFEARRAY FAR* psa)
{
    return SafeArrayUnaccessData(psa);
}

HRESULT COleAuto::_SafeArrayUnlock(SAFEARRAY FAR* psa)
{
    return SafeArrayUnlock(psa);
}

//***************************************************************************
//
//  Variant wrappers
//
//***************************************************************************


HRESULT COleAuto::_WbemVariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, VARTYPE vt)
{
    HRESULT hRes = WbemVariantChangeType(pvargDest, pvarSrc, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeType(pvargDest, pvarSrc, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeTypeEx(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeTypeEx(pvargDest, pvarSrc, lcid, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantClear(VARIANTARG FAR* pvarg)
{
    return VariantClear(pvarg);
}

HRESULT COleAuto::_VariantCopy(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopy(pvargDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantCopyInd(VARIANT FAR* pvarDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopyInd(pvarDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

void COleAuto::_VariantInit(VARIANTARG FAR* pvarg)
{
    VariantInit(pvarg);
}


//***************************************************************************
//
//  BSTR wrappers
//
//***************************************************************************


BSTR COleAuto::_SysAllocString(const OLECHAR* sz)
{
    BSTR bstr = SysAllocString(sz);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringByteLen(LPCSTR psz, UINT len)
{
    BSTR bstr = SysAllocStringByteLen(psz, len);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringLen(const OLECHAR* pch, UINT cch)
{
    BSTR bstr = SysAllocStringLen(pch, cch);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

void COleAuto::_SysFreeString(BSTR bstr)
{
    SysFreeString(bstr);
}

HRESULT COleAuto::_SysReAllocString(BSTR* pbstr, const OLECHAR* sz)
{
    HRESULT hRes = SysReAllocString(pbstr, sz);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch)
{
    HRESULT hRes = SysReAllocStringLen(pbstr, pch, cch);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysStringByteLen(BSTR bstr)
{
    return SysStringByteLen(bstr);
}

HRESULT COleAuto::_SysStringLen(BSTR bstr)
{
    return SysStringLen(bstr);
}


//***************************************************************************
//
//  Conversion wrappers
//
//***************************************************************************


HRESULT COleAuto::_VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa)
{
    HRESULT hRes = VectorFromBstr(bstr, ppsa);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_BstrFromVector (SAFEARRAY *psa, BSTR *pbstr)
{
    HRESULT hRes = BstrFromVector(psa, pbstr);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objindpacket.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

   OBJINDPACKET.H

Abstract:

   Object Sink Indicate packet.

History:

--*/

#ifndef __OBJINDPACKET_H__
#define __OBJINDPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECTSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_OBJECTSINK_INDICATE;

typedef WBEM_DATAPACKET_OBJECTSINK_INDICATE* PWBEM_DATAPACKET_OBJECTSINK_INDICATE;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemObjSinkIndicatePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemObjectSink::Indicate() operation.  The data structure of this
//	packet is described above.  It makes use of CWbemObjectPacket,
//	CWbemInstancePacket, CWbemClassPacket and CWbemClasslessInstancePacket
//	to walk and analyze data for each of the IWbemClassObjects that
//	are indicated into the Sink.
//

class COREPROX_POLARITY CWbemObjSinkIndicatePacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_OBJECTSINK_INDICATE	m_pObjSinkIndicate;

public:

	CWbemObjSinkIndicatePacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemObjSinkIndicatePacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemObjSinkIndicatePacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\olewrap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.H

Abstract:

    Wrapper classes for COM data type functions.  

	If a COM data function is required to allocate memory and fails to do 
	so, then a CX_MemoryException exception is thrown.  All COM data type 
	functions are wrapped, regardless if they allocate memory, for the sake  
	of completeness.

History:

	a-dcrews	19-Mar-99	Created.

--*/

#ifndef _OLEWRAP_H_
#define _OLEWRAP_H_

class COleAuto
{
public:

	// Safe array methods
	// ==================

	static HRESULT _SafeArrayAccessData(SAFEARRAY* psa, void HUGEP** ppvData);
	static HRESULT _SafeArrayAllocData(SAFEARRAY* psa);
	static HRESULT _SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY** ppsaOut);
	static HRESULT _SafeArrayCopy(SAFEARRAY* psa, SAFEARRAY** ppsaOut);
	static HRESULT _SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget);
	static SAFEARRAY* _SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND* rgsabound);
	static SAFEARRAY* _SafeArrayCreateVector(VARTYPE vt, long lLbound, unsigned int cElements);
	static HRESULT _SafeArrayDestroy(SAFEARRAY* psa);
	static HRESULT _SafeArrayDestroyData(SAFEARRAY* psa);
	static HRESULT _SafeArrayDestroyDescriptor(SAFEARRAY* psa);
	static UINT _SafeArrayGetDim(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static UINT _SafeArrayGetElemsize(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetLBound(SAFEARRAY* psa, unsigned int nDim, long* plLbound);
	static HRESULT _SafeArrayGetUBound(SAFEARRAY* psa, unsigned int nDim, long* plUbound);
	static HRESULT _SafeArrayLock(SAFEARRAY* psa);
	static HRESULT _SafeArrayPtrOfIndex(SAFEARRAY* psa, long* rgIndices, void HUGEP** ppvData);
	static HRESULT _SafeArrayPutElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static HRESULT _SafeArrayRedim(SAFEARRAY* psa, SAFEARRAYBOUND* psaboundNew);
	static HRESULT _SafeArrayUnaccessData(SAFEARRAY* psa);
	static HRESULT _SafeArrayUnlock(SAFEARRAY* psa);

	// Variant methods
	// ===============

	static HRESULT _WbemVariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, VARTYPE vt);
	static HRESULT _VariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantChangeTypeEx(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantClear(VARIANTARG* pvarg);
	static HRESULT _VariantCopy(VARIANTARG* pvargDest, VARIANTARG* pvargSrc);
	static HRESULT _VariantCopyInd(VARIANT* pvarDest, VARIANTARG* pvargSrc);
	static void _VariantInit(VARIANTARG* pvarg);

	// BSTR methods
	// ============

	static BSTR _SysAllocString(const OLECHAR* sz);
	static BSTR _SysAllocStringByteLen(LPCSTR psz, UINT len);
	static BSTR _SysAllocStringLen(const OLECHAR* pch, UINT cch);
	static void _SysFreeString(BSTR bstr);
	static HRESULT _SysReAllocString(BSTR* pbstr, const OLECHAR* sz);
	static HRESULT _SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch);
	static HRESULT _SysStringByteLen(BSTR bstr);
	static HRESULT _SysStringLen(BSTR bstr);

	// Conversion methods
	// ==================

	static HRESULT _VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa);
	static HRESULT _BstrFromVector (SAFEARRAY *psa, BSTR *pbstr);
};

#endif	//_OLEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ocstrcls.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  OCSTRCLS.H

Abstract:

  COctetStringClass Definition.

  Defines a class object from which instances can be spawned
  so we can model an octet string.

History:

  22-Apr-2000	sanjes    Created.

--*/

#ifndef _OCSTRCLS_H_
#define _OCSTRCLS_H_

#include "corepol.h"
#include <arena.h>
#include "fastall.h"

//***************************************************************************
//
//  class COctetStringClass
//
//  Implementation of octet string wrapper
//
//***************************************************************************

class COREPROX_POLARITY COctetStringClass : public CWbemClass
{
	BOOL	m_fInitialized;

public:

    COctetStringClass();
	~COctetStringClass(); 

	// _IUMIErrorObject Methods

	HRESULT	Init( void );
	HRESULT GetInstance( PUMI_OCTET_STRING pOctetStr, _IWmiObject** pNewInst );
	HRESULT FillOctetStr( _IWmiObject* pNewInst, PUMI_OCTET_STRING pOctetStr );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\proxmain.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PROXMAIN.CPP

Abstract:

    Main DLL entry points

History:

--*/

#include "precomp.h"
#include "fastprox.h"
#include <context.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include "fastall.h"
#include "hiperfenum.h"
#include "refrenum.h"
#include "refrcli.h"
#include "sinkmrsh.h"
#include "enummrsh.h"
#include "ubskmrsh.h"
#include "mtgtmrsh.h"
#include "wmiobftr.h"
#include "wmiobtxt.h"
#include "svcmrsh.h"
#include "callsec.h"
#include "refrsvc.h"
#include "refrcach.h"
#include "wmicombd.h"
#include "wcommrsh.h"
#include "smrtenum.h"
#include "refmghlp.h"

#include <tchar.h>

//***************************************************************************
//
//  CLASS NAME:
//
//  CGenFactory
//
//  DESCRIPTION:
//
//  Class factory for the CWbemClass .
//
//***************************************************************************


typedef LPVOID * PPVOID;
template<class TObject>
class CGenFactory : public CBaseClassFactory
{

public:
    CGenFactory( CLifeControl* pControl = NULL )
    : CBaseClassFactory( pControl ) {}

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        if(pOuter)
            return CLASS_E_NOAGGREGATION;

        // Lock
        if(m_pControl && !m_pControl->ObjectCreated(NULL))
        {
            // Shutting down
            // =============
            return CO_E_SERVER_STOPPING;
        }

        // Create
        TObject* pObject = new TObject;

        // Unlock
        if(m_pControl)
            m_pControl->ObjectDestroyed(NULL);

        // Get the interface
        if(pObject == NULL)
            return E_FAIL;

        // Setup the class all empty, etc.

        if ( FAILED( pObject->InitEmpty() ) )
        {
            return E_FAIL;
        }

        HRESULT hr = pObject->QueryInterface(riid, ppv);

        // These objects have an initial refcount of 1
        pObject->Release();

        return hr;
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};

// {71285C44-1DC0-11d2-B5FB-00104B703EFD}
const CLSID CLSID_IWbemObjectSinkProxyStub = { 0x71285c44, 0x1dc0, 0x11d2, { 0xb5, 0xfb, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0xfd } };

// {1B1CAD8C-2DAB-11d2-B604-00104B703EFD}
const CLSID CLSID_IEnumWbemClassObjectProxyStub = { 0x1b1cad8c, 0x2dab, 0x11d2, { 0xb6, 0x4, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0xfd } };

// {29B5828C-CAB9-11d2-B35C-00105A1F8177}
const CLSID CLSID_IWbemUnboundObjectSinkProxyStub = { 0x29b5828c, 0xcab9, 0x11d2, { 0xb3, 0x5c, 0x0, 0x10, 0x5a, 0x1f, 0x81, 0x77 } };

// {7016F8FA-CCDA-11d2-B35C-00105A1F8177}
static const CLSID CLSID_IWbemMultiTargetProxyStub = { 0x7016f8fa, 0xccda, 0x11d2, { 0xb3, 0x5c, 0x0, 0x10, 0x5a, 0x1f, 0x81, 0x77 } };

// {D68AF00A-29CB-43fa-8504-CE99A996D9EA}
static const CLSID CLSID_IWbemServicesProxyStub = { 0xd68af00a, 0x29cb, 0x43fa, { 0x85, 0x4, 0xce, 0x99, 0xa9, 0x96, 0xd9, 0xea } };

// {D71EE747-F455-4804-9DF6-2ED81025F2C1}
static const CLSID CLSID_IWbemComBindingProxyStub =
{ 0xd71ee747, 0xf455, 0x4804, { 0x9d, 0xf6, 0x2e, 0xd8, 0x10, 0x25, 0xf2, 0xc1 } };

// Signature to use when marshaling pointers across threads
unsigned __int64 g_ui64PointerSig = 0;

#ifdef _X86_
BOOL IsReallyWOW64( void )
{
	// Environment variable should only exist on WOW64
	return ( GetEnvironmentVariable( L"PROCESSOR_ARCHITEW6432", 0L, NULL ) != 0L );
}

void UnregisterRefresher( void )
{
    WCHAR      wcID[128];
    WCHAR  szCLSID[256];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_WbemRefresher, wcID, 128);
    lstrcpyW(szCLSID, L"SOFTWARE\\Classes\\CLSID\\");
    lstrcatW(szCLSID, wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKeyW(hKey, L"InProcServer32");
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKeyW(hKey,wcID);
        RegCloseKey(hKey);
    }
}
#endif

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_WbemClassObjectProxy,
            new CSimpleClassFactory<CFastProxy>(GetLifeControl()),
            __TEXT("WbemClassObject Marshalling proxy"), TRUE);

        AddClassInfo(CLSID_WbemContext,
            new CSimpleClassFactory<CWbemContext>(GetLifeControl()),
            __TEXT("Call Context"), TRUE);

#ifdef _X86_
		// If x86 binary, on WOW 64 we don't allow the refresher to do its little
		// dance
		if ( !IsReallyWOW64() )
		{
			AddClassInfo(CLSID_WbemRefresher,
				new CClassFactory<CUniversalRefresher>(GetLifeControl()),
				__TEXT("Universal Refresher"), TRUE);
		}
#else
		AddClassInfo(CLSID_WbemRefresher,
			new CClassFactory<CUniversalRefresher>(GetLifeControl()),
			__TEXT("Universal Refresher"), TRUE);
#endif

        AddClassInfo(CLSID_WbemClassObject,
            new CGenFactory<CWbemClass>(GetLifeControl()),
            __TEXT("WBEM Class Object"), TRUE);

        AddClassInfo(CLSID__WmiObjectFactory,
            new CSimpleClassFactory<CWmiObjectFactory>(GetLifeControl()),
            __TEXT("WMI Object Factory"), TRUE);

        AddClassInfo(CLSID_WbemObjectTextSrc,
            new CSimpleClassFactory<CWmiObjectTextSrc>(GetLifeControl()),
            __TEXT("WMI Object Factory"), TRUE);

        AddClassInfo(CLSID_IWbemObjectSinkProxyStub,
            new CSinkFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemObjectSink"), TRUE);

        AddClassInfo(CLSID_IEnumWbemClassObjectProxyStub,
            new CEnumFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IEnumWbemClassObject"), TRUE);

        AddClassInfo(CLSID_WbemUninitializedClassObject,
            new CClassObjectFactory(GetLifeControl()),
            __TEXT("Uninitialized WbemClassObject for transports"), TRUE);

        AddClassInfo(CLSID_IWbemUnboundObjectSinkProxyStub,
            new CUnboundSinkFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemUnboundObjectSink"), TRUE);

        AddClassInfo(CLSID_IWbemMultiTargetProxyStub,
            new CMultiTargetFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemMultiTarget"), TRUE);

        AddClassInfo(CLSID_IWbemServicesProxyStub,
            new CSvcFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemServices"), TRUE);

        AddClassInfo(CLSID__IWbemCallSec,
            new CSimpleClassFactory<CWbemCallSecurity>(GetLifeControl()),
            __TEXT("_IWmiCallSec Call Security Factory"), TRUE);
        
        AddClassInfo( CLSID__WbemConfigureRefreshingSvcs,
            new CClassFactory<CWbemRefreshingSvc>(GetLifeControl()),
            __TEXT("_IWbemConfigureRefreshingSvc Configure Refreshing Services Factory"), TRUE);

        AddClassInfo( CLSID__WbemRefresherMgr,
            new CClassFactory<CRefresherCache>(GetLifeControl()),
            __TEXT("_IWbemRefresherMgr Refresher Cache Factory"), TRUE);

        AddClassInfo( CLSID__WbemComBinding,
            new CClassFactory<CWmiComBinding>(GetLifeControl()),
            __TEXT("IWbemComBinding  Factory"), TRUE);

        AddClassInfo(CLSID_IWbemComBindingProxyStub,
            new CComBindFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemComBinding"), TRUE);

        AddClassInfo( CLSID__WbemEnumMarshaling,
            new CClassFactory<CWbemEnumMarshaling>(GetLifeControl()),
            __TEXT("_IWbemEnumMarshaling Enumerator Helper"), TRUE);

        // This guy is truly free threaded
        AddClassInfo( CLSID__WbemFetchRefresherMgr,
            new CClassFactory<CWbemFetchRefrMgr>(GetLifeControl()),
            __TEXT("_WbemFetchRefresherMgr Proxy Helper"), TRUE, TRUE);

        // Signature to use when marshaling pointers across threads
        LARGE_INTEGER   li;
        QueryPerformanceCounter( &li );

        g_ui64PointerSig = li.QuadPart;

        return S_OK;
    }
    void Uninitialize()
    {
        CUniversalRefresher::Flush();
    }
    void Register()
    {

#ifdef _X86_
		// If x86 binary on WOW64, we will remove any previous refresher stuff
		if ( IsReallyWOW64() )
		{
			UnregisterRefresher();
		}
#endif

        RegisterInterfaceMarshaler(IID_IWbemObjectSink, CLSID_IWbemObjectSinkProxyStub,
                __TEXT("IWbemObjectSink"), 5, IID_IUnknown);
        RegisterInterfaceMarshaler(IID_IEnumWbemClassObject, CLSID_IEnumWbemClassObjectProxyStub,
                __TEXT("IEnumWbemClassObject"), 5, IID_IUnknown);
        // This guy only has 4 methods
        RegisterInterfaceMarshaler(IID_IWbemUnboundObjectSink, CLSID_IWbemUnboundObjectSinkProxyStub,
                __TEXT("IWbemUnboundObjectSink"), 4, IID_IUnknown);
        // This guy only has 4 methods
        RegisterInterfaceMarshaler(IID_IWbemMultiTarget, CLSID_IWbemMultiTargetProxyStub,
                __TEXT("IWbemMultiTarget"), 5, IID_IUnknown);

        RegisterInterfaceMarshaler(IID_IWbemServices, CLSID_IWbemServicesProxyStub,
                __TEXT("IWbemServices"), 40, IID_IUnknown);

        RegisterInterfaceMarshaler(IID_IWbemComBinding, CLSID_IWbemComBindingProxyStub,
                __TEXT("IWbemComBinding"), 3, IID_IUnknown);

        // this is for FastProx to be used as a marshaler even if NO_CUSTOM_MARSHAL is set
        HKEY hKey;
        if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
            _T("software\\classes\\CLSID\\{4590F812-1D3A-11D0-891F-00AA004B2E24}\\")
            _T("Implemented Categories\\{00000003-0000-0000-C000-000000000046}"),
            &hKey))
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
        // this is for IWbemContext
        if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
            _T("software\\classes\\CLSID\\{674B6698-EE92-11D0-AD71-00C04FD8FDFF}\\")
            _T("Implemented Categories\\{00000003-0000-0000-C000-000000000046}"),            
            &hKey))
        {
            RegCloseKey(hKey);
            hKey = NULL;        
        }

    }
    void Unregister()
    {
#ifdef _X86_
		// If x86 binary on WOW64, we will always remove any previous refresher stuff
		if ( IsReallyWOW64() )
		{
			UnregisterRefresher();
		}
#endif

        UnregisterInterfaceMarshaler(IID_IWbemObjectSink);
        UnregisterInterfaceMarshaler(IID_IEnumWbemClassObject);
        UnregisterInterfaceMarshaler(IID_IWbemUnboundObjectSink);
        UnregisterInterfaceMarshaler(IID_IWbemMultiTarget);
        UnregisterInterfaceMarshaler(IID_IWbemServices);
        UnregisterInterfaceMarshaler(IID_IWbemComBinding);
    }
    void PostUninitialize();

} Server;

void CMyServer::PostUninitialize()
{
    // This is called during DLL shutdown. Normally, we wouldn't want to do
    // anything here, but Windows 95 has an unfortunate bug in that in its
    // CoUninitize it first unloads all COM server DLLs that it has and *then*
    // attempts to release any error object that may be outstanding at that
    // time. This, obviously, causes a crash, since Release code is no longer
    // there. Hence, during our dll unload (DllCanUnloadNow is not called on
    // shutdown), we check if an error object of ours is outstanding and clear
    // it if so.

    IErrorInfo* pInfo = NULL;
    if(SUCCEEDED(GetErrorInfo(0, &pInfo)) && pInfo != NULL)
    {
        IWbemClassObject* pObj;
        if(SUCCEEDED(pInfo->QueryInterface(IID_IWbemClassObject,
                                            (void**)&pObj)))
        {
            // Our error object is outstanding at the DLL shutdown time.
            // Release it
            // =========================================================

            pObj->Release();
            pInfo->Release();
        }
        else
        {
            // It's not ours
            // =============

            SetErrorInfo(0, pInfo);
            pInfo->Release();
        }
    }
}

static LONG g_lDebugObjCount = 0;

void ObjectCreated(DWORD dwType,IUnknown * pThis)
{
    InterlockedIncrement(&g_lDebugObjCount);
    Server.GetLifeControl()->ObjectCreated(pThis);
}

void ObjectDestroyed(DWORD dwType,IUnknown * pThis)
{
    InterlockedDecrement(&g_lDebugObjCount);
    Server.GetLifeControl()->ObjectDestroyed(pThis);
}

extern "C" _declspec(dllexport)
LONG WINAPI GetObjectCount() { return g_lDebugObjCount; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refmghlp.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFMGHLP.CPP

Abstract:

  CWbemFetchRefrMgr implementation.

  Implements the _IWbemFetchRefresherMgr interface.

History:

  07-Sep-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <corex.h>
#include "fastall.h"
#include "refmghlp.h"
#include "arrtempl.h"
#include <corex.h>

_IWbemRefresherMgr*		CWbemFetchRefrMgr::s_pRefrMgr = NULL;
CCritSec				CWbemFetchRefrMgr::s_cs;

//***************************************************************************
//
//  CWbemFetchRefrMgr::~CWbemFetchRefrMgr
//
//***************************************************************************
// ok
CWbemFetchRefrMgr::CWbemFetchRefrMgr( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk(pControl, pOuter),
	m_XFetchRefrMgr( this )
{
}
    
//***************************************************************************
//
//  CWbemFetchRefrMgr::~CWbemFetchRefrMgr
//
//***************************************************************************
// ok
CWbemFetchRefrMgr::~CWbemFetchRefrMgr()
{
}

// Override that returns us an interface
void* CWbemFetchRefrMgr::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWbemFetchRefresherMgr)
        return &m_XFetchRefrMgr;
    else
        return NULL;
}

/* _IWbemFetchRefresherMgr methods */

HRESULT CWbemFetchRefrMgr::XFetchRefrMgr::Get( _IWbemRefresherMgr** ppMgr )
{
	return m_pObject->Get( ppMgr );
}

STDMETHODIMP CWbemFetchRefrMgr::XFetchRefrMgr::Init( _IWmiProvSS* pProvSS, IWbemServices* pSvc )
{
	return m_pObject->Init( pProvSS, pSvc );
}

STDMETHODIMP CWbemFetchRefrMgr::XFetchRefrMgr::Uninit( void )
{
	return m_pObject->Uninit();
}

// Specifies everything we could possibly want to know about the creation of
// an object and more.
HRESULT CWbemFetchRefrMgr::Get( _IWbemRefresherMgr** ppMgr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		CInCritSec	ics( &s_cs );

		// If this hasn't been created, then we need to use Core Services to create this
		if ( NULL == s_pRefrMgr )
		{
			_IWmiCoreServices*	pSvc = NULL;

			hr = CoCreateInstance( CLSID_IWmiCoreServices, NULL, CLSCTX_INPROC_SERVER, IID__IWmiCoreServices, (void**) &pSvc );	
			CReleaseMe	rm( pSvc );

			if ( SUCCEEDED( hr ) )
			{
				hr = pSvc->InitRefresherMgr( 0L );

				if ( SUCCEEDED( hr ) )
				{
					if ( NULL != s_pRefrMgr )
					{
						*ppMgr = s_pRefrMgr;
						s_pRefrMgr = NULL ;
					}
					else
					{
						hr = WBEM_E_FAILED;
					}

				}	// IF InitRefresherMgr

			}	// IF CCI

		}
		else
		{
			s_pRefrMgr->AddRef();
			*ppMgr = s_pRefrMgr;
		}

		return hr;

	}
	catch ( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CWbemFetchRefrMgr::Init( _IWmiProvSS* pProvSS, IWbemServices* pSvc )
{
	CInCritSec	ics( &s_cs );

	if ( NULL == pProvSS || NULL == pSvc )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL == s_pRefrMgr )
	{
		hr = pProvSS->CreateRefresherManager(
		pSvc,
		0,                              // lFlags
		NULL,
		IID__IWbemRefresherMgr,
		(LPVOID *) &s_pRefrMgr
		);
	}

	return hr;

}

HRESULT CWbemFetchRefrMgr::Uninit( void )
{
	CCheckedInCritSec	ics( &s_cs );

	if ( NULL != s_pRefrMgr )
	{
		// We don't want to release inside the critical section, so copy the pointer
		// into a local variable, NULL out the pointer, leave the crit sec and then
		// release it.

		_IWbemRefresherMgr*	pRefrMgr = s_pRefrMgr;
		s_pRefrMgr = NULL;

		ics.Leave();

		// Now safe to release it
		pRefrMgr->Release();

	}

	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcach.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRCACH.H

Abstract:

  CRefresherCache Definition.

  Standard definition for _IWbemRefresherMgr.

History:

  27-Apr-2000	sanjes    Created.

--*/

#ifndef _REFRCACHE_H_
#define _REFRCACHE_H_

#include "corepol.h"
#include <arena.h>
#include "rfchercd.h"

//***************************************************************************
//
//  class CRefresherCache
//
//  Implementation of _IWbemRefresherMgr Interface
//
//***************************************************************************

class CRefresherCache : public CUnk
{
private:
	//TODO: How will we get this?
	_IWmiProvSS *m_pProvSS;
    CUniquePointerArray<CRefresherRecord> m_apRefreshers;
    CUniquePointerArray<CHiPerfPrvRecord> m_apProviders;
	CCritSec	m_cs;

public:
    CRefresherCache(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CRefresherCache(); 

protected:

	// COM interface implementatioms
    class XWbemRefrCache : public CImpl<_IWbemRefresherMgr, CRefresherCache>
    {
    public:
        XWbemRefrCache(CRefresherCache* pObject) : 
            CImpl<_IWbemRefresherMgr, CRefresherCache>(pObject)
        {}

		STDMETHOD(AddObjectToRefresher)( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject, WBEM_REFRESHER_ID* pDestRefresherId,
									IWbemClassObject* pInstTemplate, long lFlags, IWbemContext* pContext, IUnknown* pLockMgr,
									WBEM_REFRESH_INFO* pInfo );

		STDMETHOD(AddEnumToRefresher)( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
									WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate, LPCWSTR wszClass, long lFlags, IWbemContext* pContext, IUnknown* pLockMgr,
									WBEM_REFRESH_INFO* pInfo );

		STDMETHOD(GetRemoteRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lFlags, BOOL fAddRefresher, IWbemRemoteRefresher** ppRemRefresher, IUnknown* pLockMgr,
										GUID* pGuid );

		STDMETHOD(Startup)(	long lFlags , IWbemContext *pCtx , _IWmiProvSS* pProvSS );

		STDMETHOD(LoadProvider)( IWbemServices* pNamespace, 
		                         LPCWSTR pwszProviderName, 
		                         LPCWSTR pwszNamespace, 
		                         IWbemContext * pContext,
		                         IWbemHiPerfProvider** ppProv,
								 _IWmiProviderStack** ppProvStack );


    } m_XWbemRefrCache;
    friend XWbemRefrCache;

    class XWbemShutdown : public CImpl<IWbemShutdown, CRefresherCache>
    {
    public:
        XWbemShutdown(CRefresherCache* pObject) : 
            CImpl<IWbemShutdown, CRefresherCache>(pObject)
        {}

		STDMETHOD(Shutdown)( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context ) ;

    } m_XWbemShutdown;
    friend XWbemShutdown;

protected:

	virtual HRESULT AddObjectToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
								WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate, long lFlags, IWbemContext* pContext, IUnknown* pLockMgr,
								WBEM_REFRESH_INFO* pInfo );

	virtual HRESULT AddEnumToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
									WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate, LPCWSTR wszClass,
									long lFlags, IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo );

	virtual HRESULT GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, BOOL fAddRefresher, IWbemRemoteRefresher** ppRemRefresher,
										IUnknown* pLockMgr, GUID* pGuid );

	virtual HRESULT Startup( long lFlags , IWbemContext *pCtx , _IWmiProvSS* pProvSS );

	virtual HRESULT Shutdown( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context ) ;

	virtual HRESULT LoadProvider( IWbemServices* pNamespace, 
	                              LPCWSTR pwszProviderName, 
	                              LPCWSTR pwszNamespace, 
	                              IWbemContext * pContext,
	                              IWbemHiPerfProvider** ppProv,
								 _IWmiProviderStack** ppProvStack );

protected:
    void* GetInterface(REFIID riid);

public:

	// Dummy function for the aggregable class factory template
	BOOL Initialize( void ) { return TRUE; }

	// Workhorse helper functions
    BOOL RemoveRefresherRecord(CRefresherRecord* pRecord);
    BOOL RemoveProviderRecord(CHiPerfPrvRecord* pRecord);

    static MSHCTX GetDestinationContext(CRefresherId* pRefresherId);

    HRESULT CreateInfoForProvider(CRefresherId* pDestRefresherId,
                    CHiPerfPrvRecord*	pProvRecord,
					LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
					IWbemServices* pNamespace,
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo,
					IUnknown* pLockMgr);

    HRESULT CreateEnumInfoForProvider(CRefresherId* pDestRefresherId,
                    CHiPerfPrvRecord*	pProvRecord,
					LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
					IWbemServices* pNamespace,
                    CWbemObject* pInstTemplate,
					LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo,
					IUnknown* pLockMgr);

    HRESULT RemoveObjectFromRefresher(CRefresherId* pId,
                            long lId, long lFlags);

    HRESULT FindRefresherRecord( CRefresherId* pRefresherId, BOOL bCreate,
								IUnknown* pLockMgr, CRefresherRecord** ppRecord );

	HRESULT FindProviderRecord( LPCWSTR pwszProviderName, LPCWSTR pszNamespace, IWbemServices* pSvc, CHiPerfPrvRecord** ppRecord );

//	HRESULT FindProviderRecord2( LPCWSTR pwszProviderName, LPCWSTR pszNamespace, IWbemServices* pSvc, CHiPerfPrvRecord** ppRecord );
	
	HRESULT GetProviderInfo( IWbemServices* pSvc, LPCWSTR pwszProviderName, CLSID* pClsid, CLSID* pClientClsid );

	HRESULT LoadProvider( LPCWSTR pwszProviderName, 
	                      LPCWSTR pszNamespace, 
	                      IWbemServices* pSvc, 
	                      IWbemContext * pContext,
	                      IWbemHiPerfProvider** ppProv,
							_IWmiProviderStack** ppStack );

	HRESULT GetProviderName( IWbemClassObject*	pObj, CVar* pProviderName, BOOL* pfStatic );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcli.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCLI.CPP

Abstract:

    Refresher Client Side Code.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <process.h>
//#include <wbemcomn.h>
#include "fastall.h"
#include "hiperfenum.h"
#include "refrenum.h"
#include "refrcli.h"
#include <sync.h>
#include <provinit.h>
#include <cominit.h>
#include <wbemint.h>

//*****************************************************************************
//*****************************************************************************
//                              XCREATE
//*****************************************************************************
//*****************************************************************************

STDMETHODIMP CUniversalRefresher::XCreate::AddObjectByPath(
    IWbemServices* pNamespace, LPCWSTR wszPath,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == wszPath || NULL == ppRefreshable || NULL == *wszPath )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Validate flags
    if ( ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        // Acquire internal connection to WINMGMT
        // ====================================

        IWbemRefreshingServices* pRefServ = NULL;

        // Storage for security settings we will need in order to propagate
        // down to our internal interfaces.

        COAUTHINFO  CoAuthInfo;

        // Make sure this is totally empty
        ZeroMemory( &CoAuthInfo, sizeof(CoAuthInfo) );

        hres = m_pObject->GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );

        if ( FAILED( hres ) )
        {
            return hres;
        }
        
        // This guarantees this will be freed when we drop out of scope.  If we store
        // it we will need to allocate an internal copy.

        CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

        // Forward this request
        // ====================

        CRefreshInfo Info;
        DWORD       dwRemoteRefrVersion = 0;

        hres = pRefServ->AddObjectToRefresher(&m_pObject->m_Id, wszPath, lFlags,
                    pContext, WBEM_REFRESHER_VERSION, &Info, &dwRemoteRefrVersion);
        if(FAILED(hres)) 
        {
            pRefServ->Release();
            return hres;
        }

        // Act on the information
        // ======================

        switch(Info.m_lType)
        {
            case WBEM_REFRESH_TYPE_CLIENT_LOADABLE:
                hres = m_pObject->AddClientLoadable(Info.m_Info.m_ClientLoadable, 
                            pNamespace, pContext, ppRefreshable, plId);
                break;

            case WBEM_REFRESH_TYPE_DIRECT:
                hres = m_pObject->AddDirect(Info.m_Info.m_Direct, 
                            pNamespace, pContext, ppRefreshable, plId);
                break;

            case WBEM_REFRESH_TYPE_REMOTE:

                if ( SUCCEEDED( hres ) )
                {
                    hres = m_pObject->AddRemote( pRefServ, Info.m_Info.m_Remote, wszPath,
                            Info.m_lCancelId, ppRefreshable, plId, &CoAuthInfo);
                }

                break;

            case WBEM_REFRESH_TYPE_NON_HIPERF:
                hres = m_pObject->AddNonHiPerf(Info.m_Info.m_NonHiPerf, 
                            pNamespace, wszPath, ppRefreshable, plId, &CoAuthInfo);
                break;


            default:
                hres = WBEM_E_INVALID_OPERATION;
        }

        pRefServ->Release();
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}

STDMETHODIMP CUniversalRefresher::XCreate::AddObjectByTemplate(
    IWbemServices* pNamespace, 
    IWbemClassObject* pTemplate,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == pTemplate || NULL == ppRefreshable || 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Check that this is an instance object
    if ( ! ((CWbemObject*)pTemplate)->IsInstance() )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CVar vPath;
    ((CWbemObject*)pTemplate)->GetRelPath(&vPath);
    return AddObjectByPath(pNamespace, vPath.GetLPWSTR(), lFlags, pContext,
                            ppRefreshable, plId);
}

STDMETHODIMP CUniversalRefresher::XCreate::AddRefresher(
                    IWbemRefresher* pRefresher, long lFlags, long* plId)
{

    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pRefresher || 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        hres = m_pObject->AddRefresher( pRefresher, lFlags, plId );
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;

}

STDMETHODIMP CUniversalRefresher::XCreate::Remove(long lId, long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid flag values
    if ( ( lFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        hres = m_pObject->Remove(lId, lFlags);
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}

HRESULT CUniversalRefresher::XCreate::AddEnum( IWbemServices* pNamespace, LPCWSTR wszClassName,
                                               long lFlags, 
                                               IWbemContext* pContext, 
                                               IWbemHiPerfEnum** ppEnum,
                                               long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == wszClassName || NULL == ppEnum || NULL == *wszClassName )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Validate flags
    if ( ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {

		// Create a parser if we need one
		if ( NULL == m_pObject->m_pParser )
		{
			hres = CoCreateInstance( CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER, IID_IWbemPath, (void**) &m_pObject->m_pParser );

			if ( FAILED( hres ) )
			{
				return hres;
			}
		}

		// Set the path, and verify that it is a class path.  If not, we
		// fail the operation.

		hres = m_pObject->m_pParser->SetText( WBEMPATH_CREATE_ACCEPT_ALL, wszClassName );

		if ( SUCCEEDED( hres ) )
		{
			ULONGLONG	uResponse = 0L;

			hres = m_pObject->m_pParser->GetInfo(0, &uResponse);

			if ( SUCCEEDED( hres ) && ( uResponse & WBEMPATH_INFO_IS_CLASS_REF ) == 0 )
			{
				hres = WBEM_E_INVALID_OPERATION;
			}

		}

		// reset the parser here
		m_pObject->m_pParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, NULL);

		if ( FAILED( hres ) )
		{
			return hres;
		}

        // Acquire internal connection to WINMGMT
        // ====================================

        IWbemRefreshingServices* pRefServ = NULL;

        // Storage for security settings we will need in order to propagate
        // down to our internal interfaces.

        COAUTHINFO  CoAuthInfo;

        // Make sure this is totally empty
        ZeroMemory( &CoAuthInfo, sizeof(CoAuthInfo) );

        hres = m_pObject->GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );

        if ( FAILED( hres ) )
        {
            return hres;
        }
        
        // This guarantees this will be freed when we drop out of scope
        CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

        // Forward this request
        // ====================

        CRefreshInfo Info;
        DWORD       dwRemoteRefrVersion = 0;

        hres = pRefServ->AddEnumToRefresher(&m_pObject->m_Id, 
                                            wszClassName, lFlags,
                                            pContext, WBEM_REFRESHER_VERSION, &Info, &dwRemoteRefrVersion);
        if(FAILED(hres)) 
        {
            pRefServ->Release();
            return hres;
        }

        // Act on the information
        // ======================

        switch(Info.m_lType)
        {
            case WBEM_REFRESH_TYPE_CLIENT_LOADABLE:
                hres = m_pObject->AddClientLoadableEnum(Info.m_Info.m_ClientLoadable, 
                                                        pNamespace, wszClassName, pContext, 
                                                        ppEnum, plId);
                break;

            case WBEM_REFRESH_TYPE_DIRECT:
                hres = m_pObject->AddDirectEnum(Info.m_Info.m_Direct, 
                            pNamespace, wszClassName, pContext,
                            ppEnum, plId);
                break;

            case WBEM_REFRESH_TYPE_REMOTE:

                if ( SUCCEEDED( hres ) )
                {
                    hres = m_pObject->AddRemoteEnum( pRefServ, Info.m_Info.m_Remote, wszClassName,
                                Info.m_lCancelId, pContext, ppEnum, 
                                plId, &CoAuthInfo );
                }

                break;

            case WBEM_REFRESH_TYPE_NON_HIPERF:
                hres = m_pObject->AddNonHiPerfEnum(Info.m_Info.m_NonHiPerf, 
                            pNamespace, wszClassName, pContext,
                            ppEnum, plId, &CoAuthInfo);
                break;

			default:
				hres = WBEM_E_INVALID_OPERATION;
				break;
        }

        pRefServ->Release();
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}

//*****************************************************************************
//*****************************************************************************
//                              XREFRESHER
//*****************************************************************************
//*****************************************************************************
STDMETHODIMP CUniversalRefresher::XRefresher::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid flag values
    if ( ( lFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        hres = m_pObject->Refresh(lFlags);
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}


//*****************************************************************************
//*****************************************************************************
//                          UNIVERSAL REFRESHER
//*****************************************************************************
//*****************************************************************************

CUniversalRefresher::~CUniversalRefresher()
{
	// Release the path parser if we are holding onto one
	if ( NULL != m_pParser )
	{
		m_pParser->Release();
	}

    // When we are destructed, we need to make sure that any remote refreshers
    // that may still be trying to reconnect on separate threads are silenced

    for ( long lCtr = 0; lCtr < m_apRemote.GetSize(); lCtr++ )
    {
        CRemote* pRemote = m_apRemote.GetAt( lCtr );

        if ( NULL != pRemote )
        {
            pRemote->Quit();
        }
    }   // FOR enum refreshers
}

CClientLoadableProviderCache CUniversalRefresher::mstatic_Cache;
long CUniversalRefresher::mstatic_lLastId = 0;
long CUniversalRefresher::GetNewId()
{
    return InterlockedIncrement(&mstatic_lLastId);
}

void* CUniversalRefresher::GetInterface(REFIID riid)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRefresher)
        return &m_XRefresher;
    else if(riid == IID_IWbemConfigureRefresher)
        return &m_XCreate;
    else
        return NULL;
}

HRESULT CUniversalRefresher::GetRefreshingServices( IWbemServices* pNamespace,
                IWbemRefreshingServices** ppRefSvc,
                COAUTHINFO* pCoAuthInfo )
{
    // Acquire internal connection to WINMGMT
    // ====================================

    HRESULT hres = pNamespace->QueryInterface(IID_IWbemRefreshingServices, 
                                    (void**) ppRefSvc);

    if ( SUCCEEDED( hres ) )
    {
        // We will query the namespace for its security settings so we can propagate
        // those settings onto our own internal interfaces.

        hres = CoQueryProxyBlanket( pNamespace, &pCoAuthInfo->dwAuthnSvc, &pCoAuthInfo->dwAuthzSvc,
                &pCoAuthInfo->pwszServerPrincName, &pCoAuthInfo->dwAuthnLevel,
                &pCoAuthInfo->dwImpersonationLevel, (RPC_AUTH_IDENTITY_HANDLE*) &pCoAuthInfo->pAuthIdentityData,
                &pCoAuthInfo->dwCapabilities );

        if ( SUCCEEDED( hres ) )
        {
            hres = WbemSetProxyBlanket( *ppRefSvc, pCoAuthInfo->dwAuthnSvc, pCoAuthInfo->dwAuthzSvc,
                COLE_DEFAULT_PRINCIPAL, pCoAuthInfo->dwAuthnLevel,
                pCoAuthInfo->dwImpersonationLevel, pCoAuthInfo->pAuthIdentityData,
                pCoAuthInfo->dwCapabilities );
        }
        else if ( E_NOINTERFACE == hres )
        {
            // If we are in-proc to WMI, then CoQueryProxyBlanket can fail, but this
            // is not really an error, per se, so we will fake it.
            hres = WBEM_S_NO_ERROR;
        }

        if ( FAILED( hres ) )
        {
            (*ppRefSvc)->Release();
            *ppRefSvc = NULL;
        }

    }   // IF QI

    return hres;
}

HRESULT CUniversalRefresher::AddInProcObject(
                                CHiPerfProviderRecord* pProvider,
                                IWbemObjectAccess* pTemplate,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a provider record with this provider pointer
    // =====================================================

    CDirect* pFoundRec = NULL;
    for(int i = 0; i < m_apDirect.GetSize(); i++)
    {
        CDirect* pDirectRec = m_apDirect[i];
        if(pDirectRec->GetProvider() == pProvider)
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        IWbemRefresher* pRefresher;

        try
        {
            hres = pProvider->m_pProvider->CreateRefresher(pNamespace, 0, &pRefresher);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres))
        {
            return hres;
        }
    
        pFoundRec = new CDirect(pProvider, pRefresher);
        m_apDirect.Add(pFoundRec);
        pRefresher->Release();
    }

    // Add request in provider
    // =======================

    IWbemObjectAccess* pProviderObject;
    long lProviderId;

    // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
    // IWbemRefreshingServices::AddObjectToRefresher will return a localized
    // instance definition.  Since localized stuff should all be in the class
    // definition, the provider doesn't really "need" toknow  that we're sneaking
    // this in.  To protect our object, we'll clone it BEFORE we pass it to
    // the provider.  The instance that is returned by the provider BETTER be of
    // the same class type we are, however.

    CWbemInstance*  pClientInstance = NULL;

    hres = pTemplate->Clone( (IWbemClassObject**) &pClientInstance );

    if ( FAILED( hres ) )
    {
        return hres;
    }

    try
    {
        hres = pProvider->m_pProvider->CreateRefreshableObject(pNamespace, pTemplate, 
                pFoundRec->GetRefresher(), 0, pContext, &pProviderObject, 
                &lProviderId);
    }
    catch(...)
    {
        // Provider threw an exception, so get out of here ASAP
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(FAILED(hres))
    {
        pClientInstance->Release();
        return hres;
    }

    // Now copy the provider returned instance data.
    hres = pClientInstance->CopyBlobOf( (CWbemInstance*) pProviderObject );

    if ( SUCCEEDED( hres ) )
    {
        hres = pFoundRec->AddRequest((CWbemObject*)pProviderObject, pClientInstance, lProviderId,
                            ppRefreshable, plId);
    }

    pProviderObject->Release();
    pClientInstance->Release();

    return hres;
}

HRESULT CUniversalRefresher::AddInProcEnum(
                                CHiPerfProviderRecord* pProvider,
                                IWbemObjectAccess* pTemplate,
                                IWbemServices* pNamespace, LPCWSTR wszClassName,
                                IWbemContext * pCtx,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a provider record with this provider pointer
    // =====================================================

    CDirect* pFoundRec = NULL;
    for(int i = 0; i < m_apDirect.GetSize(); i++)
    {
        CDirect* pDirectRec = m_apDirect[i];
        if(pDirectRec->GetProvider() == pProvider)
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        IWbemRefresher* pRefresher;

        try
        {
            hres = pProvider->m_pProvider->CreateRefresher(pNamespace, 0, &pRefresher);
        }
        catch(...)
        {
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres))
        {
            return hres;
        }
    
        pFoundRec = new CDirect(pProvider, pRefresher);
        m_apDirect.Add(pFoundRec);
        pRefresher->Release();
    }

    // Add request in provider
    // =======================

    CClientLoadableHiPerfEnum*  pHPEnum = new CClientLoadableHiPerfEnum( m_pControl );

    if ( NULL != pHPEnum )
    {
        pHPEnum->AddRef();

        // Auto-release this guy when we're done
        CReleaseMe  rmEnum( pHPEnum );

        long lProviderId;

        // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
        // IWbemRefreshingServices::AddEnumToRefresher will return a localized
        // instance definition.  Since localized stuff should all be in the class
        // definition, the provider doesn't really "need" toknow  that we're sneaking
        // this in.


        hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) pTemplate );

        if ( FAILED( hres ) )
        {
            return hres;
        }

        try
        {
            hres = pProvider->m_pProvider->CreateRefreshableEnum(pNamespace, (LPWSTR) wszClassName, 
                    pFoundRec->GetRefresher(), 0, pCtx, (IWbemHiPerfEnum*) pHPEnum, 
                    &lProviderId );
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres))
        {
            return hres;
        }
    

        hres = pFoundRec->AddEnumRequest( pHPEnum, lProviderId,
                                ppEnum, plId, m_pControl );
    }

    return hres;
}

HRESULT CUniversalRefresher::AddClientLoadable(
                                const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_wszNamespace, pNamespace,pContext, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcObject( pProvider, Info.m_pTemplate, pNamespace, pContext, ppRefreshable, plId );

    pProvider->Release();
    return hres;

}
    
HRESULT CUniversalRefresher::AddClientLoadableEnum(
                                const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace, LPCWSTR wszClassName,
                                IWbemContext * pCtx,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_wszNamespace, pNamespace, pCtx, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcEnum( pProvider, Info.m_pTemplate, pNamespace, wszClassName, pCtx, ppEnum, plId );

    pProvider->Release();
    return hres;

}

HRESULT CUniversalRefresher::AddDirect(
                                const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

	IWbemHiPerfProvider*	pProv = NULL;
	_IWmiProviderStack*		pProvStack = NULL;

	HRESULT	hres = Info.m_pRefrMgr->LoadProvider( pNamespace, Info.m_pDirectNames->m_wszProviderName, Info.m_pDirectNames->m_wszNamespace, NULL, &pProv, &pProvStack );
	CReleaseMe	rmTest( pProv );
	CReleaseMe	rmProvStack( pProvStack );

	if ( SUCCEEDED( hres ) )
	{
		CHiPerfProviderRecord* pProvider = NULL;
		hres = GetProviderCache()->FindProvider(Info.m_clsid, pProv, pProvStack, Info.m_pDirectNames->m_wszNamespace, &pProvider);
		if(FAILED(hres) || pProvider == NULL) return hres;

		// Now use the helper function to do the rest of the work
		hres = AddInProcObject( pProvider, Info.m_pTemplate, pNamespace, pContext, ppRefreshable, plId );

		pProvider->Release();
	}

    return hres;
}
    
HRESULT CUniversalRefresher::AddDirectEnum(
                                const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace, LPCWSTR wszClassName, IWbemContext * pContext,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

	IWbemHiPerfProvider*	pProv = NULL;
	_IWmiProviderStack*		pProvStack = NULL;

	HRESULT	hres = Info.m_pRefrMgr->LoadProvider( pNamespace, Info.m_pDirectNames->m_wszProviderName, Info.m_pDirectNames->m_wszNamespace, pContext, &pProv, &pProvStack );
	CReleaseMe	rmTest( pProv );
	CReleaseMe	rmProvStack( pProvStack );

	if ( SUCCEEDED( hres ) )
	{
		CHiPerfProviderRecord* pProvider = NULL;
		hres = GetProviderCache()->FindProvider(Info.m_clsid, pProv, pProvStack, Info.m_pDirectNames->m_wszNamespace, &pProvider);
		if(FAILED(hres) || pProvider == NULL) return hres;

		// Now use the helper function to do the rest of the work
		hres = AddInProcEnum( pProvider, Info.m_pTemplate, pNamespace, wszClassName, pContext, ppEnum, plId );

		pProvider->Release();

	}
    return hres;
}

HRESULT CUniversalRefresher::AddNonHiPerf(	const WBEM_REFRESH_INFO_NON_HIPERF& Info,
											IWbemServices* pNamespace, LPCWSTR pwszPath,
											IWbemClassObject** ppRefreshable, long* plId,
											COAUTHINFO* pCoAuthInfo )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a Non Hi-Perf Record for this namespace
    // =====================================================

    CNonHiPerf* pFoundRec = NULL;
    for(int i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        CNonHiPerf* pDirectRec = m_apNonHiPerf[i];
        if( wbem_wcsicmp( pDirectRec->GetNamespace(), Info.m_wszNamespace ) == 0 )
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        IWbemServices*	pSvcEx = NULL;

		// QI the interface
		hres = pNamespace->QueryInterface( IID_IWbemServices, (void**) &pSvcEx );
		CReleaseMe	rmSvcEx( pSvcEx );

		if ( SUCCEEDED( hres ) )
		{
			// Secure it here
			WbemSetProxyBlanket( pSvcEx, pCoAuthInfo->dwAuthnSvc, pCoAuthInfo->dwAuthzSvc,
							COLE_DEFAULT_PRINCIPAL, pCoAuthInfo->dwAuthnLevel, pCoAuthInfo->dwImpersonationLevel,
							(RPC_AUTH_IDENTITY_HANDLE) pCoAuthInfo->pAuthIdentityData, pCoAuthInfo->dwCapabilities );

			try
			{
				pFoundRec = new CNonHiPerf( Info.m_wszNamespace, pSvcEx );

				if ( NULL != pFoundRec )
				{
					m_apNonHiPerf.Add(pFoundRec);
				}
			}
			catch( CX_MemoryException )
			{
				hres = WBEM_E_OUT_OF_MEMORY;
			}
			catch(...)
			{
				hres = WBEM_E_CRITICAL_ERROR;
			}

		}	// IF QI

    }	// IF not found

	if ( FAILED( hres ) )
	{
		return hres;
	}

    // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
    // IWbemRefreshingServices::AddObjectToRefresher will return a localized
    // instance definition.  Since localized stuff should all be in the class
    // definition, the provider doesn't really "need" toknow  that we're sneaking
    // this in.  To protect our object, we'll clone it BEFORE we pass it to
    // the provider.  The instance that is returned by the provider BETTER be of
    // the same class type we are, however.

    CWbemInstance*  pClientInstance = NULL;

    hres = Info.m_pTemplate->Clone( (IWbemClassObject**) &pClientInstance );

    if ( SUCCEEDED( hres ) )
    {
        hres = pFoundRec->AddRequest((CWbemObject*)Info.m_pTemplate, pClientInstance, pwszPath, ppRefreshable, plId);
    }

    pClientInstance->Release();

    return hres;
}

HRESULT CUniversalRefresher::AddNonHiPerfEnum(	const WBEM_REFRESH_INFO_NON_HIPERF& Info,
												IWbemServices* pNamespace, LPCWSTR wszClassName,
												IWbemContext * pContext,
												IWbemHiPerfEnum** ppEnum, long* plId,
												COAUTHINFO* pCoAuthInfo )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a Non Hi-Perf Record for this namespace
    // =====================================================

    CNonHiPerf* pFoundRec = NULL;
    for(int i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        CNonHiPerf* pDirectRec = m_apNonHiPerf[i];
        if( wbem_wcsicmp( pDirectRec->GetNamespace(), Info.m_wszNamespace ) == 0 )
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        IWbemServices*	pSvcEx = NULL;

		// QI the interface
		hres = pNamespace->QueryInterface( IID_IWbemServices, (void**) &pSvcEx );
		CReleaseMe	rmSvcEx( pSvcEx );

		if ( SUCCEEDED( hres ) )
		{
			// Secure it here
			WbemSetProxyBlanket( pSvcEx, pCoAuthInfo->dwAuthnSvc, pCoAuthInfo->dwAuthzSvc,
							COLE_DEFAULT_PRINCIPAL, pCoAuthInfo->dwAuthnLevel, pCoAuthInfo->dwImpersonationLevel,
							(RPC_AUTH_IDENTITY_HANDLE) pCoAuthInfo->pAuthIdentityData, pCoAuthInfo->dwCapabilities );

			try
			{
				pFoundRec = new CNonHiPerf( Info.m_wszNamespace, pSvcEx );

				if ( NULL != pFoundRec )
				{
					m_apNonHiPerf.Add(pFoundRec);
				}
			}
			catch( CX_MemoryException )
			{
				hres = WBEM_E_OUT_OF_MEMORY;
			}
			catch(...)
			{
				hres = WBEM_E_CRITICAL_ERROR;
			}

		}	// IF QI

    }	// IF not found

	if ( FAILED( hres ) )
	{
		return hres;
	}

    // Add request in provider
    // =======================

    CClientLoadableHiPerfEnum*  pHPEnum = new CClientLoadableHiPerfEnum( m_pControl );

    if ( NULL != pHPEnum )
    {
        pHPEnum->AddRef();

        // Auto-release this guy when we're done
        CReleaseMe  rmEnum( pHPEnum );

        long lProviderId;

        // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
        // IWbemRefreshingServices::AddEnumToRefresher will return a localized
        // instance definition.  Since localized stuff should all be in the class
        // definition, the provider doesn't really "need" toknow  that we're sneaking
        // this in.


        hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) Info.m_pTemplate );

        if ( FAILED( hres ) )
        {
            return hres;
        }

        hres = pFoundRec->AddEnumRequest( pHPEnum, wszClassName, ppEnum, plId, m_pControl );
    }

    return hres;
}

HRESULT CUniversalRefresher::FindRemoteEntry(   const WBEM_REFRESH_INFO_REMOTE& Info,
                                                COAUTHINFO* pAuthInfo,
                                                CRemote** ppRemoteRecord )
{

    // We will identify remote enumerations by server and namespace
    CVar    varNameSpace;

    HRESULT hr = ((CWbemObject*) Info.m_pTemplate)->GetServerAndNamespace( &varNameSpace );

    if ( FAILED( hr ) )
    {
        return hr;
    }
    else if ( NULL == varNameSpace.GetLPWSTR() )
    {
        // This shouldn't happen, but protect against it
        return WBEM_E_FAILED;
    }

    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;
    for(int i = 0; i < m_apRemote.GetSize(); i++)
    {
        CRemote* pRec = m_apRemote[i];

        // Original code:
        //         if(pRec->GetRemoteRefresher() == Info.m_pRefresher)
        if ( wbem_wcsicmp( varNameSpace.GetLPWSTR(), pRec->GetNamespace() ) == 0 )
        {
            pFoundRec = pRec;
            if ( NULL != pFoundRec )
            {
                pFoundRec->AddRef();
            }

            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        // Watch for errors, and do appropriate cleanup
        try
        {
            // Get the server info from the object.  If this returns a NULL, it just
            // means that we will be unable to reconnect

            CVar    varServer;

            hr = ((CWbemObject*) Info.m_pTemplate)->GetServer( &varServer );

            if ( SUCCEEDED( hr ) )
            {
                pFoundRec = new CRemote(Info.m_pRefresher, pAuthInfo, &Info.m_guid,
                                        varNameSpace.GetLPWSTR(), varServer.GetLPWSTR(), this );

                // Set the scurity appropriately
                hr = pFoundRec->ApplySecurity();

                if ( SUCCEEDED( hr ) )
                {
                    m_apRemote.Add(pFoundRec);
                }
            }

        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        if ( FAILED( hr ) )
        {
            // Release the pointer as we no longer need it
            if ( NULL != pFoundRec )
            {
                pFoundRec->Release();
                pFoundRec = NULL;
            }
        }

    }   // IF NULL == pFoundRec

    *ppRemoteRecord = pFoundRec;

    return hr;
}
        
HRESULT CUniversalRefresher::AddRemote( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
                                LPCWSTR pwcsRequestName, long lCancelId, IWbemClassObject** ppRefreshable,
                                long* plId, COAUTHINFO* pAuthInfo )
{
    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;

    HRESULT hr = FindRemoteEntry( Info, pAuthInfo, &pFoundRec );

    if ( SUCCEEDED( hr ) )
    {

        if ( !pFoundRec->IsConnected() )
        {
            hr = pFoundRec->Rebuild( pRefServ, Info.m_pRefresher, &Info.m_guid );
        }

        if ( SUCCEEDED( hr ) )
        {
            // Add a request to it
            // ===================

            IWbemObjectAccess* pAccess = Info.m_pTemplate;
            CWbemObject* pObj = (CWbemObject*)pAccess;

            hr =  pFoundRec->AddRequest(pObj, pwcsRequestName, lCancelId, ppRefreshable, plId);

        }

        // Release the record
        pFoundRec->Release();
    }

    return hr;
}

HRESULT CUniversalRefresher::AddRemoteEnum( IWbemRefreshingServices* pRefServ,
                                        const WBEM_REFRESH_INFO_REMOTE& Info, LPCWSTR pwcsRequestName,
                                        long lCancelId, IWbemContext * pContext,
                                        IWbemHiPerfEnum** ppEnum, long* plId, COAUTHINFO* pAuthInfo )

{
    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;

    HRESULT hr = FindRemoteEntry( Info, pAuthInfo, &pFoundRec );

    if ( SUCCEEDED( hr ) )
    {
        if ( !pFoundRec->IsConnected() )
        {
            hr = pFoundRec->Rebuild( pRefServ, Info.m_pRefresher, &Info.m_guid );
        }

        if ( SUCCEEDED( hr ) )
        {
            // Add a request to it
            // ===================

            IWbemObjectAccess* pAccess = Info.m_pTemplate;
            CWbemObject* pObj = (CWbemObject*)pAccess;

            hr =  pFoundRec->AddEnumRequest(pObj, pwcsRequestName, lCancelId, ppEnum, plId, m_pControl );

        }

        // Release the record
        pFoundRec->Release();
    }

    return hr;
}

HRESULT CUniversalRefresher::AddRefresher( IWbemRefresher* pRefresher, long lFlags, long* plId )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pRefresher && 0L == lFlags )
    {
        CNestedRefresher*   pNested = new CNestedRefresher( pRefresher );

        if ( NULL != pNested )
        {
            if ( NULL != plId )
            {
                *plId = pNested->GetId();
            }
            m_apNestedRefreshers.Add( pNested );
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

HRESULT CUniversalRefresher::Remove(long lId, long lFlags)
{
    HRESULT hres;

    // Search through them all
    // =======================

    int i;
    for(i = 0; i < m_apRemote.GetSize(); i++)
    {
        hres = m_apRemote[i]->Remove(lId, lFlags, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }

    for(i = 0; i < m_apDirect.GetSize(); i++)
    {
        hres = m_apDirect[i]->Remove(lId, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }
    
    for(i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        hres = m_apNonHiPerf[i]->Remove(lId, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }
    
    // Check for a nested refresher
    for ( i = 0; i < m_apNestedRefreshers.GetSize(); i++ )
    {
        if ( m_apNestedRefreshers[i]->GetId() == lId )
        {
            CNestedRefresher*   pNested = m_apNestedRefreshers[i];
            // This will delete the pointer
            m_apNestedRefreshers.RemoveAt( i );
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CUniversalRefresher::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    BOOL    fPartialSuccess = FALSE;

    // Search through them all
    // =======================

    // Keep track of how many different refresh calls we actually make.
    int i;
    HRESULT hrFirstRefresh = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRefresh = FALSE;

    for(i = 0; i < m_apRemote.GetSize(); i++)
    {
        hres = m_apRemote[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }

    for(i = 0; i < m_apDirect.GetSize(); i++)
    {
        hres = m_apDirect[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }
    }

	// Refresh Non-HiPerf Requests
    for(i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        hres = m_apNonHiPerf[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }

    // Refresh nested refreshers too
    for ( i = 0; i < m_apNestedRefreshers.GetSize(); i++ )
    {
        hres = m_apNestedRefreshers[i]->Refresh( lFlags );

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }
    }

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hres = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hres = hrFirstRefresh;
    }

    return hres;
}

void CUniversalRefresher::Flush()
{
    GetProviderCache()->Flush();
}



//*****************************************************************************
//*****************************************************************************
//                            CLIENT REQUEST
//*****************************************************************************
//*****************************************************************************


CUniversalRefresher::CClientRequest::CClientRequest(CWbemObject* pTemplate)
    : m_pClientObject(NULL), m_lClientId(0)
{
    if(pTemplate)
    {
        pTemplate->AddRef();
        m_pClientObject = (CWbemObject*)pTemplate;
    }

    m_lClientId = CUniversalRefresher::GetNewId();
}

CUniversalRefresher::CClientRequest::~CClientRequest()
{
    if(m_pClientObject)
        m_pClientObject->Release();
}

void CUniversalRefresher::CClientRequest::SetClientObject(
                                            CWbemObject* pClientObject)
{
    if(m_pClientObject)
        m_pClientObject->Release();
    m_pClientObject = pClientObject;
    if(m_pClientObject)
        m_pClientObject->AddRef();
}
void CUniversalRefresher::CClientRequest::GetClientInfo(
                       RELEASE_ME IWbemClassObject** ppRefreshable, long* plId)
{
    *ppRefreshable = m_pClientObject;
    if(m_pClientObject)
        m_pClientObject->AddRef();

    if ( NULL != plId )
    {
        *plId = m_lClientId;
    }
}

//*****************************************************************************
//*****************************************************************************
//                            DIRECT PROVIDER
//*****************************************************************************
//*****************************************************************************


CUniversalRefresher::CDirect::CDirect(CHiPerfProviderRecord* pProvider,
                                        IWbemRefresher* pRefresher)
    : m_pRefresher(pRefresher), m_pProvider(pProvider)
{
    if(m_pRefresher)
        m_pRefresher->AddRef();
    if(m_pProvider)
        m_pProvider->AddRef();
}

CUniversalRefresher::CDirect::~CDirect()
{
    if(m_pRefresher)
        m_pRefresher->Release();
    if(m_pProvider)
        m_pProvider->Release();
}

HRESULT CUniversalRefresher::CDirect::AddRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientInstance,
                         long lCancelId, IWbemClassObject** ppRefreshable, long* plId)
{
    CRequest* pRequest = NULL;

    try
    {
        pRequest = new CRequest(pRefreshedObject, pClientInstance, lCancelId);
        m_apRequests.Add(pRequest);
        pRequest->GetClientInfo(ppRefreshable, plId);
    }
    catch(...)
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CDirect::AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum,
                        long lCancelId, IWbemHiPerfEnum** ppEnum, long* plId, CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CEnumRequest* pEnumRequest = NULL;

    try
    {
        // We get away with this through inheritance and polymorphism
        pEnumRequest = new CEnumRequest(pHPEnum, lCancelId, pLifeControl);
        m_apRequests.Add((CRequest*) pEnumRequest);
        hr = pEnumRequest->GetClientInfo(ppEnum, plId);
    }
    catch(...)
    {
        if ( NULL != pEnumRequest )
        {
            delete pEnumRequest;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
    
HRESULT CUniversalRefresher::CDirect::Refresh(long lFlags)
{
    HRESULT hres;
    if(m_pRefresher)
    {
        try
        {
            hres = m_pRefresher->Refresh(0L);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres)) return hres;
    }

    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        m_apRequests[i]->Copy();
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CDirect::Remove(long lId, 
                            CUniversalRefresher* pContainer)
{
    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        CRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}
    

CUniversalRefresher::CDirect::CRequest::CRequest( CWbemObject* pProviderObject,
                                                CWbemObject* pClientInstance,
                                                long lProviderId )
    : CClientRequest(pClientInstance), m_pProviderObject(pProviderObject),
        m_lProviderId(lProviderId)
{
    if(m_pProviderObject)
        m_pProviderObject->AddRef();
}

HRESULT CUniversalRefresher::CDirect::CRequest::Cancel(
        CUniversalRefresher::CDirect* pDirect)
{
    if(pDirect->GetProvider())
    {
        try
        {
            return pDirect->GetProvider()->m_pProvider->StopRefreshing(pDirect->GetRefresher(),
                m_lProviderId, 0);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            return WBEM_E_PROVIDER_FAILURE;
        }

    }
    else return WBEM_S_NO_ERROR;
}
    
CUniversalRefresher::CDirect::CRequest::~CRequest()
{
    if(m_pProviderObject)
        m_pProviderObject->Release();
}
    

void CUniversalRefresher::CDirect::CRequest::Copy()
{
    m_pClientObject->CopyBlobOf(m_pProviderObject);
}
    

CUniversalRefresher::CDirect::CEnumRequest::CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, 
                                                long lProviderId, CLifeControl* pLifeControl )
    : CRequest( NULL, NULL, lProviderId ), m_pHPEnum(pHPEnum)
{
    if( m_pHPEnum )
        m_pHPEnum->AddRef();

    // We'll need an enumerator for the client to retrieve objects
    m_pClientEnum = new CReadOnlyHiPerfEnum( pLifeControl );

    if ( NULL != m_pClientEnum )
    {
        // Set the instance template.  Without this, there is no point
        CWbemInstance* pInst = pHPEnum->GetInstanceTemplate();

        if ( NULL != pInst )
        {
            // Don't hold onto the enumerator unless the template is
            // properly set.

            if ( SUCCEEDED(m_pClientEnum->SetInstanceTemplate( pInst ) ) )
            {
                m_pClientEnum->AddRef();
            }
            else
            {
                // Cleanup
                delete m_pClientEnum;
                m_pClientEnum = NULL;
            }

            // GetInstanceTemplate AddRefs
            pInst->Release();

        }
        else
        {
            delete m_pClientEnum;
            m_pClientEnum = NULL;
        }

    }
}

CUniversalRefresher::CDirect::CEnumRequest::~CEnumRequest()
{
    if(m_pHPEnum)
        m_pHPEnum->Release();

    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Release();
    }
}
    

void CUniversalRefresher::CDirect::CEnumRequest::Copy()
{
    // Tell the refresher enumerator to copy its objects from
    // the HiPerf Enumerator
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Copy( m_pHPEnum );
    }

}
    
HRESULT CUniversalRefresher::CDirect::CEnumRequest::GetClientInfo(  RELEASE_ME IWbemHiPerfEnum** ppEnum, 
                                                                long* plId)
{
    // We best have enumerators to hook up here
    if ( NULL != m_pClientEnum )
    {
        // Store the client id, then do a QI

        if ( NULL != plId )
        {
            *plId = m_lClientId;
        }

        return m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum );
    }
    else
    {
        return WBEM_E_FAILED;
    }
}

//*****************************************************************************
//*****************************************************************************
//                          NON HI PERF
//*****************************************************************************
//*****************************************************************************

CUniversalRefresher::CNonHiPerf::CNonHiPerf( LPCWSTR pwszNamespace, IWbemServices* pSvcEx )
    : m_wsNamespace(pwszNamespace), m_pSvcEx(pSvcEx)
{
    if(m_pSvcEx)
        m_pSvcEx->AddRef();
}

CUniversalRefresher::CNonHiPerf::~CNonHiPerf()
{
    if(m_pSvcEx)
        m_pSvcEx->Release();
}

HRESULT CUniversalRefresher::CNonHiPerf::AddRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientInstance,
                         LPCWSTR pwszPath, IWbemClassObject** ppRefreshable, long* plId)
{
    CRequest* pRequest = NULL;

    try
    {
        pRequest = new CRequest(pRefreshedObject, pClientInstance, pwszPath);
        m_apRequests.Add(pRequest);
        pRequest->GetClientInfo(ppRefreshable, plId);
    }
    catch(...)
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CNonHiPerf::AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, LPCWSTR pwszClassName, 
														IWbemHiPerfEnum** ppEnum, long* plId, CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CEnumRequest* pEnumRequest = NULL;

    try
    {
        // We get away with this through inheritance and polymorphism
        pEnumRequest = new CEnumRequest(pHPEnum, pwszClassName, pLifeControl);
        m_apRequests.Add((CRequest*) pEnumRequest);
        hr = pEnumRequest->GetClientInfo(ppEnum, plId);
    }
    catch(...)
    {
        if ( NULL != pEnumRequest )
        {
            delete pEnumRequest;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
    
HRESULT CUniversalRefresher::CNonHiPerf::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

	// Tell each request to refresh itself (we have to do this manually)
	if ( NULL != m_pSvcEx )
	{
		int nSize = m_apRequests.GetSize();
		for(int i = 0; i < nSize; i++)
		{
			hres = m_apRequests[i]->Refresh( this );
		}
	}

	return hres;

}


HRESULT CUniversalRefresher::CNonHiPerf::Remove(long lId, CUniversalRefresher* pContainer)
{
    int nSize = m_apRequests.GetSize();
    
    for(int i = 0; i < nSize; i++)
    {
        CRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;

}

// Requests
CUniversalRefresher::CNonHiPerf::CRequest::CRequest( CWbemObject* pProviderObject, CWbemObject* pClientInstance, LPCWSTR pwszPath )
    : CClientRequest(pClientInstance), m_pProviderObject( pProviderObject ), m_strPath( NULL )
{
	if ( NULL != m_pProviderObject )
	{
		m_pProviderObject->AddRef();
	}

	if ( NULL != pwszPath )
	{
		m_strPath = SysAllocString( pwszPath );

		if ( NULL == m_strPath )
		{
			throw CX_MemoryException();
		}
	}
}

HRESULT CUniversalRefresher::CNonHiPerf::CRequest::Cancel(
        CUniversalRefresher::CNonHiPerf* pNonHiPerf)
{
	return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CNonHiPerf::CRequest::Refresh(
			CUniversalRefresher::CNonHiPerf* pNonHiPerf)
{
	IWbemClassObject*	pObj = NULL;

	// Get the object and update the BLOB
	HRESULT	hr = pNonHiPerf->GetServices()->GetObject( m_strPath, 0L, NULL, &pObj, NULL );
	CReleaseMe	rmObj( pObj );

	if ( SUCCEEDED( hr ) )
	{
		_IWmiObject*	pWmiObject = NULL;

		hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );
		CReleaseMe	rmWmiObj( pWmiObject );

		if ( SUCCEEDED( hr ) )
		{
			hr = m_pClientObject->CopyInstanceData( 0L, pWmiObject );
		}
	}

	return hr;
}

CUniversalRefresher::CNonHiPerf::CRequest::~CRequest()
{
	if ( NULL != m_pProviderObject )
	{
		m_pProviderObject->Release();
	}

	if ( NULL != m_strPath )
	{
		SysFreeString( m_strPath );
	}
}
    

void CUniversalRefresher::CNonHiPerf::CRequest::Copy()
{
    m_pClientObject->CopyBlobOf(m_pProviderObject);
}
    

CUniversalRefresher::CNonHiPerf::CEnumRequest::CEnumRequest( CClientLoadableHiPerfEnum* pHPEnum, 
                                                LPCWSTR pwszClassName, CLifeControl* pLifeControl )
    : CRequest( NULL, NULL, pwszClassName ), m_pHPEnum(pHPEnum)
{
    if( m_pHPEnum )
        m_pHPEnum->AddRef();

    // We'll need an enumerator for the client to retrieve objects
    m_pClientEnum = new CReadOnlyHiPerfEnum( pLifeControl );

    if ( NULL != m_pClientEnum )
    {
        // Set the instance template.  Without this, there is no point
        CWbemInstance* pInst = pHPEnum->GetInstanceTemplate();

        if ( NULL != pInst )
        {
            // Don't hold onto the enumerator unless the template is
            // properly set.

            if ( SUCCEEDED(m_pClientEnum->SetInstanceTemplate( pInst ) ) )
            {
                m_pClientEnum->AddRef();
            }
            else
            {
                // Cleanup
                delete m_pClientEnum;
                m_pClientEnum = NULL;
            }

            // GetInstanceTemplate AddRefs
            pInst->Release();

        }
        else
        {
            delete m_pClientEnum;
            m_pClientEnum = NULL;
        }

    }
}

CUniversalRefresher::CNonHiPerf::CEnumRequest::~CEnumRequest()
{
    if(m_pHPEnum)
        m_pHPEnum->Release();

    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Release();
    }

}
    

HRESULT CUniversalRefresher::CNonHiPerf::CEnumRequest::Refresh(
			CUniversalRefresher::CNonHiPerf* pNonHiPerf)
{
	IEnumWbemClassObject*	pEnum = NULL;

	// Do a semi-sync enumeration.  We can later consider doing this Async...
	HRESULT	hr = pNonHiPerf->GetServices()->CreateInstanceEnum( m_strPath,
																WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
																NULL,
																&pEnum );
	CReleaseMe	rmEnum( pEnum );

	if ( SUCCEEDED( hr ) )
	{
		IWbemClassObject*	apObj[100];
		long				alIds[100];
		long				lId = 0;
		BOOL				fFirst = TRUE;

		while ( WBEM_S_NO_ERROR == hr )
		{
			ULONG	uReturned = 0;

			hr = pEnum->Next( 1000, 100, apObj, &uReturned );

			if ( SUCCEEDED( hr ) && uReturned > 0 )
			{
				IWbemObjectAccess*	apObjAccess[100];

				// Need to conjure up some ids quick
				for ( int x = 0; SUCCEEDED( hr ) && x < uReturned; x++ )
				{
					alIds[x] = lId++;
					hr = apObj[x]->QueryInterface( IID_IWbemObjectAccess, (void**) &apObjAccess[x] );
				}

				if ( SUCCEEDED( hr ) )
				{
					// Replace the contents of the enum
					hr = m_pClientEnum->Replace( fFirst, uReturned, alIds, apObjAccess );

					for ( ULONG uCtr = 0; uCtr < uReturned; uCtr++ )
					{
						apObj[uCtr]->Release();
						apObjAccess[uCtr]->Release();
					}

				}

				// Don't need to remove all if this is the first
				fFirst = FALSE;

			}	// IF SUCCEEDED and num returned objects > 0
			else if ( WBEM_S_TIMEDOUT == hr )
			{
				hr = WBEM_S_NO_ERROR;
			}

		}	// WHILE getting objects
		
	}	// IF CreateInstanceEnum

	return WBEM_S_NO_ERROR;
}

void CUniversalRefresher::CNonHiPerf::CEnumRequest::Copy()
{
    // Tell the refresher enumerator to copy its objects from
    // the HiPerf Enumerator
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Copy( m_pHPEnum );
    }

}
    
HRESULT CUniversalRefresher::CNonHiPerf::CEnumRequest::GetClientInfo(  RELEASE_ME IWbemHiPerfEnum** ppEnum, 
                                                                long* plId)
{
    // We best have enumerators to hook up here
    if ( NULL != m_pClientEnum )
    {
        // Store the client id, then do a QI

        if ( NULL != plId )
        {
            *plId = m_lClientId;
        }

        return m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum );
    }
    else
    {
        return WBEM_E_FAILED;
    }
}

//*****************************************************************************
//*****************************************************************************
//                          REMOTE PROVIDER
//*****************************************************************************
//*****************************************************************************

                    

CUniversalRefresher::CRemote::CRemote(IWbemRemoteRefresher* pRemRefresher, COAUTHINFO* pCoAuthInfo, const GUID* pGuid,
                                      LPCWSTR pwszNamespace, LPCWSTR pwszServer, CUniversalRefresher* pObject )
: m_pRemRefresher(pRemRefresher), m_bstrNamespace( NULL ), m_fConnected( TRUE ), m_pObject( pObject ),
m_bstrServer( NULL ), m_lRefCount( 1 ), m_pReconnectedRemote( NULL ), m_pReconnectSrv( NULL ), m_fQuit( FALSE )
{
    // Initialize the GUID data members
    ZeroMemory( &m_ReconnectGuid, sizeof(GUID));
    m_RemoteGuid = *pGuid;

    if(m_pRemRefresher)
        m_pRemRefresher->AddRef();

    m_CoAuthInfo = *pCoAuthInfo;

#if 1
	m_CoAuthInfo.pwszServerPrincName = NULL ;
#else
    if ( NULL != pCoAuthInfo->pwszServerPrincName )
    {
        // This will throw an exception if it fails
        m_CoAuthInfo.pwszServerPrincName = new WCHAR[wcslen(pCoAuthInfo->pwszServerPrincName)+1];
        wcscpy( m_CoAuthInfo.pwszServerPrincName, pCoAuthInfo->pwszServerPrincName );
    }
#endif

    // Store reconnection data
    if ( NULL != pwszNamespace )
    {
        m_bstrNamespace = SysAllocString( pwszNamespace );
    }

    if ( NULL != pwszServer )
    {
        m_bstrServer = SysAllocString( pwszServer );
    }

}
    
CUniversalRefresher::CRemote::~CRemote()
{
    ClearRemoteConnections();

    if ( NULL != m_CoAuthInfo.pwszServerPrincName )
    {
        delete [] m_CoAuthInfo.pwszServerPrincName;
    }

    if ( NULL != m_bstrNamespace )
    {
        SysFreeString( m_bstrNamespace );
    }

    if ( NULL != m_bstrServer )
    {
        SysFreeString( m_bstrServer );
    }

}

ULONG STDMETHODCALLTYPE CUniversalRefresher::CRemote::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CUniversalRefresher::CRemote::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
        delete this;
    return lRef;
}

// Applies appropriate security settings to the proxy
HRESULT CUniversalRefresher::CRemote::ApplySecurity( void )
{
    return WbemSetProxyBlanket( m_pRemRefresher, m_CoAuthInfo.dwAuthnSvc, m_CoAuthInfo.dwAuthzSvc,
                COLE_DEFAULT_PRINCIPAL, m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData, m_CoAuthInfo.dwCapabilities );
}

void CUniversalRefresher::CRemote::CheckConnectionError( HRESULT hr, BOOL fStartReconnect )
{
    if ( IsConnectionError( hr ) && fStartReconnect )
    {
        // Release and NULL out the remote refresher pointer.  The Remote GUID member
        // will tell us if a reconnect got us back to the same stub on the server

        // DEVNOTE:TODO - Looks like COM has a problem with these, so let the release happen
        // when we try to Rebuild the connection.
//      m_pRemRefresher->Release();
//      m_pRemRefresher = NULL;

        // We should change the m_fConnected data member to indicate that we are no
        // longer connected, and we need to spin off a thread to try and put us back
        // together again.  To keep things running smoothly, we should AddRef() ourselves
        // so the thread will release us when it is done.

        m_fConnected = FALSE;

        // AddRefs us so we can be passed off to the thread
        AddRef();

        DWORD   dwThreadId = NULL;
        HANDLE  hThread = (HANDLE) _beginthreadex( NULL, 0, CRemote::ThreadProc, (void*) this,
                                0, (unsigned int *) &dwThreadId );

        // If no thread was spawned, then there is no need for us to maintain the AddRef() from
        // above.

        if ( NULL != hThread )
        {
            CloseHandle( hThread );
        }
        else
        {
            Release();
        }

    }   // If connection error and start reconnect thread

}

HRESULT CUniversalRefresher::CRemote::AddRequest(
                    CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId, 
                    IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CRequest* pRequest = NULL;

    try
    {
        pRequest = new CRequest(pTemplate, lCancelId, pwcsRequestName);
        m_apRequests.Add(pRequest);
        pRequest->GetClientInfo(ppRefreshable, plId);
    }
    catch( ... )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }

        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CUniversalRefresher::CRemote::AddEnumRequest(
                    CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId, 
                    IWbemHiPerfEnum** ppEnum, long* plId, CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CEnumRequest* pRequest = NULL;

    try
    {
        // Make sure the request allocates an enumerator internally

        pRequest = new CEnumRequest( pTemplate, lCancelId, pwcsRequestName, pLifeControl );

        if ( pRequest->IsOk() )
        {
            //  All we need for the client is the id, so
            //  dummy up a holder for the refreshable object
            //  ( which is really the template for the objects
            //  we will be returning from the enumerator.

            IWbemClassObject*   pObjTemp = NULL;

            m_apRequests.Add((CRequest*) pRequest);
            pRequest->GetClientInfo( &pObjTemp, plId );

            if ( NULL != pObjTemp )
            {
                pObjTemp->Release();
            }

            // Get the enumerator
            hr = pRequest->GetEnum( ppEnum );

        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    catch( ... )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }

        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;

}

// Rebuilds a remote refresher
HRESULT CUniversalRefresher::CRemote::Rebuild( IWbemServices* pNamespace )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Storage for security settings we will need in order to propagate
    // down to our internal interfaces.

    COAUTHINFO                  CoAuthInfo;

    // Acquire internal connection to WINMGMT
    // ====================================

    IWbemRefreshingServices* pRefServ = NULL;

    hr = m_pObject->GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );
    CReleaseMe  rmrs(pRefServ);

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    // This guarantees this will be freed when we drop out of scope.  If we store
    // it we will need to allocate an internal copy.

    CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

    IWbemRemoteRefresher*   pRemRefresher = NULL;

    // Make sure a remote refresher exists for "this" refresher
    GUID    remoteGuid;
    DWORD   dwRemoteRefrVersion = 0;

    hr = pRefServ->GetRemoteRefresher( m_pObject->GetId(), 0L, WBEM_REFRESHER_VERSION, 
                        &pRemRefresher, &remoteGuid, &dwRemoteRefrVersion );
    CReleaseMe  rm(pRemRefresher);

    if ( FAILED( hr ) )
    {
        return hr;
    }
    else
    {
        // Will enter and exit the critical section with scoping
        CInCritSec  ics( &m_cs );

        // Check that we're still not connected
        if ( !m_fConnected )
        {
            // Because the original object mayhave been instantiated in an STA, we will let the Refresh
            // call do the dirty work of actually hooking up this bad boy.  In order for this
            // to work, however, 
            hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemRemoteRefresher, pRemRefresher, &m_pReconnectedRemote );

            if ( SUCCEEDED( hr ) )
            {
                hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemRefreshingServices, pRefServ, &m_pReconnectSrv );

                if ( SUCCEEDED( hr ) )
                {
                    // Store the GUID so the refresh will be able to determine the identity
                    // of the remote refresher.

                    m_ReconnectGuid = remoteGuid;
                }
                else
                {
                    IWbemRemoteRefresher*   pTemp = NULL;

                    // Cleanup the data here
                    CoGetInterfaceAndReleaseStream( m_pReconnectedRemote, IID_IWbemRemoteRefresher,
                                            (void**) &pTemp );
                    CReleaseMe  rmTemp( pTemp );

                    // NULL out the old pointer
                    m_pReconnectedRemote = NULL;
                }
            }

        }   // IF !m_fConnected

    }

    return hr;

}

HRESULT CUniversalRefresher::CRemote::Rebuild( IWbemRefreshingServices* pRefServ,
                                                IWbemRemoteRefresher* pRemRefresher,
                                                const GUID* pReconnectGuid )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Will enter and exit the critical section with scoping
    CInCritSec  ics( &m_cs );

    // Right off, check if we ARE connected, in which case we can assume we had
    // a race condition on this function, and the winner got us all hooked back
    // up again.

    if ( m_fConnected )
    {
        return hr;
    }

    // If these two are equal, we can assume that we reconnected without losing our previous connection.
    // If they are not equal, we will then need to rebuild the remote refresher, however, by calling
    // GetRemoteRefresher() successfully we will have effectively ensured that a remote refresher exists
    // for us up on the server.

    if ( *pReconnectGuid != m_RemoteGuid )
    {

        // We will need these memory buffers to hold individual request data
        WBEM_RECONNECT_INFO*    apReconnectInfo = NULL;
        WBEM_RECONNECT_RESULTS* apReconnectResults = NULL;

        // Only alloc and fill out arrays if we have requests
        if ( m_apRequests.GetSize() > 0 )
        {
            try
            {
                apReconnectInfo = new WBEM_RECONNECT_INFO[m_apRequests.GetSize()];
                apReconnectResults = new WBEM_RECONNECT_RESULTS[m_apRequests.GetSize()];
            }
            catch( ... )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            // Don't need to reset anything if nothing to reset

            if ( m_apRequests.GetSize() > 0 )
            {

                // Enumerate the requests and fill out the arrays
                for ( int i = 0; i < m_apRequests.GetSize(); i++ )
                {
                    CRequest*   pRequest = m_apRequests.GetAt( i );

                    // Setup each info structure
                    apReconnectInfo[i].m_lType = ( pRequest->IsEnum() ? WBEM_RECONNECT_TYPE_ENUM :
                                                    WBEM_RECONNECT_TYPE_OBJECT );
                    apReconnectInfo[i].m_pwcsPath = pRequest->GetName();

                    apReconnectResults[i].m_lId = pRequest->GetRemoteId();
                    apReconnectResults[i].m_hr = 0;

                }   // FOR enum requests

                DWORD   dwRemoteRefrVersion = 0;
                hr = pRefServ->ReconnectRemoteRefresher( m_pObject->GetId(), 0L, m_apRequests.GetSize(),
                                                        WBEM_REFRESHER_VERSION, apReconnectInfo,
                                                        apReconnectResults, &dwRemoteRefrVersion );
            }

            // Rehook up the object and enumids
            if ( WBEM_S_NO_ERROR == hr )
            {

                // Cleanup the old pointer
                if ( NULL != m_pRemRefresher )
                {
                    m_pRemRefresher->Release();
                    m_pRemRefresher = NULL;
                }

                // Store the new one and setup the security
                m_pRemRefresher = pRemRefresher;
                hr = ApplySecurity();

                if ( SUCCEEDED( hr ) )
                {
                    m_pRemRefresher->AddRef();

                    // Redo the ones that succeeded.  Clear the rest
                    for( int i = 0; i < m_apRequests.GetSize(); i++ )
                    {
                        CRequest*   pRequest = m_apRequests.GetAt( i );

                        if ( SUCCEEDED( apReconnectResults[i].m_hr ) )
                        {
                            pRequest->SetRemoteId( apReconnectResults[i].m_lId );
                        }
                        else
                        {
                            // This means it didn't get hooked up again.  So if the
                            // user tries to remove him, we will just ignore this
                            // id.
                            pRequest->SetRemoteId( INVALID_REMOTE_REFRESHER_ID );
                        }
                    }
                }
                else
                {
                    // Setting security failed, so just set the pointer to NULL (we haven't
                    // AddRef'd it ).
                    m_pRemRefresher = NULL;
                }

            }   // IF WBEM_S_NO_ERROR == hr

        }   // IF SUCCEEDED(hr)

        // Check that we're good to go
        if ( SUCCEEDED( hr ) )
        {
            // Clear the removed ids array since a new connection was established, hence the
            // old ids are a moot point.
            m_alRemovedIds.Empty();
            m_fConnected = TRUE;
        }


        // Cleanup the memory buffers
        if ( NULL != apReconnectInfo )
        {
            delete [] apReconnectInfo;
        }

        if ( NULL != apReconnectResults )
        {
            delete [] apReconnectResults;
        }


    }   // IF remote refreshers not the same
    else
    {
        // The remote refresher pointers match, so assume that all our old ids are still
        // valid.

        // The refresher we were handed will be automatically released.

        m_fConnected = TRUE;

        // Cleanup the old pointer
        if ( NULL != m_pRemRefresher )
        {
            m_pRemRefresher->Release();
            m_pRemRefresher = NULL;
        }

        // Store the new one and setup the security
        m_pRemRefresher = pRemRefresher;
        hr = ApplySecurity();

        if ( SUCCEEDED( hr ) )
        {
            m_pRemRefresher->AddRef();
        }
        else
        {
            // Setting security failed, so just set the pointer to NULL (we haven't
            // AddRef'd it ).
            m_pRemRefresher = NULL;
        }

        // Delete cached ids if we have any.
        if ( ( SUCCEEDED ( hr ) ) && m_alRemovedIds.Size() > 0 )
        {
            // We will need these memory buffers to hold individual request data
            long*       aplIds = NULL;

            try
            {
                aplIds = new long[m_alRemovedIds.Size()];
            }
            catch( ... )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            if ( SUCCEEDED( hr ) )
            {
                // Enumerate the requests and fill out the arrays
                for ( int i = 0; i < m_alRemovedIds.Size(); i++ )
                {
                    // DEVNOTE:WIN64:SANJ - The id's are 32-bit, but on 64-bit platforms,
                    // the flex array will contain 64-bit values, so use PtrToLong
                    // to get a warning free conversion.  On 32-bit platforms,
                    // PtrToLong will do nothing.

                    aplIds[i] = PtrToLong(m_alRemovedIds.GetAt( i ));

                }   // FOR enum requests

                // DEVNOTE:TODO:SANJ - Do we care about this return code?
                hr = m_pRemRefresher->StopRefreshing( i-1, aplIds, 0 );

                // Clear the array
                m_alRemovedIds.Empty();
            }

            if ( NULL != aplIds )
            {
                delete [] aplIds;
            }

        }   // If RemoveId list is not empty

    }   // We got the remote refresher

    return hr;

}

// This is a temporary helper function which helps us determine if a remote machine
// is actually alive, since COM/RPC seem to have problems with hanging if I constantly
// hammer at CoCreateInstanceEx() when the remote machine is down
HRESULT CUniversalRefresher::CRemote::IsAlive( void )
{
    HRESULT hr = RPC_E_DISCONNECTED;

    HKEY    hRemoteKey = NULL;
    long    lError = RegConnectRegistryW( m_bstrServer, HKEY_LOCAL_MACHINE, &hRemoteKey );

    // If we get a success or an access denied, then we will go ahead
    // and assume that the machine is up.
    if ( ERROR_SUCCESS == lError || ERROR_ACCESS_DENIED == lError )
    {
        hr = WBEM_S_NO_ERROR;
    }

    if ( NULL != hRemoteKey )
    {
        RegCloseKey( hRemoteKey );
    }

    return hr;

}

unsigned CUniversalRefresher::CRemote::ReconnectEntry( void ) 
{
    HRESULT hr = RPC_E_DISCONNECTED;

    // This guy ALWAYS runs in the MTA
    InitializeCom();

    // Basically as long as we can't connect, somebody else doesn't connect us, or we are told
    // to quit, we will run this thread.

    while ( FAILED(hr) && !m_fConnected && !m_fQuit )
    {
        IWbemLocator*   pWbemLocator = NULL;

        // Because COM and RPC seem to have this problem with actually being able to themselves
        // reconnect, we're performing our own low level "ping" of the remote machine, using RegConnectRegistry
        // to verify if the machine is indeed alive.  If it is, then and only then will be deign to use
        // DCOM to follow through the operation.

        hr = IsAlive();

        if ( SUCCEEDED( hr ) )
        {
            // Make sure we have a namespace to connect to
            if ( NULL != m_bstrNamespace )
            {

                hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator, (void**) &pWbemLocator );

                if ( SUCCEEDED( hr ) )
                {

                    IWbemServices*  pNamespace = NULL;

                    // We're gonna default to the system
                    hr = pWbemLocator->ConnectServer(   m_bstrNamespace,    // NameSpace Name
                                                        NULL,           // UserName
                                                        NULL,           // Password
                                                        NULL,           // Locale
                                                        0L,             // Security Flags
                                                        NULL,           // Authority
                                                        NULL,           // Wbem Context
                                                        &pNamespace     // Namespace
                                                        );

                    if ( SUCCEEDED( hr ) )
                    {

                        // Apply security settings to the namespace
                        hr = WbemSetProxyBlanket( pNamespace, m_CoAuthInfo.dwAuthnSvc,
                                    m_CoAuthInfo.dwAuthzSvc, COLE_DEFAULT_PRINCIPAL,
                                    m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                                    (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                                    m_CoAuthInfo.dwCapabilities );

                        if ( SUCCEEDED( hr ) )
                        {

                            hr = Rebuild( pNamespace );
                        }

                        pNamespace->Release();

                    }   // IF ConnectServer
            
                    pWbemLocator->Release();

                }   // IF Created Locator

            }   // IF NULL != m_bstrNamespace

        }   // IF IsAlive()

        // Sleep for a second and retry
        Sleep( 1000 );
    }

    // Release the AddRef() on the object from when the thread was created
    Release();

    CoUninitialize();

    return 0;
}

void CUniversalRefresher::CRemote::ClearRemoteConnections( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemRemoteRefresher*       pRemRefresher = NULL;
    IWbemRefreshingServices*    pRefServ = NULL;

    // Cleanup the IWbemRefreshingServices stream pointer
    if ( NULL != m_pReconnectSrv )
    {
        hr = CoGetInterfaceAndReleaseStream( m_pReconnectSrv, IID_IWbemRefreshingServices, (void**) &pRefServ );
        // This will autorelease
        CReleaseMe  rmrs( pRefServ );

        if ( SUCCEEDED( hr ) )
        {
            // We need to reset security on the Refreshing services proxy.

            hr = WbemSetProxyBlanket( pRefServ, m_CoAuthInfo.dwAuthnSvc,
                        m_CoAuthInfo.dwAuthzSvc, COLE_DEFAULT_PRINCIPAL,
                        m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                        m_CoAuthInfo.dwCapabilities );
        }

        m_pReconnectSrv = NULL;
    }

    // Cleanup the IWbemRemoteRefresher stream pointer
    if ( NULL != m_pReconnectedRemote )
    {
        hr = CoGetInterfaceAndReleaseStream( m_pReconnectedRemote, IID_IWbemRemoteRefresher,
                (void**) &pRemRefresher );
        CReleaseMe  rmrr( pRemRefresher );

        if ( SUCCEEDED( hr ) )
        {
            // We need to reset security on the proxy.

            hr = WbemSetProxyBlanket( pRemRefresher, m_CoAuthInfo.dwAuthnSvc,
                        m_CoAuthInfo.dwAuthzSvc, COLE_DEFAULT_PRINCIPAL,
                        m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                        m_CoAuthInfo.dwCapabilities );
        }

        // Make sure we release the stream
        m_pReconnectedRemote = NULL;
    }

    // Cleanup the IWbemRemoteRefresher pointer
    if ( NULL != m_pRemRefresher )
    {
        m_pRemRefresher->Release();
        m_pRemRefresher = NULL;
    }
}

HRESULT CUniversalRefresher::CRemote::Reconnect( void )
{
    HRESULT hr = RPC_E_DISCONNECTED;

    IWbemRemoteRefresher*       pRemRefresher = NULL;
    IWbemRefreshingServices*    pRefServ = NULL;

    CInCritSec  ics( &m_cs );

    // We will need to unmarshale both the RefreshingServices and the RemoteRefresher pointers,
    // so make sure that the streams we will need to unmarshal these from already exist.

    if ( NULL != m_pReconnectSrv && NULL != m_pReconnectedRemote )
    {
        hr = CoGetInterfaceAndReleaseStream( m_pReconnectSrv, IID_IWbemRefreshingServices, (void**) &pRefServ );
        CReleaseMe  rmrs( pRefServ );

        if ( SUCCEEDED( hr ) )
        {
            // We need to reset security on the Refreshing services proxy.

            hr = WbemSetProxyBlanket( pRefServ, m_CoAuthInfo.dwAuthnSvc,
                        m_CoAuthInfo.dwAuthzSvc, COLE_DEFAULT_PRINCIPAL,
                        m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                        m_CoAuthInfo.dwCapabilities );

            if ( SUCCEEDED( hr ) )
            {
                hr = CoGetInterfaceAndReleaseStream( m_pReconnectedRemote, IID_IWbemRemoteRefresher,
                        (void**) &pRemRefresher );
                CReleaseMe  rmrr( pRemRefresher );

                if ( SUCCEEDED( hr ) )
                {
                    // Remote refresher and refreshing services
                    hr = Rebuild( pRefServ, pRemRefresher, &m_ReconnectGuid );
                }
                else
                {
                    // Make sure we release the stream
                    m_pReconnectedRemote->Release();
                }
            }
            else
            {
                // Make sure we release the stream
                m_pReconnectedRemote->Release();
            }

        }   // IF unmarshaled refreshing services pointer
        else
        {
            m_pReconnectSrv->Release();
            m_pReconnectedRemote->Release();
        }

        // NULL out both stream pointers
        m_pReconnectSrv = NULL;
        m_pReconnectedRemote = NULL;

    }

    return hr;
}

HRESULT CUniversalRefresher::CRemote::Refresh(long lFlags)
{
    if(m_pRemRefresher == NULL  && IsConnected())
        return WBEM_E_CRITICAL_ERROR;

    WBEM_REFRESHED_OBJECT* aRefreshed = NULL;
    long lNumObjects = 0;

    HRESULT hresRefresh = WBEM_S_NO_ERROR;

    // Make sure we're connected.  If not, and we haven't been told not to, try to reconnect
    if ( !IsConnected() )
    {
        if ( ! (lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
        {
            hresRefresh = Reconnect();
            if ( FAILED( hresRefresh ) )
            {
                return hresRefresh;
            }
        }
        else
        {
            return RPC_E_DISCONNECTED;
        }
    }

    hresRefresh = m_pRemRefresher->RemoteRefresh(0, &lNumObjects, &aRefreshed);

    // If RemoteRefresh returns a connection type error, Set oiur state to "NOT" connected
    if(FAILED(hresRefresh))
    {
        // This will kick off a thread to reconnect if the error return was
        // a connection error, and the appropriate "Don't do this" flag is not set
        CheckConnectionError( hresRefresh, !(lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) );
        return hresRefresh;
    }

    int nSize = m_apRequests.GetSize();
    HRESULT hresFinal = WBEM_S_NO_ERROR;

    //  DEVNOTE:TODO:SANJ - We could make this much faster if we did some sorting on the
    //  server end

    for(int i = 0; i < lNumObjects; i++)
    {

        long lObjectId = aRefreshed[i].m_lRequestId;
        for(int j = 0; j < nSize; j++)
        {
            CRequest* pRequest = m_apRequests[j];
            if(pRequest->GetRemoteId() == lObjectId)
            {
                // The request will refresh itself
                HRESULT hres = pRequest->Refresh( &aRefreshed[i] );

                // Only copy this value if the refresh failed and we haven't already
                // gotten the value
                if(FAILED(hres) && SUCCEEDED(hresFinal))
                {
                    hresFinal = hres;
                }
                break;
            }
        }

        CoTaskMemFree(aRefreshed[i].m_pbBlob);
    }

    // Free the wrapping BLOB
    CoTaskMemFree( aRefreshed );

    // The final return code should give precedence to the actual remote refresh call if it
    // doesn't contain a NO_ERROR, and hresFinal is NOT an error

    if ( SUCCEEDED( hresFinal ) )
    {
        if ( WBEM_S_NO_ERROR != hresRefresh )
        {
            hresFinal = hresRefresh;
        }
    }

    return hresFinal;
}

HRESULT CUniversalRefresher::CRemote::Remove(long lId,
                            long lFlags,
                            CUniversalRefresher* pContainer)
{
    HRESULT hr = WBEM_S_FALSE;

    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        CRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            if ( IsConnected() )
            {
                // Check that the remote id doesn't indicate an item that
                // failed to be reconstructed.

                if ( pRequest->GetRemoteId() == INVALID_REMOTE_REFRESHER_ID )
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = pRequest->Cancel(this);
                }

                if ( FAILED(hr) && IsConnectionError(hr) )
                {
                    // This will kick off a reconnect thread unless we were told not to
                    CheckConnectionError( hr, !(lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) );

                    // We will remove the request from here, but
                    // queue up the id for later deletion
                    hr = WBEM_S_NO_ERROR;
                }
            }

            // DEVNOTE:TODO:SANJ - What about other errors?  For now, we'll lose the local
            // connection.

            if ( SUCCEEDED( hr ) )
            {
                // Retrieves the remote id from the request
                long    lRemoteId = pRequest->GetRemoteId();

                m_apRequests.RemoveAt(i);

                // If we couldn't remove the id remotely, just queue it up in the
                // removed id array so we can clean it up properly if we get
                // reconnected. We will, of course, not need to do anything if the
                // remote id indicates a failed readd during reconnection 

                if ( lRemoteId != INVALID_REMOTE_REFRESHER_ID && !IsConnected() )
                {
                    CInCritSec  ics(&m_cs);

                    // Note that we may have gotten connected on the critical section and
                    // if that is the case, for now, we'll have one extra resource on the
                    // server, but the likelihood of running into contention problems here
                    // is too high.  Plus, if it reconnected via a new remote refresher, if
                    // we retry a remove here, we could remove the "wrong" id.  To protect
                    // against this, we will check that we are still not connected and if
                    // that is not the case, we will just "forget" about the object id.

                    if (!IsConnected())
                    {
                        try
                        {
                            // BUBBUG:WIN64:SANJ - By casting to __int64 and back to void*, in 32-bit,
                            // this truncates the __int64, and in 64-bit, keeps away warningss.
                            m_alRemovedIds.Add( (void*) (__int64) lRemoteId );
                        }
                        catch(...)
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }   // IF Still not connected

                }   // IF Not connected

            }   // IF remote remove ok

            break;

        }   // IF found matching client id

    }   // FOR enum requests

    return hr;
}
            
CUniversalRefresher::CRemote::CRequest::CRequest(CWbemObject* pTemplate, 
                                                 long lRequestId,
                                                 LPCWSTR pwcsRequestName )
    : CClientRequest(pTemplate), m_lRemoteId(lRequestId), m_wstrRequestName( pwcsRequestName )
{
}

HRESULT CUniversalRefresher::CRemote::CRequest::Refresh( WBEM_REFRESHED_OBJECT* pRefrObj )
{
    CWbemInstance* pInst = (CWbemInstance*) GetClientObject();
    return pInst->CopyTransferBlob(
                pRefrObj->m_lBlobType, 
                pRefrObj->m_lBlobLength,
                pRefrObj->m_pbBlob);
                
}

HRESULT CUniversalRefresher::CRemote::CRequest::Cancel(
            CUniversalRefresher::CRemote* pRemote)
{
    if(pRemote->GetRemoteRefresher())
        return pRemote->GetRemoteRefresher()->StopRefreshing( 1, &m_lRemoteId, 0 );
    else
        return WBEM_S_NO_ERROR;
}

CUniversalRefresher::CRemote::CEnumRequest::CEnumRequest(CWbemObject* pTemplate, 
                                                         long lRequestId,
                                                         LPCWSTR pwcsRequestName, 
                                                         CLifeControl* pLifeControl )
    : CRequest(pTemplate, lRequestId, pwcsRequestName), m_pClientEnum(NULL)
{
    m_pClientEnum = new CReadOnlyHiPerfEnum( pLifeControl );

    // AddRef the new enumerator
    if ( NULL != m_pClientEnum )
    {
        // Don't hold onto this guy if we can't set the template
        if ( SUCCEEDED( m_pClientEnum->SetInstanceTemplate( (CWbemInstance*) pTemplate ) ) )
        {
            m_pClientEnum->AddRef();
        }
        else
        {
            // Cleanup
            delete m_pClientEnum;
            m_pClientEnum = NULL;
        }
    }
}

CUniversalRefresher::CRemote::CEnumRequest::~CEnumRequest( void )
{
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Release();
    }
}

HRESULT CUniversalRefresher::CRemote::CEnumRequest::Refresh( WBEM_REFRESHED_OBJECT* pRefrObj )
{
    return m_pClientEnum->Copy( pRefrObj->m_lBlobType,
                                pRefrObj->m_lBlobLength,
                                pRefrObj->m_pbBlob );
}

HRESULT CUniversalRefresher::CRemote::CEnumRequest::GetEnum( IWbemHiPerfEnum** ppEnum )
{
    return ( NULL != m_pClientEnum ?
                m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum ) :
                WBEM_E_FAILED );
}


//*****************************************************************************
//*****************************************************************************
//                          NESTED REFRESHERS
//*****************************************************************************
//*****************************************************************************

                    

CUniversalRefresher::CNestedRefresher::CNestedRefresher( IWbemRefresher* pRefresher )
    : m_pRefresher(pRefresher)
{
    if ( m_pRefresher )
        m_pRefresher->AddRef();

    // Assign a unique id
    m_lClientId = CUniversalRefresher::GetNewId();
}
    
CUniversalRefresher::CNestedRefresher::~CNestedRefresher()
{
    if ( m_pRefresher )
        m_pRefresher->Release();
}

HRESULT CUniversalRefresher::CNestedRefresher::Refresh( long lFlags )
{
    // Make sure we have an internal refresher pointer
    return ( NULL != m_pRefresher ? m_pRefresher->Refresh( lFlags ) : WBEM_E_FAILED );
}

//*****************************************************************************
//*****************************************************************************
//                          PROVIDER CACHE
//*****************************************************************************
//*****************************************************************************

CHiPerfProviderRecord::CHiPerfProviderRecord(REFCLSID rclsid, 
            LPCWSTR wszNamespace, IWbemHiPerfProvider* pProvider, _IWmiProviderStack* pProvStack)
    : m_clsid(rclsid), m_wsNamespace(wszNamespace), m_pProvider(pProvider), m_pProvStack( pProvStack ),
    m_lRef( 0 )
{
    if(m_pProvider)
        m_pProvider->AddRef();

	if ( NULL != m_pProvStack )
	{
		m_pProvStack->AddRef();
	}
}

CHiPerfProviderRecord::~CHiPerfProviderRecord()
{
    if(m_pProvider)
        m_pProvider->Release();

	if ( NULL != m_pProvStack )
	{
		m_pProvStack->Release();
	}

}

long CHiPerfProviderRecord::Release()
{
    long lRef = InterlockedDecrement( &m_lRef );

    // Removing us from the cache will delete us
    if ( 0 == lRef )
    {
        CUniversalRefresher::GetProviderCache()->RemoveRecord( this );
    }

    return lRef;
}

HRESULT CClientLoadableProviderCache::FindProvider(REFCLSID rclsid, 
                LPCWSTR wszNamespace, IUnknown* pNamespace,
                IWbemContext * pContext,
				CHiPerfProviderRecord** ppProvider)
{
    CLock   lock( &m_Lock );

    // Check that we've got something to look into
    if ( NULL == m_papRecords )
    {
        return WBEM_E_FAILED;
    }

    *ppProvider = NULL;
    HRESULT hres;

    for(int i = 0; i < m_papRecords->GetSize(); i++)
    {
        CHiPerfProviderRecord* pRecord = m_papRecords->GetAt( i );
        if(pRecord->m_clsid == rclsid && 
            pRecord->m_wsNamespace.EqualNoCase(wszNamespace))
        {
            *ppProvider = pRecord;
            (*ppProvider)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // Prepare an namespace pointer
    // ============================

    IWbemServices* pServices = NULL;
    hres = pNamespace->QueryInterface(IID_IWbemServices, (void**)&pServices);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pServices);

    // Create 
    // ======

    IUnknown* pUnk = NULL;
    hres = CoCreateInstance(rclsid, NULL, CLSCTX_INPROC_SERVER,
                        IID_IUnknown, (void**)&pUnk);
    CReleaseMe rm2(pUnk);
    if(FAILED(hres))
        return hres;

    // Initialize
    // ==========

    IWbemProviderInit* pInit = NULL;
    hres = pUnk->QueryInterface(IID_IWbemProviderInit, (void**)&pInit);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm3(pInit);

    CProviderInitSink* pSink = new CProviderInitSink;
    pSink->AddRef();
    CReleaseMe rm4(pSink);

    try
    {
        hres = pInit->Initialize(NULL, 0, (LPWSTR)wszNamespace, NULL, 
                                 pServices, pContext, pSink);
    }
    catch(...)
    {
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(FAILED(hres))
        return hres;

    hres = pSink->WaitForCompletion();
    if(FAILED(hres))
        return hres;

    // Ask for the right interface
    // ===========================

    IWbemHiPerfProvider*    pProvider = NULL;

    hres = pUnk->QueryInterface(IID_IWbemHiPerfProvider, (void**)&pProvider);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm5(pProvider);

    // Create a record
    // ===============

	// No provider stack here since we are loading the provider ourselves
    CHiPerfProviderRecord* pRecord = new CHiPerfProviderRecord(rclsid, wszNamespace, pProvider, NULL);
    m_papRecords->Add(pRecord);

    // AddRef the record
    pRecord->AddRef();
    *ppProvider = pRecord;

    return WBEM_S_NO_ERROR;
}

HRESULT CClientLoadableProviderCache::FindProvider(REFCLSID rclsid,
                IWbemHiPerfProvider* pProvider, _IWmiProviderStack* pProvStack,
				LPCWSTR wszNamespace, CHiPerfProviderRecord** ppProvider)
{
    CLock   lock( &m_Lock );

    // Check that we've got something to look into
    if ( NULL == m_papRecords )
    {
        return WBEM_E_FAILED;
    }

    *ppProvider = NULL;

    for(int i = 0; i < m_papRecords->GetSize(); i++)
    {
        CHiPerfProviderRecord* pRecord = m_papRecords->GetAt( i );
        if(pRecord->m_clsid == rclsid && 
            pRecord->m_wsNamespace.EqualNoCase(wszNamespace))
        {
            *ppProvider = pRecord;
            (*ppProvider)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // We already have provider pointer so we can just create a record
    // ===============

    CHiPerfProviderRecord* pRecord = new CHiPerfProviderRecord(rclsid, wszNamespace, pProvider, pProvStack );
    m_papRecords->Add(pRecord);

    // AddRef the record
    pRecord->AddRef();
    *ppProvider = pRecord;

    return WBEM_S_NO_ERROR;
}

void CClientLoadableProviderCache::RemoveRecord( CHiPerfProviderRecord* pRecord )
{
    CLock   lock( &m_Lock );

    // Make sure the record didn't get accessed on another thread.
    // If not, go ahead and look for our record, and remove it
    // from the array.  When we remove it, the record will be
    // deleted.

    if ( pRecord->IsReleased() )
    {

        for(int i = 0; i < m_papRecords->GetSize(); i++)
        {
            if ( pRecord == m_papRecords->GetAt( i ) )
            {
                // This will delete the record
                m_papRecords->RemoveAt( i );
                break;
            }
        }   // FOR search records

    }   // IF record is released

}

void CClientLoadableProviderCache::Flush()
{
    CLock   lock( &m_Lock );
    if ( NULL != m_papRecords )
    {
        m_papRecords->RemoveAll();
    }
}

CClientLoadableProviderCache::~CClientLoadableProviderCache( void )
{
    // This is a static list, so if we're going away and something
    // fails here because people didn't release pointers properly,
    // chances are something will fail, so since we're being dropped
    // from memory, if the provider list is not empty, don't clean
    // it up.  This is really a bad client-created leak anyways.

    if ( NULL != m_papRecords )
    {
        if ( m_papRecords->GetSize() == 0 )
        {
            delete m_papRecords;
			m_papRecords = NULL;
        }
    }

}

CClientLoadableProviderCache::CClientLoadableProviderCache( void )
:   m_papRecords( NULL )
{
    m_Lock.SetData( &m_LockData );

    // We need one of these
    m_papRecords = new CUniquePointerArray<CHiPerfProviderRecord>;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refmghlp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFMGHLP.H

Abstract:

  CWbemFetchRefrMgr Definition.

  Standard definition for _IWbemFetchRefresherMgr.

History:

  07-Sep-2000	sanjes    Created.

--*/

#ifndef _REFMGHLP_H_
#define _REFMGHLP_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include <sync.h>

//***************************************************************************
//
//  class CWbemFetchRefrMgr
//
//  Implementation of _IWbemFetchRefresherMgr Interface
//
//***************************************************************************

class COREPROX_POLARITY CWbemFetchRefrMgr : public CUnk
{
protected:
	static _IWbemRefresherMgr*		s_pRefrMgr;
	static CCritSec					s_cs;
public:
    CWbemFetchRefrMgr(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CWbemFetchRefrMgr(); 

	/* _IWbemFetchRefresherMgr methods */
    HRESULT Get( _IWbemRefresherMgr** ppMgr );
	HRESULT Init( _IWmiProvSS* pProvSS, IWbemServices* pSvc );
	HRESULT Uninit( void );

	// Specifies everything we could possibly want to know about the creation of
	// an object and more.

    class COREPROX_POLARITY XFetchRefrMgr : public CImpl<_IWbemFetchRefresherMgr, CWbemFetchRefrMgr>
    {
    public:
        XFetchRefrMgr(CWbemFetchRefrMgr* pObject) : 
            CImpl<_IWbemFetchRefresherMgr, CWbemFetchRefrMgr>(pObject)
        {}

		STDMETHOD(Get)( _IWbemRefresherMgr** ppMgr );
		STDMETHOD(Init)( _IWmiProvSS* pProvSS, IWbemServices* pSvc );
		STDMETHOD(Uninit)( void );

    } m_XFetchRefrMgr;
    friend XFetchRefrMgr;


protected:
    void* GetInterface(REFIID riid);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcli.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCLI.H

Abstract:

	Refresher Client Side Code.

History:

--*/

#ifndef __UNIVERSAL_REFRESHER__H_
#define __UNIVERSAL_REFRESHER__H_

#include <unk.h>
#include "refrhelp.h"
//#include <wbemcomn.h>

class CHiPerfProviderRecord
{
public:
    long m_lRef;

    CLSID m_clsid;
    WString m_wsNamespace;
    IWbemHiPerfProvider* m_pProvider;

	// If we pull the provider back from the provider subsystem, then we
	// need to AddRef() the provider stack to ensure that the provider stays
	// loaded in the cache.
	_IWmiProviderStack* m_pProvStack;

public:
    CHiPerfProviderRecord(REFCLSID rclsid, LPCWSTR wszNamespace, 
                        IWbemHiPerfProvider* pProvider, _IWmiProviderStack* pProvStack);
    ~CHiPerfProviderRecord();
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release();

	BOOL IsReleased( void ) { return 0 == m_lRef; }

};

class CClientLoadableProviderCache
{
protected:
    CUniquePointerArray<CHiPerfProviderRecord>*	m_papRecords;
	SHARED_LOCK_DATA							m_LockData;
	CSharedLock									m_Lock;

public:
    CClientLoadableProviderCache();
	~CClientLoadableProviderCache();

    HRESULT FindProvider(REFCLSID rclsid, LPCWSTR wszNamespace, 
                         IUnknown* pNamespace,
                         IWbemContext * pContext,
                         CHiPerfProviderRecord** ppProvider);
    HRESULT FindProvider(REFCLSID rclsid, IWbemHiPerfProvider* pProvider,
				_IWmiProviderStack* pProvStack, LPCWSTR wszNamespace,
				CHiPerfProviderRecord** ppProvider);
    void Flush();

	void RemoveRecord( CHiPerfProviderRecord* pRecord );

	class CLock
	{
	public:

		CLock( CSharedLock* pLock ) : m_pLock( pLock ) { if ( NULL != m_pLock ) m_pLock->Lock(); }
		~CLock() { if ( NULL != m_pLock ) m_pLock->Unlock(); }

		CSharedLock*	m_pLock;
	};
};



class CUniversalRefresher : public CUnk
{
protected:
    static CClientLoadableProviderCache mstatic_Cache;

public:
    static CClientLoadableProviderCache* GetProviderCache() 
        {return &mstatic_Cache;}

    class CClientRequest
    {
    protected:
        CWbemObject* m_pClientObject;
        long m_lClientId;
    public:
        CClientRequest(CWbemObject* pTemplate = NULL);
        virtual ~CClientRequest();

        void SetClientObject(CWbemObject* pClientObject);
        void GetClientInfo(RELEASE_ME IWbemClassObject** ppRefresher, 
                            long* plId);

        long GetClientId() {return m_lClientId;}
        INTERNAL CWbemObject* GetClientObject() {return m_pClientObject;}
    };
    
    class CDirect
    {
    public:
        class CRequest : public CClientRequest
        {
        protected:
            long m_lProviderId;
            CWbemObject* m_pProviderObject;
        public:
            CRequest(CWbemObject* pProviderObject, CWbemObject* pClientObject, long lProviderId);
            ~CRequest();
            virtual void Copy();
            HRESULT Cancel(CDirect* pDirect);
        };

		class CEnumRequest : public CRequest
		{
			protected:
				CClientLoadableHiPerfEnum*	m_pHPEnum;
				CReadOnlyHiPerfEnum*		m_pClientEnum;

			public:
				CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, long lProviderId, CLifeControl* pLifeControl);
				~CEnumRequest();

				HRESULT GetClientInfo(RELEASE_ME IWbemHiPerfEnum** ppEnum, 
									long* plId);
				void Copy();
		};

    protected:
        CHiPerfProviderRecord* m_pProvider;
        IWbemRefresher* m_pRefresher;

        CUniquePointerArray<CRequest> m_apRequests;
    public:
        INTERNAL CHiPerfProviderRecord* GetProvider() {return m_pProvider;}
        INTERNAL IWbemRefresher* GetRefresher() {return m_pRefresher;}
    public:
        CDirect(CHiPerfProviderRecord* pProvider, IWbemRefresher* pRefresher);
        ~CDirect();
        HRESULT AddRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientObject,
					long lCancelId, IWbemClassObject** ppRefresher, long* plId);

        HRESULT AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, long lCancelId,
					IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        HRESULT Remove(long lId, CUniversalRefresher* pContainer);
    };
        
    class CRemote
    {
    public:
        class CRequest : public CClientRequest
        {
        protected:
            long		m_lRemoteId;
			WString		m_wstrRequestName;

        public:
            CRequest(CWbemObject* pTemplate, long lRemoteId, LPCWSTR pwcsRequestName);
            ~CRequest(){}

            HRESULT Cancel(CRemote* pDirect);
            long GetRemoteId() {return m_lRemoteId;}
			void SetRemoteId( long lId ) { m_lRemoteId = lId; }
			LPCWSTR GetName( void ) { return m_wstrRequestName; }

			virtual BOOL IsEnum( void ) { return FALSE; }
			virtual HRESULT Refresh( WBEM_REFRESHED_OBJECT* pRefrObj );

        };

		class CEnumRequest : public CRequest
		{
        protected:
            long						m_lRemoteId;
			CReadOnlyHiPerfEnum*		m_pClientEnum;
        public:
            CEnumRequest( CWbemObject* pTemplate, long lRemoteId, LPCWSTR pwcsRequestName,
						CLifeControl* pLifeControl );
            ~CEnumRequest();

			BOOL	IsOk( void ) { return ( NULL != m_pClientEnum ); }
			HRESULT GetEnum( IWbemHiPerfEnum** ppEnum );

			virtual BOOL IsEnum( void ) { return TRUE; }
			// Override for enumerators
			HRESULT Refresh( WBEM_REFRESHED_OBJECT* pRefrObj );

		};
        
    protected:
		// The actual remote refresher
        IWbemRemoteRefresher*	m_pRemRefresher;
		// Remote Refresher GUID
		GUID					m_RemoteGuid;
		// Security Info
		COAUTHINFO				m_CoAuthInfo;
		// Namespace and server for reconnect
		BSTR					m_bstrNamespace;
		// Server for Reconnect workaround
		BSTR					m_bstrServer;
		// Are we connected
		BOOL					m_fConnected;
		// Flag tells us to quit if reconnecting
		BOOL					m_fQuit;
		// Requests
        CUniquePointerArray<CRequest>	m_apRequests;
		// Cache of ids we removed.
		CFlexArray						m_alRemovedIds;
		// Our wrapper object
		CUniversalRefresher*	m_pObject;
		// Internal Critical Section
		CCritSec				m_cs;
		// For marshaling/unmarshaling across apartment-models
		// during the reconnect phase
		IStream*				m_pReconnectedRemote;
		IStream*				m_pReconnectSrv;
		GUID					m_ReconnectGuid;

		long					m_lRefCount;

	protected:

		// Helper workaround for COM/RPC inadequacies.
		HRESULT IsAlive( void );

		static unsigned __stdcall ThreadProc( void * pThis )
		{
			return ((CRemote*) pThis)->ReconnectEntry();
		}

		unsigned ReconnectEntry( void );

		// Cleans up all the remote connections we may be holding onto
		void ClearRemoteConnections( void );

    public:
        CRemote( IWbemRemoteRefresher* pRemRefresher, COAUTHINFO* pACoAuthInfo, const GUID* pGuid,
					LPCWSTR pwszNamespace, LPCWSTR pwszServer, CUniversalRefresher* pObject );
        ~CRemote();

		ULONG STDMETHODCALLTYPE AddRef();
		ULONG STDMETHODCALLTYPE Release(); 

        HRESULT AddRequest(CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId,
                    IWbemClassObject** ppRefresher, long* plId );
        HRESULT AddEnumRequest(CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId,
					IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        HRESULT Remove(long lId, long lFlags, CUniversalRefresher* pContainer);
		HRESULT ApplySecurity( void );

		HRESULT Rebuild( IWbemServices* pNamespace );
		HRESULT Rebuild( IWbemRefreshingServices* pRefServ, IWbemRemoteRefresher* pRemRefresher,
							const GUID* pReconnectGuid );

		HRESULT Reconnect( void );
		BOOL IsConnectionError( HRESULT hr )
		{
			return ( RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr) || RPC_E_DISCONNECTED == hr ||
						RPC_S_CALL_FAILED == HRESULT_CODE(hr) );
		}
		void CheckConnectionError( HRESULT, BOOL fStartReconnect = FALSE );
		BOOL IsConnected( void )
		{
			return m_fConnected;
		}

		LPCWSTR GetNamespace( void )
		{
			return m_bstrNamespace;
		}

		void Quit( void )
		{
			m_fQuit = TRUE;
		}

    public:
        INTERNAL IWbemRemoteRefresher* GetRemoteRefresher() 
            {return m_pRemRefresher;}
    };


    class CNonHiPerf
    {

    public:
        class CRequest : public CClientRequest
        {
        protected:
            CWbemObject* m_pProviderObject;
			BSTR		 m_strPath;
        public:
            CRequest( CWbemObject* m_pProviderObject, CWbemObject* pClientObject, LPCWSTR pwszPath);
            ~CRequest();
            virtual void Copy();
            virtual HRESULT Refresh( CNonHiPerf* pNonHiPerf );
            HRESULT Cancel(CNonHiPerf* pNonHiPerf);
        };

		class CEnumRequest : public CRequest
		{
			protected:
				CClientLoadableHiPerfEnum*	m_pHPEnum;
				CReadOnlyHiPerfEnum*		m_pClientEnum;

			public:
				CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, LPCWSTR pwszClassName, CLifeControl* pLifeControl);
				~CEnumRequest();

				HRESULT GetClientInfo(RELEASE_ME IWbemHiPerfEnum** ppEnum, 
									long* plId);
				void Copy();
	            HRESULT Refresh( CNonHiPerf* pNonHiPerf );
		};

    protected:
		WString				m_wsNamespace;
        IWbemServices*	m_pSvcEx;
        CUniquePointerArray<CRequest> m_apRequests;

    public:
    public:
        CNonHiPerf( LPCWSTR pwszNamespace, IWbemServices* pSvcEx );
        ~CNonHiPerf();

		LPCWSTR GetNamespace( void ) { return m_wsNamespace; }
        IWbemServices* GetServices( void ) { return m_pSvcEx; }

        HRESULT AddRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientObject,
					LPCWSTR pwszPath, IWbemClassObject** ppRefresher, long* plId);

        HRESULT AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, LPCWSTR pwszClassName, IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        //
        HRESULT Remove(long lId, CUniversalRefresher* pContainer);

    };


	class CNestedRefresher
	{
	public:
		CNestedRefresher( IWbemRefresher* pRefresher );
		~CNestedRefresher();

		HRESULT Refresh( long lFlags );
		long GetId( void )
		{ return m_lClientId; }

	private:

		IWbemRefresher*	m_pRefresher;
		long			m_lClientId;
	};

protected:
    CUniquePointerArray<CDirect> m_apDirect;
    CUniquePointerArray<CNonHiPerf> m_apNonHiPerf;
    CRefedPointerArray<CRemote> m_apRemote;
    CUniquePointerArray<CNestedRefresher> m_apNestedRefreshers;
    
    CRefresherId	m_Id;
	CHiPerfLock		m_Lock;

	IWbemPath*		m_pParser;

    static long mstatic_lLastId;
protected:
    class XRefresher : public CImpl<IWbemRefresher, CUniversalRefresher>
    {
    public:
        XRefresher(CUniversalRefresher* pObject) : 
            CImpl<IWbemRefresher, CUniversalRefresher>(pObject)
        {}

        STDMETHOD(Refresh)(long lFlags);
    } m_XRefresher;
    friend XRefresher;

    class XCreate : public CImpl<IWbemConfigureRefresher, CUniversalRefresher>
    {
    public:
        XCreate(CUniversalRefresher* pObject) : 
            CImpl<IWbemConfigureRefresher, CUniversalRefresher>(pObject)
        {}

        STDMETHOD(AddObjectByPath)(IWbemServices* pNamespace, LPCWSTR wszPath,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddObjectByTemplate)(IWbemServices* pNamespace, 
            IWbemClassObject* pTemplate,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddRefresher)(IWbemRefresher* pRefresher, long lFlags,
            long* plId);

        STDMETHOD(Remove)(long lId, long lFlags);

		STDMETHOD(AddEnum)(	IWbemServices*	pNamespace, LPCWSTR wscClassName,
			long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
			long* plId );
							
    } m_XCreate;
    friend XCreate;

protected:
    void* GetInterface(REFIID riid);

	HRESULT AddInProcObject(	CHiPerfProviderRecord* pProvider,
								IWbemObjectAccess* pTemplate,
								IWbemServices* pNamespace,
								IWbemContext * pContext,
								IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddInProcEnum(		CHiPerfProviderRecord* pProvider,
								IWbemObjectAccess* pTemplate,
								IWbemServices* pNamespace, LPCWSTR wszClassName,
								IWbemContext * pContext,
								IWbemHiPerfEnum** ppEnum, long* plId);


    HRESULT AddClientLoadable(const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddClientLoadableEnum(	const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
									IWbemServices* pNamespace, LPCWSTR wszClassName, IWbemContext * pContext,
									IWbemHiPerfEnum** ppEnum, long* plId);

    HRESULT AddDirect(const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddDirectEnum(	const WBEM_REFRESH_INFO_DIRECT& Info,
									IWbemServices* pNamespace, LPCWSTR wszClassName, IWbemContext * pContext,
									IWbemHiPerfEnum** ppEnum, long* plId);

	HRESULT FindRemoteEntry(	const WBEM_REFRESH_INFO_REMOTE& Info,
								COAUTHINFO* pAuthInfo,
								CRemote** ppRemoteRecord );

    HRESULT AddRemote( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
						LPCWSTR pwcsRequestName, long lCancelId, IWbemClassObject** ppRefreshable, long* plId,
						COAUTHINFO* pCoAuthInfo );
    HRESULT AddRemoteEnum ( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
								LPCWSTR pwcsRequestName, long lCancelId, IWbemContext * pContext,
								IWbemHiPerfEnum** ppEnum,
								long* plId, COAUTHINFO* pCoAuthInfo );

    HRESULT AddRefresher( IWbemRefresher* pRefresher, long lFlags, long* plId );

    HRESULT AddNonHiPerf(const WBEM_REFRESH_INFO_NON_HIPERF& Info,
                        IWbemServices* pNamespace, LPCWSTR pwszPath,
                        IWbemClassObject** ppRefreshable, long* plId,
						COAUTHINFO* pCoAuthInfo );
	HRESULT AddNonHiPerfEnum(	const WBEM_REFRESH_INFO_NON_HIPERF& Info,
								IWbemServices* pNamespace, LPCWSTR wszClassName,
								IWbemContext * pContext,
								IWbemHiPerfEnum** ppEnum, long* plId, 
								COAUTHINFO* pCoAuthInfo );


    HRESULT Remove(long lId, long lFlags);
    HRESULT Refresh(long lFlags);

public:
    CUniversalRefresher(CLifeControl* pControl, IUnknown* pOuter = NULL) 
        : CUnk(pControl, pOuter), m_XRefresher(this), m_XCreate(this),
		m_pParser( NULL )
    {}
	~CUniversalRefresher();

	HRESULT	GetRefreshingServices( IWbemServices* pNamespace,
				IWbemRefreshingServices** ppRefSvc,
				COAUTHINFO* pCoAuthInfo );

    HRESULT FindProvider(REFCLSID rclsid, LPCWSTR wszNamespace, 
                IWbemHiPerfProvider** ppProvider);

    INTERNAL CRefresherId* GetId() {return &m_Id;}
    static long GetNewId();
    static void Flush();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcach.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRCACHE.CPP

Abstract:

  CRefresherCache implementation.

  Implements the _IWbemRefresherMgr interface.

History:

  24-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <tchar.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "refrhelp.h"
#include "refrcach.h"
#include "arrtempl.h"
#include "reg.h"

//***************************************************************************
//
//  CRefresherCache::CRefresherCache
//
//***************************************************************************
// ok
CRefresherCache::CRefresherCache( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_pProvSS ( NULL ),
	m_XWbemRefrCache( this ) ,
	m_XWbemShutdown( this )
{
}
    
//***************************************************************************
//
//  CRefresherCache::~CRefresherCache
//
//***************************************************************************
// ok
CRefresherCache::~CRefresherCache()
{
	// Release the provider factory.  Don't worry about the Svc Ex pointer, since this
	// will be aggregating us
	if ( NULL != m_pProvSS )
	{
		m_pProvSS->Release();
	}
}

// Override that returns us an interface
void* CRefresherCache::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWbemRefresherMgr)
        return &m_XWbemRefrCache;
    else if(riid == IID_IWbemShutdown)
        return &m_XWbemShutdown;
    else
        return NULL;
}

// Pass thru _IWbemRefresherMgr implementation
STDMETHODIMP CRefresherCache::XWbemRefrCache::AddObjectToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
																  WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate,
																  long lFlags, IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo )
{
	return m_pObject->AddObjectToRefresher( pNamespace, pwszServerName, pwszNamespace, pClassObject, pDestRefresherId, pInstTemplate, lFlags, pContext, pLockMgr, pInfo );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::AddEnumToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
																WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate,
																LPCWSTR wszClass, long lFlags, IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo )
{
	return m_pObject->AddEnumToRefresher( pNamespace, pwszServerName, pwszNamespace, pClassObject, pDestRefresherId, pInstTemplate, wszClass, lFlags, pContext, pLockMgr, pInfo );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, BOOL fAddRefresher, IWbemRemoteRefresher** ppRemRefresher,
																  IUnknown* pLockMgr, GUID* pGuid )
{
	return m_pObject->GetRemoteRefresher( pRefresherId, lFlags, fAddRefresher, ppRemRefresher, pLockMgr, pGuid );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::Startup(	long lFlags , IWbemContext *pCtx , _IWmiProvSS *pProvSS )
{
	return m_pObject->Startup( lFlags , pCtx, pProvSS );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::LoadProvider( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace,IWbemContext * pContext, IWbemHiPerfProvider** ppProv, _IWmiProviderStack** ppProvStack )
{
	return m_pObject->LoadProvider( pNamespace, pwszServerName, pwszNamespace, pContext, ppProv, ppProvStack  );
}


STDMETHODIMP CRefresherCache::XWbemShutdown::Shutdown( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context )
{
	return m_pObject->Shutdown( a_Flags , a_MaxMilliSeconds , a_Context  );
}

/* _IWbemRefresherMgr implemetation */
HRESULT CRefresherCache::AddObjectToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
											  WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate, long lFlags,
											  IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo )
{

	CHiPerfPrvRecord*	pProvRecord = NULL;

	CVar	vProviderName;
	BOOL	fStatic = FALSE;

	HRESULT	hr = GetProviderName( pClassObject, &vProviderName, &fStatic );

	if ( SUCCEEDED( hr ) )
	{
		if ( !fStatic )
		{
			hr = FindProviderRecord( vProviderName.GetLPWSTR(), pwszNamespace, pNamespace, &pProvRecord );
		}

		if ( SUCCEEDED( hr ) )
		{
			// Impersonate before continuing.  If this don't succeed, we no workee
			hr = CoImpersonateClient();

			if ( SUCCEEDED( hr ) )
			{
				// Setup the refresher info, inculding a remote refresher record as appropriate
				hr = CreateInfoForProvider((CRefresherId*) pDestRefresherId,
											pProvRecord,
											pwszServerName,
											pwszNamespace,
											pNamespace,
											(CWbemObject*) pInstTemplate,
											lFlags, 
											pContext,
											(CRefreshInfo*) pInfo,
											pLockMgr);

				CoRevertToSelf();

			}

			if ( NULL != pProvRecord )
			{
				pProvRecord->Release();
			}

		}	// IF FindProviderRecord

	}	// IF GetProviderName

	return hr;
}

HRESULT CRefresherCache::AddEnumToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
											WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate, LPCWSTR wszClass,
											long lFlags, IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo )
{

	CHiPerfPrvRecord*	pProvRecord = NULL;

	CVar	vProviderName;
	BOOL	fStatic = FALSE;

	HRESULT	hr = GetProviderName( pClassObject, &vProviderName, &fStatic );

	if ( SUCCEEDED( hr ) )
	{
		if ( !fStatic )
		{
			hr = FindProviderRecord( vProviderName.GetLPWSTR(), pwszNamespace, pNamespace, &pProvRecord );
		}

		if ( SUCCEEDED( hr ) )
		{
			// Impersonate before continuing.  If this don't succeed, we no workee
			hr = CoImpersonateClient();

			if ( SUCCEEDED( hr ) )
			{
				// Setup the refresher info, inculding a remote refresher record as appropriate
				hr = CreateEnumInfoForProvider((CRefresherId*) pDestRefresherId,
											pProvRecord,
											pwszServerName,
											pwszNamespace,
											pNamespace,
											(CWbemObject*) pInstTemplate,
											wszClass,
											lFlags, 
											pContext,
											(CRefreshInfo*) pInfo,
											pLockMgr);

				CoRevertToSelf();

			}

			if ( NULL != pProvRecord )
			{
				pProvRecord->Release();
			}

		}	// IF FindProviderRecord

	}	// IF GetProviderName

	return hr;
}

HRESULT CRefresherCache::GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, BOOL fAddRefresher, IWbemRemoteRefresher** ppRemRefresher,
											 IUnknown* pLockMgr, GUID* pGuid )
{
	CRefresherRecord*	pRefrRecord = NULL;

	// We may not always want to force a record to be created
	HRESULT hr = FindRefresherRecord( (CRefresherId*) pRefresherId, fAddRefresher, pLockMgr, &pRefrRecord );

    // Make sure this guy is released
    CReleaseMe  rm( (IWbemRemoteRefresher*) pRefrRecord );

	if ( SUCCEEDED( hr ) )
	{
		// Get the GUID here as well
		hr = pRefrRecord->QueryInterface( IID_IWbemRemoteRefresher, (void**) ppRemRefresher );
        pRefrRecord->GetGuid( pGuid );

	}

	return hr;
}

HRESULT CRefresherCache::Startup(	long lFlags , IWbemContext *pCtx , _IWmiProvSS *pProvSS )
{
	if ( pProvSS )
	{
		m_pProvSS = pProvSS ;
		m_pProvSS->AddRef () ;
		return WBEM_S_NO_ERROR ;
	}
	else
	{
		return WBEM_E_INVALID_PARAMETER ;
	}
}

HRESULT CRefresherCache::LoadProvider( IWbemServices* pNamespace, LPCWSTR pwszProviderName, LPCWSTR pwszNamespace, IWbemContext * pContext, IWbemHiPerfProvider** ppProv, _IWmiProviderStack** ppProvStack )
{
	return LoadProvider( pwszProviderName, pwszNamespace, pNamespace, pContext, ppProv, ppProvStack );
}

HRESULT CRefresherCache::Shutdown( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context  )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

	// Shutdown Refresher Records first
	if ( m_apRefreshers.GetSize() > 0 )
	{
		CRefresherRecord**	apRecords = new CRefresherRecord*[m_apRefreshers.GetSize()];

		if ( NULL != apRecords )
		{
			int	nSize = m_apRefreshers.GetSize();

			// AddRef each of the records then release them.  This
			// ensures that if any remote refreshers are outstanding we 
			// don't mess with them.

			// We'll probably want to shutdown each record, by having it release
			// all it's stuff.
		    for( int i = 0; i < nSize; i++ )
			{
				apRecords[i] = m_apRefreshers[i];
				apRecords[i]->AddRef();
			}

		    for( i = 0; i < nSize; i++ )
			{
				apRecords[i]->Release();
			}

			delete [] apRecords;

		}
	}

	// Now shutdown Provider Records
	if ( m_apProviders.GetSize() > 0 )
	{
		CHiPerfPrvRecord**	apRecords = new CHiPerfPrvRecord*[m_apProviders.GetSize()];

		if ( NULL != apRecords )
		{
			int	nSize = m_apProviders.GetSize();

			// AddRef each of the records then release them.  This
			// will force them out of the cache if nobody else is
			// referencing them.

			// We'll probably want to shutdown each record, by having it release
			// all it's stuff.
		    for( int i = 0; i < nSize; i++ )
			{
				apRecords[i] = m_apProviders[i];
				apRecords[i]->AddRef();
			}

		    for( i = 0; i < nSize; i++ )
			{
				apRecords[i]->Release();
			}

			delete [] apRecords;
		}

	}

	return WBEM_S_NO_ERROR ;
}

HRESULT CRefresherCache::FindRefresherRecord(CRefresherId* pRefresherId, BOOL bCreate,
                                             IUnknown* pLockMgr, CRefresherRecord** ppRecord )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // We always AddRef() the record before returning so multiple requests will keep the
    // refcount correct so we won't remove and delete a record that another thread wants to
    // use (Remove blocks on the same critical section).

    // Look for it
    // ===========

    for(int i = 0; i < m_apRefreshers.GetSize(); i++)
    {
        if(m_apRefreshers[i]->GetId() == *pRefresherId)
        {
            m_apRefreshers[i]->AddRef();
            *ppRecord = m_apRefreshers[i];
            return WBEM_S_NO_ERROR;
        }
    }

    // If we weren't told to create it, then this is not an error
    if(!bCreate)
    {
        *ppRecord = NULL;
        return WBEM_S_FALSE;
    }

    CRefresherRecord* pNewRecord = NULL;

    // Watch for memory exceptions
    try
    {
        pNewRecord = new CRemoteRecord(*pRefresherId, this, pLockMgr);

        if ( m_apRefreshers.Add(pNewRecord) < 0 )
		{
			delete pNewRecord;
			return WBEM_E_OUT_OF_MEMORY;
		}
    
        pNewRecord->AddRef();
        *ppRecord = pNewRecord;
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pNewRecord )
        {
            delete pNewRecord;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch( ... )
    {
        if ( NULL != pNewRecord )
        {
            delete pNewRecord;
        }

        return WBEM_E_FAILED;
    }
}

HRESULT CRefresherCache::CreateInfoForProvider(CRefresherId* pDestRefresherId,
                    CHiPerfPrvRecord*	pProvRecord,
					LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
					IWbemServices* pNamespace,
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo,
					IUnknown* pLockMgr)
{
    HRESULT hres;

    MSHCTX dwDestContext = GetDestinationContext(pDestRefresherId);

    // By decorating the object, we will store namespace and
    // server info in the object

    hres = pInstTemplate->SetDecoration( pwszServerName, pwszNamespace );

	if ( FAILED( hres ) )
	{
		return hres;
	}

	// If no hiperf provider, this is non-hiperf refreshing
	if ( NULL == pProvRecord )
	{
		pInfo->SetNonHiPerf( pwszNamespace, pInstTemplate );
	}
	// If this is In-Proc or Local, we'll just let the normal
	// client loadable logic handle it

	else if(     dwDestContext == MSHCTX_LOCAL
		||  dwDestContext == MSHCTX_INPROC )
	{
		// Set the info appropriately now baseed on whether we are local to
		// the machine or In-Proc to WMI

		if ( dwDestContext == MSHCTX_INPROC )
		{
			// We will use the hiperf provider interface
			// we already have loaded.

			pInfo->SetDirect( pProvRecord->GetClientLoadableClsid(), pwszNamespace, pProvRecord->GetProviderName(), pInstTemplate, &m_XWbemRefrCache );
		}
		else
		{
			if (!pInfo->SetClientLoadable( pProvRecord->GetClientLoadableClsid(), pwszNamespace, pInstTemplate ))
				hres = WBEM_E_OUT_OF_MEMORY;
		}

	}
	else
	{

		// Ensure that we will indeed have a refresher record.
		CRefresherRecord* pRecord = NULL;

		hres = FindRefresherRecord(pDestRefresherId, TRUE, pLockMgr, &pRecord);

		if ( SUCCEEDED ( hres ) )
		{
			IWbemHiPerfProvider*	pHiPerfProvider = NULL;

			// Look for the actual provider record.  If we can't find it, we need to load
			// the provider.  If we can find it, then we will use the provider currently being
			// used by the refresher record.

			pRecord->FindProviderRecord( pProvRecord->GetClsid(), &pHiPerfProvider );

			// We'll need this to properly addref the provider
			_IWmiProviderStack*	pProvStack = NULL;

			if ( NULL == pHiPerfProvider )
			{
				hres = LoadProvider( pProvRecord->GetProviderName(), pwszNamespace, pNamespace, pContext, &pHiPerfProvider, &pProvStack );
			}

			CReleaseMe	rm( pHiPerfProvider );
			CReleaseMe	rmStack( pProvStack );

			if ( SUCCEEDED( hres ) )
			{
				// Now let the record take care of getting the object inside itself
				hres = pRecord->AddObjectRefresher( pProvRecord, pHiPerfProvider, pProvStack,
										pNamespace, pwszServerName, pwszNamespace,
										pInstTemplate, lFlags, pContext, pInfo );
			}
		}

		if ( NULL != pRecord )
		{
			pRecord->Release();
		}

	}

    return hres;
}

HRESULT CRefresherCache::CreateEnumInfoForProvider(CRefresherId* pDestRefresherId,
                    CHiPerfPrvRecord*	pProvRecord,
					LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
					IWbemServices* pNamespace,
                    CWbemObject* pInstTemplate,
                    LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo,
					IUnknown* pLockMgr)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    MSHCTX dwDestContext = GetDestinationContext(pDestRefresherId);

    // By decorating the object, we will store namespace and
    // server info so that a client can auto-reconnect to
    // us if necessary

    hres = pInstTemplate->SetDecoration( pwszServerName, pwszNamespace );

    if ( FAILED( hres ) )
    {
        return hres;
    }

	// If no hiperf provider, this is non-hiperf refreshing
	if ( NULL == pProvRecord )
	{
		pInfo->SetNonHiPerf( pwszNamespace, pInstTemplate );
	}
    // If this is In-Proc or Local, we'll just let the normal
    // client loadable logic handle it ( if we have no hi-perf
	// provider record, then we'll assume remote in order to
	// 
    else if ( dwDestContext == MSHCTX_LOCAL
		||  dwDestContext == MSHCTX_INPROC )
    {
        // Set the info appropriately now baseed on whether we are local to
        // the machine or In-Proc to WMI

        if ( dwDestContext == MSHCTX_INPROC )
        {
            // We will use the hiperf provider interface
            // we already have loaded.

            pInfo->SetDirect(pProvRecord->GetClientLoadableClsid(), pwszNamespace, pProvRecord->GetProviderName(), pInstTemplate, &m_XWbemRefrCache );
        }
        else
        {
            if (!pInfo->SetClientLoadable(pProvRecord->GetClientLoadableClsid(), pwszNamespace, pInstTemplate))
            	hres = WBEM_E_OUT_OF_MEMORY;
        }

    }
    else
	{	

		// Ensure that we will indeed have a refresher record.
		CRefresherRecord* pRecord = NULL;

		hres = FindRefresherRecord(pDestRefresherId, TRUE, pLockMgr, &pRecord);

		if ( SUCCEEDED ( hres ) )
		{
			IWbemHiPerfProvider*	pHiPerfProvider = NULL;

			// Look for the actual provider record.  If we can't find it, we need to load
			// the provider.  If we can find it, then we will use the provider currently being
			// used by the refresher record.

			pRecord->FindProviderRecord( pProvRecord->GetClsid(), &pHiPerfProvider );

			// We'll need this to properly addref the provider
			_IWmiProviderStack*	pProvStack = NULL;

			if ( NULL == pHiPerfProvider )
			{
				hres = LoadProvider( pProvRecord->GetProviderName(), 
				                     pwszNamespace, pNamespace,
									 pContext, &pHiPerfProvider, &pProvStack );
			}

			CReleaseMe	rm( pHiPerfProvider );
			CReleaseMe	rmProvStack( pProvStack );

			if ( SUCCEEDED( hres ) )
			{
				// Add an enumeration to the Refresher
				hres = pRecord->AddEnumRefresher(
							pProvRecord, pHiPerfProvider, pProvStack, pNamespace, 
							pInstTemplate, wszClass, lFlags, pContext, pInfo );
			}
		}

		if ( NULL != pRecord )
		{
			pRecord->Release();
		}

	}

    return hres;
}

HRESULT CRefresherCache::RemoveObjectFromRefresher(CRefresherId* pId,
                            long lId, long lFlags)
{

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Find the refresher
    // ==================

    CRefresherRecord* pRefresherRecord = NULL;
    
    HRESULT hres = FindRefresherRecord(pId, FALSE, NULL, &pRefresherRecord );

    // Make sure this guy is released
    CReleaseMe  rm( (IWbemRemoteRefresher*) pRefresherRecord );

    // Both are error conditions
    if ( FAILED( hres ) || pRefresherRecord == NULL )
    {
        return hres;
    }

    // Remove it from the record
    // =========================

    return pRefresherRecord->Remove(lId);
}

MSHCTX CRefresherCache::GetDestinationContext(CRefresherId* pRefresherId)
{
	// If set, allows us to force remote refreshing in the provider host
#ifdef DBG
    DWORD dwVal = 0;
    Registry rCIMOM(WBEM_REG_WINMGMT);
    if (rCIMOM.GetDWORDStr( _T("DebugRemoteRefresher"), &dwVal ) == Registry::no_error)
    {
        if ( dwVal )
		{
			return MSHCTX_DIFFERENTMACHINE;
		}
	}
#endif

	char szBuffer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;
    GetComputerNameA(szBuffer, &dwLen);

    if(_stricmp(szBuffer, pRefresherId->GetMachineName()))
        return MSHCTX_DIFFERENTMACHINE;

    if(pRefresherId->GetProcessId() != GetCurrentProcessId())
        return MSHCTX_LOCAL;
    else
        return MSHCTX_INPROC;
}

BOOL CRefresherCache::RemoveRefresherRecord(CRefresherRecord* pRecord)
{

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Check that the record is actually released, in case another thread successfully requested
    // the record from FindRefresherRecord() which will have AddRef'd the record again.

    if ( pRecord->IsReleased() )
    {
        for(int i = 0; i < m_apRefreshers.GetSize(); i++)
        {
            if(m_apRefreshers[i] == pRecord)
            {
                m_apRefreshers.RemoveAt(i);
                return TRUE;
            }
        }

    }

    return FALSE;
}

BOOL CRefresherCache::RemoveProviderRecord(CHiPerfPrvRecord* pRecord)
{

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Check that the record is actually released, in case another thread successfully requested
    // the record from FindRefresherRecord() which will have AddRef'd the record again.

    if ( pRecord->IsReleased() )
    {
        for(int i = 0; i < m_apProviders.GetSize(); i++)
        {
            if(m_apProviders[i] == pRecord)
            {
                m_apProviders.RemoveAt(i);
                return TRUE;
            }
        }

    }

    return FALSE;
}

/*
HRESULT CRefresherCache::FindProviderRecord( LPCWSTR pwszProviderName, LPCWSTR pszNamespace, IWbemServices* pSvc, CHiPerfPrvRecord** ppRecord )
{

	// We need to get the GUID of the name corresponding to IWbemServices
	CLSID	clsid;
	CLSID	clientclsid;
	HRESULT hr = GetProviderInfo( pSvc, pwszProviderName, &clsid, &clientclsid );

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

	if ( SUCCEEDED( hr ) )
	{
		// Try to find the provider's class id
		for( int i = 0; i < m_apProviders.GetSize(); i++)
		{
			if ( m_apProviders[i]->GetClsid() == clsid )
			{
				break;
			}
		}

		// If the record was not found, we must add one
		if ( i >= m_apProviders.GetSize() )
		{
			IWbemHiPerfProvider*	pProv = NULL;

			try
			{
				// Load the provider
				hr = LoadProvider( pwszProviderName, pszNamespace, pSvc, &pProv );

				CReleaseMe  rm1(pProv);

				if ( SUCCEEDED( hr ) )
				{
					CHiPerfPrvRecord* pRecord = new CHiPerfPrvRecord( pwszProviderName, clsid, clientclsid, pProv, this );

					if ( NULL != pRecord )
					{
						if ( m_apProviders.Add( pRecord ) < 0 )
						{
							delete pRecord;
							hr = WBEM_E_OUT_OF_MEMORY;
						}
						else
						{
							pRecord->AddRef();
							*ppRecord = pRecord;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

				}	// IF LoadProvider
				else
				{
					// If the provider doesn't support the interface, this error will come back and we'll
					// assume that there is at least a provider and allow the caller to refresh as a 
					// non-hiperf refresh scenario.

					if ( E_NOINTERFACE == hr )
					{
						hr = WBEM_S_NO_ERROR;
					}
				}

			}
			catch( CX_MemoryException )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			catch(...)
			{
				hr = WBEM_E_CRITICAL_ERROR;
			}
		}
		else
		{
			*ppRecord = m_apProviders[i];
			(*ppRecord)->AddRef();
		}
	}

    return hr;
}
*/

//
//  Builds a record without adding to the cache and without loading
//

HRESULT CRefresherCache::FindProviderRecord( LPCWSTR pwszProviderName, LPCWSTR pszNamespace, IWbemServices* pSvc, CHiPerfPrvRecord** ppRecord )
{

	// We need to get the GUID of the name corresponding to IWbemServices
	CLSID	clsid;
	CLSID	clientclsid;
	HRESULT hr = GetProviderInfo( pSvc, pwszProviderName, &clsid, &clientclsid );

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

	if ( SUCCEEDED( hr ) )
	{
		// Try to find the provider's class id
		for( int i = 0; i < m_apProviders.GetSize(); i++)
		{
			if ( m_apProviders[i]->GetClsid() == clsid )
			{
				break;
			}
		}

		// If the record was not found, we must add one
		if ( i >= m_apProviders.GetSize() )
		{

            if (clientclsid == IID_NULL)
            {
                hr = WBEM_S_NO_ERROR;
            }
            else
            {		
			    try 
			    {
					CHiPerfPrvRecord* pRecord = new CHiPerfPrvRecord( pwszProviderName, clsid, clientclsid, this );

					if ( NULL != pRecord )
					{
						if ( m_apProviders.Add( pRecord ) < 0 )
						{
							delete pRecord;
							hr = WBEM_E_OUT_OF_MEMORY;
						}
						else
						{
							pRecord->AddRef();
							*ppRecord = pRecord;
							hr = WBEM_S_NO_ERROR;
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

				}
				catch( CX_MemoryException )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}
		}
		else
		{
			*ppRecord = m_apProviders[i];
			(*ppRecord)->AddRef();
		}
	}

    return hr;
}



HRESULT CRefresherCache::GetProviderInfo( IWbemServices* pSvc, LPCWSTR pwszProviderName, CLSID* pClsid, CLSID* pClientClsid )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Create the path
		WString	strPath( L"__Win32Provider.Name=\"" );

		strPath += pwszProviderName;
		strPath += ( L"\"" );

		BSTR	bstrPath = SysAllocString( (LPCWSTR) strPath );
		if ( NULL == bstrPath )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

		// Auto delete
		CSysFreeMe	sfm(bstrPath);

		IWbemClassObject*	pObj = NULL;

		hr = pSvc->GetObject( bstrPath, 0L, NULL, &pObj, NULL );
		CReleaseMe	rm( pObj );

		if ( SUCCEEDED( hr ) )
		{
			CWbemInstance*	pInst = (CWbemInstance*) pObj;

			CVar	var;

			hr = pInst->GetProperty( L"CLSID", &var );

			if ( SUCCEEDED( hr ) )
			{
				// Convert string to a GUID.
				hr = CLSIDFromString( var.GetLPWSTR(), pClsid );

				if ( SUCCEEDED( hr ) )
				{
					var.Empty();

					hr = pInst->GetProperty( L"ClientLoadableCLSID", &var );

					if ( SUCCEEDED( hr ) )
					{
						// Convert string to a GUID.
						hr = CLSIDFromString( var.GetLPWSTR(), pClientClsid );
					}
					else
					{
					    *pClientClsid = IID_NULL;
					    hr = WBEM_S_NO_ERROR;
					}

				}	// IF CLSID from String

			}	// IF GetCLSID

		}	// IF GetObject

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

HRESULT 
CRefresherCache::LoadProvider(LPCWSTR pwszProviderName, 
                              LPCWSTR pszNamespace, 
                              IWbemServices* pSvc, 
                              IWbemContext * pCtx,
                              IWbemHiPerfProvider** ppProv,
							  _IWmiProviderStack** ppStack )
{
	_IWmiProviderFactory *t_Factory = NULL;
    HRESULT t_Result = m_pProvSS->Create(pSvc,
                                         0,    // lFlags
                                         pCtx,    // pCtx
                                         pszNamespace, // Path
                                         IID__IWmiProviderFactory,
                                         (LPVOID *) &t_Factory);

    if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderStack *t_Stack = NULL ;

		t_Result = t_Factory->GetHostedProvider(0L,
                                     			pCtx,
			                         			NULL,
			                         			NULL,
			                         			NULL,
			                         			NULL,
			                         			pwszProviderName, 
			                         			9 ,	// SharedNetworkServiceHost
			                         			L"DefaultNetworkServiceHost",
			                         			IID__IWmiProviderStack,
			                         			(void**) &t_Stack);

		if ( SUCCEEDED ( t_Result ) )
		{
			IUnknown *t_Unknown = NULL ;
			t_Result = t_Stack->DownLevel(
				0 ,
				NULL ,
				IID_IUnknown,
				( void ** ) & t_Unknown);

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Unknown->QueryInterface( IID_IWbemHiPerfProvider , ( void ** ) ppProv );

				// We got what we wanted.  If appropriate, copy the Provider Stack
				// Interface pointer
				if ( SUCCEEDED( t_Result ) && NULL != ppStack )
				{
					*ppStack = t_Stack;
					t_Stack->AddRef();
				}

				t_Unknown->Release();
			}

			t_Stack->Release();
		}

		t_Factory->Release();
	}

	return t_Result ;

#if 0
	_IWmiProviderFactoryInitialize*	pInitFactory = NULL;

	HRESULT	hr = CoCreateInstance( CLSID_WmiProviderSharedFactory, NULL, CLSCTX_LOCAL_SERVER , IID__IWmiProviderFactoryInitialize, (void**) &pInitFactory );
	CReleaseMe	rm( pInitFactory );

	if ( SUCCEEDED( hr ) )
	{
		// What to use for Provider Subsystem?
		hr = pInitFactory->Initialize( NULL, NULL, 0L, NULL, pszNamespace, pSvc, pSvc );

		if ( SUCCEEDED( hr ) )
		{
			_IWmiProviderFactory*	pFactory = NULL;
			hr = pInitFactory->QueryInterface( IID__IWmiProviderFactory, (void**) &pFactory );
			CReleaseMe	rm1( pFactory );

			if ( SUCCEEDED( hr ) )
			{
				// Need strorage for the GUID
				GUID	guid;
				ZeroMemory ( & guid , sizeof ( GUID ) ) ;
				hr = pFactory->GetProvider( 0L, NULL, &guid, NULL, NULL, NULL, pwszProviderName, IID_IWbemHiPerfProvider,
											(void**) ppProv );
			}	// IF QI

		}	// IF Initialized Factory

	}	// IF Got Factory

	return hr;
#endif

}

HRESULT CRefresherCache::GetProviderName( IWbemClassObject*	pClassObj, CVar* pProviderName, BOOL* pfStatic )
{
	*pfStatic = FALSE;

	_IWmiObject*	pWmiObject = NULL;

    HRESULT	hr = pClassObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );
	CReleaseMe	rmObj( pWmiObject );

	if ( SUCCEEDED( hr ) )
	{
		CWbemObject*	pObj = NULL;
		
		hr = pWmiObject->_GetCoreInfo( 0L, (void**) &pObj );
		CReleaseMe	rmWmiObj( (_IWmiObject*) pObj );

		if ( SUCCEEDED( hr ) )
		{
			hr = pObj->GetQualifier(L"provider", pProviderName);

			// Must be a dynamically provided class.  If it's static, or the variant type is wrong, that's still okay
			// we just need to record this information
			if(FAILED(hr))
			{
				if ( WBEM_E_NOT_FOUND == hr )
				{
					*pfStatic = TRUE;
					return WBEM_S_NO_ERROR;
				}

				return WBEM_E_INVALID_OPERATION;
			}
			else if ( pProviderName->GetType() != VT_BSTR )
			{
				*pfStatic = TRUE;
				return WBEM_S_NO_ERROR;
			}


		}	// IF GetCoreInfo

	}	// If got WMIObject interface

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrenum.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRENUM.H

Abstract:

  This file implements a refresher enumerator.

History:

--*/

#ifndef __REFRENUM_H__
#define __REFRENUM_H__

//
//	Classes CRefresherEnumerator
//
//	CRefresherEnumerator:
//	This class provides an implementation of the IEnumWbemClassObject interface.
//	It is designed to be used with an IWbemRefresher implementation and an
//	IWbemHiPerfEnum implementation. An IWbemHiPerfProvider implementation will
//	pass data into the IWbemHiPerfEnum implementation, which is retrieved into
//	this implementation, resetting it with a minimal amount of fuss so a user
//	can access dynamic sets of class instances via a Referesher.
//

#include "unk.h"
#include "sync.h"
#include <cloadhpenum.h>

// Forward class definitions
class CHiPerfEnum;

class CRefresherEnumerator : public CUnk
{
public:

	CRefresherEnumerator(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL);
	~CRefresherEnumerator();

	/* IEnumWbemClassObject */
    HRESULT Reset();
    HRESULT Next(long lTimeout, ULONG uCount,  
        IWbemClassObject** apObj, ULONG FAR* puReturned);
    HRESULT NextAsync(ULONG uCount, IWbemObjectSink* pSink);
    HRESULT Clone(IEnumWbemClassObject** pEnum);
    HRESULT Skip(long lTimeout, ULONG nNum);

	// Allows a refresher to reset the enumerator with a new set of objects
	HRESULT Reset( CClientLoadableHiPerfEnum* pHPEnum );
	HRESULT Reset( CWbemInstance* pInstTemplate, long lBlobType, long lBlobLen, BYTE* pBlob );

protected:

	// Must implement this
    void* GetInterface(REFIID riid);

	/* IEnumWbemClassObject */
    class XEnumWbemClassObject : public CImpl<IEnumWbemClassObject, CRefresherEnumerator>
    {
    public:
        XEnumWbemClassObject(CRefresherEnumerator* pObject) : 
            CImpl<IEnumWbemClassObject, CRefresherEnumerator>(pObject)
        {}

		// Implementation methods
		STDMETHOD(Reset)();
		STDMETHOD(Next)(long lTimeout, ULONG uCount,  
			IWbemClassObject** apObj, ULONG FAR* puReturned);
		STDMETHOD(NextAsync)(ULONG uCount, IWbemObjectSink* pSink);
		STDMETHOD(Clone)(IEnumWbemClassObject** pEnum);
		STDMETHOD(Skip)(long lTimeout, ULONG nNum);

    } m_XEnumWbemClassObject;
    friend XEnumWbemClassObject;

private:

	void	ClearArray();
	BOOL	IsEnumComplete( void )
	{
		return m_dwCurrIndex >= m_dwNumObjects;
	}

	CFlexArray							m_ObjArray;
	DWORD								m_dwNumObjects;
	DWORD								m_dwCurrIndex;
	CHiPerfLock							m_Lock;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrhelp.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRHELP.CPP

Abstract:

    Refresher helpers

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include <wbemint.h>
#include <refrhelp.h>
#include <wbemcomn.h>
#include <fastobj.h>
#include <corex.h>

CRefresherId::CRefresherId()
{
    unsigned long lLen = MAX_COMPUTERNAME_LENGTH + 1;
    m_szMachineName = (LPSTR)CoTaskMemAlloc(lLen);
    GetComputerNameA(m_szMachineName, &lLen);
    m_dwProcessId = GetCurrentProcessId();
    CoCreateGuid(&m_guidRefresherId);
}
    
CRefresherId::CRefresherId(const WBEM_REFRESHER_ID& Other)
{
    m_szMachineName = (LPSTR)CoTaskMemAlloc(MAX_COMPUTERNAME_LENGTH + 1);
    strcpy(m_szMachineName, Other.m_szMachineName);
    m_dwProcessId = Other.m_dwProcessId;
    m_guidRefresherId = Other.m_guidRefresherId;
}
    
CRefresherId::~CRefresherId()
{
    CoTaskMemFree(m_szMachineName);
}


CRefreshInfo::CRefreshInfo()
{
    m_lType = WBEM_REFRESH_TYPE_INVALID;
}

CRefreshInfo::CRefreshInfo(const WBEM_REFRESH_INFO& Other)
{
/*
    m_lCancelId = Other.m_lCancelId;
    m_lType = Other.m_lType;
    if(m_lType == WBEM_REFRESH_TYPE_DIRECT)
    {
        WBEM_REFRESH_INFO_DIRECT& ThisInfo = m_Info.m_Direct;
        WBEM_REFRESH_INFO_DIRECT& OtherInfo = Other.m_Info.m_Direct;

        ThisInfo.m_pRefresher = OtherInfo.m_pRefresher;
        if(ThisInfo.m_pRefresher)
            ThisInfo.m_pRefresher->AddRef();

        ThisInfo.m_pRefreshedObject = OtherInfo.m_pRefreshedObject;
        if(ThisInfo.m_pRefreshedObject)
            ThisInfo.m_pRefreshedObject->AddRef();

        ThisInfo.m_pProvider = OtherInfo.m_pProvider;
        if(ThisInfo.m_pProvider)
            ThisInfo.m_pProvider->AddRef();

        ThisInfo.m_lRequestId = OtherInfo.m_lRequestId;
    }
    else if(m_lType == WBEM_REFRESH_TYPE_CLIENT_LOADABLE)
    {
        m_Info.m_ClientLoadable.m_clsid = Other.m_Info.m_ClientLoadable.m_clsid;
    }
    else if(m_lType == WBEM_REFRESH_TYPE_REMOTE)
    {
        m_Info.m_Remote.m_pRefresher = Other.m_Info.m_Remote.m_pRefresher;
        if(m_Info.m_Remote.m_pRefresher)
           m_Info.m_Remote.m_pRefresher->AddRef();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_CONTINUOUS)
    {
        m_Info.m_Continuous.m_pControl = Other.m_Info.m_Continuous.m_pControl;
        if(m_Info.m_Continuous.m_pControl)
           m_Info.m_Continuous.m_pControl->AddRef();
        
        m_Info.m_Continuous.m_wszSharedMemoryName = CoTaskMemAlloc(
            wcslen(Other.m_Info.m_Continuous.m_wszSharedMemoryName)*2+2);
        wcscpy(m_Info.m_Continuous.m_wszSharedMemoryName,
                Other.m_Info.m_Continuous.m_wszSharedMemoryName);
    }
    else if(m_lType == WBEM_REFRESH_TYPE_LOCAL)
    {
    }
*/
}
    
CRefreshInfo::~CRefreshInfo()
{
    if(m_lType == WBEM_REFRESH_TYPE_DIRECT)
    {
        WBEM_REFRESH_INFO_DIRECT& ThisInfo = m_Info.m_Direct;

        if(ThisInfo.m_pRefrMgr)
            ThisInfo.m_pRefrMgr->Release();

		// Free all allocated memory
        CoTaskMemFree(ThisInfo.m_pDirectNames->m_wszNamespace);
        CoTaskMemFree(ThisInfo.m_pDirectNames->m_wszProviderName);
        CoTaskMemFree(ThisInfo.m_pDirectNames);

        if(ThisInfo.m_pTemplate)
           ThisInfo.m_pTemplate->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_CLIENT_LOADABLE)
    {
        CoTaskMemFree(m_Info.m_ClientLoadable.m_wszNamespace);
        if(m_Info.m_ClientLoadable.m_pTemplate)
           m_Info.m_ClientLoadable.m_pTemplate->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_REMOTE)
    {
        if(m_Info.m_Remote.m_pRefresher)
           m_Info.m_Remote.m_pRefresher->Release();
        if(m_Info.m_Remote.m_pTemplate)
           m_Info.m_Remote.m_pTemplate->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_CONTINUOUS)
    {
        CoTaskMemFree(m_Info.m_Continuous.m_wszSharedMemoryName);
    }
    else if(m_lType == WBEM_REFRESH_TYPE_SHARED)
    {
        CoTaskMemFree(m_Info.m_Shared.m_wszSharedMemoryName);
        if(m_Info.m_Shared.m_pRefresher)
            m_Info.m_Shared.m_pRefresher->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_NON_HIPERF)
    {
        CoTaskMemFree(m_Info.m_NonHiPerf.m_wszNamespace);
        if(m_Info.m_NonHiPerf.m_pTemplate)
            m_Info.m_NonHiPerf.m_pTemplate->Release();
    }
}

void CRefreshInfo::SetRemote(IWbemRemoteRefresher* pRemRef, long lRequestId,
                                IWbemObjectAccess* pTemplate, GUID* pGuid)
{
    m_lType = WBEM_REFRESH_TYPE_REMOTE;
    m_lCancelId = lRequestId;
    m_Info.m_Remote.m_pRefresher = pRemRef;
    if(pRemRef)
        pRemRef->AddRef();
    m_Info.m_Remote.m_pTemplate = pTemplate;
    m_Info.m_Remote.m_guid = *pGuid;
    if(pTemplate)
        pTemplate->AddRef();
}

void CRefreshInfo::SetContinuous(CWbemObject* pRefreshedObject, 
                                    long lRequestId)
{
    m_lType = WBEM_REFRESH_TYPE_CONTINUOUS;
    m_lCancelId = lRequestId;
    
    CVar vPath;
    pRefreshedObject->GetPath(&vPath);
    m_Info.m_Continuous.m_wszSharedMemoryName = 
        WbemStringCopy(vPath.GetLPWSTR());
}
    
bool CRefreshInfo::SetClientLoadable(REFCLSID rClientClsid, 
                      LPCWSTR wszNamespace, IWbemObjectAccess* pTemplate)
{
    WBEM_WSTR cloned = WbemStringCopy(wszNamespace);
    if (!cloned)
    	return false;
    m_lType = WBEM_REFRESH_TYPE_CLIENT_LOADABLE;
    m_lCancelId = 0;
    m_Info.m_ClientLoadable.m_clsid = rClientClsid;
    m_Info.m_ClientLoadable.m_wszNamespace = cloned;
    m_Info.m_ClientLoadable.m_pTemplate = pTemplate;
    if(pTemplate)
        pTemplate->AddRef();
    return true;
}

void CRefreshInfo::SetDirect(REFCLSID rClientClsid, 
                      LPCWSTR wszNamespace, LPCWSTR wszProviderName,
					  IWbemObjectAccess* pTemplate,
                      _IWbemRefresherMgr* pMgr )
{
    m_lType = WBEM_REFRESH_TYPE_DIRECT;
    m_lCancelId = 0;
    m_Info.m_Direct.m_clsid = rClientClsid;
    m_Info.m_Direct.m_pDirectNames = (WBEM_REFRESH_DIRECT_NAMES*) CoTaskMemAlloc( sizeof(WBEM_REFRESH_DIRECT_NAMES) );

	if ( NULL == m_Info.m_Direct.m_pDirectNames )
	{
		throw CX_MemoryException();
	}

    m_Info.m_Direct.m_pDirectNames->m_wszNamespace = WbemStringCopy(wszNamespace);
    m_Info.m_Direct.m_pDirectNames->m_wszProviderName = WbemStringCopy(wszProviderName);

	if (	NULL == m_Info.m_Direct.m_pDirectNames->m_wszNamespace||
			NULL == m_Info.m_Direct.m_pDirectNames->m_wszProviderName )
	{
		throw CX_MemoryException();
	}

    m_Info.m_Direct.m_pTemplate = pTemplate;
    m_Info.m_Direct.m_pRefrMgr = pMgr;

    if(pTemplate)
    {
        pTemplate->AddRef();
    }

    if(pMgr)
    {
        pMgr->AddRef();
    }

}

void CRefreshInfo::SetShared(CWbemObject* pRefreshedObject,
                IWbemRefresher* pRefresher, long lRequestId)
{
    m_lType = WBEM_REFRESH_TYPE_SHARED;
    m_lCancelId = lRequestId;

    m_Info.m_Shared.m_pRefresher = pRefresher;
    if(pRefresher)
        pRefresher->AddRef();

    CVar vPath;
    pRefreshedObject->GetPath(&vPath);
    m_Info.m_Shared.m_wszSharedMemoryName = WbemStringCopy(vPath.GetLPWSTR());
}
    
void CRefreshInfo::SetNonHiPerf(LPCWSTR wszNamespace, IWbemObjectAccess* pTemplate)
{
    m_lType = WBEM_REFRESH_TYPE_NON_HIPERF;
    m_lCancelId = 0;
    m_Info.m_NonHiPerf.m_wszNamespace = WbemStringCopy(wszNamespace);
    m_Info.m_NonHiPerf.m_pTemplate = pTemplate;
    if(pTemplate)
        pTemplate->AddRef();
}

void CRefreshInfo::SetInvalid()
{
    m_lType = WBEM_REFRESH_TYPE_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrenum.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRENUM.CPP

Abstract:

  This file implements a refresher enumerator.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "hiperfenum.h"
#include <cloadhpenum.h>
#include "refrenum.h"


/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::CRefresherEnumerator
//
//  Purpose:
//      Class Constructor
//
//  Inputs:
//      CLifeControl*           pControl - Allows control of DLL lifetime
//      IUnknown*               pOuter - Controls aggregation
//
//  Outputs:
//      None.
//
//  Returns:
//      None.
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CRefresherEnumerator::CRefresherEnumerator( CLifeControl* pControl/* = NULL*/, IUnknown* pOuter/* = NULL */)
:   m_XEnumWbemClassObject( this ),
    m_ObjArray(),
    m_dwNumObjects( 0 ),
    m_dwCurrIndex( 0 ),
    m_Lock()
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::~CRefresherEnumerator
//
//  Purpose:
//      Class Destructor
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      None.
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CRefresherEnumerator::~CRefresherEnumerator()
{
    ClearArray();
}


/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::ClearArray
//
//  Purpose:
//      Clears out our array
//
//  Inputs:
//      None.
//
//  Outputs:
//      None
//
//  Returns:
//      None.
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

void CRefresherEnumerator::ClearArray( void )
{
    for ( DWORD dwCtr = 0; dwCtr < m_ObjArray.Size(); dwCtr++ )
    {
        ((IWbemClassObject*) m_ObjArray[dwCtr])->Release();
    }

    m_ObjArray.Empty();
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::Reset
//
//  Purpose:
//      Resets this enumerator using a HiPerfEnumeerator.
//
//  Inputs:
//      CClientLoadableHiPerfEnum*  pHPEnum - Enumerator to get data from
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Internal function
//      
/////////////////////////////////////////////////////////////////

HRESULT CRefresherEnumerator::Reset( CClientLoadableHiPerfEnum* pHPEnum )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );

    if ( lock.IsLocked() )
    {
        // Copy objects out of the hi perf enumerator
        hr = pHPEnum->CopyObjects( m_ObjArray, &m_dwNumObjects );

        if ( SUCCEEDED( hr ) )
        {
            m_dwCurrIndex = 0;
        }
    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::Reset
//
//  Purpose:
//      Resets this enumerator using a transfer BLOB and other
//      data.  This is so we can support remote refreshable
//      enumerations.
//
//  Inputs:
//      CWbemInstance*      pInstTemplate - Template to clone from.
//      long                lBlobType - Blob Type
//      long                lBlobLen - Blob Length
//      BYTE*               pBlob - Raw Data to initialize from
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Internal function
//      
/////////////////////////////////////////////////////////////////

HRESULT CRefresherEnumerator::Reset( CWbemInstance* pInstTemplate, long lBlobType, long lBlobLen, BYTE* pBlob )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );


    if ( lock.IsLocked() )
    {
        long    lNumObjects = 0;

        hr = CWbemInstance::CopyTransferArrayBlob( pInstTemplate, lBlobType, lBlobLen, pBlob, m_ObjArray, &lNumObjects );

        if ( SUCCEEDED( hr ) )
        {
            m_dwNumObjects = lNumObjects;
            m_dwCurrIndex = 0;
        }
    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::Reset
//
//  Purpose:
//      Resets this enumerator.
//
//  Inputs:
//      None.
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Basically just resets the index to 0.
//      
/////////////////////////////////////////////////////////////////

HRESULT CRefresherEnumerator::Reset( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );

    if ( lock.IsLocked() )
    {
        // Okay, it's reset
        m_dwCurrIndex = 0;
    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::Next
//
//  Purpose:
//      Retrieves next group of objects in enumerator until we
//      run out
//
//  Inputs:
//      long                lTimeOut - Timeout value
//      ULONG               uCount - Number of objects to retrieve
//
//  Outputs:
//      IWbemClassObject**  apObj - array for object pointers.
//      ULONG               puReturned - Numnber of returned objects
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Forwards only.
//      
/////////////////////////////////////////////////////////////////

HRESULT CRefresherEnumerator::Next(long lTimeout, ULONG uCount, 
                IWbemClassObject** apObj, ULONG* puReturned)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL != apObj && NULL != puReturned && lTimeout >= -1 )
    {

        CHiPerfLockAccess   lock( &m_Lock, lTimeout );
        
        if ( lock.IsLocked() )
        {
            *puReturned = 0;

            // While we have objects, return them the supplied array
            while (     SUCCEEDED( hr )
                    &&  uCount > 0
                    &&  !IsEnumComplete() )
            {
                apObj[*puReturned] = (IWbemClassObject*) m_ObjArray[m_dwCurrIndex++];

                // Check for a valid pointer
                if ( NULL != apObj[*puReturned] )
                {
                    // AddRef the pointer
                    apObj[*puReturned]->AddRef();

                    // Inc/Dec the appropriate counters
                    (*puReturned)++;
                    uCount--;
                }
                else
                {
                    hr = WBEM_E_UNEXPECTED;
                }   // ELSE got NULL object pointer

            }   // WHILE enuming objects

            // If succeeded, see if we got the requested number of obejcts
            if ( SUCCEEDED( hr ) )
            {
                if ( 0 != uCount )
                {
                    hr = WBEM_S_FALSE;
                }
            }
            else
            {
                // Clean up any objects we got back
                if ( *puReturned != 0 )
                {
                    for ( int x = 0; x < *puReturned; x++ )
                    {
                        apObj[x]->Release();
                        apObj[x] = NULL;
                    }   // For enum objects

                }   // IF get objects

            }   // ELSE FAILED(hr)

        }
        else
        {
            hr = WBEM_S_TIMEDOUT;
        }

    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::NextAsync
//
//  Purpose:
//      Retrieves next group of objects in enumerator until we
//      run out.  Indicates objects into the supplied sink.
//
//  Inputs:
//      ULONG               uCount - Number of objects to retrieve
//      IWbemObjectSink*    pSink - The sink to indicate objects into.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Forwards only.
//      
/////////////////////////////////////////////////////////////////

HRESULT CRefresherEnumerator::NextAsync( ULONG uCount, IWbemObjectSink* pSink )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL != pSink )
    {

        CHiPerfLockAccess   lock( &m_Lock );

        if ( lock.IsLocked() )
        {
            if ( m_ObjArray.Size() )
            {

                // While we have objects, Indicate them to the sink
                while (     SUCCEEDED( hr )
                        &&  uCount > 0
                        &&  !IsEnumComplete() )
                {
                    IWbemClassObject*   pObj = (IWbemClassObject*) m_ObjArray[m_dwCurrIndex++];

                    // Check for a valid pointer
                    if ( NULL != pObj )
                    {
                        // Indicate the object
                        pSink->Indicate( 1, &pObj );

                        // Inc/Dec the appropriate counters
                        uCount--;
                    }
                    else
                    {
                        hr = WBEM_E_UNEXPECTED;
                    }   // ELSE got NULL object pointer

                }   // WHILE enuming objects

                // If succeeded, see if we got the requested number of obejcts
                if ( SUCCEEDED( hr ) )
                {
                    HRESULT hrSetStatus = WBEM_S_NO_ERROR;

                    if ( 0 != uCount )
                    {
                        hr = WBEM_S_FALSE;
                    }

                    pSink->SetStatus( 0, hrSetStatus, NULL, NULL );
                }
                else
                {
                    pSink->SetStatus( 0, hr, NULL, NULL );
                }

                // We processed objects, so return WBEM_S_NO_ERROR
                hr = WBEM_S_NO_ERROR;

            }   // IF objects in the array
            else
            {
                hr = WBEM_S_FALSE;
            }
        }
        else
        {
            hr = WBEM_S_TIMEDOUT;
        }

    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::Skip
//
//  Purpose:
//      Skips the requested number of objects in the enumerator.
//
//  Inputs:
//      long                lTimeOut - Timeout value
//      ULONG               uCount - Number of objects to skip
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Forwards only.
//      
/////////////////////////////////////////////////////////////////

HRESULT CRefresherEnumerator::Skip( long lTimeout, ULONG uCount )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( lTimeout >= -1 )
    {

        CHiPerfLockAccess   lock( &m_Lock, lTimeout );

        if ( lock.IsLocked() )
        {
            // If the requested numbert of objects will place us past the
            // number of objects, then we should return a FALSE status
            if ( m_dwCurrIndex + uCount >= m_dwNumObjects )
            {
                m_dwCurrIndex = m_dwNumObjects;
                hr = WBEM_S_FALSE;
            }
            else
            {
                m_dwCurrIndex += uCount;
            }
        }
        else
        {
            hr = WBEM_S_TIMEDOUT;
        }

    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::Clone
//
//  Purpose:
//      Creates a logical copy of this enumerator.
//
//  Inputs:
//      None.
//
//  Outputs:
//      IEnumWbemClassObject**  ppEnum - Cloned enumerator.
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

HRESULT CRefresherEnumerator::Clone( IEnumWbemClassObject** ppEnum )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != ppEnum )
    {
        CHiPerfLockAccess   lock( &m_Lock );

        if ( lock.IsLocked() )
        {
            // Clear the enumerator
            *ppEnum = NULL;

            // Allocate a new enumerator
            CRefresherEnumerator*   pEnum = new CRefresherEnumerator();

            if ( NULL != pEnum )
            {
                // Walk the enumerator's array and clone all the objects in the current enumeration
                for ( int x = 0; SUCCEEDED( hr ) && x < m_dwNumObjects; x++ )
                {
                    IWbemClassObject*   pNewObj = NULL;

                    // Clone each object
                    hr = ((IWbemClassObject*) m_ObjArray[x])->Clone( &pNewObj );

                    // As long as we got an object, add it to
                    // the new object's array.

                    if ( SUCCEEDED( hr ) )
                    {
                        pEnum->m_ObjArray.Add( pNewObj );
                    }
                }

                if ( FAILED( hr ) )
                {
                    delete pEnum;
                    pEnum = NULL;
                }
                else
                {
                    // Copy internal values
                    pEnum->m_dwNumObjects = m_dwNumObjects;
                    pEnum->m_dwCurrIndex = m_dwCurrIndex;

                    // Get a pointer to the new interface
                    pEnum->QueryInterface( IID_IEnumWbemClassObject, (void**) &ppEnum );
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            hr = WBEM_S_TIMEDOUT;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CRefresherEnumerator::GetInterface
//
//  Purpose:
//      Returns pointer to object identified by riid if it is
//      available.
//
//  Inputs:
//      REFIID      riid - Requested interface
//
//  Outputs:
//      None.
//
//  Returns:
//      Pointer to interface implementation
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

void* CRefresherEnumerator::GetInterface(REFIID riid)
{
    if(riid == IID_IUnknown || riid == IID_IEnumWbemClassObject)
        return &m_XEnumWbemClassObject;
    else
        return NULL;
}

// Method implementations.  These just delegate to the main class
STDMETHODIMP CRefresherEnumerator::XEnumWbemClassObject::Reset( void )
{
    return m_pObject->Reset();
}

STDMETHODIMP CRefresherEnumerator::XEnumWbemClassObject::Next(long lTimeout, ULONG uCount, 
                IWbemClassObject** apObj, ULONG* puReturned)
{
    return m_pObject->Next( lTimeout, uCount, apObj, puReturned );
}

STDMETHODIMP CRefresherEnumerator::XEnumWbemClassObject::NextAsync( ULONG uCount, IWbemObjectSink* pSink )
{
    return m_pObject->NextAsync( uCount, pSink );
}

STDMETHODIMP CRefresherEnumerator::XEnumWbemClassObject::Skip( long lTimeout, ULONG uCount )
{
    return m_pObject->Skip( lTimeout, uCount );
}

STDMETHODIMP CRefresherEnumerator::XEnumWbemClassObject::Clone( IEnumWbemClassObject** ppEnum )
{
    return m_pObject->Clone( ppEnum );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRMRSH.CPP

Abstract:

    Refresher marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include "refrmrsh.h"

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

STDMETHODIMP CFactoryBuffer::XFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemRefresher)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CProxyBuffer* pProxy = new CProxyBuffer(m_pObject->m_pControl, pUnkOuter);
    pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
    pProxy->QueryInterface(riid, (void**)ppv);
    return S_OK;
}
    
STDMETHODIMP CFactoryBuffer::XFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemRefresher)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CStubBuffer* pStub = new CStubBuffer(m_pObject->m_pControl, NULL);
    pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);
    if(pUnkServer)
    {
        HRESULT hres = (*ppStub)->Connect(pUnkServer);
        if(FAILED(hres))
        {
            delete pStub;
            *ppStub = NULL;
        }
        return hres;
    }
    else
    {
        return S_OK;
    }
}

void* CFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

ULONG STDMETHODCALLTYPE CProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemRefresher)
    {
        *ppv = (IWbemRefresher*)&m_XRefresher;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CProxyBuffer::XRefresher::
QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        // Trick #2: both are internal interfaces and should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


STDMETHODIMP CProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{
    if(m_pChannel)
        return E_UNEXPECTED;

    // Verify that the channel is local
    // ================================

    DWORD dwContext;
    if(FAILED(pChannel->GetDestCtx(&dwContext, NULL)) ||
        (dwContext != MSHCTX_INPROC && dwContext != MSHCTX_LOCAL))
    {
        return E_UNEXPECTED;
    }
    
    m_pChannel = pChannel;
    if(m_pChannel)
        m_pChannel->AddRef();

    // Receive information from the stub
    // =================================

    // Get a buffer from the channel
    // =============================

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = sizeof(DWORD);
    msg.iMethod = 3;

    HRESULT hres = pChannel->GetBuffer(&msg, IID_IWbemRefresher);
    if(FAILED(hres)) return hres;

    *(DWORD*)msg.Buffer = GetCurrentProcessId();

    // Invoke the method
    // =================

    ULONG dwRes;
    hres = pChannel->SendReceive(&msg, &dwRes);
    if(FAILED(hres))
    {
        if(msg.Buffer)
            pChannel->FreeBuffer(&msg);
        return dwRes;
    }

    // We are fine --- read the event data
    // ===================================

    m_EventPair.ReadData(msg.Buffer);
    pChannel->FreeBuffer(&msg);
    return S_OK;
}

void STDMETHODCALLTYPE CProxyBuffer::Disconnect()
{
    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

STDMETHODIMP CProxyBuffer::XRefresher::Refresh(long lFlags)
{
    return m_pObject->m_EventPair.SetAndWait();
}

CProxyBuffer::~CProxyBuffer()
{
    if(m_pChannel)
        m_pChannel->Release();
    m_pControl->ObjectDestroyed(this);
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************

void* CStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XStub;
    else
        return NULL;
}

CRefreshDispatcher CStubBuffer::XStub::mstatic_Dispatcher;

CStubBuffer::XStub::XStub(CStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CStubBuffer>(pObj), m_pServer(NULL)
{
    m_EventPair.Create();
}

CStubBuffer::XStub::~XStub() 
{
    if(m_pServer)
        m_pServer->Release();
}

STDMETHODIMP CStubBuffer::XStub::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemRefresher, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // Inform the listener of this connection
    // ======================================

    hres = mstatic_Dispatcher.Add(m_EventPair.GetGoEvent(), 
                        m_EventPair.GetDoneEvent(), m_pServer);
    if(FAILED(hres))
        return E_UNEXPECTED;

    return S_OK;
}

void STDMETHODCALLTYPE CStubBuffer::XStub::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = mstatic_Dispatcher.Remove(m_pServer);

    if(m_pServer)
        m_pServer->Release();
}

STDMETHODIMP CStubBuffer::XStub::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // Must be the proxy asking us for the data
    // ========================================

    if(pMessage->cbBuffer != sizeof(DWORD) || pMessage->iMethod != 3)
    {
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;
    }

    // Read the process id
    // ===================

    DWORD dwClientPID = *(DWORD*)pMessage->Buffer;
    
    // Allocate a new buffer
    // =====================

    pMessage->cbBuffer = m_EventPair.GetDataLength();
    HRESULT hres = pChannel->GetBuffer(pMessage, IID_IWbemRefresher);
    if(FAILED(hres)) return hres;

    // Put the info in there
    // =====================

    m_EventPair.WriteData(dwClientPID, pMessage->Buffer);
    return S_OK;
}

IRpcStubBuffer* STDMETHODCALLTYPE CStubBuffer::XStub::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemRefresher)
    {
        AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CStubBuffer::XStub::CountRefs()
{
    return 1; // ?? not sure
}

STDMETHODIMP CStubBuffer::XStub::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CStubBuffer::XStub::DebugServerRelease(void* pv)
{
}

//****************************************************************************
//****************************************************************************
//                          EVENT PAIR
//****************************************************************************
//****************************************************************************


CEventPair::~CEventPair()
{
    CloseHandle(m_hGoEvent);
    CloseHandle(m_hDoneEvent);
}

void CEventPair::Create()
{
    SECURITY_DESCRIPTOR sd;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
    
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = &sd;

    m_hGoEvent = CreateEvent(&sa, FALSE, FALSE, NULL);
    m_hDoneEvent = CreateEvent(&sa, FALSE, FALSE, NULL);
}

DWORD CEventPair::GetDataLength()
{
    return 
        sizeof(DWORD) + // m_hGoEvent
        sizeof(DWORD);  // m_hDoneEvent
}

void CEventPair::WriteData(DWORD dwClientPID, void* pvBuffer)
{
    DWORD* pdwBuffer = (DWORD*)pvBuffer;

    // Open client process
    // ===================

    HANDLE m_hClient = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwClientPID);
    if(m_hClient == NULL)
    {
        long lRes = GetLastError();
        return;
    }

    // Duplicate handles
    // =================

    if(!DuplicateHandle(GetCurrentProcess(), m_hGoEvent, m_hClient, 
        (HANDLE*)pdwBuffer, EVENT_MODIFY_STATE, FALSE, 0))
    {
        long lRes = GetLastError();
        return;
    }

    if(!DuplicateHandle(GetCurrentProcess(), m_hDoneEvent, m_hClient,
        (HANDLE*)(pdwBuffer + 1), SYNCHRONIZE, FALSE, 0))
    {
        long lRes = GetLastError();
        return;
    }
}

void CEventPair::ReadData(void* pvBuffer)
{
    DWORD* pdwBuffer = (DWORD*)pvBuffer;

    m_hGoEvent = (HANDLE)pdwBuffer[0];
    m_hDoneEvent = (HANDLE)pdwBuffer[1];
}

HRESULT CEventPair::SetAndWait()
{
    SetEvent(m_hGoEvent);
    DWORD dwRes = WaitForSingleObject(m_hDoneEvent, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return WBEM_E_CRITICAL_ERROR;

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//****************************************************************************
//                          DISPATCHER
//****************************************************************************
//****************************************************************************

CRefreshDispatcher::CRefreshDispatcher() : m_hThread(NULL)
{
    m_hAttentionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hAcceptanceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CRefreshDispatcher::~CRefreshDispatcher()
{
    CloseHandle(m_hAttentionEvent);
    CloseHandle(m_hAcceptanceEvent);
}

BOOL CRefreshDispatcher::Add(HANDLE hGoEvent, HANDLE hDoneEvent, 
                                IWbemRefresher* pRefresher)
{
    CInCritSec ics(&m_cs); // all work in critical section

    // Store the data for the thread
    // =============================

    m_hNewGoEvent = hGoEvent;
    m_hNewDoneEvent = hDoneEvent;
    m_pNewRefresher = pRefresher;

    // Set attention event
    // ===================

    SetEvent(m_hAttentionEvent);

    // Make sure the thread is running
    // ===============================

    if(m_hThread == NULL)
    {
        DWORD dw;
        m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&staticWorker,
                        (void*)this, 0, &dw);
        if(m_hThread == NULL)
            return FALSE;
    }

    // Wait for the thread to accept
    // =============================

    DWORD dwRes = WaitForSingleObject(m_hAcceptanceEvent, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return FALSE;

    return TRUE;
}

BOOL CRefreshDispatcher::Remove(IWbemRefresher* pRefresher)
{
    CInCritSec ics(&m_cs); // all work in critical section

    // Store the data for the thread
    // =============================

    m_hNewGoEvent = NULL;
    m_hNewDoneEvent = NULL;
    m_pNewRefresher = pRefresher;

    // Set attention event
    // ===================

    SetEvent(m_hAttentionEvent);

    // Check if the thread is running
    // ==============================

    if(m_hThread == NULL)
    {
        return FALSE;
    }

    // Wait for the thread to accept
    // =============================

    DWORD dwRes = WaitForSingleObject(m_hAcceptanceEvent, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return FALSE;

    return TRUE;
}

BOOL CRefreshDispatcher::Stop()
{
    CInCritSec ics(&m_cs); // all work in critical section

    // Check if the thread is running
    // ==============================

    if(m_hThread == NULL)
    {
        return TRUE;
    }

    // Store the data for the thread
    // =============================

    m_hNewGoEvent = NULL;
    m_hNewDoneEvent = NULL;
    m_pNewRefresher = NULL;

    // Set attention event
    // ===================

    SetEvent(m_hAttentionEvent);

    // Wait for the thread to accept
    // =============================

    DWORD dwRes = WaitForSingleObject(m_hThread, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return FALSE;

    CloseHandle(m_hThread);
    m_hThread = NULL;
    return TRUE;
}
    

DWORD CRefreshDispatcher::staticWorker(void* pv)
{
    return ((CRefreshDispatcher*)pv)->Worker();
}

DWORD CRefreshDispatcher::Worker()
{
    // Add the attention event to our array
    // ====================================

    m_aGoEvents.Add((void*)m_hAttentionEvent);
    m_apRecords.Add(NULL);

    while(1)
    {
        // Wait for any go event to be signaled
        // ====================================

        DWORD dwRes = WaitForMultipleObjects(m_aGoEvents.Size(), 
                        (HANDLE*)m_aGoEvents.GetArrayPtr(), FALSE, INFINITE);
        if(dwRes == WAIT_FAILED || dwRes == WAIT_TIMEOUT)
        {
            // TBD: log
            Sleep(1000);
            continue;
        }

        int nIndex = dwRes - WAIT_OBJECT_0;
        if(nIndex == 0)
        {
            // Attention event is signaled --- someone wants something from us
            // ===============================================================

            if(!ProcessAttentionRequest())
            {
                m_aGoEvents.Empty();
                m_apRecords.RemoveAll();
                m_hThread = NULL;
                return 0;
            }
        }
        else
        {
            // Normal event --- refresh something
            // ==================================

            HRESULT hres = m_apRecords[nIndex]->m_pRefresher->Refresh(0);
            // TBD: do something about failures

            SetEvent(m_apRecords[nIndex]->m_hDoneEvent);
        }
    }
}

BOOL CRefreshDispatcher::ProcessAttentionRequest()
{
    BOOL bRes;
    if(m_pNewRefresher == NULL)
    {
        // Time to quit!
        // =============

        bRes = FALSE;
    }
    else if(m_hNewGoEvent == NULL)
    {
        // Remove refresher
        // ================

        for(int i = 1; i < m_apRecords.GetSize(); i++)
        {
            CRecord* pRecord= m_apRecords[i];
            if(pRecord->m_pRefresher == m_pNewRefresher)
            {
                m_apRecords.RemoveAt(i);
                m_aGoEvents.RemoveAt(i);
                i--;
            }
        }
        bRes = (m_apRecords.GetSize() > 1);
    }
    else    
    {
        // Add refresher
        // =============

        CRecord* pRecord = new CRecord(m_pNewRefresher, m_hNewDoneEvent);
        m_apRecords.Add(pRecord);
        m_aGoEvents.Add((void*)m_hNewGoEvent);
        bRes = TRUE;
    }

    SetEvent(m_hAcceptanceEvent);
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrsvc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRSVC.CPP

Abstract:

  CWbemRefreshingSvc implementation.

  Implements the IWbemRefreshingServices interface.

History:

  24-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "refrhelp.h"
#include "refrsvc.h"
#include "arrtempl.h"
#include "scopeguard.h"

//***************************************************************************
//
//  CWbemRefreshingSvc::CWbemRefreshingSvc
//
//***************************************************************************
// ok
CWbemRefreshingSvc::CWbemRefreshingSvc( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_pSvcEx( NULL ),
	m_pstrMachineName( NULL ),
	m_pstrNamespace( NULL ),
	m_XWbemRefrSvc( this ),
	m_XCfgRefrSrvc(this)
{
	if ( NULL != pOuter )
	{
		if ( SUCCEEDED( pOuter->QueryInterface( IID_IWbemServices, (void**) &m_pSvcEx ) ) )
		{
			// It's aggregated us, so we shouldn't keep it Addref'd lest we cause
			// a circular reference.
			m_pSvcEx->Release();
		}

	}

	// Establish the refresher manager pointer now

}
    
//***************************************************************************
//
//  CWbemRefreshingSvc::~CWbemRefreshingSvc
//
//***************************************************************************
// ok
CWbemRefreshingSvc::~CWbemRefreshingSvc()
{
	// Cleanup.  Don't worry about the Svc Ex pointer, since this
	// will be aggregating us
	if ( NULL != m_pstrMachineName )
	{
		SysFreeString( m_pstrMachineName );
	}

	if ( NULL != m_pstrNamespace )
	{
		SysFreeString( m_pstrNamespace );
	}

}

// Override that returns us an interface
void* CWbemRefreshingSvc::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemRefreshingServices)
        return &m_XWbemRefrSvc;
	else if ( riid == IID__IWbemConfigureRefreshingSvcs )
		return &m_XCfgRefrSrvc;
    else
        return NULL;
}

// Pass thru _IWbemConfigureRefreshingSvc implementation
STDMETHODIMP CWbemRefreshingSvc::XCfgRefrSrvc::SetServiceData( BSTR pwszMachineName, BSTR pwszNamespace )
{
	return m_pObject->SetServiceData( pwszMachineName, pwszNamespace );
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::AddEnumToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszClass, long lFlags,
			IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
	return m_pObject->AddEnumToRefresher( pRefresherId, wszClass, lFlags, pContext, dwClientRefrVersion,
											pInfo, pdwSvrRefrVersion );
}

// Pass thru IWbemRefreshingServices implementation
STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::AddObjectToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszPath, long lFlags,
			IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
	return m_pObject->AddObjectToRefresher( pRefresherId, wszPath, lFlags, pContext, dwClientRefrVersion,
											pInfo, pdwSvrRefrVersion);
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::AddObjectToRefresherByTemplate( WBEM_REFRESHER_ID* pRefresherId, IWbemClassObject* pTemplate,
			long lFlags, IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
	return m_pObject->AddObjectToRefresherByTemplate( pRefresherId, pTemplate, lFlags, pContext,
														dwClientRefrVersion, pInfo, pdwSvrRefrVersion);
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::RemoveObjectFromRefresher( WBEM_REFRESHER_ID* pRefresherId, long lId, long lFlags,
			DWORD dwClientRefrVersion, DWORD* pdwSvrRefrVersion)
{
	return m_pObject->RemoveObjectFromRefresher( pRefresherId, lId, lFlags, dwClientRefrVersion,
												pdwSvrRefrVersion );
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, DWORD dwClientRefrVersion,
			IWbemRemoteRefresher** ppRemRefresher, GUID* pGuid, DWORD* pdwSvrRefrVersion)
{
	return m_pObject->GetRemoteRefresher( pRefresherId, lFlags, dwClientRefrVersion, ppRemRefresher, pGuid,
											pdwSvrRefrVersion );
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::ReconnectRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, long lNumObjects,
			DWORD dwClientRefrVersion, WBEM_RECONNECT_INFO* apReconnectInfo, WBEM_RECONNECT_RESULTS* apReconnectResults, DWORD* pdwSvrRefrVersion)
{
	return m_pObject->ReconnectRemoteRefresher( pRefresherId, lFlags, lNumObjects, dwClientRefrVersion,
											apReconnectInfo, apReconnectResults, pdwSvrRefrVersion);
}

/* IWbemRefreshingServices implemetation */
HRESULT CWbemRefreshingSvc::AddObjectToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszObjectPath, long lFlags,
			IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
    // Validate parameters
    // ===================

    if(wszObjectPath == NULL || pInfo == NULL || pdwSvrRefrVersion == NULL || pRefresherId == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// If the client process is Winmgmt, we refuse the operation
	if ( IsWinmgmt( pRefresherId ) )
	{
		return WBEM_E_INVALID_OPERATION;
	}

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    ((CRefreshInfo*)pInfo)->SetInvalid();

    IWbemClassObject*   pInst = NULL;

    // Use the helper function create the template
    HRESULT hres = CreateRefreshableObjectTemplate( wszObjectPath, lFlags, &pInst );
    CReleaseMe  rm(pInst);

    if ( SUCCEEDED( hres ) )
    {
        hres = AddObjectToRefresher( ( dwClientRefrVersion >= WBEM_REFRESHER_VERSION ),
									pRefresherId, (CWbemObject*)pInst, lFlags,
                                    pContext, pInfo);
    }

    return hres;
}

HRESULT CWbemRefreshingSvc::AddObjectToRefresherByTemplate( WBEM_REFRESHER_ID* pRefresherId, IWbemClassObject* pTemplate,
			long lFlags, IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
    // Validate parameters
    // ===================

    if(pTemplate == NULL || pInfo == NULL || pdwSvrRefrVersion == NULL || pRefresherId == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// If the client process is Winmgmt, we refuse the operation
	if ( IsWinmgmt( pRefresherId ) )
	{
		return WBEM_E_INVALID_OPERATION;
	}

    // Set the version for return --- add client version checking logic here
    // For now, this really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    HRESULT hres = AddObjectToRefresher( ( dwClientRefrVersion >= WBEM_REFRESHER_VERSION ),
									pRefresherId, (CWbemObject*)pTemplate, lFlags,
                                    pContext, pInfo);
    return hres;
}

HRESULT CWbemRefreshingSvc::AddEnumToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszClass, long lFlags,
			IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{


    // Validate parameters
    // ===================

    if(wszClass == NULL || pInfo == NULL || pdwSvrRefrVersion == NULL || pRefresherId == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// If the client process is Winmgmt, we refuse the operation
	if ( IsWinmgmt( pRefresherId ) )
	{
		return WBEM_E_INVALID_OPERATION;
	}

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    ((CRefreshInfo*)pInfo)->SetInvalid();

    // =============================
    // TBD: check the namespace part
    // =============================

    // Get the class
    // =============

    IWbemClassObject* pClass = NULL;

    // Note that WBEM_FLAG_USE_AMENDED_QUALIFIERS is a valid flag.

	// Must use a BSTR in case the call gets marshaled
	BSTR	bstrClass = SysAllocString( wszClass );
	if ( NULL == bstrClass )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CSysFreeMe	sfm( bstrClass );

    HRESULT hres = m_pSvcEx->GetObject( bstrClass, lFlags, NULL, &pClass, NULL);
    CReleaseMe  rmClass( pClass );
    if(FAILED(hres))
    {
        return WBEM_E_INVALID_CLASS;
    }

    // Spawn an instance and decorate it
    // =================================

    IWbemClassObject* pInst = NULL;
    hres = pClass->SpawnInstance(0, &pInst);
    CReleaseMe  rmInst( pInst );

    if ( SUCCEEDED( hres ) )
    {
        // Make sure the object has a namespace
		hres = ((_IWmiObject*) pInst)->SetDecoration( m_pstrMachineName, m_pstrNamespace );

        if ( SUCCEEDED( hres ) )
        {
            // Delegate to object aware function
            // ================================

            hres = AddEnumToRefresher( ( dwClientRefrVersion >= WBEM_REFRESHER_VERSION ),
										pRefresherId, (CWbemObject*) pInst, wszClass, lFlags,
                                        pContext, pInfo);
        }

    }

	return hres;

}

HRESULT CWbemRefreshingSvc::RemoveObjectFromRefresher( WBEM_REFRESHER_ID* pRefresherId, long lId, long lFlags,
			DWORD dwClientRefrVersion, DWORD* pdwSvrRefrVersion)
{

    if(pdwSvrRefrVersion == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// If the client process is Winmgmt, we refuse the operation
	if ( IsWinmgmt( pRefresherId ) )
	{
		return WBEM_E_INVALID_OPERATION;
	}

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

//    return ConfigMgr::GetRefresherCache()->RemoveObjectFromRefresher(
//                (CRefresherId*)pRefresherId, lRequestId, lFlags);

    return WBEM_E_NOT_AVAILABLE;
}

HRESULT CWbemRefreshingSvc::GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, DWORD dwClientRefrVersion,
			IWbemRemoteRefresher** ppRemRefresher, GUID* pGuid, DWORD* pdwSvrRefrVersion)
{

    HRESULT hres = WBEM_S_NO_ERROR;

    if ( NULL == ppRemRefresher || 0l != lFlags || NULL == pGuid || NULL == pdwSvrRefrVersion || pRefresherId == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	// If the client process is Winmgmt, we refuse the operation
	if ( IsWinmgmt( pRefresherId ) )
	{
		return WBEM_E_INVALID_OPERATION;
	}

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers

	_IWbemRefresherMgr*	pRefrMgr = NULL;
	hres = GetRefrMgr( &pRefrMgr );
	CReleaseMe	rm( pRefrMgr );

	if ( SUCCEEDED( hres ) )
	{
		*pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

		hres = CoSetProxyBlanket( pRefrMgr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

		if ( SUCCEEDED( hres ) || ( hres ==  E_NOINTERFACE ) )
		{

			// Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
			// is created, then we will AddRef the refrmgr in the provider cache and
			// keep it from getting prematurely unloaded.

			// This should add a remote refresher if it does not exist
			hres = pRefrMgr->GetRemoteRefresher( pRefresherId, 0L, TRUE, ppRemRefresher, pRefrMgr, pGuid );

			// If the client version number is too small, then we need to wrap the remote refresher
			// through Winmgmt.

			if ( SUCCEEDED( hres ) && dwClientRefrVersion < WBEM_REFRESHER_VERSION )
			{
				hres = WrapRemoteRefresher( ppRemRefresher );
			}

		}

	}	// IF GetRefrMgr

    return hres;
}

HRESULT CWbemRefreshingSvc::ReconnectRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, long lNumObjects,
			DWORD dwClientRefrVersion, WBEM_RECONNECT_INFO* apReconnectInfo, WBEM_RECONNECT_RESULTS* apReconnectResults, DWORD* pdwSvrRefrVersion)
{


    HRESULT hr = WBEM_S_NO_ERROR;

    if (0l != lFlags || NULL == apReconnectResults || NULL == apReconnectInfo || NULL == pdwSvrRefrVersion || pRefresherId == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

	// If the client process is Winmgmt, we refuse the operation
	if ( IsWinmgmt( pRefresherId ) )
	{
		return WBEM_E_INVALID_OPERATION;
	}

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

	_IWbemRefresherMgr*	pRefrMgr = NULL;
	hr = GetRefrMgr( &pRefrMgr );
	CReleaseMe	rm( pRefrMgr );

	if ( SUCCEEDED( hr ) )
	{

		// If we can get a remote refresher refresher, then we will need to walk
		// our list of objects and manually re-add them.  If we can't get the remote,
		// then something is badly wrong, so we cannot continue with this operation.


		hr = CoSetProxyBlanket( pRefrMgr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );
	}

	IWbemRemoteRefresher*	pRemRefr = NULL;

	if ( SUCCEEDED( hr ) || ( hr ==  E_NOINTERFACE ) )
	{
		GUID					guid;

		// Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
		// is created, then we will AddRef the refrmgr in the provider cache and
		// keep it from getting prematurely unloaded.

		// Need to change this to NOT add a refresher if it doesn't exist
		hr = pRefrMgr->GetRemoteRefresher( pRefresherId, 0L, FALSE, &pRemRefr, pRefrMgr, &guid );
	}

	CReleaseMe	rm2( pRemRefr );

    if ( WBEM_S_NO_ERROR == hr )
    {
        // We need to manually walk the list and get ids, return codes and a remote refresher

        // Make sure we have no NULLs, and all types are valid (e.g. must specify either
        // an object or an enum.
        for ( long lCtr = 0; ( SUCCEEDED(hr) && lCtr < lNumObjects ); lCtr++ )
        {
            if ( NULL == apReconnectInfo[lCtr].m_pwcsPath ||
                apReconnectInfo[lCtr].m_lType >= WBEM_RECONNECT_TYPE_LAST )
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            for ( lCtr = 0; lCtr < lNumObjects; lCtr++ )
            {
                DWORD           dwDummyVersion;
                CRefreshInfo    Info;

                // Well, it's either an object or an enumerator.

                if ( WBEM_RECONNECT_TYPE_OBJECT == apReconnectInfo[lCtr].m_lType )
                {
                    hr = AddObjectToRefresher( (CRefresherId*) pRefresherId, apReconnectInfo[lCtr].m_pwcsPath,
                            0L, NULL, dwClientRefrVersion, &Info, &dwDummyVersion );
                }
                else
                {
                    hr = AddEnumToRefresher( (CRefresherId*) pRefresherId, apReconnectInfo[lCtr].m_pwcsPath,
                            0L, NULL, dwClientRefrVersion, &Info, &dwDummyVersion );
                }

                // Store the hresult
                apReconnectResults[lCtr].m_hr = hr;

                // If the add succeeds, store the id and if we haven't already, the remote
                // refresher

                if ( SUCCEEDED( hr ) )
                {
                    apReconnectResults[lCtr].m_lId = Info.m_lCancelId;
                }   // IF Add succeeded

            }   // FOR Enum Counters

        }   // If valid string array

    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

HRESULT CWbemRefreshingSvc::AddObjectToRefresher( BOOL fVersionMatch, WBEM_REFRESHER_ID* pRefresherId, CWbemObject* pInstTemplate, long lFlags, IWbemContext* pContext,
													WBEM_REFRESH_INFO* pInfo)
{
    if(!pInstTemplate->IsInstance())
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hres;

    // Get the class definition
    // ========================

    CVar vClassName;
    pInstTemplate->GetClassName(&vClassName);

    IWbemClassObject* pObj = NULL;

	// Must use a BSTR in case the call gets marshaled
	BSTR	bstrClass = SysAllocString( vClassName.GetLPWSTR() );
	if ( NULL == bstrClass )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CSysFreeMe	sfm( bstrClass );

    hres = m_pSvcEx->GetObject( bstrClass, 0, NULL, &pObj, NULL );
	CReleaseMe	rmClass( pObj );

    if(FAILED(hres))
    {
        return WBEM_E_INVALID_CLASS;
    }

    // Get the refresher from that provider (or a surrogate)
    // =====================================================

	// We need to have full impersonation for this to work

	_IWbemRefresherMgr*	pRefrMgr = NULL;
	hres = GetRefrMgr( &pRefrMgr );
	CReleaseMe	rm( pRefrMgr );

	if ( SUCCEEDED( hres ) )
	{
		// Impersonate before making a x-process call.
		hres = CoImpersonateClient();

		if ( SUCCEEDED( hres ) || ( hres == E_NOINTERFACE ) )
		{

			hres = CoSetProxyBlanket( pRefrMgr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
									RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

			if ( SUCCEEDED( hres ) || ( hres ==  E_NOINTERFACE ) )
			{
				// Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
				// is created, then we will AddRef the refrmgr in the provider cache and
				// keep it from getting prematurely unloaded.

				hres = pRefrMgr->AddObjectToRefresher( m_pSvcEx, m_pstrMachineName, m_pstrNamespace, pObj,
														pRefresherId, pInstTemplate, lFlags, pContext, pRefrMgr, pInfo );

				// Reset portions of the RefreshInfo structure as appropriate
				if ( SUCCEEDED( hres ) && !fVersionMatch )
				{
					hres = ResetRefreshInfo( pInfo );
				}

			}

			CoRevertToSelf();

		}	// If CoImpersonateClient

	}	// IF GetRefrMgr

    return hres;

}

HRESULT CWbemRefreshingSvc::CreateRefreshableObjectTemplate( LPCWSTR wszObjectPath, long lFlags, IWbemClassObject** ppInst )
{
    // Validate parameters
    // ===================

    if( NULL == wszObjectPath || NULL == ppInst )
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path
    // ==============
    ParsedObjectPath* pOutput = 0;

    CObjectPathParser p;
    int nStatus = p.Parse((LPWSTR)wszObjectPath,  &pOutput);

    if (nStatus != 0 || !pOutput->IsInstance())
    {
        // Cleanup the output pointer if it was allocated
        if ( NULL != pOutput )
        {
            p.Free(pOutput);
        }

        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ON_BLOCK_EXIT_OBJ(p, (void (CObjectPathParser::*)(ParsedObjectPath *))CObjectPathParser::Free, pOutput);

    // =============================
    // TBD: check the namespace part
    // =============================

    // Get the class
    // =============

    IWbemClassObject* pClass = NULL;

	// Must use a BSTR in case the call gets marshaled
	BSTR	bstrClass = SysAllocString( pOutput->m_pClass );
	if ( NULL == bstrClass )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CSysFreeMe	sfm( bstrClass );

    // Note that WBEM_FLAG_USE_AMENDED_QUALIFIERS is a valid flag
    HRESULT hres = m_pSvcEx->GetObject( bstrClass, lFlags, NULL, &pClass, NULL);
    if(FAILED(hres))
    {
        return WBEM_E_INVALID_CLASS;
    }

    // Spawn and fill the instance
    // ===========================

    IWbemClassObject* pInst = NULL;
    hres = pClass->SpawnInstance(0, &pInst);    
    pClass->Release();
    if (FAILED(hres))
    {    
        return hres;
    }

    for(DWORD i = 0; i < pOutput->m_dwNumKeys; i++)
    {
        KeyRef* pKeyRef = pOutput->m_paKeys[i];

        WString wsPropName;
        if(pKeyRef->m_pName == NULL)
        {
            // No key name --- get the key.
            // ============================

            CWStringArray awsKeys;
            ((CWbemInstance*)pInst)->GetKeyProps(awsKeys);
            if(awsKeys.Size() != 1)
            {
                pInst->Release();
                return WBEM_E_INVALID_OBJECT;
            }
            wsPropName = awsKeys[0];
        }
        else wsPropName = pKeyRef->m_pName;

        // Compute variant type of the property
        // ====================================

        CIMTYPE ctPropType;
        hres = pInst->Get(wsPropName, 0, NULL, &ctPropType, NULL);
        if(FAILED(hres))
        {
            pInst->Release();
            return WBEM_E_INVALID_PARAMETER;
        }

        VARTYPE vtVariantType = CType::GetVARTYPE(ctPropType);

        // Set the value into the instance
        // ===============================

        if(vtVariantType != V_VT(&pKeyRef->m_vValue))
        {
            hres = VariantChangeType(&pKeyRef->m_vValue, &pKeyRef->m_vValue, 0,
                        vtVariantType);
        }
        if(FAILED(hres))
        {
            pInst->Release();
            return WBEM_E_INVALID_PARAMETER;
        }

        hres = pInst->Put(wsPropName, 0, &pKeyRef->m_vValue, 0);
        if(FAILED(hres))
        {
            pInst->Release();
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    // Caller must free this guy up
    *ppInst = pInst;

    return hres;
}

HRESULT CWbemRefreshingSvc::AddEnumToRefresher(
        BOOL fVersionMatch, WBEM_REFRESHER_ID* pRefresherId,
        CWbemObject* pInstTemplate, LPCWSTR wszClass, long lFlags,
        IWbemContext* pContext, WBEM_REFRESH_INFO* pInfo)
{

    HRESULT hres;

    // Get the class definition
    // ========================

	// Must use a BSTR in case the call gets marshaled
	BSTR	bstrClass = SysAllocString( wszClass );
	if ( NULL == bstrClass )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CSysFreeMe	sfm( bstrClass );

    IWbemClassObject* pObj = NULL;
    hres = m_pSvcEx->GetObject( bstrClass, 0, NULL, &pObj, NULL);
	CReleaseMe	rmClass( pObj );

    if(FAILED(hres))
    {
        return WBEM_E_INVALID_CLASS;
    }

    // Get the refresher from that provider (or a surrogate)
    // =====================================================

	// We need to have full impersonation for this to work

	_IWbemRefresherMgr*	pRefrMgr = NULL;
	hres = GetRefrMgr( &pRefrMgr );
	CReleaseMe	rm( pRefrMgr );

	if ( SUCCEEDED( hres ) )
	{
		// Impersonate before making a x-process call.
		hres = CoImpersonateClient();

		if ( SUCCEEDED( hres ) || ( hres ==  E_NOINTERFACE ) )
		{
			hres = CoSetProxyBlanket( pRefrMgr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
									RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

			if ( SUCCEEDED( hres ) || ( hres ==  E_NOINTERFACE ) )
			{
				// Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
				// is created, then we will AddRef the refrmgr in the provider cache and
				// keep it from getting prematurely unloaded.
				hres = pRefrMgr->AddEnumToRefresher( m_pSvcEx, m_pstrMachineName, m_pstrNamespace, pObj,
														pRefresherId, pInstTemplate, wszClass,
														lFlags, pContext, pRefrMgr, pInfo );

				// Reset portions of the RefreshInfo structure as appropriate
				if ( SUCCEEDED( hres ) && !fVersionMatch )
				{
					hres = ResetRefreshInfo( pInfo );
				}
			}

			CoRevertToSelf();
		}	

	}	// IF GetRefrMgr

    return hres;

}

// Actual _IWbemConfigureRefreshingSvc implementation
HRESULT CWbemRefreshingSvc::SetServiceData( BSTR pwszMachineName, BSTR pwszNamespace )
{
	// We're in deep kimchee already
	if ( NULL == m_pSvcEx  )
	{
		return WBEM_E_FAILED;
	}

	if ( NULL == pwszMachineName || NULL == pwszNamespace )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	if ( NULL == m_pstrMachineName )
	{
		m_pstrMachineName = SysAllocString( pwszMachineName );
	}

	if ( NULL == m_pstrNamespace )
	{
		m_pstrNamespace = SysAllocString( pwszNamespace );
	}

	// Cleanup and error out
	if ( NULL == m_pstrMachineName || NULL == m_pstrNamespace )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	return WBEM_S_NO_ERROR;
}

BOOL CWbemRefreshingSvc::IsWinmgmt( WBEM_REFRESHER_ID* pRefresherId )
{
	// For now, we assume that this code is only instantiated inside Winmgmt, so we only check the
	// refresher id for its process id an compare it to the current process id.  If they match, this
	// means that a provider in-proc to Winmgmt is using a refresher.  This is not allowed, hence
	// this call will return TRUE and the request will be refused

	return ( pRefresherId->m_dwProcessId == GetCurrentProcessId() );
	
}

HRESULT	CWbemRefreshingSvc::GetRefrMgr( _IWbemRefresherMgr** ppMgr )
{
	// Grabs a refresher manager fetcher each time we need one, and returns
	// a refresher manager pointer.  This ensures that we only create this when
	// it is required, AND that the manager is appropriate to the apartment
	// we are being called on.

	_IWbemFetchRefresherMgr*	pFetchRefrMgr = NULL;

	HRESULT	hr = CoCreateInstance( CLSID__WbemFetchRefresherMgr, NULL, CLSCTX_INPROC_SERVER,
						IID__IWbemFetchRefresherMgr, (void**) &pFetchRefrMgr );
	CReleaseMe	rm( pFetchRefrMgr );

	if ( SUCCEEDED( hr ) )
	{
		hr = pFetchRefrMgr->Get( ppMgr );
	}

	return hr;
}

HRESULT CWbemRefreshingSvc::ResetRefreshInfo( WBEM_REFRESH_INFO* pRefreshInfo )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( pRefreshInfo->m_lType == WBEM_REFRESH_TYPE_REMOTE )
	{
		hr = WrapRemoteRefresher( &pRefreshInfo->m_Info.m_Remote.m_pRefresher );
	}	// IF Remote Refreshing

	return hr;
}

HRESULT CWbemRefreshingSvc::WrapRemoteRefresher( IWbemRemoteRefresher** ppRemoteRefresher )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	CWbemRemoteRefresher*	pRemRefr = new CWbemRemoteRefresher( m_pControl,
																*ppRemoteRefresher );

	if ( NULL != pRemRefr )
	{
		IWbemRemoteRefresher*	pTempRefr = *ppRemoteRefresher;

		hr = pRemRefr->QueryInterface( IID_IWbemRemoteRefresher, (void**) ppRemoteRefresher );

		// Release the original interface
		if ( NULL != pTempRefr )
		{
			pTempRefr->Release();
		}

		if ( FAILED( hr ) )
		{
			*ppRemoteRefresher = NULL;
			delete pRemRefr;
		}

	}	// IF NULL != pRemRefr

	return hr;
}

//***************************************************************************
//
//  CWbemRemoteRefresher::CWbemRemoteRefresher
//
//***************************************************************************
// ok
CWbemRemoteRefresher::CWbemRemoteRefresher( CLifeControl* pControl, IWbemRemoteRefresher* pRemRefr, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_pRemRefr( pRemRefr ),
	m_XWbemRemoteRefr( this )
{
	if ( NULL != m_pRemRefr )
	{
		m_pRemRefr->AddRef();
	}
}
    
//***************************************************************************
//
//  CWbemRemoteRefresher::~CWbemRemoteRefresher
//
//***************************************************************************
// ok
CWbemRemoteRefresher::~CWbemRemoteRefresher()
{
	if ( NULL != m_pRemRefr )
	{
		m_pRemRefr->Release();
	}
}

// Override that returns us an interface
void* CWbemRemoteRefresher::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemRemoteRefresher)
        return &m_XWbemRemoteRefr;
    else
        return NULL;
}

// Pass thru IWbemRemoteRefresher implementation
STDMETHODIMP CWbemRemoteRefresher::XWbemRemoteRefr::RemoteRefresh( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects )
{
	return m_pObject->RemoteRefresh( lFlags, plNumObjects, paObjects );
}

STDMETHODIMP CWbemRemoteRefresher::XWbemRemoteRefr::StopRefreshing( long lNumIds, long* aplIds, long lFlags)
{
	return m_pObject->StopRefreshing( lNumIds, aplIds, lFlags);
}

STDMETHODIMP CWbemRemoteRefresher::XWbemRemoteRefr::GetGuid( long lFlags, GUID*  pGuid )
{
	return m_pObject->GetGuid( lFlags, pGuid );
}

// Actual Implementation code
HRESULT CWbemRemoteRefresher::RemoteRefresh( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects )
{
	// Impersonate before making a x-process call.
	HRESULT hres = CoImpersonateClient();

	if ( SUCCEEDED( hres ) )
	{
		hres = CoSetProxyBlanket( m_pRemRefr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

		if ( SUCCEEDED( hres ) )
		{
			hres = m_pRemRefr->RemoteRefresh( lFlags, plNumObjects, paObjects );
		}

		CoRevertToSelf();
	}

	return hres;
}

HRESULT CWbemRemoteRefresher::StopRefreshing( long lNumIds, long* aplIds, long lFlags)
{
	// Impersonate before making a x-process call.
	HRESULT hres = CoImpersonateClient();

	if ( SUCCEEDED( hres ) )
	{
		hres = CoSetProxyBlanket( m_pRemRefr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

		if ( SUCCEEDED( hres ) )
		{
			hres = m_pRemRefr->StopRefreshing( lNumIds, aplIds, lFlags );
		}

		CoRevertToSelf();
	}

	return hres;
}

HRESULT CWbemRemoteRefresher::GetGuid( long lFlags, GUID*  pGuid )
{
	// Impersonate before making a x-process call.
	HRESULT hres = CoImpersonateClient();

	if ( SUCCEEDED( hres ) )
	{
		hres = CoSetProxyBlanket( m_pRemRefr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

		if ( SUCCEEDED( hres ) )
		{
			hres = m_pRemRefr->GetGuid( lFlags, pGuid );
		}

		CoRevertToSelf();
	}

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRMRSH.H

Abstract:

    Refresher marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemcomn.h>
#include <sync.h>

class CEventPair
{
protected:
    HANDLE m_hGoEvent;
    HANDLE m_hDoneEvent;
public:
    CEventPair() : m_hGoEvent(NULL), m_hDoneEvent(NULL){}
    ~CEventPair();

    HANDLE GetGoEvent() {return m_hGoEvent;}
    HANDLE GetDoneEvent() {return m_hDoneEvent;}

    void Create();
    DWORD GetDataLength();
    void WriteData(DWORD dwClientPID, void* pvBuffer);
    void ReadData(void* pvBuffer);
    HRESULT SetAndWait();
};

class CRefreshDispatcher
{
protected:
    CCritSec m_cs;

    CFlexArray m_aGoEvents;
    struct CRecord
    {
        IWbemRefresher* m_pRefresher;
        HANDLE m_hDoneEvent;

        CRecord(IWbemRefresher* pRefresher, HANDLE hDoneEvent)
            : m_pRefresher(pRefresher), m_hDoneEvent(hDoneEvent)
        {
            m_pRefresher->AddRef();
        }
        ~CRecord()
        {
            m_pRefresher->Release();
        }
    };

    CUniquePointerArray<CRecord> m_apRecords;
    HANDLE m_hAttentionEvent;
    HANDLE m_hAcceptanceEvent;

    HANDLE m_hNewGoEvent;
    HANDLE m_hNewDoneEvent;
    IWbemRefresher* m_pNewRefresher;

    HANDLE m_hThread;

protected:
    DWORD Worker();
    static DWORD staticWorker(void*);
    BOOL ProcessAttentionRequest();

public:
    CRefreshDispatcher();
    ~CRefreshDispatcher();

    BOOL Add(HANDLE hGoEvent, HANDLE hDoneEvent, 
                            IWbemRefresher* pRefresher);
    BOOL Remove(IWbemRefresher* pRefresher);
    BOOL Stop();
};

class CFactoryBuffer : public CUnk
{
protected:
    class XFactory : public CImpl<IPSFactoryBuffer, CFactoryBuffer>
    {
    public:
        XFactory(CFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XFactory;
public:
    CFactoryBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XFactory(this)
    {}
    void* GetInterface(REFIID riid);
};

/*
    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
    is its "internal" interface --- the interface that does not delegate to the
    aggregator. (Unlike in normal objects, where that interface is IUnknown)
*/
class CProxyBuffer : public IRpcProxyBuffer
{
protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XRefresher : public IWbemRefresher
    {
    protected:
        CProxyBuffer* m_pObject;
    public:
        XRefresher(CProxyBuffer* pObject) : m_pObject(pObject){}

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE Refresh(long lFlags);
    } m_XRefresher;
    friend XRefresher;

protected:
    IRpcChannelBuffer* m_pChannel;
    CEventPair m_EventPair;

public:
    CProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
        : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
            m_XRefresher(this), m_pChannel(NULL)
    {
        m_pControl->ObjectCreated(this);
    }
    ~CProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

class CStubBuffer : public CUnk
{
protected:
    class XStub : public CImpl<IRpcStubBuffer, CStubBuffer>
    {
        static CRefreshDispatcher mstatic_Dispatcher;

        CEventPair m_EventPair;
        IWbemRefresher* m_pServer;
    public:
        XStub(CStubBuffer* pObj);
        ~XStub();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
        friend CStubBuffer;
    } m_XStub;
    friend XStub;

public:
    CStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XStub(this)
    {}
    void* GetInterface(REFIID riid);
    static void Clear() {XStub::mstatic_Dispatcher.Stop();}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrhelp.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRHELP.H

Abstract:

    Refresher helpers

History:

--*/

#ifndef __REFRESH_HELPER__H_
#define __REFRESH_HELPER__H_

#include <wbemint.h>
#include "corepol.h"
#include "parmdefs.h"

// Use this id if we try to readd anobject or enum during a remote reconnection
// and this fails.

#define INVALID_REMOTE_REFRESHER_ID 0xFFFFFFFF

// NO VTABLE!!!
class COREPROX_POLARITY CRefresherId : public WBEM_REFRESHER_ID
{
public:
    CRefresherId();
    CRefresherId(const WBEM_REFRESHER_ID& Other);
    ~CRefresherId();

    INTERNAL LPCSTR GetMachineName() {return m_szMachineName;}
    DWORD GetProcessId() {return m_dwProcessId;}
    const GUID& GetId() {return m_guidRefresherId;}

    BOOL operator==(const CRefresherId& Other) 
        {return m_guidRefresherId == Other.m_guidRefresherId;}
};

// NO VTABLE!!!
class CWbemObject;
class COREPROX_POLARITY CRefreshInfo : public WBEM_REFRESH_INFO
{
public:
    CRefreshInfo();
    CRefreshInfo(const WBEM_REFRESH_INFO& Other);
    ~CRefreshInfo();

    void SetRemote(IWbemRemoteRefresher* pRemRef, long lRequestId,
                    IWbemObjectAccess* pTemplate, GUID* pGuid);
    void SetContinuous(CWbemObject* pRefreshedObject, 
                        long lExternalRequestId = 0);
    bool SetClientLoadable(REFCLSID rClientClsid, LPCWSTR wszNamespace,
                    IWbemObjectAccess* pTemplate);
    void SetDirect(REFCLSID rClientClsid, LPCWSTR wszNamespace, LPCWSTR wszProviderName,
                    IWbemObjectAccess* pTemplate, _IWbemRefresherMgr* pMgr);
    void SetShared(CWbemObject* pRefeshedObject, IWbemRefresher* pRefresher,
                    long lRequestId);
	void SetNonHiPerf(LPCWSTR wszNamespace, IWbemObjectAccess* pTemplate);
    void SetInvalid();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrsvc.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRSVC.H

Abstract:

  CWbemRefreshingSvc Definition.

  Standard definition for IWbemObjectTextSrc.

History:

  24-Apr-2000	sanjes    Created.

--*/

#ifndef _REFRSVC_H_
#define _REFRSVC_H_

#include "corepol.h"
#include <arena.h>

// Update this for server side refresher code.  Make sure to update client
// version in refrcli.h as well.
#define WBEM_REFRESHER_VERSION 1

//***************************************************************************
//
//  class CWbemRefreshingSvc
//
//  Implementation of _IWmiObjectFactory Interface
//
//***************************************************************************

class COREPROX_POLARITY CWbemRefreshingSvc : public CUnk
{
private:
	IWbemServices*		m_pSvcEx;
	_IWmiProviderFactory*	m_pProvFactory;
	BSTR					m_pstrMachineName;
	BSTR					m_pstrNamespace;

public:
    CWbemRefreshingSvc(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWbemRefreshingSvc(); 

protected:


    class COREPROX_POLARITY XWbemRefrSvc : public CImpl<IWbemRefreshingServices, CWbemRefreshingSvc>
    {
    public:
        XWbemRefrSvc(CWbemRefreshingSvc* pObject) : 
            CImpl<IWbemRefreshingServices, CWbemRefreshingSvc>(pObject)
        {}

		STDMETHOD(AddObjectToRefresher)( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszPath, long lFlags,
					IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
					DWORD* pdwSvrRefrVersion);

		STDMETHOD(AddObjectToRefresherByTemplate)( WBEM_REFRESHER_ID* pRefresherId, IWbemClassObject* pTemplate,
					long lFlags, IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
					DWORD* pdwSvrRefrVersion);

		STDMETHOD(AddEnumToRefresher)( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszClass, long lFlags,
					IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
					DWORD* pdwSvrRefrVersion);

		STDMETHOD(RemoveObjectFromRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lId, long lFlags,
					DWORD dwClientRefrVersion, DWORD* pdwSvrRefrVersion);

		STDMETHOD(GetRemoteRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lFlags, DWORD dwClientRefrVersion,
					IWbemRemoteRefresher** ppRemRefresher, GUID* pGuid, DWORD* pdwSvrRefrVersion);

		STDMETHOD(ReconnectRemoteRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lFlags, long lNumObjects,
					DWORD dwClientRefrVersion, WBEM_RECONNECT_INFO* apReconnectInfo,
					WBEM_RECONNECT_RESULTS* apReconnectResults, DWORD* pdwSvrRefrVersion);

    } m_XWbemRefrSvc;
    friend XWbemRefrSvc;

    class COREPROX_POLARITY XCfgRefrSrvc : public CImpl<_IWbemConfigureRefreshingSvcs, CWbemRefreshingSvc>
    {
    public:
        XCfgRefrSrvc(CWbemRefreshingSvc* pObject) : 
            CImpl<_IWbemConfigureRefreshingSvcs, CWbemRefreshingSvc>(pObject)
        {}

		STDMETHOD(SetServiceData)( BSTR pwszMachineName, BSTR pwszNamespace );
    } m_XCfgRefrSrvc;
    friend XCfgRefrSrvc;

protected:

	virtual HRESULT AddObjectToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszPath, long lFlags,
				IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
				DWORD* pdwSvrRefrVersion);

	virtual HRESULT AddObjectToRefresherByTemplate( WBEM_REFRESHER_ID* pRefresherId, IWbemClassObject* pTemplate,
				long lFlags, IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
				DWORD* pdwSvrRefrVersion);

	virtual HRESULT AddEnumToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszClass, long lFlags,
				IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
				DWORD* pdwSvrRefrVersion);

	virtual HRESULT RemoveObjectFromRefresher( WBEM_REFRESHER_ID* pRefresherId, long lId, long lFlags,
				DWORD dwClientRefrVersion, DWORD* pdwSvrRefrVersion);

	virtual HRESULT GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, DWORD dwClientRefrVersion,
				IWbemRemoteRefresher** ppRemRefresher, GUID* pGuid, DWORD* pdwSvrRefrVersion);

	virtual HRESULT ReconnectRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, long lNumObjects,
				DWORD dwClientRefrVersion, WBEM_RECONNECT_INFO* apReconnectInfo,
				WBEM_RECONNECT_RESULTS* apReconnectResults, DWORD* pdwSvrRefrVersion);

	virtual HRESULT SetServiceData( BSTR pwszMachineName, BSTR pwszNamespace );

	HRESULT ResetRefreshInfo( WBEM_REFRESH_INFO* pRefreshInfo );

	HRESULT WrapRemoteRefresher( IWbemRemoteRefresher** ppRemoteRefresher );

protected:
    void* GetInterface(REFIID riid);

	// Helper functions
	HRESULT AddObjectToRefresher( BOOL fVersionMatch, WBEM_REFRESHER_ID* pRefresherId, CWbemObject* pInstTemplate, long lFlags, IWbemContext* pContext,
									WBEM_REFRESH_INFO* pInfo);

	HRESULT CreateRefreshableObjectTemplate( LPCWSTR wszObjectPath, long lFlags, IWbemClassObject** ppInst );

	HRESULT AddEnumToRefresher( BOOL fVersionMatch, WBEM_REFRESHER_ID* pRefresherId, CWbemObject* pInstTemplate, LPCWSTR wszClass,
								long lFlags, IWbemContext* pContext, WBEM_REFRESH_INFO* pInfo);

	BOOL IsWinmgmt( WBEM_REFRESHER_ID* pRefresherId );

	HRESULT	GetRefrMgr( _IWbemRefresherMgr** ppMgr );

public:

	BOOL Initialize( void ) { return TRUE; }

};

class COREPROX_POLARITY CWbemRemoteRefresher : public CUnk
{
private:
	IWbemRemoteRefresher*		m_pRemRefr;

public:
    CWbemRemoteRefresher(CLifeControl* pControl, IWbemRemoteRefresher* pRemRefr, IUnknown* pOuter = NULL);
	virtual ~CWbemRemoteRefresher(); 

protected:


    class COREPROX_POLARITY XWbemRemoteRefr : public CImpl<IWbemRemoteRefresher, CWbemRemoteRefresher>
    {
    public:
        XWbemRemoteRefr(CWbemRemoteRefresher* pObject) : 
            CImpl<IWbemRemoteRefresher, CWbemRemoteRefresher>(pObject)
        {}

		STDMETHOD(RemoteRefresh)( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects );
		STDMETHOD(StopRefreshing)( long lNumIds, long* aplIds, long lFlags);
		STDMETHOD(GetGuid)( long lFlags, GUID*  pGuid );

    } m_XWbemRemoteRefr;
    friend XWbemRemoteRefr;

protected:

	virtual HRESULT RemoteRefresh( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects );
	virtual HRESULT StopRefreshing( long lNumIds, long* aplIds, long lFlags);
	virtual HRESULT GetGuid( long lFlags, GUID*  pGuid );

protected:
    void* GetInterface(REFIID riid);

public:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\rfchercd.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RFCHERCD.H

Abstract:

  Refresher cache record Definitions.

History:

  27-Apr-2000	sanjes    Created.

--*/

#ifndef __RFCHERCD_H__
#define __RFCHERCD_H__

#include "corepol.h"
#include <arena.h>
#include "sync.h"
#include "arrtempl.h"
#include "hiperfenum.h"

// Special Remote Hi-Perf Enumerator
class CRemoteHiPerfEnum : public CHiPerfEnum
{
public:

	CRemoteHiPerfEnum(void);
	~CRemoteHiPerfEnum();

	// Arranges BLOB contents from an enumeration
	HRESULT GetTransferArrayBlob(long *plBlobType, long *plBlobLen, BYTE** ppBlob);

};

// Forward Declarations
class	CRefresherCache;
class CProviderRecord;

// Request records
class CRequestRecord
{
	protected:
		long m_lExternalRequestId;
	public:
		CRequestRecord(long lExternalRequestId = 0) 
			: m_lExternalRequestId(lExternalRequestId){}
		virtual ~CRequestRecord(){}
		long GetExternalRequestId() {return m_lExternalRequestId;}
};

class CObjectRequestRecord : public CRequestRecord
{
public:
    CWbemObject* m_pRefreshedObject;
    long m_lInternalRequestId;
public:
    CObjectRequestRecord(long lExternalRequestId, 
                            CWbemObject* pRefreshedObject, 
                            long lProviderRequestId);
    ~CObjectRequestRecord();
    HRESULT Cancel(CProviderRecord* pContainer);
public:
    long GetInternalRequestId() {return m_lInternalRequestId;}
    INTERNAL CWbemObject* GetRefreshedObject() {return m_pRefreshedObject;}
};

class CEnumRequestRecord : public CRequestRecord
{
public:
    CRemoteHiPerfEnum* m_pHPEnum;
    long m_lInternalRequestId;

public:
    CEnumRequestRecord(long lExternalRequestId, 
                            CRemoteHiPerfEnum* pHPEnum, 
                            long lProviderRequestId);
    ~CEnumRequestRecord();
    HRESULT Cancel(CProviderRecord* pContainer);
public:
    long GetInternalRequestId() {return m_lInternalRequestId;}
    INTERNAL CRemoteHiPerfEnum* GetEnum() {return m_pHPEnum;}
};

//***************************************************************************
//
//  class CHiPerfPrvRecord
//
//***************************************************************************

class CHiPerfPrvRecord
{
protected:
    long m_lRef;

    WString					m_wsProviderName;
    CLSID					m_clsid;
    CLSID					m_clsidClient;
	CRefresherCache*		m_pRefresherCache;

public:
    CHiPerfPrvRecord( LPCWSTR wszName, CLSID clsid, CLSID clsidClient, CRefresherCache* pRefrCache );
    virtual ~CHiPerfPrvRecord();

    long AddRef();
    long Release();

    long GetRefCount() {return m_lRef;}

    LPCWSTR GetProviderName() const {return m_wsProviderName;}
    REFCLSID GetClsid() {return m_clsid;}
    REFCLSID GetClientLoadableClsid() {return m_clsidClient;}

	BOOL IsReleased( void ) { return ( m_lRef == 0L ); }
};

//***************************************************************************
//
//  class CProviderRecord
//
//
//***************************************************************************

class CProviderRecord
{
protected:
    long m_lRef;

	IWbemHiPerfProvider*	m_pProvider;
	_IWmiProviderStack*		m_pProvStack;
	IWbemRefresher*			m_pInternalRefresher;
	CHiPerfPrvRecord*		m_pHiPerfRecord;
	CCritSec				m_cs;

    CUniquePointerArray<CObjectRequestRecord> m_apRequests;
    CUniquePointerArray<CEnumRequestRecord>	m_apEnumRequests;

public:
    CProviderRecord( CHiPerfPrvRecord* pHiPerfRecord, IWbemHiPerfProvider* pProvider, IWbemRefresher* pRefresher,
					_IWmiProviderStack* pProvStack );
    virtual ~CProviderRecord();

    long AddRef();
    long Release();

    long GetRefCount() {return m_lRef;}

    LPCWSTR GetProviderName() const {return m_pHiPerfRecord->GetProviderName();}
    REFCLSID GetClsid() {return m_pHiPerfRecord->GetClsid();}
    REFCLSID GetClientLoadableClsid() {return m_pHiPerfRecord->GetClientLoadableClsid();}

    HRESULT Remove(long lId, BOOL* pfIsEnum);
    HRESULT Find(long lId);
    HRESULT Refresh(long lFlags);
    HRESULT Store(WBEM_REFRESHED_OBJECT* aObjects, long* plIndex);
    BOOL IsEmpty() {return (m_apRequests.GetSize() == 0) && m_apEnumRequests.GetSize() == 0;}
    INTERNAL IWbemHiPerfProvider* GetProvider() { if ( NULL != m_pProvider ) m_pProvider->AddRef(); return m_pProvider;}
    INTERNAL IWbemRefresher* GetInternalRefresher( void )
	{ return m_pInternalRefresher; }

    HRESULT AddObjectRequest(CWbemObject* pRefreshedObject, 
                            long lProviderRequestId,
							long lNewId );

    HRESULT AddEnumRequest(CRemoteHiPerfEnum* pHPEnum, 
                            long lProviderRequestId,
							long lNewId);

    HRESULT Cancel(long lId);
};

// The actual refresher record - one is created for each remote refresher
class CRefresherRecord : public IWbemRemoteRefresher, public IWbemRefresher
{
protected:
    long m_lRefCount;
    CRefresherId m_Id;
    CUniquePointerArray<CProviderRecord> m_apProviders;
    long m_lNumObjects;
	long m_lNumEnums;
	long	m_lLastId;
	GUID	m_Guid;
	CRefresherCache*	m_pRefresherCache;
	IUnknown*			m_pLockMgr;
	CCritSec	m_cs;

public:
    CRefresherRecord(const WBEM_REFRESHER_ID& Id, CRefresherCache* pRefresherCache, IUnknown* pLockMgr);
    virtual ~CRefresherRecord();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD(RemoteRefresh)(long lFlags, long* plNumObjects,
        WBEM_REFRESHED_OBJECT** paObjects);
	STDMETHOD(StopRefreshing)( long lNumIds, long* aplIds, long lFlags);
	STDMETHOD(GetGuid)( long lFlags, GUID* pGuid );

    STDMETHOD(Refresh)(long lFlags);

    CRefresherId& GetId() {return m_Id;}
    const CRefresherId& GetId() const {return m_Id;}

    INTERNAL CProviderRecord* FindProviderRecord(
                         CLSID clsid,
						 IWbemHiPerfProvider** ppProvider = NULL);

    INTERNAL HRESULT AddProvider(
                        CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						IWbemRefresher* pRefresher,
						_IWmiProviderStack* pProvStack,
						CProviderRecord** ppRecord );

	// Retrieves a new id for this remote refresher
	long GetNewRequestId( void )
	{
		return InterlockedIncrement( &m_lLastId );
	}

	virtual HRESULT AddObjectRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
						CWbemObject* pInstTemplate, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo) = 0;

	virtual HRESULT AddEnumRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						CWbemObject* pInstTemplate,
						LPCWSTR wszClass, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo) = 0;

    HRESULT Remove(long lRequestId);

	void GetGuid( GUID* pGuid ){ *pGuid = m_Guid; }

	BOOL IsReleased( void ) { return ( m_lRefCount == 0L ); }
};

class CRemoteRecord : public CRefresherRecord
{
protected:

	HRESULT GetProviderRefreshInfo( CHiPerfPrvRecord* pHiPerfRecord,
									IWbemHiPerfProvider* pProvider,
									IWbemServices* pNamespace,
									CProviderRecord** ppProvRecord,
									IWbemRefresher** ppRefresher );

public:
    CRemoteRecord(const WBEM_REFRESHER_ID& Id, CRefresherCache* pRefresherCache, IUnknown* pLockMgr);
    ~CRemoteRecord();

	HRESULT AddObjectRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
						CWbemObject* pInstTemplate, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo);

	HRESULT AddEnumRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						CWbemObject* pInstTemplate,
						LPCWSTR wszClass, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\rfchercd.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RFCHERCD.CPP

Abstract:

  Refresher cache record implementations.

History:

  24-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "refrhelp.h"
#include "rfchercd.h"
#include "refrcach.h"
#include "arrtempl.h"

// HiPerf Provider record stuff
CHiPerfPrvRecord::CHiPerfPrvRecord( LPCWSTR wszName, CLSID clsid, CLSID clsidClient, CRefresherCache* pRefrCache )
:	m_wsProviderName( wszName ),
	m_clsid( clsid ),
	m_clsidClient( clsidClient ),
	m_pRefresherCache( pRefrCache ),
	m_lRef( 0 )
{
	if ( NULL != m_pRefresherCache )
	{
		m_pRefresherCache->AddRef();
	}
}

CHiPerfPrvRecord::~CHiPerfPrvRecord( void )
{
	if ( NULL != m_pRefresherCache )
	{
		m_pRefresherCache->Release();
	}
}

long CHiPerfPrvRecord::AddRef( void )
{
	return InterlockedIncrement( &m_lRef );
}

long CHiPerfPrvRecord::Release( void )
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        // The remove call will check that this guy has really been released
        // before axing him.  All functions go through FindRefresherRecord()
        // to get a record, which blocks on the same critical section as
        // remove.  Since it AddRef()s the record before it returns, we
        // are ensured that if a client requests the same record
        // twice and one operation fails, releasing its object, before the
        // other has returned from a Find, that the ref count will get
        // bumped up again, so IsReleased() will fail, and the record won't
        // really be removed.

        m_pRefresherCache->RemoveProviderRecord(this); // deletes
    }
    return lRef;
}

// Provider Record kept inside referesher records
CProviderRecord::CProviderRecord( CHiPerfPrvRecord* pHiPerfRecord, IWbemHiPerfProvider* pProvider, IWbemRefresher* pRefresher,
								 _IWmiProviderStack* pProvStack )
:	m_pProvider( pProvider ),
	m_pInternalRefresher( pRefresher ),
	m_pHiPerfRecord( pHiPerfRecord ),
	m_pProvStack( pProvStack )
{
	if ( NULL != m_pProvider )
	{
		m_pProvider->AddRef();
	}

	if ( NULL != m_pHiPerfRecord )
	{
		m_pHiPerfRecord->AddRef();
	}

	if ( NULL != m_pInternalRefresher )
	{
		m_pInternalRefresher->AddRef();
	}

	if ( NULL != m_pProvStack )
	{
		m_pProvStack->AddRef();
	}
}

CProviderRecord::~CProviderRecord( void )
{
	if ( NULL != m_pInternalRefresher )
	{
		m_pInternalRefresher->Release();
	}

	if ( NULL != m_pProvider )
	{
		m_pProvider->Release();
	}

	if ( NULL != m_pHiPerfRecord )
	{
		m_pHiPerfRecord->Release();
	}

	if ( NULL != m_pProvStack )
	{
		m_pProvStack->Release();
	}

}

long CProviderRecord::AddRef( void )
{
	return InterlockedIncrement( &m_lRef );
}

long CProviderRecord::Release( void )
{
	long	lReturn = InterlockedIncrement( &m_lRef );

	if ( 0 == lReturn )
	{
		delete this;
	}

	return lReturn;
}

HRESULT CProviderRecord::AddObjectRequest(
            CWbemObject* pRefreshedObject, long lProviderRequestId, long lNewId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    CObjectRequestRecord* pRequest = NULL;

    // Watch for OOM exceptions
    try
    {
        pRequest = new CObjectRequestRecord(lNewId, pRefreshedObject, lProviderRequestId);

		if ( NULL == pRequest )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

        if ( m_apRequests.Add(pRequest) < 0 )
		{
			delete pRequest;
			return WBEM_E_OUT_OF_MEMORY;
		}

        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_FAILED;
    }

}

HRESULT CProviderRecord::AddEnumRequest(
            CRemoteHiPerfEnum* pHPEnum, long lProviderRequestId, long lNewId )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    CEnumRequestRecord* pRequest = NULL;


    // Watch for OOM exceptions
    try
    {
        pRequest = new CEnumRequestRecord(lNewId, pHPEnum, lProviderRequestId);

		if ( NULL == pRequest )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}

        if ( m_apEnumRequests.Add(pRequest) < 0 )
		{
			delete pRequest;
			return WBEM_E_OUT_OF_MEMORY;
		}

        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }
        return WBEM_E_FAILED;
    }

}
    
HRESULT CProviderRecord::Remove(long lId, BOOL* pfIsEnum )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Need to know if we axed an enumerator or an actual object
    *pfIsEnum = FALSE;

    // Check object requests, then enum requests
    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            hres = pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return hres;
        }
    }

    for(i = 0; i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            hres = pRequest->Cancel(this);
            m_apEnumRequests.RemoveAt(i);
            *pfIsEnum = TRUE;
            return hres;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CProviderRecord::Find( long lId )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Check object requests, then enum requests
    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            return WBEM_S_NO_ERROR;
        }
    }

    for(i = 0; i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CProviderRecord::Cancel(long lId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    if(m_pHiPerfRecord)
    {
        // Watch for any exceptions that may get thrown
        try
        {
            return m_pProvider->StopRefreshing(m_pInternalRefresher, lId, 0);
        }
        catch(...)
        {
            return WBEM_E_PROVIDER_FAILURE;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CProviderRecord::Refresh(long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    if(m_pInternalRefresher)
    {
        try
        {
            return m_pInternalRefresher->Refresh(0L);
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }
    }
    else 
        return WBEM_S_NO_ERROR;
}

HRESULT CProviderRecord::Store(
            WBEM_REFRESHED_OBJECT* aObjects, long* plIndex)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Error out if anything beefs

    // First handle the single objects, then we'll get the
    // enumerations
    for(int i = 0; SUCCEEDED( hres ) && i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        CWbemInstance* pInst = (CWbemInstance*)pRequest->GetRefreshedObject();
        WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + *plIndex;

        hres = pInst->GetTransferBlob(&(pRefreshed->m_lBlobType), 
                &(pRefreshed->m_lBlobLength), &(pRefreshed->m_pbBlob));

        if ( SUCCEEDED( hres ) )
        {
            pRefreshed->m_lRequestId = pRequest->GetExternalRequestId();
            (*plIndex)++;
        }
        else
        {
            // Clear all data in case of failure
            ZeroMemory( pRefreshed, sizeof(WBEM_REFRESHED_OBJECT) );
        }
    }

    // Now handle the enumerations.  Each enum will create an array
    // of BLOBs
    for( i = 0; SUCCEEDED( hres ) && i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];

        WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + *plIndex;
        hres = pRequest->GetEnum()->GetTransferArrayBlob( &(pRefreshed->m_lBlobType), 
                    &(pRefreshed->m_lBlobLength), &(pRefreshed->m_pbBlob) );

        if ( SUCCEEDED( hres ) )
        {
            pRefreshed->m_lRequestId = pRequest->GetExternalRequestId();
            (*plIndex)++;
        }
        else
        {
            // Clear all data in case of failure
            ZeroMemory( pRefreshed, sizeof(WBEM_REFRESHED_OBJECT) );
        }

    }

    // We need to cleanup any allocated sub-blobs now
    if ( FAILED( hres ) )
    {
        for ( int x = 0; x < *plIndex; x++ )
        {
            WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + x;

            if ( NULL != pRefreshed->m_pbBlob )
            {
                CoTaskMemFree( pRefreshed->m_pbBlob );
                pRefreshed->m_pbBlob = NULL;
            }

        }   // FOR x

    }   // IF FAILED(hres


    return hres;
}

//*****************************************************************************
//                         OBJECT REQUEST RECORD
//*****************************************************************************
//*****************************************************************************

CObjectRequestRecord::CObjectRequestRecord(
        long lExternalRequestId,
        CWbemObject* pRefreshedObject,
        long lProviderRequestId)
    : 
        CRequestRecord(lExternalRequestId), 
        m_pRefreshedObject(pRefreshedObject),
        m_lInternalRequestId(lProviderRequestId)
{
    if(m_pRefreshedObject)
        m_pRefreshedObject->AddRef();
}
        
HRESULT CObjectRequestRecord::Cancel(
                                CProviderRecord* pContainer)
{
    return pContainer->Cancel(m_lInternalRequestId);
}

CObjectRequestRecord::~CObjectRequestRecord()
{
    if(m_pRefreshedObject)
        m_pRefreshedObject->Release();
}

//*****************************************************************************
//*****************************************************************************
//                         ENUM REQUEST RECORD
//*****************************************************************************
//*****************************************************************************

CEnumRequestRecord::CEnumRequestRecord(
        long lExternalRequestId,
        CRemoteHiPerfEnum* pHPEnum,
        long lProviderRequestId)
    : 
        CRequestRecord(lExternalRequestId), 
        m_pHPEnum(pHPEnum),
        m_lInternalRequestId(lProviderRequestId)
{
    if(m_pHPEnum)
        m_pHPEnum->AddRef();
}
        
HRESULT CEnumRequestRecord::Cancel( CProviderRecord* pContainer)
{
    return pContainer->Cancel(m_lInternalRequestId);
}

CEnumRequestRecord::~CEnumRequestRecord()
{
    if(m_pHPEnum)
        m_pHPEnum->Release();
}

//*****************************************************************************
//*****************************************************************************
//                         REMOTE HIPERF ENUM SUPPORT
//*****************************************************************************
//*****************************************************************************

CRemoteHiPerfEnum::CRemoteHiPerfEnum()
{
}

CRemoteHiPerfEnum::~CRemoteHiPerfEnum()
{
}

HRESULT CRemoteHiPerfEnum::GetTransferArrayBlob( long *plBlobType, long *plBlobLen, BYTE** ppBlob)
{
    // This is the correct BLOB type.  Beware 800 series was sending WBEM_BLOB_TYPE_ENUM for everything
    *plBlobType = WBEM_BLOB_TYPE_ENUM;

    HRESULT hr = WBEM_S_NO_ERROR;
    long    lBuffSize = 0,
            lLastBuffSize = 0,
            lNumObjects = 0;
    BYTE*   pData = NULL;

        // Get through the lock first
    if ( m_Lock.Lock() )
    {

        // Make sure we have objects to enumerate
        if ( m_aIdToObject.Size() > 0 )
        {
            // Enumerate the objects in the array and add up the size of the
            // buffer we will have to allocate
            for ( DWORD dwCtr = 0; dwCtr < m_aIdToObject.Size(); dwCtr++ )
            {
                CWbemInstance*  pInst = (CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj;;

                // Buffer Size
                lLastBuffSize = pInst->GetTransferArrayBlobSize();

                // Skip zero length
                if ( 0 != lLastBuffSize )
                {
                    lBuffSize += lLastBuffSize;
                    lNumObjects++;
                }
            }

            // Make sure we have a size to work with
            if ( lBuffSize > 0 )
            {
                long    lTempBuffSize = lBuffSize;

                // Entire buffer is prepended by a number of objects and a version
                lBuffSize += CWbemInstance::GetTransferArrayHeaderSize();

                // May require CoTaskMemAlloc()
                pData = (BYTE*) CoTaskMemAlloc( lBuffSize );

                if ( NULL != pData )
                {
                    BYTE*   pTemp = pData;

                    // Now write the header
                    CWbemInstance::WriteTransferArrayHeader( lNumObjects, &pTemp );

                    // Now enumerate the objects and transfer into the array BLOB
                    for ( dwCtr = 0; SUCCEEDED(hr) && dwCtr < m_aIdToObject.Size(); dwCtr++ )
                    {
                        CWbemInstance*  pInst = (CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj;

                        lLastBuffSize = pInst->GetTransferArrayBlobSize();

                        if ( lLastBuffSize > 0 )
                        {
                            long    lUsedSize;
                            hr = pInst->GetTransferArrayBlob( lTempBuffSize, &pTemp, &lUsedSize );

#ifdef _DEBUG
                            // During DEBUG HeapValidate our BLOB
                            HeapValidate( GetProcessHeap(), 0, pData );
#endif

                            // Account for BLOB size used

                            if ( SUCCEEDED( hr ) )
                            {
                                lTempBuffSize -= lUsedSize;
                            }
                        }

                    }   // FOR dwCtr

                    // Cleanup if things exploded, otherwise perform garbage collection
                    if ( FAILED( hr ) )
                    {
                        CoTaskMemFree( pData );
                        pData = NULL;
                        lBuffSize = 0;
                    }
                    else
                    {
                        // if everything is okay, go ahead and do any necessary garbage collection on
                        // our arrays.

                        m_aReusable.GarbageCollect();
                    }
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // IF lBuffSize > 0

        }   // IF Size() > 0
        
        m_Lock.Unlock();

    }   // IF Lock()
    else
    {
        // If we can't get access to the enumerator to figure out which
        // BLOBs to transfer, something is badly worng.
        hr = WBEM_E_REFRESHER_BUSY;
    }

    // Make sure we store appropriate data
    *ppBlob = pData;
    *plBlobLen = lBuffSize;

    return hr;

}

//*****************************************************************************
//*****************************************************************************
//                          REFRESHER RECORD
//*****************************************************************************
//*****************************************************************************

CRefresherRecord::CRefresherRecord(const WBEM_REFRESHER_ID& Id, CRefresherCache* pRefrCache,
								IUnknown* pLockMgr )
    : m_Id(Id), m_lRefCount(0), m_lNumObjects(0), m_lNumEnums(0), m_lLastId( 0 ),
	m_pRefresherCache( pRefrCache ), m_pLockMgr( pLockMgr ), m_cs()
{
    // We need a guid to uniquely identify this bad boy for remote auto-connect
    CoCreateGuid( &m_Guid );

	if ( NULL != m_pRefresherCache )
	{
		m_pRefresherCache->AddRef();
	}

	if ( NULL != m_pLockMgr )
	{
		m_pLockMgr->AddRef();
	}
}

CRefresherRecord::~CRefresherRecord( void )
{
	if ( NULL != m_pRefresherCache )
	{
		m_pRefresherCache->Release();
	}

	if ( NULL != m_pLockMgr )
	{
		m_pLockMgr->Release();
	}

}

INTERNAL HRESULT CRefresherRecord::
AddProvider( CHiPerfPrvRecord* pHiPerfRecord,
			IWbemHiPerfProvider* pProvider,
            IWbemRefresher* pRefresher,
			_IWmiProviderStack* pProvStack,
			CProviderRecord** ppRecord )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    CProviderRecord* pProvRecord = NULL;

    // Watch for memory exceptions
    try
    {
        pProvRecord = new CProviderRecord( pHiPerfRecord, pProvider, pRefresher, pProvStack );
        m_apProviders.Add(pProvRecord);
        *ppRecord = pProvRecord;
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        if ( NULL != pProvRecord )
        {
            delete pProvRecord;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch( ... )
    {
        if ( NULL != pProvRecord )
        {
            delete pProvRecord;
        }

        return WBEM_E_FAILED;
    }

}

INTERNAL CProviderRecord* CRefresherRecord::
FindProviderRecord( CLSID clsid, IWbemHiPerfProvider** ppProvider /* = NULL */ )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    for(int i = 0; i < m_apProviders.GetSize(); i++)
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        if(pProvRecord->GetClsid() == clsid)
		{
			if ( NULL != ppProvider )
			{
				*ppProvider = pProvRecord->GetProvider();
			}

            return pProvRecord;
		}
    }
    return NULL;
}
    

HRESULT CRefresherRecord::Remove(long lId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Find it first
    // =============

    for(int i = 0; i < m_apProviders.GetSize(); i++)
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        BOOL    fIsEnum = FALSE;
        HRESULT hres = pProvRecord->Remove( lId, &fIsEnum );

        if(hres == WBEM_S_FALSE) continue;
        if(FAILED(hres)) return hres;
    
        // Found it
        // ========

        if(pProvRecord->IsEmpty())
            m_apProviders.RemoveAt(i);

        // Decrememt the proper counter
        if ( fIsEnum )
        {
            m_lNumEnums--;
        }
        else
        {
            m_lNumObjects--;
        }

        return WBEM_S_NO_ERROR;
    }
    return WBEM_S_FALSE;
}
    
ULONG STDMETHODCALLTYPE CRefresherRecord::AddRef()
{
    int x = 1;
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CRefresherRecord::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
    {
        // The remove call will check that this guy has really been released
        // before axing him.  All functions go through FindRefresherRecord()
        // to get a record, which blocks on the same critical section as
        // remove.  Since it AddRef()s the record before it returns, we
        // are ensured that if a client requests the same record
        // twice and one operation fails, releasing its object, before the
        // other has returned from a Find, that the ref count will get
        // bumped up again, so IsReleased() will fail, and the record won't
        // really be removed.

        m_pRefresherCache->RemoveRefresherRecord(this); // deletes
    }
    return lRef;
}

STDMETHODIMP CRefresherRecord::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRemoteRefresher)
    {
        AddRef();
        *ppv = (IWbemRemoteRefresher*)this;
        return S_OK;
    }
    else if(riid == IID_IWbemRefresher)
    {
        AddRef();
        *ppv = (IWbemRefresher*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CRefresherRecord::Refresh(long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Go through all our providers and refresh them
    // =============================================

    long lObjectIndex = 0;
    HRESULT hres;
    for(int i = 0; i < m_apProviders.GetSize(); i++)  
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        hres = pProvRecord->Refresh(lFlags);
        if(FAILED(hres)) return hres;
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CRefresherRecord::RemoteRefresh(
                                    long lFlags, long* plNumObjects, 
                                    WBEM_REFRESHED_OBJECT** paObjects)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Use CoTaskMemAlloc()?
    if(paObjects)
    {
        // Original code
        //*paObjects = new WBEM_REFRESHED_OBJECT[m_lNumObjects];
        *paObjects = (WBEM_REFRESHED_OBJECT*) CoTaskMemAlloc( ( m_lNumObjects + m_lNumEnums ) * sizeof(WBEM_REFRESHED_OBJECT));

        if ( NULL != *paObjects )
        {
            // Zero out the BLOB
            ZeroMemory( *paObjects, ( m_lNumObjects + m_lNumEnums ) * sizeof(WBEM_REFRESHED_OBJECT) );
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // This value needs to reflect the number of objects as well as the number of enumerators we are shipping
    // back to the client.

    if(plNumObjects)
    {
        *plNumObjects = m_lNumObjects + m_lNumEnums;
    }

    // Go through all our providers and refresh them
    // =============================================

    long    lObjectIndex = 0;
    HRESULT hrFirstRefresh = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRefresh = FALSE;
    BOOL    fPartialSuccess = FALSE;

    for(int i = 0; i < m_apProviders.GetSize(); i++)  
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        hres = pProvRecord->Refresh(lFlags);
    
        if ( SUCCEEDED( hres ) )
        {
            if(paObjects)
            {
                // Store the result
                // ================

                hres = pProvRecord->Store(*paObjects, &lObjectIndex);

                // If this fails, we will consider this catastrophic, since the
                // only reason this would fail is under out of memory conditions,
                // and in that case, since we are remoting, all sorts of things
                // could go wrong, so if this breaks, just cleanup and bail out.

                if ( FAILED( hres ) )
                {
                    if ( *paObjects )
                    {
                        CoTaskMemFree( *paObjects );
                        *paObjects = NULL;
                    }
                    
                    *plNumObjects = 0;

                    return hres;
                }

            }   // IF NULL != paObjects

        }   // IF Refresh Succeeded

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }   // FOR enum providers

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hres = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hres = hrFirstRefresh;
    }

    // Finally, if the object index is less than the number of array elements we "thought"
    // we would be sending back, make sure we reflect this.  If it is zero, just delete the
    // elements (we wouldn't have allocated any sub-buffers anyway).  Since
    // *plNumObjects is a sizeof, only *plNumObjects elements will be sent back, although
    // CoTaskMemFree() should cleanup the entire array buffer.

    if ( lObjectIndex != *plNumObjects )
    {
        *plNumObjects = lObjectIndex;

        if ( 0 == lObjectIndex )
        {
            if ( *paObjects )
            {
                CoTaskMemFree( *paObjects );
                *paObjects = NULL;
            }

        }

    }

    return hres;
}
            
STDMETHODIMP CRefresherRecord::StopRefreshing(
                        long lNumIds, long* aplIds, long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrFirst = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRemove = FALSE;
    BOOL    fPartialSuccess = FALSE;

    for ( long lCtr = 0; lCtr < lNumIds; lCtr++ )
    {
        hr = Remove( aplIds[lCtr] );

        if ( !fOneRemove )
        {
            hrFirst = hr;
            fOneRemove = TRUE;
        }

        // Record the fact we got at least one success if we got one
        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hr )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRemove && WBEM_S_NO_ERROR != hrFirst )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }   // FOR enum ids

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hr = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hr = hrFirst;
    }

    return hr;
}

STDMETHODIMP CRefresherRecord::GetGuid(
                        long lFlags, GUID* pGuid )
{
    
    if ( 0L != lFlags || NULL == pGuid )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pGuid = m_Guid;

    return WBEM_S_NO_ERROR;

}

//*****************************************************************************
//*****************************************************************************
//                              REMOTE RECORD
//*****************************************************************************
//*****************************************************************************

CRemoteRecord::CRemoteRecord( const WBEM_REFRESHER_ID& Id, CRefresherCache* pRefrCache,
							 IUnknown* pLockMgr )
    : CRefresherRecord( Id, pRefrCache, pLockMgr )
{
}

CRemoteRecord::~CRemoteRecord()
{
}

HRESULT CRemoteRecord::GetProviderRefreshInfo(
                                CHiPerfPrvRecord* pHiPerfRecord,
								IWbemHiPerfProvider* pProvider,
								IWbemServices* pNamespace,
                                CProviderRecord** ppProvRecord,
                                IWbemRefresher** ppRefresher )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Get a refresher from the provider, unless already available
    // ===========================================================

    *ppProvRecord = FindProviderRecord( pHiPerfRecord->GetClsid() );

    // We couldn't find the record so make sure we are able to get a refresher
    if ( NULL == *ppProvRecord )
    {
        try
        {
            hres = pProvider->CreateRefresher( pNamespace, 0, ppRefresher );

            if ( SUCCEEDED(hres) && NULL == *ppRefresher )
            {
                hres = WBEM_E_PROVIDER_FAILURE;
            }
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }
    }
    else
    {
        // Get the refresher pointer and AddRef it
        *ppRefresher = (*ppProvRecord)->GetInternalRefresher();
        if(*ppRefresher)
        {
            (*ppRefresher)->AddRef();
        }
    }

    return hres;
}

HRESULT CRemoteRecord::AddObjectRefresher(
                    CHiPerfPrvRecord* pHiPerfRecord,
					IWbemHiPerfProvider* pProvider,
					_IWmiProviderStack* pProvStack,
					IWbemServices* pNamespace,
					LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    // Enters and Leaves as a byproduct of scoping
    CInCritSec  ics(&m_cs);

    // Get a refresher from the provider, unless already available
    // ===========================================================

    IWbemRefresher* pProvRefresher = NULL;
    CProviderRecord* pProvRecord = NULL;

    HRESULT hres = GetProviderRefreshInfo( pHiPerfRecord, pProvider, pNamespace, &pProvRecord, &pProvRefresher );

    // Always release going out of scope
    CReleaseMe  rmRefresh( pProvRefresher );

    if ( SUCCEEDED( hres ) )
    {
        // Call provider for information
        // =============================

        IWbemObjectAccess* pRefreshedOA = NULL;
        long lProvRequestId;

        // Now try to add the object

        try
        {
            hres = pProvider->CreateRefreshableObject(
                    pNamespace, pInstTemplate, pProvRefresher,
                    0, pContext, &pRefreshedOA,
                    &lProvRequestId);
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }

        // Always release going out of scope
        CReleaseMe  rmRefreshed( pRefreshedOA );

        CWbemObject* pRefreshedObject = (CWbemObject*)pRefreshedOA;
        CWbemObject* pClientObject = NULL;

        if ( SUCCEEDED( hres ) )
        {

            // The object we return to the client, since we are remote, should
            // contain amended qualifiers if we are using localization, so to make
            // sure of this, we will clone an object off of the pInstTemplate and
            // the copy the instance data from the object the provider returned
            // to us. The provider can refresh the object it gave to us, since
            // we will only be sending the instance part

            hres = pInstTemplate->Clone( (IWbemClassObject**) &pClientObject );

            if ( SUCCEEDED( hres ) )
            {
                hres = pClientObject->CopyBlobOf( pRefreshedObject );

                if ( SUCCEEDED( hres ) )
                {
                    hres = pClientObject->SetDecoration( pwszServerName, pwszNamespace );
                }

            }   // IF Clones

        }   // IF Object Created

        // Release going out of scope
        CReleaseMe  rmClient( (IWbemClassObject*) pClientObject );

        if ( SUCCEEDED( hres ) )
        {
            // Add a new provider record if necessary
            if(pProvRecord == NULL)
            {
                hres = AddProvider( pHiPerfRecord, pProvider,
                                    pProvRefresher, pProvStack,
									&pProvRecord );
            }

            // Now we will add the actual request
            if ( SUCCEEDED( hres ) )
            {

                // Generate the new id from our datamember
                long    lNewId = GetNewRequestId();

                hres = pProvRecord->AddObjectRequest(pRefreshedObject, lProvRequestId, lNewId );

                if ( SUCCEEDED( hres ) )
                {
                    m_lNumObjects++;
                    pInfo->SetRemote(this, lNewId, pClientObject, &m_Guid);
                }

            }   // IF we have a provider record

        }   // IF created a client object


    }   // IF Got refresher


    return hres;
}

HRESULT CRemoteRecord::AddEnumRefresher(
                    CHiPerfPrvRecord* pHiPerfRecord,
					IWbemHiPerfProvider* pProvider,
					_IWmiProviderStack* pProvStack,
					IWbemServices* pNamespace,
					CWbemObject* pInstTemplate,
                    LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    // Enters and Leaves as a byproduct of scoping
    CInCritSec  ics(&m_cs);

    // Get a refresher from the provider, unless already available
    // ===========================================================

    IWbemRefresher* pProvRefresher = NULL;
    CProviderRecord* pProvRecord = NULL;

    HRESULT hres = GetProviderRefreshInfo( pHiPerfRecord, pProvider, pNamespace, &pProvRecord, &pProvRefresher );

    // Always release going out of scope
    CReleaseMe  rmRefresh( pProvRefresher );

    if ( SUCCEEDED( hres ) )
    {
        // Call provider for information
        // =============================

        // Create a HiPerf Enumerator (We know we will need one
        // of these since we will only be in this code when we
        // go remote).
        CRemoteHiPerfEnum*  pHPEnum = NULL;
        
        // Watch for OOM exceptions
        try
        {
            pHPEnum = new CRemoteHiPerfEnum;
        }
        catch( CX_MemoryException )
        {
            hres = WBEM_E_OUT_OF_MEMORY;
        }
        catch( ... )
        {
            hres = WBEM_E_FAILED;
        }

        if ( SUCCEEDED( hres ) )
        {
            // Bump up the RefCount
            pHPEnum->AddRef();

            // Release this pointer when we drop out of scope
            CReleaseMe  rm( pHPEnum );

            // The enumerator will need to know this
            hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) pInstTemplate );

            if ( FAILED(hres) )
            {
                return hres;
            }

            long lProvRequestId = 0;

            try
            {
                hres = pProvider->CreateRefreshableEnum(
                        pNamespace, wszClass, pProvRefresher,
                        0, pContext, pHPEnum, &lProvRequestId);
            }
            catch(...)
            {
                // The provider threw an exception.  Just return and let scoping
                // release anything we may be holding onto.

                return WBEM_E_PROVIDER_FAILURE;
            }

            // Add a new provider record if we need one
            if( SUCCEEDED( hres ) && ( pProvRecord == NULL ) )
            {
                hres = AddProvider( pHiPerfRecord, pProvider,
                                   pProvRefresher, pProvStack,
								   &pProvRecord);
            }
    
            // Now we will add the actual request
            if ( SUCCEEDED( hres ) )
            {

                // Generate the new id from our datamember
                long    lNewId = GetNewRequestId();

                hres = pProvRecord->AddEnumRequest( pHPEnum, lProvRequestId, lNewId );

                if ( SUCCEEDED( hres ) )
                {
                    m_lNumEnums++;
                    pInfo->SetRemote(this, lNewId, pInstTemplate, &m_Guid);
                }

            }   // IF we have a provider record

        }   // IF Created HPEnum

    }   // IF Got Refresher

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\shmem.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SHMEM.CPP

Abstract:

  Class CWbemSharedMem

History:

  paulall      24-Oct-97

--*/

#ifndef _SHMEM_H_
#define _SHMEM_H_

#include "corepol.h"
#include "flexarry.h"
#include "shmlock.h"

struct SHMEM_HEADER;
struct SHMEM_INDEX_HEADER;

/*============================================================================
 *
 * WBEM_SHMEM_HANDLE
 *
 * This structure represents a single location within the shared memory
 * by means of storing a page and an offset within the page.
 *============================================================================
 */
struct WBEM_SHMEM_HANDLE
{
    DWORD dwPage;
    DWORD dwOffset;
};

class COREPROX_POLARITY CWbemSharedMem
{
private:
    HANDLE m_hFile;                         //Handle to the file for the memory mapped file
    HANDLE m_hMmfLock;                      //Global handle for controling access to the MMF
    BOOL   m_bInitialised;                  //Make sure initialisaton only happens once
    CFlexArray  blockTracker;               //Keeps track of what blocks are in memory

    struct SHMEM_HEADER *m_pHeader;

public:
    //Low level heap management methods to allocate/free blocks of memory.
    //These can only be called once the header is set up properly!
    int AllocateBlock(DWORD  dwBlockSize,
                      DWORD *pdwBlockNumber, 
                      DWORD *pdwBlockOffset);
    void  FreeBlock(DWORD dwBlock, DWORD dwOffset);

    DWORD GetBlockSize(void *pBlock);

    //Gets a true pointer to a block given a block number and offset
    void *GetPointer(DWORD dwBlockNumber, DWORD dwBlockOffset);

    //Creates/opens/closes the memory mapped file.  The Open will fail if
    //there is no memory mapped file available.  The Open method returns NotFound
    //if the MMF file does not exist.  In this case use the 
    //Create method.
    int CreateMemoryMappedFile();
    int OpenMemoryMappedFile();
    int CloseMemoryMappedFile();

    //Creates/reads the main MMF memory header
    int CreateHeaderBlock();
    int ReadHeaderBlock();

    //Creates the head index block
    int CreateIndexBlock();

    //Finds/creates blobs of memory with a key reference in the index
    int FindIndexedItem(const wchar_t *pszKey, DWORD *dwObjectPage, DWORD *dwObjectOffset);
    int InsertIndexedItem(const wchar_t *pszKey, DWORD dwObjectPage, DWORD dwObjectOffset);
    int _InsertIndexAt(SHMEM_INDEX_HEADER *pIndexHeader, int dwIndexEntry, const wchar_t *pszKey, DWORD dwObjectPage, DWORD dwObjectOffset);
    int _MakeRoomForIndex(SHMEM_INDEX_HEADER *pIndexHeader, int dwIndexEntry);
    int RemoveIndexedItem(const wchar_t *pszKey);
    int _RemoveIndexAt(SHMEM_INDEX_HEADER *pIndexHeader, int dwIndexEntry);
    int _RemoveRoomForIndex(SHMEM_INDEX_HEADER *pIndexHeader, int dwIndexEntry);

    //Locking methods which stop others from updating/reading the MMF structure.
    int LockMmf();
    int UnlockMmf();

public:
    enum { NoError, Failed, AlreadyExists, NotFound, AccessDenied, InsufficientMemory };
    
    CWbemSharedMem();   // No effect
   ~CWbemSharedMem();
    
    //Opens the memory mapped file and gets everything ready for use.
    int Initialize();

    //Allocates a blob of memory in the MMF of specified size with an
    //access key of the specified key.
    // Returns AlreadyExists if the key is already mapped
    int MapNew(IN  LPCWSTR pszKey, 
               IN  DWORD   dwNumBytes,
               OUT LPVOID *pBlobLocation);

    //Based on the key string, returns a pointer to the memory block, and also 
    //returns the size of the allocated block. pdwBlobSize can be NULL
    // Returns NotFound if the key doesn't exist
    int MapExisting(IN LPCWSTR  pszKey, 
                    OUT LPVOID *pBlobLocation,
                    OUT DWORD  *pdwBlobSize);

    //Creates/returns a blob of memory and gives it an associatory key to query on.
    //If it exists it returns an existing pointer, if it does not exist it creates
    //it and returns the value.
    int MapAlways(IN LPCWSTR  pszKey, 
                  IN DWORD dwInitialSize,
                  IN BOOL bLockBlock,
                  OUT LPVOID *pBlobLocation);
        
    //Frees up the memory to the object if no one wants it any more.
    //Every MapExisting should have a Unmap when it is no longer needed.
    int Unmap(IN LPCWSTR pszObjectPath);
    int Unmap(IN LPVOID pMem) { return Failed; }

    //Gets an exclusive lock to an object specified by the block pointer itself
    int AcquireLock(IN LPVOID pBlobLocation);
        
    //Releases the exclusive lock to an object specified by the block pointer itself
    int ReleaseLock(IN LPVOID pBlobLocation);

    //Gets a pointer to the lock within the block of memory allocated when mapping
    //a block to a key.  Do not pass in any other pointer to this or it will fail
    //even if the pointer was one allocated with AllocateBlob!
    SHARED_LOCK_DATA *GetLockLocation(IN const void *pBlobLocation);

    //Allocates a block of memory within the shared memory
    int AllocateBlob(IN  DWORD dwBlockSize,
                     OUT WBEM_SHMEM_HANDLE &hBlob)
    {
        return AllocateBlock(dwBlockSize, &hBlob.dwPage, &hBlob.dwOffset);
    }

    //Deallocates a block of memory allocated with the AllocateBlob from the shared memory
    void FreeBlob(IN WBEM_SHMEM_HANDLE &hBlob)
    {
        FreeBlock(hBlob.dwPage, hBlob.dwOffset);
    }

    //Returns an absolute pointer to the handle retrieved from the AllocateBlob method
    void *GetPointer(IN WBEM_SHMEM_HANDLE &hBlob)
    {
        return GetPointer(hBlob.dwPage, hBlob.dwOffset);
    }


    //Some debugging functions
    void DumpIndexes();
    void DumpStats();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\shmem.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SHMEM.CPP

Abstract:

  Class CWbemSharedMem

History:

  paulall      24-Oct-97

--*/

#include "precomp.h"
#include <stdio.h>
#include "genutils.h"
#include "shmem.h"

#define WBEM_SHMEM_PAGE_SIZE            64  /* Size of pages in KBytes */
#define WBEM_SHMEM_INDEX_BLOCK_SIZE     64  /* Size in terms of number of entries */
#define WBEM_SHMEM_MIN_FREE_MEM_ALLOC   64  /* Minimum number of bytes allowed to alloc */
#define WBEM_SHMEM_LOCK_INIT            1   /* Initial lock value */

#define WBEM_SHMEM_MMF_FILENAME         __TEXT("c:\\wbemshmem.mmf")
#define WBEM_SHMEM_GLOBAL_MUTEX         __TEXT("WBEM Shared Memory Lock")

#define WBEM_SHMEM_GRANULARITY          4   


/*============================================================================
 *
 * SHMEM_LOCK
 *
 * This structure is used by the locking functionality.  It creates
 * a read and write lock for access to either the memory block itself,
 * or a lock to the index.
 *============================================================================
 */
struct SHMEM_LOCK
{
    DWORD dwLock1;
    DWORD dwLock2;
} ;

/*============================================================================
 *
 * SHMEM_HEADER
 *
 * This structure goes at the start of the shared memory block as is
 * filled in by the first process to create the MMF.  All other
 * processes then use the settings specified.
 * Before any process accesses the index they should lock it, and release
 * when done.  This makes sure we do not try to access the index when
 * someone is updating it.
 *============================================================================
 */
struct SHMEM_HEADER
{
    DWORD dwPageSize;
    DWORD dwNumPages;
    struct SHMEM_LOCK lock;
    DWORD dwFirstIndexBlockPage;
    DWORD dwFirstIndexBlockOffset;
    DWORD dwHeadFreeBlockPage;
    DWORD dwHeadFreeBlockOffset;
} ;

/*============================================================================
 *
 * SHMEM_INDEX_HEADER
 *
 * At the start of each index block is a set of information to help manage
 * this block, as well as a link on to the next index block in the event that
 * the index block fills up.
 *============================================================================
 */
struct SHMEM_INDEX_HEADER
{
    DWORD dwIndexLength;            //Number of index entries in block
    DWORD dwNextIndexBlockPage;     //0 means this is the last block
    DWORD dwNextIndexBlockOffset;   //0 means this is the last block
} ;

/*============================================================================
 *
 * SHMEM_INDEX
 *
 * Each index entry contains information to find the object path, and
 * any other information associated with the index.
 *============================================================================
 */
struct SHMEM_INDEX
{
    DWORD dwObjPathPage;
    DWORD dwObjPathOffset;
    DWORD dwObjectPage;
    DWORD dwObjectOffset;
} ;

/*============================================================================
 *
 * SHMEM_MEMBLOCK_HEADER
 *
 * This is the header to the actual memory block.
 *============================================================================
 */
struct SHMEM_MEMBLOCK_HEADER
{
    SHARED_LOCK_DATA lock;
    DWORD dwRefCount;
} ;

struct SHMEM_MEMBLOCK_ALLOCATED
{
    DWORD dwBlockLength;
};
struct SHMEM_MEMBLOCK_FREE
{
    DWORD dwBlockLength;
    DWORD dwNextBlock;
    DWORD dwNextOffset;
};

/*============================================================================
 *
 * CWbemShMemBlockTracker
 *
 * This is used to control what blocks are in memory or not
 *============================================================================
 */
struct SHMEM_BLOCK_TRACKER
{
    DWORD  dwBlockNumber;
    HANDLE hMapping;
    void  *pBlockStart;
};
/*============================================================================
 *============================================================================
 *=========================                       ============================
 *=========================    PUBLIC METHODS     ============================
 *=========================                       ============================
 *============================================================================
 *============================================================================
 */


/*============================================================================
 *
 * CWbemSharedMem::CWbemSharedMem()
 *
 * The constructor only zeros out variables.  It does no opening of the
 * memory mapped file.
 *============================================================================
 */
CWbemSharedMem::CWbemSharedMem()
{
    //Zero out any local pointers and variables
    m_hFile = INVALID_HANDLE_VALUE;
    m_hMmfLock = INVALID_HANDLE_VALUE;
    m_bInitialised = FALSE;
    m_pHeader = NULL;
}

/*============================================================================
 *
 * CWbemSharedMem::~CWbemSharedMem()
 *
 * The destructor closes the memory mapped file and tidies up memory.
 *============================================================================
 */
CWbemSharedMem::~CWbemSharedMem()
{
    if(!m_bInitialised)
        return;

    //Lock the MMF in case someone is doing something strange...
    if (LockMmf() != NoError)
        return;

    //Close the memory mapped file
    CloseMemoryMappedFile();

    //Get rid of the lock
    CloseHandle(m_hMmfLock);

    m_hMmfLock = INVALID_HANDLE_VALUE;

    m_bInitialised = FALSE;
}

/*============================================================================
 *
 * CWbemSharedMem::Initialize()
 *
 * Opens an existing memory mapped file, or creates a new one if there isn't
 * one already.
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::Initialize()
{
    int nRet = NoError;

    if (m_bInitialised)
        return NoError;

    //First thing first, we need to create our global mutex and lock it.  This stops
    //anyone else beating us to the creation process.  We then lock this mutex before
    //we do anything which updates/reads the mmf structure.
    m_hMmfLock = CreateMutex(NULL, TRUE, WBEM_SHMEM_GLOBAL_MUTEX);

    if(m_bInitialised)
        return NoError;

    m_bInitialised = TRUE;

    //Check to make sure we succeeded.  If not we cannot continue with anything!
    if (m_hMmfLock == NULL)
        return Failed;

    //Set up some privileges on this object so that others can get access to this object
    SetObjectAccess(m_hMmfLock);

    //Open the memory mapped file...
    nRet = OpenMemoryMappedFile();
    if (nRet == NotFound)
    {
        nRet = CreateMemoryMappedFile();
        if (nRet != NoError)
        {
            UnlockMmf();
            return nRet;
        }
    }
    else if (nRet != NoError)
    {
        UnlockMmf();
        return nRet;
    }

    UnlockMmf();
    return nRet;
}

/*============================================================================
 *
 * CWbemSharedMem::MapNew()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::MapNew( IN  LPCWSTR pszKey,
                            IN  DWORD dwNumBytes,
                            OUT LPVOID *pBlobLocation )
{
    //Lock the MMF so others do not update it at the same time as us...
    if (LockMmf() != NoError)
        return Failed;
    
    //Item should not exist... make sure it does not...
    DWORD dwBlock, dwOffset;
    int nRet = FindIndexedItem(pszKey, &dwBlock, &dwOffset);
    if (nRet == NoError)
    {
        UnlockMmf();
        return AlreadyExists;
    }
    else if (nRet != NotFound)
    {
        UnlockMmf();
        return nRet;
    }

    //If it is not there, insert it into the correct location...
    //First allocate the block of memory...
    DWORD dwMemBlock, dwMemOffset;
    nRet = AllocateBlock(dwNumBytes + sizeof(SHMEM_MEMBLOCK_HEADER), &dwMemBlock, &dwMemOffset);
    if (nRet != NoError)
    {
        UnlockMmf();
        return nRet;
    }

    nRet = InsertIndexedItem(pszKey, dwMemBlock, dwMemOffset);

    if (nRet == NoError)
    {
        SHMEM_MEMBLOCK_HEADER *pBlockHeader = (SHMEM_MEMBLOCK_HEADER *)GetPointer(dwMemBlock, dwMemOffset);
        if (pBlockHeader == NULL)
        {
            UnlockMmf();
            return Failed;
        }

        //Set up the lock...
        pBlockHeader->lock.Init();
        pBlockHeader->dwRefCount = 1;
        *pBlobLocation = PBYTE(pBlockHeader) + sizeof(SHMEM_MEMBLOCK_HEADER);
    }
    else
    {
        //Free up the memory block we allocated...
        FreeBlock(dwMemBlock, dwMemOffset);
    }

    UnlockMmf();
    return nRet;
}

/*============================================================================
 *
 * CWbemSharedMem::MapExisting()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::MapExisting(LPCWSTR pszKey,
                                LPVOID *pBlobLocation,
                                DWORD  *pdwBlobSize)
{
    //Lock the MMF so others do not update while we are looking...
    if (LockMmf() != NoError)
        return Failed;

    DWORD dwBlock, dwOffset;
    int nRet = FindIndexedItem(pszKey, &dwBlock, &dwOffset);
    if (nRet != NoError)
    {
        UnlockMmf();
        return nRet;
    }

    SHMEM_MEMBLOCK_HEADER *pBlockHeader = (SHMEM_MEMBLOCK_HEADER *) GetPointer(dwBlock, dwOffset);
    if (pBlockHeader == NULL)
    {
        UnlockMmf();
        return Failed;
    }

    *pBlobLocation = PBYTE(pBlockHeader) + sizeof(SHMEM_MEMBLOCK_HEADER);

    if (pdwBlobSize)
        *pdwBlobSize = GetBlockSize(pBlockHeader) - sizeof(SHMEM_MEMBLOCK_HEADER);
    pBlockHeader->dwRefCount++;

    UnlockMmf();
    return NoError;
}

/*============================================================================
 *
 * CWbemSharedMem::MapExisting()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::MapAlways(IN LPCWSTR  pszKey,
                              IN DWORD dwInitialSize,
                              IN BOOL bLockBlock,
                              OUT LPVOID *pBlobLocation)
{
    //Lock the MMF so others do not update it at the same time as us...
    if (LockMmf() != NoError)
        return Failed;
    
    //If item exists, use the existing one...
    DWORD dwBlock, dwOffset;
    int nRet = FindIndexedItem(pszKey, &dwBlock, &dwOffset);
    if (nRet == NoError)
    {
        UnlockMmf();
        *pBlobLocation = GetPointer(dwBlock, dwOffset);

        if (*pBlobLocation != NULL)
        {
            if (bLockBlock)
                AcquireLock(pBlobLocation);
            return AlreadyExists;
        }
        else
            return Failed;
    }
    else if (nRet != NotFound)
    {
        UnlockMmf();
        return nRet;
    }

    //If it is not there, insert it into the correct location...
    //First allocate the block of memory...
    DWORD dwMemBlock, dwMemOffset;
    nRet = AllocateBlock(dwInitialSize + sizeof(SHMEM_MEMBLOCK_HEADER), &dwMemBlock, &dwMemOffset);
    if (nRet != NoError)
    {
        UnlockMmf();
        return nRet;
    }

    nRet = InsertIndexedItem(pszKey, dwMemBlock, dwMemOffset);

    if (nRet == NoError)
    {
        SHMEM_MEMBLOCK_HEADER *pBlockHeader = (SHMEM_MEMBLOCK_HEADER *)GetPointer(dwMemBlock, dwMemOffset);
        if (pBlockHeader == NULL)
        {
            UnlockMmf();
            return Failed;
        }

        //Set up the lock...
        pBlockHeader->lock.Init();
        pBlockHeader->dwRefCount = 1;
        *pBlobLocation = PBYTE(pBlockHeader) + sizeof(SHMEM_MEMBLOCK_HEADER);

        UnlockMmf();

        if (bLockBlock)
            AcquireLock(pBlobLocation);
    }
    else
    {
        //Free up the memory block we allocated...
        FreeBlock(dwMemBlock, dwMemOffset);

        UnlockMmf();
    }

    return nRet;
}

/*============================================================================
 *
 * CWbemSharedMem::Unmap()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::Unmap(LPCWSTR pszKey)
{
    //Lock the MMF so others do not update at the same time as us...
    if (LockMmf() != NoError)
        return Failed;

    DWORD dwBlock, dwOffset;
    int nRet = FindIndexedItem(pszKey, &dwBlock, &dwOffset);
    if (nRet != NoError)
    {
        UnlockMmf();
        return nRet;
    }

    SHMEM_MEMBLOCK_HEADER *pBlockHeader = (SHMEM_MEMBLOCK_HEADER *) GetPointer(dwBlock, dwOffset);

    if (pBlockHeader == NULL)
    {
        UnlockMmf();
        return Failed;
    }

    pBlockHeader->dwRefCount--;

    if (pBlockHeader->dwRefCount == 0)
    {
        //We need to remove everything to do with this!
        //First the index...
        int nRet = RemoveIndexedItem(pszKey);
        if (nRet != NoError)
        {
            UnlockMmf();
            return nRet;
        }

        //Next the memory block...
        FreeBlock(dwBlock, dwOffset);
    }

    UnlockMmf();
    return NoError;
}

/*============================================================================
 *
 * CWbemSharedMem::AcquireLock()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::AcquireLock(IN LPVOID pBlobLocation)
{
    CSharedLock lock;
    SHARED_LOCK_DATA *pLock = GetLockLocation(pBlobLocation);
    if (pLock)
    {
        lock.SetData(pLock);
        lock.Lock();
        return NoError;
    }

    return Failed;
}

/*============================================================================
 *
 * CWbemSharedMem::ReleaseLock()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::ReleaseLock(IN LPVOID pBlobLocation)
{
    CSharedLock lock;
    SHARED_LOCK_DATA *pLock = GetLockLocation(pBlobLocation);
    if (pLock)
    {
        lock.SetData(pLock);
        lock.Unlock();
        return NoError;
    }

    return Failed;
}

/*============================================================================
 *
 * CWbemSharedMem::GetLockLocation()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
SHARED_LOCK_DATA *CWbemSharedMem::GetLockLocation(IN const void *pBlobLocation)
{
    return &(((SHMEM_MEMBLOCK_HEADER*)(PBYTE(pBlobLocation) - sizeof(SHMEM_MEMBLOCK_HEADER)))->lock);
}

/*============================================================================
 *
 * CWbemSharedMem::DumpIndexes()
 *
 * Debug method (when it gets implemented!)
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
void CWbemSharedMem::DumpIndexes()
{
    if (LockMmf() != NoError)
        return;

    UnlockMmf();
}
/*============================================================================
 *
 * CWbemSharedMem::DumpStats()
 *
 * Debug method
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
void CWbemSharedMem::DumpStats()
{
    if (LockMmf() != NoError)
    {
        printf("Failed to lock the shared memory. Aborting...\n");
        return;
    }

    printf("Shared memory statistics...\n\n");
    printf("Memory page size = %lu", m_pHeader->dwPageSize);
    if (m_pHeader->dwPageSize != WBEM_SHMEM_PAGE_SIZE)
        printf(", default is %lu\n", (DWORD)WBEM_SHMEM_PAGE_SIZE);
    else
        printf("\n");
    printf("Number of pages = %lu\n", m_pHeader->dwNumPages);
    printf("Total size of page file = %lu\n", m_pHeader->dwPageSize * m_pHeader->dwNumPages);

    //Calculate the number of index blocks...
    DWORD dwNumIndexBlocks = 0;
    DWORD dwNumIndexEntries = 0;
    DWORD dwIndexBlockSize = 0;
    BOOL  bIndexBlockSizeNotDefault = FALSE;
    DWORD dwIndexPage, dwIndexOffset;
    dwIndexPage = m_pHeader->dwFirstIndexBlockPage;
    dwIndexOffset = m_pHeader->dwFirstIndexBlockOffset;
    while ((dwIndexPage != 0) || (dwIndexOffset != 0))
    {
        SHMEM_INDEX_HEADER *pIndexHeader = (SHMEM_INDEX_HEADER *)GetPointer(dwIndexPage, dwIndexOffset);

		// RAJESHR - Fix for prefix bug 144447
		if(!pIndexHeader)
		{
		    printf("Could not get Index Header for index page %lu and index offset %lu - Discontinuing dump\n",
				dwIndexPage, dwIndexOffset);
			break;
		}

        SHMEM_INDEX *pIndex = (SHMEM_INDEX *)(PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));

        dwNumIndexBlocks ++;

        //First time around we need to get a value...
        if (dwIndexBlockSize == 0)
            dwIndexBlockSize = pIndexHeader->dwIndexLength;

        //Check if this value is not default, or different size...
        if ((pIndexHeader->dwIndexLength != WBEM_SHMEM_INDEX_BLOCK_SIZE) ||
            (pIndexHeader->dwIndexLength != dwIndexBlockSize))
            bIndexBlockSizeNotDefault = TRUE;

        //Make sure we have the largest value...
        if (pIndexHeader->dwIndexLength > dwIndexBlockSize)
            dwIndexBlockSize = pIndexHeader->dwIndexLength;

        //Here is a really crazy way of calculating the number of entries taken!  Such is life!
        for (DWORD dwItem = 0; dwItem != pIndexHeader->dwIndexLength; dwItem++)
        {
            if ((pIndex[dwItem].dwObjPathPage != 0) || (pIndex[dwItem].dwObjPathOffset != 0))
                dwNumIndexEntries ++;
            else
                break;
        }

        //Move on to the next block (if present!)
        dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
        dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;
    }

    printf("Number index blocks = %lu\n", dwNumIndexBlocks);
    printf("Number index entries = %lu\n", dwNumIndexEntries);
    if (bIndexBlockSizeNotDefault)
        printf("Maximum number index block entries per block = %lu, default is %lu, \nsome blocks are not default size or are different sizes\n", dwIndexBlockSize, (DWORD)WBEM_SHMEM_INDEX_BLOCK_SIZE);
    else
        printf("Number index block entries per block = %lu\n", dwIndexBlockSize);

    //Now do some deleted block checking....
    DWORD dwNumberDeletedBlocks = 0;
    DWORD dwLargestDeletedBlockSize = 0;
    DWORD dwSmallestDeletedBlockSize = 0xFFFF;
    DWORD dwTotalDeletedSpace = 0;
    DWORD dwDeletedPage, dwDeletedOffset;
    dwDeletedPage = m_pHeader->dwHeadFreeBlockPage;
    dwDeletedOffset = m_pHeader->dwHeadFreeBlockOffset;

    while ((dwDeletedPage != 0) || (dwDeletedOffset != 0))
    {
        SHMEM_MEMBLOCK_FREE *pFreeMem = (SHMEM_MEMBLOCK_FREE*) GetPointer(dwDeletedPage, dwDeletedOffset);

        DWORD dwThisBlockSize = pFreeMem->dwBlockLength;

        dwNumberDeletedBlocks ++;

        if (dwThisBlockSize < dwSmallestDeletedBlockSize)
            dwSmallestDeletedBlockSize = dwThisBlockSize;

        if (dwThisBlockSize > dwLargestDeletedBlockSize)
            dwLargestDeletedBlockSize = dwThisBlockSize;

        dwTotalDeletedSpace += dwThisBlockSize;

        dwDeletedPage = pFreeMem->dwNextBlock;
        dwDeletedOffset = pFreeMem->dwNextOffset;
    }

    printf("Total number of deleted blocks = %lu\n", dwNumberDeletedBlocks);
    printf("Total bytes of deleted blocks = %lu\n", dwTotalDeletedSpace);
    printf("Smallest deleted block size = %lu\n", dwSmallestDeletedBlockSize);
    printf("Largest deleted block size = %lu\n", dwLargestDeletedBlockSize);

    UnlockMmf();
}


/*============================================================================
 *============================================================================
 *=========================                       ============================
 *=========================    CLASS METHODS      ============================
 *=========================                       ============================
 *============================================================================
 *============================================================================
 */

int CWbemSharedMem::LockMmf()
{
    return (WaitForSingleObject(m_hMmfLock, INFINITE) == WAIT_OBJECT_0 ? NoError : Failed);
}
int CWbemSharedMem::UnlockMmf()
{
    return (ReleaseMutex(m_hMmfLock) == 0? Failed : NoError);
}


int CWbemSharedMem::AllocateBlock(DWORD  dwBlockSize,
                                  DWORD *pdwBlockNumber,
                                  DWORD *pdwBlockOffset)
{
    //Quick sanity check to make sure the block of memory which is being
    //requested is not bigger than we can deal with....
    if (dwBlockSize > ((WBEM_SHMEM_PAGE_SIZE * 1024) - sizeof(SHMEM_MEMBLOCK_ALLOCATED)))
        return InsufficientMemory;

    //Need to make sure we are a granularity of 4 so everything is aligned correctly
    dwBlockSize = (dwBlockSize - 1 + WBEM_SHMEM_GRANULARITY) / WBEM_SHMEM_GRANULARITY * WBEM_SHMEM_GRANULARITY;

    //If there was no block large enough, the last thing we do is make space.
    //In this case we need to go through the whole process again.  If this
    //fails we are in trouble and return failure.  The second time around
    //should find the first block suitable for their needs through, therefore
    //quite efficient!
    for (int retryLoop = 0; retryLoop != 2; retryLoop++)
    {
        //dwCur* are the current location within the free-list chain
        DWORD dwCurBlock =  m_pHeader->dwHeadFreeBlockPage;
        DWORD dwCurOffset = m_pHeader->dwHeadFreeBlockOffset;
        //pFreeBlock is a pointer to the start of the block pointed to by dwCur
        SHMEM_MEMBLOCK_FREE *pFreeBlock = NULL;
        //pPrevFreeBlock is a pointer to the previous free-list block so we can take
        //the free block we use out of the list
        SHMEM_MEMBLOCK_FREE *pPrevFreeBlock = NULL;

        while ((dwCurBlock != 0) || (dwCurOffset != 0))
        {
            pFreeBlock = (SHMEM_MEMBLOCK_FREE *)GetPointer(dwCurBlock, dwCurOffset);

            if (pFreeBlock == NULL)
            {
                //Something went really bad...
                *pdwBlockNumber = 0;
                *pdwBlockOffset = 0;

                return Failed;
            }

            //Is this block large enough for the requested size (plus block header size!)
            if ((dwBlockSize + sizeof(SHMEM_MEMBLOCK_ALLOCATED)) <= pFreeBlock->dwBlockLength)
            {
                //We need to return this block to the user....
                *pdwBlockNumber = dwCurBlock;
                *pdwBlockOffset = dwCurOffset + sizeof(SHMEM_MEMBLOCK_ALLOCATED);

                //We need to split this block if possible otherwise the first
                //block will use all the memory available!  We must make sure we
                //do not leave a block which is too small though!  The smallest
                //block size is that of the free-list block!
                if (pFreeBlock->dwBlockLength >
                    (dwBlockSize + sizeof(SHMEM_MEMBLOCK_ALLOCATED) + sizeof(SHMEM_MEMBLOCK_FREE)))
                {
                    //We can split...

                    //Create a pointer to the start of the new free block...
                    DWORD dwNewFreeBlock = dwCurBlock;
                    DWORD dwNewFreeOffset = dwCurOffset + dwBlockSize + sizeof(SHMEM_MEMBLOCK_ALLOCATED);
                    SHMEM_MEMBLOCK_FREE *pNewFreeBlock = (SHMEM_MEMBLOCK_FREE *)GetPointer(dwNewFreeBlock, dwNewFreeOffset);
					// rajeshr : Fix for Prefix bug# 144451
					// Need to confirm that this fix is ok. from Sanj
		            if (pNewFreeBlock == NULL)
					{
						//Something went really bad...
						*pdwBlockNumber = 0;
						*pdwBlockOffset = 0;

						return Failed;
					}


                    //Set the size of this new block...
                    pNewFreeBlock->dwBlockLength = pFreeBlock->dwBlockLength - (dwBlockSize + sizeof(SHMEM_MEMBLOCK_ALLOCATED));

                    //Set the size of this current block to the newly allocated size...
                    pFreeBlock->dwBlockLength = dwBlockSize + sizeof(SHMEM_MEMBLOCK_ALLOCATED);

                    //Point this new free block at the next block that the old block points
                    //to...
                    pNewFreeBlock->dwNextBlock = pFreeBlock->dwNextBlock;
                    pNewFreeBlock->dwNextOffset = pFreeBlock->dwNextOffset;

                    //Point the previous block's free-list (or header) at the new block, not our
                    //newly allocated block...
                    if ((dwCurBlock == m_pHeader->dwHeadFreeBlockPage) &&
                        (dwCurOffset == m_pHeader->dwHeadFreeBlockOffset))
                    {
                        //The header pointed to us...point it at the new free block...
                        m_pHeader->dwHeadFreeBlockPage = dwNewFreeBlock;
                        m_pHeader->dwHeadFreeBlockOffset = dwNewFreeOffset;
                    }
                    else if ( NULL != pPrevFreeBlock )
                    {
                        pPrevFreeBlock->dwNextBlock = dwNewFreeBlock;
                        pPrevFreeBlock->dwNextOffset = dwNewFreeOffset;
                    }
					else
					{
						//Something went really bad...
						*pdwBlockNumber = 0;
						*pdwBlockOffset = 0;
						return Failed;
					}
                    
                }
                else
                {
                    //We use it in it's entirety...
                    //We need to take this block out of the free-list chain, so the item which pointed
                    //to us needs to point to what we are pointing to.  Note that this could be the
                    //header!
                    if ((dwCurBlock == m_pHeader->dwHeadFreeBlockPage) &&
                        (dwCurOffset == m_pHeader->dwHeadFreeBlockOffset))
                    {
                        //The header pointed to us...
                        m_pHeader->dwHeadFreeBlockPage = pFreeBlock->dwNextBlock;
                        m_pHeader->dwHeadFreeBlockOffset = pFreeBlock->dwNextOffset;
                    }
                    else if ( NULL != pPrevFreeBlock )
                    {
                        pPrevFreeBlock->dwNextBlock = pFreeBlock->dwNextBlock;
                        pPrevFreeBlock->dwNextOffset = pFreeBlock->dwNextOffset;
                    }
					else
					{
						//Something went really bad...
						*pdwBlockNumber = 0;
						*pdwBlockOffset = 0;
						return Failed;
					}
                }

                

                return NoError;
            }

            //Move on to the next block....
            dwCurBlock  = pFreeBlock->dwNextBlock;
            dwCurOffset = pFreeBlock->dwNextOffset;

            //Remember this block in case the next block is the one we use and
            //it needs to be taken out of the free-list chain
            pPrevFreeBlock = pFreeBlock;
        }

        //If here we did not have a block of memory which was big enough.  SO...
        //we need to load in a new block of memory, one more than the current
        //number of blocks...
    
        //Increment the number of blocks...
        m_pHeader->dwNumPages++;

        //Get this new block in memory
        SHMEM_MEMBLOCK_FREE *pNewBlock = (SHMEM_MEMBLOCK_FREE *)GetPointer(m_pHeader->dwNumPages, 0);

        if (pNewBlock == NULL)
        {
            //Restore the block count to what it was...
            m_pHeader->dwNumPages--;

            return InsufficientMemory;
        }

        //Create a header at the start of the block to say it is all free...
        pNewBlock->dwBlockLength = ((WBEM_SHMEM_PAGE_SIZE * 1024) - sizeof(SHMEM_MEMBLOCK_ALLOCATED));

        //Point this free block at the current head free block
        pNewBlock->dwNextBlock = m_pHeader->dwHeadFreeBlockPage;
        pNewBlock->dwNextOffset = m_pHeader->dwHeadFreeBlockOffset;

        //Set up the header to point to this free block as the first free block....
        m_pHeader->dwHeadFreeBlockPage = m_pHeader->dwNumPages;
        m_pHeader->dwHeadFreeBlockOffset = 0;   

        //go around the process again of trying to find a free block...
    }
    //If we get here something really nasty has happened!  Return failure...

    *pdwBlockNumber = 0;
    *pdwBlockOffset = 0;
    return InsufficientMemory;
}

void  CWbemSharedMem::FreeBlock(DWORD dwBlock, DWORD dwOffset)
{
    //In case the allocation failed and they free it!
    if ((dwBlock == 0) && (dwOffset == 0))
        return;

    //Note, the dwOffset is pointing to the actual user memory, not the actual start of
    //the block.  So, we need to adjust this....
    DWORD dwNewBlock  = dwBlock;
    DWORD dwNewOffset = dwOffset - sizeof(SHMEM_MEMBLOCK_ALLOCATED);

    //Now we need a pointer to this.  We now want this to be a free block, so
    //we get a free block pointer!
    SHMEM_MEMBLOCK_FREE *pNewBlock = (SHMEM_MEMBLOCK_FREE*)GetPointer(dwNewBlock, dwNewOffset);

	// Make sure this actually resolved into something
	if ( NULL != pNewBlock )
	{
		//This new block needs to point to the previous head of the free list...
		pNewBlock->dwNextBlock  = m_pHeader->dwHeadFreeBlockPage;
		pNewBlock->dwNextOffset = m_pHeader->dwHeadFreeBlockOffset;

		//Now we need to make this the head of the free list chain...
		m_pHeader->dwHeadFreeBlockPage = dwNewBlock;
		m_pHeader->dwHeadFreeBlockOffset = dwNewOffset;
	}
}

DWORD CWbemSharedMem::GetBlockSize(void *pBlock)
{
    SHMEM_MEMBLOCK_ALLOCATED *pBlockHeader = (SHMEM_MEMBLOCK_ALLOCATED *)(PBYTE(pBlock) - sizeof(SHMEM_MEMBLOCK_ALLOCATED));
    return pBlockHeader->dwBlockLength - sizeof(SHMEM_MEMBLOCK_ALLOCATED);
}
/*============================================================================
 *
 * CWbemSharedMem::GetPointer()
 *
 *
 * Returns:
 *      NULL - we failed to load in the block
 *============================================================================
 */
void *CWbemSharedMem::GetPointer(DWORD dwBlockNumber, DWORD dwBlockOffset)
{
    //If this block is already in memory return a pointer to this...
    for (int i = 0; i != blockTracker.Size(); i++)
    {
        SHMEM_BLOCK_TRACKER *pBlockInfo = (SHMEM_BLOCK_TRACKER *)blockTracker[i];

        if (pBlockInfo->dwBlockNumber == dwBlockNumber)
        {
            //We already have this block, just return the pointer...
            return PBYTE(pBlockInfo->pBlockStart) + dwBlockOffset;
        }
    }

    //Otherwise we have to create a mapping to this page...
    SHMEM_BLOCK_TRACKER *pBlockInfo = new SHMEM_BLOCK_TRACKER;
    pBlockInfo->dwBlockNumber = dwBlockNumber;

    //Creates a file mapping.
    pBlockInfo->hMapping = CreateFileMapping(
        m_hFile,                            // Disk file
        0,                                  // No security
        PAGE_READWRITE | SEC_COMMIT,        // Extend the file to match the heap size
        0,                                                      // High-order max size
        (WBEM_SHMEM_PAGE_SIZE * 1024) * (dwBlockNumber + 1),    // Low-order max size
        0                                   // No name for the mapping object
        );

    if (pBlockInfo->hMapping == NULL)
    {
        //The mapping failed!
        delete pBlockInfo;
        return NULL;
    }
    pBlockInfo->pBlockStart = MapViewOfFile(
                        pBlockInfo->hMapping,                           //mapping handle
                        FILE_MAP_ALL_ACCESS,                            //access
                        0,                                              //high start location
                        m_pHeader->dwPageSize * 1024 * dwBlockNumber,   //low start location
                        m_pHeader->dwPageSize * 1024);                  //size

    if (pBlockInfo->pBlockStart == NULL)
    {
        //This means the mapping failed.  Tidy up and return a failure
        CloseHandle(pBlockInfo->hMapping);
        delete pBlockInfo;
        return NULL;
    }

    //Add this block information and return the new pointer
    blockTracker.Add((SHMEM_BLOCK_TRACKER *)pBlockInfo);
    return PBYTE(pBlockInfo->pBlockStart) + dwBlockOffset;
}
/*============================================================================
 *
 * CWbemSharedMem::CreateMemoryMappedFile()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::CreateMemoryMappedFile()
{
    // Attempt to delete the file for cleanup purposes. If it fails, someone
    // must be using it --- not a problem
    // =====================================================================

    DeleteFile(WBEM_SHMEM_MMF_FILENAME);

    //Create a new file.
    m_hFile = CreateFile(
         WBEM_SHMEM_MMF_FILENAME,
         GENERIC_READ |
            GENERIC_WRITE,
         FILE_SHARE_WRITE |
            FILE_SHARE_READ,                                // Anyone can read and write
         0,                                                 // Security
         CREATE_NEW,                                        // Create new, fail if exists
         FILE_ATTRIBUTE_NORMAL |
            FILE_FLAG_RANDOM_ACCESS,                        // Attribute
         0                                                  // Template file
         );

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_ALREADY_EXISTS)
            return AlreadyExists;
        else
            return Failed;
    }

    int nRet = CreateHeaderBlock();
    if (nRet != NoError)
        return nRet;

    nRet = CreateIndexBlock();
    if (nRet != NoError)
        return nRet;

    return NoError;
}
/*============================================================================
 *
 * CWbemSharedMem::OpenMemoryMappedFile()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::OpenMemoryMappedFile()
{
    // Attempt to delete the file for cleanup purposes. If it fails, someone
    // must be using it --- not a problem
    // =====================================================================

    DeleteFile(WBEM_SHMEM_MMF_FILENAME);

    //Open the existing file. If it does not exist then we need to fail
    //as the caller will have to create a new one
    m_hFile = CreateFile(
         WBEM_SHMEM_MMF_FILENAME,
         GENERIC_READ |
            GENERIC_WRITE,
         FILE_SHARE_WRITE |
            FILE_SHARE_READ,                                // Anyone can read and write
         0,                                                 // Security
         OPEN_EXISTING,                                     // Opening an existing file
         FILE_ATTRIBUTE_NORMAL |
            FILE_FLAG_RANDOM_ACCESS,                        // Attribute
         0                                                  // Template file
         );

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwError = GetLastError();
        if (dwError == ERROR_FILE_NOT_FOUND)
            return NotFound;
        else
            return Failed;
    }

    //Get the pointer to the header
    int nRet = ReadHeaderBlock();
    if (nRet != NoError)
        return nRet;

    return NoError;
}
/*============================================================================
 *
 * CWbemSharedMem::CloseMemoryMappedFile()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::CloseMemoryMappedFile()
{
    //Close all the pages we have in memory...
    //blockTracker...
    for (int i = blockTracker.Size(); i; i--)
    {
        SHMEM_BLOCK_TRACKER *pBlockInfo = (SHMEM_BLOCK_TRACKER *)blockTracker[i - 1];

        CloseHandle(pBlockInfo->hMapping);
        delete pBlockInfo;

        blockTracker.RemoveAt(i - 1);
    }

    //Close the file
    CloseHandle(m_hFile);

    m_hFile = INVALID_HANDLE_VALUE;

    // Attempt to delete the file for cleanup purposes. If it fails, someone
    // must be using it --- not a problem
    // =====================================================================

    DeleteFile(WBEM_SHMEM_MMF_FILENAME);

    return NoError;
}

/*============================================================================
 *
 * CWbemSharedMem::CreateHeaderBlock()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::CreateHeaderBlock()
{
    //Create a temporary header
    m_pHeader = new SHMEM_HEADER;
    if (m_pHeader == NULL)
        return InsufficientMemory;

    //populate it
    m_pHeader->dwPageSize = WBEM_SHMEM_PAGE_SIZE;
    m_pHeader->dwNumPages = 1;
    m_pHeader->lock.dwLock1 = WBEM_SHMEM_LOCK_INIT;
    m_pHeader->lock.dwLock2 = WBEM_SHMEM_LOCK_INIT;
    m_pHeader->dwFirstIndexBlockPage = 0;
    m_pHeader->dwFirstIndexBlockOffset = 0;
    m_pHeader->dwHeadFreeBlockPage = 0;
    m_pHeader->dwHeadFreeBlockOffset = sizeof(SHMEM_HEADER);


    //Get the pointer to the header
    void *pMem = GetPointer(0, 0);
    if (pMem == NULL)
    {
        delete m_pHeader;
        m_pHeader = NULL;
        return Failed;
    }

    //Copy the header into the MMF
    memcpy(pMem, m_pHeader, sizeof(SHMEM_HEADER));

    //delete the temporary copy
    delete m_pHeader;

    //Set the real header pointer
    m_pHeader = (SHMEM_HEADER*)pMem;

    //Get a pointer to the free-list block
    pMem = GetPointer(m_pHeader->dwHeadFreeBlockPage, m_pHeader->dwHeadFreeBlockOffset);

	// rajeshr : Fix for Prefix bug 144448
	// Does anything need to be freed before returning?
	if (pMem == NULL)
    {
        return Failed;
    }
 
	struct SHMEM_MEMBLOCK_FREE *pFreeMem = (SHMEM_MEMBLOCK_FREE *) pMem;

    //Fill in the details for this block - all memory except the header, no next block
    pFreeMem->dwBlockLength = (WBEM_SHMEM_PAGE_SIZE * 1024) - sizeof (SHMEM_HEADER);
    pFreeMem->dwNextBlock = 0;
    pFreeMem->dwNextOffset = 0;

    return NoError;
}

/*============================================================================
 *
 * CWbemSharedMem::ReadHeaderBlock()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::ReadHeaderBlock()
{
    //Create a temporary header and read it in
    m_pHeader = new SHMEM_HEADER;
    DWORD bytesRead;
    if (ReadFile(m_hFile, m_pHeader, sizeof(SHMEM_HEADER), &bytesRead, NULL) == 0)
    {
        //We failed to read the header.  This is pretty serious!
        return Failed;
    }

    //Get a true pointer to this header
    PVOID pMem = GetPointer(0, 0);

    //Delete the temporary header pointer...
    delete m_pHeader;

    if (pMem == NULL)
    {
        //Something went bad!
        m_pHeader = NULL;
        return Failed;
    }

    //point to the proper header
    m_pHeader = (SHMEM_HEADER *) pMem;

    return NoError;
}

/*============================================================================
 *
 * CWbemSharedMem::CreateIndexBlock()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::CreateIndexBlock()
{
    if (AllocateBlock(sizeof(SHMEM_INDEX_HEADER) + (sizeof(SHMEM_INDEX) * WBEM_SHMEM_INDEX_BLOCK_SIZE),
                      &m_pHeader->dwFirstIndexBlockPage,
                      &m_pHeader->dwFirstIndexBlockOffset) != NoError)
        return InsufficientMemory;

    //Get a pointer to the head index block
    struct SHMEM_INDEX_HEADER  *pIndex;

    pIndex = (struct SHMEM_INDEX_HEADER *)GetPointer(m_pHeader->dwFirstIndexBlockPage, m_pHeader->dwFirstIndexBlockOffset);
    if (pIndex == NULL)
        return Failed;

    //Set up the index header
    pIndex->dwIndexLength = WBEM_SHMEM_INDEX_BLOCK_SIZE;
    pIndex->dwNextIndexBlockPage = 0;
    pIndex->dwNextIndexBlockOffset = 0;

    //Clear out index table
    memset(PBYTE(pIndex) + sizeof(SHMEM_INDEX_HEADER), 0, sizeof(SHMEM_INDEX) * WBEM_SHMEM_INDEX_BLOCK_SIZE);
    return NoError;
}

/*============================================================================
 *
 * CWbemSharedMem::InsertIndexedItem()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::InsertIndexedItem(const wchar_t *pszKey,
                                      DWORD dwObjectPage,
                                      DWORD dwObjectOffset)
{
    //We need to work through each of the index blocks until we find the item we are
    //looking for, or until we find a location to insert the new item.  An existing
    //item is an error!
    DWORD dwIndexPage = m_pHeader->dwFirstIndexBlockPage;
    DWORD dwIndexOffset = m_pHeader->dwFirstIndexBlockOffset;
    DWORD dwPrevIndexPage = 0;
    DWORD dwPrevIndexOffset = 0;

    while ((dwIndexPage != 0) || (dwIndexOffset != 0))
    {
        //Get a pointer to the header and index entries...
        SHMEM_INDEX_HEADER *pIndexHeader = (SHMEM_INDEX_HEADER *)GetPointer(dwIndexPage, dwIndexOffset);
        if (pIndexHeader == NULL)
            return Failed;

        SHMEM_INDEX *pIndex = (SHMEM_INDEX *)(PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));

        //Before we do a binary search, we can do a quick check to see if it is in
        //this index block.  This can speed things up quite a bit when there are
        //large numbers of indexes...  IF there is no next page, we do some
        //extra stuff below, so we might as well bite the bullet and not do this!
        if (((pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathPage != 0) ||
             (pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathOffset != 0)) &&
            ((pIndexHeader->dwNextIndexBlockPage != 0) ||
             (pIndexHeader->dwNextIndexBlockOffset != 0)))
        {
            //Get the pointer to this item....          
            wchar_t *pszCurKey = (wchar_t *)GetPointer(pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathPage, pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathOffset);
            if (pszCurKey == NULL)
                return Failed;

            int nTest = wbem_wcsicmp(pszKey, pszCurKey);
            if (nTest > 0)
            {
                //That's what we were looking for.  The current key is greater than the
                //last one in this block.  Move to the next promptly...
                dwPrevIndexPage = dwIndexPage;
                dwPrevIndexOffset = dwIndexOffset;
                dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
                dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;

                continue;
            }
        }

        //Now we need to do a binary search of this index.  Note that the last index
        //block may have some free space at the end of the block, so we should
        //ignore these....

        int l = 0, u = (int)pIndexHeader->dwIndexLength - 1;
        BOOL bFound = FALSE;
        int nLocus = 0; //This is where we should insert an item

        while (l <= u)
        {
            int m = (l + u) / 2;

            //OK, lets do that test to see if this entry is not used...
            if ((pIndex[m].dwObjPathPage == 0) &&
                (pIndex[m].dwObjPathOffset == 0))
            {
                //This entry is empty.  We need to deal with this as through this entry
                //is greater than the one we are looking for.  Then continue like nothing
                //happened!
                u = m - 1;
                nLocus = m;

                continue;
            }
            //We need to get the object path for this entry....
            wchar_t *pszCurKey = (wchar_t *)GetPointer(pIndex[m].dwObjPathPage, pIndex[m].dwObjPathOffset);
            if (pszCurKey == NULL)
                return Failed;

            int nTest = wbem_wcsicmp(pszKey, pszCurKey);
            if (nTest < 0)
            {
                u = m - 1;
                nLocus = m;
            }
            else if (nTest > 0)
            {
                l = m + 1;
                nLocus = l;
            }
            else
            {
                //If an entry already exists we need to return a failure...
                return AlreadyExists;
            }
        }

        //Now we need to work out if this current locus is where we need to insert
        //this item, or if in fact we need to move on to the next index block

        //Have we run out of room?  Locus will be past the end of the block if we have,
        //so this is an easy option of moving onto the next block....
        if (nLocus > (int)pIndexHeader->dwIndexLength)
        {
            dwPrevIndexPage = dwIndexPage;
            dwPrevIndexOffset = dwIndexOffset;
            dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
            dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;
            continue;
        }

        //Is this item blank?  If so use it
        if ((pIndex[nLocus].dwObjPathPage == 0) && (pIndex[nLocus].dwObjPathOffset == 0))
        {
            //We need to insert here....
            return _InsertIndexAt(pIndexHeader, nLocus, pszKey, dwObjectPage, dwObjectOffset);
        }

        //Is this item greater than the item we want, if so insert here
        wchar_t *pszCurKey = (wchar_t *)GetPointer(pIndex[nLocus].dwObjPathPage, pIndex[nLocus].dwObjPathOffset);
        if (pszCurKey == NULL)
            return Failed;

        if (wbem_wcsicmp(pszKey, pszCurKey) < 0)
        {
            //We need to insert here....
            return _InsertIndexAt(pIndexHeader, nLocus, pszKey, dwObjectPage, dwObjectOffset);
        }

        //Otherwise we move on to the next block.
        dwPrevIndexPage = dwIndexPage;
        dwPrevIndexOffset = dwIndexOffset;
        dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
        dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;
    }

    //This is yet another special case.  This means we had to go onto the next block, and
    //there is no next block.  This is why we kept a record of the previous one!  We
    //need to create a new index block, and use the previous block details to chain it.
    SHMEM_INDEX_HEADER *pPrevIndexHeader = (SHMEM_INDEX_HEADER *)GetPointer(dwPrevIndexPage, dwPrevIndexOffset);
    if (AllocateBlock(sizeof(SHMEM_INDEX_HEADER) + (sizeof(SHMEM_INDEX) * WBEM_SHMEM_INDEX_BLOCK_SIZE),
                      &pPrevIndexHeader->dwNextIndexBlockPage,
                      &pPrevIndexHeader->dwNextIndexBlockOffset) != NoError)
        return InsufficientMemory;

    //Get a pointer to the head index block
    struct SHMEM_INDEX_HEADER  *pIndex;

    pIndex = (struct SHMEM_INDEX_HEADER *)GetPointer(pPrevIndexHeader->dwNextIndexBlockPage, pPrevIndexHeader->dwNextIndexBlockOffset);
    if (pIndex == NULL)
        return Failed;

    //Set up the index header
    pIndex->dwIndexLength = WBEM_SHMEM_INDEX_BLOCK_SIZE;
    pIndex->dwNextIndexBlockPage = 0;
    pIndex->dwNextIndexBlockOffset = 0;

    //Clear out index table
    memset(PBYTE(pIndex) + sizeof(SHMEM_INDEX_HEADER), 0, sizeof(SHMEM_INDEX) * WBEM_SHMEM_INDEX_BLOCK_SIZE);

    //Insert here
    return _InsertIndexAt(pIndex, 0, pszKey, dwObjectPage, dwObjectOffset);
}

int CWbemSharedMem::_InsertIndexAt(SHMEM_INDEX_HEADER *pIndexHeader,
                                   int dwIndexEntry,
                                   const wchar_t *pszKey,
                                   DWORD dwObjectPage,
                                   DWORD dwObjectOffset)
{
    //allocate the key buffer
    DWORD dwObjPathPage, dwObjPathOffset;
    int nRet = AllocateBlock(sizeof(wchar_t) * (wcslen(pszKey) + 1), &dwObjPathPage, &dwObjPathOffset);
    if (nRet != NoError)
    {
        return nRet;
    }
    //get pointer to the new key
    SHMEM_INDEX *pIndex = (SHMEM_INDEX*)(PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));
    wchar_t *pNewKey = (wchar_t *)GetPointer(dwObjPathPage, dwObjPathOffset);
    if (pNewKey == NULL)
        return Failed;
    
    //Put the key into the new buffer...
    wcscpy(pNewKey, pszKey);

    //now we need to make room for this new entry... (this is a recursive method...)
    nRet = _MakeRoomForIndex(pIndexHeader, dwIndexEntry);
    if (nRet != NoError)
    {
        //delete the buffer we created for the key...
        FreeBlock(dwObjPathPage, dwObjPathOffset);
        return nRet;
    }

    //insert the key details...
    pIndex[dwIndexEntry].dwObjPathPage = dwObjPathPage;
    pIndex[dwIndexEntry].dwObjPathOffset = dwObjPathOffset;

    //insert object details
    pIndex[dwIndexEntry].dwObjectPage = dwObjectPage;
    pIndex[dwIndexEntry].dwObjectOffset = dwObjectOffset;

    return NoError;
}

int CWbemSharedMem::_MakeRoomForIndex(SHMEM_INDEX_HEADER *pIndexHeader,
                                      int dwIndexEntry)
{
    struct SHMEM_INDEX  *pIndex;
    SHMEM_INDEX_HEADER *pNextIndexHeader = NULL;

    pIndex = (struct SHMEM_INDEX *)(PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));

    if ((pIndex[pIndexHeader->dwIndexLength-1].dwObjPathPage != 0) ||
        (pIndex[pIndexHeader->dwIndexLength-1].dwObjPathOffset != 0))
    {
        if ((pIndexHeader->dwNextIndexBlockPage == 0) &&
            (pIndexHeader->dwNextIndexBlockOffset == 0))
        {
            //Allocate a new index block and chain it to this one
            int nRet = AllocateBlock(sizeof(SHMEM_INDEX_HEADER) + (sizeof(SHMEM_INDEX) * WBEM_SHMEM_INDEX_BLOCK_SIZE),
                                      &pIndexHeader->dwNextIndexBlockPage,
                                      &pIndexHeader->dwNextIndexBlockOffset);
            if (nRet != NoError)
            {
                return nRet;
            }

            //Get a pointer to the new index block
            pNextIndexHeader = (struct SHMEM_INDEX_HEADER *)GetPointer(pIndexHeader->dwNextIndexBlockPage, pIndexHeader->dwNextIndexBlockOffset);
            if (pNextIndexHeader == NULL)
                return Failed;

            //Set up the index chain to point to nothing...
            pNextIndexHeader->dwIndexLength = WBEM_SHMEM_INDEX_BLOCK_SIZE;
            pNextIndexHeader->dwNextIndexBlockPage = 0;
            pNextIndexHeader->dwNextIndexBlockOffset = 0;

            //Clear out index table
            memset(PBYTE(pNextIndexHeader) + sizeof(SHMEM_INDEX_HEADER), 0, sizeof(SHMEM_INDEX) * WBEM_SHMEM_INDEX_BLOCK_SIZE);
        }
        else
        {
            pNextIndexHeader = (SHMEM_INDEX_HEADER *)GetPointer(pIndexHeader->dwNextIndexBlockPage, pIndexHeader->dwNextIndexBlockOffset);
            if (pNextIndexHeader == NULL)
                return Failed;

            _MakeRoomForIndex(pNextIndexHeader, 0);
        }
    }

    if (pNextIndexHeader)
    {
        //Move the last entry in this block into the first entry of the next block
        SHMEM_INDEX *pNextIndex = (SHMEM_INDEX *) (PBYTE(pNextIndexHeader) + sizeof(SHMEM_INDEX_HEADER));
        memcpy(pNextIndex, &pIndex[pIndexHeader->dwIndexLength - 1], sizeof(SHMEM_INDEX));
    }

    //Copy everything from where we want to make space up to the end (minus 1!) down 1 place
    memmove(&pIndex[dwIndexEntry + 1],
            &pIndex[dwIndexEntry],
            sizeof(SHMEM_INDEX) * (pIndexHeader->dwIndexLength - dwIndexEntry - 1));

    return NoError;
}
/*============================================================================
 *
 * CWbemSharedMem::FindIndexedItem()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::FindIndexedItem(const wchar_t *pszKey,
                                    DWORD *dwObjectPage,
                                    DWORD *dwObjectOffset)
{
    //looking for, or until we find a location to insert the new item.  An existing
    //item is an error!
    DWORD dwIndexPage = m_pHeader->dwFirstIndexBlockPage;
    DWORD dwIndexOffset = m_pHeader->dwFirstIndexBlockOffset;

    while ((dwIndexPage != 0) || (dwIndexOffset != 0))
    {
        //Get a pointer to the header and index entries...
        SHMEM_INDEX_HEADER *pIndexHeader = (SHMEM_INDEX_HEADER *)GetPointer(dwIndexPage, dwIndexOffset);
        if (pIndexHeader == NULL)
            return Failed;

        SHMEM_INDEX *pIndex = (SHMEM_INDEX*)(PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));

        //Before we do a binary search, we can do a quick check to see if it is in
        //this index block.  This can speed things up quite a bit when there are
        //large numbers of indexes...
        if ((pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathPage != 0) ||
            (pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathOffset != 0))
        {
            //Get the pointer to this item....          
            wchar_t *pszCurKey = (wchar_t *)GetPointer(pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathPage, pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathOffset);
            if (pszCurKey == NULL)
                return Failed;

            int nTest = wbem_wcsicmp(pszKey, pszCurKey);
            if (nTest > 0)
            {
                //That's what we were looking for.  The current key is greater than the
                //last one in this block.  Move to the next promptly...
                dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
                dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;

                continue;
            }
        }

        //Now we need to do a binary search of this index.  Note that the last index
        //block may have some free space at the end of the block, so we should
        //ignore these....

        int l = 0, u = pIndexHeader->dwIndexLength - 1;
        BOOL bFound = FALSE;
        int nLocus = 0; //This is where we should insert an item
        int nTest = 0;  //This is used to work out if the last test was as far as we need to go

        while (l <= u)
        {
            int m = (l + u) / 2;

            //OK, lets do that test to see if this entry is not used...
            if ((pIndex[m].dwObjPathPage == 0) &&
                (pIndex[m].dwObjPathOffset == 0))
            {
                //This entry is empty.  We need to deal with this as through this entry
                //is greater than the one we are looking for.  Then continue like nothing
                //happened!
                u = m - 1;
                nLocus = m;
                nTest = -1;

                continue;
            }
            //We need to get the object path for this entry....
            wchar_t *pszCurKey = (wchar_t *)GetPointer(pIndex[m].dwObjPathPage, pIndex[m].dwObjPathOffset);
            if (pszCurKey == NULL)
                return Failed;

            nTest = wbem_wcsicmp(pszKey, pszCurKey);
            if (nTest < 0)
            {
                u = m - 1;
                nLocus = m;
            }
            else if (nTest > 0)
            {
                l = m + 1;
                nLocus = l;
            }
            else
            {
                //If an entry already exists we need to return the results
                *dwObjectPage = pIndex[m].dwObjectPage;
                *dwObjectOffset = pIndex[m].dwObjectOffset;
                return NoError;
            }
        }

        //Test to see if we have gone as far a we need to go...
        if (nTest < 0)
            return NotFound;

        //Otherwise we move on to the next block.
        dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
        dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;
    }
    return NotFound;
}

/*============================================================================
 *
 * CWbemSharedMem::RemoveIndexedItem()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::RemoveIndexedItem(const wchar_t *pszKey)
{
    //We need to work through each of the index blocks until we find the item we are
    //looking for.  If we do not find the item we return an error!
    DWORD dwIndexPage = m_pHeader->dwFirstIndexBlockPage;
    DWORD dwIndexOffset = m_pHeader->dwFirstIndexBlockOffset;
    DWORD dwPrevIndexPage = 0;
    DWORD dwPrevIndexOffset = 0;

    while ((dwIndexPage != 0) || (dwIndexOffset != 0))
    {
        //Get a pointer to the header and index entries...
        SHMEM_INDEX_HEADER *pIndexHeader = (SHMEM_INDEX_HEADER *)GetPointer(dwIndexPage, dwIndexOffset);
        if (pIndexHeader == NULL)
            return Failed;

        SHMEM_INDEX *pIndex = (SHMEM_INDEX *)(PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));

        //Before we do a binary search, we can do a quick check to see if it is in
        //this index block.  This can speed things up quite a bit when there are
        //large numbers of indexes...
        if ((pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathPage != 0) ||
            (pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathOffset != 0))
        {
            //Get the pointer to this item....          
            wchar_t *pszCurKey = (wchar_t *)GetPointer(pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathPage, pIndex[pIndexHeader->dwIndexLength - 1].dwObjPathOffset);
            if (pszCurKey == NULL)
                return Failed;

            int nTest = wbem_wcsicmp(pszKey, pszCurKey);
            if (nTest > 0)
            {
                //That's what we were looking for.  The current key is greater than the
                //last one in this block.  Move to the next promptly...
                dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
                dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;

                continue;
            }
        }

        //Now we need to do a binary search of this index.  Note that the last index
        //block may have some free space at the end of the block, so we should
        //ignore these....

        int l = 0, u = pIndexHeader->dwIndexLength - 1;
        BOOL bFound = FALSE;
        int nLocus = 0; //This is where we should insert an item
        int nTest = 0;      //What the last compare result shows

        while (l <= u)
        {
            int m = (l + u) / 2;

            //OK, lets do that test to see if this entry is not used...
            if ((pIndex[m].dwObjPathPage == 0) &&
                (pIndex[m].dwObjPathOffset == 0))
            {
                //This entry is empty.  We need to deal with this as through this entry
                //is greater than the one we are looking for.  Then continue like nothing
                //happened!
                u = m - 1;
                nLocus = m;

                continue;
            }
            //We need to get the object path for this entry....
            wchar_t *pszCurKey = (wchar_t *)GetPointer(pIndex[m].dwObjPathPage, pIndex[m].dwObjPathOffset);
            if (pszCurKey == NULL)
                return Failed;

            nTest = wbem_wcsicmp(pszKey, pszCurKey);
            if (nTest < 0)
            {
                u = m - 1;
                nLocus = m;
            }
            else if (nTest > 0)
            {
                l = m + 1;
                nLocus = l;
            }
            else
            {
                //We found what we were looking for..... Lets deal with it!
                return _RemoveIndexAt(pIndexHeader, m);
            }
        }

        //Test to see if we have gone as far a we need to go...
        if (nTest < 0)
            return NotFound;


        //Otherwise we move on to the next block.
        dwIndexPage = pIndexHeader->dwNextIndexBlockPage;
        dwIndexOffset = pIndexHeader->dwNextIndexBlockOffset;
    }

    return NotFound;
}

/*============================================================================
 *
 * CWbemSharedMem::_RemoveIndexAt()
 *
 *
 * Returns:
 *      NoError - Everything worked
 *============================================================================
 */
int CWbemSharedMem::_RemoveIndexAt(SHMEM_INDEX_HEADER *pIndexHeader, int dwIndexEntry)
{
    //Get the index pointer...
    SHMEM_INDEX *pIndex = (SHMEM_INDEX *)(PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));

    //Get the object path (key) details so we can safely delete it later
    DWORD dwObjPathPage, dwObjPathOffset;

    dwObjPathPage = pIndex[dwIndexEntry].dwObjPathPage;
    dwObjPathOffset = pIndex[dwIndexEntry].dwObjPathOffset;

    //Now remove the entry from the index by shifting the indexes around....
    //this is a call to a recursive method...
    int nRet = _RemoveRoomForIndex(pIndexHeader, dwIndexEntry);

    if (nRet != NoError)
        return nRet;

    //Free up the memory for the object path (key)
    FreeBlock(dwObjPathPage, dwObjPathOffset);
    
    return NoError;

}

int CWbemSharedMem::_RemoveRoomForIndex(SHMEM_INDEX_HEADER *pIndexHeader, int dwIndexEntry)
{
    struct SHMEM_INDEX  *pIndex;

    pIndex = (struct SHMEM_INDEX *) (PBYTE(pIndexHeader) + sizeof(SHMEM_INDEX_HEADER));

    //We need to shift the block down one place
    //Copy everything from where we want to make space up to the end (minus 1!) down 1 place
    memmove(&pIndex[dwIndexEntry],
            &pIndex[dwIndexEntry + 1],
            sizeof(SHMEM_INDEX) * (pIndexHeader->dwIndexLength - dwIndexEntry - 1));

    //If there is a next page, grab the first item of it and stick it at the end
    //of this block
    if ((pIndexHeader->dwNextIndexBlockPage != 0) ||
        (pIndexHeader->dwNextIndexBlockOffset != 0))
    {
        SHMEM_INDEX_HEADER *pNextIndexHeader;
        pNextIndexHeader = (SHMEM_INDEX_HEADER *)GetPointer(pIndexHeader->dwNextIndexBlockPage, pIndexHeader->dwNextIndexBlockOffset);
        if (pNextIndexHeader == NULL)
            return Failed;

        memcpy(&pIndex[pIndexHeader->dwIndexLength - 1], PBYTE(pNextIndexHeader) + sizeof(SHMEM_INDEX_HEADER), sizeof(SHMEM_INDEX));

        //Now we need to do the same for the next index block...
        return _RemoveRoomForIndex(pNextIndexHeader, 0);
    }
    else
    {
        //otherwise we need to blank out the last entry
        memset(&pIndex[pIndexHeader->dwIndexLength - 1], 0, sizeof(SHMEM_INDEX));
    }

    return NoError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\shmlock.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SHMLOCK.H

Abstract:

    Shared Memory Lock

History:

--*/

#ifndef __SHARED_MEMORY_LOCK__H_
#define __SHARED_MEMORY_LOCK__H_

struct COREPROX_POLARITY SHARED_LOCK_DATA
{
    long m_lLock;
	long m_lLockCount;
    DWORD m_dwThreadId;

    SHARED_LOCK_DATA() : m_lLock(-1), m_dwThreadId(0), m_lLockCount(0){}
    void Init()
    {
        m_lLock = -1;
        m_dwThreadId = 0;
		m_lLockCount = 0;
    }
};

class COREPROX_POLARITY CSharedLock
{
protected:
    volatile SHARED_LOCK_DATA* m_pData;
public:
    inline BOOL Lock()
    {
        SHARED_LOCK_DATA* pData = (SHARED_LOCK_DATA*)m_pData; 

        int		nSpin = 0;
		BOOL	fAcquiredLock = FALSE,
				fIncDec = FALSE;

		// Only do this once
		DWORD	dwCurrentThreadId = GetCurrentThreadId();

		// Check if we are the current owning thread.  We can do this here because
		// this test will ONLY succeed in the case where we have a Nested Lock(),
		// AND because we are zeroing out the thread id when the lock count hits
		// 0.

		if( dwCurrentThreadId == pData->m_dwThreadId )
		{
			// It's us - Bump the lock count
			// =============================

			// Don't need to use InterlockedInc/Dec here because
			// this will ONLY happen on pData->m_dwThreadId.

			++(pData->m_lLockCount);
			return TRUE;
		}


        while( !fAcquiredLock )
        {

			// We only increment/decrement when pData->m_lLock is -1
			if ( pData->m_lLock == -1 )
			{
				fIncDec = TRUE;

				// Since only one thread will get the 0, it is this thread that
				// actually acquires the lock.
				fAcquiredLock = ( InterlockedIncrement( &(pData->m_lLock) ) == 0 );
			}
			else
			{

				fIncDec = FALSE;
			}

			// Only spins if we don't acquire the lock
			if ( !fAcquiredLock )
			{

				// Clean up our Incremented value only if we actually incremented
				// it to begin with
				if ( fIncDec )
					InterlockedDecrement(&(pData->m_lLock));

				// to spin or not to spin
				if(nSpin++ == 10000)
				{
					// We've been spinning long enough --- yield
					// =========================================
					Sleep(0);
					nSpin = 0;
				}

				// The rule is that if this is switched out it must ONLY be done with
				// a new data block and not one that has been used for locking elsewhere.

				pData = (SHARED_LOCK_DATA*)m_pData; // in case it's been switched

			}	// IF !fAcquiredLock

        }	// WHILE !fAcquiredLock

		// We got the lock so increment the lock count.  Again, we are not
		// using InterlockedInc/Dec since this should all only occur on a
		// single thread.

		++(pData->m_lLockCount);
        pData->m_dwThreadId = dwCurrentThreadId;

        return TRUE;
    }

    inline BOOL Unlock()
    {
		// SINCE we assume this is happening on a single thread, we can do this
		// without calling InterlockedInc/Dec.  When the value hits zero, at that
		// time we are done with the lock and can zero out the thread id and
		// decrement the actual lock test value.

		if ( --(m_pData->m_lLockCount) == 0 )
		{
			m_pData->m_dwThreadId = 0;
	        InterlockedDecrement((long*)&(m_pData->m_lLock));
		}

        return TRUE;
    }

    void SetData(SHARED_LOCK_DATA* pData)
    {
        m_pData = pData;
    }


	inline void FastLock()
#ifdef i386
	{
		SHARED_LOCK_DATA *pData;
		DWORD threadId = GetCurrentThreadId();
//		__asm
//		{
//			mov eax,fs:[18h];
//			mov eax,dword ptr [eax+24h];
//			mov	threadId, eax;
//
//		}
		
	TryAgain:
		pData = (SHARED_LOCK_DATA*)m_pData;
		__asm
		{

		// Do an InterlockedIncrement on the value....
		mov         ecx,dword ptr [pData] ;
		mov         eax,1 ;
		lock xadd   dword ptr [ecx],eax ;
		inc         eax ;

		// If the result is zero we can return
		jz FinishedAndSetThreadId;

		//Check to make sure the current thread ID is the same as the one currently holding
		//the lock....
		mov eax, threadId ;

		mov ecx, pData;
		add ecx, 4;

		xor eax, dword ptr [ecx] ;

		// If this was zero, we are the same thread so return...
		jz Finished;
		
		//Do an InterlockedIncrement
		lea ecx, dword ptr[pData] ;
		mov eax, 0FFFFFFFFh ;
		lock xadd dword ptr [ecx], eax ;

		//Sleep for 0 (which causes a context switch...)
		xor eax, eax ;
		push eax ;
		call dword ptr [Sleep];

		//Try the whole lot again...
		jmp TryAgain ;

FinishedAndSetThreadId:
		mov ecx, pData;
		add ecx, 4;
		mov eax, threadId;

		mov dword ptr [ecx], eax ;

Finished:
		}

	}
#else
	{
        SHARED_LOCK_DATA* pData = (SHARED_LOCK_DATA*)m_pData; 
		DWORD dwThreadId = GetCurrentThreadId();

        while(InterlockedIncrement(&(pData->m_lLock)))
        {
            // Someone has it
            // ==============

            if(dwThreadId == pData->m_dwThreadId)
            {
                // It's us
                // =======
                return;
            }
            InterlockedDecrement(&(pData->m_lLock));
            pData = (SHARED_LOCK_DATA*)m_pData; // in case it's been switched
        }
        pData->m_dwThreadId = dwThreadId;
	}
#endif
};
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\sinkmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SINKMRSH.H

Abstract:

    IWbemObjectSink marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <objindpacket.h>
#include <lockst.h>
#include "mrshbase.h"

//***************************************************************************
//
//  class CSinkFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CSinkFactoryBuffer : public CUnkInternal
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XSinkFactory : public CImpl<IPSFactoryBuffer, CSinkFactoryBuffer>
    {
    public:
        XSinkFactory(CSinkFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CSinkFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XSinkFactory;
public:
    CSinkFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_pLifeControl( pControl ), m_XSinkFactory(this)
    {
    }
    ~CSinkFactoryBuffer()
    {
    }    

    void* GetInterface(REFIID riid);

	friend XSinkFactory;
};

//***************************************************************************
//
//  class CSinkProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CSinkProxyBuffer : public CBaseProxyBuffer
{
private:
    enum {OLD, NEW, UNKNOWN} m_StubType;
    CWbemClassToIdMap m_ClassToIdMap;

protected:
	IWbemObjectSink*	m_pOldProxySink;

protected:
    class XSinkFacelet : public IWbemObjectSink
    {
    protected:
        CSinkProxyBuffer* m_pObject;
        CriticalSection m_csSafe;        

    public:
        XSinkFacelet(CSinkProxyBuffer* pObject) : m_pObject(pObject), m_csSafe(false){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray );
		HRESULT STDMETHODCALLTYPE SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam );
    } m_XSinkFacelet;
    friend XSinkFacelet;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

public:
    CSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CSinkProxyBuffer();
};

//***************************************************************************
//
//  class CSinkStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CSinkStubBuffer : public CBaseStubBuffer
{

protected:
    class XSinkStublet : public CBaseStublet
    {
        IWbemObjectSink* m_pServer;
        CWbemClassCache m_ClassCache;
        bool m_bFirstIndicate;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XSinkStublet(CSinkStubBuffer* pObj);
        ~XSinkStublet();

        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        
	private:
		HRESULT Indicate_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer );
        friend CSinkStubBuffer;
    } m_XSinkStublet;
    friend XSinkStublet;

public:
    CSinkStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer( pControl, pUnkOuter ), m_XSinkStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\sinkmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SINKMRSH.CPP

Abstract:

    IWbemObjectSink marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "sinkmrsh.h"
#include <fastall.h>
#include <fastobj.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSinkFactoryBuffer::XSinkFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSinkFactoryBuffer::XSinkFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemObjectSink)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CSinkProxyBuffer* pProxy = new CSinkProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CSinkFactoryBuffer::XSinkFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemObjectSink 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CSinkFactoryBuffer::XSinkFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemObjectSink)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CSinkStubBuffer* pStub = new CSinkStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CSinkFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XSinkFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSinkProxyBuffer::CSinkProxyBuffer
//  ~CSinkProxyBuffer::CSinkProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CSinkProxyBuffer::CSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IWbemObjectSink ), 
        m_XSinkFacelet(this), m_pOldProxySink( NULL )
{
    m_StubType = UNKNOWN;
}

CSinkProxyBuffer::~CSinkProxyBuffer()
{
    // This should be cleaned up here

    if ( NULL != m_pOldProxySink )
    {
        m_pOldProxySink->Release();
    }

}

void* CSinkProxyBuffer::GetInterface( REFIID riid )
{
    if(riid == IID_IWbemObjectSink)
        return &m_XSinkFacelet;
    else return NULL;
}

void** CSinkProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxySink;
}

void CSinkProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxySink )
    {
        m_pOldProxySink->Release();
        m_pOldProxySink = NULL;
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//                      Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemObjectSink::Indicate calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )
{
    HRESULT hr = S_OK;

    // Make sure the lObjectCount parameter and the array pointer make sense

    if ( lObjectCount < 0 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount == 0 && NULL != ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount > 0 && NULL == ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    LockGuard<CriticalSection> gl(m_csSafe);
    if(gl.locked() == false)
        return WBEM_E_OUT_OF_MEMORY;

    // If the stublet is an old style, just let the old proxy handle it

    if(m_pObject->m_StubType == OLD) 
        return m_pObject->m_pOldProxySink->Indicate( lObjectCount, ppObjArray );

    // If the stublet is unknown, send just the first object and check the return
    // code to determine what is on the other side. 

    if(m_pObject->m_StubType == UNKNOWN) 
    {
        hr = m_pObject->m_pOldProxySink->Indicate( 1, ppObjArray );

        // bump up pointer to the next object so that it isnt sent more than once
    
        lObjectCount--;
        ppObjArray++;

        if(FAILED(hr))
            return hr;
        if(hr == WBEM_S_NEW_STYLE)
        {
            m_pObject->m_StubType = NEW;
        }
        else
        {
            // We have an old client, set the stub type and send any remaining objects

            m_pObject->m_StubType = OLD;
            if(lObjectCount > 0)
                hr = m_pObject->m_pOldProxySink->Indicate( lObjectCount, ppObjArray );
            return hr;
        }
    }

    if(lObjectCount < 1)
        return S_OK;            // if all done, then just return.

    // Create a packet and some data for it to use.  Then calculate 
    // the length of the packet

    DWORD dwLength = 0;
    GUID* pguidClassIds = new GUID[lObjectCount];
    BOOL* pfSendFullObject = new BOOL[lObjectCount];

    // arrays will be deleted when we drop out of scope.
    CVectorDeleteMe<GUID>   delpguidClassIds( pguidClassIds );
    CVectorDeleteMe<BOOL>   delpfSendFullObject( pfSendFullObject );

    if ( NULL == pguidClassIds || NULL == pfSendFullObject )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemObjSinkIndicatePacket packet;
    hr = packet.CalculateLength(lObjectCount, ppObjArray, &dwLength, 
            m_pObject->m_ClassToIdMap, pguidClassIds, pfSendFullObject );
    if (FAILED(hr))
    {
#ifdef DBG
        char pBuff[128];
        sprintf(pBuff,"CSinkProxyBuffer::XSinkFacelet::Indicate %08x\n",hr);
        OutputDebugStringA(pBuff);
#endif
    	return hr;
    }

    // Declare the message structure

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = dwLength;

    // This is the id of the Invoke function.  This MUST be set before calling GetBuffer, or 
    // it will fail.

    msg.iMethod = 3;

    // allocate the channel buffer and marshal the data into it

    HRESULT hres = m_pObject->GetChannel()->GetBuffer(&msg, IID_IWbemObjectSink);
    if(FAILED(hres)) return hres;

#ifdef DBG
    BYTE * pCheckTail = (BYTE *)CBasicBlobControl::sAllocate(dwLength+8);
    if (!pCheckTail)
    	return WBEM_E_OUT_OF_MEMORY;

    BYTE * pTail = pCheckTail+dwLength;
    memcpy(pTail,"TAILTAIL",8);


    hr = packet.MarshalPacket(  pCheckTail, dwLength, lObjectCount, ppObjArray, 
                                             pguidClassIds, pfSendFullObject);

    if (0 != memcmp(pTail,"TAILTAIL",8))
    	DebugBreak();
    
    memcpy(msg.Buffer,pCheckTail,dwLength);
    
    CBasicBlobControl::sDelete(pCheckTail);
#else
    // Setup the packet for marshaling
    hr = packet.MarshalPacket(  (LPBYTE)msg.Buffer, dwLength, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);
#endif /* DBG*/

    // Send the data to the stub only if the marshaling was successful

    if ( SUCCEEDED( hr ) )
    {

        DWORD dwRes;
        hr = m_pObject->GetChannel()->SendReceive(&msg, &dwRes);
        if(FAILED(hr))
        {
            if(msg.Buffer)
                m_pObject->GetChannel()->FreeBuffer(&msg);
            return dwRes;
        }

        // We appear to be ok, so get HRESULT

        LPBYTE pbData = (LPBYTE) msg.Buffer;
        hr = *((HRESULT*) pbData);
        m_pObject->GetChannel()->FreeBuffer(&msg);

    }
    else
    {
        // Clean up the buffer -- Marshaling the packet failed
        if(msg.Buffer)
            m_pObject->GetChannel()->FreeBuffer(&msg);
    }

    return hr;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//     SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemObjectSink::SetStatus calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
      SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam )
{

    // Just pass through to the old sink.
    HRESULT hr = RPC_E_DISCONNECTED;
    try {
        if (m_pObject->m_pOldProxySink)
        {
            hr = m_pObject->m_pOldProxySink->SetStatus( lFlags, hResult, strParam, pObjParam );
        }
    } catch(...) {
        
    }
    return hr;

}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CSinkStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XSinkStublet;
    else
        return NULL;
}

CSinkStubBuffer::XSinkStublet::XSinkStublet(CSinkStubBuffer* pObj) 
    : CBaseStublet(pObj, IID_IWbemObjectSink), m_pServer(NULL)
{
    m_bFirstIndicate = true;
}

CSinkStubBuffer::XSinkStublet::~XSinkStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CSinkStubBuffer::XSinkStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CSinkStubBuffer::XSinkStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CSinkStubBuffer::XSinkStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CSinkStubBuffer::XSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSinkStubBuffer::XSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( pMessage->iMethod == 3 )
        return Indicate_Stub( pMessage, pChannel );
    else if ( pMessage->iMethod == 4 )
        return GetOldStub()->Invoke( pMessage, pChannel );
    else
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;

}

//***************************************************************************
//
//  HRESULT CSinkStubBuffer::XSinkStublet::Indicate_Stub( RPCOLEMESSAGE* pMessage, 
//                                                        IRpcChannelBuffer* pBuffer )
//
//  DESCRIPTION:
//
//  Handles the Indicate function in the stublet.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CSinkStubBuffer::XSinkStublet::Indicate_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer )
{
    HRESULT             hr = RPC_E_SERVER_CANTUNMARSHAL_DATA;
    SCODE sc;

    // Determine if an old style, or new style packet has arrived

    CWbemObjSinkIndicatePacket packet( (LPBYTE) pMessage->Buffer, pMessage->cbBuffer);
    sc = packet.IsValid();
    bool bOldStyle = (S_OK != packet.IsValid());

    if(bOldStyle)
    {
        // Pass the call in using the old style stub

        hr = GetOldStub()->Invoke( pMessage, pBuffer );

		// Invoke must return S_OK, m_bFirstIndicate must be true and the actual return
		// code from the implementation code must be S_OK.

        if( hr == S_OK && m_bFirstIndicate && *(( HRESULT __RPC_FAR * )pMessage->Buffer) == S_OK )
        {
            // Let proxy know that we can handle the new style by returning a special return code.
        
            *(( HRESULT __RPC_FAR * )pMessage->Buffer) = WBEM_S_NEW_STYLE;
            m_bFirstIndicate = false;
            return hr;
        }
        return hr;
    }
    m_bFirstIndicate = false;

    // Got some new style data.  Unmarshall it.

    long lObjectCount; 
    IWbemClassObject ** pObjArray;
    sc = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

    // Only continue if the Unmarshaling succeeded.  If it failed, we still want
    // the sc to go back to the other side

    if ( SUCCEEDED( sc ) )
    {

        // Call the acual sink

        sc = m_pServer->Indicate( lObjectCount, pObjArray );


        for ( int nCtr = 0; nCtr < lObjectCount; nCtr++ )
        {
            pObjArray[nCtr]->Release();
        }
    
        delete [] pObjArray;

    }

    // Send the results back

    pMessage->cbBuffer = sizeof(HRESULT);

    hr = pBuffer->GetBuffer( pMessage, IID_IWbemObjectSink );

    if ( SUCCEEDED( hr ) )
    {
        ((HRESULT*)pMessage->Buffer)[0] = sc;
    }
    else
    {
        hr = sc;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smrtenum.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SMRTENUM.CPP

Abstract:

  CWbemEnumMarshling implementation.

  Implements the _IWbemEnumMarshaling interface.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "fastall.h"
#include "smrtenum.h"
#include <corex.h>

//***************************************************************************
//
//  CWbemEnumMarshaling::~CWbemEnumMarshaling
//
//***************************************************************************
// ok
CWbemEnumMarshaling::CWbemEnumMarshaling( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk(pControl, pOuter),
	m_XEnumMarshaling( this )
{
}
    
//***************************************************************************
//
//  CWbemEnumMarshaling::~CWbemEnumMarshaling
//
//***************************************************************************
// ok
CWbemEnumMarshaling::~CWbemEnumMarshaling()
{
}

// Override that returns us an interface
void* CWbemEnumMarshaling::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWbemEnumMarshaling)
        return &m_XEnumMarshaling;
    else
        return NULL;
}

/* _IWbemEnumMarshaling methods */

HRESULT CWbemEnumMarshaling::XEnumMarshaling::GetMarshalPacket( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
																ULONG* pdwBuffSize, byte** pBuffer )
{
	return m_pObject->GetMarshalPacket( proxyGUID, uCount, apObjects, pdwBuffSize, pBuffer );
}


// Specifies everything we could possibly want to know about the creation of
// an object and more.
HRESULT CWbemEnumMarshaling::GetMarshalPacket( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
												ULONG* pdwBuffSize, byte** pBuffer )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		CInCritSec	ics( &m_cs );

		// Look for the GUID in the cache.  If we don't find it, it's new so add it
		CWbemClassToIdMap*		pClassToId = NULL;
		CGUID					guid( proxyGUID );

		hr = m_GuidToClassMap.GetMap( guid, &pClassToId );

		if ( FAILED( hr ) )
		{
			hr = m_GuidToClassMap.AddMap( guid, &pClassToId );
		}

		// Only continue if we have a cache to work with
		if ( SUCCEEDED( hr ) )
		{

			// Only marshal data if we need to
			if ( uCount > 0 )
			{
				// Calculate data length first
				DWORD dwLength = 0;
				GUID* pguidClassIds = new GUID[uCount];
				BOOL* pfSendFullObject = new BOOL[uCount];
				CWbemSmartEnumNextPacket packet;

				// Auto cleanup
				CVectorDeleteMe<GUID>	vdm1( pguidClassIds );
				CVectorDeleteMe<BOOL>	vdm2( pfSendFullObject );

                if(pguidClassIds && pfSendFullObject)
				{
    				hr = packet.CalculateLength(uCount, apObjects, &dwLength,
						*pClassToId, pguidClassIds, pfSendFullObject );
				}
                else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

				if ( SUCCEEDED( hr ) )
				{

					// As we could be going cross process/machine, use the
					// COM memory allocator
					LPBYTE pbData = (LPBYTE) CoTaskMemAlloc( dwLength );

					if ( NULL != pbData )
					{
						// hr contains the actual proper return code, so let's not overwrite
						// that valu unless something goes wrong during marshaling.

						// Write the objects out to the buffer
						hr = packet.MarshalPacket( pbData, dwLength, uCount, apObjects,
													 pguidClassIds, pfSendFullObject);

						// Copy the values, we're golden.
						if ( SUCCEEDED( hr ) )
						{
							*pdwBuffSize = dwLength;
							*pBuffer = pbData;
						}
						else
						{
							// Clean up the memory --- something went wrong
							CoTaskMemFree( pbData );
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

				}	// IF CalculateLength()

			}	// IF *puReturned > 0
			else
			{
				// NULL these out
				*pdwBuffSize = 0;
				*pBuffer = NULL;
			}


		}

		return hr;
	}
	catch ( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smartnextpacket.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMARTNEXTPACKET.CPP

Abstract:

    Smart Next Packets

History:


--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "smartnextpacket.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::CWbemSmartEnumNextPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemSmartEnumNextPacket::CWbemSmartEnumNextPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pSmartEnumNext( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pSmartEnumNext = (PWBEM_DATAPACKET_SMARTENUM_NEXT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::~CWbemSmartEnumNextPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemSmartEnumNextPacket::~CWbemSmartEnumNextPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemSmartEnumNextPacket::CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwLength = 0;

    // Now get the size of the objects as described by the object array
    CWbemObjectArrayPacket  arrayPacket;

    hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwLength, classtoidmap, pguidClassIds, pfSendFullObject );

    // Store the length if we're okey-dokey
    if ( SUCCEEDED( hr ) )
    {
        // Account for the header sizes
        *pdwLength = ( dwLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_SMARTENUM_NEXT ) );
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemSmartEnumNextPacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_SMARTENUM_NEXT, 0 );

    if ( SUCCEEDED( hr ) )
    {
        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pSmartEnumNext;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the packet Header
        m_pSmartEnumNext->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);
        m_pSmartEnumNext->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);
        dwLength -= sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);

        // Now use the array packet class to marshal the objects into the buffer
        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemSmartEnumNextPacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pSmartEnumNext;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and use the object array to unmarshal the
        // objects from the buffer

        // Points us at the first object
        pbData += sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);
        dwLength -= sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);

        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemSmartEnumNextPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pSmartEnumNext = (PWBEM_DATAPACKET_SMARTENUM_NEXT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pSmartEnumNext = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smartnextpacket.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMARTNEXTPACKET.H

Abstract:

    Smart Next Packets

History:


--*/

#ifndef __SMARTNEXTPACKET_H__
#define __SMARTNEXTPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemWCOSmartEnum::Next() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_SMARTENUM_NEXT
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_SMARTENUM_NEXT;

typedef WBEM_DATAPACKET_SMARTENUM_NEXT* PWBEM_DATAPACKET_SMARTENUM_NEXT;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemSmartEnumNextPacket
//
//	This class is designed to wrapper a data packet that describes data
//	for IWbemWCOSmartEnum::Next.  Basically, it sits in front of an oject
//	array packet that describes 1..n IWbemClassObject packets.
//

class COREPROX_POLARITY CWbemSmartEnumNextPacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_SMARTENUM_NEXT	m_pSmartEnumNext;

public:

	CWbemSmartEnumNextPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemSmartEnumNextPacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemSmartEnumNextPacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcmrsh.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCMRSH.CPP

Abstract:

    IWbemServices marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "Svcmrsh.h"
#include <fastall.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSvcFactoryBuffer::XSvcFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSvcFactoryBuffer::XSvcFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemServices)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CSvcProxyBuffer* pProxy = new CSvcProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
		sc = pProxy->Init();

		if ( SUCCEEDED( sc ) )
		{
			pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
			sc = pProxy->QueryInterface(riid, (void**)ppv);
		}
		else
		{
			delete pProxy;
		}

    }

    return sc;
}

//***************************************************************************
//
//  CSvcFactoryBuffer::XSvcFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemServices 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CSvcFactoryBuffer::XSvcFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemServices)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CSvcStubBuffer* pStub = new CSvcStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CSvcFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSvcFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CSvcFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XSvcFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSvcProxyBuffer::CSvcProxyBuffer
//  ~CSvcProxyBuffer::CSvcProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CSvcProxyBuffer::CSvcProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IWbemServices ), 
        m_pWrapperProxy( NULL ), m_pOldProxySvc( NULL )
{
}

CSvcProxyBuffer::~CSvcProxyBuffer()
{
    // This should be cleaned up here

    if ( NULL != m_pOldProxySvc )
    {
        m_pOldProxySvc->Release();
    }

	if ( NULL != m_pWrapperProxy )
	{
		m_pWrapperProxy->Release();
	}

}

HRESULT CSvcProxyBuffer::Init( void )
{
    m_pWrapperProxy = new CWbemSvcWrapper( m_pControl, m_pUnkOuter );

	if ( NULL == m_pWrapperProxy )
	{
		return E_OUTOFMEMORY;
	}

	m_pWrapperProxy->AddRef();

	return S_OK;
}

void* CSvcProxyBuffer::GetInterface( REFIID riid )
{
    if( riid == IID_IWbemServices )
	{
		void*	pvData = NULL;

		// This will AddRef the UnkOuter, so we need to release, and
		// then we'll return pvoid, which will get Addref'd again
		// isn't aggregation wonderful

		m_pWrapperProxy->QueryInterface( riid, &pvData );
		((IUnknown*) pvData)->Release();

		return pvData;
	}

    else return NULL;
}

void** CSvcProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxySvc;
}

void CSvcProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxySvc )
    {
        m_pOldProxySvc->Release();
        m_pOldProxySvc = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CSvcProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.  We let the base class initialize first, then pass the
//	base proxy into the delegator
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSvcProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    HRESULT             hr = CBaseProxyBuffer::Connect(pChannel);

	if ( SUCCEEDED( hr ) )
	{
		m_pWrapperProxy->SetProxy( m_pOldProxySvc );
	}

    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CSvcProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//	We cleanup before the base cleans up, or things can and will beef
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CSvcProxyBuffer::Disconnect()
{
	// Disconnect the wrapper proxy.  We should release the actual Wrapper
	// when we destruct
	if ( NULL != m_pWrapperProxy )
	{
		m_pWrapperProxy->Disconnect();
	}

	CBaseProxyBuffer::Disconnect();

}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CSvcFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSvcFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CSvcStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XSvcStublet;
    else
        return NULL;
}

CSvcStubBuffer::XSvcStublet::XSvcStublet(CSvcStubBuffer* pObj) 
    : CBaseStublet(pObj, IID_IWbemServices), m_pServer(NULL)
{
}

CSvcStubBuffer::XSvcStublet::~XSvcStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CSvcStubBuffer::XSvcStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CSvcStubBuffer::XSvcStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CSvcStubBuffer::XSvcStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smrtenum.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SMRTENUM.H

Abstract:

  CWbemEnumMarshaling Definition.

  Standard definition for _IWbemEnumMarshaling.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _SMRTENUM_H_
#define _SMRTENUM_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include <sync.h>

// Marshaling Packet definitions
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <wbemguidtoclassmap.h>
#include <smartnextpacket.h>

//***************************************************************************
//
//  class CWbemEnumMarshaling
//
//  Implementation of _IWbemEnumMarshaling Interface
//
//***************************************************************************

class COREPROX_POLARITY CWbemEnumMarshaling : public CUnk
{
protected:
	// Maintains per proxy class maps
	CWbemGuidToClassMap	m_GuidToClassMap;
	CCritSec			m_cs;

public:
    CWbemEnumMarshaling(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CWbemEnumMarshaling(); 

	/* _IWbemEnumMarshaling methods */
    HRESULT GetMarshalPacket( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
								ULONG* pdwBuffSize, byte** pBuffer );

    class COREPROX_POLARITY XEnumMarshaling : public CImpl<_IWbemEnumMarshaling, CWbemEnumMarshaling>
    {
    public:
        XEnumMarshaling(CWbemEnumMarshaling* pObject) : 
            CImpl<_IWbemEnumMarshaling, CWbemEnumMarshaling>(pObject)
        {}

		STDMETHOD(GetMarshalPacket)( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
									ULONG* pdwBuffSize, byte** pBuffer );

    } m_XEnumMarshaling;
    friend XEnumMarshaling;


protected:
    void* GetInterface(REFIID riid);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcmrsh.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCMRSH.H

Abstract:

    IWbemServices marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include "mrshbase.h"
#include "svcwrap.h"

//***************************************************************************
//
//  class CSvcFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemService interface.
//
//***************************************************************************

class CSvcFactoryBuffer : public CUnkInternal
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XSvcFactory : public CImpl<IPSFactoryBuffer, CSvcFactoryBuffer>
    {
    public:
        XSvcFactory(CSvcFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CSvcFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XSvcFactory;
public:
    CSvcFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_pLifeControl( pControl ), m_XSvcFactory(this)
    {
    }
    ~CSvcFactoryBuffer()
    {
    }    
    

    void* GetInterface(REFIID riid);

	friend XSvcFactory;
};

//***************************************************************************
//
//  class CSvcProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemServices interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CSvcProxyBuffer : public CBaseProxyBuffer
{
protected:
	IWbemServices*	m_pOldProxySvc;
	CWbemSvcWrapper*	m_pWrapperProxy;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

	// Special overrides
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();

public:
    CSvcProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CSvcProxyBuffer();

	HRESULT Init( void );
};

//***************************************************************************
//
//  class CSvcStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemServices interface.
//
//***************************************************************************

class CSvcStubBuffer : public CBaseStubBuffer
{

protected:
    class XSvcStublet : public CBaseStublet
    {
        IWbemServices* m_pServer;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XSvcStublet(CSvcStubBuffer* pObj);
        ~XSvcStublet();

	private:
        friend CSvcStubBuffer;
    } m_XSvcStublet;
    friend XSvcStublet;

public:
    CSvcStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer( pControl, pUnkOuter ), m_XSvcStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\strm.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRM.H

Abstract:

  CMemStream implementation.

  CMemStream implementation for WBEM.

  This is a thread-safe generic data stream which can be used
  with memory objects, pipes, mailslots, or files.  This is the basic
  object for interface & call marshaling.

  a-raymcc    04-Apr-96   Created.
  a-raymcc    06-Jun-96   CArena support.
  a-raymcc    11-Sep-96   Support NULL pointers

  Supported types:
      VT_NULL

      VT_UI1, VT_I1, VT_UI2, VT_I2, VT_UI4, VT_I4, VT_I8, VT_UI8
      VT_R4, VT_R8, VT_BOOL

      VT_LPSTR, VT_LPWSTR, VT_BSTR

      VT_CLSID, VT_UNKNOWN, VT_FILETIME, VT_ERROR, VT_BLOB, VT_PTR

      VT_EMPTY = End of stream

      VT_USERDEFINED      
          VT_EX_VAR
          VT_EX_VARVECTOR

History:

--*/


#ifndef _STRM_H_
#define _STRM_H_
#include "corepol.h"

#include <arena.h>
#include <var.h>
#include <wbemutil.h>

#define SIGNATURE_STREAM            0x80F6A003

#pragma warning(disable: 4275)

class COREPROX_POLARITY CMemStream : public IStream
{
protected:

    // Types, constants.
    // =================
    enum { stack_size = 32 };

    struct STREAM_HEADER
    {
        DWORD dwSignature;
        DWORD dwLength;

        STREAM_HEADER() { dwSignature = SIGNATURE_STREAM; }
        BOOL Verify() { return SIGNATURE_STREAM == dwSignature; }
    };

    // Member variables.
    // =================
    int     m_nStatus;
    DWORD   m_dwSize;
    DWORD   m_dwGrowBy;
    DWORD   m_dwCurrentPos;
    DWORD   m_dwEndOfStream;
    BYTE    *m_pBuffer;
    int     m_nFlags;
    DWORD   m_dwStack[stack_size];
    int     m_nStackPtr;
    
    long    m_lRef;

    // protected functions.
    // ==================
    void Empty();
    int Resize(DWORD dwNewSize);
    void UpdateHdr() { ((STREAM_HEADER *)m_pBuffer)->dwLength = m_dwEndOfStream; }
            
public:
    enum { no_error, failed, type_mismatch, end_of_stream, 
           out_of_memory, critical_error, invalid_parameter , timeout };
        
    enum { auto_delete, no_delete };
    
    CMemStream(
        int nFlags = auto_delete, 
        int nInitialSize = 512, 
        int nGrowBy = 512
        );

    CMemStream(
        LPVOID pBindingAddress,
        int nFlags = auto_delete, 
        int nGrowBy = 512
        );
        
    CMemStream(CMemStream &Src);
    CMemStream &operator =(CMemStream &Src);
   ~CMemStream();
        // Releases the arena

    void Push() { m_dwStack[++m_nStackPtr] = m_dwCurrentPos; }
    void Pop(BOOL bDiscard);
    
    void FreeMemory(void *pBlock) { free(pBlock); }
    void Unbind() { m_nFlags = no_delete; }
            
    int Append(CMemStream *pSrc);
    
    int Deserialize(HANDLE hFile);
    int Deserialize(FILE *fStream);
    int Deserialize(LPBYTE pBlock, DWORD dwSize); 
    
    int Serialize(HANDLE hFile);
    int Serialize(FILE *fStream);
    int Serialize(BYTE **pBlock, DWORD *pdwSize);
         // Use HeapFree() if no arena present

    void    Trim() { UpdateHdr(); Resize(m_dwEndOfStream); }     // Reduce excess of internal block.
             
    int     Status() { return m_nStatus; }
    DWORD   GetCurrentPos() { return m_dwCurrentPos; }
    void    SetCurrentPos(DWORD dwPos) { m_dwCurrentPos = dwPos; }
    DWORD   Size() { return m_dwEndOfStream; }
    DWORD   BufferSize() { return m_dwSize; }
    LPVOID  GetPtr() { UpdateHdr(); return m_pBuffer; }    
    void    Reset() { m_dwCurrentPos = sizeof(STREAM_HEADER); }
    int     NextType();

    int WriteType(DWORD dwType) { return WriteBytes(&dwType, sizeof(DWORD)); }
                               
    // Write operations.
    // ==================
    
    int WriteBytes(LPVOID, DWORD);

    int WriteNull() { return WriteType(VT_NULL); }

    int WriteChar(IN char c);
    int WriteByte(IN BYTE b);
    int WriteShort(IN SHORT iVal);
    int WriteWORD(IN WORD wVal);
    int WriteLong(IN LONG l);
    int WriteDWORD(IN DWORD dwVal);
    int WriteFloat(IN float fltVal);
    int WriteDouble(IN double dblVal);
    int WriteBool(IN VARIANT_BOOL b);
    
    int WriteLPSTR(IN LPSTR pStr);
    int WriteLPWSTR(IN LPWSTR pStr);
    int WriteBSTR(IN BSTR pStr);

    int WriteCLSID(IN CLSID *pClsId);
    int WriteUnknown(IN IUnknown *pObj);
    int WriteFILETIME(IN FILETIME *pTime);
    int WriteError(IN SCODE sVal);        
    int WriteBlob(IN BLOB *pBlob);
    int WritePtr(IN LPVOID p);

    int WriteCVar(IN CVar *pObj);
    int WriteCVarVector(IN CVarVector *pObj);

    // Read operations.
    // ================
                    
    int ReadBytes(LPVOID, DWORD);

    int ReadNull();
    int ReadByte(OUT BYTE *pByte);
    int ReadChar(OUT char *pc);
    int ReadShort(OUT SHORT *piVal);
    int ReadWORD(OUT WORD *pwVal);
    int ReadLong(OUT LONG *plVal);
    int ReadDWORD(OUT DWORD *pdwVal);
    int ReadFloat(OUT float *pfltVal);
    int ReadDouble(OUT double *pdlbVal);    
    int ReadBool(OUT VARIANT_BOOL *pBool);
    
    int ReadLPSTR(OUT LPSTR *pStr);
    int ReadLPWSTR(OUT LPWSTR *pStr);
    int ReadBSTR(OUT BSTR *pStr);

    int ReadCLSID(OUT CLSID *pClsId);
    int ReadUnknown(IUnknown **pObj);
    int ReadFILETIME(OUT FILETIME *pTime);
    int ReadError(OUT SCODE *pVal);
    int ReadBlob(OUT BLOB *pBlob);
    int ReadPtr(OUT LPVOID *p);

    int ReadCVar(OUT CVar **pObj);    
    int ReadCVarVector(OUT CVarVector **pObj);

    int ReadType();  

    BOOL EndOfStream() { return m_dwCurrentPos == m_dwEndOfStream; }

    // IStream implementation
    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement(&m_lRef);
    }

    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0) delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(Read)(
         void *pv,
         ULONG cb,
         ULONG *pcbRead);

    STDMETHOD(Write)(
         const void *pv,
         ULONG cb,
         ULONG *pcbWritten);

    STDMETHOD(Seek)(
         LARGE_INTEGER dlibMove,
         DWORD dwOrigin,
         ULARGE_INTEGER *plibNewPosition);

    STDMETHOD(SetSize)(
         ULARGE_INTEGER libNewSize);

    STDMETHOD(CopyTo)(
         IStream *pstm,
         ULARGE_INTEGER cb,
         ULARGE_INTEGER *pcbRead,
         ULARGE_INTEGER *pcbWritten);

    STDMETHOD(Commit)(
         DWORD grfCommitFlags);

    STDMETHOD(Revert)( void);

    STDMETHOD(LockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(UnlockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(Stat)(
         STATSTG *pstatstg,
         DWORD grfStatFlag);

    STDMETHOD(Clone)(
         IStream **ppstm);
};
                            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\strm.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRM.CPP

Abstract:


  CMemStream implementation.

  This is a generic data stream for object/interface marshaling.

History:

  a-raymcc    10-Apr-96   Created.
  a-raymcc    06-Jun-96   CArena support.
  a-raymcc    11-Sep-96   Support NULL pointers

--*/

#include "precomp.h"

#include <stdio.h>
#include <string.h>

#include "strm.h"

//***************************************************************************
//
//  CMemStream::CMemStream
//
//  Standard constructor.
//
//  PARAMETERS:
//  nFlags
//      auto_delete or no_delete.  If auto_delete, the internal buffer
//      is automatically deallocated at destruct-time.  If no_delete,
//      it is assumed that another object has acquired the m_pBuffer
//      pointer and will deallocate it with free().
//  pArena
//      The arena to use for allocation/deallocation.  If NULL, the
//      CWin32DefaultArena is used.
//  nInitialSize
//      The initial size of the stream in bytes.
//  nGrowBy
//      How much to grow the internal buffer by when the caller has written
//      past the end-of-stream.
//
//***************************************************************************
// ok
CMemStream::CMemStream(
    int nFlags,
    int nInitialSize,
    int nGrowBy
    )
{
    _ASSERT((nInitialSize >= 16), __TEXT("CMemStream: Initial size must be >= 16"));
    
    m_lRef = 0;
    m_nStatus = no_error;

    m_pBuffer = (BYTE *) malloc((DWORD) nInitialSize + 
        sizeof(STREAM_HEADER));
    if (!m_pBuffer)
        m_nStatus = out_of_memory;

    m_dwGrowBy = (DWORD) nGrowBy;
    m_dwSize = nInitialSize;
    m_dwCurrentPos = 0;
    m_nFlags = nFlags;
    m_nStackPtr = -1;
    m_dwEndOfStream = 0;

    // Write the validation header for this new stream.
    // ================================================

    STREAM_HEADER hdr;
    WriteBytes(&hdr, sizeof(STREAM_HEADER));    
}

//***************************************************************************
//
//  CMemStream::CMemStream
//
//  Binding constructor.
//
//***************************************************************************
// ok
CMemStream::CMemStream(
    LPVOID pBindingAddress,
    int nFlags,
    int nGrowBy
    )
{
    m_nStatus = no_error;
    m_pBuffer = (LPBYTE) pBindingAddress;
    m_nFlags = nFlags;
    m_lRef = 0;

    // The stream header must be present in the block which
    // is being bound to.
    // ====================================================

    STREAM_HEADER& hdr = *(STREAM_HEADER *) m_pBuffer;

    if (!hdr.Verify()) {
        m_nStatus = failed;
        return;
    }
    
    // Initialize the remaining member variables.
    // ==========================================

    m_dwSize = hdr.dwLength;
    m_dwGrowBy = nGrowBy;
    m_dwCurrentPos = sizeof(hdr);
    m_dwEndOfStream = hdr.dwLength;
    m_nFlags = nFlags;
    m_nStackPtr = -1;
}



//***************************************************************************
//
//  CMemStream::CMemStream
//
//  Copy constructor.
//
//***************************************************************************
// ok
CMemStream::CMemStream(CMemStream &Src)
{
    m_nStatus = 0;
    m_pBuffer = 0;
    m_dwGrowBy = 0;
    m_dwSize = 0;
    m_dwCurrentPos = 0;
    m_nFlags = 0;
    m_nStackPtr = -1;
    m_dwEndOfStream = 0; 
    m_lRef = 0;

    // The assignment operator does not copy the arena
    // so as to allow transfers of stream objects between
    // arenas.  So, we have to set up the arena here.
    // ==================================================

    *this = Src;
}

//***************************************************************************
//
//  CMemStream::operator =
//
//  Note that the arena is not copied as part of the assignment.  This
//  is to allow transfer of objects between arenas.
//
//***************************************************************************
// ok
CMemStream& CMemStream::operator =(CMemStream &Src)
{
    m_nStatus = Src.m_nStatus;
    m_dwSize = Src.m_dwSize;

    if (m_pBuffer)
        free(m_pBuffer);

    m_pBuffer = (BYTE *) malloc(m_dwSize);
    if (!m_pBuffer)
        m_nStatus = out_of_memory;
    else
        memcpy(m_pBuffer, Src.m_pBuffer, m_dwSize);

    m_dwGrowBy = Src.m_dwGrowBy;

    m_dwCurrentPos = Src.m_dwCurrentPos;
    m_nFlags = Src.m_nFlags;
    m_nStackPtr = Src.m_nStackPtr;
    m_dwEndOfStream = Src.m_dwEndOfStream;

    return *this;
}


//***************************************************************************
//
//  CMemStream::Deserialize
//
//  This function deserializes a stream from a Win32 file handle.
//  This function only works for files (including memory mapped files, etc.)
/// and pipes.  It will not work for mailslots since they must be read
//  in one operation.
//
//  PARAMETERS:
//  hFile
//      The Win32 file handle.
//
//  RETURN VALUES:
//  failed, out_of_memory, no_error
//
//***************************************************************************
// ok
int CMemStream::Deserialize(HANDLE hFile)
{
    Reset();    

    // Read the header.  Note that we read this separately
    // first before the stream proper.  This is because we
    // don't know how much memory to allocate until we have
    // read the header.
    // ====================================================

    STREAM_HEADER &hdr = *(STREAM_HEADER *) m_pBuffer;
    BOOL bRes;
    DWORD dwRead;

    bRes = ReadFile(hFile, &hdr, sizeof(hdr), &dwRead, 0);
    if (!bRes || dwRead != sizeof(hdr))
    {
        DWORD t_LastError = GetLastError () ;
        return failed;
    }
    if (!hdr.Verify())
        return failed;

    DWORD t_ReadLength = hdr.dwLength;

    // Read the rest.
    // ===============
    if (Resize(hdr.dwLength))
        return out_of_memory;

    BYTE *t_ReadPosition = m_pBuffer + sizeof ( hdr ) ;
    DWORD t_Remainder = m_dwSize - dwRead ;

    while ( t_Remainder )
    {
        bRes = ReadFile(hFile, t_ReadPosition , t_Remainder, &dwRead, 0);
        if (!bRes )
            return failed;

        t_Remainder = t_Remainder - dwRead ;
        t_ReadPosition = t_ReadPosition + dwRead ;
    }

    m_dwEndOfStream = t_ReadLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Deserialize
//
//  This function deserializes a stream from an ANSI C file object.
//
//  PARAMETERS:
//  fStream
//      The ANSI C file object.
//
//  RETURN VALUES:
//  failed, out_of_memory, no_error
//
//***************************************************************************
// ok
int CMemStream::Deserialize(FILE *fStream)
{
    Reset();

    STREAM_HEADER &hdr = *(STREAM_HEADER *) m_pBuffer;
    
    if (1 != fread(&hdr, sizeof(STREAM_HEADER), 1, fStream))
        return failed;
    if (!hdr.Verify())
        return failed;
        
    if (Resize(hdr.dwLength) != no_error)
        return out_of_memory;

    DWORD dwRemainder = m_dwSize - sizeof(hdr);
    
    if (dwRemainder != fread(m_pBuffer + sizeof(hdr), sizeof(BYTE), 
        dwRemainder, fStream))
        return failed;

    m_dwEndOfStream = hdr.dwLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Deserialize
//
//  This function deserializes a stream from a memory block.
//
//  PARAMETERS:
//  pBlock
//      The memory block.
//  dwSize
//      The size of the memory block.
//
//  RETURN VALUES:
//  failed, no_error
//
//***************************************************************************

int CMemStream::Deserialize(LPBYTE pBlock, DWORD dwSize)
{
    Reset();

    STREAM_HEADER *pHdr = (STREAM_HEADER *) pBlock;

    if (!pHdr->Verify())
        return failed;

	// RAJESHR - FIx for Prefix Bug# 144445
    if (Resize(pHdr->dwLength) != no_error)
        return out_of_memory;

    memcpy(
        m_pBuffer,
        pBlock,
        pHdr->dwLength
        );

    m_dwEndOfStream = pHdr->dwLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Resize
//
//  Increases the size of the internal buffer.  Does not affect the
//  current offset or end-of-stream markers.
//
//  RETURN VALUES:
//  no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::Resize(DWORD dwNewSize)
{
	// rajeshr : Fix for Prefix bug 144429
	BYTE *pTemp = m_pBuffer;
    m_pBuffer = (BYTE *) realloc(m_pBuffer, dwNewSize + 
        sizeof(STREAM_HEADER));

    if (!m_pBuffer) {
		m_pBuffer = pTemp;
        m_nStatus = out_of_memory;
        return m_nStatus;
    }

    STREAM_HEADER& hdr = *(STREAM_HEADER *) m_pBuffer;
    hdr.dwSignature = SIGNATURE_STREAM ;
    hdr.dwLength = dwNewSize + sizeof ( STREAM_HEADER ) ;

    m_dwSize = dwNewSize;
    return no_error;
}

//***************************************************************************
//
//  CMemStream::Serialize
//
//  Writes the object to a Win32 file.
//
//  PARAMETERS:
//  hFile
//      The Win32 file handle to which to write the object.
//
//  RETURN VALUES:
//  failed, no_error
//
//***************************************************************************
// ok
int CMemStream::Serialize(HANDLE hFile)
{
    UpdateHdr();
    
    // Write body of stream.  This includes the header.
    // ================================================

    DWORD dwWritten = 0;
    BOOL bRes = WriteFile(hFile, m_pBuffer, m_dwEndOfStream, &dwWritten, 0);
    if (!bRes || m_dwEndOfStream != dwWritten)
        return failed;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::Serialize
//
//  Serializes the entire stream to the specified FILE object, which
//  must have been opened in binary mode for writing.
//
//  PARAMETERS:
//  fStream
//      The ANSI C FILE object to which to write the object.
//
//  RETURN VALUE:
//  no_error, failed
//
//***************************************************************************
// ok

int CMemStream::Serialize(FILE *fStream)
{
    UpdateHdr();
    
    // Write body of stream.
    // =====================

    int nRes = fwrite(m_pBuffer, sizeof(BYTE), m_dwEndOfStream, fStream);
    if (nRes != (int) m_dwEndOfStream)
        return failed;

    return no_error;
}


//***************************************************************************
//
//  CMemStream::Serialize
//
//  Serializes the entire object to a memory block which is allocated
//  with HeapAlloc using the default process heap. The caller must call
//  FreeMem() when the block is no longer needed.
//
//  PARAMETERS:
//  pBlock
//      Should point to NULL on entry and will be assigned to point to the
//      new memory block containing the serialized form of the object.
//      The receiver must call FreeMem() using the default process heap
//      when this block is no longer needed.
//  pdwSize
//      Points to a DWORD which will be set to the size in bytes
//      of the returned memory block.
//
//  RETURN VALUES:
//  out_of_memory, no_error
//
//***************************************************************************

int CMemStream::Serialize(BYTE **pBlock, DWORD *pdwSize)
{
    UpdateHdr();

    LPVOID pMem = malloc(m_dwEndOfStream);            
    if (!pMem)
        return out_of_memory;
        
    memcpy(pMem, m_pBuffer, m_dwEndOfStream);
    *pBlock = (BYTE *) pMem;
    *pdwSize = m_dwEndOfStream;
    
    return no_error;
}


//***************************************************************************
//
//  CMemStream::Append
//
//  Appends one CMemStream object onto the end of the current one.
//  When deserialization occurs, the stream will appear as one large object;
//  the original number of appended objects is lost information.
//
//  PARAMETERS:
//  pSubStream
//      The stream which needs to be appended to 'this' object.
//
//  RETURN VALUES:
//  no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::Append(CMemStream *pSubstream)
{
    DWORD dwNumBytesToCopy =  pSubstream->m_dwEndOfStream - sizeof(STREAM_HEADER);

    if (no_error != Resize(m_dwEndOfStream + dwNumBytesToCopy))
        return out_of_memory;

    memcpy(&m_pBuffer[m_dwEndOfStream], 
        pSubstream->m_pBuffer + sizeof(STREAM_HEADER),
        dwNumBytesToCopy
        );

    m_dwEndOfStream += dwNumBytesToCopy;
    m_dwCurrentPos = m_dwEndOfStream;

    return no_error;
}

// SAFE AREA

//***************************************************************************
//
//  CMemStream::WriteBlob
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBlob(BLOB *pBlob)
{
    int nRes;
    nRes = WriteType(VT_BLOB);
    if (nRes) return nRes;

    DWORD dwSize = BlobLength(pBlob);
    if (WriteBytes(&dwSize, sizeof(DWORD)) != no_error)
        return out_of_memory;
    if (WriteBytes(BlobDataPtr(pBlob), dwSize) != no_error)
        return out_of_memory;

    return no_error;
}


//***************************************************************************
//
//  CMemStream::WriteDouble
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteDouble(double dblVal)
{
    int nRes;
    nRes = WriteType(VT_R8);
    if (nRes) return nRes;
    nRes = WriteBytes(&dblVal, sizeof(double));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteFloat
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteFloat(float fltVal)
{
    int nRes;
    nRes = WriteType(VT_R4);
    if (nRes) return nRes;
    nRes = WriteBytes(&fltVal, sizeof(float));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteFloat
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBool(VARIANT_BOOL bVal)
{
    int nRes;
    nRes = WriteType(VT_BOOL);
    if (nRes) return nRes;
    nRes = WriteBytes(&bVal, sizeof(VARIANT_BOOL));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteByte
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteByte(BYTE b)
{
    int nRes;
    nRes = WriteType(VT_UI1);
    if (nRes) return nRes;
    nRes = WriteBytes(&b, sizeof(BYTE));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteChar
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteChar(char c)
{
    int nRes;
    nRes = WriteType(VT_I1);
    if (nRes) return nRes;
    nRes = WriteBytes(&c, sizeof(char));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteLong
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteLong(LONG l)
{
    int nRes;
    nRes = WriteType(VT_I4);
    if (nRes) return nRes;
    nRes = WriteBytes(&l, sizeof(LONG));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteDWORD
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteDWORD(DWORD dwVal)
{
    int nRes;
    nRes = WriteType(VT_UI4);
    if (nRes) return nRes;
    nRes = WriteBytes(&dwVal, sizeof(DWORD));
    return nRes;
}


//***************************************************************************
//
//  CMemStream::WriteDWORD
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteWORD(WORD wVal)
{
    int nRes;
    nRes = WriteType(VT_UI2);
    if (nRes) return nRes;
    nRes = WriteBytes(&wVal, sizeof(WORD));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteShort
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteShort(SHORT iVal)
{
    int nRes;
    nRes = WriteType(VT_I2);
    if (nRes) return nRes;
    nRes = WriteBytes(&iVal, sizeof(SHORT));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteLPSTR
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteLPSTR(LPSTR pStr)
{
    int nRes;
    nRes = WriteType(VT_LPSTR);
    if (nRes) return nRes;

    if (pStr)
    {
        DWORD dwLen = strlen(pStr);
        nRes = WriteBytes(&dwLen, sizeof(DWORD));
        if (nRes) return nRes;

        nRes = WriteBytes(pStr, strlen(pStr) + 1);
    }
    // Null pointers are encoded as 0xFFFFFFFF for the string length.
    // ==============================================================
    else 
    {
        DWORD dwNullEncoding = 0xFFFFFFFF;
        nRes = WriteBytes(&dwNullEncoding, sizeof(DWORD));
    }        
            
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteLPWSTR
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteLPWSTR(LPWSTR pStr)
{
    int nRes;
    nRes = WriteType(VT_LPWSTR);
    if (nRes) return nRes;
    
    // If a non-NULL pointer, the length prefixes the string data.
    // ============================================================
    if (pStr)
    {
        DWORD dwLen = wcslen(pStr);
        nRes = WriteBytes(&dwLen, sizeof(DWORD));
        if (nRes) return nRes;
        nRes = WriteBytes(pStr, (wcslen(pStr) + 1) * 2);
    }
    // Null pointers are encoded as 0xFFFFFFFF for the string length.
    // ==============================================================
    else 
    {
        DWORD dwNullEncoding = 0xFFFFFFFF;
        nRes = WriteBytes(&dwNullEncoding, sizeof(DWORD));
    }        

            
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteBSTR
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBSTR(BSTR pStr)
{
    int nRes;
    nRes = WriteType(VT_BSTR);
    if (nRes) return nRes;
    if (pStr)
    {
        DWORD dwLen = wcslen(pStr);
        nRes = WriteBytes(&dwLen, sizeof(DWORD));
        if (nRes) return nRes;
        nRes = WriteBytes(pStr, (wcslen(pStr) + 1) * 2);
    }
    // NULL pointers are encoded as 0xFFFFFFFF for the length prefix.
    // ==============================================================
    else 
    {
        DWORD dwNullEncoding = 0xFFFFFFFF;
        nRes = WriteBytes(&dwNullEncoding, sizeof(DWORD));
    }        

    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteCLSID
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteCLSID(CLSID *pClsId)
{
    int nRes;
    nRes = WriteType(VT_CLSID);
    if (nRes) return nRes;
    return WriteBytes(pClsId, sizeof(CLSID));
}

//***************************************************************************
//
//  CMemStream::WriteCLSID
//
//  Serializes the literal value of a pointer.
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteUnknown(IUnknown *pObj)
{
    int nRes;
    nRes = WriteType(VT_UNKNOWN);
    if (nRes) return nRes;
    return WriteBytes(pObj, sizeof(void *));
}


//***************************************************************************
//
//  CMemStream::WriteFILETIME
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteFILETIME(FILETIME *pTime)
{
    int nRes;
    nRes = WriteType(VT_FILETIME);
    if (nRes) return nRes;
    nRes = WriteBytes(pTime, sizeof(FILETIME));
    return nRes;
}

//***************************************************************************
//
//  CMemStream::WriteCVar
//
//  Writes a CVar into the stream.
//
//  PARAMETERS:
//  pObj
//      Points to the CVar object to serialize.  The CVar can contains
//      an embedded CVarVector array which itself consists of arbitrary
//      CVar objects.
//
//  RETURN VALUES:
//  critical_error (unsupported type)
//  no_error
//  invalid_parameter
//  out_of_memory  (returned by embedded calls)
//
//***************************************************************************
// ok
int CMemStream::WriteCVar(CVar *pObj)
{
    if (!pObj)
        return invalid_parameter;

    // Write the CVar type indicator for the deserialization.
    // =======================================================

    int nRes = WriteType(VT_EX_CVAR);
    int nType = pObj->GetType();

    // Write out the field.
    // ====================

    switch (nType) {
        case VT_EMPTY:
        case VT_NULL: return WriteNull();

        case VT_I1:   return WriteChar(pObj->GetChar());
        case VT_UI1:  return WriteByte(pObj->GetByte());
        case VT_I2:   return WriteShort(pObj->GetShort());
        case VT_UI2:  return WriteWORD(pObj->GetWord());
        case VT_I4:   return WriteLong(pObj->GetLong());
        case VT_UI4:  return WriteDWORD(pObj->GetDWORD());
        case VT_BOOL: return WriteBool(pObj->GetBool());
        case VT_R4:   return WriteFloat(pObj->GetFloat());
        case VT_R8:   return WriteDouble(pObj->GetDouble());

        case VT_LPSTR:  return WriteLPSTR(pObj->GetLPSTR());
        case VT_LPWSTR: return WriteLPWSTR((LPWSTR) pObj->GetLPWSTR());

        case VT_BSTR:   return WriteBSTR((LPWSTR) pObj->GetLPWSTR());
            // Intentional type mismatch on pObj->GetLPWSTR
            // so we don't have to get a new BSTR and deallocate it.
            // CVar stores BSTR as LPWSTR internally, so this is ok.

        case VT_FILETIME:
            {
                FILETIME ft = pObj->GetFileTime();
                WriteFILETIME(&ft);
                return no_error;
            }

        case VT_BLOB:    return WriteBlob((BLOB *) pObj->GetBlob());
        case VT_CLSID:   return WriteCLSID((CLSID *) pObj->GetClsId());
        case VT_EX_CVARVECTOR: return WriteCVarVector((CVarVector *) pObj->GetVarVector());
    }

    return critical_error;
}

//***************************************************************************
//
//  CMemStream::WriteCVarVector
//
//  Write the incoming CVarVector to the stream.  For efficiency,
//  the type indicator is not repeated for each element.  However, each
//  element can be another embedded VT_EX_CVAR type.
//
//  PARAMETERS:
//  pVec
//      The pointer to the CVarVector object to serialize.
//  RETURN VALUE:
//  no_error, invalid_parameter, out_of_memory, critical_error
//
//***************************************************************************
// ok
int CMemStream::WriteCVarVector(IN CVarVector *pVec)
{
    if (!pVec)
        return invalid_parameter;

    // Write the CVarVector type indicator for the deserialization.
    // ============================================================

    if (WriteType(VT_EX_CVARVECTOR) != no_error)
        return out_of_memory;

    // Write the element type.
    // =======================

    int nElementType = pVec->GetType();

    if (WriteType(nElementType) != no_error)
        return out_of_memory;

    // Write out the vector length.
    // ============================

    DWORD dwSize = (DWORD) pVec->Size();
    int nRes = WriteBytes(&dwSize, sizeof(DWORD));

    // Write out the elements.
    // =======================

    for (int i = 0; i < pVec->Size(); i++) {
        CVar& v = pVec->GetAt(i);

        switch (pVec->GetType()) {
            case VT_EX_CVARVECTOR:
                if (WriteCVarVector((CVarVector *) v.GetVarVector()) != no_error)
                    return out_of_memory;
                break;

            case VT_EX_CVAR:
                if (WriteCVar(&v) != no_error)
                    return out_of_memory;
                break;

            case VT_I1:
                {
                    char c = v.GetChar();
                    if (WriteBytes(&c, sizeof(char)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_UI1:
                {
                    BYTE b = v.GetByte();
                    if (WriteBytes(&b, sizeof(BYTE)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_I2:
                {
                    SHORT i = v.GetShort();
                    if (WriteBytes(&i, sizeof(SHORT)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_UI2:
                {
                    WORD w = v.GetWord();
                    if (WriteBytes(&w, sizeof(WORD)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_I4:
                {
                    LONG l = v.GetLong();
                    if (WriteBytes(&l, sizeof(LONG)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_UI4:
                {
                    DWORD dw = v.GetDWORD();
                    if (WriteBytes(&dw, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_BOOL:
                {
                    VARIANT_BOOL b = v.GetBool();
                    if (WriteBytes(&b, sizeof(VARIANT_BOOL)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_R4:
                {
                    float f = v.GetFloat();
                    if (WriteBytes(&f, sizeof(float)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_R8:
                {
                    double d = v.GetDouble();
                    if (WriteBytes(&d, sizeof(double)) != no_error)
                        return out_of_memory;
                    break;
                }


            // NOTES: String types are written with a prefixed with
            // a DWORD length indicator so that during deserialization
            // the correct buffer length can be allocated before the
            // string is read back.  The length indicator is in characters,
            // not bytes.

            case VT_LPSTR:
                {
                    LPSTR pStr = v.GetLPSTR();
                    DWORD dwLength = strlen(pStr) + 1;
                    if (WriteBytes(&dwLength, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(pStr, dwLength) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_LPWSTR:
                {
                    LPWSTR pStr = v.GetLPWSTR();
                    DWORD dwLength = wcslen(pStr) + 1;
                    if (WriteBytes(&dwLength, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(pStr, dwLength * 2) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_BSTR:
                {
                    // Even though the type is BSTR, we request as
                    // an LPWSTR so as to avoid the lost time of calling
                    // SysAllocString/SysFreeString, etc.
                    LPWSTR pStr = v.GetLPWSTR();
                    DWORD dwLength = wcslen(pStr) + 1;
                    if (WriteBytes(&dwLength, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(pStr, dwLength * 2) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_FILETIME:
                {
                    FILETIME ft = v.GetFileTime();
                    if (WriteBytes(&ft, sizeof(FILETIME)) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_BLOB:
                {
                    BLOB *p = v.GetBlob();
                    DWORD dwLen = BlobLength(p);
                    if (WriteBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return out_of_memory;
                    if (WriteBytes(BlobDataPtr(p), dwLen) != no_error)
                        return out_of_memory;
                    break;
                }

            case VT_CLSID:
                {
                    CLSID *p = v.GetClsId();
                    if (WriteBytes(p, sizeof(CLSID)) != no_error)
                        return out_of_memory;
                    break;
                }

            // This should never execute.
            default:
                return critical_error;
        }
    }

    return no_error;
}


//***************************************************************************
//
//  CMemStream::ReadNull
//
//  Return values:
//      end_of_stream, type_mismatch, no_error
//
//***************************************************************************
// ok
int CMemStream::ReadNull()
{
    int nRes = ReadType();
    if (nRes == VT_EMPTY)
        return end_of_stream;
    else if (nRes != VT_NULL)
        return type_mismatch;
    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadBytes
//
//  Return value:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadBytes(LPVOID pBlock, DWORD dwLength)
{
    if (dwLength + m_dwCurrentPos > m_dwEndOfStream) {
        m_dwCurrentPos = m_dwEndOfStream;
        return end_of_stream;
    }

    memcpy(pBlock, &m_pBuffer[m_dwCurrentPos], dwLength);
    m_dwCurrentPos += dwLength;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::WriteBytes
//
//  Writes the specified bytes at the current offset. The
//  end-of-stream marker is unchanged, unless the current position
//  has been advanced beyond the previous end-of-stream marker by
//  the write.  In the latter case, the end-of-stream marker is
//  set to the byte immediately after the write.
//
//  Return values:
//      no_error, out_of_memory
//
//***************************************************************************
// ok
int CMemStream::WriteBytes(LPVOID pBlock, DWORD dwLength)
{
    while (m_dwCurrentPos + dwLength > m_dwSize) {
        m_dwSize += m_dwGrowBy;
        if (Resize(m_dwSize) != no_error)
            return out_of_memory;
    }

    memcpy(&m_pBuffer[m_dwCurrentPos], pBlock, dwLength);
    m_dwCurrentPos += dwLength;

    // Reset the end of stream pointer if we have grown 
    if (m_dwCurrentPos > m_dwEndOfStream)
        m_dwEndOfStream = m_dwCurrentPos;
    return no_error;
}

//***************************************************************************
//
//  Macro TYPE_CHECK
//
//  Checks that the next value in the stream is a type indicator which
/// matches the current type.
//
//  Returns end_of_stream or type_mismatch on errors.
//  On error, the current stream pointer is set back to where it was
//  on entry.  It is only allowed to advance on success.
//
//***************************************************************************

#define TYPE_CHECK(vt)          \
    {                           \
    Push();                     \
    int nType = ReadType();     \
    if (nType == VT_EMPTY) {    \
        Pop(FALSE);             \
        return end_of_stream;   \
    }                           \
    if (nType != vt)          { \
        Pop(FALSE);             \
        return type_mismatch;   \
    }                           \
    Pop(TRUE);                  \
    }


//***************************************************************************
//
//  CMemStream::ReadBlob
//
//  Reads a BLOB and dynamically allocates buffer to hold it. The caller
//  must call FreeMem to free the memory block.
//
//  Parameters:
//      pBytes
//          A pointer to the user's pointer, which should point to NULL
//          on entry. This will be assigned to point to the new block.
//      pdwSize
//          Points to a DWORD which will be assigned to the size of the
//          returned block.
//
//  Return values:
//      end_of_stream,  type_mismatch, no_error
//
//***************************************************************************
// ok
int CMemStream::ReadBlob(BLOB *pBlob)
{
    TYPE_CHECK(VT_BLOB);

    DWORD dwSize = 0;
    int nRes = ReadBytes(&dwSize, sizeof(DWORD));
    if (nRes != no_error)
        return nRes;

    LPVOID pBlock = new BYTE[dwSize];
    if (pBlock == NULL)
        return out_of_memory;

    nRes = ReadBytes(pBlock, dwSize);
    if (nRes != no_error)
        return end_of_stream;

    pBlob->cbSize = dwSize;
    pBlob->pBlobData = (BYTE *) pBlock;

    return no_error;
}


//***************************************************************************
//
//  CMemStream::ReadDouble
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadDouble(double *pdblVal)
{
    TYPE_CHECK(VT_R8);
    return ReadBytes(pdblVal, sizeof(double));
}

//***************************************************************************
//
//  CMemStream::ReadByte
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadByte(BYTE *pByte)
{
    TYPE_CHECK(VT_UI1);
    return ReadBytes(pByte, sizeof(BYTE));
}

//***************************************************************************
//
//  CMemStream::ReadFloat
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadFloat(float *pfltVal)
{
    TYPE_CHECK(VT_R4);
    return ReadBytes(pfltVal, sizeof(float));
}

//***************************************************************************
//
//  CMemStream::ReadFloat
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadBool(VARIANT_BOOL *pBool)
{
    TYPE_CHECK(VT_BOOL);
    return ReadBytes(pBool, sizeof(VARIANT_BOOL));
}

//***************************************************************************
//
//  CMemStream::ReadWORD
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadWORD(WORD *pw)
{
    TYPE_CHECK(VT_UI2);
    return ReadBytes(pw, sizeof(WORD));
}

//***************************************************************************
//
//  CMemStream::ReadChar
//
//  Return values:
//      no_error, end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadChar(char *pc)
{
    TYPE_CHECK(VT_I1);
    return ReadBytes(pc, sizeof(char));
}


//***************************************************************************
//
//  CMemStream::ReadLong
//
//***************************************************************************
// ok
int CMemStream::ReadLong(LONG *plVal)
{
    TYPE_CHECK(VT_I4);
    return ReadBytes(plVal, sizeof(LONG));
}

//***************************************************************************
//
//  CMemStream::ReadDWORD
//
//***************************************************************************
// ok
int CMemStream::ReadDWORD(DWORD *pdwVal)
{
    TYPE_CHECK(VT_UI4);
    return ReadBytes(pdwVal, sizeof(DWORD));
}

//***************************************************************************
//
//  CMemStream::ReadShort
//
//***************************************************************************
// ok
int CMemStream::ReadShort(SHORT *piVal)
{
    TYPE_CHECK(VT_I2);
    return ReadBytes(piVal, sizeof(SHORT));
}

//***************************************************************************
//
//  CMemStream::ReadLPSTR
//
//***************************************************************************
// ok
int CMemStream::ReadLPSTR(LPSTR *pStr)
{
    TYPE_CHECK(VT_LPSTR);
    DWORD dwLength = 0;
    int nRes = ReadBytes(&dwLength, sizeof(DWORD));
    if (nRes)
        return nRes;

    // Check for encoded NULL pointer.
    // ===============================        
    if (dwLength == 0xFFFFFFFF)
    {
        *pStr = 0;
        return no_error;
    }

    // If here, there is at least a string of some kind,
    // possibly zero length.
    // ==================================================
                    
    *pStr = new char[dwLength + 1];
    nRes = ReadBytes(*pStr, dwLength + 1);  // Include read of NULL
    if (nRes != no_error)
        return nRes;
    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadLPWSTR
//
//***************************************************************************
// ok
int CMemStream::ReadLPWSTR(LPWSTR *pStr)
{
    TYPE_CHECK(VT_LPWSTR);

    DWORD dwLength = 0;
    int nRes = ReadBytes(&dwLength, sizeof(DWORD));
    if (nRes)
        return nRes;

    // Check for encoded NULL pointer.
    // ===============================        
    if (dwLength == 0xFFFFFFFF)
    {
        *pStr = 0;
        return no_error;
    }

    // If here, there is at least a string of some kind,
    // possibly zero length.
    // ==================================================
    
    *pStr = new wchar_t[dwLength + 1];
    nRes = ReadBytes(*pStr, (dwLength + 1) * 2);
    if (nRes != no_error)
        return nRes;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadBSTR
//
//***************************************************************************
// ok
int CMemStream::ReadBSTR(BSTR *pStr)
{
    *pStr = 0;

    TYPE_CHECK(VT_BSTR);

    DWORD dwLength = 0;
    int nRes = ReadBytes(&dwLength, sizeof(DWORD));
    if (nRes)
        return nRes;

    // Check for encoded NULL pointer.
    // ===============================        
    if (dwLength == 0xFFFFFFFF)
    {
        *pStr = 0;
        return no_error;
    }

    // If here, there is at least a string of some kind,
    // possibly zero length.
    // ==================================================

    wchar_t* pTemp = new wchar_t[dwLength + 1];
    nRes = ReadBytes(pTemp, (dwLength + 1) * 2);
    if (nRes != no_error)
        return nRes;

    *pStr = SysAllocString(pTemp);
    delete pTemp;

    return no_error;
}

//***************************************************************************
//
//  CMemStream::ReadCLSID
//
//***************************************************************************
// ok
int CMemStream::ReadCLSID(CLSID *pClsId)
{
    TYPE_CHECK(VT_CLSID);
    return ReadBytes(pClsId, sizeof(CLSID));
}


//***************************************************************************
//
//  CMemStream::ReadUnknown
//
//***************************************************************************
// ok
int CMemStream::ReadUnknown(IUnknown **pObj)
{
    TYPE_CHECK(VT_UNKNOWN);
    return ReadBytes(*pObj, sizeof(LPVOID));
}

//***************************************************************************
//
//  CMemStream::ReadFILETIME
//
//  Reads a Win32 FILETIME struct.
//
//***************************************************************************
// ok
int CMemStream::ReadFILETIME(OUT FILETIME *pTime)
{
    TYPE_CHECK(VT_FILETIME);
    return ReadBytes(pTime, sizeof(FILETIME));
}


//***************************************************************************
//
//  CMemStream::Read
//
//  Reads a CVar from the stream.
//
//  RETURN VALUES:
//  no_error
//  end_of_stream
//
//***************************************************************************
// ok
int CMemStream::ReadCVar(OUT CVar **pObj)
{
    TYPE_CHECK(VT_EX_CVAR);

    // Now read the internal type of the CVar. We read ahead, and then
    // move the current pointer back so that subsequent calls to
    // deserialize the typed value will work properly (they all need
    // the type prefixes).
    // ================================================================

    CVar *pVar = new CVar;

    DWORD dwPos = GetCurrentPos();
    int nVarType = ReadType();
    int nErrorCode = no_error;
    SetCurrentPos(dwPos);

    switch (nVarType) {
        case VT_EMPTY:
        case VT_NULL:
            pVar->SetAsNull();
            break;

        case VT_I1:
            {
                char c = 0;
                if (ReadChar(&c) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetChar(c);
            }
            break;

        case VT_UI1:
            {
                BYTE b = 0;
                if (ReadByte(&b) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetByte(b);
            }
            break;

        case VT_I2:
            {
                SHORT i = 0;
                if (ReadShort(&i) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetShort(i);
            }
            break;

        case VT_UI2:
            {
                WORD w = 0;
                if (ReadWORD(&w) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetWord(w);
            }
            break;

        case VT_I4:
            {
                LONG l = 0;
                if (ReadLong(&l) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetLong(l);
            }
            break;

        case VT_UI4:
            {
                DWORD dw = 0;
                if (ReadDWORD(&dw) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetDWORD(dw);
            }
            break;

        case VT_BOOL:
            {
                VARIANT_BOOL b = 0;
                if (ReadBool(&b) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetBool(b);
            }
            break;

        case VT_R4:
            {
                float f = (float) 0.0;
                if (ReadFloat(&f) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetFloat(f);
            }
            break;

        case VT_R8:
            {
                double d = 0.0;
                if (ReadDouble(&d) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetDouble(d);
            }
            break;

        case VT_LPSTR:
            {
                LPSTR pStr = 0;
                if (ReadLPSTR(&pStr) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetLPSTR(pStr, TRUE);
            }
            break;

        case VT_LPWSTR:
            {
                LPWSTR pStr = 0;
                if (ReadLPWSTR(&pStr) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetLPWSTR(pStr, TRUE);
            }
            break;


        case VT_BSTR:
            {
                BSTR Str = 0;
                if (ReadBSTR(&Str) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else {
                    pVar->SetBSTR(Str, FALSE);
                    SysFreeString(Str);
                }
            }
            break;

        case VT_FILETIME:
            {
                FILETIME f = {0};
                if (ReadFILETIME(&f) != no_error) {
                    nErrorCode = end_of_stream;
                }
                else
                    pVar->SetFileTime(&f);
            }
            break;

        case VT_BLOB:
            {
                BLOB b;
                BlobInit(&b);
                if (ReadBlob(&b) != no_error)
                    nErrorCode = end_of_stream;
                else
                    pVar->SetBlob(&b, TRUE);
            }
            break;

        case VT_CLSID:
            {
                CLSID ClsId = {0};
                if (ReadCLSID(&ClsId) != no_error)
                    nErrorCode = end_of_stream;
                else
                    pVar->SetClsId(&ClsId, FALSE);
            }
            break;

        case VT_EX_CVARVECTOR:
            {
                CVarVector *pVec = 0;
                if (ReadCVarVector(&pVec) != no_error)
                    nErrorCode = end_of_stream;
                else
                    pVar->SetVarVector(pVec, TRUE);
            }
            break;
    }

    if (nErrorCode != no_error)
        delete pVar;
    else
        *pObj = pVar;

    return nErrorCode;
}

//***************************************************************************
//
//  CMemStream::ReadCVarVector
//
//
//***************************************************************************
// ok
int CMemStream::ReadCVarVector(CVarVector **pObj)
{
    *pObj = 0;

    TYPE_CHECK(VT_EX_CVARVECTOR);

    // Read the element type.
    // ======================

    DWORD dwPos = GetCurrentPos();
    int nType = ReadType();
    CVarVector *pVec = new CVarVector(nType);

    // Read the size of the vector.
    // ============================
    DWORD dwVecSize = 0;
    if (ReadBytes(&dwVecSize, sizeof(DWORD)) != no_error)
        return end_of_stream;

    // Read each element.
    // ==================

    for (DWORD dwIx = 0; dwIx < dwVecSize; dwIx++) {
        switch (nType) {
            case VT_EX_CVARVECTOR:
                {
                    CVarVector *pTmpVec = 0;
                    if (ReadCVarVector(&pTmpVec) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(pTmpVec, TRUE));
                    break;
                }

            case VT_EX_CVAR:
                {
                    CVar *pVar = 0;
                    if (ReadCVar(&pVar) != no_error)
                        return end_of_stream;
                    pVec->Add(pVar);
                    break;
                }

            case VT_I1:
                {
                    char c = 0;
                    if (ReadBytes(&c, sizeof(char)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(c));
                    break;
                }

            case VT_UI1:
                {
                    BYTE b = 0;
                    if (ReadBytes(&b, sizeof(BYTE)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(b));
                    break;
                }

            case VT_I2:
                {
                    SHORT i = 0;
                    if (ReadBytes(&i, sizeof(SHORT)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(i));
                    break;
                }

            case VT_UI2:
                {
                    WORD w = 0;
                    if (ReadBytes(&w, sizeof(WORD)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(w));
                    break;
                }

            case VT_I4:
                {
                    LONG l = 0;
                    if (ReadBytes(&l, sizeof(LONG)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(l));
                    break;
                }

            case VT_UI4:
                {
                    DWORD dw = 0;
                    if (ReadBytes(&dw, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(dw));
                    break;
                }

            case VT_BOOL:
                {
                    VARIANT_BOOL b = 0;
                    if (ReadBytes(&b, sizeof(VARIANT_BOOL)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(b));
                    break;
                }

            case VT_R4:
                {
                    float f = (float) 0.0;
                    if (ReadBytes(&f, sizeof(float)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(f));
                    break;
                }

            case VT_R8:
                {
                    double d = 0.0;
                    if (ReadBytes(&d, sizeof(double)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(d));
                    break;
                }


            // NOTE: String types were written with a prefixed with
            // a DWORD length indicator so that during deserialization
            // the correct buffer length can be allocated before the
            // string is read back.  The length indicator is in characters,
            // not bytes.
            // ============================================================
            case VT_LPSTR:
                {
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPSTR pStr = new char[dwLen];
                    if (ReadBytes(pStr, dwLen) != no_error)
                        return out_of_memory;
                    pVec->Add(CVar(pStr, TRUE));
                    break;
                }

            case VT_LPWSTR:
                {
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPWSTR pStr = new wchar_t[dwLen];
                    if (ReadBytes(pStr, dwLen * 2) != no_error)
                        return out_of_memory;
                    pVec->Add(CVar(pStr, TRUE));
                    break;
                }

            case VT_BSTR:
                {
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPWSTR pStr = new wchar_t[dwLen];
                    if (ReadBytes(pStr, dwLen * 2) != no_error)
                        return out_of_memory;
                    pVec->Add(CVar(VT_BSTR, pStr, FALSE));
                    delete pStr;
                    break;
                }

            case VT_FILETIME:
                {
                    FILETIME ft = {0};
                    if (ReadBytes(&ft, sizeof(FILETIME)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(&ft));
                    break;
                }

            case VT_BLOB:
                {
                    BLOB b;
                    BlobInit(&b);
                    DWORD dwLen = 0;
                    if (ReadBytes(&dwLen, sizeof(DWORD)) != no_error)
                        return end_of_stream;
                    LPBYTE pBuf = new BYTE[dwLen];
                    if (ReadBytes(pBuf, dwLen) != no_error)
                        return end_of_stream;
                    BlobAssign(&b, pBuf, dwLen, TRUE);
                    pVec->Add(CVar(&b, TRUE));
                }

            case VT_CLSID:
                {
                    CLSID clsid = {0};
                    if (ReadBytes(&clsid, sizeof(CLSID)) != no_error)
                        return end_of_stream;
                    pVec->Add(CVar(&clsid));
                    break;
                }

            // This should never execute.
            default:
                return critical_error;
        }
    }

    *pObj = pVec;
    return no_error;
}

//***************************************************************************
//
//   CMemStream::ReadError
//
//***************************************************************************
// ok
int CMemStream::ReadError(SCODE *pVal)
{
    TYPE_CHECK(VT_ERROR);
    return ReadBytes(pVal, sizeof(SCODE));
}

//***************************************************************************
//
//  CMemStream::NextType
//
//***************************************************************************
// ok
int CMemStream::NextType()
{
    Push();
    int nType = ReadType();
    Pop(FALSE);
    return nType;
}

//***************************************************************************
//
//  CMemStream::ReadType
//
//  Returns a VT_ type indicator or VT_EMPTY on end-of-stream.
//
//***************************************************************************
// ok
int CMemStream::ReadType()
{
    DWORD dwType = VT_EMPTY;

    if (ReadBytes(&dwType, sizeof(DWORD)) == end_of_stream)
        return VT_EMPTY;

    return dwType;
}


//***************************************************************************
//
//  CMemStream::Pop
//
//***************************************************************************
// ok
void CMemStream::Pop(BOOL bDiscard)
{
    if (bDiscard)
        m_nStackPtr--;
    else
        m_dwCurrentPos = m_dwStack[m_nStackPtr--];
}


//***************************************************************************
//
//  CMemStream::~CMemStream
//
//***************************************************************************
// ok
CMemStream::~CMemStream()
{
    //_ASSERT(m_lRef == 0, "CMemStream used for COM deleted without Release");
    if (m_nFlags == auto_delete)
        free(m_pBuffer);
}

//***************************************************************************
//
//  CMemStream::IStream implementation
//
//***************************************************************************

STDMETHODIMP CMemStream::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IStream)
    {
        *ppv = (void*)(IStream*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CMemStream::Read(
     void *pv,
     ULONG cb,
     ULONG *pcbRead)
{
    if(ReadBytes(pv, cb) == no_error)
    {
        if(pcbRead) *pcbRead = cb;
        return S_OK;
    }
    else 
    {
        if(pcbRead) *pcbRead = 0;
        return S_FALSE;
    }
}
    
STDMETHODIMP CMemStream::Write(
     const void *pv,
     ULONG cb,
     ULONG *pcbWritten)
{
    if(WriteBytes((void*)pv, cb) == no_error)
    {
        if(pcbWritten) *pcbWritten = cb;
        return S_OK;
    }
    else
    {
        if(pcbWritten) *pcbWritten = 0;
        return S_FALSE;
    }
}

STDMETHODIMP CMemStream::Seek(
     LARGE_INTEGER dlibMove,
     DWORD dwOrigin,
     ULARGE_INTEGER *plibNewPosition)
{
    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
        SetCurrentPos(dlibMove.LowPart);
        break;
    case STREAM_SEEK_CUR:
        SetCurrentPos(GetCurrentPos() + (long)dlibMove.QuadPart);
        break;
    case STREAM_SEEK_END:
        SetCurrentPos(Size() + (long)dlibMove.QuadPart);
        break;
    }

    if(plibNewPosition)
    {
        plibNewPosition->QuadPart = (LONGLONG)GetCurrentPos();
    }
    return S_OK;
}

STDMETHODIMP CMemStream::SetSize(
     ULARGE_INTEGER libNewSize)
{
    return S_OK;
}

STDMETHODIMP CMemStream::CopyTo(
     IStream *pstm,
     ULARGE_INTEGER cb,
     ULARGE_INTEGER *pcbRead,
     ULARGE_INTEGER *pcbWritten)
{
    _ASSERT(0, __TEXT("CopyTo is called on CMemStream!"));
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CMemStream::Commit(
     DWORD grfCommitFlags)
{
    return S_OK;
}

STDMETHODIMP CMemStream::Revert()
{
    return S_OK;
}


STDMETHODIMP CMemStream::LockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    return S_OK;
}

STDMETHODIMP CMemStream::UnlockRegion(
     ULARGE_INTEGER libOffset,
     ULARGE_INTEGER cb,
     DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CMemStream::Stat(
     STATSTG *pstatstg,
     DWORD grfStatFlag)
{
    pstatstg->pwcsName = NULL;
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.QuadPart = (LONGLONG)Size();
    
    return S_OK;
}
    
    

STDMETHODIMP CMemStream::Clone(
     IStream **ppstm)
{
    *ppstm = new CMemStream(*this);
    (*ppstm)->AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcwrap.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCWRAP.CPP

Abstract:

    IWbemServices Delegator

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <fastall.h>
#include "svcwrap.h"

#define BAIL_IF_DISCONN() if (!m_pObject->m_pRealWbemSvcProxy) return RPC_E_DISCONNECTED;

//***************************************************************************
//
//  CWbemSvcWrapper::CWbemSvcWrapper
//  ~CWbemSvcWrapper::CWbemSvcWrapper
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CWbemSvcWrapper::CWbemSvcWrapper(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CUnk( pControl, pUnkOuter ), m_XWbemServices(this), m_pRealWbemSvcProxy( NULL )
{
}

CWbemSvcWrapper::~CWbemSvcWrapper()
{
    // This should be cleaned up here

    if ( NULL != m_pRealWbemSvcProxy )
    {
        m_pRealWbemSvcProxy->Release();
    }

}

void* CWbemSvcWrapper::GetInterface( REFIID riid )
{
    if(riid == IID_IWbemServices)
        return &m_XWbemServices;
    else return NULL;
}

void CWbemSvcWrapper::SetProxy( IWbemServices* pProxy )
{
	// Release the current proxy and AddRef the new one
	if ( m_pRealWbemSvcProxy != NULL )
	{
		// This should never happen!
		m_pRealWbemSvcProxy->Release();
	}

	m_pRealWbemSvcProxy = pProxy;
	m_pRealWbemSvcProxy->AddRef();
}

HRESULT CWbemSvcWrapper::Disconnect( void )
{
    if ( NULL != m_pRealWbemSvcProxy )
    {
        m_pRealWbemSvcProxy->Release();
		m_pRealWbemSvcProxy = NULL;
    }

	return WBEM_S_NO_ERROR;
}

/* IWbemServices methods implemented as pass-throughs */

STDMETHODIMP CWbemSvcWrapper::XWbemServices::OpenNamespace(
		const BSTR Namespace, LONG lFlags, IWbemContext* pContext, IWbemServices** ppNewNamespace,
		IWbemCallResult** ppResult
		)
{
    BAIL_IF_DISCONN();
    
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Namespace, &bstrTemp );
	CSysFreeMe	sfm(	bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->OpenNamespace( bstrTemp, lFlags, pContext, ppNewNamespace, ppResult );
	}

	return hr;
}


STDMETHODIMP CWbemSvcWrapper::XWbemServices::CancelAsyncCall(IWbemObjectSink* pSink)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->CancelAsyncCall( pSink );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::QueryObjectSink(long lFlags, IWbemObjectSink** ppResponseHandler)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->QueryObjectSink( lFlags, ppResponseHandler );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::GetObject(const BSTR ObjectPath, long lFlags, IWbemContext* pContext,
	IWbemClassObject** ppObject, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
    
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );
	IWbemClassObject*	pNewObj = NULL;

	// Per docs, we ALWAYS NULL out.  Technically we should release, but due to provider based backwards
	// compatibility issues #337798, we are not doing so.  We may cause "strange" client code written
	// in the past to leak, however it was causing Winmgmt to leak, so we just moved the leak into their
	// process.

	if ( NULL != ppObject )
	{
		*ppObject = NULL;
	}

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->GetObject( bstrTemp, lFlags, pContext, ppObject, ppResult );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::GetObjectAsync(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
    
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->GetObjectAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutClass(IWbemClassObject* pObject, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->PutClass( pObject, lFlags, pContext, ppResult );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutClassAsync(IWbemClassObject* pObject, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->PutClassAsync( pObject, lFlags, pContext, pResponseHandler );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteClass(const BSTR Class, long lFlags, IWbemContext* pContext,
	IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteClass( bstrTemp, lFlags, pContext, ppResult );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteClassAsync(const BSTR Class, long lFlags, IWbemContext* pContext,
	IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteClassAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateClassEnum(const BSTR Superclass, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Superclass, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateClassEnum( bstrTemp, lFlags, pContext, ppEnum );
	}

	return hr;

}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateClassEnumAsync(const BSTR Superclass, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Superclass, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateClassEnumAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutInstance(IWbemClassObject* pInst, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->PutInstance( pInst, lFlags, pContext, ppResult );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutInstanceAsync(IWbemClassObject* pInst, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->PutInstanceAsync( pInst, lFlags, pContext, pResponseHandler );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteInstance(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteInstance( bstrTemp, lFlags, pContext, ppResult );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteInstanceAsync(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteInstanceAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateInstanceEnum(const BSTR Class, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateInstanceEnum( bstrTemp, lFlags, pContext, ppEnum );
	}

	return hr;

}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateInstanceEnumAsync(const BSTR Class, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateInstanceEnumAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecQuery(const BSTR QueryLanguage, const BSTR Query, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryLanguage, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecQuery( bstrTemp1, bstrTemp2, lFlags, pContext, ppEnum );

		}
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecQueryAsync(const BSTR QueryFormat, const BSTR Query, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryFormat, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecQueryAsync( bstrTemp1, bstrTemp2, lFlags, pContext, pResponseHandler );

		}
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecNotificationQuery(const BSTR QueryLanguage, const BSTR Query,
	long lFlags, IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryLanguage, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecNotificationQuery( bstrTemp1, bstrTemp2, lFlags, pContext, ppEnum );

		}
	}

	return hr;

}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecNotificationQueryAsync(const BSTR QueryFormat, const BSTR Query,
	long lFlags, IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryFormat, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecNotificationQueryAsync( bstrTemp1, bstrTemp2, lFlags, pContext, pResponseHandler );

		}
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecMethod(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
	IWbemContext *pCtx, IWbemClassObject *pInParams,
	IWbemClassObject **ppOutParams, IWbemCallResult  **ppCallResult)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( MethodName, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecMethod( bstrTemp1, bstrTemp2, lFlags, pCtx, pInParams, ppOutParams, ppCallResult );

		}
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
	IWbemContext *pCtx, IWbemClassObject *pInParams,
	IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( MethodName, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecMethodAsync( bstrTemp1, bstrTemp2, lFlags, pCtx, pInParams, pResponseHandler );

		}
	}

	return hr;
}

//	Helper function to wrap supplied BSTRs in case we were called with
//	LPCWSTRs - basically a helper for people who used to be in-proc to winmgmt
//	who were relying on the fact that they could use LPWSTRs instead of
//	BSTRs since they were in-proc and no-marshaling was taking place.

HRESULT CWbemSvcWrapper::XWbemServices::WrapBSTR( BSTR bstrSrc, BSTR* pbstrDest )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != bstrSrc )
	{
		*pbstrDest = SysAllocString( bstrSrc );

		if ( NULL == *pbstrDest )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		*pbstrDest = bstrSrc;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcwrap.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCWRAP.H

Abstract:

    IWbemServices delegator

History:

--*/

#ifndef __SVCWRAP_H__
#define __SVCWRAP_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>

//***************************************************************************
//
//  class CWbemSvcWrapper
//
//  DESCRIPTION:
//
//  This class wraps an IWbemServices interface and can be used
//	to act as a delegator on method calls.
//
//***************************************************************************

class COREPROX_POLARITY CWbemSvcWrapper : public CUnk
{
protected:
	IWbemServices*	m_pRealWbemSvcProxy;

public:
    CWbemSvcWrapper(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWbemSvcWrapper(); 

protected:

    class COREPROX_POLARITY XWbemServices : public CImpl<IWbemServices, CWbemSvcWrapper>
    {
    public:
        XWbemServices(CWbemSvcWrapper* pObject) : 
            CImpl<IWbemServices, CWbemSvcWrapper>(pObject)
        {}

		STDMETHOD(OpenNamespace)(
				const BSTR Namespace,
				LONG lFlags,
				IWbemContext* pContext,
				IWbemServices** ppNewNamespace,
				IWbemCallResult** ppResult
				);

		STDMETHOD(CancelAsyncCall)(IWbemObjectSink* pSink);
		STDMETHOD(QueryObjectSink)(long lFlags, IWbemObjectSink** ppResponseHandler);

		STDMETHOD(GetObject)(const BSTR ObjectPath, long lFlags, IWbemContext* pContext,
			IWbemClassObject** ppObject, IWbemCallResult** ppResult);
		STDMETHOD(GetObjectAsync)(const BSTR ObjectPath, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(PutClass)(IWbemClassObject* pObject, long lFlags,
			IWbemContext* pContext, IWbemCallResult** ppResult);
		STDMETHOD(PutClassAsync)(IWbemClassObject* pObject, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(DeleteClass)(const BSTR Class, long lFlags, IWbemContext* pContext,
			IWbemCallResult** ppResult);
		STDMETHOD(DeleteClassAsync)(const BSTR Class, long lFlags, IWbemContext* pContext,
			IWbemObjectSink* pResponseHandler);

		STDMETHOD(CreateClassEnum)(const BSTR Superclass, long lFlags,
			IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(CreateClassEnumAsync)(const BSTR Superclass, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(PutInstance)(IWbemClassObject* pInst, long lFlags,
			IWbemContext* pContext, IWbemCallResult** ppResult);
		STDMETHOD(PutInstanceAsync)(IWbemClassObject* pInst, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(DeleteInstance)(const BSTR ObjectPath, long lFlags,
			IWbemContext* pContext, IWbemCallResult** ppResult);
		STDMETHOD(DeleteInstanceAsync)(const BSTR ObjectPath, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(CreateInstanceEnum)(const BSTR Class, long lFlags,
			IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(CreateInstanceEnumAsync)(const BSTR Class, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(ExecQuery)(const BSTR QueryLanguage, const BSTR Query, long lFlags,
			IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(ExecQueryAsync)(const BSTR QueryFormat, const BSTR Query, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(ExecNotificationQuery)(const BSTR QueryLanguage, const BSTR Query,
			long lFlags, IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(ExecNotificationQueryAsync)(const BSTR QueryFormat, const BSTR Query,
			long lFlags, IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(ExecMethod)(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
			IWbemContext *pCtx, IWbemClassObject *pInParams,
			IWbemClassObject **ppOutParams, IWbemCallResult  **ppCallResult);
		STDMETHOD(ExecMethodAsync)(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
			IWbemContext *pCtx, IWbemClassObject *pInParams,
			IWbemObjectSink* pResponseHandler);

		HRESULT WrapBSTR( BSTR bstrSrc, BSTR* pbstrDest );

    } m_XWbemServices;
    friend XWbemServices;

protected:
    void* GetInterface(REFIID riid);

public:
	void SetProxy( IWbemServices* pProxy );

	HRESULT Disconnect( void );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\txtscmgr.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    TXTSCMGR.H

Abstract:

  CTextSourceMgr Definition.

  Class to manage Text Source Encoder/Decoder objects

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _TXTSRCMGR_H_
#define _TXTSRCMGR_H_

#include "corepol.h"
#include "wmitxtsc.h"
#include "sync.h"
#include <arena.h>

//***************************************************************************
//
//  class CTextSourceMgr
//
//    Helper class to manage Text Source Encoder/Decoder objects
//
//***************************************************************************

class COREPROX_POLARITY CTextSourceMgr
{
private:
	CCritSec				m_cs;
	CWmiTextSourceArray		m_TextSourceArray;

public:
    CTextSourceMgr();
	virtual ~CTextSourceMgr(); 

protected:
	HRESULT Add( ULONG ulId, CWmiTextSource** pNewTextSource );

public:
    HRESULT Find( ULONG ulId, CWmiTextSource** pTextSource );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\txtscmgr.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    TXTSCMGR.CPP

Abstract:

  CTextSourceMgr implementation.

  Helper class for maintaining text source objects.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include <reg.h>
#include "txtscmgr.h"

//***************************************************************************
//
//  CTextSourceMgr::~CTextSourceMgr
//
//***************************************************************************
// ok
CTextSourceMgr::CTextSourceMgr()
:	m_cs(),
	m_TextSourceArray()
{
}
    
//***************************************************************************
//
//  CTextSourceMgr::~CTextSourceMgr
//
//***************************************************************************
// ok
CTextSourceMgr::~CTextSourceMgr()
{
}

// Protected Helpers
HRESULT CTextSourceMgr::Add( ULONG ulId, CWmiTextSource** pNewTextSource )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Always created with a ref count of 1
	CWmiTextSource*	pTextSource = new CWmiTextSource;
	CTemplateReleaseMe<CWmiTextSource>	rm( pTextSource );

	if ( NULL != pTextSource )
	{
		hr = pTextSource->Init( ulId );

		if ( SUCCEEDED( hr ) )
		{
			if ( m_TextSourceArray.Add( pTextSource ) < 0 )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				// Copy out the new guy
				pTextSource->AddRef();
				*pNewTextSource = pTextSource;
			}
		}	//IF Initialized

	}	// IF alloc succeeded

	return hr;
}

//Implementation functions

// Adds if it cannot find an id
HRESULT CTextSourceMgr::Find( ULONG ulId, CWmiTextSource** pSrc )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// This must be thread-safe
	CInCritSec	ics( &m_cs );

	// Keep track of the object we are pointing at
	CWmiTextSource*	pTextSource = NULL;

	for( int x = 0; x < m_TextSourceArray.GetSize(); x++ )
	{
		CWmiTextSource*	pTmpSource = m_TextSourceArray.GetAt( x );
		
		if ( pTmpSource->GetId() == ulId )
		{
			// AddRef for the return
			pTextSource = pTmpSource;
			pTextSource->AddRef();
			break;
		}
	}

	// See if we found it
	if ( NULL == pTextSource )
	{
		// We only need Read access
		Registry	reg( HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_WBEM_TEXTSRC );

		if ( reg.GetLastError() == ERROR_SUCCESS )
		{
			hr = Add( ulId, pSrc );
		}
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		// Already AddRef'd
		*pSrc = pTextSource;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKMRSH.CPP

Abstract:

    Unbound Sink Marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "ubskmrsh.h"
#include <fastall.h>
#include <cominit.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemUnboundObjectSink)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CUnboundSinkProxyBuffer* pProxy = new CUnboundSinkProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemUnboundObjectSink 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemUnboundObjectSink)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CUnboundSinkStubBuffer* pStub = new CUnboundSinkStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }

    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CUnboundSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XUnboundSinkFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer
//  ~CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
        m_XUnboundSinkFacelet(this), m_pChannel(NULL), m_pOldProxy( NULL ), m_pOldProxyUnboundSink( NULL ),
        m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
    m_StubType = UNKNOWN;

}

CUnboundSinkProxyBuffer::~CUnboundSinkProxyBuffer()
{
    // This MUST be released first

    if ( NULL != m_pOldProxyUnboundSink )
    {
        m_pOldProxyUnboundSink->Release();
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pControl->ObjectDestroyed(this);

}

ULONG STDMETHODCALLTYPE CUnboundSinkProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CUnboundSinkProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemUnboundObjectSink)
    {
        *ppv = (IWbemUnboundObjectSink*)&m_XUnboundSinkFacelet;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}

//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return the security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // First set the security explicitly on our IUnknown, then we will Set the blanket
    // on ourselves using the punkOuter (It's tricky but it works...uh...we think).
    
    // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
    // may have to go remote

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );

    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
//                      Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemUnboundObjectSink::Indicate calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
IndicateToConsumer( IWbemClassObject* pLogicalConsumer, LONG lObjectCount, IWbemClassObject** ppObjArray )
{
    HRESULT hr = S_OK;

    // Make sure the lObjectCount parameter and the array pointer make sense

    if ( lObjectCount < 0 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount == 0 && NULL != ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount > 0 && NULL == ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }


    CInCritSec ics(&m_cs);

    // If the stublet is an old style, just let the old proxy handle it

    if(m_pObject->m_StubType == OLD) 
        return m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, lObjectCount, ppObjArray );

    // If the stublet is unknown, send just the first object and check the return
    // code to determine what is on the other side. 

    if(m_pObject->m_StubType == UNKNOWN) 
    {
        hr = m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, 1, ppObjArray );

        // bump up pointer to the next object so that it isnt sent more than once
    
        lObjectCount--;
        ppObjArray++;

        if(hr == WBEM_S_NEW_STYLE)
        {
            m_pObject->m_StubType = NEW;
        }
        else
        {
            // We have an old client, set the stub type and send any remaining objects

            m_pObject->m_StubType = OLD;
            if(lObjectCount > 0)
                hr = m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, lObjectCount, ppObjArray );
            return hr;
        }
    }


    if(lObjectCount < 1)
        return S_OK;            // if all done, then just return.

    // Create a packet and some data for it to use.  Then calculate 
    // the length of the packet

    DWORD dwLength = 0;
    GUID* pguidClassIds = new GUID[lObjectCount];
    BOOL* pfSendFullObject = new BOOL[lObjectCount];

    // arrays will be deleted when we drop out of scope.
    CVectorDeleteMe<GUID>   delpguidClassIds( pguidClassIds );
    CVectorDeleteMe<BOOL>   delpfSendFullObject( pfSendFullObject );

    if (!pguidClassIds || !pfSendFullObject)
    	return WBEM_E_OUT_OF_MEMORY;

    CWbemUnboundSinkIndicatePacket packet;
    hr = packet.CalculateLength( pLogicalConsumer, lObjectCount, ppObjArray, &dwLength, 
            m_pObject->m_ClassToIdMap, pguidClassIds, pfSendFullObject );
    if (FAILED(hr))
    {
#ifdef DBG
        char pBuff[128];
        sprintf(pBuff,"CUnboundSinkProxyBuffer::XUnboundSinkFacelet::IndicateToConsumer %08x\n",hr);
        OutputDebugStringA(pBuff);
#endif    
        return hr;
    }


    // Declare the message structure

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = dwLength;

    // This is the id of the Invoke function.  This MUST be set before calling GetBuffer, or 
    // it will fail.

    msg.iMethod = 3;

    // allocate the channel buffer and marshal the data into it

    HRESULT hres = m_pObject->GetChannel()->GetBuffer(&msg, IID_IWbemUnboundObjectSink);
    if(FAILED(hres)) return hres;

#ifdef DBG
    BYTE * pCheckTail = (BYTE *)CBasicBlobControl::sAllocate(dwLength+8);
    if (!pCheckTail)
    	return WBEM_E_OUT_OF_MEMORY;

    BYTE * pTail = pCheckTail+dwLength;
    memcpy(pTail,"TAILTAIL",8);

    hr = packet.MarshalPacket( pCheckTail, dwLength, pLogicalConsumer, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);

    if (0 != memcmp(pTail,"TAILTAIL",8))
    	DebugBreak();
    
    memcpy(msg.Buffer,pCheckTail,dwLength);
    
    CBasicBlobControl::sDelete(pCheckTail);
#else
    // Setup the packet for marshaling
    hr = packet.MarshalPacket(  (LPBYTE)msg.Buffer, dwLength, pLogicalConsumer, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);
#endif /* ifdef DBG*/

    // Send the data to the stub only if the marshaling was successful

    if ( SUCCEEDED( hr ) )
    {

        DWORD dwRes;
        hr = m_pObject->GetChannel()->SendReceive(&msg, &dwRes);
        if(FAILED(hr))
        {
            if(msg.Buffer)
                m_pObject->GetChannel()->FreeBuffer(&msg);
            return dwRes;
        }

        // We appear to be ok, so get HRESULT

        LPBYTE pbData = (LPBYTE) msg.Buffer;
        hr = *((HRESULT*) pbData);
        m_pObject->GetChannel()->FreeBuffer(&msg);

    }
    else
    {
        // Clean up the buffer -- Marshaling the packet failed
        if(msg.Buffer)
            m_pObject->GetChannel()->FreeBuffer(&msg);
    }

    return hr;

}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    // get a pointer to the old UnboundSink which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // Establish the marshaling context
    DWORD   dwCtxt = 0;
    pChannel->GetDestCtx( &dwCtxt, NULL );

    m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.


    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );
    if (FAILED(hr))
    	return hr;

    // We aggregated it --- WE OWN IT!
    
    hr = pIPS->CreateProxy( this, IID_IWbemUnboundObjectSink, &m_pOldProxy, (void**) &m_pOldProxyUnboundSink );
    pIPS->Release();
    if (FAILED(hr))
    	return hr;    

    // Save a reference to the channel

    hr = m_pOldProxy->Connect( pChannel );

    if(m_pChannel)
        return E_UNEXPECTED;
    
    m_pChannel = pChannel;
    if(m_pChannel)
        m_pChannel->AddRef();

    return S_OK;
}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CUnboundSinkProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old Proxy UnboundSink MUST be released first.

    if ( NULL != m_pOldProxyUnboundSink )
    {
        m_pOldProxyUnboundSink->Release();
        m_pOldProxyUnboundSink = NULL;
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CUnboundSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CUnboundSinkStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XUnboundSinkStublet;
    else
        return NULL;
}

CUnboundSinkStubBuffer::XUnboundSinkStublet::XUnboundSinkStublet(CUnboundSinkStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CUnboundSinkStubBuffer>(pObj), m_pServer(NULL), m_lConnections( 0 )
{
    m_bFirstIndicate = true;
}

CUnboundSinkStubBuffer::XUnboundSinkStublet::~XUnboundSinkStublet() 
{
    if(m_pServer)
        m_pServer->Release();

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject UnboundSink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemUnboundObjectSink, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // get a pointer to the old stub which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.


    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );
    if (FAILED(hr))
    	return hr;    

    hr = pIPS->CreateStub( IID_IWbemUnboundObjectSink, m_pServer, &m_pObject->m_pOldStub );
    pIPS->Release();
    if (FAILED(hr))
    	return hr;

    // Successful connection

    m_lConnections++;
    return S_OK;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemUnboundObjectSink
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    if(m_pServer)
    {
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Successful disconnect
    m_lConnections--;

}


//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( pMessage->iMethod == 3 )
        return IndicateToConsumer_Stub( pMessage, pChannel );
    else
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;

}

//***************************************************************************
//
//  HRESULT CUnboundSinkStubBuffer::XUnboundSinkStublet::IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, 
//                                                        IRpcChannelBuffer* pBuffer )
//
//  DESCRIPTION:
//
//  Handles the Indicate function in the stublet.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CUnboundSinkStubBuffer::XUnboundSinkStublet::IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer )
{
    HRESULT             hr = RPC_E_SERVER_CANTUNMARSHAL_DATA;
    SCODE sc;

    // Determine if an old style, or new style packet has arrived

    CWbemUnboundSinkIndicatePacket packet( (LPBYTE) pMessage->Buffer, pMessage->cbBuffer);
    sc = packet.IsValid();
    bool bOldStyle = (S_OK != packet.IsValid());

    if(bOldStyle)
    {
        // Pass the call in using the old style stub

        hr = m_pObject->m_pOldStub->Invoke( pMessage, pBuffer );

		// Invoke must return S_OK, m_bFirstIndicate must be true and the actual return
		// code from the implementation code must be S_OK.

        if( hr == S_OK && m_bFirstIndicate && *(( HRESULT __RPC_FAR * )pMessage->Buffer) == S_OK )
        {
            // Let proxy know that we can handle the new style by returning a special return code.
        
            *(( HRESULT __RPC_FAR * )pMessage->Buffer) = WBEM_S_NEW_STYLE;
            m_bFirstIndicate = false;
            return hr;
        }
        return hr;
    }

    m_bFirstIndicate = false;

    // Got some new style data.  Unmarshall it.

    long lObjectCount = 0; 
    IWbemClassObject*   pLogicalConsumer = NULL;
    IWbemClassObject ** pObjArray = NULL;
    sc = packet.UnmarshalPacket( pLogicalConsumer, lObjectCount, pObjArray, m_ClassCache );

    // Only continue if the Unmarshaling succeeded.  If it failed, we still want
    // the sc to go back to the other side

    if ( SUCCEEDED( sc ) )
    {

        // Call the acual UnboundSink
        sc = m_pServer->IndicateToConsumer( pLogicalConsumer, lObjectCount, pObjArray );

        for ( int nCtr = 0; nCtr < lObjectCount; nCtr++ )
        {
            pObjArray[nCtr]->Release();
        }
    
        delete [] pObjArray;

        // Done with the logical consumer
        if ( NULL != pLogicalConsumer )
        {
            pLogicalConsumer->Release();
        }

    }

    // Send the results back

    pMessage->cbBuffer = sizeof(HRESULT);

    hr = pBuffer->GetBuffer( pMessage, IID_IWbemUnboundObjectSink );

    if ( SUCCEEDED( hr ) )
    {
        ((HRESULT*)pMessage->Buffer)[0] = sc;
    }
    else
    {
        hr = sc;
    }
    return hr;

}

IRpcStubBuffer* STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKMRSH.H

Abstract:

    Unbound Sink Marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include "ubskpckt.h"

//***************************************************************************
//
//  class CUnboundSinkFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemUnboundObjectSink interface.
//
//***************************************************************************

class CUnboundSinkFactoryBuffer : public CUnkInternal
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XUnboundSinkFactory : public CImpl<IPSFactoryBuffer, CUnboundSinkFactoryBuffer>
    {
    public:
        XUnboundSinkFactory(CUnboundSinkFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CUnboundSinkFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XUnboundSinkFactory;
public:
    CUnboundSinkFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_XUnboundSinkFactory(this), m_pLifeControl( pControl )
    {
    }
    ~CUnboundSinkFactoryBuffer()
    {
    }    

    void* GetInterface(REFIID riid);

	friend XUnboundSinkFactory;
};

//***************************************************************************
//
//  class CUnboundSinkProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemUnboundObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CUnboundSinkProxyBuffer : public IRpcProxyBuffer
{
private:
	IRpcProxyBuffer*	m_pOldProxy;
	IWbemUnboundObjectSink*	m_pOldProxyUnboundSink;
    enum {OLD, NEW, UNKNOWN} m_StubType;
    CWbemClassToIdMap m_ClassToIdMap;
	bool		m_fRemote;

protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XUnboundSinkFacelet : public IWbemUnboundObjectSink, IClientSecurity
    {
    protected:
        CUnboundSinkProxyBuffer* m_pObject;
        CRITICAL_SECTION m_cs;        

    public:
        XUnboundSinkFacelet(CUnboundSinkProxyBuffer* pObject) : m_pObject(pObject){InitializeCriticalSection(&m_cs);};
        ~XUnboundSinkFacelet(){DeleteCriticalSection(&m_cs);};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE IndicateToConsumer( IWbemClassObject* pLogicalConsumer, LONG lObjectCount, IWbemClassObject** ppObjArray );

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XUnboundSinkFacelet;
    friend XUnboundSinkFacelet;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

public:
    CUnboundSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CUnboundSinkProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CUnboundSinkStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemUnboundObjectSink interface.
//
//***************************************************************************

class CUnboundSinkStubBuffer : public CUnk
{
private:

	IRpcStubBuffer*	m_pOldStub;

protected:
    class XUnboundSinkStublet : public CImpl<IRpcStubBuffer, CUnboundSinkStubBuffer>
    {
        IWbemUnboundObjectSink* m_pServer;
		LONG			m_lConnections;
        CWbemClassCache m_ClassCache;
        bool m_bFirstIndicate;
    public:
        XUnboundSinkStublet(CUnboundSinkStubBuffer* pObj);
        ~XUnboundSinkStublet();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
	private:

		HRESULT IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer );
        friend CUnboundSinkStubBuffer;
    } m_XUnboundSinkStublet;
    friend XUnboundSinkStublet;

public:
    CUnboundSinkStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XUnboundSinkStublet(this), m_pOldStub( NULL )
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umicombd.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMICOMBD.CPP

Abstract:

  CUMIComBinding implementation.

  Implements the IWbemComBinding interface.

History:

  14-May-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "umicombd.h"
#include "arrtempl.h"

//***************************************************************************
//
//  CUMIComBinding::CUMIComBinding
//
//***************************************************************************
// ok
CUMIComBinding::CUMIComBinding( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWmiComBinding( this )
{
}
    
//***************************************************************************
//
//  CUMIComBinding::~CUMIComBinding
//
//***************************************************************************
// ok
CUMIComBinding::~CUMIComBinding()
{
}

// Override that returns us an interface
void* CUMIComBinding::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemComBinding )
        return &m_XWmiComBinding;
    else
        return NULL;
}

// Pass thru _IWbemConfigureRefreshingSvc implementation
STDMETHODIMP CUMIComBinding::XWmiComBinding::GetCLSIDArrayForIID( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags,
															IWbemContext* pCtx, SAFEARRAY** pArray )
{
	return m_pObject->GetCLSIDArrayForIID( pSvcEx, pObject, riid, lFlags, pCtx, pArray );
}

STDMETHODIMP CUMIComBinding::XWmiComBinding::BindComObject( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId,
								IWbemContext *pCtx, long lFlags, IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface )
{
	return m_pObject->BindComObject( pSvcEx, pObject, ClsId, pCtx, lFlags, pUnkOuter, dwClsCntxt, riid, pInterface );
}

STDMETHODIMP CUMIComBinding::XWmiComBinding::GetCLSIDArrayForNames( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
																	LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray )
{
	return m_pObject->GetCLSIDArrayForNames( pSvcEx, pObject, rgszNames, cNames, lcid, pCtx, lFlags, pArray );
}

/* IWbemComBinding implemetation */
HRESULT CUMIComBinding::GetCLSIDArrayForIID( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags,
										IWbemContext* pCtx, SAFEARRAY** pArray )
{
	// Check we've got everything we need, and that the class context is one of the ones we
	// currently support.

	if ( 0L != lFlags || NULL == pSvcEx || NULL == pObject || NULL == pArray )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Pass through to the UMI interface
		CLSID	clsid;
		IUmiCustomInterfaceFactory*	pUmiIntfFactory = NULL;

		HRESULT	hr = pObject->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pUmiIntfFactory );
		CReleaseMe	rmFactory( pUmiIntfFactory );

		if ( SUCCEEDED ( hr ) )
		{
			hr = pUmiIntfFactory->GetCLSIDForIID( riid, 0L,  &clsid );

			if ( SUCCEEDED( hr ) )
			{

				WCHAR	strGuid[64];

				if ( StringFromGUID2( clsid, strGuid, 64 ) > 0 )
				{
					// The one we'll return to the user
					CSafeArray	saCLSID( VT_BSTR, CSafeArray::auto_delete );

					BSTR	bstrGuid = SysAllocString( strGuid );
					CSysFreeMe	sfmGuid( bstrGuid );

					if ( NULL != bstrGuid )
					{
						// Add the BSTR
						saCLSID.AddBSTR( bstrGuid );
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

					// IF all is kosher, get the array, and set the destructor policy to not delete it
					if ( SUCCEEDED( hr ) )
					{
						*pArray = saCLSID.GetArray();
						saCLSID.SetDestructorPolicy( CSafeArray::no_delete );
					}

				}
				else
				{
					// We got back a bad CLSID
					hr = WBEM_E_FAILED;
				}

			}	// IF GetCLSIDForIID

		}	// IF QI for UMI Factory Interface
		 

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	
	return hr;
}

HRESULT CUMIComBinding::BindComObject( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId, IWbemContext *pCtx,
										long lFlags, IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface )
{

	// Check we've got everything we need, and that the class context is one of the ones we
	// currently support.

	if ( 0L != lFlags || NULL == pSvcEx || NULL == pObject || NULL == pInterface )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Aggregation requires IID_IUnknown
	if ( NULL != pUnkOuter && riid != IID_IUnknown )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{

		// Pass through to the UMI interface
		CLSID	clsid;
		IUmiCustomInterfaceFactory*	pUmiIntfFactory = NULL;

		HRESULT	hr = pObject->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pUmiIntfFactory );
		CReleaseMe	rmFactory( pUmiIntfFactory );

		if ( SUCCEEDED ( hr ) )
		{
			hr = pUmiIntfFactory->GetObjectByCLSID( ClsId, pUnkOuter, dwClsCntxt, riid, 0L, pInterface );

		}	// IF QI for UMI Factory Interface
		 
	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	
	return hr;
}

HRESULT CUMIComBinding::GetCLSIDArrayForNames( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
												LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray )
{
	if ( 0L != lFlags || NULL == pSvcEx || NULL == pObject || NULL == pArray || cNames <= 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		IWbemClassObject*	pDispInfoInst = NULL;

		DISPID*	pDispIdArray = new DISPID[cNames];
		CVectorDeleteMe<DISPID>	vdm( pDispIdArray );

		if ( NULL != pDispIdArray )
		{
			ZeroMemory( pDispIdArray, cNames * sizeof(DISPID) );
			CLSID	clsid;

			IUmiCustomInterfaceFactory*	pUmiIntfFactory = NULL;

			hr = pObject->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pUmiIntfFactory );
			CReleaseMe	rmFactory( pUmiIntfFactory );

			if ( SUCCEEDED ( hr ) )
			{
				hr = pUmiIntfFactory->GetCLSIDForNames( (LPOLESTR *) rgszNames, cNames, lcid, pDispIdArray, 0L,  &clsid );

				if ( SUCCEEDED( hr ) )
				{
					// Get an instance for the array
					hr = GetDispatchInfoInstance( &pDispInfoInst );
					CReleaseMe	rmInst( pDispInfoInst );

					if ( SUCCEEDED( hr ) )
					{
						hr = FillOutInstance( pDispInfoInst, cNames, pDispIdArray, &clsid);

						if ( SUCCEEDED( hr ) )
						{
							// The array we'll return to the user
							CSafeArray	saObjects( VT_UNKNOWN, CSafeArray::auto_delete );

							// Add the object and unbind the array pointer
							saObjects.AddUnknown( pDispInfoInst );

							*pArray = saObjects.GetArray();
							saObjects.SetDestructorPolicy( CSafeArray::no_delete );
						}

					}	// If Got a dispatch info instance

				}	// IF GetCLSIDForNames

			}	// IF QI

		}	// IF allocate dispid array
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	
	return hr;
}

// Helper to create a DispatchInfo Instance
HRESULT	CUMIComBinding::GetDispatchInfoInstance( IWbemClassObject** ppInst )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	CComDispatchInfoClass	DispInfoClass;

	hr = DispInfoClass.Init();

	if ( SUCCEEDED( hr ) )
	{
		hr = DispInfoClass.SpawnInstance( 0L, ppInst );
	}

	return hr;
}

// Helper to create a DispatchInfo Instance
HRESULT	CUMIComBinding::FillOutInstance( IWbemClassObject* pInst, ULONG cDispIds, DISPID* pDispIdArray, CLSID* pClsId )
{
	_IWmiObject*	pWmiObject = NULL;

	HRESULT	hr = pInst->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

	if ( SUCCEEDED( hr ) )
	{
		WCHAR	strTemp[64];

		// Write out the CLSID
		if ( StringFromGUID2( *pClsId, strTemp, 64 ) > 0 )
		{
			hr = pWmiObject->WriteProp( L"CLSID", 0L, ( wcslen( strTemp ) + 1 ) * 2, 0L, CIM_STRING, &strTemp );

			if ( SUCCEEDED( hr ) )
			{
				hr = pWmiObject->WriteProp( L"DISPID", 0L, sizeof(DISPID), 0L, CIM_SINT32, &pDispIdArray[0] );

				if ( SUCCEEDED( hr ) )
				{
					// Use this to hold DISPID names
					CSafeArray	saDISPID( VT_I4, CSafeArray::auto_delete );

					for ( ULONG uCtr = 1; SUCCEEDED( hr ) && uCtr < cDispIds; uCtr++ )
					{
						saDISPID.AddLong( pDispIdArray[uCtr] );
					}	// For enumerate dispids and add to safe array

					if ( SUCCEEDED( hr ) )
					{
						VARIANT	vTargetDispIds;

						// We won't clear this, the Safe Array will take care of cleanup
						V_VT( &vTargetDispIds ) = ( VT_I4 | VT_ARRAY );
						V_ARRAY( &vTargetDispIds ) = saDISPID.GetArray();

						hr = pInst->Put( L"NamedArgumentDISPIDs", 0L, &vTargetDispIds, 0L );
					}

				}	// IF Put DISPID

			}	// IF Put CLSID

		}	// IF GetStr for CLSID
		else
		{
			hr = WBEM_E_FAILED;
		}

	}	// IF QI for IWmiObject

	return hr;
}

HRESULT CUMIComBinding::CComDispatchInfoClass::Init()
{
    HRESULT	hRes = InitEmpty(1024);

	if ( FAILED( hRes ) )
	{
		return hRes;
	}

    CVar v(VT_BSTR, L"__COMDispatchInfo");
    hRes = SetPropValue(L"__CLASS", &v, 0);

	if ( SUCCEEDED( hRes ) )
	{
		CVar vNull;
		vNull.SetAsNull();
		hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);

		if ( SUCCEEDED( hRes ) )
		{
		    hRes = SetPropValue(L"DISPID", &vNull, CIM_SINT32);

			if ( SUCCEEDED( hRes ) )
			{

			    hRes = SetPropValue(L"NamedArgumentDISPIDs", &vNull, CIM_SINT32 | CIM_FLAG_ARRAY );

			}// DISPID

		}	// CLSID

	}	// IF Added __CLASS

	return hRes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskpckt.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKPCKT.H

Abstract:

    Unbound Sink Packet

History:

--*/

#ifndef __UBSINKPACKET_H__
#define __UBSINKPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_UNBOUNDSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwLogicalConsumerSize;	// Size of Logical Consumer Object
} WBEM_DATAPACKET_UNBOUNDSINK_INDICATE;

#ifdef _WIN64
typedef UNALIGNED WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#else
typedef WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#endif

// restore packing
#pragma pack( pop )

//
//	Class: CWbemUnboundSinkIndicatePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemUnbopundObjectSink::IndicateToConsumer() operation.  The data
//	structure of this packet is described above.  It makes use of
//	CWbemObjectPacket, CWbemInstancePacket, CWbemClassPacket and
//	CWbemClasslessInstancePacket to walk and analyze data for each of
//	the IWbemClassObjects that are indicated into the Sink.
//

class CWbemUnboundSinkIndicatePacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE	m_pUnboundSinkIndicate;

public:

	CWbemUnboundSinkIndicatePacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemUnboundSinkIndicatePacket();

	HRESULT CalculateLength( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
				IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
				IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( IWbemClassObject*& pLogicalConsumer, LONG& lObjectCount,
							IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, IWbemClassObject* pLogicalConsumer, 
				LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds,
				BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemUnboundSinkIndicatePacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength,
															 IWbemClassObject* pLogicalConsumer,
															 LONG lObjectCount,
															 IWbemClassObject** apClassObjects,
															 GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( pLogicalConsumer, lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskpckt.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKPCKT.CPP

Abstract:

    Unbound Sink Packet

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "ubskpckt.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::CWbemUnboundSinkIndicatePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemUnboundSinkIndicatePacket::CWbemUnboundSinkIndicatePacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pUnboundSinkIndicate( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pUnboundSinkIndicate = (PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::~CWbemUnboundSinkIndicatePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemUnboundSinkIndicatePacket::~CWbemUnboundSinkIndicatePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              IWbemClassObject*   pLogicalConsumer - Consumer Object
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::CalculateLength( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
                                                        IWbemClassObject** apClassObjects, DWORD* pdwLength,
                                                        CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds,
                                                        BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwObjectLength = 0;

    // Get the size of the logical consumer object.  If it doesn't exist, obviously
    // its size is 0

    if ( NULL != pLogicalConsumer )
    {
        _IWmiObject* pObjInternals = NULL;

        hr = pLogicalConsumer->QueryInterface( IID__IWmiObject, (void**) &pObjInternals );

        if ( SUCCEEDED( hr ) )
        {

            // We need enough room to store the logical consumer object
            hr = pObjInternals->GetObjectMemory( NULL, 0, &dwObjectLength );

            // This is not an error
            if ( WBEM_E_BUFFER_TOO_SMALL == hr )
            {
                hr = WBEM_S_NO_ERROR;
            }

            // Cleanup the AddRef
            pObjInternals->Release();

        }   // IF QI

    }   // IF pLogicalConsumer

    // Now factor in the actual array
    if ( SUCCEEDED( hr ) )
    {
        DWORD   dwArrayLength = 0;

        // Now get the size of the objects as described by the object array
        CWbemObjectArrayPacket  arrayPacket;

        hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwArrayLength, classtoidmap, pguidClassIds, pfSendFullObject );

        // Store the length if we're okey-dokey
        if ( SUCCEEDED( hr ) )
        {
            // Account for the header sizes
            *pdwLength = ( dwArrayLength + dwObjectLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_UNBOUNDSINK_INDICATE ) );
        }

    }   // IF Got Object Length

    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              IWbemClassObject*   pLogicalConsumer - Consumer Object
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::MarshalPacket( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
                                                      IWbemClassObject** apClassObjects, GUID* paguidClassIds,
                                                      BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE, 0 );

    if ( SUCCEEDED( hr ) )
    {
        DWORD   dwUnboundObjectLength = 0;

        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pUnboundSinkIndicate;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the Indicate Header
        m_pUnboundSinkIndicate->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        m_pUnboundSinkIndicate->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        if ( NULL != pLogicalConsumer )
        {

            // Now we will get the object memory and copy it into the buffer,
            // remembering that we will be filling the LogicalConsumerLength in
            // the header with the proper object buffer size.

            _IWmiObject*   pObjInternals = NULL;

            hr = pLogicalConsumer->QueryInterface( IID__IWmiObject, (void**) &pObjInternals );

            if ( SUCCEEDED( hr ) )
            {

                // We need enough room to store the logical consumer object
                DWORD dwTemp;

                hr = pObjInternals->GetObjectMemory( pbData, dwLength, &dwTemp);
                m_pUnboundSinkIndicate->dwLogicalConsumerSize = dwTemp;
                // Cleanup QI AddRef
                pObjInternals->Release();
                
            }   // IF QI

        }   // IF NULL != pLogicalConsumer
        else
        {
            // No consumer, so the length must be 0
            m_pUnboundSinkIndicate->dwLogicalConsumerSize = 0;
        }

        // Now marshal the array packet
        if ( SUCCEEDED( hr ) )
        {
            // Adjust for the logical consumer object then package up the rest of the array
            pbData += m_pUnboundSinkIndicate->dwLogicalConsumerSize;
            dwLength -= m_pUnboundSinkIndicate->dwLogicalConsumerSize;

            // Now use the array packet class to marshal the objects into the buffer
            CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
            hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

        }   // IF GetObjectMemory



    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              IWbemClassObject*&  pLogicalConsumer - Consumer Object
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::UnmarshalPacket( IWbemClassObject*& pLogicalConsumer, LONG& lObjectCount,
                                                        IWbemClassObject**& apClassObjects,
                                                        CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pUnboundSinkIndicate;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and try to construct the logical consumer from memory.

        // Points us at the logical consumer object
        pbData += sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        // Only need to handle the logical consumer if there was one.  If there wasn't then
        // the size will be 0.

        if ( m_pUnboundSinkIndicate->dwLogicalConsumerSize > 0 )
        {
            // Allocate a buffer big enough to hold the memory blob, copy out the data and then
            // create us an object from the memory

            LPBYTE  pbObjData = CBasicBlobControl::sAllocate(m_pUnboundSinkIndicate->dwLogicalConsumerSize);

            if ( NULL != pbObjData )
            {
                // Copy the bytes (this is VERY IMPORTANT)
                memcpy( pbObjData, pbData, m_pUnboundSinkIndicate->dwLogicalConsumerSize );

                DWORD dwTemp = m_pUnboundSinkIndicate->dwLogicalConsumerSize;
                pLogicalConsumer = CWbemObject::CreateFromMemory( pbObjData, dwTemp , TRUE );

                if ( NULL == pLogicalConsumer )
                {
                    // Cleanup the byte array
                    CBasicBlobControl::sDelete(pbObjData);
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF logical cosumer size is > 0
        else
        {
            // No consumer to worry ourselves over
            pLogicalConsumer = NULL;
        }

        // Unmarshal the object array
        if ( SUCCEEDED( hr ) )
        {
            // Now skip over the object and try to unwind the object array
            pbData += m_pUnboundSinkIndicate->dwLogicalConsumerSize;
            dwLength -= m_pUnboundSinkIndicate->dwLogicalConsumerSize;

            // Unwind the array
            CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
            hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );
        }

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemUnboundSinkIndicatePacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pUnboundSinkIndicate = (PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pUnboundSinkIndicate = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umicombd.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMICOMBD.H

Abstract:

  CUMIComBinding Definition.

  Implements the IWbemComBinding interface.

History:

  05-May-2000	sanjes    Created.

--*/

#ifndef __UMICOMBD_H__
#define __UMICOMBD_H__

#include "corepol.h"
#include <arena.h>

//***************************************************************************
//
//  class CUMIComBinding
//
//  Implementation of IWbemComBinding Interface
//
//***************************************************************************

class COREPROX_POLARITY CUMIComBinding : public CUnk
{
private:

public:
    CUMIComBinding(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CUMIComBinding(); 

	// Initializes a class we use to generate instances for GetCLSIDArrayForNames
	class CComDispatchInfoClass : public CWbemClass
	{
	public:
		CComDispatchInfoClass(){}
		HRESULT Init();
	};

protected:


    class COREPROX_POLARITY XWmiComBinding : public CImpl<IWbemComBinding, CUMIComBinding>
    {
    public:
        XWmiComBinding(CUMIComBinding* pObject) : 
            CImpl<IWbemComBinding, CUMIComBinding>(pObject)
        {}

		// Returns all matching CLSIDs for requested IID as array of BSTRs
		STDMETHOD(GetCLSIDArrayForIID)( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags, IWbemContext* pCtx, SAFEARRAY** pArray );

		// Gets the requested object and creates the supplied CLSID, requesting
		// the specified interface, and returning that in pObj
		STDMETHOD(BindComObject)( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId, IWbemContext *pCtx, long lFlags,
								IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface );

		// Provides DISPIDs for Names and the CLSID for the object that supports them
		// Returned as a SAFEARRAY of IUnknowns.
		STDMETHOD(GetCLSIDArrayForNames)( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
										LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray );

    } m_XWmiComBinding;
    friend XWmiComBinding;


protected:

	// Returns all matching CLSIDs for requested IID as array of BSTRs
	virtual HRESULT GetCLSIDArrayForIID( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags, IWbemContext* pCtx, SAFEARRAY** pArray );

	// Gets the requested object and creates the supplied CLSID, requesting
	// the specified interface, and returning that in pObj
	virtual HRESULT BindComObject( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId, IWbemContext *pCtx, long lFlags,
									IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface );

	virtual HRESULT GetCLSIDArrayForNames( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
											LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray );

protected:
    void* GetInterface(REFIID riid);

	// Helper Functions
	HRESULT	GetDispatchInfoInstance( IWbemClassObject** ppInst );
	HRESULT FillOutInstance( IWbemClassObject* pInst, ULONG cDispIds, DISPID* pDispIdArray, CLSID* pClsId );

public:

	BOOL Initialize( void ) { return TRUE; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umictxt.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMICTXT.CPP

Abstract:

  CUmiContextWrapper implementation.

  Implements methods for setting interface properties on UMI
  interfaces from an IWbemContext.

History:

  17-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umictxt.h"
#include <corex.h>
#include "strutils.h"
#include "umiprop.h"

LPCWSTR	CUMIContextWrapper::s_aConnectionContextNames[MAXNUM_CONNECTION_NAMES] = {
	L"__UMI_CONN__TIMEOUT",
	L"__UMI_CONN__USERID",
	L"__UMI_CONN__PASSWORD",
	L"__UMI_CONN__SECUREDAUTHENTICATION",
	L"__UMI_CONN__PADS_CONNECTION_READONLYSERVER",
	L"__UMI_CONN__PADS_CONNECTION_NOAUTHENTICATION",
	L"__UMI_CONN__PADS_CONNECTION_SERVER_BIND",
	L"__UMI_CONN__PADS_CONNECTION_FAST_BIND"
};

LPCWSTR	CUMIContextWrapper::s_aConnectionPropListNames[MAXNUM_CONNECTION_NAMES] = {
	L"__TIMEOUT",
	L"__USERID",
	L"__PASSWORD",
	L"__SECUREDAUTHENTICATION",
	L"__PADS_CONNECTION_READONLYSERVER",
	L"__PADS_CONNECTION_NOAUTHENTICATION",
	L"__PADS_CONNECTION_SERVER_BIND",
	L"__PADS_CONNECTION_FAST_BIND"
};

LPCWSTR	CUMIContextWrapper::s_aQueryContextNames[MAXNUM_QUERY_NAMES] = {
	L"__UMI_QUERY__SEARCHSCOPE",
	L"__UMI_QUERY__SORT_ON",
	L"__UMI_QUERY__PADS_ASYNCHRONOUS",
	L"__UMI_QUERY__PADS_DEREF_ALIASES",
	L"__UMI_QUERY__PADS_SIZE_LIMIT",
	L"__UMI_QUERY__PADS_TIME_LIMIT",
	L"__UMI_QUERY__PADS_ATTRIBTYPES_ONLY",
	L"__UMI_QUERY__PADS_TIMEOUT",
	L"__UMI_QUERY__PADS_PAGESIZE",
	L"__UMI_QUERY__PADS_PAGED_TIME_LIMIT",
	L"__UMI_QUERY__PADS_CHASE_REFERRALS",
	L"__UMI_QUERY__PADS_CASH_RESULT",
	L"__UMI_QUERY__PADS_TOMBSTONE",
	L"__UMI_QUERY__PADS_FILTER",
	L"__UMI_QUERY__PADS_ATTRIBUTES"
};

LPCWSTR	s_aQueryPropListNames[MAXNUM_QUERY_NAMES] = {
	L"__SEARCHSCOPE",
	L"__SORT_ON",
	L"__PADS_ASYNCHRONOUS",
	L"__PADS_DEREF_ALIASES",
	L"__PADS_SIZE_LIMIT",
	L"__PADS_TIME_LIMIT",
	L"__PADS_ATTRIBTYPES_ONLY",
	L"__PADS_TIMEOUT",
	L"__PADS_PAGESIZE",
	L"__PADS_PAGED_TIME_LIMIT",
	L"__PADS_CHASE_REFERRALS",
	L"__PADS_CASH_RESULT",
	L"__PADS_TOMBSTONE",
	L"__PADS_FILTER",
	L"__PADS_ATTRIBUTES"
};

//***************************************************************************
//
//  CUMIContextWrapper::CUMIContextWrapper
//
//***************************************************************************
// ok
CUMIContextWrapper::CUMIContextWrapper( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWbemUMIContextWrapper( this )
{
}
    
//***************************************************************************
//
//  CUMIContextWrapper::~CUMIContextWrapper
//
//***************************************************************************
// ok
CUMIContextWrapper::~CUMIContextWrapper()
{
}

void* CUMIContextWrapper::GetInterface(REFIID riid)
{
	if ( riid == IID_IUnknown || riid == IID__IWbemUMIContextWrapper )
	{
		return &m_XWbemUMIContextWrapper;
	}

    return NULL;
}

/* IWbemClassObject methods */

// Sets the specified System Properties on a connection object
STDMETHODIMP CUMIContextWrapper::XWbemUMIContextWrapper::SetConnectionProps( long lFlags, IWbemContext* pContext, IUnknown* pUnk )
{
	return m_pObject->SetConnectionProps( lFlags, pContext, pUnk );
}

// Sets the specified System Properties on a UMI Query object
STDMETHODIMP CUMIContextWrapper::XWbemUMIContextWrapper::SetQueryProps( long lFlags, IWbemContext* pContext, IUnknown* pUnk )
{
	return m_pObject->SetQueryProps( lFlags, pContext, pUnk );
}

// Walks the list of names in a context searching for UMI filter names, and sets the matches in the pUnk
HRESULT CUMIContextWrapper::XWbemUMIContextWrapper::SetPropertyListProps( long lFlags, LPCWSTR pwszName, IWbemContext* pContext, IUnknown* pUnk )
{
	return m_pObject->SetPropertyListProps( lFlags, pwszName, pContext, pUnk );
}

// This is the actual implementation

/* _IWbemUMIContextWrapper methods */

HRESULT CUMIContextWrapper::SetConnectionProps( long lFlags, IWbemContext* pContext, IUnknown* pUnk )
{
	return SetPropertyListProps( lFlags, L"CONN", pContext, pUnk );
}

HRESULT CUMIContextWrapper::SetQueryProps( long lFlags, IWbemContext* pContext, IUnknown* pUnk )
{
	return SetPropertyListProps( lFlags, L"QUERY", pContext, pUnk );
}

HRESULT CUMIContextWrapper::SetPropertyListProps( long lFlags, LPCWSTR pwszName, IWbemContext* pContext, IUnknown* pUnk )
{
	// Check for bad params
	if ( 0L != lFlags || NULL == pUnk || NULL == pwszName )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Assume that this is okay
	if ( NULL == pContext )
	{
		return WBEM_S_NO_ERROR;
	}

	IUmiPropList*	pPropList = NULL;

	HRESULT	hr = GetPropertyList( pUnk, &pPropList );
	CReleaseMe	rm( pPropList );

	if ( SUCCEEDED( hr ) )
	{

		LPWSTR	pwszStartName = new WCHAR[wcslen( L"__UMI_" ) + wcslen( pwszName ) + 3];
		CVectorDeleteMe<WCHAR>	vdm( pwszStartName );

		if ( NULL != pwszName )
		{
			// String to look for
			swprintf( pwszStartName, L"__UMI_%s_", pwszName );
			int	nNumChars = wcslen( pwszStartName );

			SAFEARRAY*	psa;

			hr = pContext->GetNames( 0, &psa );

			if ( SUCCEEDED( hr ) )
			{
				// Acquire the array
				CSafeArray	SA( psa, VT_BSTR, CSafeArray::auto_delete | CSafeArray::bind );

				for( int x = 0; SUCCEEDED( hr ) && x < SA.Size(); x++ )
				{
					BSTR	bstrName = SA.GetBSTRAt( x );
					CSysFreeMe	sfm( bstrName );

					if ( NULL != bstrName )
					{
						// We found a string that matches our criteria
						if ( _wcsnicmp( bstrName, pwszStartName, nNumChars ) == 0 && wcslen( bstrName ) > nNumChars )
						{
							LPCWSTR	pwszPropName = ( (LPWSTR) bstrName ) + nNumChars;

							hr = SetInterfaceProperty( pContext, pPropList, bstrName, pwszPropName );
						}

					}
					else
					{
						hr = WBEM_S_NO_ERROR;
					}

				}	// For enum array

			}	// If we got the names

		}	// If we allocated a name buffer
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;	
		}

	}	// If got property list

	return hr;
}

HRESULT	CUMIContextWrapper::GetPropertyList( IUnknown* pUnk, IUmiPropList** ppPropList )
{
	IUmiBaseObject*	pUmiBaseObj = NULL;

	HRESULT	hr = pUnk->QueryInterface( IID_IUmiBaseObject, (void**) &pUmiBaseObj );
	CReleaseMe	rmbo( pUmiBaseObj );

	if ( SUCCEEDED( hr ) )
	{
		hr = pUmiBaseObj->GetInterfacePropList( 0L, ppPropList );
	}

	return hr;
}

HRESULT	CUMIContextWrapper::SetInterfaceProperty( IWbemContext* pContext, IUmiPropList* pPropList, LPCWSTR pwszContextName,
												 LPCWSTR pwszPropListName )
{
	VARIANT	v;
	VariantInit( &v );

	HRESULT	hr = pContext->GetValue( pwszContextName, 0L, &v );
	CClearMe	cm(&v);

	if ( SUCCEEDED( hr ) )
	{
		CType	type = CType::VARTYPEToType(V_VT( &v ));
		ULONG umiType = CUmiValue::CIMTYPEToUmiType( type );

		// Convert to a property array and extract the value as a
		// VARIANT.

		CUmiPropertyArray	umiPropArray;

		hr = umiPropArray.Add( umiType, UMI_OPERATION_UPDATE, pwszPropListName, 0L, NULL, FALSE );

		if ( SUCCEEDED( hr ) )
		{
			CUmiProperty*	pActualProp = NULL;

			hr = umiPropArray.GetAt( 0L, &pActualProp );

			if ( SUCCEEDED( hr ) )
			{
				hr = pActualProp->SetFromVariant( &v, umiType );

				if ( SUCCEEDED( hr ) )
				{
					UMI_PROPERTY_VALUES*	pPropValues;

					// We will want the data structures filled out, and we will take care of
					// calling Delete on the data when we are done
					hr = umiPropArray.Export( &pPropValues );

					if ( SUCCEEDED( hr ) )
					{
						hr = pPropList->Put( pwszPropListName, 0, pPropValues );
						umiPropArray.Delete( pPropValues );
					}

				}	// If set the value

			}	// IF got the prop

		}	// IF added property

	}
	else if ( WBEM_E_NOT_FOUND == hr )
	{
		hr = WBEM_S_NO_ERROR;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umictxt.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMICTXT.H

Abstract:

  CUmiObjectWrapper Definition.

  Standard definition for _IWbemUMIObjectWrapper.

History:

  17-Apr-2000	sanjes    Created.

--*/

#ifndef _UMICTXT_H_
#define _UMICTXT_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include "umi.h"

#define	MAXNUM_CONNECTION_NAMES	8
#define	MAXNUM_QUERY_NAMES		15

//***************************************************************************
//
//  class CUMIContextWrapper
//
//  Implementation of _IWbemUMIContextWrapper Interface
//
//***************************************************************************

class COREPROX_POLARITY CUMIContextWrapper : public CUnk
{
protected:
	static	LPCWSTR	s_aConnectionContextNames[MAXNUM_CONNECTION_NAMES];
	static	LPCWSTR	s_aConnectionPropListNames[MAXNUM_CONNECTION_NAMES];
	static	LPCWSTR	s_aQueryContextNames[MAXNUM_QUERY_NAMES];
	static	LPCWSTR	s_aQueryPropListNames[MAXNUM_QUERY_NAMES];

public:

    CUMIContextWrapper(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CUMIContextWrapper(); 

	IUmiObject*	GetUmiObject( void );

    class COREPROX_POLARITY XWbemUMIContextWrapper : public CImpl<_IWbemUMIContextWrapper, CUMIContextWrapper>
    {
    public:
        XWbemUMIContextWrapper(CUMIContextWrapper* pObject) : 
            CImpl<_IWbemUMIContextWrapper, CUMIContextWrapper>(pObject)
        {}
		
		STDMETHOD(SetConnectionProps)( long lFlags, IWbemContext* pContext,	IUnknown* pUnk );
		// Sets the specified System Properties on a connection object

		STDMETHOD(SetQueryProps)( long lFlags, IWbemContext* pContext, IUnknown* pUnk );
		// Sets the specified System Properties on a UMI Query object

		STDMETHOD(SetPropertyListProps)( long lFlags, LPCWSTR pwszName, IWbemContext* pContext, IUnknown* pUnk );
		// Walks the list of names in a context searching for UMI filter names, and sets the matches in the pUnk

    } m_XWbemUMIContextWrapper;
    friend XWbemUMIContextWrapper;

    /* _IWbemUMIContextWrapper methods */
	virtual HRESULT SetConnectionProps( long lFlags, IWbemContext* pContext,	IUnknown* pUnk );
	// Sets the specified System Properties on a connection object

	virtual HRESULT SetQueryProps( long lFlags, IWbemContext* pContext, IUnknown* pUnk );
	// Sets the specified System Properties on a UMI Query object

	virtual HRESULT SetPropertyListProps( long lFlags, LPCWSTR pwszName, IWbemContext* pContext, IUnknown* pUnk );
	// Walks the list of names in a context searching for UMI filter names, and sets the matches in the pUnk

protected:

    void* GetInterface(REFIID riid);

	HRESULT	SetInterfaceProperty( IWbemContext* pContext, IUmiPropList* pPropList, LPCWSTR pwszContextName, LPCWSTR pwszPropListName );
	HRESULT	GetPropertyList( IUnknown* pUnk, IUmiPropList** ppPropList );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umienumprop.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMIENUMPROP.H

Abstract:

  CUmiEnumPropData Definition.

  Property enumeration helper

History:

  21-May-2000	sanjes    Created.

--*/

#ifndef _UMIENUMPROP_H_
#define _UMIENUMPROP_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include "umi.h"
#include "umischm.h"
#include "umisysprop.h"

#define	UMIWRAP_INVALID_INDEX	(-2)
#define	UMIWRAP_START_INDEX		(-1)

//***************************************************************************
//
//  class CUmiPropEnumData
//
//  Property enumeration helper
//
//***************************************************************************

class COREPROX_POLARITY CUmiPropEnumData
{
private:
	long				m_lPropIndex;
	long				m_lEnumFlags;
	CUmiPropertyArray*	m_pSysPropArray;
	UMI_PROPERTY_VALUES*	m_pUmiSysProperties;
	CUMISystemProperties*	m_pUmiSystemProps;
	CUMISchemaWrapper*	m_pSchema;
	IUmiObject*			m_pUMIObj;
	UINT				m_nNumNonSystemProps;
	UINT				m_nNumSystemProps;

public:
	CUmiPropEnumData() : m_lPropIndex( UMIWRAP_INVALID_INDEX ),	m_lEnumFlags( 0L ), m_pSysPropArray( NULL ),
		m_pUmiSysProperties( NULL ), m_pSchema( NULL ), m_pUMIObj( NULL ), m_nNumNonSystemProps( 0 ), m_pUmiSystemProps( NULL ),
		m_nNumSystemProps( 0 )
	{};
	~CUmiPropEnumData()
	{};

	HRESULT BeginEnumeration( long lEnumFlags, IUmiObject* pUMIObj, CUMISchemaWrapper* pSchema, CUMISystemProperties* pSysProps );
	HRESULT Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType, long* plFlavor );
	HRESULT EndEnumeration();

protected:

	HRESULT GetPropertyInfo( long lIndex, LPCWSTR* pwszName, BSTR* pName, CIMTYPE* pctType, long* plFlavor, IUmiPropList** ppPropList );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umienumprop.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMIENUMPROP.CPP

Abstract:

  CUmiEnumPropData Definition.

  Property enumeration helper

History:

  21-May-2000	sanjes    Created.

--*/


#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umiwrap.h"
#include <corex.h>
#include "strutils.h"
#include "umiprop.h"
#include "umienumprop.h"

// Enumeration helpers - caller is responsible for thread safety
HRESULT CUmiPropEnumData::BeginEnumeration( long lEnumFlags, IUmiObject* pUMIObj, CUMISchemaWrapper* pSchema,
															  CUMISystemProperties* pSysProps )
{
	try
	{

		HRESULT	hr = WBEM_S_NO_ERROR;

		// All we really support are the origin flags
        long lOriginFlags = lEnumFlags & WBEM_MASK_CONDITION_ORIGIN;
		long lClassFlags = lEnumFlags & WBEM_MASK_CLASS_CONDITION;

        BOOL bKeysOnly = lEnumFlags & WBEM_FLAG_KEYS_ONLY;
        BOOL bRefsOnly = lEnumFlags & WBEM_FLAG_REFS_ONLY;

		// We allow CLASS Flags only on classes
		if( lClassFlags || bKeysOnly | bRefsOnly )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        if( lEnumFlags & ~WBEM_MASK_CONDITION_ORIGIN & ~WBEM_FLAG_KEYS_ONLY &
                ~WBEM_FLAG_REFS_ONLY & ~WBEM_MASK_CLASS_CONDITION )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

		if ( UMIWRAP_INVALID_INDEX == m_lPropIndex )
		{
			// Hang onto our helpers
			m_pUMIObj = pUMIObj;
			m_pUMIObj->AddRef();

			m_pSchema = pSchema;
			m_pUmiSystemProps = pSysProps;

			// Calculate the number of System Properties
			if (	lOriginFlags != WBEM_FLAG_NONSYSTEM_ONLY	&&
					lOriginFlags != WBEM_FLAG_LOCAL_ONLY		&&
					lOriginFlags != WBEM_FLAG_PROPAGATED_ONLY )
			{

				m_nNumSystemProps = m_pUmiSystemProps->GetNumProperties();
			}	// If we need system properties
			else
			{
				m_nNumSystemProps = 0;
			}

			// Calculate the number of non-system properties
			if ( lOriginFlags != WBEM_FLAG_SYSTEM_ONLY )
			{

				m_nNumNonSystemProps = m_pSchema->GetNumProperties();
			}	// If we need system properties
			else
			{
				m_nNumNonSystemProps = 0;
			}

			
			// Cleanup if we beefed
			if ( FAILED( hr ) )
			{
				EndEnumeration();
			}
			else
			{
				m_lPropIndex = UMIWRAP_START_INDEX;
				m_lEnumFlags = lEnumFlags;
			}

		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT CUmiPropEnumData::Next( long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType, long* plFlavor )
{
	try
	{

		HRESULT	hr = WBEM_S_NO_ERROR;

		if ( m_lPropIndex >= UMIWRAP_START_INDEX )
		{

			// The index should be less than the size of both arrays combined
			long	lTotalSize = m_nNumSystemProps + m_nNumNonSystemProps;

			if ( m_lPropIndex < lTotalSize && 
				++m_lPropIndex < lTotalSize )
			{
				// If a system property, ask the class for it.
				if ( m_lPropIndex < m_nNumSystemProps )
				{
					return m_pUmiSystemProps->GetProperty( m_lPropIndex, pName, pctType, pVal, plFlavor );
				}

				IUmiPropList*			pPropList = NULL;
				CUmiProperty*			pProp = NULL;
				LPCWSTR					pwszPropName = NULL;
				CIMTYPE					ctPropInfo = CIM_ILLEGAL;

				// Get the property info
				hr = GetPropertyInfo( m_lPropIndex, &pwszPropName, pName, &ctPropInfo, plFlavor, &pPropList );
				
				CReleaseMe	rm(pPropList);

				// Store this value if necessary at this time so we don't have to add
				// a bunch of special case logic below.
				if ( NULL != pctType )
				{
					*pctType = ctPropInfo;
				}

				// We always come through for values
				if ( SUCCEEDED( hr ) &&
					( NULL != pVal  ) )
				{
					UMI_PROPERTY_VALUES*	pValues = NULL;

					// Provider cache always takes precedence
					hr = pPropList->Get( pwszPropName, UMI_FLAG_PROVIDER_CACHE, &pValues );

					if ( SUCCEEDED( hr ) )
					{
						// Now place the value in our class so we can coerce it to
						// a variant
						CUmiPropertyArray	umiPropArray;

						hr = umiPropArray.Set( pValues );

						if ( SUCCEEDED( hr ) )
						{
							CUmiProperty*	pActualProp = NULL;

							hr = umiPropArray.GetAt( 0L, &pActualProp );

							if ( SUCCEEDED( hr ) )
							{
								if ( !pActualProp->IsSynchronizationRequired() )
								{
									// Store the type if we don't really have it yet
									if ( CIM_ILLEGAL == ctPropInfo )
									{
										ctPropInfo = pActualProp->GetPropertyCIMTYPE();
									}

									if ( NULL != pctType )
									{
										*pctType = ctPropInfo;
									}

									// Make sure they passed us a pVal before trying to fill it out
									if ( NULL != pVal )
									{
										hr = pActualProp->FillVariant( pVal, ( ctPropInfo & CIM_FLAG_ARRAY ) );

									}	// If we should fill out the value

								}	// IF Synchronization not required
								else
								{
									hr = WBEM_E_SYNCHRONIZATION_REQUIRED;
								}

							}	// IF got the value

						}	// IF Set Array

						pPropList->FreeMemory( 0L, pValues );
					}
					else if ( UMI_E_NOT_FOUND == hr || UMI_E_UNBOUND_OBJECT == hr )
					{
						// If the Get of a known property name failed with UMI_E_NOT_FOUND or UMI_E_UNBOUND_OBJECT
						// We will set pVal to NULL and consider this a success

						if ( NULL != pVal )
						{
							V_VT( pVal ) = VT_NULL;
						}

						hr = WBEM_S_NO_ERROR;
					}

					// Cleanup the name if appropriate
					if ( FAILED(hr) && NULL != pName )
					{
						// Cleanup if we allocated a name
						SysFreeString( *pName );
						*pName = NULL;
					}


				}	// If got basic property info

			}
			else
			{
				hr = WBEM_S_NO_MORE_DATA;
			}
		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

		return hr;

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUmiPropEnumData::EndEnumeration( void )
{
	try
	{

		// Clear out the enumeration values
		m_lPropIndex = UMIWRAP_INVALID_INDEX;

		if ( NULL != m_pUmiSysProperties )
		{
			m_pUMIObj->FreeMemory( 0L, m_pUmiSysProperties );
			m_pUmiSysProperties = NULL;
		}

		if ( NULL != m_pSysPropArray )
		{
			delete m_pSysPropArray;
			m_pSysPropArray = NULL;
		}

		if ( NULL != m_pUMIObj )
		{
			m_pUMIObj->Release();
			m_pUMIObj = NULL;
		}

		m_pSchema = NULL;

		m_nNumNonSystemProps = 0L;

		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUmiPropEnumData::GetPropertyInfo( long lIndex, LPCWSTR* pwszName, BSTR* pName, CIMTYPE* pctType,
																long* plFlavor, IUmiPropList** ppPropList )
{
	IUmiPropList*			pPropList = NULL;
	CUmiProperty*			pProp = NULL;
	LPCWSTR					pwszPropName = NULL;

	// Make sure we've got a pointer to the name
	HRESULT	hr = m_pSchema->GetPropertyName( lIndex - m_nNumSystemProps, &pwszPropName );

	if ( SUCCEEDED( hr ) )
	{

		// Get allocated Property name and type now
		hr = m_pSchema->GetProperty( lIndex - m_nNumSystemProps, pName, pctType );

		// We're reading from the object
		pPropList = m_pUMIObj;
		pPropList->AddRef();

		// It's a local property
		if ( NULL != plFlavor )
		{
			*plFlavor = WBEM_FLAVOR_ORIGIN_LOCAL;
		}

	}	// IF GetPropertyName

	// Store the property name as needed
	if ( NULL != pwszName )
	{
		*pwszName = pwszPropName;
	}

	// Handle the proplist - cleanup as required
	if ( NULL != ppPropList )
	{
		// Already AddRef'd
		*ppPropList = pPropList;
	}
	else
	{
		pPropList->Release();
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umierobj.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIEROBJ.CPP

Abstract:

  CUMIErrorObject Definition.

  Standard definition for _IUMIErrorObject.

History:

  18-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umierobj.h"
#include <corex.h>
#include "strutils.h"
#include "arrtempl.h"

//***************************************************************************
//
//  CUMIErrorObject::~CUMIErrorObject
//
//***************************************************************************
// ok
CUMIErrorObject::CUMIErrorObject( CLifeControl* pControl, IUnknown* pOuter )
:	CWmiErrorObject( pControl, pOuter ),
	m_XUMIErrorObject( this )
{
	ZeroMemory( &m_Guid, sizeof( &m_Guid ) );
	ObjectCreated( OBJECT_TYPE_FREEFORM_OBJ, this );
}
    
//***************************************************************************
//
//  CUMIErrorObject::~CUMIErrorObject
//
//***************************************************************************
// ok
CUMIErrorObject::~CUMIErrorObject()
{
	ObjectDestroyed( OBJECT_TYPE_FREEFORM_OBJ, this );
}


CWmiObjectWrapper* CUMIErrorObject::CreateNewWrapper( BOOL fClone )
{
	CUMIErrorObject*	pNewObj = new CUMIErrorObject( m_pControl, m_pOuter );

	if ( NULL != pNewObj )
	{
		if ( !SUCCEEDED( pNewObj->Copy( *this ) ) )
		{
			delete pNewObj;
			pNewObj = NULL;
		}
	}

	return pNewObj;
}

// Copy the property bags
HRESULT CUMIErrorObject::Copy( const CUMIErrorObject& source )
{
	return WBEM_S_NO_ERROR;
}

/*	IUnknown Methods */

void* CUMIErrorObject::GetInterface(REFIID riid)
{
	if ( riid == IID_IUnknown || riid == IID__IUmiErrorObject )
	{
		return &m_XUMIErrorObject;
	}
	else if ( riid == IID__IWmiObject )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID__IWmiObjectAccessEx )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IWbemObjectAccess )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IWbemClassObject )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IMarshal )
	{
		return &m_XObjectMarshal;
	}
	else if ( riid == IID_IUmiPropList )
	{
		return &m_XUmiPropList;
	}
    return NULL;
}

/*_IUMIErrorObject Pass-thrus */
// Specifies a property origin (in case we have properties originating in classes
// which we know nothing about).
STDMETHODIMP CUMIErrorObject::XUMIErrorObject::SetExtendedStatus( GUID* pGuidSource, IUnknown* pUnk, LPCWSTR pwszDescription, LPCWSTR pwszOperation,
				LPCWSTR pwszParameterInfo, LPCWSTR pwszProviderName )
{
	//Pass through to the wrapper
	return m_pObject->SetExtendedStatus( pGuidSource, pUnk, pwszDescription, pwszOperation, pwszParameterInfo, pwszProviderName );
}

// Specifies a method origin (in case we have methods originating in classes
// which we know nothing about).
HRESULT CUMIErrorObject::SetExtendedStatus( GUID* pGuidSource, IUnknown* pUnk, LPCWSTR pwszDescription, LPCWSTR pwszOperation,
				LPCWSTR pwszParameterInfo, LPCWSTR pwszProviderName )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	CLock	lock(this);

	// Get the base object
	IUmiBaseObject*	pBaseObject = NULL;

	hr = pUnk->QueryInterface( IID_IUmiBaseObject, (void**) &pBaseObject );
	CReleaseMe	rm( pBaseObject );

	if ( SUCCEEDED( hr ) )
	{
		// Get the last status and setup the error object
		DWORD	dwLastStatus = 0;

		hr = pBaseObject->GetLastStatus( 0L, &dwLastStatus, IID_IUnknown, NULL );

		if ( SUCCEEDED( hr ) )
		{
			hr = SetErrorInfo( pGuidSource, 0, NULL, NULL, pwszDescription, pwszOperation, pwszParameterInfo, pwszProviderName, dwLastStatus );
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umierobj.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIEROBJ.H

Abstract:

  CUMIErrorObject Definition.

  Standard definition for _IUMIErrorObject.

History:

  18-Apr-2000	sanjes    Created.

--*/

#ifndef _UMIERROBJ_H_
#define _UMIERROBJ_H_

#include "corepol.h"
#include <arena.h>
#include "wrapobj.h"
#include "wmierobj.h"

//***************************************************************************
//
//  class CUMIErrorObject
//
//  Implementation of _IUMIErrorObject Interface
//
//***************************************************************************

class COREPROX_POLARITY CUMIErrorObject : public CWmiErrorObject
{

public:

	GUID	m_Guid;
	DWORD	m_dwHelpContext;
	LPWSTR	m_pwszHelpFile;
	LPWSTR	m_pwszSource;

    CUMIErrorObject(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CUMIErrorObject(); 

	// _IUMIErrorObject Methods

    class COREPROX_POLARITY XUMIErrorObject : public CImpl<_IUmiErrorObject, CUMIErrorObject>
    {
    public:
        XUMIErrorObject(CUMIErrorObject* pObject) : 
            CImpl<_IUmiErrorObject, CUMIErrorObject>(pObject)
        {}

		STDMETHOD(SetExtendedStatus)( GUID* pGuidSource, IUnknown* pUnk, LPCWSTR pwszDescription, LPCWSTR pwszOperation,
				LPCWSTR pwszParameterInfo, LPCWSTR pwzProviderName );

    } m_XUMIErrorObject;
    friend XUMIErrorObject;
	
	// Sets the actual error info values for the object.
	virtual HRESULT SetExtendedStatus( GUID* pGuidSource, IUnknown* pUnk, LPCWSTR pwszDescription, LPCWSTR pwszOperation,
				LPCWSTR pwszParameterInfo, LPCWSTR pwzProviderName );

public:
	
	// Creates a new wrapper object to wrap any objects we may return
	CWmiObjectWrapper*	CreateNewWrapper( BOOL fClone );

protected:
    void* GetInterface(REFIID riid);

	HRESULT Copy( const CUMIErrorObject& sourceobj );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiprop.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIPROP.CPP

Abstract:

  CUmiProperty implementation.

  Implements UMI Helper classes.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wrapobj.h"
#include <corex.h>
#include "umiprop.h"

//***************************************************************************
//
//  CUmiProperty::~CUmiProperty
//
//***************************************************************************
// ok
CUmiProperty::CUmiProperty( UMI_TYPE uType, ULONG uOperationType, LPCWSTR pszPropName,
							ULONG uNumValues, LPVOID pvData, BOOL fAcquire )
:	CUmiValue( uType, uNumValues, pvData, fAcquire ),
	m_uPropertyType( uType ),
	m_uOperationType( uOperationType ),
	m_pszPropertyName( NULL )
{
	// Finally, set the property name as appropriate

	if ( FAILED( SetPropertyName( pszPropName, fAcquire ) ) )
	{
		throw CX_MemoryException();
	}
}

//***************************************************************************
//
//  CUmiProperty::~CUmiProperty
//
//***************************************************************************
// ok
CUmiProperty::~CUmiProperty()
{
}

// Frees any memory we may have allocated
void CUmiProperty::Clear( void )
{
	// Dump the property name
	ClearPropertyName();
	m_uPropertyType = UMI_TYPE_NULL;
	m_uOperationType = UMI_OPERATION_NONE;

	// Now clear the base class
	CUmiValue::Clear();
}

// Sets us from a raw property value
HRESULT CUmiProperty::Set( PUMI_PROPERTY pUmiProperty, BOOL fAcquire )
{
	// Clear us out
	Clear();

	HRESULT hr = SetRaw( pUmiProperty->uCount, pUmiProperty->pUMIValue, pUmiProperty->uType, fAcquire );

	if ( SUCCEEDED( hr ) )
	{
		hr = SetPropertyName( pUmiProperty->pszPropertyName, fAcquire );

		if ( SUCCEEDED( hr ) )
		{
			m_uPropertyType = pUmiProperty->uType;
			m_uOperationType = pUmiProperty->uOperationType;
		}
	}

	return hr;
}

void CUmiProperty::ClearPropertyName( void )
{
	// First if m_fCanDelete is TRUE delete the name first
	if ( m_fCanDelete )
	{
		// Finally, if m_pValue is not pointing at the local value, we'll tank
		// that as well
		if ( m_pszPropertyName != NULL )
		{
			delete [] m_pszPropertyName;
		}
	}

	// Reset the member data
	m_pszPropertyName = NULL;
}

// Helper function to set values in the proper place and perform an
HRESULT CUmiProperty::SetPropertyName( LPCWSTR pszPropertyName, BOOL fAcquire )
{

	// What about 0 Length arrays?
	if ( !fAcquire )
	{
		if ( NULL != pszPropertyName )
		{
			LPWSTR pwszTemp = new WCHAR[wcslen(pszPropertyName)+1];

			if ( NULL == pwszTemp )
			{
				return WBEM_E_OUT_OF_MEMORY;
			}

			wcscpy( pwszTemp, pszPropertyName );

			pszPropertyName = pwszTemp;
		}

	}

	ClearPropertyName();
	m_pszPropertyName = (LPWSTR) pszPropertyName;

	return WBEM_S_NO_ERROR;
}

// Helper function that sets the propery type
void CUmiProperty::SetPropertyType( UMI_TYPE umiType )
{

	// First, clear underlying type data, then set the
	// property type.  This way, we'll be in sync.

	CUmiValue::Clear();
	m_uPropertyType = umiType;
}

// Exports the data back out
HRESULT CUmiProperty::Export( PUMI_PROPERTY pProperty )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// First copy the basic values
	pProperty->uType = m_uPropertyType;
	pProperty->uCount = m_uNumValues;
	pProperty->uOperationType = m_uOperationType;
	pProperty->pszPropertyName = m_pszPropertyName;

	// See if the actual value is NULL or not
	if ( UMI_TYPE_NULL == m_uType )
	{
		// For NULL properties we ALWAYS set to NULL everything ( pointers, count, type, etc. )
		pProperty->uType = UMI_TYPE_NULL;
		pProperty->uCount = 0;
		pProperty->pUMIValue = NULL;
	}
	else
	{
		// Oops, we need to allocate a buffer to hold the value, since we're actually pointing
		// to a piece of internal data
		if ( m_pValue == &m_singleValue )
		{
			pProperty->pUMIValue = new UMI_VALUE;

			if ( NULL != pProperty->pUMIValue )
			{
				CopyMemory( pProperty->pUMIValue, m_pValue, CUmiValue::Size( pProperty->uType ) );
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else
		{
			pProperty->pUMIValue = m_pValue;
		}
	}

	return hr;
}

CIMTYPE CUmiProperty::GetPropertyCIMTYPE( void )
{
	CIMTYPE ct = UmiTypeToCIMTYPE( m_uPropertyType );

	// OCTET String is ALWAYS an array
	if ( ( 1 != m_uNumValues && UMI_TYPE_NULL != m_uType ) || UMI_TYPE_OCTETSTRING == m_uPropertyType )
	{
		ct |= CIM_FLAG_ARRAY;
	}

	return ct;
}

// Property Array Helper Class
CUmiPropertyArray::CUmiPropertyArray( void )
: m_UmiPropertyArray()
{
}

CUmiPropertyArray::~CUmiPropertyArray( void )
{
}

// Allocates and adds a Singleton property to the array
HRESULT CUmiPropertyArray::Add( LPCWSTR pszPropName, CIMTYPE ct, CVar* pVar )
{
	HRESULT	hr = WBEM_S_NO_ERROR;
	UMI_TYPE umiType = CUmiValue::CIMTYPEToUmiType( ct );

	try
	{
		CUmiProperty*	pNewProp = new CUmiProperty( umiType, UMI_OPERATION_NONE, pszPropName );
													
		if ( NULL != pNewProp )
		{
			// Now we need to set the value, unless it's NULL.
			if ( !pVar->IsNull() )
			{
				hr = pNewProp->SetRaw( 1, pVar->GetRawData(), umiType, FALSE );
			}

			// Finally add it into the array
			if ( SUCCEEDED( hr ) )
			{
				hr = Add( pNewProp );
			}

			if ( FAILED( hr ) )
			{
				delete pNewProp;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	catch(CX_MemoryException)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_FAILED;
	}

	return hr;

}

// Allocates and adds an Array property to the array
HRESULT CUmiPropertyArray::Add( LPCWSTR pszPropName, CIMTYPE ct, _IWmiArray* pArray )
{
	HRESULT	hr = WBEM_S_NO_ERROR;
	UMI_TYPE umiType = CUmiValue::CIMTYPEToUmiType( ct );

	try
	{
		CUmiProperty*	pNewProp = new CUmiProperty( umiType | UMI_TYPE_ARRAY_FLAG, UMI_OPERATION_NONE, pszPropName );
													
		if ( NULL != pNewProp )
		{
			ULONG	uNumElements = 0L;
			ULONG	uBuffSize = 0L;

			hr = pArray->GetAt( 0L, 0L, WMIARRAY_FLAG_ALLELEMENTS, 0L, &uNumElements, &uBuffSize, NULL );

			if ( SUCCEEDED( hr ) )
			{
				LPBYTE	pData = new BYTE[uBuffSize];

				if ( NULL != pData )
				{
					ULONG	uNumReturned, uBuffSizeUsed;

					hr = pArray->GetAt( 0L, 0L, WMIARRAY_FLAG_ALLELEMENTS, 0L, &uNumReturned, &uBuffSizeUsed, pData );

					// Now we need to get the array into the value
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}	// IF GetAt succeeded

			// Finally add it into the array
			if ( SUCCEEDED( hr ) )
			{
				hr = Add( pNewProp );
			}

			if ( FAILED( hr ) )
			{
				delete pNewProp;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	catch(CX_MemoryException)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_FAILED;
	}

	return hr;

}

// Allocates and adds a property to the array
HRESULT CUmiPropertyArray::Add( UMI_TYPE uType, ULONG uOperationType, LPCWSTR pszPropName,
							ULONG uNumValues, LPVOID pvData, BOOL fAcquire )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		CUmiProperty*	pNewProp = new CUmiProperty( uType, uOperationType, pszPropName,
													uNumValues, pvData, fAcquire );

		if ( NULL != pNewProp )
		{
			hr = Add( pNewProp );

			if ( FAILED( hr ) )
			{
				delete pNewProp;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	catch(CX_MemoryException)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

// Adds a new property to the array
HRESULT CUmiPropertyArray::Add( CUmiProperty* pUmiProperty )
{
	if ( m_UmiPropertyArray.Add( pUmiProperty ) < 0 )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	
	return WBEM_S_NO_ERROR;
}

// Removes a property from the array
HRESULT CUmiPropertyArray::RemoveAt( ULONG uIndex )
{
	if ( uIndex >= m_UmiPropertyArray.GetSize() )
	{
		return WBEM_E_NOT_FOUND;
	}

	m_UmiPropertyArray.RemoveAt( uIndex );
	return WBEM_S_NO_ERROR;
}

// Retrieves a property from the array
HRESULT CUmiPropertyArray::GetAt( ULONG uIndex, CUmiProperty** ppProperty )
{
	if ( uIndex >= m_UmiPropertyArray.GetSize() )
	{
		return WBEM_E_NOT_FOUND;
	}

	*ppProperty = m_UmiPropertyArray.GetAt( uIndex );
	return WBEM_S_NO_ERROR;
}

// Retrieves a property from the array
HRESULT CUmiPropertyArray::Get( LPCWSTR pwszPropName, CUmiProperty** ppProperty )
{
	CUmiProperty*	pProp = NULL;

	for ( ULONG uIndex = 0; uIndex < m_UmiPropertyArray.GetSize(); uIndex++ )
	{
		pProp = m_UmiPropertyArray.GetAt( uIndex );

		if ( wbem_wcsicmp( pwszPropName, pProp->GetPropertyName() ) == 0 )
		{
			*ppProperty = pProp;
			return WBEM_S_NO_ERROR;
		}
	}

	return WBEM_E_NOT_FOUND;
}

// Sets the array using a property values structure
HRESULT CUmiPropertyArray::Set( PUMI_PROPERTY_VALUES pPropertyValues, BOOL fAcquire, BOOL fCanDelete )
{
	// Don't go any further if we got a NULL pointer
	if ( NULL == pPropertyValues )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	// Clear the array first
	m_UmiPropertyArray.RemoveAll();

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Now we'll walk the property values and initialize underlying data
	for ( ULONG uCtr = 0; SUCCEEDED( hr ) && uCtr < pPropertyValues->uCount; uCtr++ )
	{
		CUmiProperty*	pProperty = new CUmiProperty;

		if ( NULL != pProperty )
		{
			hr = pProperty->Set( &pPropertyValues->pPropArray[uCtr], fAcquire );
			pProperty->SetCanDelete( fCanDelete );

			if ( SUCCEEDED( hr ) )
			{
				hr = Add( pProperty );
			}

			if ( FAILED( hr ) )
			{
				delete pProperty;
			}

		}	// IF Alloc succeeded

	}	// FOR enum properties

	return hr;
}

// Walks a property values structure and cleans up any potentially allocated memory
HRESULT CUmiPropertyArray::Delete( PUMI_PROPERTY_VALUES pPropertyValues, BOOL fWalkProperties /* = TRUE */ )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// We're done
	if ( NULL == pPropertyValues )
	{
		return hr;
	}

	if ( fWalkProperties )
	{
		CUmiProperty	umiProperty;

		// Now we'll walk the property values and initialize underlying data
		for ( ULONG uCtr = 0; SUCCEEDED( hr ) && uCtr < pPropertyValues->uCount; uCtr++ )
		{
			// Acquire the value and all allocated memory will be deleted
			umiProperty.Set( &pPropertyValues->pPropArray[uCtr], TRUE );
			umiProperty.Clear();
		}

	}	// IF fWalkProperties

	// Cleanup the array as well
	if ( NULL != pPropertyValues->pPropArray )
	{
		delete pPropertyValues->pPropArray;
	}

	delete pPropertyValues;

	return hr;
}

// Helper function to export out a property array
HRESULT CUmiPropertyArray::Export( PUMI_PROPERTY_VALUES* ppValues, BOOL fCanDeleteAfterSuccess )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	PUMI_PROPERTY_VALUES pValues = new UMI_PROPERTY_VALUES;

	if ( NULL != pValues )
	{
		ULONG	uNumProperties = m_UmiPropertyArray.GetSize();

		if ( uNumProperties > 0 )
		{
			PUMI_PROPERTY pPropArray = new UMI_PROPERTY[uNumProperties];

			if ( NULL != pPropArray )
			{
				// Export all the properties
				for( ULONG uCtr = 0; SUCCEEDED( hr ) && uCtr < uNumProperties; uCtr++ )
				{
					CUmiProperty*	pProperty = m_UmiPropertyArray.GetAt( uCtr );
					hr = pProperty->Export( &pPropArray[uCtr] );
				}

				if ( SUCCEEDED( hr ) )
				{
					// IF Successful, set the can delete flag
					for( ULONG uCtr = 0; uCtr < uNumProperties; uCtr++ )
					{
						CUmiProperty*	pProperty = m_UmiPropertyArray.GetAt( uCtr );
						pProperty->SetCanDelete( fCanDeleteAfterSuccess );
					}

					// We're done
					pValues->uCount = uNumProperties;
					pValues->pPropArray = pPropArray;
					*ppValues = pValues;
				}
				else
				{
					delete [] pPropArray;
				}


			}	// IF NULL != pPropArray
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else
		{
			// We're done
			pValues->uCount = uNumProperties;
			pValues->pPropArray = NULL;
			*ppValues = pValues;
		}

		// Cleanup if necessary
		if ( FAILED(hr) )
		{
			delete pValues;
		}

	}
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

// Helper function to walk a property array and release any underlying COM pointers
void CUmiPropertyArray::ReleaseMemory( PUMI_PROPERTY_VALUES pPropertyValues )
{
	if ( NULL != pPropertyValues )
	{
		for( ULONG uCtr = 0; uCtr < pPropertyValues->uCount; uCtr++ )
		{
			if ( pPropertyValues->pPropArray[uCtr].uType == UMI_TYPE_IUNKNOWN	||
				pPropertyValues->pPropArray[uCtr].uType == UMI_TYPE_IDISPATCH )
			{
				for ( ULONG x = 0; x < pPropertyValues->pPropArray[uCtr].uType; x++ )
				{
					((IUnknown*) pPropertyValues->pPropArray[uCtr].pUMIValue->comObject[x].pInterface)->Release();
				}
			}

		}	// FOR enum values

	}	// IF NULL != pPropertyValues
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umischm.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMISCHM.CPP

Abstract:

  CUmiSchemaWrapper implementation.

  Implements a wrapper around a UMI Schema object so
  we can try and get schema information.

History:

  01-May-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umiwrap.h"
#include <corex.h>
#include "strutils.h"
#include "umiprop.h"
#include "umischm.h"

//***************************************************************************
//
//  CUMISchemaWrapper::CUMISchemaWrapper
//
//***************************************************************************
// ok
CUMISchemaWrapper::CUMISchemaWrapper( void )
:	m_pUmiObj( NULL ),
	m_pUmiSchemaObj( NULL ),
	m_pPropArray( NULL ),
	m_pUmiProperties( NULL ),
	m_fTrueSchemaObject( FALSE )
{
}
    
//***************************************************************************
//
//  CUMISchemaWrapper::~CUMISchemaWrapper
//
//***************************************************************************
// ok
CUMISchemaWrapper::~CUMISchemaWrapper()
{
	if ( NULL != m_pUmiProperties )
	{
		m_pUmiSchemaObj->FreeMemory( 0L, m_pUmiProperties );
		m_pUmiProperties = NULL;
	}

	if ( NULL != m_pPropArray )
	{
		delete m_pPropArray;
		m_pPropArray = NULL;
	}

	if ( NULL != m_pUmiSchemaObj )
	{
		m_pUmiSchemaObj->Release();
	}

	if ( NULL != m_pUmiObj )
	{
		m_pUmiObj->Release();
	}

}

// Allocates schema information
HRESULT CUMISchemaWrapper::AllocateSchemaInfo( void )
{

	HRESULT	hr = WBEM_S_NO_ERROR;

	// If we don't have a true schema object, we'll be faking things using the current object
	if ( !m_fTrueSchemaObject )
	{
		hr = m_pUmiSchemaObj->Refresh( UMI_FLAG_REFRESH_PARTIAL, 0L, NULL );
	}

	if ( SUCCEEDED( hr ) )
	{
		IUmiPropList*	pPropList = NULL;

		// If we really have a schema object, we use it's interface property list.  Otherwise,
		// we use the actual object.

		if ( m_fTrueSchemaObject )
		{
			hr = m_pUmiSchemaObj->GetInterfacePropList( 0L, &pPropList );
		}
		else
		{
			pPropList = m_pUmiSchemaObj;
			pPropList->AddRef();
		}

		CReleaseMe	rm( pPropList );

		if ( SUCCEEDED( hr ) )
		{
			ULONG	ulFlags = ( m_fTrueSchemaObject ? UMI_FLAG_GETPROPS_SCHEMA : UMI_FLAG_GETPROPS_NAMES );

			hr = pPropList->GetProps( NULL, 0, ulFlags, &m_pUmiProperties );

			if ( SUCCEEDED( hr ) )
			{
				m_pPropArray = new CUmiPropertyArray;

				if ( NULL != m_pPropArray )
				{
					hr = m_pPropArray->Set( m_pUmiProperties );
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}	// IF GetProps Succeeded

		}	// Get the property list

	}	// IF everything is okay

	return hr;

}

// Initializes our schema data, handling objects as necessary
HRESULT CUMISchemaWrapper::InitializeSchema( IUmiObject* pUmiObj )
{
	// We're already good to go, so don't worry
	if ( NULL != m_pUmiSchemaObj )
	{
		return WBEM_S_NO_ERROR;
	}

	// Our base object
	m_pUmiObj = pUmiObj;
	m_pUmiObj->AddRef();

	IUmiPropList*	pUmiPropList = NULL;

	HRESULT hr = m_pUmiObj->GetInterfacePropList( 0L, &pUmiPropList );
	CReleaseMe	rm( pUmiPropList );

	if ( SUCCEEDED( hr ) )
	{
		UMI_PROPERTY_VALUES*	pGenusValues = NULL;

		// Get the __GENUS, if this is a class object, this *is* the schema

		hr = pUmiPropList->Get( L"__GENUS", 0, &pGenusValues );

		if ( SUCCEEDED( hr ) )
		{
			if ( pGenusValues->pPropArray[0].uType == UMI_TYPE_I4 )
			{

				if ( pGenusValues->pPropArray[0].pUMIValue->lValue[0] == UMI_GENUS_INSTANCE )
				{
					// Get the "__SCHEMA" property.  If this fails, then we just use the current
					// object as the schema object

					UMI_PROPERTY_VALUES*	pSchemaValues = NULL;

					hr = pUmiPropList->Get( L"__SCHEMA", 0, &pSchemaValues );

					if ( SUCCEEDED( hr ) )
					{
						if ( pSchemaValues->pPropArray[0].uType == UMI_TYPE_IUNKNOWN )
						{
							IUnknown*	pUnk = (IUnknown*) pSchemaValues->pPropArray[0].pUMIValue->comObject[0].pInterface;

							hr = pUnk->QueryInterface( IID_IUmiObject, (void**) &m_pUmiSchemaObj );

							if ( SUCCEEDED( hr ) )
							{
								m_fTrueSchemaObject = TRUE;

								// Allocate memory to hold actual Schema Information
								hr = AllocateSchemaInfo();
							}

						}	// IF it's a COM Object
						else
						{
							hr = WBEM_E_TYPE_MISMATCH;
						}

					}	// IF Get

					// Cleanup
					pUmiPropList->FreeMemory( 0L, pSchemaValues );

					// If any of the above failed, we will just use the current object as a schema object to
					// the best of our ability.

					if ( FAILED( hr ) )
					{
						m_pUmiSchemaObj = m_pUmiObj;
						m_pUmiSchemaObj->AddRef();

						// Allocate Schema Info now.
						hr = AllocateSchemaInfo();
					}

				}
				else if ( pGenusValues->pPropArray[0].pUMIValue->lValue[0] == UMI_GENUS_CLASS )
				{
					// It's already a schema object, so no harm directly referring to it as our schema object
					m_pUmiSchemaObj = m_pUmiObj;
					m_pUmiSchemaObj->AddRef();
					m_fTrueSchemaObject = TRUE;

					// Allocate memory to hold actual Schema Information
					hr = AllocateSchemaInfo();
				}
				else
				{
					// The underlying object has no idea what it is.  We give up
					hr = WBEM_E_FAILED;
				}

			}
			else
			{
				// The underlying object has no idea what it is.  We give up
				hr = WBEM_E_FAILED;
			}

			// Cleanup
			pUmiPropList->FreeMemory( 0L, pGenusValues );

		}
		else
		{
			// The underlying object has no idea what it is.  We give up
			hr = WBEM_E_FAILED;
		}


	}	// IF GetInterfacePropList

	return hr;
}

// Number of properties
int CUMISchemaWrapper::GetNumProperties( void )
{
	if ( NULL != m_pPropArray )
	{
		return m_pPropArray->GetSize();
	}

	return 0;
}

// Returns property info
HRESULT CUMISchemaWrapper::GetProperty( int nIndex, BSTR* bstrName, CIMTYPE* pctType )
{
	// Make sure we've got info we can check against
	if ( NULL == m_pPropArray )
	{
		return WBEM_S_NO_MORE_DATA;
	}

	if ( nIndex >= m_pPropArray->GetSize() )
	{
		return WBEM_E_NOT_FOUND;
	}

	// First get the property
	CUmiProperty*			pProp = NULL;
	HRESULT	hr = m_pPropArray->GetAt( nIndex, &pProp );

	if ( SUCCEEDED( hr ) )
	{
		if ( NULL != pctType )
		{
			if ( m_fTrueSchemaObject )
			{
				*pctType = pProp->GetPropertyCIMTYPE();
			}
			else
			{
				UMI_PROPERTY_VALUES*	pValues = NULL;

				hr = m_pUmiSchemaObj->Get( pProp->GetPropertyName(), 0, &pValues );

				if ( SUCCEEDED( hr ) )
				{
					// Convert to a property array and extract the value as a
					// VARIANT.

					CUmiPropertyArray	umiPropArray;

					hr = umiPropArray.Set( pValues );

					if ( SUCCEEDED( hr ) )
					{
						CUmiProperty*	pActualProp = NULL;

						hr = umiPropArray.GetAt( 0L, &pActualProp );

						*pctType = pActualProp->GetPropertyCIMTYPE();
					}	// IF Set Array

					m_pUmiSchemaObj->FreeMemory( 0L, pValues );

				}	// IF Got a value

			}	// ELSE don't have a schema object

		}	// IF NULL != pctType

		if ( SUCCEEDED( hr ) && NULL != bstrName )
		{
			*bstrName = SysAllocString( pProp->GetPropertyName() );

			if ( NULL == *bstrName )
			{
				return WBEM_E_OUT_OF_MEMORY;
			}

		}	// IF need to get the name

	}	// IF Got At property

	return hr;

}

// Returns property info
HRESULT CUMISchemaWrapper::GetType( LPCWSTR pwszName, CIMTYPE* pctType )
{
	// Make sure we've got info we can check against
	if ( NULL == m_pPropArray )
	{
		return WBEM_E_NOT_FOUND;
	}

	// First get the property
	CUmiProperty*			pProp = NULL;
	HRESULT	hr = m_pPropArray->Get( pwszName, &pProp );

	if ( SUCCEEDED( hr ) )
	{
		if ( NULL != pctType )
		{
			if ( m_fTrueSchemaObject )
			{
				*pctType = pProp->GetPropertyCIMTYPE();
			}
			else
			{
				UMI_PROPERTY_VALUES*	pValues = NULL;

				// Cache always takes precedence
				hr = m_pUmiSchemaObj->Get( pProp->GetPropertyName(), UMI_FLAG_PROVIDER_CACHE, &pValues );

				if ( SUCCEEDED( hr ) )
				{
					// Convert to a property array and extract the value as a
					// VARIANT.

					CUmiPropertyArray	umiPropArray;

					hr = umiPropArray.Set( pValues );

					if ( SUCCEEDED( hr ) )
					{
						CUmiProperty*	pActualProp = NULL;

						hr = umiPropArray.GetAt( 0L, &pActualProp );

						*pctType = pActualProp->GetPropertyCIMTYPE();
					}	// IF Set Array

					m_pUmiSchemaObj->FreeMemory( 0L, pValues );

				}	// IF Got a value

			}	// ELSE don't have a schema object

		}	// IF NULL != pctType

	}	// IF Got At property

	return hr;

}

HRESULT CUMISchemaWrapper::GetPropertyName( int nIndex, LPCWSTR* pwszName )
{
	CUmiProperty*			pProp = NULL;
	HRESULT	hr = m_pPropArray->GetAt( nIndex, &pProp );

	if ( SUCCEEDED( hr ) )
	{
		*pwszName = pProp->GetPropertyName();
	}

	return hr;
}

// Returns property info
HRESULT CUMISchemaWrapper::GetPropertyOrigin( LPCWSTR pwszName, BSTR* pName )
{

	IUmiPropList*	pPropList = NULL;

	// The value is returned off of an interface property list
	HRESULT	hr = m_pUmiSchemaObj->GetInterfacePropList( 0L, &pPropList );
	CReleaseMe	rmProp( pPropList );

	if ( SUCCEEDED( hr ) )
	{
		UMI_PROPERTY_VALUES*	pValues = NULL;
		hr = 	pPropList->Get( pwszName, UMI_FLAG_PROPERTY_ORIGIN, &pValues );

		if ( SUCCEEDED( hr ) )
		{
			// Convert to a property array and extract the value as a
			// VARIANT.

			CUmiPropertyArray	umiPropArray;

			hr = umiPropArray.Set( pValues );

			if ( SUCCEEDED( hr ) )
			{
				CUmiProperty*	pActualProp = NULL;

				hr = umiPropArray.GetAt( 0L, &pActualProp );

				if ( pActualProp->GetPropertyType() == UMI_TYPE_LPWSTR )
				{
					*pName = SysAllocString( pActualProp->GetLPWSTR() );

					if ( NULL == *pName )
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				else
				{
					hr = WBEM_E_UNEXPECTED;
				}

			}	// IF Set Array

			// Cleanup
			pPropList->FreeMemory( 0L, pValues );

		}	// IF Get originb

	}	// IF GetInterfacePropList

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiprox.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIPROX.CPP

Abstract:

    Object Marshaling

History:

--*/

#include "precomp.h"
#include "umiprox.h"
#include "umiwrap.h"
#include "arrtempl.h"

//Used to initialize and verify datapackets
BYTE CUMIDataPacket::s_abSignature[UMI_DATAPACKET_SIZEOFSIGNATURE] = UMI_DATAPACKET_SIGNATURE;

// Signature to use when marshaling pointers across threads
extern unsigned __int64 g_ui64PointerSig;

ULONG CUMIProxy::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRef);
}

ULONG CUMIProxy::Release()
{
    long lNewRef = InterlockedDecrement(&m_lRef);
    if(lNewRef == 0)
    {
        delete this;
    }
    return lNewRef;
}

STDMETHODIMP CUMIProxy::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
    {
        AddRef();
        *ppv = (void*)(IUnknown*)(IMarshal*)this;
        return S_OK;
    }
    if(riid == IID_IMarshal)
    {
        AddRef();
        *ppv = (void*)(IMarshal*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CUMIProxy::GetUnmarshalClass(REFIID riid, void* pv, 
          DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CUMIProxy::GetMarshalSizeMax(REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CUMIProxy::MarshalInterface(IStream* pStream, REFIID riid, 
    void* pv, DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CUMIProxy::UnmarshalInterface(IStream* pStream, REFIID riid, 
                                            void** ppv)
{
	CUMIDataPacket	umiDataPacket;

	// Try to unmarshal the object.  If this succeeds, then QI for the requested interface
	_IWbemUMIObjectWrapper*	pWrapper = NULL;

	HRESULT	hres = umiDataPacket.GetObject( pStream, &pWrapper );
	CReleaseMe	rm(pWrapper);

	if ( SUCCEEDED( hres ) )
	{
		hres = pWrapper->QueryInterface(riid, ppv);
	}

    return hres;
}

STDMETHODIMP CUMIProxy::ReleaseMarshalData(IStream* pStream)
{
	CUMIDataPacket	umiDataPacket;

	// Try to unmarshal the object.  If this succeeds, then release the underlying pointer
	_IWbemUMIObjectWrapper*	pWrapper = NULL;

	HRESULT	hres = umiDataPacket.GetObject( pStream, &pWrapper );
	CReleaseMe	rm(pWrapper);

	if ( SUCCEEDED( hres ) )
	{
		pWrapper->Release();
	}

    return S_OK;
}

STDMETHODIMP CUMIProxy::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}

CUMIDataPacket::CUMIDataPacket( void )
{
};

CUMIDataPacket::~CUMIDataPacket( void )
{
};

// Initializes a data packet
HRESULT CUMIDataPacket::Init( PUMI_MARSHALPACKET_DATAPACKET pPacket, CUMIObjectWrapper* pWrapper )
{
	ZeroMemory( pPacket, sizeof( UMI_MARSHALPACKET_DATAPACKET ) );

	CopyMemory( pPacket->m_UmiPcktHdr.m_abSignature, s_abSignature, sizeof(s_abSignature) );
	pPacket->m_UmiPcktHdr.m_dwSizeOfHeader = sizeof( UMI_MARSHALPACKET_HEADER );
	pPacket->m_UmiPcktHdr.m_dwDataSize = sizeof( UMI_MARSHALPACKET_DATAPACKET ) - sizeof( UMI_MARSHALPACKET_HEADER );
	pPacket->m_UmiPcktHdr.m_bVersion = UMI_DATAPACKET_HEADER_CURRENTVERSION;

	pPacket->m_ui64PrePointerSig = g_ui64PointerSig;

	// AddRef's - Will be Released when Unmarshaled
	HRESULT	hr = pWrapper->QueryInterface( IID__IWbemUMIObjectWrapper, (void**) &pPacket->m_pUmiObjWrapper );
	pPacket->m_ui64PostPointerSig = g_ui64PointerSig;

	return hr;
}

// Validates a packet
HRESULT CUMIDataPacket::Validate( PUMI_MARSHALPACKET_DATAPACKET pPacket )
{
	HRESULT	hr = WBEM_E_FAILED;

	// Signature must match, the version must be recognized and the lengths MUST make sense
	if ( memcmp( pPacket->m_UmiPcktHdr.m_abSignature, s_abSignature, sizeof(s_abSignature) ) == 0 )
	{
		if ( UMI_DATAPACKET_HEADER_CURRENTVERSION == pPacket->m_UmiPcktHdr.m_bVersion )
		{

			if ( sizeof( UMI_MARSHALPACKET_HEADER ) == pPacket->m_UmiPcktHdr.m_dwSizeOfHeader	&&
				sizeof( UMI_MARSHALPACKET_DATAPACKET ) - sizeof( UMI_MARSHALPACKET_HEADER ) == pPacket->m_UmiPcktHdr.m_dwDataSize )
			{

				// Check the pre and post signatures
				if ( g_ui64PointerSig == pPacket->m_ui64PrePointerSig	&&
					g_ui64PointerSig == pPacket->m_ui64PostPointerSig )
				{
					hr = WBEM_S_NO_ERROR;
				}	// IF pre/post signatures match

			}	// IF Size values make sense

		}	// If version matches

	}	// IF Signature matches

	return hr;
}

// Attempts to unmarshal a data packet from a stream
HRESULT	CUMIDataPacket::GetObject( IStream* pStream, _IWbemUMIObjectWrapper** ppObj )
{
    UMI_MARSHALPACKET_DATAPACKET	datapacket;

	// Read in a data packet's size in bytes.  If it comes in, then validate the packet
    HRESULT	hr = pStream->Read((void*)&datapacket, sizeof(datapacket), NULL);

	if ( SUCCEEDED( hr ) )
	{
		hr = Validate( &datapacket );

		if ( SUCCEEDED( hr ) )
		{
			// Already AddRef'd
			*ppObj = datapacket.m_pUmiObjWrapper;
		}
	}

	return hr;
}

int CUMIDataPacket::GetMarshalSize( void )
{
	return sizeof( UMI_MARSHALPACKET_DATAPACKET );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiprox.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIPROX.H

Abstract:

    UMI Object Marshaling

History:

--*/

#ifndef __UMIPROX__H_
#define __UMIPROX__H_
#pragma warning (disable : 4786)

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include <commain.h>
#include <wbemutil.h>
#include <fastall.h>

//forward declarations
class	CUMIObjectWrapper;

class CUMIProxy : public IMarshal
{
protected:
    long m_lRef;

public:

    CUMIProxy(CLifeControl* pControl) : m_lRef(0){}

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);
};

// Then comes the signature bytes
#define	UMI_DATAPACKET_SIGNATURE	{ 0x57, 0x42, 0x45, 0x4D, 0x55, 0x4D, 0x49, 0xFF }

// We use an 8 byte signature
#define UMI_DATAPACKET_SIZEOFSIGNATURE	8

#define UMI_DATAPACKET_HEADER_CURRENTVERSION	1

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

typedef struct tagUMI_MARSHALPACKET_HEADER
{
	BYTE	m_abSignature[UMI_DATAPACKET_SIZEOFSIGNATURE];	// Set to the signature value defined above
	DWORD	m_dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	m_dwDataSize;		// Size of Data following header.
	DWORD	m_dwFlags;		// Compression, encryption, etc.
	BYTE	m_bVersion;		// Version Number of Header.  Starting Version is 1.
} UMI_MARSHALPACKET_HEADER;

typedef UMI_MARSHALPACKET_HEADER* PUMI_MARSHALPACKET_HEADER;

typedef struct tagUMI_MARSHALPACKET_DATAPACKET
{
	UMI_MARSHALPACKET_HEADER	m_UmiPcktHdr;
	unsigned __int64			m_ui64PrePointerSig;
	_IWbemUMIObjectWrapper*		m_pUmiObjWrapper;
	unsigned __int64			m_ui64PostPointerSig;
} UMI_MARSHALPACKET_DATAPACKET;

typedef UMI_MARSHALPACKET_DATAPACKET* PUMI_MARSHALPACKET_DATAPACKET;

#pragma pack( pop )

class CUMIDataPacket
{
protected:
	static BYTE s_abSignature[UMI_DATAPACKET_SIZEOFSIGNATURE];

public:
	CUMIDataPacket();
	~CUMIDataPacket();

	static int	GetMarshalSize( void );
	HRESULT		Init( PUMI_MARSHALPACKET_DATAPACKET pPacket, CUMIObjectWrapper* pWrapper );
	HRESULT		Validate( PUMI_MARSHALPACKET_DATAPACKET pPacket );
	HRESULT		GetObject( IStream* pStream, _IWbemUMIObjectWrapper** ppObj );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiqual.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMIQUAL.H

Abstract:

  CUmiQualifierWrapper Definition.

  Standard definition for IWbemQualifierSet for UMI Objects

History:

  09-May-2000	sanjes    Created.

--*/

#ifndef _UMIQUAL_H_
#define _UMIQUAL_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include "umi.h"
#include "sync.h"

#define	UMIQUAL_KEY_INDEX			(0)
#define	UMIQUAL_CIMTYPE_INDEX		(1)
#define	UMIQUAL_MAX_INDEX			(1)
#define	UMIQUAL_INVALID_INDEX		(-2)
#define	UMIQUAL_START_INDEX			(-1)

//***************************************************************************
//
//  class CUmiQualifierWrapper
//
//  Implementation of IWbemQualifier Interface
//
//***************************************************************************

class COREPROX_POLARITY CUmiQualifierWrapper : public CUnk
{
protected:
	long	m_lEnumIndex;
	BOOL	m_fKey;
	BOOL	m_fProp;
	BOOL	m_fIsClass;
	BOOL	m_ct;
	CCritSec	m_cs;
	
public:

    CUmiQualifierWrapper(CLifeControl* pControl, BOOL fIsKey = FALSE, BOOL fIsProp = FALSE,
							BOOL fIsClass = FALSE, CIMTYPE ct = CIM_EMPTY, IUnknown* pOuter = NULL);
    CUmiQualifierWrapper(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CUmiQualifierWrapper(); 

    class COREPROX_POLARITY XWbemQualifierSet : public CImpl<IWbemQualifierSet, CUmiQualifierWrapper>
    {
    public:
        XWbemQualifierSet(CUmiQualifierWrapper* pObject) : 
            CImpl<IWbemQualifierSet, CUmiQualifierWrapper>(pObject)
        {}

		/* IWbemQualifierSet methods */
		STDMETHOD(Get)( LPCWSTR Name, LONG lFlags, VARIANT *pVal, LONG *plFlavor);    
		STDMETHOD(Put)( LPCWSTR Name, VARIANT *pVal, LONG lFlavor);
		STDMETHOD(Delete)( LPCWSTR Name );
    	STDMETHOD(GetNames)( LONG lFlavor, LPSAFEARRAY *pNames);
    	STDMETHOD(BeginEnumeration)(LONG lFlags);
    	STDMETHOD(Next)( LONG lFlags, BSTR *pName, VARIANT *pVal, LONG *plFlavor);
		STDMETHOD(EndEnumeration)();

    } m_XWbemQualifierSet;
    friend XWbemQualifierSet;

protected:

    /* IWbemQualifierSet methods */
	virtual HRESULT Get( LPCWSTR Name, LONG lFlags, VARIANT *pVal, LONG *plFlavor);    
	virtual HRESULT Put( LPCWSTR Name, VARIANT *pVal, LONG lFlavor);
	virtual HRESULT Delete( LPCWSTR Name );
    virtual HRESULT GetNames( LONG lFlavor, LPSAFEARRAY *pNames);
    virtual HRESULT BeginEnumeration(LONG lFlags);
    virtual HRESULT Next( LONG lFlags, BSTR *pName, VARIANT *pVal, LONG *plFlavor);
	virtual HRESULT EndEnumeration( void );

    void* GetInterface(REFIID riid);

	HRESULT GetQualifier( LPCWSTR Name, BSTR* pName, VARIANT *pVal, LONG *plFlavor);    

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiprop.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIPROP.H

Abstract:

  CUmiProperty Definitions.

  Helper classes for UMI and WMI conversions.

History:

  6-Mar-2000	sanjes    Created.

--*/

#ifndef _UMIPROP_H_
#define _UMIPROP_H_

#include "corepol.h"
#include <arena.h>
#include "arrtempl.h"
#include "umivalue.h"

//***************************************************************************
//
//  class CUmiProperty
//
//  Helper function for UMI Types
//
//***************************************************************************

class COREPROX_POLARITY CUmiProperty : public CUmiValue
{
protected:
	UMI_TYPE	m_uPropertyType;
    ULONG		m_uOperationType;
    LPWSTR		m_pszPropertyName;

public:

    CUmiProperty( UMI_TYPE uType = UMI_TYPE_NULL, ULONG uOperationType = UMI_OPERATION_NONE,
				LPCWSTR pszPropName = NULL,	ULONG uNumValues = 0, LPVOID pvData = NULL, BOOL fAcquire = FALSE );
	~CUmiProperty(); 


	// Accessor functions
	LPCWSTR GetPropertyName( void )
	{ return m_pszPropertyName; }
	UMI_TYPE GetPropertyType( void )
	{ return m_uPropertyType; }
	ULONG GetOperationType( void )
	{ return m_uOperationType; }
	BOOL IsArray( void )
	{ return m_uPropertyType & UMI_TYPE_ARRAY_FLAG; }

	// If the operation is not one of the following, then it requires synchronization
	BOOL IsSynchronizationRequired( void )
	{ return	m_uOperationType != UMI_OPERATION_UPDATE &&
				m_uOperationType != UMI_OPERATION_EMPTY	&&
				m_uOperationType != UMI_OPERATION_NONE; }

	// Returns the property CIMTYPE
	CIMTYPE GetPropertyCIMTYPE( void );


	HRESULT Set( PUMI_PROPERTY pUmiProperty, BOOL fAcquire = FALSE );
	HRESULT SetPropertyName( LPCWSTR pwszPropertyName, BOOL fAcquire = FALSE );
	void ClearPropertyName( void );
	void SetPropertyType( UMI_TYPE uType );
	void SetOperationType( ULONG uOperationType )
	{ m_uOperationType = uOperationType; }

	// Overrides
	void Clear( void );

	// This will copy all data up and shut off the can delete flags on the underlying properties
	HRESULT Export( PUMI_PROPERTY pProperty );

};

// Workaround for import/export issues
class COREPROX_POLARITY CUmiPropValues : public CUniquePointerArray<CUmiProperty>
{
public:
	CUmiPropValues() {};
	~CUmiPropValues() {};
};

//***************************************************************************
//
//  class CUmiPropertyArray
//
//  Maintains an array of CUmiProperty objects
//
//***************************************************************************

class COREPROX_POLARITY CUmiPropertyArray
{
protected:
	CUmiPropValues	m_UmiPropertyArray;

public:

    CUmiPropertyArray();
	~CUmiPropertyArray(); 


	// Accessor functions
	int GetSize( void )
	{ return m_UmiPropertyArray.GetSize(); }

	HRESULT Set( PUMI_PROPERTY_VALUES pPropertyValues, BOOL fAcquire = TRUE, BOOL fCanDelete = FALSE );
	HRESULT Add( UMI_TYPE uType, ULONG uOperationType, LPCWSTR pszPropName, ULONG uNumValues, LPVOID pvData, BOOL fAcquire );
	HRESULT Add( CUmiProperty* pUmiProperty );
	HRESULT Add( LPCWSTR pszPropName, CIMTYPE ct, CVar* pVar );
	HRESULT Add( LPCWSTR pszPropName, CIMTYPE ct, _IWmiArray* pArray );
	HRESULT RemoveAt( ULONG uIndex );
	HRESULT GetAt( ULONG uIndex, CUmiProperty** ppProperty );
	HRESULT Get( LPCWSTR pwszPropName, CUmiProperty** ppProperty );

	// Cleanup helper
	HRESULT Delete( PUMI_PROPERTY_VALUES pPropertyValues, BOOL fWalkProperties = TRUE );

	// This will copy all data up and if successful set candelete properly
	HRESULT Export( PUMI_PROPERTY_VALUES* ppValues, BOOL fCanDeleteAfterSuccess = FALSE );

	// Helper function to walk property arrays and release any underlying COM pointers
	static void ReleaseMemory( PUMI_PROPERTY_VALUES pPropertyValues );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiqual.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMIQUAL.H

Abstract:

  CUmiQualifierWrapper Definition.

  Standard definition for IWbemQualifierSet for UMI Objects

History:

  09-May-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umiwrap.h"
#include <corex.h>
#include "strutils.h"
#include "umiqual.h"

//***************************************************************************
//
//  CUmiQualifierWrapper::CUmiQualifierWrapper
//
//***************************************************************************
// ok
CUmiQualifierWrapper::CUmiQualifierWrapper( CLifeControl* pControl, BOOL fIsKey, BOOL fIsProp, BOOL fIsClass, CIMTYPE ct, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWbemQualifierSet( this ),
	m_fKey( fIsKey ),
	m_fProp( fIsProp ),
	m_fIsClass( fIsClass ),
	m_lEnumIndex( UMIQUAL_INVALID_INDEX ),
	m_ct( ct ),
	m_cs()
{
}

CUmiQualifierWrapper::CUmiQualifierWrapper( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWbemQualifierSet( this ),
	m_fKey( FALSE ),
	m_fProp( FALSE ),
	m_fIsClass( FALSE ),
	m_lEnumIndex( UMIQUAL_INVALID_INDEX ),
	m_ct( CIM_ILLEGAL ),
	m_cs()
{
}
   
//***************************************************************************
//
//  CUmiQualifierWrapper::~CUmiQualifierWrapper
//
//***************************************************************************
// ok
CUmiQualifierWrapper::~CUmiQualifierWrapper()
{
}

void* CUmiQualifierWrapper::GetInterface(REFIID riid)
{
	if ( riid == IID_IUnknown || riid == IID_IWbemQualifierSet )
	{
		return &m_XWbemQualifierSet;
	}

    return NULL;
}

/* IWbemQualifierSet methods */

STDMETHODIMP CUmiQualifierWrapper::XWbemQualifierSet::Get( LPCWSTR Name, LONG lFlags, VARIANT *pVal, LONG *plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Get( Name, lFlags, pVal, plFlavor);
}

STDMETHODIMP CUmiQualifierWrapper::XWbemQualifierSet::Put( LPCWSTR Name, VARIANT *pVal, LONG lFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Put( Name, pVal, lFlavor);
}

STDMETHODIMP CUmiQualifierWrapper::XWbemQualifierSet::Delete( LPCWSTR Name )
{
	// Pass through to the wrapper object
	return m_pObject->Delete( Name );
}

STDMETHODIMP CUmiQualifierWrapper::XWbemQualifierSet::GetNames( LONG lFlavor, LPSAFEARRAY *pNames)
{
	// Pass through to the wrapper object
	return m_pObject->GetNames( lFlavor, pNames);
}

STDMETHODIMP CUmiQualifierWrapper::XWbemQualifierSet::BeginEnumeration(LONG lFlags)
{
	// Pass through to the wrapper object
	return m_pObject->BeginEnumeration( lFlags  );
}

STDMETHODIMP CUmiQualifierWrapper::XWbemQualifierSet::Next( LONG lFlags, BSTR *pName, VARIANT *pVal, LONG *plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Next( lFlags, pName, pVal, plFlavor);
}

STDMETHODIMP CUmiQualifierWrapper::XWbemQualifierSet::EndEnumeration()
{
	// Pass through to the wrapper object
	return m_pObject->EndEnumeration();
}

// Actual Implementations

HRESULT CUmiQualifierWrapper::Get( LPCWSTR Name, LONG lFlags, VARIANT *pVal, LONG *plFlavor)
{
	if ( 0L != lFlags )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Very few actual qualifiers
	if ( wbem_wcsicmp( Name, L"key" ) == 0 && m_fKey )
	{
		if ( NULL != pVal )
		{
			V_VT( pVal ) = VT_BOOL;
			V_BOOL( pVal ) = VARIANT_TRUE;
		}

		if ( NULL != plFlavor )
		{
			// For right now
			*plFlavor = ( m_fIsClass ? WBEM_FLAVOR_ORIGIN_LOCAL : WBEM_FLAVOR_ORIGIN_PROPAGATED );
		}
	}
	else if ( wbem_wcsicmp( Name, L"cimtype" ) == 0 && m_fProp )
	{
		if ( NULL != pVal )
		{
			V_VT( pVal ) = VT_BSTR;
			V_BSTR( pVal ) = SysAllocString( CType::GetSyntax( m_ct ) );

			if ( NULL == V_BSTR( pVal ) )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}

		if ( NULL != plFlavor )
		{
			// For right now
			*plFlavor = ( m_fIsClass ? WBEM_FLAVOR_ORIGIN_LOCAL : WBEM_FLAVOR_ORIGIN_PROPAGATED );
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}


	return WBEM_S_NO_ERROR;
}

HRESULT CUmiQualifierWrapper::Put( LPCWSTR Name, VARIANT *pVal, LONG lFlavor)
{
	// Disallowed operation
	return WBEM_E_ACCESS_DENIED;
}

HRESULT CUmiQualifierWrapper::Delete( LPCWSTR Name )
{
	// Disallowed operation
	return WBEM_E_ACCESS_DENIED;
}

HRESULT CUmiQualifierWrapper::GetNames( LONG lFlavor, LPSAFEARRAY *pNames)
{
	// Pass through to the wrapper object
	return WBEM_E_NOT_AVAILABLE;
}

HRESULT CUmiQualifierWrapper::BeginEnumeration(LONG lFlags)
{
	CInCritSec	ics( &m_cs );

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( m_lEnumIndex == UMIQUAL_INVALID_INDEX )
	{
		m_lEnumIndex = UMIQUAL_START_INDEX;
	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CUmiQualifierWrapper::Next( LONG lFlags, BSTR *pName, VARIANT *pVal, LONG *plFlavor)
{
	if ( 0L != lFlags )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	CInCritSec	ics( &m_cs );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// See if we're done with the enumeration
	if ( m_lEnumIndex >= UMIQUAL_START_INDEX )
	{

		if ( m_lEnumIndex < UMIQUAL_MAX_INDEX && ++m_lEnumIndex <= UMIQUAL_MAX_INDEX )
		{
			// Try the ones we recognize then give up

			if ( UMIQUAL_KEY_INDEX == m_lEnumIndex )
			{
				if ( m_fKey )
				{
					hr = GetQualifier( L"key", pName,  pVal, plFlavor);
				}
				else
				{
					++m_lEnumIndex;
				}
			}

			if ( UMIQUAL_CIMTYPE_INDEX == m_lEnumIndex  )
			{
				if ( m_fProp )
				{
					hr = GetQualifier( L"cimtype", pName,  pVal, plFlavor);
				}
				else
				{
					++m_lEnumIndex;
				}
			}

			if ( m_lEnumIndex > UMIQUAL_MAX_INDEX )
			{
				hr = WBEM_S_NO_MORE_DATA;
			}
		}
		else
		{
			hr = WBEM_S_NO_MORE_DATA;
		}
	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CUmiQualifierWrapper::EndEnumeration()
{
	CInCritSec	ics( &m_cs );

	// Pass through to the wrapper object
	m_lEnumIndex = UMIQUAL_INVALID_INDEX;
	return WBEM_S_NO_ERROR;
}

HRESULT CUmiQualifierWrapper::GetQualifier( LPCWSTR Name, BSTR* pName, VARIANT *pVal, LONG *plFlavor)
{
	HRESULT hr = Get( Name, 0L,  pVal, plFlavor );

	if ( SUCCEEDED( hr ) )
	{
		if ( NULL != pName )
		{
			*pName = SysAllocString( Name );
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umischm.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMISCHM.H

Abstract:

  CUMISchemaWrapper Definition.

  Standard definition for UMI Schema wrapper.

History:

  01-May-2000	sanjes    Created.

--*/

#ifndef _UMISCHM_H_
#define _UMISCHM_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include "umi.h"

//***************************************************************************
//
//  class CUMISchemaWrapper
//
//
//***************************************************************************

class COREPROX_POLARITY CUMISchemaWrapper
{

protected:
	IUmiObject*				m_pUmiObj;
	IUmiObject*				m_pUmiSchemaObj;
	CUmiPropertyArray*		m_pPropArray;
	UMI_PROPERTY_VALUES*	m_pUmiProperties;
	BOOL					m_fTrueSchemaObject;

public:

	HRESULT AllocateSchemaInfo( void );
	HRESULT InitializeSchema( IUmiObject* pObject );

	int GetNumProperties( void );
	HRESULT GetProperty( int nIndex, BSTR* bstrName, CIMTYPE* pctType );
	HRESULT GetType( LPCWSTR pwszName, CIMTYPE* pctType );
	HRESULT GetPropertyName( int nIndex, LPCWSTR* pwszName );
	HRESULT GetPropertyOrigin( LPCWSTR pwszName, BSTR* pName );

    CUMISchemaWrapper( void );
	~CUMISchemaWrapper(); 

	BOOL IsSchemaAvailable( void ) { return m_fTrueSchemaObject; }

protected:


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umisysprop.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMISYSPROP.CPP

Abstract:

  CUMISystemProperties implementation.

  Implements a wrapper around UMI objects so we can
  coerce WBEM type system properties out of them.

History:

  01-May-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umiwrap.h"
#include <corex.h>
#include "strutils.h"
#include "umiprop.h"
#include "umischm.h"
#include "umisysprop.h"

LPWSTR	CUMISystemProperties::s_apSysPropNames[] =
{
    /*1*/ L"__GENUS",
    /*2*/ L"__CLASS",
    /*3*/ L"__SUPERCLASS",
    /*4*/ L"__DYNASTY",
    /*5*/ L"__RELPATH",
    /*6*/ L"__PROPERTY_COUNT",
    /*7*/ L"__DERIVATION",
    /*8*/ L"__SERVER",
    /*9*/ L"__NAMESPACE",
    /*10*/L"__PATH",
	/*14*/L"__SECURITY_DESCRIPTOR"
};

//***************************************************************************
//
//  CUMISystemProperties::CUMISystemProperties
//
//***************************************************************************
// ok
CUMISystemProperties::CUMISystemProperties( void )
:	m_pUmiObj( NULL ),
	m_pSysPropArray( NULL ),
	m_pUmiSysProperties( NULL ),
	m_pSysPropList( NULL ),
	m_nNumProperties( 0L ),
	m_lFlags( 0L )
{
}
    
//***************************************************************************
//
//  CUMISystemProperties::~CUMISystemProperties
//
//***************************************************************************
// ok
CUMISystemProperties::~CUMISystemProperties()
{
	if ( NULL != m_pUmiSysProperties )
	{
		m_pSysPropList->FreeMemory( 0L, m_pUmiSysProperties );
		m_pUmiSysProperties = NULL;
	}

	if ( NULL != m_pSysPropArray )
	{
		delete m_pSysPropArray;
		m_pSysPropArray = NULL;
	}

	if ( NULL != m_pSysPropList )
	{
		m_pSysPropList->Release();
	}

	if ( NULL != m_pUmiObj )
	{
		m_pUmiObj->Release();
	}

}

int CUMISystemProperties::NumDefaultSystemProperties( void )
{
	return sizeof(s_apSysPropNames) / sizeof(LPCWSTR);
}

BOOL CUMISystemProperties::IsDefaultSystemProperty( LPCWSTR wszName )
{
	return GetDefaultSystemPropertyIndex( wszName ) >= 0;
}

int CUMISystemProperties::GetDefaultSystemPropertyIndex( LPCWSTR wszName )
{
	int	nTotal = NumDefaultSystemProperties();

	for ( int nCtr = 0; nCtr < nTotal; nCtr++ )
	{
		if ( wbem_wcsicmp( wszName, s_apSysPropNames[nCtr] ) == 0 )
		{
			return nCtr;
		}
	}

	return -1;
}

BOOL CUMISystemProperties::IsPossibleSystemPropertyName( LPCWSTR wszName )
{
	return ( wcslen( wszName ) > 2 && wszName[0] == '_' && wszName[1] == '_' );
}

// Calculates a delta between properties the interface prop list says it
// has and the properties we MUST report for WBEM
HRESULT CUMISystemProperties::CalculateNumProperties( void )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	m_nNumProperties = NumDefaultSystemProperties() + m_pSysPropArray->GetSize();

	// Now walk the system properties and for each one that is in our fixed list, drop the
	// total value by 1.
	for ( ULONG	uCtr = 0; SUCCEEDED( hr ) && uCtr < m_pSysPropArray->GetSize(); uCtr++ )
	{
		CUmiProperty*			pProp = NULL;
		hr = m_pSysPropArray->GetAt( uCtr, &pProp );

		if ( SUCCEEDED( hr ) )
		{
			if ( IsDefaultSystemProperty( pProp->GetPropertyName() ) )
			{
				m_nNumProperties--;

				// Delete the property
				m_pSysPropArray->RemoveAt( uCtr );
				uCtr--;
			}

		}	// IF got property

	}	// FOR enum interface properties

	return hr;
}

// Initializes our schema data, handling objects as necessary
HRESULT CUMISystemProperties::Initialize( IUmiObject* pUmiObj, CUMISchemaWrapper* pSchemaWrapper )
{
	// We're already good to go, so don't worry
	if ( NULL != m_pSysPropList )
	{
		return WBEM_S_NO_ERROR;
	}

	// We'll need this in order to surface some properties
	m_pSchemaWrapper = pSchemaWrapper;

	// Our base object
	m_pUmiObj = pUmiObj;
	m_pUmiObj->AddRef();

	IUmiPropList*	pUmiPropList = NULL;

	HRESULT hr = m_pUmiObj->GetInterfacePropList( 0L, &pUmiPropList );
	CReleaseMe	rm( pUmiPropList );

	if ( SUCCEEDED( hr ) )
	{

		// Get property names from the interface property list and hold them in
		// temporary storage
		hr = pUmiPropList->GetProps( NULL, 0, UMI_FLAG_GETPROPS_NAMES, &m_pUmiSysProperties );

		if ( SUCCEEDED( hr ) )
		{
			m_pSysPropArray = new CUmiPropertyArray;

			if ( NULL != m_pSysPropArray )
			{
				hr = m_pSysPropArray->Set( m_pUmiSysProperties );

				// Properties are set --- now calculate how many properties we really have
				if ( SUCCEEDED( hr ) )
				{
					hr = CalculateNumProperties();

					if ( SUCCEEDED( hr ) )
					{
						m_pSysPropList = pUmiPropList;
						m_pSysPropList->AddRef();
					}

				}

			}	
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

		}	// IF GetProps Succeeded

	}	// IF GetInterfacePropList

	// Cleanup if anything beefed
	if ( FAILED ( hr ) )
	{
		// Clear these up if appropriate
		if ( NULL != m_pUmiSysProperties )
		{
			pUmiPropList->FreeMemory( 0L, m_pUmiSysProperties );
			m_pUmiSysProperties = NULL;
		}

		if ( NULL != m_pSysPropArray )
		{
			delete m_pSysPropArray;
			m_pSysPropArray = NULL;
		}

		if ( NULL != m_pUmiObj )
		{
			m_pUmiObj->Release();
			m_pUmiObj = NULL;
		}
	}

	return hr;
}

// Returns property info
HRESULT CUMISystemProperties::GetNullProperty( LPCWSTR wszName, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor )
{
	// Forces a NULL return type, while filling out requisite data
	if ( NULL != bstrName )
	{
		*bstrName = SysAllocString( wszName );
		if ( *bstrName == NULL )
		{
			return WBEM_E_OUT_OF_MEMORY;
		}
	}

	if ( NULL != pctType )
	{
		if ( wbem_wcsicmp( wszName, s_apSysPropNames[UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR] ) == 0 )
		{
			*pctType = CIM_UINT8 | CIM_FLAG_ARRAY;
		}
		else
		{
			*pctType = CIM_STRING;
		}
	}

	if ( NULL != pVal )
	{
		V_VT( pVal ) = VT_NULL;
	}

	if ( NULL != plFlavor )
	{
		*plFlavor = WBEM_FLAVOR_ORIGIN_SYSTEM;
	}

	return WBEM_S_NO_ERROR;
	
}

// Returns property info
HRESULT CUMISystemProperties::GetDefaultSystemProperty( int nIndex, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor )
{
	// Check that a valid index was requested
	if ( nIndex >= NumDefaultSystemProperties() )
	{
		return WBEM_E_NOT_FOUND;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Go to the right place for the property
	switch ( nIndex )
	{
		case UMI_DEFAULTSYSPROP_GENUS:
		case UMI_DEFAULTSYSPROP_CLASS:
		case UMI_DEFAULTSYSPROP_SUPERCLASS:
		case UMI_DEFAULTSYSPROP_RELPATH:
		case UMI_DEFAULTSYSPROP_PATH:
		{
			// For these, if we get a not found failure, assume a NULL property
			hr = GetPropListProperty( s_apSysPropNames[nIndex], bstrName, pctType, pVal, plFlavor );

			// If we get back a not found or Unbound object error, return as a NULL
			if ( UMI_E_NOT_FOUND == hr || UMI_E_UNBOUND_OBJECT == hr )
			{
				hr = GetNullProperty( s_apSysPropNames[nIndex], bstrName, pctType, pVal, plFlavor );
			}
		}
		break;

		// Special cased
		case UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR:
		{
			hr = GetSecurityDescriptor( bstrName, pctType, pVal, plFlavor );


		}
		break;

		case UMI_DEFAULTSYSPROP_DYNASTY:
		case UMI_DEFAULTSYSPROP_PROPERTY_COUNT:
		case UMI_DEFAULTSYSPROP_DERIVATION:
		case UMI_DEFAULTSYSPROP_SERVER:
		case UMI_DEFAULTSYSPROP_NAMESPACE:
		{
			hr = GetNullProperty( s_apSysPropNames[nIndex], bstrName, pctType, pVal, plFlavor );

			// If we get back a not found or Unbound object error, return as a NULL
			if ( UMI_E_NOT_FOUND == hr || UMI_E_UNBOUND_OBJECT == hr )
			{
				hr = GetNullProperty( s_apSysPropNames[nIndex], bstrName, pctType, pVal, plFlavor );
			}
		}
		break;

		default:
			return WBEM_E_NOT_FOUND;
			break;

	}


	return hr;
}

// Returns property info by index
HRESULT CUMISystemProperties::GetProperty( int nIndex, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor )
{
	// Check if the index is one of our system properties
	if ( nIndex < NumDefaultSystemProperties() )
	{
		return GetDefaultSystemProperty( nIndex, bstrName, pctType, pVal, plFlavor );
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Subtract the number of system properties and hunt for the first non-system property from our
	// index forwards in the property array
	nIndex -= NumDefaultSystemProperties();
	CUmiProperty*			pProp = NULL;

	hr = m_pSysPropArray->GetAt( nIndex, &pProp );

	if ( SUCCEEDED( hr ) )
	{
		hr = GetPropListProperty( pProp->GetPropertyName(), bstrName, pctType, pVal, plFlavor );
	}

	return hr;

}

// Retrieves a property by name
HRESULT CUMISystemProperties::GetProperty( LPCWSTR wszName, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor )
{
	// Check if the index is one of our system properties
	int	nIndex = GetDefaultSystemPropertyIndex( wszName );

	if ( nIndex >= 0 )
	{
		return GetDefaultSystemProperty( nIndex, bstrName, pctType, pVal, plFlavor );
	}

	return GetPropListProperty( wszName, bstrName, pctType, pVal, plFlavor );
}

// Returns property info from the property list
HRESULT CUMISystemProperties::GetPropListProperty( LPCWSTR wszName, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor,
												  long lFlags )
{
	// First get the property
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != pctType || NULL != pVal )
	{
		UMI_PROPERTY_VALUES*	pValues = NULL;

		hr = m_pSysPropList->Get( wszName, lFlags, &pValues );

		if ( SUCCEEDED( hr ) )
		{
			// Convert to a property array and extract the value as a
			// VARIANT.

			CUmiPropertyArray	umiPropArray;

			hr = umiPropArray.Set( pValues );

			if ( SUCCEEDED( hr ) )
			{
				CUmiProperty*	pActualProp = NULL;

				hr = umiPropArray.GetAt( 0L, &pActualProp );

				if ( SUCCEEDED( hr ) )
				{
					// Tells us if synchronization is required
					if ( !pActualProp->IsSynchronizationRequired() )
					{
						CIMTYPE ctPropInfo = pActualProp->GetPropertyCIMTYPE();

						if ( NULL != pctType )
						{
							*pctType = pActualProp->GetPropertyCIMTYPE();
						}

						if ( NULL != pVal )
						{
							hr = pActualProp->FillVariant( pVal, ( ctPropInfo & CIM_FLAG_ARRAY ) );
						}

					}	// IF Synchronization not required
					else
					{
						hr = WBEM_E_SYNCHRONIZATION_REQUIRED;
					}

				}	// IF Got property

			}	// IF Set Array

			m_pSysPropList->FreeMemory( 0L, pValues );

		}	// IF Got a value
		else
		{
			// If we get back an Unbound object error, return as a NULL
			if ( UMI_E_UNBOUND_OBJECT == hr )
			{
				hr = GetNullProperty( wszName, bstrName, pctType, pVal, plFlavor );
			}
		}
	}	// IF NULL != pctType || NULL != pVal

	if ( SUCCEEDED( hr ) )
	{
		if ( NULL != plFlavor )
		{
			*plFlavor = WBEM_FLAVOR_ORIGIN_SYSTEM;
		}

		if ( NULL != bstrName )
		{
			*bstrName = SysAllocString( wszName );

			if ( NULL == *bstrName )
			{
				// Clear the variant if appropriate
				hr = WBEM_E_OUT_OF_MEMORY;
				
				if ( NULL != pVal )
				{
					VariantClear( pVal );
				}

			}	// IF Allocation failed

		}	// IF need to fill out the string

	}	// IF all is well

	return hr;
}

HRESULT CUMISystemProperties::Put( LPCWSTR wszName, ULONG ulFlags, UMI_PROPERTY_VALUES* pPropValues )
{

	// Original code without OCTETSTRING workaround
/*
	HRESULT	hr = m_pSysPropList->Put( wszName, 0, pPropValues );

	if ( SUCCEEDED( hr ) )
	{
		// If we just put the __SECURITY_DESCRIPTOR property, we should set the USE bit so
		// we will actually retrieve it instead of intercepting calls.
		if ( GetDefaultSystemPropertyIndex( wszName ) == UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR )
		{
			m_lFlags |= UMIOBJECT_WRAPPER_FLAG_SECURITY;
		}

	}	// IF put property
*/
	
	HRESULT	hr = WBEM_S_NO_ERROR;

	// We must do special processing
	if ( GetDefaultSystemPropertyIndex( wszName ) == UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR )
	{
		// If the type of the property is an object array, we must coerce to an octet string before putting
		CIMTYPE	ct;
		hr = GetPropListProperty( s_apSysPropNames[UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR], NULL, &ct, NULL, NULL );

		if ( ( CIM_OBJECT | CIM_FLAG_ARRAY ) == ct &&
			pPropValues->pPropArray[0].uType == UMI_TYPE_UI1 &&
			pPropValues->pPropArray[0].uOperationType == UMI_OPERATION_UPDATE )
		{
			// Create a new structure that reorganizes the current values
			UMI_OCTET_STRING	octetString;
			octetString.uLength = pPropValues->pPropArray[0].uCount;
			octetString.lpValue = (byte*) pPropValues->pPropArray[0].pUMIValue;

			UMI_PROPERTY UmiProp;
			UmiProp.uType = UMI_TYPE_OCTETSTRING;
			UmiProp.uCount = 1;
			UmiProp.uOperationType = UMI_OPERATION_UPDATE;
			UmiProp.pszPropertyName = L"__SECURITY_DESCRIPTOR";
			UmiProp.pUMIValue = (UMI_VALUE *) &octetString;

			UMI_PROPERTY_VALUES UmiPropVals;
			UmiPropVals.uCount = 1;
			UmiPropVals.pPropArray = &UmiProp;

			hr = m_pSysPropList->Put( wszName, 0, &UmiPropVals );
		}
		else
		{
			hr = m_pSysPropList->Put( wszName, 0, pPropValues );
		}

		// If we just put the __SECURITY_DESCRIPTOR property, we should set the USE bit so
		// we will actually retrieve it instead of intercepting calls.
		if ( SUCCEEDED( hr ) )
		{
			m_lFlags |= UMIOBJECT_WRAPPER_FLAG_SECURITY;
		}
	}
	else
	{
		hr = m_pSysPropList->Put( wszName, 0, pPropValues );
	}

	return hr;
}

HRESULT CUMISystemProperties::GetSecurityDescriptor( BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor )
{
	// Only get the security descriptor if the flag is set.  If it is not set, we'll just return NULL.  Otherwise, we
	// get only the elements the user is interested in (UMI will default to Owner/Group/Dacl if no values supplied.
	if ( NULL != pVal && m_lFlags & UMIOBJECT_WRAPPER_FLAG_SECURITY )
	{
		long	lFlags = m_lFlags & UMI_SECURITY_MASK ;
		
		// original code with OCTETSTRING workaround
		// return GetPropListProperty( s_apSysPropNames[UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR], bstrName, pctType, pVal, plFlavor, lFlags );

		HRESULT	hr = WBEM_S_NO_ERROR;

		if ( NULL != pVal )
		{
			// First, this will return as an octet string.  We want to return the actual BYTE array
			VARIANT	vTemp;
			CIMTYPE	ct;

			hr = GetPropListProperty( s_apSysPropNames[UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR], bstrName, &ct, &vTemp, plFlavor, lFlags );

			if ( SUCCEEDED( hr ) )
			{
				CClearMe	cmTemp( &vTemp );

				if ( NULL != pctType )
				{
					*pctType = ct;
				}

				// Must be an array of IUnknowns
				if ( ( CIM_OBJECT | CIM_FLAG_ARRAY ) == ct && V_VT( &vTemp ) == ( VT_UNKNOWN | VT_ARRAY ) )
				{
					CSafeArray	saObj( V_ARRAY( &vTemp ), VT_UNKNOWN, CSafeArray::bind | CSafeArray::no_delete );

					if ( saObj.Size() == 1 )
					{
						// Use IWbemClassObject to get the vale which should be the BYTE array we
						// really want to return

						IUnknown*	pUnk = saObj.GetUnknownAt( 0 );
						CReleaseMe	rmUnk( pUnk );

						IWbemClassObject*	pObj = NULL;
						hr = pUnk->QueryInterface( IID_IWbemClassObject, (void**) &pObj );
						CReleaseMe	rmObj( pObj );

						if ( SUCCEEDED( hr ) )
						{
							hr = pObj->Get( L"values", 0L, pVal, pctType, plFlavor );
						}

					}	// IF the size is 1
					else
					{
						hr = WBEM_E_TYPE_MISMATCH;
					}

				}	// IF it's an object array
				else if ( ( CIM_UINT8 | CIM_FLAG_ARRAY ) != ct )
				{
					// A UI8 array is okay as well, but NOTHING else
					return WBEM_E_TYPE_MISMATCH;
				}

			}	// IF we got the property

		}
		else
		{
			hr = GetPropListProperty( s_apSysPropNames[UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR], bstrName, pctType, pVal, plFlavor, lFlags );
		}

		return hr;

	}
	else
	{
		return GetNullProperty( s_apSysPropNames[UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR], bstrName, pctType, pVal, plFlavor );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umitemp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMIWRAP.H

Abstract:

  CUmiObjectWrapper Definition.

  Standard definition for _IWbemUMIObjectWrapper.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _UMIWRAP_H_
#define _UMIWRAP_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include "umi.h"

#define	UMIWRAP_INVALID_INDEX	(-2)
#define	UMIWRAP_START_INDEX		(-1)

//***************************************************************************
//
//  class CUMIObjectWrapper
//
//  Implementation of _IWmiFreeFormObject Interface
//
//***************************************************************************

class COREPROX_POLARITY CUMIObjectWrapper : public CUnk
{
	class COREPROX_POLARITY CUmiPropEnumData
	{
	private:
		long				m_lPropIndex;
		long				m_lEnumFlags;
		CUmiPropertyArray*	m_pPropArray;
		UMI_PROPERTY_VALUES*	m_pUmiProperties;
		CUmiPropertyArray*	m_pSysPropArray;
		UMI_PROPERTY_VALUES*	m_pUmiSysProperties;

	public:
		CUmiPropEnumData() : m_lPropIndex( UMIWRAP_INVALID_INDEX ),	m_lEnumFlags( 0L ), m_pPropArray( NULL ),
			m_pUmiProperties( NULL ), m_pSysPropArray( NULL ), m_pUmiSysProperties( NULL )
		{};
		~CUmiPropEnumData()
		{};

		HRESULT BeginEnumeration( long lEnumFlags, IUmiObject* pUMIObj, IUmiObject*	pSchemaObj, BOOL fRefresh );
		HRESULT Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
						long* plFlavor, IUmiObject* pUMIObj, IUmiObject* pSchemaObj);
		HRESULT EndEnumeration( IUmiObject* pUMIObj, IUmiObject* pSchemaObj );

	};

protected:
	IUmiObject*			m_pUMIObj;
	IUmiObject*			m_pUMISchemaObj;
	CUmiPropEnumData	m_EnumPropData;
	BOOL				m_fHaveSchemaObject;	// Tells us if the schema object pointer
												// is really a schema object or not
	BOOL				m_fDirty;	// Workaround until Refresh is fixed.
	BOOL				m_fIsClass;				// Is this a class object

    SHARED_LOCK_DATA	m_LockData;
    CSharedLock			m_Lock;

public:

    CUMIObjectWrapper(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CUMIObjectWrapper(); 

	IUmiObject*	GetUmiObject( void );

    class COREPROX_POLARITY XWbemClassObject : public CImpl<IWbemClassObject, CUMIObjectWrapper>
    {
    public:
        XWbemClassObject(CUMIObjectWrapper* pObject) : 
            CImpl<IWbemClassObject, CUMIObjectWrapper>(pObject)
        {}

		/* IWbemClassObject methods */
		STDMETHOD(GetQualifierSet)(IWbemQualifierSet** pQualifierSet);
		STDMETHOD(Get)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
			long* plFlavor);

		STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
		STDMETHOD(Delete)(LPCWSTR wszName);
		STDMETHOD(GetNames)(LPCWSTR wszName, long lFlags, VARIANT* pVal,
							SAFEARRAY** pNames);
		STDMETHOD(BeginEnumeration)(long lEnumFlags);

		STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
						long* plFlavor);

		STDMETHOD(EndEnumeration)();

		STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty,
										   IWbemQualifierSet** pQualifierSet);
		STDMETHOD(Clone)(IWbemClassObject** pCopy);
		STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax);

		STDMETHOD(CompareTo)(long lFlags, IWbemClassObject* pCompareTo);
		STDMETHOD(GetPropertyOrigin)(LPCWSTR wszProperty, BSTR* pstrClassName);
		STDMETHOD(InheritsFrom)(LPCWSTR wszClassName);

		STDMETHOD(SpawnDerivedClass)(long lFlags, IWbemClassObject** ppNewClass);
		STDMETHOD(SpawnInstance)(long lFlags, IWbemClassObject** ppNewInstance);
		STDMETHOD(GetMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
								IWbemClassObject** ppOutSig);
		STDMETHOD(PutMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
								IWbemClassObject* pOutSig);
		STDMETHOD(DeleteMethod)(LPCWSTR wszName);
		STDMETHOD(BeginMethodEnumeration)(long lFlags);
		STDMETHOD(NextMethod)(long lFlags, BSTR* pstrName, 
						   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
		STDMETHOD(EndMethodEnumeration)();
		STDMETHOD(GetMethodQualifierSet)(LPCWSTR wszName, IWbemQualifierSet** ppSet);
		STDMETHOD(GetMethodOrigin)(LPCWSTR wszMethodName, BSTR* pstrClassName);

    } m_XWbemClassObject;
    friend XWbemClassObject;

    class COREPROX_POLARITY XWbemClassObjectEx : public CImpl<IWbemClassObjectEx, CUMIObjectWrapper>
    {
    public:
        XWbemClassObjectEx(CUMIObjectWrapper* pObject) : 
            CImpl<IWbemClassObjectEx, CUMIObjectWrapper>(pObject)
        {}

		STDMETHOD(PutEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
		STDMETHOD(DeleteEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
	} m_XWbemClassObjectEx;
	friend XWbemClassObjectEx;

	// IUmiObject Methods
    class COREPROX_POLARITY XUmiObject : public CImpl<IUmiObject, CUMIObjectWrapper>
    {
    public:
        XUmiObject(CUMIObjectWrapper* pObject) : 
            CImpl<IUmiObject, CUMIObjectWrapper>(pObject)
        {}
		/* IUmiPropList Methods */
		STDMETHOD(Put)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp );
		STDMETHOD(Get)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp );
		STDMETHOD(GetAt)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
		STDMETHOD(GetAs)( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp );
		STDMETHOD(FreeMemory)( ULONG uReserved, LPVOID pMem );
		STDMETHOD(Delete)( LPCWSTR pszName, ULONG uFlags );
		STDMETHOD(GetProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps );
		STDMETHOD(PutProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps );
		STDMETHOD(PutFrom)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );

		/* IUmiBaseObject Methods */
        STDMETHOD(GetLastStatus)( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj );
		STDMETHOD(GetInterfacePropList)( ULONG uFlags, IUmiPropList **pPropList );

		/* IUmiObject Methods */
        STDMETHOD(Clone)( ULONG uFlags, REFIID riid, LPVOID *pCopy );
        STDMETHOD(Refresh)( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames );
		STDMETHOD(Commit)( ULONG uFlags );
	}	m_XUmiObject;
	friend XUmiObject;

	// IUmiObject Methods
    class COREPROX_POLARITY XWbemUMIObjectWrapper : public CImpl<_IWbemUMIObjectWrapper, CUMIObjectWrapper>
    {
    public:
        XWbemUMIObjectWrapper(CUMIObjectWrapper* pObject) : 
            CImpl<_IWbemUMIObjectWrapper, CUMIObjectWrapper>(pObject)
        {}
		
		STDMETHOD(SetObject)( long lFlags, IUnknown* pUnk );
	// Sets the underlying UMI Object interface pointer
	}	m_XWbemUMIObjectWrapper;
	friend XWbemUMIObjectWrapper;

	// IUmiCustomInterfaceFactory Methods
    class COREPROX_POLARITY XUmiCustIntfFactory : public CImpl<IUmiCustomInterfaceFactory, CUMIObjectWrapper>
    {
    public:
        XUmiCustIntfFactory(CUMIObjectWrapper* pObject) : 
            CImpl<IUmiCustomInterfaceFactory, CUMIObjectWrapper>(pObject)
        {}
		
		// Returns matching CLSID for requested IID
		STDMETHOD(GetCLSIDForIID)( REFIID riid, long lFlags, CLSID *pCLSID );

		// Creates (possibly aggregated) object of given CLSID and returns interface
		STDMETHOD(GetObjectByCLSID)( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface );

		// Provides DISPIDs for Names and the CLSID for the object that supports them
		STDMETHOD(GetCLSIDForNames)( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID );

	}	m_XUmiCustIntfFactory;
	friend XUmiCustIntfFactory;

    // IMarshal methods
    class COREPROX_POLARITY XObjectMarshal : public CImpl<IMarshal, CUMIObjectWrapper>
    {
    public:
        XObjectMarshal(CUMIObjectWrapper* pObject) : 
            CImpl<IMarshal, CUMIObjectWrapper>(pObject)
        {}
		STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
			void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
		STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
			void* pvReserved, DWORD mshlFlags, ULONG* plSize);
		STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv,
			DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
		STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
		STDMETHOD(ReleaseMarshalData)(IStream* pStream);
		STDMETHOD(DisconnectObject)(DWORD dwReserved);
	}	m_XObjectMarshal;
	friend XObjectMarshal;

    /* IWbemClassObject methods */
    virtual HRESULT GetQualifierSet(IWbemQualifierSet** pQualifierSet);
    virtual HRESULT Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
        long* plFlavor);

    virtual HRESULT Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
    virtual HRESULT Delete(LPCWSTR wszName);
    virtual HRESULT GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                        SAFEARRAY** pNames);
    virtual HRESULT BeginEnumeration(long lEnumFlags);

    virtual HRESULT Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                    long* plFlavor);

    virtual HRESULT EndEnumeration();

    virtual HRESULT GetPropertyQualifierSet(LPCWSTR wszProperty,
                                       IWbemQualifierSet** pQualifierSet);
    virtual HRESULT Clone(IWbemClassObject** pCopy);
    virtual HRESULT GetObjectText(long lFlags, BSTR* pMofSyntax);

    virtual HRESULT CompareTo(long lFlags, IWbemClassObject* pCompareTo);
    virtual HRESULT GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName);
    virtual HRESULT InheritsFrom(LPCWSTR wszClassName);

    virtual HRESULT SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass);
    virtual HRESULT SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance);
    virtual HRESULT GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                            IWbemClassObject** ppOutSig);
    virtual HRESULT PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                            IWbemClassObject* pOutSig);
    virtual HRESULT DeleteMethod(LPCWSTR wszName);
    virtual HRESULT BeginMethodEnumeration(long lFlags);
    virtual HRESULT NextMethod(long lFlags, BSTR* pstrName, 
                       IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
    virtual HRESULT EndMethodEnumeration();
    virtual HRESULT GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet);
    virtual HRESULT GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName);

	/* IWbemClassObjectEx Methods */
	virtual HRESULT PutEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
	virtual HRESULT DeleteEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );

	/* IUmiPropList Methods */
	virtual HRESULT Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp );
	virtual HRESULT Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp );
	virtual HRESULT GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
	virtual HRESULT GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp );
	virtual HRESULT FreeMemory( ULONG uReserved, LPVOID pMem );
	virtual HRESULT Delete( LPCWSTR pszName, ULONG uFlags );
	virtual HRESULT GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps );
	virtual HRESULT PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps );
	virtual HRESULT PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );

	/* IUmiBaseObject Methods */
    virtual HRESULT GetLastStatus( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj );
	virtual HRESULT GetInterfacePropList( ULONG uFlags, IUmiPropList **pPropList );

	/* IUmiObject Methods */
    virtual HRESULT Clone( ULONG uFlags, REFIID riid, LPVOID *pCopy );
    virtual HRESULT Refresh( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames );
	virtual HRESULT Commit( ULONG uFlags );

	/* _IWbemUMIObjectWrapper */
	virtual HRESULT SetObject( long lFlags, IUnknown* pUnk );

	/* IMarshal methods */
	virtual HRESULT GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
		void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
	virtual HRESULT GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
		void* pvReserved, DWORD mshlFlags, ULONG* plSize);
	virtual HRESULT MarshalInterface(IStream* pStream, REFIID riid, void* pv,
		DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
	virtual HRESULT UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv);
	virtual HRESULT ReleaseMarshalData(IStream* pStream);
	virtual HRESULT DisconnectObject(DWORD dwReserved);

	/* IUmiCustomInterfaceFactory */
	virtual HRESULT GetCLSIDForIID( REFIID riid, long lFlags, CLSID *pCLSID );
	virtual HRESULT GetObjectByCLSID( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface );
	virtual HRESULT GetCLSIDForNames( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID );


	// Lock/Unlock helpers
    HRESULT Lock(long lFlags);
    HRESULT Unlock(long lFlags);

protected:

	// Helper function that locks/unlocks the object using scoping
    class CLock
    {
    protected:
        CUMIObjectWrapper* m_p;
    public:
        CLock(CUMIObjectWrapper* p, long lFlags = 0) : m_p(p) { if ( NULL != p ) p->Lock(lFlags);}
        ~CLock() { if ( NULL != m_p ) m_p->Unlock(0);}
    };

    void* GetInterface(REFIID riid);

	HRESULT GetPropertyCimType( LPCWSTR wszName, CIMTYPE* pct );
	HRESULT PutVariant( LPCWSTR wszName, ULONG umiOperation, VARIANT* pVal, CIMTYPE ct );

	// Helper function to establish the schema object we will use to
	// determine available properties, and such
	HRESULT SetSchemaObject( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umivalue.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIVALUE.CPP

Abstract:

  CUmiValue implementation.

  Helper classes for dealing with UMI

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wrapobj.h"
#include <corex.h>
#include "umivalue.h"
#include "cwbemtime.h"
#include "arrtempl.h"
#include "genutils.h"
#include "ocstrcls.h"

ULONG CUmiValue::m_auUMITypeSize[UMI_TYPE_DEFAULT+1] =
{
	0,
	1, 2, 4, 8,	// Integer Types
	1, 2, 4, 8, // Unsigned integers
	4, 8,		// real values
	0,			// Unused
	sizeof(FILETIME), sizeof(SYSTEMTIME),	// Date/Time structures
	4,			// BOOL
	sizeof(UMI_COM_OBJECT), sizeof(UMI_COM_OBJECT),	// COM Types
	0,			// Variant
	0,0,		// Unused
	sizeof(LPWSTR),	// LPWSTR
	sizeof(UMI_OCTET_STRING),	// Octet string
	0,				// Array ??????
	0,				// Discovery ?????
	0,				// Undefined ????
	0				// Default????
};

//***************************************************************************
//
//  CUmiValue::~CUmiValue
//
//***************************************************************************
// ok
CUmiValue::CUmiValue( UMI_TYPE uType, ULONG uNumValues, LPVOID pvData, BOOL fAcquire )
:	m_uNumValues( uNumValues ),
	m_uType( uType ),
	m_pValue( &m_singleValue ),
	m_fCanDelete( TRUE )
{
	if ( UMI_TYPE_NULL != uType )
	{
		if ( FAILED( SetRaw( uNumValues, pvData, uType, fAcquire ) ) )
		{
			throw CX_MemoryException();
		}
	}
}
    
//***************************************************************************
//
//  CUmiValue::~CUmiValue
//
//***************************************************************************
// ok
CUmiValue::~CUmiValue()
{
	Clear();
}

// Returns the type base on the array above
ULONG CUmiValue::Size( UMI_TYPE umiType )
{
	return m_auUMITypeSize[(ULONG) umiType];
}

// Is the type one which requires allocation handling?
BOOL CUmiValue::IsAllocatedType( UMI_TYPE umiType )
{
	return ( UMI_TYPE_LPWSTR == umiType );
}

// Is the type one which requires AddRef/Release handling?
BOOL CUmiValue::IsAddRefType( UMI_TYPE umiType )
{
	return ( UMI_TYPE_IDISPATCH == umiType || UMI_TYPE_IUNKNOWN == umiType );
}

// Checks indexes
BOOL CUmiValue::ValidIndex( ULONG uIndex )
{
	return ( uIndex < m_uNumValues );
}

// Helper to convert between type systems
UMI_TYPE CUmiValue::CIMTYPEToUmiType( CIMTYPE ct )
{
	switch ( CType::GetBasic( ct ) )
	{
		case CIM_SINT8:			return UMI_TYPE_I1;
		case CIM_UINT8:			return UMI_TYPE_UI1;
		case CIM_SINT16:		return UMI_TYPE_I2;
		case CIM_UINT16:		return UMI_TYPE_UI2;
		case CIM_SINT32:		return UMI_TYPE_I4;
		case CIM_UINT32:		return UMI_TYPE_UI4;
		case CIM_SINT64:		return UMI_TYPE_I8;
		case CIM_UINT64:		return UMI_TYPE_UI8;
		case CIM_REAL32:		return UMI_TYPE_R4;
		case CIM_REAL64:		return UMI_TYPE_R8;
		case CIM_BOOLEAN:		return UMI_TYPE_BOOL;
		case CIM_STRING:		return UMI_TYPE_LPWSTR;
		case CIM_DATETIME:		return UMI_TYPE_LPWSTR;
		case CIM_REFERENCE:		return UMI_TYPE_SYSTEMTIME;
		case CIM_CHAR16:		return UMI_TYPE_UI2;
		case CIM_OBJECT:		return UMI_TYPE_OCTETSTRING;
		case CIM_IUNKNOWN:		return UMI_TYPE_IUNKNOWN;
	}

	return UMI_TYPE_DEFAULT;
}

// Helper to convert between type systems
CIMTYPE CUmiValue::UmiTypeToCIMTYPE( UMI_TYPE umiType )
{
	CIMTYPE	ct;
	switch ( GetBasic( umiType ) )
	{
		case UMI_TYPE_I1:				ct = CIM_SINT8;	break;
		case UMI_TYPE_UI1:				ct = CIM_UINT8;	break;
		case UMI_TYPE_I2:				ct = CIM_SINT16;	break;
		case UMI_TYPE_UI2:				ct = CIM_UINT16;	break;
		case UMI_TYPE_I4:				ct = CIM_SINT32;	break;
		case UMI_TYPE_UI4:				ct = CIM_UINT32;	break;
		case UMI_TYPE_I8:				ct = CIM_SINT64;	break;
		case UMI_TYPE_UI8:				ct = CIM_UINT64;	break;
		case UMI_TYPE_R4:				ct = CIM_REAL32;	break;
		case UMI_TYPE_R8:				ct = CIM_REAL64;	break;
		case UMI_TYPE_BOOL:				ct = CIM_BOOLEAN;	break;
		case UMI_TYPE_LPWSTR:			ct = CIM_STRING;	break;
		case UMI_TYPE_OCTETSTRING:		ct = CIM_OBJECT;	break;
		case UMI_TYPE_SYSTEMTIME:		ct = CIM_DATETIME;	break;
		case UMI_TYPE_FILETIME:			ct = CIM_DATETIME;	break;
		case UMI_TYPE_IUNKNOWN:			ct = CIM_IUNKNOWN;	break;
		case UMI_TYPE_IDISPATCH:		ct = CIM_IUNKNOWN;	break;
		case UMI_TYPE_NULL:				ct = CIM_EMPTY;	break;
		default:						return CIM_ILLEGAL;
	}

	if ( umiType & UMI_TYPE_ARRAY_FLAG )
	{
		ct |= CIM_FLAG_ARRAY;
	}

	return ct;
}

UMI_TYPE CUmiValue::GetBasic( UMI_TYPE umiType )
{
	return umiType & 0x1FFF;
}

// Frees any memory we may have allocated
void CUmiValue::Clear( void )
{
	// First if m_fCanDelete is TRUE and the type is an allocated or AddRefed type, we need to
	// walk the array and do proper cleanup

	if ( m_fCanDelete )
	{
		if ( IsAllocatedType( m_uType ) )
		{
			// Handles deletes
			for ( ULONG	uCtr = 0; uCtr < m_uNumValues; uCtr++ )
			{
				if ( UMI_TYPE_LPWSTR == m_uType )
				{
					delete [] m_pValue->pszStrValue[uCtr];
				}
			}
		}
		else if ( IsAddRefType( m_uType ) )
		{
			// Handles Releases
			for ( ULONG	uCtr = 0; uCtr < m_uNumValues; uCtr++ )
			{
				((IUnknown*) m_pValue->comObject[uCtr].pInterface)->AddRef();
			}
		}

		// Finally, if m_pValue is not pointing at the local value, we'll tank
		// that as well
		if ( m_pValue != &m_singleValue )
		{
			delete [] m_pValue;
		}
	}

	// Reset the member data
	m_pValue = &m_singleValue;
	m_uType = UMI_TYPE_NULL;
	m_uNumValues = 0;
	m_fCanDelete = TRUE;
}

// Helper function to set values in the proper place and perform an
HRESULT CUmiValue::SetRaw( ULONG uNumValues, LPVOID pvData, UMI_TYPE umiType, BOOL fAcquire )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// NULL data buffer means this guys NULL.
	if ( NULL == pvData )
	{
		m_uType = UMI_TYPE_NULL;
		return WBEM_S_NO_ERROR;
	}
	else if ( UMI_TYPE_NULL == umiType && NULL != pvData )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Removes the array flag from the type
	umiType = GetBasic( umiType );

	ULONG	uSize = Size( umiType );
	void*	pvTemp = (void*) &m_singleValue;

	if ( !fAcquire )
	{
		if ( uNumValues > 1 )
		{
			pvTemp = (void*) new BYTE[uNumValues*uSize];

			if ( NULL == pvTemp )
			{
				return WBEM_E_OUT_OF_MEMORY;
			}

		}

		m_pValue = (PUMI_VALUE) pvTemp;
		m_uNumValues = uNumValues;
		m_uType = umiType;

		// Copies as necessary
		if ( IsAllocatedType( m_uType ) )
		{
			for ( ULONG	uCtr = 0; SUCCEEDED( hr ) && uCtr < m_uNumValues; uCtr++ )
			{
				if ( UMI_TYPE_LPWSTR == m_uType )
				{
					hr = SetLPWSTR( ((LPWSTR*) pvData)[uCtr] );
				}
			}

			// We'll set the number of values to reflect what was actually stored
			// so a subsequent clear will clean us up
			if ( FAILED( hr ) )
			{
				m_uNumValues = uCtr - 1;
			}
		}
		else if ( IsAddRefType( m_uType ) )
		{
			// Copy the underlying data and AddRef() the pointers
			CopyMemory( m_pValue, pvData, uNumValues*uSize );

			for ( ULONG	uCtr = 0; SUCCEEDED( hr ) && uCtr < m_uNumValues; uCtr++ )
			{
				((IUnknown*) m_pValue->comObject[uCtr].pInterface)->AddRef();
			}
		}
		else
		{
			// We'll handle allocated and AddRefd stuff separately
			CopyMemory( m_pValue, pvData, uNumValues*uSize );
		}

	}
	else
	{
		// Grab their buffer and hold onto it - We will automatically own all
		// string data - we will AddRef all AddRef'd values
		m_pValue = (PUMI_VALUE) pvData;
		m_uNumValues = uNumValues;
		m_uType = umiType;
	}

	// If we have FAILED at this point, just cleanup and get on
	if ( FAILED(hr) )
	{
		Clear();
	}

	return hr;
}

// Helper Function for quick memory access
HRESULT CUmiValue::GetRaw( ULONG* puNumValues, LPVOID* ppvData, UMI_TYPE* pumitype )
{
	*puNumValues = m_uNumValues;
	*pumitype = m_uType;
	*ppvData = m_pValue;

	return WBEM_S_NO_ERROR;
}

// Helper Function for SAFEARRAY access
HRESULT CUmiValue::FillVariant( VARIANT* pVariant, BOOL fForceArray )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	CIMTYPE	ct = UmiTypeToCIMTYPE( m_uType );

	try
	{
		// Initialize the variant
		VariantInit( pVariant );

		UINT	uNumValues = m_uNumValues;

		if ( !fForceArray && 1 == uNumValues && m_uType != UMI_TYPE_OCTETSTRING && !( m_uType & CIM_FLAG_ARRAY )  )
		{

			switch( m_uType )
			{
				case UMI_TYPE_I1:
				case UMI_TYPE_UI1:
				{
					pVariant->bVal = m_pValue->byteValue[0];
				}
				break;

				case UMI_TYPE_I2:
				case UMI_TYPE_UI2:
				{
					pVariant->iVal = m_pValue->wValue[0];
				}
				break;

				case UMI_TYPE_I4:
				{
					pVariant->lVal = m_pValue->lValue[0];
				}
				break;

				case UMI_TYPE_UI4:
				{
					pVariant->lVal = m_pValue->dwValue[0];
				}
				break;

				case UMI_TYPE_I8:
				case UMI_TYPE_UI8:
				{
					// We need to convert to a string and set the LPWSTR value
					WCHAR	wcsTemp[64];

					if ( UMI_TYPE_I8 == m_uType )
					{
						swprintf( wcsTemp, L"%I64d", m_pValue->nValue64[0] );
					}
					else
					{
						swprintf( wcsTemp, L"%I64u", m_pValue->uValue64[0] );
					}

					pVariant->bstrVal = SysAllocString( wcsTemp );

					if ( NULL == pVariant->bstrVal )
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

				}
				break;

				case UMI_TYPE_R4:
				{
					pVariant->fltVal = (float)  m_pValue->dblValue[0];
				}
				break;

				case UMI_TYPE_R8:
				{
					pVariant->dblVal = m_pValue->dblValue[0];
				}
				break;

				case UMI_TYPE_BOOL:
				{
					pVariant->boolVal = ( m_pValue->bValue[0] ? VARIANT_TRUE : VARIANT_FALSE ); 
				}
				break;

				case UMI_TYPE_LPWSTR:
				{
					if ( NULL != m_pValue->pszStrValue[0] )
					{
						pVariant->bstrVal = SysAllocString( m_pValue->pszStrValue[0] );

						if ( NULL == pVariant->bstrVal )
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}
					else
					{
						// If a NULL, we consider this to be a NULL
						V_VT( pVariant ) = VT_NULL;
						pVariant->bstrVal = NULL;
						return WBEM_S_NO_ERROR;
					}
				}
				break;

				case UMI_TYPE_SYSTEMTIME:
				{
					// Get a string out of this and stick it in the BLOB
					WCHAR	wcsTime[32];
					CWbemTime	wbemTime;

					wbemTime.SetSystemTime( m_pValue->sysTimeValue[0] );
					wbemTime.GetDMTF( TRUE, 32, wcsTime );
					pVariant->bstrVal = SysAllocString( wcsTime );

					if ( NULL == pVariant->bstrVal )
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				break;

				case UMI_TYPE_FILETIME:
				{
					// Get a string out of this and stick it in the BLOB
					WCHAR	wcsTime[32];
					CWbemTime	wbemTime;

					wbemTime.SetFileTime( m_pValue->fileTimeValue[0] );
					wbemTime.GetDMTF( TRUE, 32, wcsTime );
					pVariant->bstrVal = SysAllocString( wcsTime );

					if ( NULL == pVariant->bstrVal )
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}
				}
				break;

				case UMI_TYPE_IUNKNOWN:
				case UMI_TYPE_IDISPATCH:
				{
					// AddRef on the way out
					if ( NULL != m_pValue->comObject[0].pInterface )
					{
						pVariant->punkVal = (IUnknown*) m_pValue->comObject[0].pInterface;
						pVariant->punkVal->AddRef();
					}
					else
					{
						// If a NULL, we consider this to be a NULL
						V_VT( pVariant ) = VT_NULL;
						pVariant->punkVal = NULL;
						return WBEM_S_NO_ERROR;
					}
				}
				break;

				default:
				{
					hr = WBEM_E_TYPE_MISMATCH;
				}
				break;


			}	// SWITCH

			if ( SUCCEEDED( hr ) )
			{
				V_VT(pVariant) = CType::GetVARTYPE( ct );
			}

		}
		else if ( 0 == m_uNumValues && UMI_TYPE_NULL == m_uType )
		{
			// It's a NULL.
			V_VT( pVariant ) = VT_NULL;
		}
		else
		{
			COctetStringClass	octstrClass;

			// Assume an array
			CSafeArray SA( CType::GetVARTYPE( ct ), CSafeArray::auto_delete, uNumValues );


			for ( ULONG uCtr = 0; SUCCEEDED( hr ) && uCtr < uNumValues; uCtr++ )
			{
				switch( m_uType )
				{
					case UMI_TYPE_I1:
					case UMI_TYPE_UI1:
					{
						SA.SetByteAt( uCtr, m_pValue->byteValue[uCtr] );
					}
					break;

					case UMI_TYPE_I2:
					case UMI_TYPE_UI2:
					{
						SA.SetShortAt( uCtr, m_pValue->wValue[uCtr] );
					}
					break;

					case UMI_TYPE_I4:
					{
						SA.SetLongAt( uCtr, m_pValue->lValue[uCtr] );
					}
					break;

					case UMI_TYPE_UI4:
					{
						SA.SetLongAt( uCtr, m_pValue->dwValue[uCtr] );
					}
					break;

					case UMI_TYPE_I8:
					case UMI_TYPE_UI8:
					{
						// We need to convert to a string and set the LPWSTR value
						WCHAR	wcsTemp[64];

						if ( UMI_TYPE_I8 == m_uType )
						{
							swprintf( wcsTemp, L"%I64d", m_pValue->nValue64[uCtr] );
						}
						else
						{
							swprintf( wcsTemp, L"%I64u", m_pValue->uValue64[uCtr] );
						}

						SA.SetBSTRAt( uCtr, wcsTemp );
					}
					break;

					case UMI_TYPE_R4:
					{
						SA.SetFloatAt( uCtr, (float) m_pValue->dblValue[uCtr] );
					}
					break;

					case UMI_TYPE_R8:
					{
						SA.SetDoubleAt( uCtr, m_pValue->dblValue[uCtr] );
					}
					break;

					case UMI_TYPE_BOOL:
					{
						SA.SetBoolAt( uCtr, ( m_pValue->bValue[uCtr] ? VARIANT_TRUE : VARIANT_FALSE ) );
					}
					break;

					case UMI_TYPE_LPWSTR:
					{
						SA.SetBSTRAt( uCtr, m_pValue->pszStrValue[uCtr] );
					}
					break;

					case UMI_TYPE_OCTETSTRING:
					{
						// Stored as embedded objects
						_IWmiObject*	pInst = NULL;

						hr = octstrClass.GetInstance( &m_pValue->octetStr[uCtr], &pInst );
						CReleaseMe	rm( pInst );

						if ( SUCCEEDED( hr ) )
						{
							// AddRef on the way out
							SA.SetUnknownAt( uCtr, pInst );
						}

					}
					break;

					case UMI_TYPE_SYSTEMTIME:
					{
						// Get a string out of this and stick it in the BLOB
						WCHAR	wcsTime[32];
						CWbemTime	wbemTime;

						wbemTime.SetSystemTime( m_pValue->sysTimeValue[uCtr] );
						wbemTime.GetDMTF( TRUE, 32, wcsTime );
						SA.SetBSTRAt( uCtr, wcsTime );
					}
					break;

					case UMI_TYPE_FILETIME:
					{
						// Get a string out of this and stick it in the BLOB
						WCHAR	wcsTime[32];
						CWbemTime	wbemTime;

						wbemTime.SetFileTime( m_pValue->fileTimeValue[uCtr] );
						wbemTime.GetDMTF( TRUE, 32, wcsTime );
						SA.SetBSTRAt( uCtr, wcsTime );
					}
					break;

					case UMI_TYPE_IUNKNOWN:
					case UMI_TYPE_IDISPATCH:
					{
						// AddRef on the way out
						SA.SetUnknownAt( uCtr, (IUnknown*) m_pValue->comObject[uCtr].pInterface );
					}
					break;

					default:
					{
						hr = WBEM_E_TYPE_MISMATCH;
					}
					break;


	/*
					case UMI_TYPE_IUNKNOWN:			return CIM_OBJECT;
	*/
				}	// SWITCH

			}	// FOR

			if ( SUCCEEDED( hr ) )
			{
				// Now fill out the variant
				SA.Trim();

				V_ARRAY(pVariant) = SA.GetArrayCopy();
				V_VT(pVariant) = CType::GetVARTYPE( ct ) | VT_ARRAY;
			}

		}	// IF Is Array

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;

}

// Loads From a Variant
HRESULT CUmiValue::SetFromVariant( VARIANT* pVariant, ULONG umiType )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Clear at this level only
		CUmiValue::Clear();

		// Check for NULL or an array
		if ( NULL == pVariant || V_VT( pVariant ) == VT_NULL )
		{
			return hr;
		}

		// Set from an array as necessary
		if ( V_VT( pVariant ) & VT_ARRAY )
		{
			return SetFromVariantArray( pVariant, umiType );
		}


		UMI_TYPE	umiBasicType = GetBasic( umiType );

		switch( umiBasicType )
		{
			case UMI_TYPE_I1:
			case UMI_TYPE_UI1:
			{
				hr = SetRaw( 1, &pVariant->bVal, umiBasicType, FALSE );
			}
			break;

			case UMI_TYPE_I2:
			case UMI_TYPE_UI2:
			{
				hr = SetRaw( 1, &pVariant->iVal, umiBasicType, FALSE );
			}
			break;

			case UMI_TYPE_I4:
			case UMI_TYPE_UI4:
			{
				hr = SetRaw( 1, &pVariant->lVal, umiBasicType, FALSE );
			}
			break;

			case UMI_TYPE_I8:
			case UMI_TYPE_UI8:
			{
				if ( UMI_TYPE_I8 == m_uType )
				{
					__int64 i64 = 0;
					ReadI64( pVariant->bstrVal, i64);
					hr = SetRaw( 1, &i64, umiBasicType, FALSE );
				}
				else
				{
					unsigned __int64 ui64 = 0;
					ReadUI64( pVariant->bstrVal, ui64);
					hr = SetRaw( 1, &ui64, umiBasicType, FALSE );
				}
			}
			break;

			case UMI_TYPE_R4:
			{
				hr = SetRaw( 1, &pVariant->fltVal, umiBasicType, FALSE );
			}
			break;

			case UMI_TYPE_R8:
			{
				hr = SetRaw( 1, &pVariant->dblVal, umiBasicType, FALSE );
			}
			break;

			case UMI_TYPE_BOOL:
			{
				BOOL	fVal = ( pVariant->boolVal == VARIANT_TRUE ? TRUE : FALSE );
				hr = SetRaw( 1, &fVal, umiBasicType, FALSE );
			}
			break;

			case UMI_TYPE_LPWSTR:
			{
				hr = SetRaw( 1, &pVariant->bstrVal, umiBasicType, FALSE );
			}
			break;

			case UMI_TYPE_FILETIME:
			case UMI_TYPE_SYSTEMTIME:
			{
				CWbemTime	wbemTime;

				if ( wbemTime.SetDMTF( pVariant->bstrVal ) )
				{
					if ( UMI_TYPE_SYSTEMTIME == umiType )
					{
						SYSTEMTIME	st;

						if ( wbemTime.GetSYSTEMTIME( &st ) )
						{
							hr = SetRaw( 1, &st, umiBasicType, FALSE );
						}
						else
						{
							hr = WBEM_E_TYPE_MISMATCH;
						}
					}
					else
					{
						FILETIME	ft;

						if ( wbemTime.GetFILETIME( &ft ) )
						{
							hr = SetRaw( 1, &ft, umiBasicType, FALSE );
						}
						else
						{
							hr = WBEM_E_TYPE_MISMATCH;
						}

					}

				}
				else
				{
					hr = WBEM_E_TYPE_MISMATCH;
				}

			}
			break;

			default:
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}
			break;


			case UMI_TYPE_IUNKNOWN:			return CIM_OBJECT;
		}	// SWITCH

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}

// Loads From a Variant
HRESULT CUmiValue::SetFromVariantArray( VARIANT* pVariant, ULONG umiType )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Clear at this level only
		CUmiValue::Clear();

		UMI_TYPE	umiBasicType = GetBasic( umiType );

		CSafeArray SA( V_ARRAY( pVariant ), V_VT( pVariant ) & ~VT_ARRAY,
						CSafeArray::no_delete | CSafeArray::bind );

		UINT	uNumValues = SA.Size();

		LPVOID	pvData = (LPVOID) new BYTE[ Size( umiBasicType ) * uNumValues ];

		if ( NULL != pvData )
		{
			ZeroMemory( pvData, Size( umiBasicType ) * uNumValues );

			// We should delete the pointer when we go away
			hr = SetRaw( uNumValues, pvData, umiBasicType, TRUE );

			// Now enum the values and set them in the final array.
			// We will probably want to speed this up for simple numeric
			// types

			for ( ULONG uCtr = 0; SUCCEEDED( hr ) && uCtr < uNumValues; uCtr++ )
			{
				switch( umiBasicType )
				{
					case UMI_TYPE_I1:
					case UMI_TYPE_UI1:
					{
						m_pValue->byteValue[uCtr] = SA.GetByteAt( uCtr );
					}
					break;

					case UMI_TYPE_I2:
					case UMI_TYPE_UI2:
					{
						m_pValue->wValue[uCtr] = SA.GetShortAt( uCtr );
					}
					break;

					case UMI_TYPE_I4:
					{
						m_pValue->lValue[uCtr] = SA.GetLongAt( uCtr );
					}
					break;

					case UMI_TYPE_UI4:
					{
						m_pValue->dwValue[uCtr] = SA.GetLongAt( uCtr );
					}
					break;

					case UMI_TYPE_I8:
					case UMI_TYPE_UI8:
					{
						BSTR	bstrVal = SA.GetBSTRAt( uCtr );
						CSysFreeMe	sfm( bstrVal );
						if ( NULL != bstrVal )
						{
							if ( UMI_TYPE_I8 == m_uType )
							{
								ReadI64( bstrVal, m_pValue->nValue64[uCtr]);
							}
							else
							{
								ReadUI64( bstrVal, m_pValue->uValue64[uCtr]);
							}
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}
					break;

					case UMI_TYPE_R4:
					{
						m_pValue->dblValue[uCtr] = SA.GetFloatAt( uCtr );
					}
					break;

					case UMI_TYPE_R8:
					{
						m_pValue->dblValue[uCtr] = SA.GetDoubleAt( uCtr );
					}
					break;

					case UMI_TYPE_BOOL:
					{
						m_pValue->bValue[uCtr] = ( SA.GetBoolAt( uCtr ) == VARIANT_TRUE ? TRUE : FALSE );
					}
					break;

					case UMI_TYPE_LPWSTR:
					{
						BSTR	bstrVal = SA.GetBSTRAt( uCtr );
						CSysFreeMe	sfm( bstrVal );
						if ( NULL != bstrVal )
						{
							m_pValue->pszStrValue[uCtr] = new WCHAR[wcslen( bstrVal ) + 1];

							if ( NULL != m_pValue->pszStrValue[uCtr] )
							{
								wcscpy( m_pValue->pszStrValue[uCtr], bstrVal );
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}
					break;

					case UMI_TYPE_FILETIME:
					case UMI_TYPE_SYSTEMTIME:
					{
						BSTR	bstrVal = SA.GetBSTRAt( uCtr );
						CSysFreeMe	sfm( bstrVal );
						if ( NULL != bstrVal )
						{
							CWbemTime	wbemTime;

							if ( wbemTime.SetDMTF( bstrVal ) )
							{
								if ( UMI_TYPE_SYSTEMTIME == umiType )
								{
									if ( !wbemTime.GetSYSTEMTIME( &m_pValue->sysTimeValue[uCtr] ) )
									{
										hr = WBEM_E_TYPE_MISMATCH;
									}
								}
								else
								{
									if ( !wbemTime.GetFILETIME( &m_pValue->fileTimeValue[uCtr] ) )
									{
										hr = WBEM_E_TYPE_MISMATCH;
									}
								}
							}
							else
							{
								hr = WBEM_E_TYPE_MISMATCH;
							}

						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}
					}
					break;

					case UMI_TYPE_OCTETSTRING:
					{
						IUnknown*	pUnk = SA.GetUnknownAt( uCtr );
						CReleaseMe	rm(pUnk);

						if ( NULL != pUnk )
						{
							_IWmiObject*	pObj = NULL;
							hr = pUnk->QueryInterface( IID__IWmiObject, (void**) &pObj );

							if ( SUCCEEDED( hr ) )
							{
								// Use the octet string abstractin to do our dirty work for us
								COctetStringClass	octstrClass;

								hr = octstrClass.FillOctetStr( pObj, &m_pValue->octetStr[uCtr] );
							}
							else
							{
								hr = WBEM_E_TYPE_MISMATCH;
							}
						}
						else
						{
							hr = WBEM_E_TYPE_MISMATCH;
						}
					}
					break;

					default:
					{
						hr = WBEM_E_TYPE_MISMATCH;
					}
					break;


	/*
					case UMI_TYPE_IUNKNOWN:			return CIM_OBJECT;
	*/
				}	// SWITCH

			}	// FOR


		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}


	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}


// Helper Function to deal with memory allocations for LPWSTRs
HRESULT CUmiValue::SetLPWSTRAt( LPWSTR val, ULONG uIndex, BOOL fAcquire )
{
	// Verofy index
	if ( !ValidIndex( uIndex ) )
	{
		return WBEM_E_NOT_FOUND;
	}

	// If we acquire, we just copy
	if ( !fAcquire )
	{
		if ( NULL != val )
		{
			LPWSTR	pszTemp = new WCHAR[wcslen(val) + 1];

			if ( NULL == pszTemp )
			{
				return WBEM_E_OUT_OF_MEMORY;
			}

			wcscpy( pszTemp, val );

			// A brief sleight of hand
			val = pszTemp;
		}
	
	}

	// Store the value
	m_pValue->pszStrValue[uIndex] = val;

	return WBEM_S_NO_ERROR;
}

// Helper Function to coerce types
BOOL CUmiValue::CanCoerce( ULONG umiType )
{
	// It's this way for now
	if (	UMI_TYPE_LPWSTR			==	m_uType	||
			UMI_TYPE_OCTETSTRING	==	m_uType	||
			UMI_TYPE_FILETIME		==	m_uType ||
			UMI_TYPE_SYSTEMTIME		==	m_uType ||
			UMI_TYPE_IDISPATCH		==	m_uType ||
			UMI_TYPE_IUNKNOWN		==	m_uType ||
			UMI_TYPE_VARIANT		==	m_uType ||
			UMI_TYPE_DISCOVERY		==	m_uType ||
			UMI_TYPE_UNDEFINED		==	m_uType )
	{
		return FALSE;
	}

	if (	UMI_TYPE_LPWSTR			==	umiType	||
			UMI_TYPE_OCTETSTRING	==	umiType	||
			UMI_TYPE_FILETIME		==	umiType ||
			UMI_TYPE_SYSTEMTIME		==	umiType ||
			UMI_TYPE_IDISPATCH		==	umiType ||
			UMI_TYPE_IUNKNOWN		==	umiType ||
			UMI_TYPE_VARIANT		==	umiType ||
			UMI_TYPE_DISCOVERY		==	umiType ||
			UMI_TYPE_UNDEFINED		==	umiType )
	{
		return FALSE;
	}

	return TRUE;
}

// Helper Function to coerce arrays of values.
HRESULT CUmiValue::CoerceToCIMTYPE( ULONG* puNumElements, ULONG* puBuffSize, CIMTYPE* pct, BYTE** pUmiValueDest )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	UMI_TYPE umiType = (UMI_TYPE) m_uType;
	CIMTYPE	ct = CUmiValue::UmiTypeToCIMTYPE( umiType );

	// Clear it all out
	*puNumElements = 0;
	*puBuffSize = 0;
	*pUmiValueDest = NULL;

	if ( NULL != pct )
	{
		*pct = ct;
	}

	if ( m_uNumValues > 0 )
	{

		BYTE* pUmiValueSrc = (BYTE*) m_pValue;

		int	nSizeUmi = CUmiValue::Size( umiType );
		int nSizeCIM = CType::GetLength( ct );

		// If It's a string, we need to alloc a linear buffer to make this fly.
		// In other cases, we can just take the raw buffer
		if ( UMI_TYPE_LPWSTR == m_uType )
		{
			LPWSTR*	pszTemp = (LPWSTR*) m_pValue;

			ULONG	uBuffSize = 0;

			for ( ULONG uCtr = 0; uCtr < m_uNumValues; uCtr++ )
			{
				uBuffSize += ( wcslen( pszTemp[uCtr] ) + 1 );
			}

			// Multiply by two, then allocate a buffer
			uBuffSize *= 2;

			LPBYTE	pbData = (BYTE*) new WCHAR[uBuffSize];

			if ( NULL != pbData )
			{
				LPWSTR pszCurrStr = (LPWSTR) pbData;
				for ( uCtr = 0, pszTemp = (LPWSTR*) m_pValue; uCtr < m_uNumValues; uCtr++ )
				{
					wcscpy( pszCurrStr, pszTemp[uCtr] );
					pszCurrStr += ( wcslen( pszTemp[uCtr] ) + 1 );
				}
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

			*pUmiValueDest = pbData;
			*puNumElements = m_uNumValues;
			*puBuffSize = uBuffSize;			

		}
		else if ( UMI_TYPE_OCTETSTRING == m_uType )
		{
			// We can't convert more than a single OCTET String, as that would imply a
			// Multidimensional array

			if ( m_uNumValues == 1 )
			{
				LPBYTE	pbData = new BYTE[m_pValue->octetStr[0].uLength];

				if ( NULL != pbData )
				{
					CopyMemory( pbData, m_pValue->octetStr[0].lpValue, m_pValue->octetStr[0].uLength );
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

				*pUmiValueDest = pbData;

				// Number of elements is length since this is a BYTE string
				*puNumElements = m_pValue->octetStr[0].uLength;
				*puBuffSize = m_pValue->octetStr[0].uLength;			
					
			}
			else
			{
				hr = WBEM_E_TYPE_MISMATCH;
			}

		}
		else
		{
			// Copy the smallest number of bytes, or we may get screwy values
			int nCopySize = min( nSizeUmi, nSizeCIM );

			LPBYTE	pbData = new BYTE[ m_uNumValues * nSizeCIM ];

			if ( NULL != pbData )
			{
				ZeroMemory( pbData, m_uNumValues * nSizeCIM );

				// Now copy data by bytes.  If the sizes are the same, we just
				// do a blind MemCopy
				
				if ( nSizeUmi == nSizeCIM )
				{
					CopyMemory( pbData, pUmiValueSrc, nCopySize * m_uNumValues );
				}
				else
				{
					LPBYTE pbTempDest = pbData;
					LPBYTE pbTempSrc = pUmiValueSrc;

					for ( ULONG uCtr = 0; uCtr < m_uNumValues; uCtr++ )
					{
						CopyMemory( pbTempDest, pbTempSrc, nCopySize );
					}
				}

				*pUmiValueDest = pbData;
				*puNumElements = m_uNumValues;
				*puBuffSize = nSizeCIM * m_uNumValues;			

			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

		}	// Else copying raw value

	}	// IF we've got > 0 values

	return hr;
}

// Helper Function to coerce types
HRESULT CUmiValue::CoerceTo( ULONG uType, UMI_VALUE* pUmiValueSrc, UMI_VALUE* pUmiValueDest )
{
	UMI_TYPE umiType = GetBasic( uType );

	CIMTYPE	ctSource = UmiTypeToCIMTYPE( m_uType ),
			ctDest = UmiTypeToCIMTYPE( umiType );

	CVar	var;

	HRESULT hr = CUntypedValue::FillCVarFromUserBuffer( ctSource, &var, Size(m_uType), pUmiValueSrc );

	if ( SUCCEEDED( hr ) )
	{
		if ( var.ChangeTypeTo( CType::GetVARTYPE( ctDest ) ) )
		{
			CopyMemory( pUmiValueDest, var.GetRawData(), Size( umiType ) );
		}
		else
		{
			hr = WBEM_E_TYPE_MISMATCH;
		}
	}

	return hr;
}

// Helper Function to coerce types
HRESULT CUmiValue::Coerce( ULONG uType )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	UMI_TYPE	umiType = GetBasic( uType );
	UMI_VALUE	tempValue;
	UMI_VALUE*	pValue = &tempValue;

	// Check if there's even a point
	if ( !CanCoerce( umiType ) )
	{
		return WBEM_E_TYPE_MISMATCH;
	}

	// We'll need these a bunch
	int		nSizeSrc = Size( m_uType ),
			nSizeDest = Size( umiType );


	// If we have more than 1 element, we need to go through 1 element at a time
	if ( m_uNumValues > 1 )
	{
		BYTE*	pTemp = new BYTE[m_uNumValues * nSizeDest];

		if ( NULL != pTemp )
		{
			ZeroMemory( pTemp, m_uNumValues * nSizeDest );
			pValue = (UMI_VALUE*) pTemp;
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	// Convenient for casting
	BYTE*	pSource = (BYTE*) m_pValue;
	BYTE*	pDest = (BYTE*) pValue;

	// Coerce each value as we go
	for ( ULONG uCtr = 0; SUCCEEDED(hr) && uCtr < m_uNumValues; uCtr++ )
	{
		hr = CoerceTo( umiType, (UMI_VALUE*) pSource, (UMI_VALUE*) pDest );
		pSource += nSizeSrc;
		pDest += nSizeDest;
	}

	if ( SUCCEEDED( hr ) )
	{
		ULONG uNumValues = m_uNumValues;

		// Clear us out
		CUmiValue::Clear();

		// The value should be acqired if it's > 1.
		hr = SetRaw( uNumValues, pValue, umiType, ( uNumValues > 1 ) );

		// We CAN delete this
		m_fCanDelete = TRUE;

	}

	// Cleanup as necessary
	if ( FAILED( hr ) )
	{
		if ( pValue != &tempValue )
		{
			delete pValue;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umitemp.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIWRAP.CPP

Abstract:

  CUmiObjectWrapper implementation.

  Implements an aggregable wrapper around a UMI Object.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umiwrap.h"
#include <corex.h>
#include "strutils.h"
#include "umiprop.h"
#include "umiprox.h"

//***************************************************************************
//
//  CUMIObjectWrapper::CUMIObjectWrapper
//
//***************************************************************************
// ok
CUMIObjectWrapper::CUMIObjectWrapper( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWbemClassObject( this ),
	m_XWbemClassObjectEx( this ),
	m_XUmiObject( this ),
	m_XWbemUMIObjectWrapper( this ),
	m_XUmiCustIntfFactory( this ),
	m_XObjectMarshal( this ),
	m_pUMIObj( NULL ),
	m_pUMISchemaObj( NULL ),
	m_EnumPropData(),
	m_fDirty( FALSE ),
	m_fHaveSchemaObject( FALSE ),
	m_fIsClass( FALSE )
{
    m_Lock.SetData(&m_LockData);
}
    
//***************************************************************************
//
//  CUMIObjectWrapper::~CUMIObjectWrapper
//
//***************************************************************************
// ok
CUMIObjectWrapper::~CUMIObjectWrapper()
{

	// In case one was running
	EndEnumeration();

	// Cleanup our schema objects
	if ( NULL != m_pUMIObj )
	{
		m_pUMIObj->Release();
	}

	if ( NULL != m_pUMISchemaObj )
	{
		m_pUMISchemaObj->Release();
	}
}

void* CUMIObjectWrapper::GetInterface(REFIID riid)
{
	if ( riid == IID_IUnknown || riid == IID_IWbemClassObject )
	{
		return &m_XWbemClassObject;
	}
	else if ( riid == IID_IWbemClassObjectEx )
	{
		return &m_XWbemClassObjectEx;
	}
	else if ( riid == IID_IUmiObject )
	{
		return &m_XUmiObject;
	}
	else if ( riid == IID_IUmiBaseObject )
	{
		return &m_XUmiObject;
	}
	else if ( riid == IID_IUmiPropList )
	{
		return &m_XUmiObject;
	}
	else if ( riid == IID__IWbemUMIObjectWrapper )
	{
		return &m_XWbemUMIObjectWrapper;
	}
	else if ( riid == IID_IMarshal )
	{
		return &m_XObjectMarshal;
	}

    return NULL;
}

/* IWbemClassObject methods */

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetQualifierSet(IWbemQualifierSet** pQualifierSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetQualifierSet( pQualifierSet );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
									long* plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Get( wszName, lFlags, pVal, pctType, plFlavor );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
	// Pass through to the wrapper object
	return m_pObject->Put( wszName, lFlags, pVal, ctType );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Delete(LPCWSTR wszName)
{
	// Pass through to the wrapper object
	return m_pObject->Delete( wszName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
											SAFEARRAY** pNames)
{
	// Pass through to the wrapper object
	return m_pObject->GetNames( wszName, lFlags, pVal, pNames );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::BeginEnumeration(long lEnumFlags)
{
	// Pass through to the wrapper object
	return m_pObject->BeginEnumeration( lEnumFlags );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                long* plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Next( lFlags, pName, pVal, pctType, plFlavor );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::EndEnumeration()
{
	// Pass through to the wrapper object
	return m_pObject->EndEnumeration();
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** pQualifierSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyQualifierSet( wszProperty, pQualifierSet );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Clone(IWbemClassObject** pCopy)
{
	// Pass through to the wrapper object
	return m_pObject->Clone( pCopy );

}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetObjectText(long lFlags, BSTR* pMofSyntax)
{
	// Pass through to the wrapper object
	return m_pObject->GetObjectText( lFlags, pMofSyntax );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
	// Pass through to the wrapper object
	return m_pObject->CompareTo( lFlags, pCompareTo );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyOrigin( wszProperty, pstrClassName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::InheritsFrom(LPCWSTR wszClassName)
{
	// Pass through to the wrapper object
	return m_pObject->InheritsFrom( wszClassName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass)
{
	// Pass through to the wrapper object
	return m_pObject->SpawnDerivedClass( lFlags, ppNewClass );

}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance)
{
	// Pass through to the wrapper object
	return m_pObject->SpawnInstance( lFlags, ppNewInstance );

}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                        IWbemClassObject** ppOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethod( wszName, lFlags, ppInSig, ppOutSig );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                        IWbemClassObject* pOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->PutMethod( wszName, lFlags, pInSig, pOutSig );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::DeleteMethod(LPCWSTR wszName)
{
	// Pass through to the wrapper object
	return m_pObject->DeleteMethod( wszName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::BeginMethodEnumeration(long lFlags)
{
	// Pass through to the wrapper object
	return m_pObject->BeginMethodEnumeration( lFlags );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::NextMethod(long lFlags, BSTR* pstrName, 
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->NextMethod( lFlags, pstrName, ppInSig, ppOutSig );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::EndMethodEnumeration()
{
	// Pass through to the wrapper object
	return m_pObject->EndMethodEnumeration();
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethodQualifierSet( wszName, ppSet );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethodOrigin( wszMethodName, pstrClassName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObjectEx::PutEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	// Pass through to the wrapper object
	return m_pObject->PutEx( wszName, lFlags, pvFilter, pvInVals );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObjectEx::DeleteEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	// Pass through to the wrapper object
	return m_pObject->DeleteEx( wszName, lFlags, pvFilter, pvInVals );
}

// * IUmiPropList functions */

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp )
{
	return m_pObject->Put( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp )
{
	return m_pObject->Get( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	return m_pObject->GetAt( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp )
{
	return m_pObject->GetAs( pszName, uFlags, uCoercionType, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::FreeMemory( ULONG uReserved, LPVOID pMem )
{
	return m_pObject->FreeMemory( uReserved, pMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Delete( LPCWSTR pszName, ULONG uFlags )
{
	return m_pObject->Delete( pszName, uFlags );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps )
{
	return m_pObject->GetProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps )
{
	return m_pObject->PutProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	return m_pObject->PutFrom( pszName, uFlags, uBufferLength, pExistingMem );
}

/* IUmiBaseObject Methods */

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetLastStatus( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj )
{
	return m_pObject->GetLastStatus( uFlags, puSpecificStatus, riid, pStatusObj );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetInterfacePropList( ULONG uFlags, IUmiPropList **pPropList )
{
	return m_pObject->GetInterfacePropList( uFlags, pPropList );
}

		/* IUmiObject Methods */
// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Clone( ULONG uFlags, REFIID riid, LPVOID *pCopy )
{
	return m_pObject->Clone( uFlags, riid, pCopy );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Refresh( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames )
{
	return m_pObject->Refresh( uFlags, uNameCount, pszNames );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Commit( ULONG uFlags )
{
	return m_pObject->Commit( uFlags );
}

// See WBEMINT.IDL for Documentation
HRESULT CUMIObjectWrapper::XWbemUMIObjectWrapper::SetObject( long lFlags, IUnknown* pUnk )
{
	return m_pObject->SetObject( lFlags, pUnk );
}

/* IMarshal Pass-thrus */
STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
	// Pass through to the wrapper object
	return m_pObject->GetUnmarshalClass( riid, pv, dwDestContext, pvReserved, mshlFlags, pClsid );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
	// Pass through to the wrapper object
	return m_pObject->GetMarshalSizeMax( riid, pv, dwDestContext, pvReserved, mshlFlags, plSize );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::MarshalInterface(IStream* pStream, REFIID riid, void* pv,
													DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
	// Pass through to the wrapper object
	return m_pObject->MarshalInterface( pStream, riid, pv, dwDestContext, pvReserved, mshlFlags );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv)
{
	// Pass through to the wrapper object
	return m_pObject->UnmarshalInterface( pStream, riid, ppv );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::ReleaseMarshalData(IStream* pStream)
{
	// Pass through to the wrapper object
	return m_pObject->ReleaseMarshalData( pStream );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::DisconnectObject(DWORD dwReserved)
{
	// Pass through to the wrapper object
	return m_pObject->DisconnectObject( dwReserved );
}

/* IUmiCustomInterfaceFactory pass-thrus*/

STDMETHODIMP CUMIObjectWrapper::XUmiCustIntfFactory::GetCLSIDForIID( REFIID riid, long lFlags, CLSID *pCLSID )
{
	// Pass through to the wrapper object
	return m_pObject->GetCLSIDForIID( riid, lFlags, pCLSID );
}

STDMETHODIMP CUMIObjectWrapper::XUmiCustIntfFactory::GetObjectByCLSID( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface )
{
	// Pass through to the wrapper object
	return m_pObject->GetObjectByCLSID( clsid, pUnkOuter, dwClsContext, riid, lFlags,  ppInterface );
}

STDMETHODIMP CUMIObjectWrapper::XUmiCustIntfFactory::GetCLSIDForNames( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID )
{
	// Pass through to the wrapper object
	return m_pObject->GetCLSIDForNames( rgszNames,	cNames, lcid, rgDispId, lFlags,	pCLSID );
}

// This is the actual implementation

/* IWbemClassObject methods */

HRESULT CUMIObjectWrapper::GetQualifierSet(IWbemQualifierSet** pQualifierSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
									long* plFlavor)
{
	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		UMI_PROPERTY_VALUES*	pValues = NULL;

		// Call into the UMI Object

		HRESULT hr = WBEM_S_NO_ERROR;
		
		// Call into the UMI Object.  If the user is trying to access a system property (one that starts
		// with a "__"), then we need to get it from the object's interface prop list.

		if ( wcslen( wszName ) > 2 && wszName[0] == '_' && wszName[1] == '_' )
		{
			IUmiPropList*	pUmiPropList = NULL;

			hr = m_pUMIObj->GetInterfacePropList( 0L, &pUmiPropList );
			CReleaseMe	rm( pUmiPropList );

			if ( SUCCEEDED( hr ) )
			{
				hr = pUmiPropList->Get( wszName, 0, &pValues );
			}

			// It's a system property
			if ( NULL != plFlavor )
			{
				*plFlavor = WBEM_FLAVOR_ORIGIN_SYSTEM;
			}

		}
		else
		{
			// Now try setting the actual value
			hr = m_pUMIObj->Get( wszName, 0, &pValues );

			// It's a system property
			if ( NULL != plFlavor )
			{
				*plFlavor = WBEM_FLAVOR_ORIGIN_SYSTEM;
			}

		}


		if ( SUCCEEDED( hr ) )
		{
			// Convert to a property array and extract the value as a
			// VARIANT.

			CUmiPropertyArray	umiPropArray;

			hr = umiPropArray.Set( pValues );

			if ( SUCCEEDED( hr ) )
			{
				CUmiProperty*	pActualProp = NULL;

				hr = umiPropArray.GetAt( 0L, &pActualProp );

				if ( SUCCEEDED( hr ) )
				{
					if ( NULL != pVal )
					{
						hr = pActualProp->FillVariant( pVal );
					}

					if ( NULL != pctType )
					{
						*pctType = pActualProp->GetPropertyCIMTYPE();
					}

				}	// IF got the value

			}	// IF Set Array

			m_pUMIObj->FreeMemory( 0L, pValues );
		}

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	HRESULT hr = WBEM_S_NO_ERROR;

	// If we don't know the CIMTYPE, then we need to get it from the property
	if ( 0 == ctType )
	{
		hr = GetPropertyCimType( wszName, &ctType );
	}	// IF 0 == ctType

	// We don't know the CIMTYPE, so we need to get it from the property
	if ( SUCCEEDED( hr ) )
	{
		// Now just put the variant
		hr = PutVariant( wszName, UMI_OPERATION_UPDATE, pVal, ctType );
	}	// IF A-OK

	return hr;
}

HRESULT CUMIObjectWrapper::Delete(LPCWSTR wszName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	return m_pUMIObj->Delete( wszName, 0L );
}

HRESULT CUMIObjectWrapper::GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
											SAFEARRAY** pNames)
{
	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// We must have a schema object for this to work
		HRESULT hr = SetSchemaObject();

		if ( FAILED( hr ) )
		{
			return hr;
		}

		// Workaround for Refresh Bug
		if ( !m_fDirty )
		{
			hr = m_pUMIObj->Refresh( 0L/*UMI_FLAG_REFRESH_PARTIAL*/, 0L, NULL );
		}

		if ( SUCCEEDED( hr ) )
		{
			UMI_PROPERTY_VALUES*	pProps = NULL;

			HRESULT	hr = m_pUMIObj->GetProps( NULL, 0, UMI_FLAG_GETPROPS_NAMES, &pProps );

			if ( SUCCEEDED( hr ) )
			{
				try
				{

					CUmiPropertyArray	umiPropArray;

					// By Default it will acquire values without deleting
					hr = umiPropArray.Set( pProps );

					if ( SUCCEEDED( hr ) )
					{
						CSafeArray SA(VT_BSTR, CSafeArray::auto_delete, umiPropArray.GetSize() );

						// Now add each property name (this will throw an exception if anything
						// beefs).

						for ( ULONG uCtr = 0; SUCCEEDED(hr) && uCtr < umiPropArray.GetSize(); uCtr++ )
						{
							CUmiProperty*	pProp = NULL;
							
							hr = umiPropArray.GetAt( uCtr, &pProp );

							if ( SUCCEEDED( hr ) )
							{

								SA.AddBSTR( (LPWSTR) pProp->GetPropertyName() );

							}
						}

						if ( SUCCEEDED ( hr ) )
						{
							// Create SAFEARRAY and return
							// ===========================

							SA.Trim();

							// Now we make a copy, since the member array will be autodestructed (this
							// allows us to write exception-handling code
							*pNames = SA.GetArrayCopy();
						}

					}	// IF successfully set the properties

				}
				catch( CX_MemoryException )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
				catch(...)
				{
					hr = WBEM_E_CRITICAL_ERROR;
				}

				// Clean up the memory
				m_pUMIObj->FreeMemory( 0L, pProps );
			}

		}	// Did a full refresh of the object

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::BeginEnumeration(long lEnumFlags)
{
	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// We must have a schema object for this to work
		HRESULT hr = SetSchemaObject();

		if ( SUCCEEDED( hr ) )
		{
			hr = m_EnumPropData.BeginEnumeration( lEnumFlags, m_pUMIObj, m_pUMISchemaObj, !m_fDirty );
		}

		return hr;

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT CUMIObjectWrapper::Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                long* plFlavor)
{
	try
	{

		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);
		return m_EnumPropData.Next( lFlags, pName, pVal, pctType, plFlavor, m_pUMIObj, m_pUMISchemaObj );

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::EndEnumeration()
{
	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		return m_EnumPropData.EndEnumeration( m_pUMIObj, m_pUMISchemaObj );
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** pQualifierSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::Clone(IWbemClassObject** pCopy)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Hit the equivalent function, then create a wrapper and 
	IUmiObject*	pNewUmiObj = NULL;
	HRESULT	hr = m_pUMIObj->Clone( 0L, IID_IUmiObject, (void**) &pNewUmiObj );
	CReleaseMe	rm(pNewUmiObj);

	if ( SUCCEEDED( hr ) )
	{
		// Set the underlying object in a new wrapper
		CUMIObjectWrapper*	pNewWrapper = new CUMIObjectWrapper( m_pControl, m_pOuter );

		if ( NULL != pNewWrapper )
		{
			hr = pNewWrapper->m_XWbemUMIObjectWrapper.SetObject( 0L, pNewUmiObj );

			if ( SUCCEEDED( hr ) )
			{
				hr = pNewWrapper->QueryInterface( IID_IWbemClassObject, (void**) pCopy );
			}

			// Cleanup in the event of an error
			if ( FAILED( hr ) )
			{
				delete pNewWrapper;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

HRESULT CUMIObjectWrapper::GetObjectText(long lFlags, BSTR* pMofSyntax)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// We must have a schema object for this to work
	HRESULT hr = SetSchemaObject();

	if ( FAILED( hr ) )
	{
		return hr;
	}

	CWbemClass*	pClassObj = new CWbemClass;
	CReleaseMe	rm1( (IWbemClassObject*) pClassObj );

	if ( NULL != pClassObj )
	{
		// Initialize the class object
		pClassObj->InitEmpty();

		// Get the object class name and write that into the object

		VARIANT	vTemp;
		hr = Get( L"__CLASS", 0L, &vTemp, NULL, NULL );

		if ( SUCCEEDED( hr ) )
		{
			hr = pClassObj->Put( L"__CLASS", 0L, &vTemp, CIM_STRING );
			VariantClear( &vTemp );
		}

		if ( SUCCEEDED( hr ) )
		{
			CUmiPropEnumData	enumPropData;

			// We'll need to do this internally so we don't overrun an enum in process
			hr = enumPropData.BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY, m_pUMIObj, m_pUMISchemaObj, FALSE );

			if ( SUCCEEDED( hr ) )
			{
				while ( S_OK == hr )
				{
					BSTR	bstrProp = NULL;
					CIMTYPE	ct;

					// Gets  all the proper values
					hr = enumPropData.Next( 0L, &bstrProp, NULL, &ct, NULL, m_pUMIObj, m_pUMISchemaObj );
					CSysFreeMe	sfm(bstrProp);

					if ( WBEM_S_NO_ERROR == hr )
					{
						hr = pClassObj->Put( bstrProp, 0L, NULL, ct );
					}

				}
				
				enumPropData.EndEnumeration( m_pUMIObj, m_pUMISchemaObj );
			}

			// This means we completed the enum and put properties properly
			if ( WBEM_S_NO_MORE_DATA == hr )
			{
				IWbemClassObject*	pInst = NULL;

				// Spawn an instance - now reenumerate the properties and Put them
				hr = pClassObj->SpawnInstance( 0L, &pInst );
				CReleaseMe	rm2(pInst);

				if ( SUCCEEDED( hr ) )
				{
					CUmiPropEnumData	enumPropData;

					// We'll need to do this internally so we don't overrun an enum in process
					hr = enumPropData.BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY, m_pUMIObj, m_pUMISchemaObj, FALSE );

					if ( SUCCEEDED( hr ) )
					{
						while ( S_OK == hr )
						{
							VARIANT	v;
							BSTR	bstrProp = NULL;
							CIMTYPE	ct;

							VariantInit( &v );

							// Gets  all the proper values
							hr = enumPropData.Next( 0L, &bstrProp, &v, &ct, NULL, m_pUMIObj, m_pUMISchemaObj );
							CSysFreeMe	sfm(bstrProp);

							if ( WBEM_S_NO_ERROR == hr )
							{
								hr = pInst->Put( bstrProp, 0L, &v, ct );
							}

							VariantClear( &v );
						}
						
						enumPropData.EndEnumeration( m_pUMIObj, m_pUMISchemaObj );
					}

					// Now, if the enum successfully completed, we can
					// use the classic WMI Object to get the MOF Text
					if ( WBEM_S_NO_MORE_DATA == hr )
					{
						hr = pInst->GetObjectText( 0L, pMofSyntax );
					}

				}	// IF Spawned an instance

			}	// IF successfully created class

		}	// IF Wrote Class Name

	}	// IF allocated class object
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

HRESULT CUMIObjectWrapper::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::InheritsFrom(LPCWSTR wszClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                        IWbemClassObject** ppOutSig)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                        IWbemClassObject* pOutSig)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::DeleteMethod(LPCWSTR wszName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::BeginMethodEnumeration(long lFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::NextMethod(long lFlags, BSTR* pstrName, 
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
				   {
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::EndMethodEnumeration()
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

/* IWbemClassObjectEx functions */
HRESULT CUMIObjectWrapper::PutEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// Make sure parameters are correct
		if ( lFlags & ~WBEM_MASK_PUTEX_OPERATION || NULL == pvInVals )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Only supported operation here is Append - which means we basically ignore
		// the pvFilter parameter
		if ( ( lFlags & WBEM_MASK_PUTEX_OPERATION ) != WBEM_FLAG_PUTEX_APPEND || NULL == pvFilter )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// We don't know the CIMTYPE, so we need to get it from the property
		CIMTYPE	ctType;

		hr = GetPropertyCimType( wszName, &ctType );

		if ( SUCCEEDED( hr ) )
		{
			hr = PutVariant( wszName, UMI_OPERATION_APPEND, pvInVals, ctType );
		}	// IF A-OK

	}	// try
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	return hr;
}

HRESULT CUMIObjectWrapper::DeleteEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// Make sure parameters are correct
		if ( lFlags & ~WBEM_MASK_DELETEEX_OPERATION || NULL == pvInVals )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		if ( ( ( lFlags & WBEM_MASK_PUTEX_OPERATION ) != WBEM_FLAG_PUTEX_DELETE_FIRST_MATCH && 
			( lFlags & WBEM_MASK_PUTEX_OPERATION ) != WBEM_FLAG_DELETE_ALL_MATCHES ) ||
			NULL == pvFilter )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// We don't know the CIMTYPE, so we need to get it from the property
		CIMTYPE	ctType;

		hr = GetPropertyCimType( wszName, &ctType );

		if ( SUCCEEDED( hr ) )
		{
			ULONG	ulOperation = ( lFlags & WBEM_MASK_PUTEX_OPERATION ) == WBEM_FLAG_PUTEX_DELETE_FIRST_MATCH ?
						UMI_OPERATION_DELETE_FIRST_MATCH : UMI_OPERATION_DELETE_ALL_MATCHES;

			hr = PutVariant( wszName, ulOperation, pvInVals, ctType );
		}	// IF A-OK

	}	// try
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	return hr;
}


// * IUmiPropList functions */

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Put( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Get( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetAt( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetAs( pszName, uFlags, uCoercionType, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::FreeMemory( ULONG uReserved, LPVOID pMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->FreeMemory( uReserved, pMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Delete( LPCWSTR pszName, ULONG uFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Delete( pszName, uFlags );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->PutProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->PutFrom( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetLastStatus( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetLastStatus( uFlags, puSpecificStatus, riid, pStatusObj );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetInterfacePropList( ULONG uFlags, IUmiPropList **pPropList )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetInterfacePropList( uFlags, pPropList );
}

		/* IUmiObject Methods */
// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Clone( ULONG uFlags, REFIID riid, LPVOID *pCopy )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Clone( uFlags, riid, pCopy );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Refresh( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Refresh( uFlags, uNameCount, pszNames );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Commit( ULONG uFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	HRESULT hr = m_pUMIObj->Commit( uFlags );

	if ( SUCCEEDED( hr ) )
	{
		m_fDirty = FALSE;
	}

	return hr;
}

// See WBEMINT.IDL for Documentation
HRESULT CUMIObjectWrapper::SetObject( long lFlags, IUnknown* pUnk )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	if ( 0L != lFlags || NULL == pUnk )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	IUmiObject*	pObj = NULL;

	HRESULT hr = pUnk->QueryInterface( IID_IUmiObject, (void**) &pObj );

	if ( SUCCEEDED( hr ) )
	{
		if ( NULL != m_pUMIObj )
		{
			m_pUMIObj->Release();
		}

		// Store the object and get on with our lives
		m_pUMIObj = pObj;
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;

}

/* IMarshal Methods */

HRESULT CUMIObjectWrapper::GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Onlyb allows in-proc marshaling for now
	if ( MSHCTX_INPROC != dwDestContext )
	{
		return E_FAIL;
	}

    *pClsid = CLSID_UmiObjectWrapperProxy;

	return S_OK;
}

HRESULT CUMIObjectWrapper::GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Only allows in-proc marshaling for now
	if ( MSHCTX_INPROC != dwDestContext )
	{
		return E_FAIL;
	}

	// How long is it?
	*plSize = CUMIDataPacket::GetMarshalSize();

    return S_OK;
}

HRESULT CUMIObjectWrapper::MarshalInterface(IStream* pStream, REFIID riid, void* pv,
													DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Onlyb allows in-proc marshaling for now
	if ( MSHCTX_INPROC != dwDestContext )
	{
		return E_FAIL;
	}

	// Marshal into the stream
	UMI_MARSHALPACKET_DATAPACKET	packet;
	CUMIDataPacket	umiDataPacket;

	HRESULT	hr = umiDataPacket.Init( &packet, this );

	if ( SUCCEEDED( hr ) )
	{
		hr = pStream->Write((void*)&packet, CUMIDataPacket::GetMarshalSize(), NULL);

		if ( FAILED(hr) )
		{
			packet.m_pUmiObjWrapper->Release();
		}
	}

	return hr;
}

HRESULT CUMIObjectWrapper::UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return E_UNEXPECTED;
}

HRESULT CUMIObjectWrapper::ReleaseMarshalData(IStream* pStream)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return E_UNEXPECTED;
}

HRESULT CUMIObjectWrapper::DisconnectObject(DWORD dwReserved)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return E_UNEXPECTED;
}

/* 	IUmiCustomInterfaceFactory Methods */
HRESULT CUMIObjectWrapper::GetCLSIDForIID( REFIID riid, long lFlags, CLSID *pCLSID )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	IUmiCustomInterfaceFactory*	pInterfaceFactory = NULL;

	HRESULT	hr = m_pUMIObj->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pInterfaceFactory );
	CReleaseMe	rm(pInterfaceFactory);

	if ( SUCCEEDED( hr ) )
	{
		hr = pInterfaceFactory->GetCLSIDForIID( riid, lFlags, pCLSID );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::GetObjectByCLSID( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	IUmiCustomInterfaceFactory*	pInterfaceFactory = NULL;

	HRESULT	hr = m_pUMIObj->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pInterfaceFactory );
	CReleaseMe	rm(pInterfaceFactory);

	if ( SUCCEEDED( hr ) )
	{
		hr = pInterfaceFactory->GetObjectByCLSID( clsid, pUnkOuter, dwClsContext, riid, lFlags,  ppInterface );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::GetCLSIDForNames( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	IUmiCustomInterfaceFactory*	pInterfaceFactory = NULL;

	HRESULT	hr = m_pUMIObj->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pInterfaceFactory );
	CReleaseMe	rm(pInterfaceFactory);

	if ( SUCCEEDED( hr ) )
	{
		hr = pInterfaceFactory->GetCLSIDForNames( rgszNames,	cNames, lcid, rgDispId, lFlags,	pCLSID );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::Lock(long lFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
    m_Lock.Lock();
	return WBEM_S_NO_ERROR;
}

HRESULT CUMIObjectWrapper::Unlock(long lFlags)
{
    m_Lock.Unlock();
	return WBEM_S_NO_ERROR;
}

IUmiObject*	CUMIObjectWrapper::GetUmiObject( void )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	if ( NULL != m_pUMIObj )
	{
		m_pUMIObj->AddRef();
	}

	IUmiObject*	pReturn = m_pUMIObj;
	return pReturn;
}

// Enumeration helpers - caller is responsible for thread safety
HRESULT CUMIObjectWrapper::CUmiPropEnumData::BeginEnumeration( long lEnumFlags, IUmiObject* pUMIObj, IUmiObject* pSchemaObj, BOOL fRefresh )
{
	try
	{

		HRESULT	hr = WBEM_S_NO_ERROR;

		// All we really support are the origin flags
        long lOriginFlags = lEnumFlags & WBEM_MASK_CONDITION_ORIGIN;
		long lClassFlags = lEnumFlags & WBEM_MASK_CLASS_CONDITION;

        BOOL bKeysOnly = lEnumFlags & WBEM_FLAG_KEYS_ONLY;
        BOOL bRefsOnly = lEnumFlags & WBEM_FLAG_REFS_ONLY;

		// We allow CLASS Flags only on classes
		if( lClassFlags || bKeysOnly | bRefsOnly )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        if( lEnumFlags & ~WBEM_MASK_CONDITION_ORIGIN & ~WBEM_FLAG_KEYS_ONLY &
                ~WBEM_FLAG_REFS_ONLY & ~WBEM_MASK_CLASS_CONDITION )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

		if ( UMIWRAP_INVALID_INDEX == m_lPropIndex )
		{

			// Workaround for Refresh Bug
			if ( fRefresh )
			{
				// Refresh the object and get all the properties
				hr = pSchemaObj->Refresh( 0L/*UMI_FLAG_REFRESH_PARTIAL*/, 0L, NULL );
			}

			if ( SUCCEEDED( hr ) )
			{
				if (	lOriginFlags != WBEM_FLAG_NONSYSTEM_ONLY	&&
						lOriginFlags != WBEM_FLAG_LOCAL_ONLY		&&
						lOriginFlags != WBEM_FLAG_PROPAGATED_ONLY )
				{
					IUmiPropList*	pPropList = NULL;

					hr = pUMIObj->GetInterfacePropList( 0L, &pPropList );
					CReleaseMe	rm( pPropList );

					if ( SUCCEEDED( hr ) )
					{

						hr = pPropList->GetProps( NULL, 0, UMI_FLAG_GETPROPS_NAMES, &m_pUmiSysProperties );

						if ( SUCCEEDED( hr ) )
						{
							m_pSysPropArray = new CUmiPropertyArray;

							if ( NULL != m_pSysPropArray )
							{
								hr = m_pSysPropArray->Set( m_pUmiSysProperties );
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}

						}	// IF GetProps Succeeded

					}	// Get the property list

				}	// If we need system properties
				else
				{
					// Make an empty array
					m_pSysPropArray = new CUmiPropertyArray;

					if ( NULL == m_pSysPropArray )
					{
						hr = m_pSysPropArray->Set( m_pUmiSysProperties );
					}
				}

				// Only continue if we're okay
				if ( SUCCEEDED( hr ) )
				{

					// We'll just make an empty array if only system properties are required
					if ( lOriginFlags != WBEM_FLAG_SYSTEM_ONLY )
					{

						// Get this from the schema object
						hr = pSchemaObj->GetProps( NULL, 0, UMI_FLAG_GETPROPS_NAMES, &m_pUmiProperties );

						if ( SUCCEEDED( hr ) )
						{

							m_pPropArray = new CUmiPropertyArray;

							if ( NULL != m_pPropArray )
							{
								hr = m_pPropArray->Set( m_pUmiProperties );
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}


						}	// IF we got the properties

					}	// IF should have non-system props
					else
					{
						m_pPropArray = new CUmiPropertyArray;

						if ( NULL == m_pPropArray )
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}

					}

				}	// IF everything's okay

				
				// Cleanup if we beefed
				if ( FAILED( hr ) )
				{
					EndEnumeration( pUMIObj, pSchemaObj );
				}
				else
				{
					m_lPropIndex = UMIWRAP_START_INDEX;
					m_lEnumFlags = lEnumFlags;
				}


			}	// IF Refresh succeeds

		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT CUMIObjectWrapper::CUmiPropEnumData::Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                long* plFlavor, IUmiObject* pUMIObj, IUmiObject* pSchemaObj)
{
	try
	{

		HRESULT	hr = WBEM_S_NO_ERROR;

		if ( m_lPropIndex >= UMIWRAP_START_INDEX )
		{

			// The index should be less than the size of both arrays combined
			long	lTotalSize = m_pSysPropArray->GetSize() + m_pPropArray->GetSize();

			if ( m_lPropIndex < lTotalSize && 
				++m_lPropIndex < lTotalSize )
			{
				IUmiPropList*			pPropList = NULL;
				CUmiProperty*			pProp = NULL;

				// Make sure we retrieve the property and value from the proper place
				if ( m_lPropIndex < m_pSysPropArray->GetSize() )
				{
					hr = m_pSysPropArray->GetAt( m_lPropIndex, &pProp );

					if ( SUCCEEDED( hr ) )
					{
						hr = pUMIObj->GetInterfacePropList( 0L, &pPropList );
					}

					// It's a system property
					if ( NULL != plFlavor )
					{
						*plFlavor = WBEM_FLAVOR_ORIGIN_SYSTEM;
					}
				}
				else
				{
					// We're reading from the object
					hr = m_pPropArray->GetAt( m_lPropIndex - m_pSysPropArray->GetSize(), &pProp );
					pPropList = pUMIObj;
					pPropList->AddRef();

					// It's a local property
					if ( NULL != plFlavor )
					{
						*plFlavor = WBEM_FLAVOR_ORIGIN_LOCAL;
					}

				}
				
				CReleaseMe	rm(pPropList);

				if ( SUCCEEDED( hr ) )
				{
					UMI_PROPERTY_VALUES*	pValues = NULL;

					hr = pPropList->Get( pProp->GetPropertyName(), 0, &pValues );

					if ( SUCCEEDED( hr ) )
					{
						// Now place the value in our class so we can coerce it to
						// a variant
						CUmiPropertyArray	umiPropArray;

						hr = umiPropArray.Set( pValues );

						if ( SUCCEEDED( hr ) )
						{
							CUmiProperty*	pActualProp = NULL;

							hr = umiPropArray.GetAt( 0L, &pActualProp );

							// Store the type
							if ( NULL != pctType )
							{
								*pctType = pActualProp->GetPropertyCIMTYPE();
							}

							// Store the name
							if ( NULL != pName )
							{
								*pName = SysAllocString( pProp->GetPropertyName() );

								if ( NULL == *pName )
								{
									hr = WBEM_E_OUT_OF_MEMORY;
								}

							}	// IF name required


							// Make sure they passed us a pVal before trying to fill it out
							if ( SUCCEEDED( hr ) && NULL != pVal )
							{
								hr = pActualProp->FillVariant( pVal );

								if ( SUCCEEDED( hr ) )
								{
									if ( FAILED(hr) && NULL != pName )
									{
										// Cleanup if we allocated a name
										SysFreeString( *pName );
										*pName = NULL;
									}

								}	// IF Filled Variant

							}	// IF got the value

						}	// IF Set Array

						pPropList->FreeMemory( 0L, pValues );
					}
					else
					{
							// If this was a regular property, check the error and return a VT_NULL variant
							// as necessary, and the correct CIMTYPE from the schema object

						UMI_PROPERTY_VALUES*	pValues = NULL;

						hr = pSchemaObj->Get( pProp->GetPropertyName(), 0, &pValues );

						if ( SUCCEEDED( hr ) )
						{
							// Now place the value in our class so we can coerce it to
							// a variant
							CUmiPropertyArray	umiPropArray;

							hr = umiPropArray.Set( pValues );

							if ( SUCCEEDED( hr ) )
							{
								CUmiProperty*	pActualProp = NULL;

								hr = umiPropArray.GetAt( 0L, &pActualProp );

								// Store the type
								if ( NULL != pctType )
								{
									*pctType = pActualProp->GetPropertyCIMTYPE();
								}

								// Store the name
								if ( NULL != pName )
								{
									*pName = SysAllocString( pProp->GetPropertyName() );

									if ( NULL == *pName )
									{
										hr = WBEM_E_OUT_OF_MEMORY;
									}

								}	// IF name required


								// Make sure they passed us a pVal before trying to fill it out
								if ( SUCCEEDED( hr ) && NULL != pVal )
								{
									VariantInit( pVal );
									V_VT( pVal ) = VT_NULL;
								}	// IF got the value

							}	// IF Set Array

							pPropList->FreeMemory( 0L, pValues );

						}

					}	// If got the property

				}	// IF got a property list

			}
			else
			{
				hr = WBEM_S_NO_MORE_DATA;
			}
		}
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

		return hr;

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::CUmiPropEnumData::EndEnumeration( IUmiObject* pUMIObj, IUmiObject* pSchemaObj )
{
	try
	{

		// Clear out the enumeration values
		m_lPropIndex = UMIWRAP_INVALID_INDEX;

		if ( NULL != m_pUmiProperties )
		{
			// Free this using an interface property list
			IUmiPropList*	pUmiPropList = NULL;

			if ( SUCCEEDED( pUMIObj->GetInterfacePropList( 0L, &pUmiPropList ) ) )
			{
				CReleaseMe	rm( pUmiPropList );
				pUmiPropList->FreeMemory( 0L, m_pUmiProperties );
			}

			m_pUmiProperties = NULL;
		}

		if ( NULL != m_pPropArray )
		{
			delete m_pPropArray;
			m_pPropArray = NULL;
		}

		if ( NULL != m_pUmiSysProperties )
		{
			pSchemaObj->FreeMemory( 0L, m_pUmiSysProperties );
			m_pUmiSysProperties = NULL;
		}

		if ( NULL != m_pSysPropArray )
		{
			delete m_pSysPropArray;
			m_pSysPropArray = NULL;
		}


		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

// Helper function to retrieve a UMI value from an object
HRESULT CUMIObjectWrapper::GetPropertyCimType( LPCWSTR wszName, CIMTYPE* pct )
{
	// We must have a schema object for this to work
	HRESULT hr = SetSchemaObject();

	if ( FAILED( hr ) )
	{
		return hr;
	}

	// We don't know the CIMTYPE, so we need to get it from the property

	UMI_PROPERTY_VALUES*	pValues = NULL;

	// Use this to free memory
	IUmiPropList*			pUmiPropList = NULL;

	// Call into the UMI Object.  If the user is trying to access a system property (one that starts
	// with a "__"), then we need to get it from the object's interface prop list.

	if ( wcslen( wszName ) > 2 && wszName[0] == '_' && wszName[1] == '_' )
	{
		IUmiPropList*	pUmiPropList = NULL;

		hr = m_pUMIObj->GetInterfacePropList( 0L, &pUmiPropList );

		if ( SUCCEEDED( hr ) )
		{
			hr = pUmiPropList->Get( wszName, 0, &pValues );
		}
	}
	else
	{
		// Get straight from the object
		hr = m_pUMISchemaObj->Get( wszName, 0, &pValues );

		// This is what we will use to free the object memory
		pUmiPropList = m_pUMISchemaObj;
		pUmiPropList->AddRef();
	}

	// Auto-release
	CReleaseMe	rm( pUmiPropList );


	if ( SUCCEEDED( hr ) )
	{
		// Convert to a property array and extract the value as a
		// VARIANT.

		CUmiPropertyArray	umiPropArray;

		hr = umiPropArray.Set( pValues );

		if ( SUCCEEDED( hr ) )
		{
			CUmiProperty*	pActualProp = NULL;

			hr = umiPropArray.GetAt( 0L, &pActualProp );

			*pct = pActualProp->GetPropertyCIMTYPE() | CIM_FLAG_ARRAY;
		}	// IF Set Array

		pUmiPropList->FreeMemory( 0L, pValues );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::PutVariant( LPCWSTR wszName, ULONG umiOperation, VARIANT* pVal, CIMTYPE ct )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	ULONG umiType = CUmiValue::CIMTYPEToUmiType( CType::GetBasic( ct ) );

	// Convert to a property array and extract the value as a
	// VARIANT.

	CUmiPropertyArray	umiPropArray;

	hr = umiPropArray.Add( umiType, umiOperation, wszName, 0L, NULL, FALSE );

	if ( SUCCEEDED( hr ) )
	{
		CUmiProperty*	pActualProp = NULL;

		hr = umiPropArray.GetAt( 0L, &pActualProp );

		if ( SUCCEEDED( hr ) )
		{
			hr = pActualProp->SetFromVariant( pVal, umiType );

			if ( SUCCEEDED( hr ) )
			{
				UMI_PROPERTY_VALUES*	pPropValues;

				// We will want the data structures filled out, and we will take care of
				// calling Delete on the data when we are done
				hr = umiPropArray.Export( &pPropValues );

				if ( SUCCEEDED( hr ) )
				{
					// Call into the UMI Object.  If the user is trying to access a system property (one that starts
					// with a "__"), then we need to get it from the object's interface prop list.

					if ( wcslen( wszName ) > 2 && wszName[0] == '_' && wszName[1] == '_' )
					{
						IUmiPropList*	pUmiPropList = NULL;

						hr = m_pUMIObj->GetInterfacePropList( 0L, &pUmiPropList );
						CReleaseMe	rm( pUmiPropList );

						if ( SUCCEEDED( hr ) )
						{
							hr = pUmiPropList->Put( wszName, 0, pPropValues );
						}
					}
					else
					{
						// Now try setting the actual value
						hr = m_pUMIObj->Put( wszName, 0L, pPropValues );
					}

					// Workaround for Refresh Bug
					if ( SUCCEEDED( hr ) )
					{
						m_fDirty = TRUE;
					}

					umiPropArray.Delete( pPropValues );
				}

			}	// If set the value

		}	// IF got the prop

	}	// IF added property

	return hr;
}

HRESULT CUMIObjectWrapper::SetSchemaObject( void )
{
	// We're already good to go
	if ( NULL != m_pUMISchemaObj )
	{
		return WBEM_S_NO_ERROR;
	}

	IUmiPropList*	pUmiPropList = NULL;

	HRESULT hr = m_pUMIObj->GetInterfacePropList( 0L, &pUmiPropList );
	CReleaseMe	rm( pUmiPropList );

	if ( SUCCEEDED( hr ) )
	{
		UMI_PROPERTY_VALUES*	pGenusValues = NULL;

		// Get the __GENUS, if this is a class object, this *is* the schema

		hr = pUmiPropList->Get( L"__GENUS", 0, &pGenusValues );

		if ( SUCCEEDED( hr ) )
		{
			if ( pGenusValues->pPropArray[0].uType == UMI_TYPE_I4 )
			{

				if ( pGenusValues->pPropArray[0].pUMIValue->lValue[0] == UMI_GENUS_INSTANCE )
				{
					// Get the "__SCHEMA" property.  If this fails, then we just use the current
					// object as the schema object

					UMI_PROPERTY_VALUES*	pSchemaValues = NULL;

					hr = pUmiPropList->Get( L"__SCHEMA", 0, &pSchemaValues );

					if ( SUCCEEDED( hr ) )
					{
						if ( pSchemaValues->pPropArray[0].uType == UMI_TYPE_IUNKNOWN )
						{
							IUnknown*	pUnk = (IUnknown*) pSchemaValues->pPropArray[0].pUMIValue->comObject[0].pInterface;

							hr = pUnk->QueryInterface( IID_IUmiObject, (void**) &m_pUMISchemaObj );

							if ( SUCCEEDED( hr ) )
							{
								m_fHaveSchemaObject = TRUE;
							}

						}	// IF it's a COM Object
						else
						{
							hr = WBEM_E_TYPE_MISMATCH;
						}

					}	// IF Get

					// Cleanup
					pUmiPropList->FreeMemory( 0L, pSchemaValues );

					// If any of the above failed, we will just use the current object as a schema object to
					// the best of our ability.

					if ( FAILED( hr ) )
					{
						m_pUMISchemaObj = m_pUMIObj;
						m_pUMISchemaObj->AddRef();
					}

				}
				else if ( pGenusValues->pPropArray[0].pUMIValue->lValue[0] == UMI_GENUS_CLASS )
				{
					// It's already a schema object, so no harm directly referring to it as our schema object
					m_pUMISchemaObj = m_pUMIObj;
					m_pUMISchemaObj->AddRef();
					m_fHaveSchemaObject = TRUE;
					m_fIsClass = TRUE;
				}
				else
				{
					// The underlying object has no idea what it is.  We give up
					hr = WBEM_E_FAILED;
				}

			}
			else
			{
				// The underlying object has no idea what it is.  We give up
				hr = WBEM_E_FAILED;
			}

			// Cleanup
			pUmiPropList->FreeMemory( 0L, pGenusValues );

		}
		else
		{
			// The underlying object has no idea what it is.  We give up
			hr = WBEM_E_FAILED;
		}


	}	// IF GetInterfacePropList

	// This will ALWAYS work
	return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiwrap.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIWRAP.CPP

Abstract:

  CUmiObjectWrapper implementation.

  Implements an aggregable wrapper around a UMI Object.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "umiwrap.h"
#include <corex.h>
#include "strutils.h"
#include "umiprop.h"
#include "umiprox.h"
#include "umiqual.h"
#include "svexwrap.h"

//***************************************************************************
//
//  CUMIObjectWrapper::CUMIObjectWrapper
//
//***************************************************************************
// ok
CUMIObjectWrapper::CUMIObjectWrapper( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWbemClassObject( this ),
	m_XWbemClassObjectEx( this ),
	m_XUmiObject( this ),
	m_XWbemUMIObjectWrapper( this ),
	m_XUmiCustIntfFactory( this ),
	m_XObjectMarshal( this ),
	m_pUMIObj( NULL ),
	m_pWbemSvc( NULL ),
	m_EnumPropData(),
	m_Schema(),
	m_SystemProperties(),
	m_fEnumingMethods( FALSE )
{
    m_Lock.SetData(&m_LockData);
}
    
//***************************************************************************
//
//  CUMIObjectWrapper::~CUMIObjectWrapper
//
//***************************************************************************
// ok
CUMIObjectWrapper::~CUMIObjectWrapper()
{

	// In case one was running
	EndEnumeration();

	if ( NULL != m_pUMIObj )
	{
		m_pUMIObj->Release();
	}

	if ( NULL != m_pWbemSvc )
	{
		m_pWbemSvc->Release();
		m_pWbemSvc = NULL;
	}
}

void* CUMIObjectWrapper::GetInterface(REFIID riid)
{
	if ( riid == IID_IUnknown || riid == IID_IWbemClassObject )
	{
		return &m_XWbemClassObject;
	}
	else if ( riid == IID_IWbemClassObjectEx )
	{
		return &m_XWbemClassObjectEx;
	}
	else if ( riid == IID_IUmiObject )
	{
		return &m_XUmiObject;
	}
	else if ( riid == IID_IUmiBaseObject )
	{
		return &m_XUmiObject;
	}
	else if ( riid == IID_IUmiPropList )
	{
		return &m_XUmiObject;
	}
	else if ( riid == IID__IWbemUMIObjectWrapper )
	{
		return &m_XWbemUMIObjectWrapper;
	}
	else if ( riid == IID_IUmiCustomInterfaceFactory )
	{
		return &m_XUmiCustIntfFactory;
	}
	else if ( riid == IID_IMarshal )
	{
		return &m_XObjectMarshal;
	}
	else if ( riid == IID_IWbemServices || riid == IID_IWbemServicesEx )
	{
		CLock	lock( this );
		
		HRESULT	hr = WBEM_S_NO_ERROR;

		if ( NULL == m_pWbemSvc )
		{
			IUnknown*	pUnk = NULL;
			hr = m_pUMIObj->QueryInterface( IID_IUnknown, (void**) &pUnk );
			CReleaseMe	rmUnk( pUnk );

			if ( SUCCEEDED( hr ) )
			{
				// Use the helper function to set the internal pointers
				hr = SetContainer( 0L, pUnk );
			}	// IF QI for IUnknown

		}	// IF NULL == m_pWbemSvc
		
		if ( FAILED( hr ) )
		{
			return NULL;
		}

		void*	pvData = NULL;

		// This will AddRef the UnkOuter, so we need to release, and
		// then we'll return pvoid, which will get Addref'd again
		// isn't aggregation wonderful

		m_pWbemSvc->QueryInterface( riid, &pvData );
		((IUnknown*) pvData)->Release();

		return pvData;
	}

    return NULL;
}

/* IWbemClassObject methods */

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetQualifierSet(IWbemQualifierSet** pQualifierSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetQualifierSet( pQualifierSet );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
									long* plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Get( wszName, lFlags, pVal, pctType, plFlavor );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
	// Pass through to the wrapper object
	return m_pObject->Put( wszName, lFlags, pVal, ctType );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Delete(LPCWSTR wszName)
{
	// Pass through to the wrapper object
	return m_pObject->Delete( wszName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
											SAFEARRAY** pNames)
{
	// Pass through to the wrapper object
	return m_pObject->GetNames( wszName, lFlags, pVal, pNames );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::BeginEnumeration(long lEnumFlags)
{
	// Pass through to the wrapper object
	return m_pObject->BeginEnumeration( lEnumFlags );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                long* plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Next( lFlags, pName, pVal, pctType, plFlavor );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::EndEnumeration()
{
	// Pass through to the wrapper object
	return m_pObject->EndEnumeration();
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** pQualifierSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyQualifierSet( wszProperty, pQualifierSet );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::Clone(IWbemClassObject** pCopy)
{
	// Pass through to the wrapper object
	return m_pObject->Clone( pCopy );

}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetObjectText(long lFlags, BSTR* pMofSyntax)
{
	// Pass through to the wrapper object
	return m_pObject->GetObjectText( lFlags, pMofSyntax );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
	// Pass through to the wrapper object
	return m_pObject->CompareTo( lFlags, pCompareTo );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyOrigin( wszProperty, pstrClassName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::InheritsFrom(LPCWSTR wszClassName)
{
	// Pass through to the wrapper object
	return m_pObject->InheritsFrom( wszClassName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass)
{
	// Pass through to the wrapper object
	return m_pObject->SpawnDerivedClass( lFlags, ppNewClass );

}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance)
{
	// Pass through to the wrapper object
	return m_pObject->SpawnInstance( lFlags, ppNewInstance );

}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                        IWbemClassObject** ppOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethod( wszName, lFlags, ppInSig, ppOutSig );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                        IWbemClassObject* pOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->PutMethod( wszName, lFlags, pInSig, pOutSig );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::DeleteMethod(LPCWSTR wszName)
{
	// Pass through to the wrapper object
	return m_pObject->DeleteMethod( wszName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::BeginMethodEnumeration(long lFlags)
{
	// Pass through to the wrapper object
	return m_pObject->BeginMethodEnumeration( lFlags );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::NextMethod(long lFlags, BSTR* pstrName, 
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->NextMethod( lFlags, pstrName, ppInSig, ppOutSig );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::EndMethodEnumeration()
{
	// Pass through to the wrapper object
	return m_pObject->EndMethodEnumeration();
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethodQualifierSet( wszName, ppSet );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObject::GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethodOrigin( wszMethodName, pstrClassName );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObjectEx::PutEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	// Pass through to the wrapper object
	return m_pObject->PutEx( wszName, lFlags, pvFilter, pvInVals );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObjectEx::DeleteEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	// Pass through to the wrapper object
	return m_pObject->DeleteEx( wszName, lFlags, pvFilter, pvInVals );
}

STDMETHODIMP CUMIObjectWrapper::XWbemClassObjectEx::GetEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals, CIMTYPE* pCimType, long* plFlavor)
{
	return m_pObject->GetEx( wszName, lFlags, pvFilter, pvInVals, pCimType, plFlavor );
}

// * IUmiPropList functions */

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp )
{
	return m_pObject->Put( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp )
{
	return m_pObject->Get( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	return m_pObject->GetAt( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp )
{
	return m_pObject->GetAs( pszName, uFlags, uCoercionType, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::FreeMemory( ULONG uReserved, LPVOID pMem )
{
	return m_pObject->FreeMemory( uReserved, pMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Delete( LPCWSTR pszName, ULONG uFlags )
{
	return m_pObject->Delete( pszName, uFlags );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps )
{
	return m_pObject->GetProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps )
{
	return m_pObject->PutProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	return m_pObject->PutFrom( pszName, uFlags, uBufferLength, pExistingMem );
}

/* IUmiBaseObject Methods */

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetLastStatus( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj )
{
	return m_pObject->GetLastStatus( uFlags, puSpecificStatus, riid, pStatusObj );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::GetInterfacePropList( ULONG uFlags, IUmiPropList **pPropList )
{
	return m_pObject->GetInterfacePropList( uFlags, pPropList );
}

		/* IUmiObject Methods */
// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Clone( ULONG uFlags, REFIID riid, LPVOID *pCopy )
{
	return m_pObject->Clone( uFlags, riid, pCopy );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Refresh( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames )
{
	return m_pObject->Refresh( uFlags, uNameCount, pszNames );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::CopyTo( ULONG uFlags, IUmiURL *pURL, REFIID riid, LPVOID *pCopy )
{
	return m_pObject->CopyTo( uFlags, pURL, riid, pCopy );
}


// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::XUmiObject::Commit( ULONG uFlags )
{
	return m_pObject->Commit( uFlags );
}

// See WBEMINT.IDL for Documentation
HRESULT CUMIObjectWrapper::XWbemUMIObjectWrapper::SetObject( long lFlags, IUnknown* pUnk )
{
	return m_pObject->SetObject( lFlags, pUnk );
}

HRESULT CUMIObjectWrapper::XWbemUMIObjectWrapper::ConnectToProvider( LPCWSTR pwszUser, LPCWSTR pwszPassword, IUnknown* pPath, REFCLSID rclsid, IWbemContext* pCtx )
{
	return m_pObject->ConnectToProvider( pwszUser, pwszPassword, pPath, rclsid, pCtx );
}

/* IMarshal Pass-thrus */
STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
	// Pass through to the wrapper object
	return m_pObject->GetUnmarshalClass( riid, pv, dwDestContext, pvReserved, mshlFlags, pClsid );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
	// Pass through to the wrapper object
	return m_pObject->GetMarshalSizeMax( riid, pv, dwDestContext, pvReserved, mshlFlags, plSize );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::MarshalInterface(IStream* pStream, REFIID riid, void* pv,
													DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
	// Pass through to the wrapper object
	return m_pObject->MarshalInterface( pStream, riid, pv, dwDestContext, pvReserved, mshlFlags );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv)
{
	// Pass through to the wrapper object
	return m_pObject->UnmarshalInterface( pStream, riid, ppv );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::ReleaseMarshalData(IStream* pStream)
{
	// Pass through to the wrapper object
	return m_pObject->ReleaseMarshalData( pStream );
}

STDMETHODIMP CUMIObjectWrapper::XObjectMarshal::DisconnectObject(DWORD dwReserved)
{
	// Pass through to the wrapper object
	return m_pObject->DisconnectObject( dwReserved );
}

/* IUmiCustomInterfaceFactory pass-thrus*/

STDMETHODIMP CUMIObjectWrapper::XUmiCustIntfFactory::GetCLSIDForIID( REFIID riid, long lFlags, CLSID *pCLSID )
{
	// Pass through to the wrapper object
	return m_pObject->GetCLSIDForIID( riid, lFlags, pCLSID );
}

STDMETHODIMP CUMIObjectWrapper::XUmiCustIntfFactory::GetObjectByCLSID( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface )
{
	// Pass through to the wrapper object
	return m_pObject->GetObjectByCLSID( clsid, pUnkOuter, dwClsContext, riid, lFlags,  ppInterface );
}

STDMETHODIMP CUMIObjectWrapper::XUmiCustIntfFactory::GetCLSIDForNames( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID )
{
	// Pass through to the wrapper object
	return m_pObject->GetCLSIDForNames( rgszNames,	cNames, lcid, rgDispId, lFlags,	pCLSID );
}

// This is the actual implementation

/* IWbemClassObject methods */

HRESULT CUMIObjectWrapper::GetQualifierSet(IWbemQualifierSet** pQualifierSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	CUmiQualifierWrapper*	pWrapper = new CUmiQualifierWrapper( m_pControl, m_pOuter );

	if ( NULL == pWrapper )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	return pWrapper->QueryInterface( IID_IWbemQualifierSet, (void**) pQualifierSet );
}

HRESULT CUMIObjectWrapper::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
									long* plFlavor)
{
	try
	{
		if ( NULL == wszName )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		UMI_PROPERTY_VALUES*	pValues = NULL;

		// Call into the UMI Object

		HRESULT hr = WBEM_S_NO_ERROR;
		
		// Call into the UMI Object.  If the user is trying to access a system property (one that starts
		// with a "__"), then we will use the proper class to try and access it.

		if ( CUMISystemProperties::IsPossibleSystemPropertyName( wszName ) )
		{
			// Initialize all the appropriate info
			hr = InitPropertyInfo( TRUE );

			if ( SUCCEEDED( hr ) )
			{
				return m_SystemProperties.GetProperty( wszName, NULL, pctType, pVal, plFlavor );
			}

		}
		else
		{
			// Now try getting the actual value - we will always use the cache
			hr = m_pUMIObj->Get( wszName, UMI_FLAG_PROVIDER_CACHE, &pValues );

			// It's a system property
			if ( NULL != plFlavor )
			{
				*plFlavor = WBEM_FLAVOR_ORIGIN_LOCAL;
			}

		}

		if ( SUCCEEDED( hr ) )
		{
			// Convert to a property array and extract the value as a
			// VARIANT.

			CUmiPropertyArray	umiPropArray;

			hr = umiPropArray.Set( pValues );

			if ( SUCCEEDED( hr ) )
			{
				CUmiProperty*	pActualProp = NULL;

				hr = umiPropArray.GetAt( 0L, &pActualProp );

				if ( SUCCEEDED( hr ) )
				{
					if ( !pActualProp->IsSynchronizationRequired() )
					{
						// The schema type will always outrank what the property says it is
						CIMTYPE	ctPropInfo = CIM_ILLEGAL;
						m_Schema.GetType( wszName, &ctPropInfo );

						if ( CIM_ILLEGAL == ctPropInfo )
						{
							ctPropInfo = pActualProp->GetPropertyCIMTYPE();
						}

						if ( NULL != pctType )
						{
							*pctType = ctPropInfo;
						}

						if ( NULL != pVal )
						{
							hr = pActualProp->FillVariant( pVal, ( ctPropInfo & CIM_FLAG_ARRAY ) );
						}

					}	// IF Synchronization not required
					else
					{
						hr = WBEM_E_SYNCHRONIZATION_REQUIRED;
					}

				}	// IF got the value

			}	// IF Set Array

			m_pUMIObj->FreeMemory( 0L, pValues );
		}
		else if ( UMI_E_NOT_FOUND == hr || UMI_E_UNBOUND_OBJECT == hr )
		{
			// If the property was not found or returns UMI_E_UNBOUND_OBJECT, check in the schema if it exists.
			// If so, it's a NULL property
			if ( SUCCEEDED( InitPropertyInfo( FALSE ) ) )
			{
				if ( wszName[0] != '_' )
				{
					CIMTYPE	ct;
					hr = m_Schema.GetType( wszName, &ct );

					if ( SUCCEEDED( hr ) )
					{
						if ( NULL != pctType )
						{
							*pctType = ct;
						}

						if ( NULL != pVal )
						{
							V_VT( pVal ) = VT_NULL;
						}

						if ( NULL != plFlavor )
						{
							*plFlavor = WBEM_FLAVOR_ORIGIN_LOCAL;
						}
					}
					else if ( !m_Schema.IsSchemaAvailable() )
					{
						// This is a no schema error - we can't verify if the property
						// really doesn't exist because there isn't any schema to check
						// against.
						hr = WBEM_E_NO_SCHEMA;
					}

				}	// IF not a system property

			}	// IF schema initialized

		}	// IF Not Found error

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	HRESULT hr = WBEM_S_NO_ERROR;

	// If we don't know the CIMTYPE, then we need to get it from the property
	if ( 0 == ctType )
	{
		hr = GetPropertyCimType( wszName, &ctType );
	}	// IF 0 == ctType

	// We don't know the CIMTYPE, so we need to get it from the property
	if ( SUCCEEDED( hr ) )
	{
		// Now just put the variant
		hr = PutVariant( wszName, UMI_OPERATION_UPDATE, pVal, ctType );
	}	// IF A-OK

	return hr;
}

HRESULT CUMIObjectWrapper::Delete(LPCWSTR wszName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	return m_pUMIObj->Delete( wszName, 0L );
}

HRESULT CUMIObjectWrapper::GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
											SAFEARRAY** pNames)
{
	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// Initialize all the appropriate info
		HRESULT	hr = InitPropertyInfo( TRUE );

		if ( SUCCEEDED( hr ) )
		{

			try
			{
				CUmiPropEnumData	enumPropData;
				CSafeArray SA(VT_BSTR, CSafeArray::auto_delete );

				// We'll need to do this internally so we don't overrun an enum in process
				hr = enumPropData.BeginEnumeration( 0L, m_pUMIObj, &m_Schema, &m_SystemProperties );

				if ( SUCCEEDED( hr ) )
				{
					while ( S_OK == hr )
					{
						BSTR	bstrProp = NULL;
						CIMTYPE	ct;

						// Gets  all the proper values
						hr = enumPropData.Next( 0L, &bstrProp, NULL, &ct, NULL );
						CSysFreeMe	sfm(bstrProp);

						if ( WBEM_S_NO_ERROR == hr )
						{
							SA.AddBSTR( bstrProp );
						}

					}

					enumPropData.EndEnumeration();

					if ( SUCCEEDED ( hr ) )
					{
						// Create SAFEARRAY and return
						// ===========================

						SA.Trim();

						// Now we make a copy, since the member array will be autodestructed (this
						// allows us to write exception-handling code
						*pNames = SA.GetArrayCopy();
					}

				}	// IF BeginEnumeration

			}
			catch( CX_MemoryException )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			catch(...)
			{
				hr = WBEM_E_CRITICAL_ERROR;
			}

		}	// If Schema initialized

		return hr;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::BeginEnumeration(long lEnumFlags)
{
	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// Initialize all the appropriate info
		HRESULT	hr = InitPropertyInfo( TRUE );

		if ( SUCCEEDED( hr ) )
		{
			hr = m_EnumPropData.BeginEnumeration( lEnumFlags, m_pUMIObj, &m_Schema, &m_SystemProperties );
		}

		return hr;

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}
}

HRESULT CUMIObjectWrapper::Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                long* plFlavor)
{
	try
	{

		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);
		return m_EnumPropData.Next( lFlags, pName, pVal, pctType, plFlavor );

	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::EndEnumeration()
{
	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		return m_EnumPropData.EndEnumeration();
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

HRESULT CUMIObjectWrapper::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** pQualifierSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	if ( NULL == wszProperty )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// We don't supprt this for system properties.

	if ( wcslen( wszProperty ) > 2 && wszProperty[0] == '_' && wszProperty[1] == '_' )
	{
		return WBEM_E_SYSTEM_PROPERTY;
	}

	// Initialize all the appropriate info
	HRESULT	hr = InitPropertyInfo( TRUE );

	if ( SUCCEEDED( hr ) )
	{
		CIMTYPE	ct;
		BOOL	fKey = FALSE;
		BOOL	fClass = FALSE;

		hr = m_Schema.GetType( wszProperty, &ct );

		if ( SUCCEEDED( hr ) )
		{
			VARIANT	v;

			// See if this is the key property
			hr = Get( L"__KEY", 0L, &v, NULL, NULL );

			if ( SUCCEEDED( hr ) )
			{
				if ( V_VT( &v ) == VT_BSTR )
				{
					fKey = ( wbem_wcsicmp( V_BSTR( &v ), wszProperty ) == 0 );
				}

				VariantClear( &v );
			}

			// Get the Genus of the object
			hr = Get( L"__GENUS", 0, &v, NULL, NULL );

			if ( SUCCEEDED( hr ) )
			{
				if ( V_VT( &v ) == VT_I4 )
				{
					fClass = ( V_I4( &v ) != UMI_GENUS_INSTANCE );
				}
			}

			// Allocate a qualifier set and initialize it
			CUmiQualifierWrapper*	pWrapper = new CUmiQualifierWrapper( m_pControl, fKey, TRUE, fClass, ct, m_pOuter );

			if ( NULL == pWrapper )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				hr = pWrapper->QueryInterface( IID_IWbemQualifierSet, (void**) pQualifierSet );
			}

		}	// IF hr

	}	// IF Initialize Schema


	return hr;
}

HRESULT CUMIObjectWrapper::Clone(IWbemClassObject** pCopy)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Hit the equivalent function, then create a wrapper and 
	IUmiObject*	pNewUmiObj = NULL;
	HRESULT	hr = m_pUMIObj->Clone( 0L, IID_IUmiObject, (void**) &pNewUmiObj );
	CReleaseMe	rm(pNewUmiObj);

	if ( SUCCEEDED( hr ) )
	{
		// Set the underlying object in a new wrapper
		CUMIObjectWrapper*	pNewWrapper = new CUMIObjectWrapper( m_pControl, m_pOuter );

		if ( NULL != pNewWrapper )
		{
			hr = pNewWrapper->m_XWbemUMIObjectWrapper.SetObject( 0L, pNewUmiObj );

			if ( SUCCEEDED( hr ) )
			{
				hr = pNewWrapper->QueryInterface( IID_IWbemClassObject, (void**) pCopy );
			}

			// Cleanup in the event of an error
			if ( FAILED( hr ) )
			{
				delete pNewWrapper;
			}

		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

HRESULT CUMIObjectWrapper::GetObjectText(long lFlags, BSTR* pMofSyntax)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	HRESULT	hr= WBEM_S_NO_ERROR;

	CWbemClass*	pClassObj = new CWbemClass;
	CReleaseMe	rm1( (IWbemClassObject*) pClassObj );

	if ( NULL != pClassObj )
	{
		// Initialize the class object
		hr = pClassObj->InitEmpty();

		if ( SUCCEEDED( hr ) )
		{
			// Get the actual classname and put it in the class object

			VARIANT	vClass;
			
			hr = Get( L"__CLASS", 0L, &vClass, NULL, NULL );

			if ( SUCCEEDED( hr ) )
			{
				CClearMe	cmClass( &vClass );

				hr = pClassObj->Put( L"__CLASS", 0L, &vClass, CIM_STRING );

				if ( SUCCEEDED( hr ) )
				{
					CUmiPropEnumData	enumPropData;

					// We'll need to do this internally so we don't overrun an enum in process
					hr = enumPropData.BeginEnumeration( WBEM_FLAG_LOCAL_ONLY, m_pUMIObj, &m_Schema, &m_SystemProperties );

					if ( SUCCEEDED( hr ) )
					{
						while ( S_OK == hr )
						{
							BSTR	bstrProp = NULL;
							CIMTYPE	ct;

							// Gets  all the proper values
							hr = enumPropData.Next( 0L, &bstrProp, NULL, &ct, NULL );
							CSysFreeMe	sfm(bstrProp);

							if ( WBEM_S_NO_ERROR == hr )
							{
								// It's sleazy, but we want these properties to go through
								// regardless
								hr = pClassObj->ForcePut( bstrProp, 0L, NULL, ct );

							}

						}
						
						enumPropData.EndEnumeration();
					}

					// This means we completed the enum and put properties properly
					if ( WBEM_S_NO_MORE_DATA == hr )
					{
						// Now find out if the underlying object is an instance or class
						BOOL	fIsInst = FALSE;

						hr = IsInstance( &fIsInst );

						if ( SUCCEEDED( hr ) )
						{
							if ( fIsInst )
							{
								IWbemClassObject*	pInst = NULL;

								// Spawn an instance - now reenumerate the properties and Put them
								hr = pClassObj->SpawnInstance( 0L, &pInst );
								CReleaseMe	rm2(pInst);

								if ( SUCCEEDED( hr ) )
								{
									CUmiPropEnumData	enumPropData;

									// We'll need to do this internally so we don't overrun an enum in process
									hr = enumPropData.BeginEnumeration( WBEM_FLAG_LOCAL_ONLY, m_pUMIObj, &m_Schema, &m_SystemProperties );

									if ( SUCCEEDED( hr ) )
									{
										while ( S_OK == hr )
										{
											VARIANT	v;
											BSTR	bstrProp = NULL;
											CIMTYPE	ct;

											VariantInit( &v );

											// Gets  all the proper values
											hr = enumPropData.Next( 0L, &bstrProp, &v, &ct, NULL );
											CSysFreeMe	sfm(bstrProp);

											if ( WBEM_S_NO_ERROR == hr && V_VT( &v ) != VT_NULL )
											{
												hr = pInst->Put( bstrProp, 0L, &v, ct );
											}

											VariantClear( &v );
										}
										
										enumPropData.EndEnumeration();
									}

									// Now, if the enum successfully completed, we can
									// use the classic WMI Object to get the MOF Text
									if ( WBEM_S_NO_MORE_DATA == hr )
									{
										hr = pInst->GetObjectText( 0L, pMofSyntax );
									}

								}	// IF Spawned an instance

							}	// IF is an instance
							else
							{
								// All done.  Get the class information
								hr = pClassObj->GetObjectText( 0L, pMofSyntax );
							}

						}	// IF IsInstance() Succeeded

					}	// IF successfully created class

				}	// IF Wrote Class Name

			}	// IF Got class name

		}	// IF Initialized class

	}	// IF allocated class object
	else
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

HRESULT CUMIObjectWrapper::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	if ( NULL == wszProperty || NULL == pstrClassName )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Only need schema infor for this
	HRESULT	hr = InitPropertyInfo( FALSE );

	if ( SUCCEEDED( hr ) )
	{
		hr = m_Schema.GetPropertyOrigin( wszProperty, pstrClassName );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::InheritsFrom(LPCWSTR wszClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                        IWbemClassObject** ppOutSig)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                        IWbemClassObject* pOutSig)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::DeleteMethod(LPCWSTR wszName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return WBEM_E_INVALID_OPERATION;
}

HRESULT CUMIObjectWrapper::BeginMethodEnumeration(long lFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( !m_fEnumingMethods )
	{
		m_fEnumingMethods = TRUE;
	}
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}

HRESULT CUMIObjectWrapper::NextMethod(long lFlags, BSTR* pstrName, 
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{

	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	if ( 0L != lFlags )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	return ( m_fEnumingMethods ? WBEM_S_NO_MORE_DATA : WBEM_E_INVALID_OPERATION );
}

HRESULT CUMIObjectWrapper::EndMethodEnumeration()
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	m_fEnumingMethods = FALSE;
	return WBEM_S_NO_ERROR;
}

HRESULT CUMIObjectWrapper::GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	if ( NULL == wszName || NULL == ppSet )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	return WBEM_E_NOT_FOUND;
}

HRESULT CUMIObjectWrapper::GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	if ( NULL == wszMethodName || NULL == pstrClassName )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	return WBEM_E_NOT_FOUND;
}

/* IWbemClassObjectEx functions */
HRESULT CUMIObjectWrapper::PutEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// Make sure parameters are correct
		if ( lFlags & ~WBEM_MASK_PUTEX_OPERATION || NULL == pvInVals )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Only supported operation here is Append - which means we basically ignore
		// the pvFilter parameter
		if ( ( lFlags & WBEM_MASK_PUTEX_OPERATION ) != WBEM_FLAG_PUTEX_APPEND || NULL == pvFilter )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// We don't know the CIMTYPE, so we need to get it from the property
		CIMTYPE	ctType;

		hr = GetPropertyCimType( wszName, &ctType );

		if ( SUCCEEDED( hr ) )
		{
			hr = PutVariant( wszName, UMI_OPERATION_APPEND, pvInVals, ctType );
		}	// IF A-OK

	}	// try
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	return hr;
}

HRESULT CUMIObjectWrapper::DeleteEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	try
	{
		// Do this so the wrapped object doesn't get ripped out from underneath us
		CLock	lock(this);

		// Make sure parameters are correct
		if ( lFlags & ~WBEM_MASK_DELETEEX_OPERATION || NULL == pvInVals )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		if ( ( ( lFlags & WBEM_MASK_PUTEX_OPERATION ) != WBEM_FLAG_PUTEX_DELETE_FIRST_MATCH && 
			( lFlags & WBEM_MASK_PUTEX_OPERATION ) != WBEM_FLAG_DELETE_ALL_MATCHES ) ||
			NULL == pvFilter )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// We don't know the CIMTYPE, so we need to get it from the property
		CIMTYPE	ctType;

		hr = GetPropertyCimType( wszName, &ctType );

		if ( SUCCEEDED( hr ) )
		{
			ULONG	ulOperation = ( lFlags & WBEM_MASK_PUTEX_OPERATION ) == WBEM_FLAG_PUTEX_DELETE_FIRST_MATCH ?
						UMI_OPERATION_DELETE_FIRST_MATCH : UMI_OPERATION_DELETE_ALL_MATCHES;

			hr = PutVariant( wszName, ulOperation, pvInVals, ctType );
		}	// IF A-OK

	}	// try
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	return hr;
}

HRESULT CUMIObjectWrapper::GetEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals, CIMTYPE* pCimType, long* plFlavor)
{
	return WBEM_E_NOT_AVAILABLE;
}

// * IUmiPropList functions */

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Put( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Get( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetAt( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetAs( pszName, uFlags, uCoercionType, pProp );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::FreeMemory( ULONG uReserved, LPVOID pMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->FreeMemory( uReserved, pMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Delete( LPCWSTR pszName, ULONG uFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	if ( wcslen( pszName ) > 2 && pszName[0] == '_' && pszName[1] == '_' )
	{
		return WBEM_E_SYSTEM_PROPERTY;
	}

	// Create NULL variant and put it with a RESTORE_DEFAULT operation
	return PutVariant( pszName, UMI_OPERATION_RESTORE_DEFAULT, NULL, CIM_EMPTY );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->PutProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->PutFrom( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetLastStatus( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetLastStatus( uFlags, puSpecificStatus, riid, pStatusObj );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::GetInterfacePropList( ULONG uFlags, IUmiPropList **pPropList )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->GetInterfacePropList( uFlags, pPropList );
}

		/* IUmiObject Methods */
// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Clone( ULONG uFlags, REFIID riid, LPVOID *pCopy )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Clone( uFlags, riid, pCopy );
}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Refresh( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pUMIObj->Refresh( uFlags, uNameCount, pszNames );
}

HRESULT CUMIObjectWrapper::CopyTo( ULONG uFlags, IUmiURL *pURL, REFIID riid, LPVOID *pCopy )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	return m_pUMIObj->CopyTo( uFlags, pURL, riid, pCopy );

}

// See UMI.IDL for Documentation
HRESULT CUMIObjectWrapper::Commit( ULONG uFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	return m_pUMIObj->Commit( uFlags );

}

// See WBEMINT.IDL for Documentation
HRESULT CUMIObjectWrapper::SetObject( long lFlags, IUnknown* pUnk )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Check for valid flags
	if ( ( lFlags & ~( UMIOBJECT_WRAPPER_FLAG_SECURITY | UMI_SECURITY_MASK | UMIOBJECT_WRAPPER_FLAG_CONTAINER ) ) ||
			NULL == pUnk )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// We only allow this once
	if ( NULL != m_pUMIObj )
	{
		return WBEM_E_FAILED;
	}

	IUmiObject*	pObj = NULL;

	// QI for the interface we're really interested in
	HRESULT hr = WBEM_S_NO_ERROR;

	// If storing as a container, we need to connect the object up to a DS Svc Ex Wrapper
	if ( lFlags & UMIOBJECT_WRAPPER_FLAG_CONTAINER )
	{
		IUnknown*	pRawUnknown = NULL;

		_IUmiDsWrapper*	pUmiDsWrapper = NULL;
		hr = pUnk->QueryInterface( IID__IUmiDsWrapper, (void**) &pUmiDsWrapper );
		CReleaseMe	rmds( pUmiDsWrapper );

		// If we got a raw interface, get the raw container, otherwise, just use the supplied
		// IUnknown.
		if ( SUCCEEDED( hr ) )
		{
			// This will be the object we set as the UMI object
			hr = pUmiDsWrapper->GetRealContainer( &pRawUnknown );
		}
		else
		{
			hr = WBEM_S_NO_ERROR;
			pRawUnknown = pUnk;
		}

		if ( SUCCEEDED( hr ) )
		{
			// Use the helper function to set the internal pointers
			hr = SetContainer( UMISVCEX_WRAPPER_FLAG_SETDIRECT, pUnk );

			// If this succeeds, then set the root object
			if ( SUCCEEDED( hr ) )
			{
				hr = pRawUnknown->QueryInterface( IID_IUmiObject, (void**) &m_pUMIObj );
			}


		}	// IF QI for IUnknown
	
	}	// IF storing a container
	else
	{
		// Store the object and get on with our lives
		hr = pUnk->QueryInterface( IID_IUmiObject, (void**) &m_pUMIObj );
	}

	// Make sure the system properties object is initialized so it can deal with __SECURITY_DESCRIPTOR properly
	m_SystemProperties.SetSecurityFlags( lFlags & ( UMIOBJECT_WRAPPER_FLAG_SECURITY | UMI_SECURITY_MASK ) );

	return hr;

}

HRESULT CUMIObjectWrapper::ConnectToProvider( LPCWSTR pwszUser, LPCWSTR pwszPassword, IUnknown* pPath, REFCLSID rclsid, IWbemContext* pCtx )
{
	_IUmiSvcExWrapper*	pSvcExWrapper = NULL;
	HRESULT	hr = CoCreateInstance( CLSID__DSSvcExWrap, NULL, CLSCTX_INPROC_SERVER, IID__IUmiSvcExWrapper, (void**) &pSvcExWrapper );
	CReleaseMe	rmWrap( pSvcExWrapper );

	if ( SUCCEEDED( hr ) )
	{
		// Pass through the connect request to the svc ex wrapper
		IUnknown*	pUnk = NULL;
		hr = pSvcExWrapper->ConnectToProvider( pwszUser, pwszPassword, pPath, rclsid, pCtx, &pUnk );

		if ( SUCCEEDED( hr ) )
		{

			// Set the local object pointer
			hr = pUnk->QueryInterface( IID_IUmiObject, (void**) &m_pUMIObj );

			if ( SUCCEEDED( hr ) )
			{

				IWbemServicesEx*	pSvcEx = NULL;
				hr = pSvcExWrapper->QueryInterface( IID_IWbemServicesEx, (void**) &pSvcEx );
				CReleaseMe	rmSvcEx( pSvcEx );

				if ( SUCCEEDED( hr ) )
				{
					// We will be the controlling unknown
					CUmiWbemSvcExWrapper*	pNewWrapper = new CUmiWbemSvcExWrapper( m_pControl, this );

					if ( NULL != pNewWrapper )
					{
						// Set the wrapper proxy, and we will have successfully aggregated the wrapper
						pNewWrapper->SetProxy( pSvcEx );
						hr = pNewWrapper->QueryInterface( IID_IUnknown, (void**) &m_pWbemSvc );
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

				}	// IF QI IWbemServicesEx

			}	// IF Qi IUmiObject

		}	// IF Connect to Provider

	}	// IF CCI

	return hr;
}

/* IMarshal Methods */

HRESULT CUMIObjectWrapper::GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Onlyb allows in-proc marshaling for now
	if ( MSHCTX_INPROC != dwDestContext )
	{
		return E_FAIL;
	}

    *pClsid = CLSID_UmiObjectWrapperProxy;

	return S_OK;
}

HRESULT CUMIObjectWrapper::GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Only allows in-proc marshaling for now
	if ( MSHCTX_INPROC != dwDestContext )
	{
		return E_FAIL;
	}

	// How long is it?
	*plSize = CUMIDataPacket::GetMarshalSize();

    return S_OK;
}

HRESULT CUMIObjectWrapper::MarshalInterface(IStream* pStream, REFIID riid, void* pv,
													DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// Onlyb allows in-proc marshaling for now
	if ( MSHCTX_INPROC != dwDestContext )
	{
		return E_FAIL;
	}

	// Marshal into the stream
	UMI_MARSHALPACKET_DATAPACKET	packet;
	CUMIDataPacket	umiDataPacket;

	HRESULT	hr = umiDataPacket.Init( &packet, this );

	if ( SUCCEEDED( hr ) )
	{
		hr = pStream->Write((void*)&packet, CUMIDataPacket::GetMarshalSize(), NULL);

		if ( FAILED(hr) )
		{
			packet.m_pUmiObjWrapper->Release();
		}
	}

	return hr;
}

HRESULT CUMIObjectWrapper::UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return E_UNEXPECTED;
}

HRESULT CUMIObjectWrapper::ReleaseMarshalData(IStream* pStream)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return E_UNEXPECTED;
}

HRESULT CUMIObjectWrapper::DisconnectObject(DWORD dwReserved)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return E_UNEXPECTED;
}

/* 	IUmiCustomInterfaceFactory Methods */
HRESULT CUMIObjectWrapper::GetCLSIDForIID( REFIID riid, long lFlags, CLSID *pCLSID )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	IUmiCustomInterfaceFactory*	pInterfaceFactory = NULL;

	HRESULT	hr = m_pUMIObj->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pInterfaceFactory );
	CReleaseMe	rm(pInterfaceFactory);

	if ( SUCCEEDED( hr ) )
	{
		hr = pInterfaceFactory->GetCLSIDForIID( riid, lFlags, pCLSID );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::GetObjectByCLSID( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	IUmiCustomInterfaceFactory*	pInterfaceFactory = NULL;

	HRESULT	hr = m_pUMIObj->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pInterfaceFactory );
	CReleaseMe	rm(pInterfaceFactory);

	if ( SUCCEEDED( hr ) )
	{
		hr = pInterfaceFactory->GetObjectByCLSID( clsid, pUnkOuter, dwClsContext, riid, lFlags,  ppInterface );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::GetCLSIDForNames( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	IUmiCustomInterfaceFactory*	pInterfaceFactory = NULL;

	HRESULT	hr = m_pUMIObj->QueryInterface( IID_IUmiCustomInterfaceFactory, (void**) &pInterfaceFactory );
	CReleaseMe	rm(pInterfaceFactory);

	if ( SUCCEEDED( hr ) )
	{
		hr = pInterfaceFactory->GetCLSIDForNames( rgszNames,	cNames, lcid, rgDispId, lFlags,	pCLSID );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::Lock(long lFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
    m_Lock.Lock();
	return WBEM_S_NO_ERROR;
}

HRESULT CUMIObjectWrapper::Unlock(long lFlags)
{
    m_Lock.Unlock();
	return WBEM_S_NO_ERROR;
}

IUmiObject*	CUMIObjectWrapper::GetUmiObject( void )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	if ( NULL != m_pUMIObj )
	{
		m_pUMIObj->AddRef();
	}

	IUmiObject*	pReturn = m_pUMIObj;
	return pReturn;
}

// Helper function to retrieve a UMI value from an object
HRESULT CUMIObjectWrapper::GetPropertyCimType( LPCWSTR wszName, CIMTYPE* pct )
{

	// Initialize all appropriate info
	HRESULT hr = InitPropertyInfo( TRUE );

	// We don't know the CIMTYPE, so we need to get it from the property

	UMI_PROPERTY_VALUES*	pValues = NULL;

	// Call into the UMI Object.  If the user is trying to access a system property (one that starts
	// with a "__"), then we need to get it from the object's interface prop list.

	if ( CUMISystemProperties::IsPossibleSystemPropertyName( wszName ) )
	{
		hr = m_SystemProperties.GetProperty( wszName, NULL, pct, NULL, NULL );
	}
	else
	{
		// Get from the schema
		hr = m_Schema.GetType( wszName, pct );
	}

	return hr;
}

HRESULT CUMIObjectWrapper::PutVariant( LPCWSTR wszName, ULONG umiOperation, VARIANT* pVal, CIMTYPE ct )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	ULONG umiType = CUmiValue::CIMTYPEToUmiType( CType::GetBasic( ct ) );

	// Convert to a property array and extract the value as a
	// VARIANT.

	CUmiPropertyArray	umiPropArray;

	hr = umiPropArray.Add( umiType, umiOperation, wszName, 0L, NULL, FALSE );

	if ( SUCCEEDED( hr ) )
	{
		CUmiProperty*	pActualProp = NULL;

		hr = umiPropArray.GetAt( 0L, &pActualProp );

		if ( SUCCEEDED( hr ) )
		{
			hr = pActualProp->SetFromVariant( pVal, umiType );

			if ( SUCCEEDED( hr ) )
			{
				UMI_PROPERTY_VALUES*	pPropValues;

				// We will want the data structures filled out, and we will take care of
				// calling Delete on the data when we are done
				hr = umiPropArray.Export( &pPropValues );

				if ( SUCCEEDED( hr ) )
				{
					// Call into the UMI Object.  If the user is trying to access a system property (one that starts
					// with a "__"), then we need to get it from the object's interface prop list.

					if ( CUMISystemProperties::IsPossibleSystemPropertyName( wszName ) )
					{
						hr = m_SystemProperties.Put( wszName, 0, pPropValues );
					}
					else
					{
						// Now try setting the actual value
						hr = m_pUMIObj->Put( wszName, 0L, pPropValues );
					}

					umiPropArray.Delete( pPropValues );
				}

			}	// If set the value

		}	// IF got the prop

	}	// IF added property

	return hr;
}

HRESULT CUMIObjectWrapper::IsInstance( BOOL* pfIsInst )
{
	IUmiPropList*	pUmiPropList = NULL;

	HRESULT hr = m_pUMIObj->GetInterfacePropList( 0L, &pUmiPropList );
	CReleaseMe	rm( pUmiPropList );

	if ( SUCCEEDED( hr ) )
	{
		UMI_PROPERTY_VALUES*	pGenusValues = NULL;

		// Get the __GENUS, if this is a class object, this *is* the schema

		hr = pUmiPropList->Get( L"__GENUS", 0, &pGenusValues );

		if ( SUCCEEDED( hr ) )
		{
			if ( pGenusValues->pPropArray[0].uType == UMI_TYPE_I4 )
			{

				*pfIsInst = pGenusValues->pPropArray[0].pUMIValue->lValue[0] == UMI_GENUS_INSTANCE;
			}

			// Cleanup
			pUmiPropList->FreeMemory( 0L, pGenusValues );

		}	// IF Get __GENUS

	}	// IF GetIntfPropList

	return hr;

}

HRESULT CUMIObjectWrapper::InitPropertyInfo( BOOL fInitSystemProps )
{
	HRESULT	hr = m_Schema.InitializeSchema( m_pUMIObj );

	if ( SUCCEEDED( hr ) && fInitSystemProps )
	{
		hr = m_SystemProperties.Initialize( m_pUMIObj, &m_Schema );
	}

	return hr;

}

HRESULT CUMIObjectWrapper::SetContainer( long lFlags, IUnknown* pContainer )
{
	_IUmiSvcExWrapper*	pSvcExWrapper = NULL;
	HRESULT hr = CoCreateInstance( CLSID__DSSvcExWrap, NULL, CLSCTX_INPROC_SERVER, IID__IUmiSvcExWrapper, (void**) &pSvcExWrapper );
	CReleaseMe	rmWrap( pSvcExWrapper );

	if ( SUCCEEDED( hr ) )
	{
		// Set the interface pointer directly
		hr = pSvcExWrapper->SetContainer( lFlags, pContainer );

		if ( SUCCEEDED( hr ) )
		{

			IWbemServicesEx*	pSvcEx = NULL;
			hr = pSvcExWrapper->QueryInterface( IID_IWbemServicesEx, (void**) &pSvcEx );
			CReleaseMe	rmSvcEx( pSvcEx );

			if ( SUCCEEDED( hr ) )
			{
				// We will be the controlling unknown
				CUmiWbemSvcExWrapper*	pNewWrapper = new CUmiWbemSvcExWrapper( m_pControl, this );

				if ( NULL != pNewWrapper )
				{
					// Set the wrapper proxy, and we will have successfully aggregated the wrapper
					pNewWrapper->SetProxy( pSvcEx );
					hr = pNewWrapper->QueryInterface( IID_IUnknown, (void**) &m_pWbemSvc );

				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}	// IF QI IWbemServicesEx

		}	// IF SetContainer

	}	// IF CCI

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umisysprop.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMISYSPROP.H

Abstract:

  CUMISystemProperty Definition.

  Standard definition for UMI Schema wrapper.

History:

  01-May-2000	sanjes    Created.

--*/

#ifndef _UMISYSPROP_H_
#define _UMISYSPROP_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include "umi.h"

//***************************************************************************
//
//  class CUMISystemProperties
//
//
//***************************************************************************

class COREPROX_POLARITY CUMISystemProperties
{

	enum
	{
		UMI_DEFAULTSYSPROP_GENUS,
		UMI_DEFAULTSYSPROP_CLASS,
		UMI_DEFAULTSYSPROP_SUPERCLASS,
		UMI_DEFAULTSYSPROP_DYNASTY,
		UMI_DEFAULTSYSPROP_RELPATH,
		UMI_DEFAULTSYSPROP_PROPERTY_COUNT,
		UMI_DEFAULTSYSPROP_DERIVATION,
		UMI_DEFAULTSYSPROP_SERVER,
		UMI_DEFAULTSYSPROP_NAMESPACE,
		UMI_DEFAULTSYSPROP_PATH,
		UMI_DEFAULTSYSPROP_SECURITY_DESCRIPTOR
	};

protected:
	static LPWSTR			s_apSysPropNames[];
	IUmiObject*				m_pUmiObj;
	IUmiPropList*			m_pSysPropList;
	CUmiPropertyArray*		m_pSysPropArray;
	UMI_PROPERTY_VALUES*	m_pUmiSysProperties;
	CUMISchemaWrapper*		m_pSchemaWrapper;
	ULONG					m_nNumProperties;
	long					m_lFlags;

public:

	HRESULT CalculateNumProperties( void );
	HRESULT Initialize( IUmiObject* pObject, CUMISchemaWrapper* pSchemaWrapper );

	int GetNumProperties( void ) { return m_nNumProperties; }
    CUMISystemProperties( void );
	~CUMISystemProperties(); 

	// Static helpers
	static BOOL IsDefaultSystemProperty( LPCWSTR wszName );
	static int GetDefaultSystemPropertyIndex( LPCWSTR wszName );
	static int NumDefaultSystemProperties( void );
	static BOOL IsPossibleSystemPropertyName( LPCWSTR wszName );

	HRESULT GetProperty( int nIndex, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor );
	HRESULT GetProperty( LPCWSTR wszName, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor );

	HRESULT Put( LPCWSTR wszName, ULONG ulFlags, UMI_PROPERTY_VALUES* pPropValues );
	void SetSecurityFlags( long lFlags ) { m_lFlags = lFlags; }

protected:

	HRESULT GetDefaultSystemProperty( int nIndex, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor );
	HRESULT GetPropListProperty( LPCWSTR wszName, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor, long lFlags = 0L );
	HRESULT GetNullProperty( LPCWSTR wszName, BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor );

	HRESULT GetSecurityDescriptor( BSTR* bstrName, CIMTYPE* pctType, VARIANT* pVal, long* plFlavor );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umiwrap.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

  UMIWRAP.H

Abstract:

  CUmiObjectWrapper Definition.

  Standard definition for _IWbemUMIObjectWrapper.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _UMIWRAP_H_
#define _UMIWRAP_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include "umi.h"
#include "umischm.h"
#include "umisysprop.h"
#include "umienumprop.h"

//***************************************************************************
//
//  class CUMIObjectWrapper
//
//  Implementation of _IWmiFreeFormObject Interface
//
//***************************************************************************

class COREPROX_POLARITY CUMIObjectWrapper : public CUnk
{
protected:
	IUmiObject*			m_pUMIObj;
	IUnknown*			m_pWbemSvc;
	CUMISchemaWrapper	m_Schema;
	CUMISystemProperties	m_SystemProperties;
	CUmiPropEnumData	m_EnumPropData;
	BOOL				m_fDirty;	// Workaround until Refresh is fixed.
	BOOL				m_fEnumingMethods;

    SHARED_LOCK_DATA	m_LockData;
    CSharedLock			m_Lock;

public:

    CUMIObjectWrapper(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CUMIObjectWrapper(); 

	IUmiObject*	GetUmiObject( void );

    class COREPROX_POLARITY XWbemClassObject : public CImpl<IWbemClassObject, CUMIObjectWrapper>
    {
    public:
        XWbemClassObject(CUMIObjectWrapper* pObject) : 
            CImpl<IWbemClassObject, CUMIObjectWrapper>(pObject)
        {}

		/* IWbemClassObject methods */
		STDMETHOD(GetQualifierSet)(IWbemQualifierSet** pQualifierSet);
		STDMETHOD(Get)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
			long* plFlavor);

		STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
		STDMETHOD(Delete)(LPCWSTR wszName);
		STDMETHOD(GetNames)(LPCWSTR wszName, long lFlags, VARIANT* pVal,
							SAFEARRAY** pNames);
		STDMETHOD(BeginEnumeration)(long lEnumFlags);

		STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
						long* plFlavor);

		STDMETHOD(EndEnumeration)();

		STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty,
										   IWbemQualifierSet** pQualifierSet);
		STDMETHOD(Clone)(IWbemClassObject** pCopy);
		STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax);

		STDMETHOD(CompareTo)(long lFlags, IWbemClassObject* pCompareTo);
		STDMETHOD(GetPropertyOrigin)(LPCWSTR wszProperty, BSTR* pstrClassName);
		STDMETHOD(InheritsFrom)(LPCWSTR wszClassName);

		STDMETHOD(SpawnDerivedClass)(long lFlags, IWbemClassObject** ppNewClass);
		STDMETHOD(SpawnInstance)(long lFlags, IWbemClassObject** ppNewInstance);
		STDMETHOD(GetMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
								IWbemClassObject** ppOutSig);
		STDMETHOD(PutMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
								IWbemClassObject* pOutSig);
		STDMETHOD(DeleteMethod)(LPCWSTR wszName);
		STDMETHOD(BeginMethodEnumeration)(long lFlags);
		STDMETHOD(NextMethod)(long lFlags, BSTR* pstrName, 
						   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
		STDMETHOD(EndMethodEnumeration)();
		STDMETHOD(GetMethodQualifierSet)(LPCWSTR wszName, IWbemQualifierSet** ppSet);
		STDMETHOD(GetMethodOrigin)(LPCWSTR wszMethodName, BSTR* pstrClassName);

    } m_XWbemClassObject;
    friend XWbemClassObject;

    class COREPROX_POLARITY XWbemClassObjectEx : public CImpl<IWbemClassObjectEx, CUMIObjectWrapper>
    {
    public:
        XWbemClassObjectEx(CUMIObjectWrapper* pObject) : 
            CImpl<IWbemClassObjectEx, CUMIObjectWrapper>(pObject)
        {}

		STDMETHOD(PutEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
		STDMETHOD(DeleteEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
	    STDMETHOD(GetEx)( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals, CIMTYPE* pCimType, long* plFlavor);

	} m_XWbemClassObjectEx;
	friend XWbemClassObjectEx;

	// IUmiObject Methods
    class COREPROX_POLARITY XUmiObject : public CImpl<IUmiObject, CUMIObjectWrapper>
    {
    public:
        XUmiObject(CUMIObjectWrapper* pObject) : 
            CImpl<IUmiObject, CUMIObjectWrapper>(pObject)
        {}
		/* IUmiPropList Methods */
		STDMETHOD(Put)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp );
		STDMETHOD(Get)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp );
		STDMETHOD(GetAt)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
		STDMETHOD(GetAs)( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp );
		STDMETHOD(FreeMemory)( ULONG uReserved, LPVOID pMem );
		STDMETHOD(Delete)( LPCWSTR pszName, ULONG uFlags );
		STDMETHOD(GetProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps );
		STDMETHOD(PutProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps );
		STDMETHOD(PutFrom)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );

		/* IUmiBaseObject Methods */
        STDMETHOD(GetLastStatus)( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj );
		STDMETHOD(GetInterfacePropList)( ULONG uFlags, IUmiPropList **pPropList );

		/* IUmiObject Methods */
        STDMETHOD(Clone)( ULONG uFlags, REFIID riid, LPVOID *pCopy );
        STDMETHOD(Refresh)( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames );
		STDMETHOD(CopyTo)( ULONG uFlags, IUmiURL *pURL, REFIID riid, LPVOID *pCopy );

		STDMETHOD(Commit)( ULONG uFlags );
	}	m_XUmiObject;
	friend XUmiObject;

	// IUmiObjectWrapper Methods
    class COREPROX_POLARITY XWbemUMIObjectWrapper : public CImpl<_IWbemUMIObjectWrapper, CUMIObjectWrapper>
    {
    public:
        XWbemUMIObjectWrapper(CUMIObjectWrapper* pObject) : 
            CImpl<_IWbemUMIObjectWrapper, CUMIObjectWrapper>(pObject)
        {}
		
		STDMETHOD(SetObject)( long lFlags, IUnknown* pUnk );
		// Sets the underlying UMI Object interface pointer
		STDMETHOD(ConnectToProvider)( LPCWSTR pwszUser, LPCWSTR pwszPassword, IUnknown* pPath, REFCLSID rclsid, IWbemContext* pCtx );
		// Connects the wrapper to a provider
	}	m_XWbemUMIObjectWrapper;
	friend XWbemUMIObjectWrapper;

	// IUmiCustomInterfaceFactory Methods
    class COREPROX_POLARITY XUmiCustIntfFactory : public CImpl<IUmiCustomInterfaceFactory, CUMIObjectWrapper>
    {
    public:
        XUmiCustIntfFactory(CUMIObjectWrapper* pObject) : 
            CImpl<IUmiCustomInterfaceFactory, CUMIObjectWrapper>(pObject)
        {}
		
		// Returns matching CLSID for requested IID
		STDMETHOD(GetCLSIDForIID)( REFIID riid, long lFlags, CLSID *pCLSID );

		// Creates (possibly aggregated) object of given CLSID and returns interface
		STDMETHOD(GetObjectByCLSID)( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface );

		// Provides DISPIDs for Names and the CLSID for the object that supports them
		STDMETHOD(GetCLSIDForNames)( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID );

	}	m_XUmiCustIntfFactory;
	friend XUmiCustIntfFactory;

    // IMarshal methods
    class COREPROX_POLARITY XObjectMarshal : public CImpl<IMarshal, CUMIObjectWrapper>
    {
    public:
        XObjectMarshal(CUMIObjectWrapper* pObject) : 
            CImpl<IMarshal, CUMIObjectWrapper>(pObject)
        {}
		STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
			void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
		STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
			void* pvReserved, DWORD mshlFlags, ULONG* plSize);
		STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv,
			DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
		STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
		STDMETHOD(ReleaseMarshalData)(IStream* pStream);
		STDMETHOD(DisconnectObject)(DWORD dwReserved);
	}	m_XObjectMarshal;
	friend XObjectMarshal;

    /* IWbemClassObject methods */
    virtual HRESULT GetQualifierSet(IWbemQualifierSet** pQualifierSet);
    virtual HRESULT Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
        long* plFlavor);

    virtual HRESULT Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
    virtual HRESULT Delete(LPCWSTR wszName);
    virtual HRESULT GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                        SAFEARRAY** pNames);
    virtual HRESULT BeginEnumeration(long lEnumFlags);

    virtual HRESULT Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                    long* plFlavor);

    virtual HRESULT EndEnumeration();

    virtual HRESULT GetPropertyQualifierSet(LPCWSTR wszProperty,
                                       IWbemQualifierSet** pQualifierSet);
    virtual HRESULT Clone(IWbemClassObject** pCopy);
    virtual HRESULT GetObjectText(long lFlags, BSTR* pMofSyntax);

    virtual HRESULT CompareTo(long lFlags, IWbemClassObject* pCompareTo);
    virtual HRESULT GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName);
    virtual HRESULT InheritsFrom(LPCWSTR wszClassName);

    virtual HRESULT SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass);
    virtual HRESULT SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance);
    virtual HRESULT GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                            IWbemClassObject** ppOutSig);
    virtual HRESULT PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                            IWbemClassObject* pOutSig);
    virtual HRESULT DeleteMethod(LPCWSTR wszName);
    virtual HRESULT BeginMethodEnumeration(long lFlags);
    virtual HRESULT NextMethod(long lFlags, BSTR* pstrName, 
                       IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
    virtual HRESULT EndMethodEnumeration();
    virtual HRESULT GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet);
    virtual HRESULT GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName);

	/* IWbemClassObjectEx Methods */
	virtual HRESULT PutEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
	virtual HRESULT DeleteEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals );
	virtual HRESULT GetEx( LPCWSTR wszName, long lFlags, VARIANT* pvFilter, VARIANT* pvInVals, CIMTYPE* pCimType, long* plFlavor);

	/* IUmiPropList Methods */
	virtual HRESULT Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp );
	virtual HRESULT Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp );
	virtual HRESULT GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
	virtual HRESULT GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp );
	virtual HRESULT FreeMemory( ULONG uReserved, LPVOID pMem );
	virtual HRESULT Delete( LPCWSTR pszName, ULONG uFlags );
	virtual HRESULT GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps );
	virtual HRESULT PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps );
	virtual HRESULT PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );

	/* IUmiBaseObject Methods */
    virtual HRESULT GetLastStatus( ULONG uFlags, ULONG *puSpecificStatus, REFIID riid, LPVOID *pStatusObj );
	virtual HRESULT GetInterfacePropList( ULONG uFlags, IUmiPropList **pPropList );

	/* IUmiObject Methods */
    virtual HRESULT Clone( ULONG uFlags, REFIID riid, LPVOID *pCopy );
    virtual HRESULT Refresh( ULONG uFlags, ULONG uNameCount, LPWSTR *pszNames );
	virtual HRESULT CopyTo( ULONG uFlags, IUmiURL *pURL, REFIID riid, LPVOID *pCopy );
	virtual HRESULT Commit( ULONG uFlags );

	/* _IWbemUMIObjectWrapper */
	virtual HRESULT SetObject( long lFlags, IUnknown* pUnk );
	virtual HRESULT ConnectToProvider( LPCWSTR pwszUser, LPCWSTR pwszPassword, IUnknown* pPath, REFCLSID rclsid, IWbemContext* pCtx );

	/* IMarshal methods */
	virtual HRESULT GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
		void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
	virtual HRESULT GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
		void* pvReserved, DWORD mshlFlags, ULONG* plSize);
	virtual HRESULT MarshalInterface(IStream* pStream, REFIID riid, void* pv,
		DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
	virtual HRESULT UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv);
	virtual HRESULT ReleaseMarshalData(IStream* pStream);
	virtual HRESULT DisconnectObject(DWORD dwReserved);

	/* IUmiCustomInterfaceFactory */
	virtual HRESULT GetCLSIDForIID( REFIID riid, long lFlags, CLSID *pCLSID );
	virtual HRESULT GetObjectByCLSID( CLSID clsid, IUnknown *pUnkOuter, DWORD dwClsContext, REFIID riid, long lFlags,  void **ppInterface );
	virtual HRESULT GetCLSIDForNames( LPOLESTR * rgszNames,	UINT cNames, LCID lcid, DISPID * rgDispId, long lFlags,	CLSID *pCLSID );


	// Lock/Unlock helpers
    HRESULT Lock(long lFlags);
    HRESULT Unlock(long lFlags);

protected:

	// Helper function that locks/unlocks the object using scoping
    class CLock
    {
    protected:
        CUMIObjectWrapper* m_p;
    public:
        CLock(CUMIObjectWrapper* p, long lFlags = 0) : m_p(p) { if ( NULL != p ) p->Lock(lFlags);}
        ~CLock() { if ( NULL != m_p ) m_p->Unlock(0);}
    };

    void* GetInterface(REFIID riid);

	HRESULT GetPropertyCimType( LPCWSTR wszName, CIMTYPE* pct );
	HRESULT IsInstance( BOOL* pfIsInst );
	HRESULT PutVariant( LPCWSTR wszName, ULONG umiOperation, VARIANT* pVal, CIMTYPE ct );

	HRESULT InitPropertyInfo( BOOL fInitSystemProps );

	HRESULT SetContainer( long lFlags, IUnknown* pContainer );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\umivalue.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UMIVALUE.H

Abstract:

  CUmiValue Definitions.

  Helper classes for UMI and WMI conversions.

History:

  6-Mar-2000	sanjes    Created.

--*/

#ifndef _UMIVALUE_H_
#define _UMIVALUE_H_

#include "corepol.h"
#include <arena.h>
#include "umi.h"

//***************************************************************************
//
//  class CUmiValue
//
//  Wrapper for UMI Values
//
//***************************************************************************

class COREPROX_POLARITY CUmiValue
{
protected:
	ULONG		m_uNumValues;
	UMI_TYPE	m_uType;
	UMI_VALUE	m_singleValue;
	UMI_VALUE*	m_pValue;
	BOOL		m_fCanDelete;	// Controls if we delete stuff when we clear

	// Helper for getting sizes
	static ULONG m_auUMITypeSize[UMI_TYPE_DEFAULT+1];

	// Coercion helpers
	BOOL CanCoerce( ULONG umiType );
	HRESULT CoerceTo( ULONG umiType, UMI_VALUE* pUmiValueSrc, UMI_VALUE* pUmiValueDest );

public:

    CUmiValue( UMI_TYPE uType = UMI_TYPE_NULL, ULONG uNumValues = 0, LPVOID pvData = NULL, BOOL fAcquire = FALSE );
	virtual ~CUmiValue(); 

	static ULONG Size( UMI_TYPE umiType );
	static BOOL	IsAllocatedType( UMI_TYPE umiType );
	static BOOL	IsAddRefType( UMI_TYPE umiType );
	static UMI_TYPE CIMTYPEToUmiType( CIMTYPE ct );
	static CIMTYPE UmiTypeToCIMTYPE( UMI_TYPE umiType );
	static UMI_TYPE GetBasic( UMI_TYPE umiType );

	// Data Management
	virtual void Clear( void );
	BOOL ValidIndex( ULONG uIndex );
	HRESULT Coerce( ULONG umiType );
	HRESULT CoerceToCIMTYPE( ULONG* puNumElements, ULONG* puBuffSize, CIMTYPE* pct, BYTE** pUmiValueDest );

	// Member variable access
	void SetCanDelete( BOOL fCanDelete )
	{ m_fCanDelete = fCanDelete; }
	ULONG GetNumVals( void )
	{ return m_uNumValues; }
	UMI_TYPE GetType( void )
	{ return m_uType; }

	// NULL functions
	void SetToNull( void )
	{ Clear();	m_uType = UMI_TYPE_NULL; }
	BOOL IsNull( void )
	{ return UMI_TYPE_NULL == m_uType; }

	// A down and dirty set
	HRESULT SetRaw( ULONG uNumValues, LPVOID pvData, UMI_TYPE umitype, BOOL fAcquire );
	HRESULT GetRaw( ULONG* puNumValues, LPVOID* ppvData, UMI_TYPE* pumitype );

	// Retrieves as a Variant
	HRESULT FillVariant( VARIANT* pVariant, BOOL fForceArray = FALSE );

	// Loads From a Variant
	HRESULT SetFromVariant( VARIANT* pVariant, ULONG umiType );
	HRESULT SetFromVariantArray( VARIANT* pVariant, ULONG umiType );

	// UMI_TYPE_I1
	HRESULT SetI1( BYTE* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_I1, fAcquire ); }
	HRESULT SetI1At( BYTE val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return WBEM_E_NOT_FOUND;	m_pValue->byteValue[uIndex] = val;		return WBEM_S_NO_ERROR; }
	HRESULT SetI1( BYTE val )
	{ return SetI1At( val, 0 ); }
	BYTE GetI1At( ULONG uIndex )
	{ return m_pValue->byteValue[uIndex]; }
	BYTE* GetI1( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->byteValue; }
	BYTE GetI1( void )
	{	ULONG	uTemp;	return *GetI1(uTemp);	}

	// UMI_TYPE_I2
	HRESULT SetI2( short* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_I2, fAcquire ); }
	HRESULT SetI2At( short val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return WBEM_E_NOT_FOUND;	m_pValue->wValue[uIndex] = (WORD) val;		return WBEM_S_NO_ERROR; }
	HRESULT SetI2( short val )
	{ return SetI2At( val, 0 ); }
	short GetI2At( ULONG uIndex )
	{ return (short) m_pValue->wValue[uIndex]; }
	short* GetI2( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return (short*) m_pValue->wValue; }
	short GetI2( void )
	{	ULONG	uTemp;	return *GetI2(uTemp);	}

	// UMI_TYPE_I4
	HRESULT SetI4( long* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_I4, fAcquire ); }
	HRESULT SetI4At( long val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return WBEM_E_NOT_FOUND;	m_pValue->lValue[uIndex] = val;		return WBEM_S_NO_ERROR; }
	HRESULT SetI4( long val )
	{ return SetI4At( val, 0 ); }
	long GetI4At( ULONG uIndex )
	{ return m_pValue->lValue[uIndex]; }
	long* GetI4( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->lValue; }
	long GetI4( void )
	{	ULONG	uTemp;	return *GetI4(uTemp);	}

	// UMI_TYPE_I8
	HRESULT SetI8( __int64* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_I8, fAcquire ); }
	HRESULT SetI8At( __int64 val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return WBEM_E_NOT_FOUND;	m_pValue->nValue64[uIndex] = val;		return WBEM_S_NO_ERROR; }
	HRESULT SetI8( __int64 val )
	{ return SetI8At( val, 0 ); }
	__int64 GetI8At( ULONG uIndex )
	{ return m_pValue->nValue64[uIndex]; }
	__int64* GetI8( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->nValue64; }
	__int64 GetI8( void )
	{	ULONG	uTemp;	return *GetI8(uTemp);	}

	// UMI_TYPE_UI1
	HRESULT SetUI1( BYTE* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_UI1, fAcquire ); }
	HRESULT SetUI1At( BYTE val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return WBEM_E_NOT_FOUND;	m_pValue->byteValue[uIndex] = val;		return WBEM_S_NO_ERROR; }
	HRESULT SetUI1( BYTE val )
	{ return SetUI1At( val, 0 ); }
	BYTE GetUI1At( ULONG uIndex )
	{ return m_pValue->byteValue[uIndex]; }
	BYTE* GetUI1( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->byteValue; }
	BYTE GetUI1( void )
	{	ULONG	uTemp;	return *GetUI1(uTemp);	}

	// UMI_TYPE_UI2
	HRESULT SetUI2( WORD* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_UI2, fAcquire ); }
	HRESULT SetUI2At( short val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return WBEM_E_NOT_FOUND;	m_pValue->wValue[uIndex] = val;		return WBEM_S_NO_ERROR; }
	HRESULT SetUI2( short val )
	{ return SetUI2At( val, 0 ); }
	WORD GetUI2At( ULONG uIndex )
	{ return m_pValue->wValue[uIndex]; }
	WORD* GetUI2( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->wValue; }
	WORD GetUI2( void )
	{	ULONG	uTemp;	return *GetUI2(uTemp);	}

	// UMI_TYPE_UI4
	HRESULT SetUI4( DWORD* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_UI4, fAcquire ); }
	HRESULT SetUI4At( DWORD val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return WBEM_E_NOT_FOUND;	m_pValue->dwValue[uIndex] = val;		return WBEM_S_NO_ERROR; }
	HRESULT SetUI4( int val )
	{ return SetUI4At( val, 0 ); }
	DWORD GetUI4At( ULONG uIndex )
	{ return m_pValue->dwValue[uIndex]; }
	DWORD* GetUI4( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->dwValue; }
	DWORD GetUI4( void )
	{	ULONG	uTemp;	return *GetUI4(uTemp);	}

	// UMI_TYPE_UI8
	HRESULT SetUI8( unsigned __int64* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_UI8, fAcquire ); }
	BOOL SetUI8At( unsigned __int64 val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return FALSE;	m_pValue->uValue64[uIndex] = val;		return TRUE; }
	HRESULT SetUI8( unsigned __int64 val )
	{ return SetUI8At( val, 0 ); }
	unsigned __int64 GetUI8At( ULONG uIndex )
	{ return m_pValue->uValue64[uIndex]; }
	unsigned __int64* GetUI8( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->uValue64; }
	unsigned __int64 GetUI8( void )
	{	ULONG	uTemp;	return *GetUI8(uTemp);	}

	// UMI_TYPE_R8
	HRESULT SetR8( double* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_R8, fAcquire ); }
	BOOL SetR8At( double val, ULONG uIndex )
	{ if ( !ValidIndex( uIndex ) ) return FALSE;	m_pValue->dblValue[uIndex] = val;		return TRUE; }
	HRESULT SetR8( double val )
	{ return SetR8At( val, 0 ); }
	double GetR8At( ULONG uIndex )
	{ return m_pValue->dblValue[uIndex]; }
	double* GetR8( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->dblValue; }
	double GetR8( void )
	{	ULONG	uTemp;	return *GetR8(uTemp);	}

	// UMI_TYPE_LPWSTR
	HRESULT SetLPWSTR( LPWSTR* pVal, ULONG uNumVals = 1, BOOL fAcquire = FALSE )
	{ return SetRaw( uNumVals, pVal, UMI_TYPE_LPWSTR, fAcquire ); }
	HRESULT SetLPWSTRAt( LPWSTR val, ULONG uIndex, BOOL fAcquire = FALSE );
	HRESULT SetLPWSTR( LPWSTR val )
	{ return SetLPWSTRAt( val, 0 ); }
	LPWSTR GetLPWSTRAt( ULONG uIndex )
	{ return m_pValue->pszStrValue[uIndex]; }
	LPWSTR* GetLPWSTR( ULONG& uNumVals )
	{ uNumVals = m_uNumValues;	return m_pValue->pszStrValue; }
	LPWSTR GetLPWSTR( void )
	{	ULONG	uTemp;	return *GetLPWSTR(uTemp);	}

/*
	// UMI_TYPE_R4
	void SetR4( float* pVal, ULONG uNumVals = 1 );
	{ SetRaw( uNumVals, pVal, UMI_TYPE_R4 ); }
	BOOL SetR4At( float val, ULONG uIndex );
	{ if ( !ValidIndex( uIndex ) ) return FALSE;	m_pValue->Value[uIndex] = val;		return TRUE; }
	float GetR4At( ULONG uIndex );
	{ return m_pValue->lValue[uIndex]; }
	float* GetR4( ULONG& uNumVals );
	{ return &m_pValue->lValue; }
*/

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemdatapacket.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMDATAPACKET.H

Abstract:

  Base class for data packets.

History:

--*/

#ifndef __WBEMDATAPACKET_H__
#define __WBEMDATAPACKET_H__

// All Datapackets preceded by these values.

// One of these values comes first
#define	WBEM_DATAPACKET_LITTLEENDIAN	0x00000000
#define	WBEM_DATAPACKET_BIGENDIAN		0xFFFFFFFF

// Then comes the signature bytes
#define	WBEM_DATAPACKET_SIGNATURE	{ 0x57, 0x42, 0x45, 0x4D, 0x44, 0x41, 0x54, 0x41 }

// We use an 8 byte signature
#define WBEM_DATAPACKET_SIZEOFSIGNATURE	8

// As DataPacketType is actually a byte, this gives us 255 of these effectively
typedef enum
{
	WBEM_DATAPACKETYPE_FIRST = 0,
	WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE = 0,
	WBEM_DATAPACKETTYPE_SMARTENUM_NEXT = 1,
	WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE = 2,
	WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT = 3,
	WBEM_DATAPACKETTYPE_LAST
} WBEM_DATAPACKETTYPE;

// Define any packet specific flags here (we're looking at BitMasks here)
typedef enum
{
	WBEM_DATAPACKETFLAGS_COMPRESSED = 1
} WBEM_DATAPACKETFLAGS;

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// Version 1 data packet
// Add data to these structures at the bottom to ensure backwards compatibility
typedef struct tagWBEM_DATAPACKET_HEADER1
{
	DWORD	dwByteOrdering;	// Big or Little Endian?
	BYTE	abSignature[WBEM_DATAPACKET_SIZEOFSIGNATURE];	// Set to the signature value defined above
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwFlags;		// Compression, encryption, etc.
	BYTE	bVersion;		// Version Number of Header.  Starting Version is 1.
	BYTE	bPacketType;	// Type of packet this is
} WBEM_DATAPACKET_HEADER1;

typedef WBEM_DATAPACKET_HEADER1*	PWBEM_DATAPACKET_HEADER1;

// Version Information

// As the packet format changes, change these to stay current
#define WBEM_DATAPACKET_HEADER_CURRENTVERSION	1
#define WBEM_DATAPACKET_HEADER					WBEM_DATAPACKET_HEADER1
#define PWBEM_DATAPACKET_HEADER					PWBEM_DATAPACKET_HEADER1

// Minimum packet size
#define	WBEM_DATAPACKET_HEADER_MINSIZE			sizeof(WBEM_DATAPACKET_HEADER1)

// restore packing
#pragma pack( pop )

// Accessor class for making packets from objects and turning packets
// into objects.

//
//	Class: CWbemDataPacket
//
//	This class is designed to provide a single point of access for working
//	with Wbem Data Packets.  Base classes should inherit from this class
//	and implement functions that:
//
//	1>	Return a precalculated length.
//	2>	Build a packet (including this header) from supplied data.
//	3>	Read an existing packet and supply appropriate data from it.
//
//	Derived classes are responsible for their own formats.  It is assumed that
//	a Wbem Data Packet is a large BLOB, which will always begin with this
//	header.
//
//	This class will not FREE up any memory it is sitting on top of.  It is
//	up to the supplier of said memory to clean up after themselves.
//

class COREPROX_POLARITY CWbemDataPacket
{
private:
protected:

	static BYTE				s_abSignature[WBEM_DATAPACKET_SIZEOFSIGNATURE];
	PWBEM_DATAPACKET_HEADER	m_pDataPacket;
	DWORD					m_dwPacketLength;

	// Packet Building Functions
	HRESULT SetupDataPacketHeader( DWORD dwDataSize, BYTE bPacketType, DWORD dwFlags, DWORD dwByteOrdering = WBEM_DATAPACKET_LITTLEENDIAN );

public:

	CWbemDataPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemDataPacket();

	DWORD GetMinHeaderSize( void );

	// Packet Validation
	virtual HRESULT IsValid( void );

	// Change the underlying pointers
	virtual void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline DWORD CWbemDataPacket::GetMinHeaderSize( void )
{
	return WBEM_DATAPACKET_HEADER_MINSIZE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasscache.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCLASSCACHE.CPP

Abstract:

  WBEM Class Cache

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <sync.h>
#include "wbemclasscache.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::CWbemClassCache
//  
//  Default class constructor.
//
//  Inputs:
//              DWORD   dwBlockSize -   Block Size to resize cache
//                                      with.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

CWbemClassCache::CWbemClassCache( DWORD dwBlockSize /* WBEMCLASSCACHE_DEFAULTBLOCKSIZE */ )
:   m_GuidToObjCache(),
    m_dwBlockSize( dwBlockSize )
{
    // NB: InitializeCriticalSection can raise a STATUS_NO_MEMORY exception
    InitializeCriticalSection( &m_cs );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::~CWbemClassCache
//  
//  Class destructor.
//
//  Inputs:
//              DWORD   dwBlockSize -   Block Size to resize cache
//                                      with.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

CWbemClassCache::~CWbemClassCache()
{
    try 
    {
        // Dump out our internal data
        Clear();
    }
    catch(...)
    {
        DeleteCriticalSection( &m_cs );
        throw;
    }

    DeleteCriticalSection( &m_cs );

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::Clear
//  
//  Empties out the cache.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

void CWbemClassCache::Clear( void )
{
    // Be careful here
    CInCritSec autoCS( &m_cs );

    // Walk the map and release all objects we find.
    for (   WBEMGUIDTOOBJMAPITER    iter = m_GuidToObjCache.begin();
            iter != m_GuidToObjCache.end();
            iter++ )
    {
        iter->second->Release();
    }

    m_GuidToObjCache.erase( m_GuidToObjCache.begin(), m_GuidToObjCache.end() );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::AddObject
//  
//  Associates a GUID with an IWbemClassObject and places them
//  in the cache.
//
//  Inputs:
//              GUID&               guid - GUID to associate with pObj.
//              IWbemClassObject*   pObj - Object to associate with guid.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   The object will be AddRef()'d.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassCache::AddObject( GUID& guid, IWbemClassObject* pObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pObj )
    {
        CGUID   guidInst( guid );

        // Must be threadsafe
        CInCritSec autoCS( &m_cs );

        // Add the object to the cache, if it doesn't already exist
        WBEMGUIDTOOBJMAPITER    iter;

        // If we found the guid, return an error (this shouldn't happen) 
        if( ( iter = m_GuidToObjCache.find( guidInst ) ) == m_GuidToObjCache.end() )
        {
            try
            {
                m_GuidToObjCache[guidInst] = pObj;
                pObj->AddRef();
            }
            catch( CX_MemoryException )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            catch(...)
            {
                // Catch-all will return generic
                hr = WBEM_E_FAILED;
            }
        }
        else
        {
            // We've got duplicate GUIDs.  Why did this happen?
            hr = WBEM_E_FAILED;
        }

    }   // NULL != pObj
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::GetObject
//  
//  Searches the cache for the supplied GUID, and returns the associated
//  object to the caller.
//
//  Inputs:
//              GUID&               guid - GUID to look for
//
//  Outputs:
//              IWbemClassObject**  ppObj - Object that guid refers to.
//
//  Returns:
//              None.
//
//  Comments:   The IWbemClassObject::AddRef() will be called before
//              the function returns.  Caller must Release() the
//              object.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassCache::GetObject( GUID& guidClassId, IWbemClassObject** ppObj )
{
    HRESULT hr = WBEM_E_FAILED;

    if ( NULL != ppObj )
    {
        CGUID   guidTemp( guidClassId );

        // Must be threadsafe
        CInCritSec autoCS( &m_cs );
        
        // Add the object to the cache, if it doesn't already exist
        WBEMGUIDTOOBJMAPITER    iter;

        // If we found the guid, return an error (this shouldn't happen) 
        if( ( iter = m_GuidToObjCache.find( guidTemp ) ) != m_GuidToObjCache.end() )
        {
            try 
            {
                *ppObj = iter->second;
                (*ppObj)->AddRef();
                hr = WBEM_S_NO_ERROR;
            }
            catch(...)
            {
                // Catch all will return generic error message
                hr = WBEM_E_FAILED;
            }
        }
        else
        {
            // We got problems!
            hr = WBEM_E_NOT_FOUND;
        }

    }   // NULL != pObj
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemdatapacket.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMDATAPACKET.CPP

Abstract:

    Base Data packet class

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "wbemdatapacket.h"

BYTE CWbemDataPacket::s_abSignature[WBEM_DATAPACKET_SIZEOFSIGNATURE] = WBEM_DATAPACKET_SIGNATURE;

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::CWbemDataPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemDataPacket::CWbemDataPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   m_pDataPacket( (PWBEM_DATAPACKET_HEADER) pDataPacket ),
    m_dwPacketLength( dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::~CWbemDataPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemDataPacket::~CWbemDataPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::IsValid
//  
//  Checks the underlying memory for known byte patterns and values
//  in the header to make the determination as to whether or not
//  the packet is a valid header.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemDataPacket::IsValid( void )
{
    HRESULT hr = WBEM_E_INVALID_OPERATION;

    // We must have a data packet
    if ( NULL != m_pDataPacket )
    {
        // The packet MUST be of at least the minimum size
        if ( m_dwPacketLength >= WBEM_DATAPACKET_HEADER_MINSIZE ) 
        {

            // The packet MUST start with one of the valid byte ordering values
            // immediately followed by the supplied signature
            if (    (   m_pDataPacket->dwByteOrdering == WBEM_DATAPACKET_LITTLEENDIAN
                    ||  m_pDataPacket->dwByteOrdering == WBEM_DATAPACKET_BIGENDIAN  )
                &&  memcmp( m_pDataPacket->abSignature, s_abSignature, WBEM_DATAPACKET_SIZEOFSIGNATURE ) == 0 )
            {
                // The packet type MUST be recognized
                if ( WBEM_DATAPACKETTYPE_LAST > m_pDataPacket->bPacketType )
                {

                    // Version must be <= to the current version or we in big trouble
                    if ( m_pDataPacket->bVersion <= WBEM_DATAPACKET_HEADER_CURRENTVERSION )
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hr = WBEM_E_MARSHAL_VERSION_MISMATCH;
                    }
                }
                else
                {
                    hr = WBEM_E_UNKNOWN_PACKET_TYPE;
                }

            }   // IF Check Signature
            else
            {
                hr = WBEM_E_MARSHAL_INVALID_SIGNATURE;
            }

        }   // IF length too small
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

    }   // IF buffer pointer invalid

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::SetupDataPacketHeader
//  
//  Places the supplied data in the supplied buffer in a format that
//  will identify the buffer as a Wbem data packet.
//
//  Inputs:
//              DWORD                   dwDataSize - Size of Data following header.
//              BYTE                    bPacketType - Our packet type.
//              DWORD                   dwFlags - Flag values.
//              DWORD                   dwByteOrdering - Byte ordering.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   dwByteOrdering should be either WBEM_DATAPACKET_LITTLEENDIAN or
//              WBEM_DATAPACKET_BIGENDIAN.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemDataPacket::SetupDataPacketHeader( DWORD dwDataSize, BYTE bPacketType, DWORD dwFlags, DWORD dwByteOrdering /* = WBEM_DATAPACKET_LITTLEENDIAN */ )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    // Initialize using our member variables
    LPBYTE  pData           =   (LPBYTE) m_pDataPacket;
    DWORD   dwBufferLength  =   m_dwPacketLength;

    // Pointer and length must be valid
    if ( NULL != pData )
    {

        if ( dwBufferLength >= ( sizeof(WBEM_DATAPACKET_HEADER) + dwDataSize ) )
        {

            // Now we can fill out the packet
            PWBEM_DATAPACKET_HEADER pDataPacket = (PWBEM_DATAPACKET_HEADER) pData;

            // Clear out memory, then fill out the packet
            ZeroMemory( pDataPacket, sizeof(WBEM_DATAPACKET_HEADER) );

            pDataPacket->dwByteOrdering = dwByteOrdering;
            memcpy( pDataPacket->abSignature, s_abSignature, WBEM_DATAPACKET_SIZEOFSIGNATURE );
            pDataPacket->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_HEADER);
            pDataPacket->dwDataSize = dwDataSize;
            pDataPacket->bVersion = WBEM_DATAPACKET_HEADER_CURRENTVERSION;
            pDataPacket->bPacketType = bPacketType;
            pDataPacket->dwFlags = dwFlags;

            hr = WBEM_S_NO_ERROR;

        }   // IF length is valid
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

    }   // IF NULL != pData

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemDataPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    m_pDataPacket = (PWBEM_DATAPACKET_HEADER) pDataPacket;
    m_dwPacketLength = dwPacketLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasstoidmap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCLASSTOIDMAP.CPP

Abstract:

  Class to id map for marshaling.

History:

--*/

///////////////////////////////////////////////////////////////////
//
//  Todo:       Create a new helper method to allocate and fetch
//              the object part.  Remove multiple maintenance 
//              points from AssignClassId and GetClassId
//
//
///////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <sync.h>
#include "wbemclasstoidmap.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::CWbemClassToIdMap
//  
//  Default Class Constructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClassToIdMap::CWbemClassToIdMap()
:   m_ClassToIdMap()
{
    InitializeCriticalSection( &m_cs );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::~CWbemClassToIdMap
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClassToIdMap::~CWbemClassToIdMap()
{
    DeleteCriticalSection( &m_cs );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::GetClassId
//  
//  Searches the map for the supplied object's class part and returns
//  the corresponding class id.
//
//  Inputs:
//              CWbemObject*    pObj - Pointer to Object
//              CMemBuffer*     pCacheBuffer - Object with a buffer to
//                              help minimize allocs.
//
//  Outputs:
//              GUID*           pguidClassId - Class Id we found.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassToIdMap::GetClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer /* = NULL */ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if ( NULL != pObj && NULL != pguidClassId )
        {
            // Obtain class part data from the supplied instance
            DWORD                   dwLength,
                                    dwLengthCopied;

            hr = pObj->GetObjectParts( NULL, 0, WBEM_OBJ_CLASS_PART, &dwLength );

            if ( WBEM_E_BUFFER_TOO_SMALL == hr )
            {
                // OOM: Local memory - will be cleaned up automatically
                CMemBuffer  buff;
                BOOL        fGotMem = FALSE;

                // If we got passed in a cache buffer, we can use this to
                // store data for multiple operations, and just set its pointers
                // and length in the stack buffer.  Otherwise do our own allocation
                if ( NULL != pCacheBuffer )
                {
                    // Only alloc if the buffer is to small
                    if ( pCacheBuffer->GetLength() < dwLength )
                    {
                        // OOM: Up to the calling method to clean up
                        fGotMem = pCacheBuffer->Alloc( dwLength );
                    }
                    else
                    {
                        fGotMem = TRUE;
                    }

                    // SetData means that buff won't free it.  Also the length
                    // we're interested in here is the length of the data, not
                    // the length of the buffer, since we already know it's big
                    // enough.

                    buff.SetData( pCacheBuffer->GetData(), dwLength );
                }
                else
                {
                    // OOM: Up to the calling method to clean up
                    // Must allocate buffer now.
                    fGotMem = buff.Alloc( dwLength );
                }

                // Now, if we've got a buffer of the appropriate length, copy out the data
                if ( fGotMem )
                {
                    hr = pObj->GetObjectParts( buff.GetData(), buff.GetLength(), 
                                                WBEM_OBJ_CLASS_PART, &dwLengthCopied );

                    if ( SUCCEEDED( hr ) )
                    {
                        WBEMCLASSTOIDMAPITER    iter;

                        CInCritSec autoCS( &m_cs );

                        // Store the id if we are able to find  a match for the buffer
                        if( ( iter = m_ClassToIdMap.find( buff ) ) != m_ClassToIdMap.end() )
                        {
                            *pguidClassId = iter->second;
                        }
                        else
                        {
                            hr = WBEM_E_FAILED;
                        }

                    }   // IF GetObjectParts\

                }   // IF buff.Alloc()
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // Buffer too small error

        }   // IF pointers valid
        else
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    catch (CX_MemoryException)
    {
        // OOM: Catch WMI Memory Exceptions
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        // OOM: Catchall for any unhandled exceptions
        hr = WBEM_E_FAILED;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::AssignClassId
//  
//  Adds the supplied object's class data to the map, assigning a newly
//  created GUID to the name.
//
//  Inputs:
//              CWbemObject*    pObj - Pointer to Object
//              CMemBuffer*     pCacheBuffer - Object with a buffer to
//                              help minimize allocs.
//
//  Outputs:
//              GUID*       pguidClassId - Class Id we obtained.
//
//  Returns:
//              None.
//
//  Comments:   For speed sake, we may which to use a cache of
//              GUIDs, as CoCreateGuid apparently uses a system
//              wide mutex to do its dirty work.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassToIdMap::AssignClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer /* = NULL */ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        if ( NULL != pObj && NULL != pguidClassId )
        {
            // Obtain class part data from the supplied instance
            DWORD                   dwLength,
                                    dwLengthCopied;

            hr = pObj->GetObjectParts( NULL, 0, WBEM_OBJ_CLASS_PART, &dwLength );

            if ( WBEM_E_BUFFER_TOO_SMALL == hr )
            {
                // OOM: Local memory - will be cleaned up automatically
                CMemBuffer  buff;
                BOOL        fGotMem = FALSE;

                // If we got passed in a cache buffer, we can use this to
                // store data for multiple operations, and just set its pointers
                // and length in the stack buffer.  Otherwise do our own allocation
                if ( NULL != pCacheBuffer )
                {
                    // Only alloc if the buffer is to small
                    if ( pCacheBuffer->GetLength() < dwLength )
                    {
                        // OOM: Up to the calling method to clean up
                        fGotMem = pCacheBuffer->Alloc( dwLength );
                    }
                    else
                    {
                        fGotMem = TRUE;
                    }

                    // SetData means that buff won't free it.  Also the length
                    // we're interested in here is the length of the data, not
                    // the length of the buffer, since we already know it's big
                    // enough.

                    buff.SetData( pCacheBuffer->GetData(), dwLength );
                }
                else
                {
                    // OOM: Up to the calling method to clean up
                    // Must allocate buffer now
                    fGotMem = buff.Alloc( dwLength );
                }

                // Now, if we've got a buffer of the appropriate length, copy out the data
                if ( fGotMem )
                {
                    hr = pObj->GetObjectParts( buff.GetData(), buff.GetLength(), 
                                                WBEM_OBJ_CLASS_PART, &dwLengthCopied );

                    if ( SUCCEEDED( hr ) )
                    {

                        WBEMCLASSTOIDMAPITER    iter;

                        CInCritSec autoCS( &m_cs );

                        // If we are unable to locate our key in the map, then we should
                        // add a new entry.
                        if( ( iter = m_ClassToIdMap.find( buff ) ) == m_ClassToIdMap.end() )
                        {
                            // Store the next id, then bump it up one.
                            GUID    guid;

                            hr = CoCreateGuid( &guid );

                            if ( SUCCEEDED( hr ) )
                            {
                                // Call CopyData on buff using its internal pointers if we
                                // are using a cache buffer, since we want the buffer to
                                // be stored locally at this point.  Otherwise there is no
                                // need to copy the buffer

                                if ( NULL == pCacheBuffer
                                    || buff.CopyData( buff.GetData(), buff.GetLength() ) )
                                {
                                    // At this point, buff only holds the pointers.  Force a copy
                                    // of the data to be made before we store the data.
                                    try
                                    {
                                        m_ClassToIdMap[buff] = guid;
                                        *pguidClassId = guid;
                                    }
                                    catch( CX_MemoryException )
                                    {
                                        hr = WBEM_E_OUT_OF_MEMORY;
                                    }
                                    catch(...)
                                    {
                                        // Catch-all will return generic
                                        hr = WBEM_E_FAILED;
                                    }
                                }
                                else
                                {
                                    hr = WBEM_E_OUT_OF_MEMORY;
                                }
                            }

                        }   // IF found
                        else
                        {
                            hr = WBEM_E_FAILED;
                        }

                    }   // IF GetObjectParts\

                }   // IF buff.Alloc()
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // Buffer too small error

        }   // IF pointers valid
        else
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }
    catch(CX_MemoryException)
    {
        // OOM: Catch WMI Memory Exceptions
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        // OOM: Catchall for any unhandled exceptions
        hr = WBEM_E_FAILED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasstoidmap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMCLASSTOIDMAP.H

Abstract:

  Class to id map for marshaling.

History:

--*/

#ifndef __WBEMCLASSTOIDMAP_H__
#define __WBEMCLASSTOIDMAP_H__

#include <map>
#include "wstlallc.h"

//
//	Class:	CMemBuffer
//
//	The intent of this class is to provide a packager for a memory buffer
//	so we can use the buffer in STL implementations of standard data structures
//	such as maps, vectors, lists, etc.
//
//

class COREPROX_POLARITY CMemBuffer
{
public:

	CMemBuffer( LPBYTE pbData = NULL, DWORD dwLength = 0 );
	CMemBuffer( const CMemBuffer& buff );
	~CMemBuffer();

	BOOL Alloc( DWORD dwLength );
	BOOL ReAlloc( DWORD dwLength );
	void Free( void );

	LPBYTE GetData( void );
	DWORD GetLength( void );
	BOOL CopyData( LPBYTE pbData, DWORD dwLength );
	void SetData( LPBYTE pbData, DWORD dwLength );

	CMemBuffer& operator=( CMemBuffer& buff );
	bool operator<( const CMemBuffer& buff ) const;
	bool operator==( const CMemBuffer& buff ) const;

private:

	LPBYTE	m_pbData;	// Pointer to buffer
	DWORD	m_dwLength;	// Length of buffer
	BOOL	m_fOwned;	// Is the buffer owned internally?
};

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::CMemBuffer
//	
//	 Class Constructor
//
//	Inputs:
//				LPBYTE		pbData - Data Buffer
//				DWORD		dwLength - Length of Buffer
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer::CMemBuffer( LPBYTE pbData /* = NULL */, DWORD dwLength /* = 0 */ )
:	m_pbData( pbData ),
	m_dwLength( dwLength ),
	m_fOwned( FALSE )
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::~CMemBuffer
//	
//	 Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer::~CMemBuffer()
{
	Free();
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::CMemBuffer
//	
//	 Class Copy Constructor
//
//	Inputs:
//				const CMemBuffer& buff - Bufffer object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer::CMemBuffer( const CMemBuffer& buff )
:	m_pbData( NULL ),
	m_dwLength( 0 ),
	m_fOwned( FALSE )
{
	// Perform Copy or set based on whether or not the buffer
	// we are copying owns its data or not.

	if ( buff.m_fOwned )
	{
		CopyData( buff.m_pbData, buff.m_dwLength );
	}
	else
	{
		SetData( buff.m_pbData, buff.m_dwLength );
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::GetData
//	
//	Retrieves a pointer to the internal data.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				LPBYTE m_pbData.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline LPBYTE CMemBuffer::GetData( void )
{
	return m_pbData;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::GetLength
//	
//	Retrieves the length value.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				DWORD m_dwLength.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline DWORD CMemBuffer::GetLength( void )
{
	return m_dwLength;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::Alloc
//	
//	Allocates a buffer to the specified length.
//
//	Inputs:
//				DWORD		dwLength - Length of buffer to allocate
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE	- Success/Failure
//
//	Comments:	Previous data is cleared.
//
///////////////////////////////////////////////////////////////////

inline BOOL CMemBuffer::Alloc( DWORD dwLength )
{
	Free();
	m_pbData = new BYTE[dwLength];

	if ( NULL != m_pbData )
	{
		m_dwLength = dwLength;
		m_fOwned = TRUE;
	}

	return NULL != m_pbData;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::ReAlloc
//	
//	Reallocs our buffer, copying data as necessary.
//
//	Inputs:
//				DWORD		dwLength - Length of buffer to allocate
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE	- Success/Failure
//
//	Comments:	Previous data is copied into new buffer.
//
///////////////////////////////////////////////////////////////////

inline BOOL CMemBuffer::ReAlloc( DWORD dwLength )
{
	LPBYTE	pbData = new BYTE[dwLength];

	if ( NULL != pbData )
	{
		CopyMemory( pbData, m_pbData, min( dwLength, m_dwLength ) );
		Free();
		m_pbData = pbData;
		m_dwLength = dwLength;
		m_fOwned = TRUE;
	}

	return ( NULL != pbData );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::Free
//	
//	Clears data.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Data buffer is only freed if it is owned
//
///////////////////////////////////////////////////////////////////

inline void CMemBuffer::Free( void )
{
	if ( NULL != m_pbData && m_fOwned )
	{
		delete [] m_pbData;
	}
	m_pbData = NULL;
	m_dwLength = 0;
	m_fOwned = FALSE;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::CopyData
//	
//	Copies supplied data internally.
//
//	Inputs:
//				LPBYTE		pbData - Data Buffer to copy
//				DWORD		dwLength - Length of buffer
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE	- Success/Failure
//
//	Comments:	Previous data is freed.
//
///////////////////////////////////////////////////////////////////

inline BOOL CMemBuffer::CopyData( LPBYTE pbData, DWORD dwLength )
{
	BOOL fReturn = Alloc( dwLength );

	if ( fReturn )
	{
		CopyMemory( m_pbData, pbData, dwLength );
	}

	return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::SetData
//	
//	Sets internal pointers, but does not allocate data.
//
//	Inputs:
//				LPBYTE		pbData - Data Buffer to set
//				DWORD		dwLength - Length of buffer
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE	- Success/Failure
//
//	Comments:	Previous data is freed.
//
///////////////////////////////////////////////////////////////////

inline void CMemBuffer::SetData( LPBYTE pbData, DWORD dwLength )
{
	Free();
	m_pbData = pbData;
	m_dwLength = dwLength;
	m_fOwned = FALSE;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::operator=
//	
//	Copies supplied Memory Buffer
//
//	Inputs:
//				CMemBuffer&	buff - Buffer object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				CMemBuffer&	*this
//
//	Comments:	CopyData() or SetData() called based on whether
//				the supplied buffer owns its data.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer& CMemBuffer::operator=( CMemBuffer& buff )
{
	if ( buff.m_fOwned )
	{
		CopyData( buff.m_pbData, buff.m_dwLength );
	}
	else
	{
		SetData( buff.m_pbData, buff.m_dwLength );
	}

	return *this;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::operator==
//	
//	Checks supplied Memory Buffer for equality
//
//	Inputs:
//				const CMemBuffer&	buff - Buffer object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE - Equals or not equals
//
//	Comments:	Compares data in this and that buffer.
//
///////////////////////////////////////////////////////////////////

inline bool CMemBuffer::operator==( const CMemBuffer& buff ) const
{
	if ( m_dwLength == buff.m_dwLength )
	{
		return ( memcmp( m_pbData, buff.m_pbData, m_dwLength ) == 0);
	}
	else
	{
		return false;
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CMemBuffer::operator<
//	
//	Checks supplied Memory Buffer for equality
//
//	Inputs:
//				const CMemBuffer&	buff - Buffer object to copy.
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE - Is Less Than
//
//	Comments:	Compares data in this and that buffer.
//
///////////////////////////////////////////////////////////////////

inline bool CMemBuffer::operator<( const CMemBuffer& buff ) const
{
	if ( m_dwLength == buff.m_dwLength  )
	{
		return ( memcmp( m_pbData, buff.m_pbData, m_dwLength ) < 0 );
	}
	else
	{
		return ( m_dwLength < buff.m_dwLength );
	}
}

//
//	Class:	CWbemClassToIdMap
//
//	This Class is intended to provide a simple interface for relating a classname
//	to a GUID.  It uses an STL map to accomplish this.  Because the class name
//	is a string, we convert it to a DWORD using a hash function.  The interface
//	to this function should be string based for ease of use.  The underlying
//	mechanism can be modified as needed should speed become an issue.
//

// Defines an allocator so we can throw exceptions
class CCToIdGUIDAlloc : public wbem_allocator<GUID>
{
};

typedef	std::map<CMemBuffer,GUID,less<CMemBuffer>,CCToIdGUIDAlloc>				WBEMCLASSTOIDMAP;
typedef	std::map<CMemBuffer,GUID,less<CMemBuffer>,CCToIdGUIDAlloc>::iterator	WBEMCLASSTOIDMAPITER;

#pragma warning(disable:4251)   // benign warning in this case
// This is so we can get all that dllimport/dllexport hoohah all sorted out
class COREPROX_POLARITY CWrapClassToIdMap : public WBEMCLASSTOIDMAP
{
};

class COREPROX_POLARITY CWbemClassToIdMap
{
private:

	CRITICAL_SECTION	m_cs;
	CWrapClassToIdMap	m_ClassToIdMap;

public:

	CWbemClassToIdMap();
	~CWbemClassToIdMap();

	HRESULT GetClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer = NULL );
	HRESULT AssignClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer = NULL );
};

inline bool operator==(const CCToIdGUIDAlloc&, const CCToIdGUIDAlloc&)
    { return (true); }
inline bool operator!=(const CCToIdGUIDAlloc&, const CCToIdGUIDAlloc&)
    { return (false); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasscache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCLASSCACHE.H

Abstract:

    Class Cache for marshaling

History:

--*/

#ifndef __WBEMCLASSCACHE_H__
#define __WBEMCLASSCACHE_H__

#include "wbemguid.h"
#include <vector>
#include "wstlallc.h"

//
//	Class:	CWbemClassCacheData
//
//	The intent of this class is to provide a packager for the data we contain
//	in the CWbemClassCache object.  It provides accessors to the data and
//	overloads appropriate operators so it will work with STL as well as any
//	other collection classes we may choose to use for the cache.
//
//

// Class to hold the Wbem Class Data
class COREPROX_POLARITY CWbemClassCacheData
{
private:

	GUID				m_guidClassId;
	IWbemClassObject*	m_pObj;

	CWbemClassCacheData& Equals( const CWbemClassCacheData& data );

public:

	CWbemClassCacheData();
	CWbemClassCacheData( const CWbemClassCacheData& data );
	~CWbemClassCacheData();

	void SetData( const GUID& guid, IWbemClassObject* pObj );
	BOOL IsGUID( GUID& guid );
	void GetGUID( GUID& guid );
	BOOL IsEmpty( void );
	IWbemClassObject* GetClassObject( void );
	void SetClassObject( IWbemClassObject* pObj );

	CWbemClassCacheData& operator=( const CWbemClassCacheData& data );
	bool operator<( const CWbemClassCacheData& data ) const ;
	bool operator==( const CWbemClassCacheData& data ) const ;
};

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::CWbemClassCacheData
//	
//	Default Class Constructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CWbemClassCacheData::CWbemClassCacheData()
: m_pObj( NULL )
{
	ZeroMemory( &m_guidClassId, sizeof(GUID) );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::CWbemClassCacheData
//	
//	Class Copy Constructor
//
//	Inputs:
//				const CWbemClassCacheData& data - Class to copy
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CWbemClassCacheData::CWbemClassCacheData( const CWbemClassCacheData& data )
: m_pObj( NULL )
{
	Equals( data );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::~CWbemClassCacheData
//	
//	Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CWbemClassCacheData::~CWbemClassCacheData()
{
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::Operator<
//	
//	Class < Operator
//
//	Inputs:
//				const CWbemClassCacheData& data - Class to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Compares GUIDs.
//
///////////////////////////////////////////////////////////////////

inline bool CWbemClassCacheData::operator<( const CWbemClassCacheData& data ) const 
{
	return ( memcmp( &m_guidClassId, &data.m_guidClassId, sizeof(GUID) ) < 0 );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::Operator==
//	
//	Class == Operator
//
//	Inputs:
//				const CWbemClassCacheData& data - Class to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Compares GUIDs.
//
///////////////////////////////////////////////////////////////////

inline bool CWbemClassCacheData::operator==( const CWbemClassCacheData& data ) const 
{
	return ( memcmp( &m_guidClassId, &data.m_guidClassId, sizeof(GUID) ) == 0 );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::Operator=
//	
//	Class = Operator
//
//	Inputs:
//				const CWbemClassCacheData& data - Class to copy
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Copies GUID and object.  AddRef() and Release() called
//				as appropriate.
//
///////////////////////////////////////////////////////////////////

inline CWbemClassCacheData& CWbemClassCacheData::operator=( const CWbemClassCacheData& data )
{
	return Equals( data );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::Equals
//	
//	Sets 'this' class equal to another.
//
//	Inputs:
//				const CWbemClassCacheData& data - Class to copy
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Copies GUID and object.  AddRef() and Release() called
//				as appropriate.
//
///////////////////////////////////////////////////////////////////

inline CWbemClassCacheData& CWbemClassCacheData::Equals( const CWbemClassCacheData& data )
{
	SetData( data.m_guidClassId, data.m_pObj );
	return *this;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::SetData
//	
//	Sets the data in 'this' class
//
//	Inputs:
//				const GUID&			guid - New GUID
//				IWbemClassObject*	pObj - Object to associate to guid
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Calls AddRef() on pObj.
//
///////////////////////////////////////////////////////////////////

inline void CWbemClassCacheData::SetData( const GUID& guid, IWbemClassObject* pObj )
{
	m_guidClassId = guid;
	SetClassObject( pObj );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::SetClassObject
//	
//	Sets the Object value
//
//	Inputs:
//				IWbemClassObject*	pObj - New Object pointer.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	Calls AddRef() on pObj. Release() on previous value.
//
///////////////////////////////////////////////////////////////////

inline void CWbemClassCacheData::SetClassObject( IWbemClassObject* pObj )
{
	IWbemClassObject* pOldObj = m_pObj;

	m_pObj = pObj;

	// AddRef the new value as necessary
	if ( NULL != m_pObj )
	{
		m_pObj->AddRef();
	}

	// Clean up the old value
	if ( NULL != pOldObj )
	{
		pOldObj->Release();
	}
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::IsGUID
//	
//	Returns whether or not our guid matches the supplied one.
//
//	Inputs:
//				GUID&	guid - GUID to compare to.
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline BOOL CWbemClassCacheData::IsGUID( GUID& guid )
{
	return ( memcmp( &m_guidClassId, &guid, sizeof(GUID) ) == 0 );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::IsEmpty
//	
//	Returns whether or not our object is set.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				TRUE/FALSE
//
//	Comments:	This is a hack for quickness sake.
//
///////////////////////////////////////////////////////////////////

inline BOOL CWbemClassCacheData::IsEmpty( void )
{
	return ( NULL == m_pObj );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::GetGUID
//	
//	Returns our GUID.
//
//	Inputs:
//				None.
//
//	Outputs:
//				GUID&	guid - Storage for a GUID.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline void CWbemClassCacheData::GetGUID( GUID& guid )
{
	guid = m_guidClassId;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CWbemClassCacheData::GetClassObject
//	
//	Returns our IWbemClassObject* pointer.
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				IWbemClassObject*	- Can be NULL.
//
//	Comments:	Calls AddRef() on the pointer before returning.
//
///////////////////////////////////////////////////////////////////

inline IWbemClassObject* CWbemClassCacheData::GetClassObject( void )
{
	// AddRef before we return
	if ( NULL != m_pObj )
	{
		m_pObj->AddRef();
	}

	return m_pObj;
}

//
//	Class:	CWbemClassCache
//
//	This class is intended to provide an easy to use interface for relating
//	GUIDs to IWbemClassObject pointers.  Its primary use is during Unmarshaling
//	of object pointers for WBEM operations in which we intend to share data
//	pieces between many individual IWbemClassObjects.
//
//

// Default Block Size for the class object array
#define	WBEMCLASSCACHE_DEFAULTBLOCKSIZE	64

// Defines an allocator so we can throw exceptions
class CCCWCOAlloc : public wbem_allocator<IWbemClassObject*>
{
};

typedef std::map<CGUID,IWbemClassObject*,less<CGUID>,CCCWCOAlloc>				WBEMGUIDTOOBJMAP;
typedef std::map<CGUID,IWbemClassObject*,less<CGUID>,CCCWCOAlloc>::iterator		WBEMGUIDTOOBJMAPITER;

#pragma warning(disable:4251)   // benign warning in this instance
// This is so we can get all that dllimport/dllexport hoohah all sorted out
class COREPROX_POLARITY CWbemGUIDToObjMap : public WBEMGUIDTOOBJMAP
{
};

class COREPROX_POLARITY CWbemClassCache
{
private:

	CRITICAL_SECTION	m_cs;
	CWbemGUIDToObjMap	m_GuidToObjCache;
	DWORD				m_dwBlockSize;

	void Clear(void);

public:

	CWbemClassCache( DWORD dwBlockSize = WBEMCLASSCACHE_DEFAULTBLOCKSIZE );
	~CWbemClassCache();

	// AddRefs the object if placed in the map.  Released on destruction
	HRESULT AddObject( GUID& guid, IWbemClassObject* pObj );

	// If object is found, it is AddRefd before it is returned
	HRESULT GetObject( GUID& guid, IWbemClassObject** pObj );
};


// new compiler gives C2678 errors since class is exported
inline bool operator==(const CCCWCOAlloc&, const CCCWCOAlloc&)
    { return (true); }

inline bool operator!=(const CCCWCOAlloc&, const CCCWCOAlloc&)
    { return (false); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemguidtoclassmap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMGUIDTOCLASSMAP.CPP

Abstract:

    GUID to class map for marshaling.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <sync.h>
#include "wbemguidtoclassmap.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::CWbemGuidToClassMap
//  
//  Default Class Constructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemGuidToClassMap::CWbemGuidToClassMap()
:   m_GuidToClassMap()
{
    InitializeCriticalSection( &m_cs );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::~CWbemGuidToClassMap
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemGuidToClassMap::~CWbemGuidToClassMap()
{
    Clear();
    DeleteCriticalSection( &m_cs );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::Clear
//  
//  Empties out the cache.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

void CWbemGuidToClassMap::Clear( void )
{
    // Be careful here
    EnterCriticalSection( &m_cs );

    // Walk the map and release all objects we find.
    for (   WBEMGUIDTOCLASSMAPITER  iter = m_GuidToClassMap.begin();
            iter != m_GuidToClassMap.end();
            iter++ )
    {
        delete iter->second;
    }

    m_GuidToClassMap.erase( m_GuidToClassMap.begin(), m_GuidToClassMap.end() );

    LeaveCriticalSection( &m_cs );
}


///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::GetMap
//  
//  Searches the map for the supplied guid name and returns the
//  corresponding map.
//
//  Inputs:
//              CGUD&       guid - GUID to find
//
//  Outputs:
//              CWbemClassToIdMap** ppMap - Storage for pointer
//
//  Returns:
//              WBEM_S_NO_ERROR of successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemGuidToClassMap::GetMap( CGUID& guid, CWbemClassToIdMap** ppMap )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != ppMap )
    {
        WBEMGUIDTOCLASSMAPITER  iter;

        EnterCriticalSection( &m_cs );

        // Store the pointer if we can find our GUID
        if( ( iter = m_GuidToClassMap.find( guid ) ) != m_GuidToClassMap.end() )
        {
            *ppMap = iter->second;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

        LeaveCriticalSection( &m_cs );
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::AddMap
//  
//  Adds the supplied guid to the map, assigning a new class to
//  ID map  to the GUID.
//
//  Inputs:
//              CGUID&      guid - Guid to add
//
//  Outputs:
//              CWbemClassToIdMap** ppMap - Map to assign to GUID.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemGuidToClassMap::AddMap( CGUID& guid, CWbemClassToIdMap** ppMap )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != ppMap )
    {
        WBEMGUIDTOCLASSMAPITER  iter;

        // Must be threadsafe
        CInCritSec autoCS( &m_cs );

        // If we are unable to locate our guid in the map, then we should
        // add a new entry.
        if( ( iter = m_GuidToClassMap.find( guid ) ) == m_GuidToClassMap.end() )
        {
            // Allocate and store a new map
            CWbemClassToIdMap*  pMap = new CWbemClassToIdMap;

            if ( NULL != pMap )
            {
                try
                {
                    m_GuidToClassMap[guid] = pMap;
                    *ppMap = pMap;
                }
                catch( CX_MemoryException )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                catch(...)
                {
                    // Catch-all will return generic
                    hr = WBEM_E_FAILED;
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemguid.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMGUID.H

Abstract:

	GUID wrapper class

History:

--*/

#ifndef __GUID_H__
#define __GUID_H__

//
//	Class:	CGUID
//
//	The intent of this class is to provide a packager for a GUID so we can
//	us the GUID in STL implementations of standard data structures such
//	as maps, vectors, lists, etc.
//
//

class CGUID
{
private:
	GUID	m_guid;

public:

	CGUID();
	CGUID( const GUID& guid );
	CGUID( const CGUID& guid );
	~CGUID();

	void SetGUID( const GUID& guid );
	void GetGUID( GUID& guid );
	CGUID& operator=( const CGUID& guid );
	bool operator<( const CGUID& guid ) const ;
	bool operator==( const CGUID& guid ) const ;


};

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::CGUID
//	
//	Default Class Constructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::CGUID()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::CGUID
//	
//	Class Constructor
//
//	Inputs:
//				const GUID&	guid - Initializes from a raw GUID
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::CGUID( const GUID& guid )
{
	m_guid = guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::CGUID
//	
//	Class Copy Constructor
//
//	Inputs:
//				const CGUID&	guid - instance to copy
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::CGUID( const CGUID& guid )
{
	m_guid = guid.m_guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::~CGUID
//	
//	Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::~CGUID()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::SetGUID
//	
//	GUID Accessor.
//
//	Inputs:
//				const GUID&	guid - Guid to set to.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline void CGUID::SetGUID( const GUID& guid )
{
	m_guid = guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::GetGUID
//	
//	GUID Accessor.
//
//	Inputs:
//				GUID&	guid - Storage for GUID
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline void CGUID::GetGUID( GUID& guid )
{
	m_guid = guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::operator=
//	
//	Equals Operator
//
//	Inputs:
//				const CGUID&	guid - instance to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				CGUID& this
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID& CGUID::operator=( const CGUID& guid )
{
	m_guid = guid.m_guid;
	return *this;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::operator<
//	
//	Less than operator
//
//	Inputs:
//				const CGUID&	guid - instance to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				bool	TRUE/FALSE
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline bool CGUID::operator<( const CGUID& guid ) const
{
	return ( memcmp( &m_guid, &guid.m_guid, sizeof(GUID) ) < 0 );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::operator==
//	
//	Comparison operator
//
//	Inputs:
//				const CGUID&	guid - instance to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				bool	TRUE/FALSE
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline bool CGUID::operator==( const CGUID& guid ) const
{
	return ( memcmp( &m_guid, &guid.m_guid, sizeof(GUID) ) == 0 );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemobjpacket.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMOBJPACKET.H

Abstract:

	Object packet classes.

History:

--*/

#ifndef __WBEMOBJPACKET_H__
#define __WBEMOBJPACKET_H__

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// Define any IWbemClassObject Packet Types
typedef enum
{
	WBEMOBJECT_FIRST			= 0,	
	WBEMOBJECT_NONE				= 0,	
	WBEMOBJECT_CLASS_FULL		= 1,
	WBEMOBJECT_INSTANCE_FULL	= 2,
	WBEMOBJECT_INSTANCE_NOCLASS	= 3,
	WBEMOBJECT_LAST
} WBEMOBJECT_PACKETTYPE;

// Add Data at the bottom of this structure to ensure backwards compatibility.
// If this or any of the subsequent structures changes, bump up version
// information above

typedef struct tagWBEM_DATAPACKET_OBJECT_HEADER
{
	DWORD	dwSizeOfHeader;	// Size Of Header
	DWORD	dwSizeOfData;	// Size Of Data following Header
	BYTE	bObjectType;	// Value from WBEMOBJECT_PACKETTYPE
} WBEM_DATAPACKET_OBJECT_HEADER;

typedef WBEM_DATAPACKET_OBJECT_HEADER* PWBEM_DATAPACKET_OBJECT_HEADER;

// Add Data at the bottom of this structure to ensure backwards compatibility.
// If this or any of the subsequent structures changes, bump up version
// information above

typedef struct tagWBEM_DATAPACKET_CLASS_HEADER
{
	DWORD	dwSizeOfHeader;	// Size Of Header
	DWORD	dwSizeOfData;	// Size Of Data following Header
} WBEM_DATAPACKET_CLASS_HEADER;

typedef WBEM_DATAPACKET_CLASS_HEADER* PWBEM_DATAPACKET_CLASS_HEADER;

typedef struct tagWBEM_DATAPACKET_CLASS_FULL
{
	WBEM_DATAPACKET_CLASS_HEADER	ClassHeader;		// Header information	
} WBEM_DATAPACKET_CLASS_FULL;

typedef WBEM_DATAPACKET_CLASS_FULL* PWBEM_DATAPACKET_CLASS_FULL;

// Add Data at the bottom of this structure to ensure backwards compatibility.
// If this or any of the subsequent structures changes, bump up version
// information above

typedef struct tagWBEM_DATAPACKET_INSTANCE_HEADER
{
	DWORD	dwSizeOfHeader;	// Size Of Header
	DWORD	dwSizeOfData;	// Size Of Data following Header
	GUID	guidClassId;	// Class Id for caching
} WBEM_DATAPACKET_INSTANCE_HEADER;

typedef WBEM_DATAPACKET_INSTANCE_HEADER* PWBEM_DATAPACKET_INSTANCE_HEADER;

// Following the header in the following structures, will be the actual data in
// byte format.

typedef struct tagWBEM_DATAPACKET_INSTANCE_FULL
{
	WBEM_DATAPACKET_INSTANCE_HEADER	InstanceHeader;		// Header information	
} WBEM_DATAPACKET_INSTANCE_FULL;

typedef WBEM_DATAPACKET_INSTANCE_FULL*	PWBEM_DATAPACKET_INSTANCE_FULL;

typedef struct tagWBEM_DATAPACKET_INSTANCE_NOCLASS
{
	WBEM_DATAPACKET_INSTANCE_HEADER	InstanceHeader;		// Header information	
} WBEM_DATAPACKET_INSTANCE_NOCLASS;

typedef WBEM_DATAPACKET_INSTANCE_NOCLASS*	PWBEM_DATAPACKET_INSTANCE_NOCLASS;

// restore packing
#pragma pack( pop )

// Accessor class for making packets from objects and turning packets
// into objects.

// Forward Class References
class CWbemInstance;

//
//	Class: CWbemObjectPacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject pointer.  As these objects are actually divided into
//	classes and instances, this class is designed to be a base class for
//	the classes that actually perform the packetizing/unpacketizing of the
//	data.
//

class CWbemObjectPacket
{
private:
protected:

	PWBEM_DATAPACKET_OBJECT_HEADER	m_pObjectPacket;
	DWORD							m_dwPacketLength;

	// Packet Building Functions
	HRESULT SetupObjectPacketHeader( DWORD dwDataSize, BYTE bPacketType );

public:

	CWbemObjectPacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemObjectPacket( CWbemObjectPacket& objectPacket );
	~CWbemObjectPacket();

	HRESULT	CalculatePacketLength( IWbemClassObject* pObj, DWORD* pdwLength, BOOL fFull = TRUE  );

	BYTE	GetObjectType( void );
	DWORD	GetDataSize( void );

	HRESULT WriteEmptyHeader( void );

	// Change the underlying pointers
	virtual void SetData( LPBYTE pObjectPacket, DWORD dwPacketLength );
};

inline BYTE CWbemObjectPacket::GetObjectType( void )
{
	return ( NULL == m_pObjectPacket ? WBEMOBJECT_FIRST : m_pObjectPacket->bObjectType );
}

inline DWORD CWbemObjectPacket::GetDataSize( void )
{
	return ( NULL == m_pObjectPacket ? 0 : m_pObjectPacket->dwSizeOfData );
}

inline HRESULT CWbemObjectPacket::WriteEmptyHeader( void )
{
	return SetupObjectPacketHeader( 0, WBEMOBJECT_NONE );
}

//
//	Class: CWbemClassPacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject that is a class.  It is responsible for reading and
//	writing these objects to and from memory.
//

class CWbemClassPacket : public CWbemObjectPacket
{
private:
protected:

	PWBEM_DATAPACKET_CLASS_FULL	m_pWbemClassData;

public:

	CWbemClassPacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemClassPacket( CWbemObjectPacket& objectPacket );
	~CWbemClassPacket();

	HRESULT GetWbemClassObject( CWbemClass** pWbemClass );
	HRESULT WriteToPacket( IWbemClassObject* pObj, DWORD* pdwLengthUsed );

	// Helper function
	HRESULT WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, DWORD* pdwLengthUsed );
	DWORD	GetClassSize( void );

	// Change the underlying pointers
	void SetData( LPBYTE pObjectPacket, DWORD dwPacketLength );
};

inline DWORD CWbemClassPacket::GetClassSize( void )
{
	return ( NULL == m_pWbemClassData ? 0 : m_pWbemClassData->ClassHeader.dwSizeOfData );
}

inline HRESULT CWbemClassPacket::WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, DWORD* pdwLengthUsed )
{
	SetData( pData, dwBufferLength );
	return WriteToPacket( pObj, pdwLengthUsed );
}

//
//	Class: CWbemInstancePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject that is an instance.  It is responsible for reading
//	and writing these objects to and from memory.  Please note that
//	it acts as a base class for Classless Instance objects.
//

class CWbemInstancePacket : public CWbemObjectPacket
{
private:
protected:

	PWBEM_DATAPACKET_INSTANCE_HEADER	m_pWbemInstanceData;

	virtual BYTE GetInstanceType( void );
	virtual HRESULT GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed );
	virtual void SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize );

public:

	CWbemInstancePacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemInstancePacket( CWbemObjectPacket& objectPacket );
	~CWbemInstancePacket();

	HRESULT GetWbemInstanceObject( CWbemInstance** pWbemInstance, GUID& guidClassId );
	HRESULT WriteToPacket( IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed );

	// Helper function
	HRESULT WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed );
	DWORD	GetInstanceSize( void );

	// Change the underlying pointers
	void SetData( LPBYTE pObjectPacket, DWORD dwPacketLength );
};

inline DWORD CWbemInstancePacket::GetInstanceSize( void )
{
	return ( NULL == m_pWbemInstanceData ? 0 : m_pWbemInstanceData->dwSizeOfData );
}

inline HRESULT CWbemInstancePacket::WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed )
{
	SetData( pData, dwBufferLength );
	return WriteToPacket( pObj, guidClassId, pdwLengthUsed );
}

//
//	Class: CWbemClasslessInstancePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject that is a classless instance.  These are instances
//	that we have decided should NOT contain class information when written
//	out, and read back in.  Once read back in, however, these objects
//	will need to have class data passed in, or merged in, before they will
//	work properly.
//

class COREPROX_POLARITY CWbemClasslessInstancePacket : public CWbemInstancePacket
{
private:
protected:

	virtual BYTE GetInstanceType( void );
	virtual HRESULT GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed );
	virtual void SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize );

public:

	CWbemClasslessInstancePacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemClasslessInstancePacket( CWbemObjectPacket& objectPacket );
	~CWbemClasslessInstancePacket();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemguidtoclassmap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMGUIDTOCLASSMAP.H

Abstract:

	GUID to class map for marshaling.

History:

--*/

#ifndef __WBEMGUIDTOCLASSMAP_H__
#define __WBEMGUIDTOCLASSMAP_H__

#include "wbemguid.h"
#include "wbemclasstoidmap.h"
#include <map>
#include "wstlallc.h"

//
//	Class:	CWbemGuidToClassMap
//
//	This Class is intended to provide a simple interface for relating a GUID
//	to a class to id map.  It uses an STL map to accomplish this.  In cases where we
//	need to keep multiple caches for unique instances, this map provides an
//	easy interface for doing so.
//

// Defines an allocator so we can throw exceptions
class CGUIDToClassMapAlloc : public wbem_allocator<CWbemClassToIdMap*>
{
};

typedef	std::map<CGUID,CWbemClassToIdMap*,less<CGUID>,CGUIDToClassMapAlloc>				WBEMGUIDTOCLASSMAP;
typedef	std::map<CGUID,CWbemClassToIdMap*,less<CGUID>,CGUIDToClassMapAlloc>::iterator	WBEMGUIDTOCLASSMAPITER;

#pragma warning(disable:4251)   // benign warning in this instance
// This is so we can get all that dllimport/dllexport hoohah all sorted out
class COREPROX_POLARITY CWrapWbemGUIDToClassMap : public WBEMGUIDTOCLASSMAP
{
};

class COREPROX_POLARITY CWbemGuidToClassMap
{
private:

	CRITICAL_SECTION	m_cs;
	CWrapWbemGUIDToClassMap	m_GuidToClassMap;

	void Clear( void );

public:

	CWbemGuidToClassMap();
	~CWbemGuidToClassMap();

	HRESULT GetMap( CGUID& guid, CWbemClassToIdMap** ppCache );
	HRESULT AddMap( CGUID& guid, CWbemClassToIdMap** pppCache );

};


inline bool operator==(const CGUIDToClassMapAlloc&, const CGUIDToClassMapAlloc&)
    { return (true); }
inline bool operator!=(const CGUIDToClassMapAlloc&, const CGUIDToClassMapAlloc&)
    { return (false); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wcommrsh.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WCOMMRSH.CPP

Abstract:

    IWbemComBinding marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "wcommrsh.h"
#include <fastall.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CComBindFactoryBuffer::XComBindFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CComBindFactoryBuffer::XComBindFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemComBinding)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CComBindProxyBuffer* pProxy = new CComBindProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
		sc = pProxy->Init();

		if ( SUCCEEDED( sc ) )
		{
			pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
			sc = pProxy->QueryInterface(riid, (void**)ppv);
		}
		else
		{
			delete pProxy;
		}
    }

    return sc;
}

//***************************************************************************
//
//  CComBindFactoryBuffer::XComBindFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemComBinding 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CComBindFactoryBuffer::XComBindFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemComBinding)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CComBindStubBuffer* pStub = new CComBindStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CComBindFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CComBindFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CComBindFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XComBindFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CComBindProxyBuffer::CComBindProxyBuffer
//  ~CComBindProxyBuffer::CComBindProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CComBindProxyBuffer::CComBindProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IWbemComBinding ), 
		m_pComBinding( NULL )
{
}

CComBindProxyBuffer::~CComBindProxyBuffer()
{
    // This should all be cleaned up here

	if ( NULL != m_pComBinding )
	{
		m_pComBinding->Release();
	}

}

HRESULT CComBindProxyBuffer::Init( void )
{
    m_pComBinding = new CWmiComBinding( m_pControl, m_pUnkOuter );

	if ( NULL == m_pComBinding )
	{
		return E_OUTOFMEMORY;
	}

	m_pComBinding->AddRef();

	return S_OK;
}

void* CComBindProxyBuffer::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemComBinding  )
	{
		void*	pvData = NULL;

		// This will AddRef the UnkOuter, so we need to release, and
		// then we'll return pvoid, which will get Addref'd again
		// isn't aggregation wonderful

		m_pComBinding->QueryInterface( riid, &pvData );
		((IUnknown*) pvData)->Release();

		return pvData;
	}
    else return NULL;
}

// We're not using an old proxy, so don't worry about this
void** CComBindProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return NULL;
}

void CComBindProxyBuffer::ReleaseOldProxyInterface( void )
{
}

//***************************************************************************
//
//  STDMETHODIMP CComBindProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.  We let the base class initialize first, then pass the
//	base proxy into the delegator
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CComBindProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{
	// We don't really need to the RPC Channel buffer, since we're not even
	// going to call out on it, but it can't hurt to keep it

	// Just AddRef and return a success

    m_pChannel = pChannel;
    if(m_pChannel)
        m_pChannel->AddRef();

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  STDMETHODIMP CComBindProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//	We cleanup before the base cleans up, or things can and will beef
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CComBindProxyBuffer::Disconnect()
{
	// Cleanup then let the base class do its dirty work
	if ( NULL != m_pComBinding )
	{
		m_pComBinding->Release();
		m_pComBinding = NULL;
	}

	CBaseProxyBuffer::Disconnect();

}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CComBindFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CComBindFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CComBindStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XComBindStublet;
    else
        return NULL;
}

CComBindStubBuffer::XComBindStublet::XComBindStublet(CComBindStubBuffer* pObj) 
    : CBaseStublet(pObj, IID_IWbemComBinding), m_pServer(NULL)
{
}

CComBindStubBuffer::XComBindStublet::~XComBindStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CComBindStubBuffer::XComBindStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CComBindStubBuffer::XComBindStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CComBindStubBuffer::XComBindStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CComBindStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  Override of base
//	class implementation.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CComBindStubBuffer::XComBindStublet::Connect(IUnknown* pUnkServer)
{
    // Something is wrong
    if( GetServerInterface() )
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface( m_riid, GetServerPtr() );
    if(FAILED(hres))
        return E_NOINTERFACE;

    // Successful connection
    m_lConnections++;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemstr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMSTR.CPP

Abstract:

    String helpers.

History:

--*/

#include "precomp.h"
#include "wbemstr.h"
#include <wbemutil.h>
#include <algorithm>

COREPROX_POLARITY WBEM_WSTR WbemStringAlloc(unsigned long lNumChars) 
{
    return (WBEM_WSTR)CoTaskMemAlloc(lNumChars+1);
}

COREPROX_POLARITY void WbemStringFree(WBEM_WSTR String)
{
    CoTaskMemFree(String);
}

COREPROX_POLARITY unsigned long WbemStringLen(const WCHAR* String)
{
    return wcslen(String);
}

COREPROX_POLARITY WBEM_WSTR WbemStringCopy(const WCHAR* String)
{
    if(String == NULL) return NULL;
    WBEM_WSTR NewString = (WBEM_WSTR)CoTaskMemAlloc(2*(wcslen(String)+1));
    if(NewString == NULL) return NULL;
    wcscpy(NewString, String);
    return NewString;
}

//******************************************************************************
//******************************************************************************
//                  INTERNAL STRING
//******************************************************************************
//******************************************************************************
CInternalString::CInternalString(LPCWSTR wsz)
{
    m_pcs = (CCompressedString*)new BYTE[
                    CCompressedString::ComputeNecessarySpace(wsz)];
    if (m_pcs)
        m_pcs->SetFromUnicode(wsz);
}

CInternalString::CInternalString(const CInternalString& Other) 
    : m_pcs(NULL)
{
    if (Other.m_pcs)
    {
        int nLen = Other.m_pcs->GetLength();
	 m_pcs = (CCompressedString*)new BYTE[nLen];
	 if(m_pcs == NULL)
	     throw CX_MemoryException();       
	 memcpy((void*)m_pcs, (void*)Other.m_pcs, nLen);
    }
}

CInternalString & CInternalString::operator=(const CInternalString& Other)
{    
    CInternalString temp(Other);
    std::swap(m_pcs,temp.m_pcs);
    return *this;
}

BOOL CInternalString::operator=(CCompressedString* pcs)
{
    delete [] (BYTE*)m_pcs;
    if(pcs)
    {
        int nLen = pcs->GetLength();
        m_pcs = (CCompressedString*)new BYTE[nLen];
        if(m_pcs == NULL)
            return FALSE;
        memcpy((void*)m_pcs, (void*)pcs, nLen);
    }
    else
    {
        m_pcs = NULL;
    }

    return TRUE;
}

BOOL CInternalString::operator=(LPCWSTR wsz)
{
    delete [] (BYTE*)m_pcs;
    m_pcs = (CCompressedString*)new BYTE[CCompressedString::ComputeNecessarySpace(wsz)];
    if(m_pcs == NULL)
        return FALSE;
    m_pcs->SetFromUnicode(wsz);
    return TRUE;
}

LPWSTR CInternalString::CreateLPWSTRCopy() const
{
    return m_pcs->CreateWStringCopy().UnbindPtr();
}


CInternalString::operator WString() const
{
    return m_pcs->CreateWStringCopy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wcommrsh.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WCOMMRSH.H

Abstract:

    IWbemComBinding marshaling

History:

--*/

#ifndef __WCOMMRSH_H__
#define __WCOMMRSH_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include "mrshbase.h"
#include "wmicombd.h"


//***************************************************************************
//
//  class CComBindFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemComBinding interface.
//
//***************************************************************************

class CComBindFactoryBuffer : public CUnkInternal
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XComBindFactory : public CImpl<IPSFactoryBuffer, CComBindFactoryBuffer>
    {
    public:
        XComBindFactory(CComBindFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CComBindFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XComBindFactory;
public:
    CComBindFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_pLifeControl( pControl ), m_XComBindFactory(this)
    {
    }
    ~CComBindFactoryBuffer()
    {
    }        

    void* GetInterface(REFIID riid);

	friend XComBindFactory;
};

//***************************************************************************
//
//  class CComBindProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemComBinding interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CComBindProxyBuffer : public CBaseProxyBuffer
{
protected:
	CWmiComBinding*	m_pComBinding;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

	// Special overrides
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();

public:
    CComBindProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CComBindProxyBuffer();

	HRESULT Init( void );
};

//***************************************************************************
//
//  class CComBindStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemComBinding interface.
//
//***************************************************************************

class CComBindStubBuffer : public CBaseStubBuffer
{

protected:
    class XComBindStublet : public CBaseStublet
    {
        IWbemComBinding* m_pServer;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

		// We'll override the connect
		STDMETHOD(Connect)(IUnknown* pUnkServer);

    public:
        XComBindStublet(CComBindStubBuffer* pObj);
        ~XComBindStublet();

	private:
        friend CComBindStubBuffer;
    } m_XComBindStublet;
    friend XComBindStublet;

public:
    CComBindStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer( pControl, pUnkOuter ), m_XComBindStublet(this)
    {}
    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiarray.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIARRAY.CPP

Abstract:

  CWmiArray implementation.

  Implements a standard interface for accessing arrays.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmiarray.h"
#include <corex.h>
#include "strutils.h"

//***************************************************************************
//
//  CWmiArray::~CWmiArray
//
//***************************************************************************
// ok
CWmiArray::CWmiArray()
:	m_ct(0),
	m_pObj(NULL),
	m_lHandle(0),
	m_lRefCount(0),
	m_fIsQualifier( FALSE ),
	m_fHasPrimaryName( FALSE ),
	m_wsPrimaryName(),
	m_wsQualifierName(),
	m_fIsMethodQualifier( FALSE )
{
    ObjectCreated(OBJECT_TYPE_WMIARRAY,this);
}
    
//***************************************************************************
//
//  CWmiArray::~CWmiArray
//
//***************************************************************************
// ok
CWmiArray::~CWmiArray()
{
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
	}

    ObjectDestroyed(OBJECT_TYPE_WMIARRAY,this);
}

// Initializes the object to point at an _IWmiObject for an array property.
HRESULT CWmiArray::InitializePropertyArray( _IWmiObject* pObj, LPCWSTR pwszPropertyName )
{
	HRESULT			hr = WBEM_S_NO_ERROR;

	// Release a prexisting object
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
	}

	// Now AddRef the object and get its property handle
	m_pObj = (CWbemObject*) pObj;
	m_pObj->AddRef();

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pObj->GetPropertyHandleEx( pwszPropertyName, 0L, &m_ct, &m_lHandle );

		try
		{
			m_wsPrimaryName = pwszPropertyName;
			m_fIsQualifier = FALSE;
			m_fHasPrimaryName = FALSE;
		}
		catch(CX_MemoryException)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		catch(...)
		{
			hr = WBEM_E_FAILED;
		}
	}

	return hr;
}

// Initializes the object to point at an _IWmiObject for an array qualifier (property or object).
HRESULT CWmiArray::InitializeQualifierArray( _IWmiObject* pObj, LPCWSTR pwszPrimaryName, 
											LPCWSTR pwszQualifierName, CIMTYPE ct, BOOL fIsMethodQualifier )
{
	HRESULT			hr = WBEM_S_NO_ERROR;

	// Release a prexisting object
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
	}

	// Now AddRef the object and get its property handle
	m_pObj = (CWbemObject*) pObj;
	m_pObj->AddRef();

	if ( SUCCEEDED( hr ) )
	{
		try
		{
			if ( NULL != pwszPrimaryName )
			{
				m_wsPrimaryName = pwszPrimaryName;
				m_fIsMethodQualifier = fIsMethodQualifier;
				m_fHasPrimaryName = TRUE;
			}
			
			m_wsQualifierName = pwszQualifierName;
			m_fIsQualifier = TRUE;

			m_ct = ct;
		}
		catch(CX_MemoryException)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		catch(...)
		{
			hr = WBEM_E_FAILED;
		}
	}

	return hr;
}

/*	IUnknown Methods */

STDMETHODIMP CWmiArray::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	if ( riid == IID_IUnknown )
	{
		*ppvObj = (LPVOID**) this;
	}
	else if ( riid == IID__IWmiArray )
	{
		*ppvObj = (LPVOID**) this;
	}
	else
	{
		return E_NOINTERFACE;
	}

    ((IUnknown*)*ppvObj)->AddRef();
    return S_OK;
}

ULONG CWmiArray::AddRef()
{
    return InterlockedIncrement((long*)&m_lRefCount);
}

ULONG CWmiArray::Release()
{
    long lRef = InterlockedDecrement((long*)&m_lRefCount);
    _ASSERT(lRef >= 0, __TEXT("Reference count on _IWmiArray went below 0!"))

    if(lRef == 0)
        delete this;
    return lRef;
}

/* _IWmiArray methods */

//	Initializes the array.  Number of initial elements as well
//	as the type (determines the size of each element)
STDMETHODIMP CWmiArray::Initialize( long lFlags, CIMTYPE cimtype, ULONG uNumElements )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// We don't let people do anything here
	return WBEM_E_INVALID_OPERATION;
}

//	Returns CIMTYPE and Number of elements.
STDMETHODIMP CWmiArray::GetInfo( long lFlags, CIMTYPE* pcimtype, ULONG* puNumElements )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		// Get qualifier array info
		hr = m_pObj->GetQualifierArrayInfo( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
										0L, pcimtype, puNumElements );
	}
	else
	{
		// Get array property info
		hr =  m_pObj->GetArrayPropInfoByHandle( m_lHandle, 0L, NULL, pcimtype, puNumElements );
	}

	return hr;
}

//	Clears out the array
STDMETHODIMP CWmiArray::Empty( long lFlags )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Just remove the range of all elements starting at 0
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		// Get qualifier array info
		hr = m_pObj->RemoveQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
												WMIARRAY_FLAG_ALLELEMENTS, 0, 0 );
	}
	else
	{
		// Get array property info
		hr =  m_pObj->RemoveArrayPropRangeByHandle( m_lHandle, WMIARRAY_FLAG_ALLELEMENTS, 0, 0 );
	}

	return hr;
}

// Returns the requested elements.  Buffer must be large enough to hold
// the element.  Embedded objects returned as AddRef'd _IWmiObject pointers.
// Strings are copied directly into the specified buffer and null-terminatead. UNICODE only.
STDMETHODIMP CWmiArray::GetAt( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								ULONG* puNumElements, ULONG* puBuffSizeUsed, LPVOID pDest )
{
	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Set the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->GetQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
											lFlags, uStartIndex, uNumElements, uBuffSize,
											puNumElements, puBuffSizeUsed, pDest );
	}
	else
	{
		hr =  m_pObj->GetArrayPropRangeByHandle( m_lHandle, lFlags, uStartIndex, uNumElements, uBuffSize,
						puNumElements, puBuffSizeUsed, pDest );
	}

	return hr;
}

// Sets the specified elements.  Buffer must supply data matching the CIMTYPE
// of the Array.  Embedded objects set as _IWmiObject pointers.
// Strings accessed as LPCWSTRs and the 2-byte null is copied.
STDMETHODIMP CWmiArray::SetAt( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								LPVOID pDest )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	// Set the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->SetQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
											lFlags, ARRAYFLAVOR_USEEXISTING, m_ct, uStartIndex,
											uNumElements, uBuffSize, pDest );
	}
	else
	{
		hr =  m_pObj->SetArrayPropRangeByHandle( m_lHandle, lFlags, uStartIndex, uNumElements, uBuffSize, pDest );
	}

	return hr;

}

// Appends the specified elements.  Buffer must supply data matching
// the CIMTYPE of the Array.  Embedded objects set as _IWmiObject pointers.
// Strings accessed as LPCWSTRs and the 2-byte null is copied.
STDMETHODIMP CWmiArray::Append( long lFlags, ULONG uNumElements, ULONG uBuffSize, LPVOID pDest )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	// Set the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->AppendQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
												lFlags, m_ct, uNumElements, uBuffSize, pDest );
	}
	else
	{
		hr =  m_pObj->AppendArrayPropRangeByHandle( m_lHandle, lFlags, uNumElements, uBuffSize, pDest );
	}

	return hr;
}

// Removes the specified elements from the array.  Subseqent elements are copied back
// to the starting point
STDMETHODIMP CWmiArray::RemoveAt( long lFlags, ULONG uStartIndex, ULONG uNumElements )
{
	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Remove the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->RemoveQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
												lFlags, uStartIndex, uNumElements );
	}
	else
	{
		hr =  m_pObj->RemoveArrayPropRangeByHandle( m_lHandle, lFlags, uStartIndex, uNumElements );
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemobjpacket.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMOBJPACKET.CPP

Abstract:

    Object packet classes.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "wbemobjpacket.h"

// IWbemClassObject Base Packet Classes

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::CWbemObjectPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjectPacket::CWbemObjectPacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   m_pObjectPacket( (PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket ),
    m_dwPacketLength( dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::CWbemObjectPacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjectPacket::CWbemObjectPacket( CWbemObjectPacket& objectPacket )
:   m_pObjectPacket( objectPacket.m_pObjectPacket ),
    m_dwPacketLength( objectPacket.m_dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::~CWbemObjectPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemObjectPacket::~CWbemObjectPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::SetupObjectPacketHeader
//  
//  Helper function that writes appropriate data into an Object
//  Packet header.
//
//  Inputs:
//              DWORD       dwDataSize - Size of Data following header.
//              BYTE        bObjectType - Type of object following header.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectPacket::SetupObjectPacketHeader( DWORD dwDataSize, BYTE bObjectType )
{
    HRESULT hr = WBEM_E_FAILED;

    // Init from member variables
    LPBYTE  pData = (LPBYTE) m_pObjectPacket;
    DWORD   dwBufferLength = m_dwPacketLength;

    // Pointer and length must be valid
    if ( NULL != pData )
    {

        if ( dwBufferLength >= ( sizeof(WBEM_DATAPACKET_OBJECT_HEADER) + dwDataSize ) )
        {
            PWBEM_DATAPACKET_OBJECT_HEADER  pObjectPacket = (PWBEM_DATAPACKET_OBJECT_HEADER) pData;

            // Clear out memory, then fill out the packet
            ZeroMemory( pObjectPacket, sizeof(WBEM_DATAPACKET_OBJECT_HEADER) );

            pObjectPacket->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
            pObjectPacket->dwSizeOfData = dwDataSize;
            pObjectPacket->bObjectType = bObjectType;

            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::CalculatePacketLength
//  
//  Determines number of bytes needed to marshal the packet into.
//
//  Inputs:
//              IWbemClassObject*   pObj - Object to calculate size for
//              BOOL                fFull - Write out full object (may be
//                                          false for Instances).
//
//  Outputs:
//              DWORD*              pdwLength - Number of bytes needed
//                                              to describe the object.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectPacket::CalculatePacketLength( IWbemClassObject* pObj, DWORD* pdwLength, BOOL fFull /* = TRUE */ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Pointer and length must be valid
    if ( NULL != pObj )
    {
        DWORD       dwObjectLength = 0;

        // Check for an _IWmiObject interface
		_IWmiObject*	pWmiObject = NULL;

		hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

		if ( SUCCEEDED( hr ) )
		{
			*pdwLength = sizeof(WBEM_DATAPACKET_OBJECT_HEADER);

			// It's an instance or a class
			if ( pWmiObject->IsObjectInstance() == WBEM_S_NO_ERROR )
			{
				*pdwLength += sizeof( WBEM_DATAPACKET_INSTANCE_HEADER );

				// Retrieve info differently based on whether or not we want
				// a full or lobotomized instance
				if ( !fFull )
				{
					hr = pWmiObject->GetObjectParts( NULL, 0, WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART, &dwObjectLength );
				}
				else
				{
					// We want all parts, but be aware that the object could be decoupled
					// and part of a pass through

					hr = pWmiObject->GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwObjectLength );
				}
			}
			else
			{
				// We want the WHOLE class
				*pdwLength += sizeof( WBEM_DATAPACKET_CLASS_HEADER );
				hr = pWmiObject->GetObjectMemory( NULL, 0, &dwObjectLength );
			}

			pWmiObject->Release();

		}	// IF QI'd _IWmiObject

        // If we're okey-dokey, then factor in the object length (we expect
        // the buffer too small return here).
        if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            *pdwLength += dwObjectLength;
            hr = WBEM_S_NO_ERROR;
        }
    }
    else
    {
        // Length is just this header size
        *pdwLength = sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
    }

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pObjectPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class to marshal/unmarshal
//              objects.
//
///////////////////////////////////////////////////////////////////

void CWbemObjectPacket::SetData( LPBYTE pObjectPacket, DWORD dwPacketLength )
{
    m_pObjectPacket = (PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket;
    m_dwPacketLength = dwPacketLength;
}


///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::CWbemClassPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClassPacket::CWbemClassPacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   CWbemObjectPacket( pObjectPacket, dwPacketLength ),
    m_pWbemClassData( NULL )
{
    // Point class data appropriately
    if ( NULL != pObjectPacket )
    {
        m_pWbemClassData = (PWBEM_DATAPACKET_CLASS_FULL) (pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket)->dwSizeOfHeader);
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::CWbemClassPacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClassPacket::CWbemClassPacket( CWbemObjectPacket& objectPacket )
:   CWbemObjectPacket( objectPacket ),
    m_pWbemClassData( NULL )
{
    // Point class data appropriately
    if ( NULL != m_pObjectPacket )
    {
        m_pWbemClassData = (PWBEM_DATAPACKET_CLASS_FULL) ( (LPBYTE) m_pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) m_pObjectPacket)->dwSizeOfHeader);
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::~CWbemClassPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClassPacket::~CWbemClassPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::WriteToPacket
//  
//  Writes data out to the supplied buffer.
//
//  Inputs:
//              LPBYTE              pData - Buffer to write into.
//              DWORD               dwBufferLength - Size of buffer
//              IWbemClassObject*   pObj - Object to write out.
//
//  Outputs:
//              DWORD*              pdwLengthUsed - Num bytes used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassPacket::WriteToPacket( IWbemClassObject* pObj, DWORD* pdwLengthUsed )
{
    CWbemObject*    pWbemObject = (CWbemObject*) pObj;
    DWORD           dwObjectSize = 0;

    HRESULT hr = WBEM_E_FAILED;

    /// Discover how big the object is
    hr = pWbemObject->GetObjectMemory( NULL, 0, &dwObjectSize );

    // Expecting an error here, since we just wanted the BLOB length
    if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
    {
        hr = WBEM_S_NO_ERROR;

        // Calculate the size needed for our object and header
        DWORD   dwDataSize = sizeof(WBEM_DATAPACKET_CLASS_FULL) + dwObjectSize;

        // Now init the Object Header
        hr = SetupObjectPacketHeader( dwDataSize, WBEMOBJECT_CLASS_FULL );

        if ( SUCCEEDED( hr ) )
        {
            // Setup the Class object header (use our member variable)
            LPBYTE  pTempData = (LPBYTE) m_pWbemClassData;

            m_pWbemClassData->ClassHeader.dwSizeOfHeader = sizeof(WBEM_DATAPACKET_CLASS_HEADER);
            m_pWbemClassData->ClassHeader.dwSizeOfData = dwObjectSize;

            // Put in the actual object data
            pTempData += sizeof(WBEM_DATAPACKET_CLASS_HEADER);

            DWORD   dwSizeUsed = 0;

            hr = pWbemObject->GetObjectMemory( pTempData, dwObjectSize, &dwSizeUsed );

            if ( SUCCEEDED( hr ) )
            {
                *pdwLengthUsed = sizeof(WBEM_DATAPACKET_OBJECT_HEADER) + sizeof(WBEM_DATAPACKET_CLASS_FULL) + dwObjectSize;
            }

        }   // IF object header initialized

    }   // If got object length

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::GetWbemClassObject
//  
//  Retrieves a Wbem Class Object from a previously marshaled
//  packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              CWbemClass**    ppWbemClass - Class we read in.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Caller is responsible for RELEASING the object.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassPacket::GetWbemClassObject( CWbemClass** ppWbemClass )
{
    HRESULT hr = WBEM_E_FAILED;

    if ( NULL != m_pWbemClassData )
    {
        hr = WBEM_E_OUT_OF_MEMORY;

        // Get a class object
        CWbemClass* pClass = new CWbemClass;

        if ( NULL != pClass )
        {
            LPBYTE pbData = CBasicBlobControl::sAllocate(m_pWbemClassData->ClassHeader.dwSizeOfData);
            
            if ( NULL != pbData )
            {
                // Copy the memory into the new buffer and initialize a Wbem Class with it.
                CopyMemory( pbData, ((LPBYTE) m_pWbemClassData) + m_pWbemClassData->ClassHeader.dwSizeOfHeader, m_pWbemClassData->ClassHeader.dwSizeOfData );

                // Initialize the Instance using the BLOB
                pClass->SetData( pbData, m_pWbemClassData->ClassHeader.dwSizeOfData );

                // Object is already AddRef'd so we be done
                *ppWbemClass = pClass;
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                // Error, so cleanup
                pClass->Release();
            }

        }   // IF NULL != pClass

    }   // IF internal data available
    else
    {
        // We can't do this if we have no buffer
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pObjectPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Marshal/Unmarshal
//              to work.
//
///////////////////////////////////////////////////////////////////

void CWbemClassPacket::SetData( LPBYTE pObjectPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pObjectPacket )
    {
        m_pWbemClassData = (PWBEM_DATAPACKET_CLASS_FULL) ( pObjectPacket + sizeof(WBEM_DATAPACKET_OBJECT_HEADER) );
    }
    else
    {
        m_pWbemClassData = NULL;
    }

    // Initialize the base class
    CWbemObjectPacket::SetData( pObjectPacket, dwPacketLength );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::CWbemInstancePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemInstancePacket::CWbemInstancePacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   CWbemObjectPacket( pObjectPacket, dwPacketLength ),
    m_pWbemInstanceData( NULL )
{
    // Point Instance data appropriately
    if ( NULL != pObjectPacket )
    {
        m_pWbemInstanceData = (PWBEM_DATAPACKET_INSTANCE_HEADER) ( pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket)->dwSizeOfHeader );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::CWbemInstancePacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemInstancePacket::CWbemInstancePacket( CWbemObjectPacket& objectPacket )
:   CWbemObjectPacket( objectPacket ),
    m_pWbemInstanceData( NULL )
{
    // Point Instance data appropriately
    if ( NULL != m_pObjectPacket )
    {
        m_pWbemInstanceData = (PWBEM_DATAPACKET_INSTANCE_HEADER) ( (LPBYTE) m_pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) m_pObjectPacket)->dwSizeOfHeader);
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::~CWbemInstancePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemInstancePacket::~CWbemInstancePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetInstanceType
//  
//  Returns instance type data for the packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEMOBJECT_INSTANCE_FULL
//
//  Comments:   Override to return a different type.
//
///////////////////////////////////////////////////////////////////

BYTE CWbemInstancePacket::GetInstanceType( void )
{
    return WBEMOBJECT_INSTANCE_FULL;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetObjectMemory
//  
//  Copies internal object memory into the supplied buffer.
//
//  Inputs:
//              CWbemObject*    pObj - Object whose memory to retrieve.
//              LPBYTE          pbData - Buffer to place data in.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              DWORD*          pdwDataUsed - Amount of data used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to retrieve data in other fashions.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemInstancePacket::GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed )
{
    // We want all parts, but be aware that the object could be decoupled
    // and part of a pass through

    return pObj->GetObjectParts( pbData, dwDataSize, WBEM_INSTANCE_ALL_PARTS, pdwDataUsed );

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::SetObjectMemory
//  
//  Sets internal object memory in the supplied instance to point
//  to the supplied buffer.
//
//  Inputs:
//              CWbemInstance*  pInstance - Instance to set memory in.
//              LPBYTE          pbData - Buffer to Set Memory from.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to set data in other ways.  Note that the
//              instance object will delete the buffer when it is
//              freed up.
//
///////////////////////////////////////////////////////////////////

void CWbemInstancePacket::SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize )
{
    pInstance->SetData( pbData, dwDataSize );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::WriteToPacket
//  
//  Determines number of bytes needed to marshal the packet into.
//
//  Inputs:
//              IWbemClassObject*   pObj - Object to write out.
//
//  Outputs:
//              DWORD*              pdwLengthUsed - Num bytes used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemInstancePacket::WriteToPacket( IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed )
{
    CWbemObject*    pWbemObject = (CWbemObject*) pObj;
    DWORD           dwObjectSize = 0;

    HRESULT hr = WBEM_E_FAILED;

    /// Discover how big the object is
    hr = GetObjectMemory( pWbemObject, NULL, 0, &dwObjectSize );

    // Expecting an error here, since we just wanted the BLOB length
    if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
    {
        hr = WBEM_S_NO_ERROR;

        // Calculate the size needed for our object and header
        DWORD   dwDataSize = sizeof(WBEM_DATAPACKET_INSTANCE_HEADER) + dwObjectSize;

        // Now init the Object Header
        hr = SetupObjectPacketHeader( dwDataSize, GetInstanceType() );

        if ( SUCCEEDED( hr ) )
        {
            // Initialize from our member data
            LPBYTE  pTempData = (LPBYTE) m_pWbemInstanceData;

            m_pWbemInstanceData->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_INSTANCE_HEADER);
            m_pWbemInstanceData->dwSizeOfData = dwObjectSize;
            m_pWbemInstanceData->guidClassId = guidClassId;

            // Put in the actual object data
            pTempData += sizeof(WBEM_DATAPACKET_INSTANCE_HEADER);

            DWORD   dwSizeUsed = 0;

            hr = GetObjectMemory( pWbemObject, pTempData, dwObjectSize, &dwSizeUsed );

            if ( SUCCEEDED( hr ) )
            {
                *pdwLengthUsed = sizeof(WBEM_DATAPACKET_OBJECT_HEADER) + sizeof(WBEM_DATAPACKET_INSTANCE_HEADER) + dwObjectSize;
            }

        }   // IF object header initialized

    }   // If got object length

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::GetWbemInstanceObject
//  
//  Retrieves a Wbem Instance Object from a previously marshaled
//  packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              CWbemInstance** ppWbemInstance - Instance we read in.
//              GUID&           guidClassId - Class Id for instance
//                                          caching.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Caller is responsible for RELEASING the object.  The
//              class id can be used to cache the instance, or if
//              it is classless, hook up the instance with a previously
//              cached instance.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemInstancePacket::GetWbemInstanceObject( CWbemInstance** ppWbemInstance, GUID& guidClassId )
{
    HRESULT hr = WBEM_E_FAILED;

    if ( NULL != m_pWbemInstanceData )
    {
        hr = WBEM_E_OUT_OF_MEMORY;

        // Get a Instance object
        CWbemInstance*  pInstance = new CWbemInstance;

        if ( NULL != pInstance )
        {
            LPBYTE pbData = CBasicBlobControl::sAllocate(m_pWbemInstanceData->dwSizeOfData);
            
            if ( NULL != pbData )
            {
                // Copy the memory into the new buffer and initialize a Wbem Instance with it.
                CopyMemory( pbData, ((LPBYTE) m_pWbemInstanceData) + m_pWbemInstanceData->dwSizeOfHeader, m_pWbemInstanceData->dwSizeOfData );

                // Initialize the Instance using the BLOB
                SetObjectMemory( pInstance, pbData, m_pWbemInstanceData->dwSizeOfData );

                // Object is already AddRef'd so we be done
                guidClassId = m_pWbemInstanceData->guidClassId;
                *ppWbemInstance = pInstance;
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                // Error, so cleanup
                pInstance->Release();
            }

        }   // IF NULL != pInstance

    }   // IF internal data available
    else
    {
        // We can't do this if we have no buffer
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pObjectPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Marshal/Unmarshal
//              to work.
//
///////////////////////////////////////////////////////////////////

void CWbemInstancePacket::SetData( LPBYTE pObjectPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pObjectPacket )
    {
        m_pWbemInstanceData = (PWBEM_DATAPACKET_INSTANCE_HEADER) ( pObjectPacket + sizeof(WBEM_DATAPACKET_OBJECT_HEADER) );
    }
    else
    {
        m_pWbemInstanceData = NULL;
    }

    // Initialize the base class
    CWbemObjectPacket::SetData( pObjectPacket, dwPacketLength );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClasslessInstancePacket::CWbemClasslessInstancePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClasslessInstancePacket::CWbemClasslessInstancePacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   CWbemInstancePacket( pObjectPacket, dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClasslessInstancePacket::CWbemClasslessInstancePacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClasslessInstancePacket::CWbemClasslessInstancePacket( CWbemObjectPacket& objectPacket )
:   CWbemInstancePacket( objectPacket )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClasslessInstancePacket::~CWbemClasslessInstancePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClasslessInstancePacket::~CWbemClasslessInstancePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetInstanceType
//  
//  Returns instance type data for the packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEMOBJECT_INSTANCE_FULL
//
//  Comments:   Override to return a different type.
//
///////////////////////////////////////////////////////////////////

BYTE CWbemClasslessInstancePacket::GetInstanceType( void )
{
    return WBEMOBJECT_INSTANCE_NOCLASS;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetObjectMemory
//  
//  Copies internal object memory into the supplied buffer.
//
//  Inputs:
//              CWbemObject*    pObj - Object whose memory to retrieve.
//              LPBYTE          pbData - Buffer to place data in.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              DWORD*          pdwDataUsed - Amount of data used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to retrieve data in other fashions.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClasslessInstancePacket::GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed )
{
    return pObj->GetObjectParts( pbData, dwDataSize, WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART, pdwDataUsed );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::SetObjectMemory
//  
//  Sets internal object memory in the supplied instance to point
//  to the supplied buffer.
//
//  Inputs:
//              CWbemInstance*  pInstance - Instance to set memory in.
//              LPBYTE          pbData - Buffer to Set Memory from.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to set data in other ways.  Note that the
//              instance object will delete the buffer when it is
//              freed up.
//
///////////////////////////////////////////////////////////////////

void CWbemClasslessInstancePacket::SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize )
{
    pInstance->SetData( pbData, dwDataSize, WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemstr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMSTR.H

Abstract:

    String helpers.

History:

--*/

#ifndef __WBEM_STR__H_
#define __WBEM_STR__H_

#include <wbemidl.h>
#include "corepol.h"
#include "faststr.h"
#include <functional>

COREPROX_POLARITY WBEM_WSTR WbemStringAlloc(unsigned long lNumChars); 


COREPROX_POLARITY void WbemStringFree(WBEM_WSTR String);

COREPROX_POLARITY unsigned long WbemStringLen(const WCHAR* String);


COREPROX_POLARITY WBEM_WSTR WbemStringCopy(const WCHAR* String);

class COREPROX_POLARITY CInternalString
{
protected:
    CCompressedString* m_pcs;
public:
    CInternalString() : m_pcs(NULL){}
    CInternalString(LPCWSTR wsz);
    CInternalString(const CInternalString& Other);
    ~CInternalString() {delete [] (BYTE*)m_pcs;}
private:    
    operator CCompressedString*() {return m_pcs;}
    operator CCompressedString*() const {return m_pcs;}
public:    
    void Empty() {delete [] (BYTE*)m_pcs; m_pcs = NULL;}
    bool IsEmpty() {return (m_pcs == NULL);}
    //
    // this is an implementation of the assignement operator against the semantic
    //
    BOOL operator=(LPCWSTR wsz);
    BOOL operator=(CCompressedString* pcs);        
    CInternalString & operator=(const CInternalString& Other);    	
    void AcquireCompressedString(CCompressedString* pcs)
        {delete [] (BYTE*)m_pcs; m_pcs = pcs;}
    void Unbind() {m_pcs = NULL;}
    LPWSTR CreateLPWSTRCopy() const;
    operator WString() const;
    int GetLength() const {return m_pcs->GetStringLength();}
    bool operator==(LPCWSTR wsz) const
        {return m_pcs->CompareNoCase(wsz) == 0;}
    bool operator==(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) == 0;}
    bool operator!=(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) != 0;}
    bool operator<(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) < 0;}
    bool operator>(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) > 0;}

    int Compare(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs);}
    int Compare(LPCWSTR wsz) const
        {return m_pcs->CompareNoCase(wsz);}

    LPCSTR GetText() const {return ((LPCSTR)m_pcs) + 1;}
};

class CInternalLess : 
           public std::binary_function<CInternalString*, CInternalString*, bool>
{
public:
    bool operator()(const CInternalString*& pis1, const CInternalString*& pis2) 
            const
        {return *pis1 < *pis2;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmicombd.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMICOMBD.H

Abstract:

  CWmiComBinding Definition.

  Implements the IWbemComBinding interface.

History:

  05-May-2000	sanjes    Created.

--*/

#ifndef __WMICOMBD_H__
#define __WMICOMBD_H__

#include "corepol.h"
#include <arena.h>

//***************************************************************************
//
//  class CWmiComBinding
//
//  Implementation of IWbemComBinding Interface
//
//***************************************************************************

#define COMBINDING_ASSOC_QUERY_FORMAT	L"ASSOCIATORS OF {__CLASSVECTOR.ClassPath=\"%s\"} WHERE RESULTCLASS = %s"

class COREPROX_POLARITY CWmiComBinding : public CUnk
{
private:

public:
    CWmiComBinding(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWmiComBinding(); 

protected:


    class COREPROX_POLARITY XWmiComBinding : public CImpl<IWbemComBinding, CWmiComBinding>
    {
    public:
        XWmiComBinding(CWmiComBinding* pObject) : 
            CImpl<IWbemComBinding, CWmiComBinding>(pObject)
        {}

		// Returns all matching CLSIDs for requested IID as array of BSTRs
		STDMETHOD(GetCLSIDArrayForIID)( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags, IWbemContext* pCtx, SAFEARRAY** pArray );

		// Gets the requested object and creates the supplied CLSID, requesting
		// the specified interface, and returning that in pObj
		STDMETHOD(BindComObject)( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId, IWbemContext *pCtx, long lFlags,
								IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface );

		// Provides DISPIDs for Names and the CLSID for the object that supports them
		// Returned as a SAFEARRAY of IUnknowns.
		STDMETHOD(GetCLSIDArrayForNames)( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
										LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray );

    } m_XWmiComBinding;
    friend XWmiComBinding;


protected:

	// Returns all matching CLSIDs for requested IID as array of BSTRs
	virtual HRESULT GetCLSIDArrayForIID( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags, IWbemContext* pCtx, SAFEARRAY** pArray );

	// Gets the requested object and creates the supplied CLSID, requesting
	// the specified interface, and returning that in pObj
	virtual HRESULT BindComObject( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId, IWbemContext *pCtx, long lFlags,
									IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface );

	virtual HRESULT GetCLSIDArrayForNames( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
											LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray );

	// General Helper functions
	BSTR GetAssociatorsQuery( BSTR bstrClass, LPCWSTR pwszResultClass );
	HRESULT GetClassChain( IWbemClassObject* pObj, CSafeArray* psa );

	// IID Helper functions
	HRESULT CheckRIID( IWbemClassObject* pWmiObj, LPCWSTR pwszRIID, CSafeArray* psa );
	HRESULT ExecuteComBindingQuery( IWbemServicesEx* pSvcEx, IWbemContext* pCtx, BSTR bstrClass, LPCWSTR pwszRIID, CSafeArray* psa );

	// DISPIDs helper functions
	HRESULT ExecuteDispatchElementQuery( IWbemServicesEx* pSvcEx, IWbemContext* pCtx, IWbemClassObject* pInst,
										BSTR bstrClass, LPCWSTR * rgszNames, UINT cNames, CSafeArray* psa );
	HRESULT GetDispInfoInstance( IWbemServicesEx *pSvcEx, IWbemContext* pCtx, IWbemClassObject** ppInst );
	HRESULT ResolveMethod( IWbemClassObject* pResultObj, LPCWSTR* rgszNames, UINT cNames, IWbemClassObject* pInst, CSafeArray* psa );
	HRESULT CopyMethodNameAndDispId( IWbemClassObject* pResultObj, IWbemClassObject* pInst );
	HRESULT	ResolveArgumentNames( IWbemClassObject* pResultObj, LPCWSTR* rgszNames, UINT cNames, IWbemClassObject* pInst );
	HRESULT	CheckArgumentNames( CSafeArray* psaNames, CSafeArray* psaDispIds, LPCWSTR* rgszNames, UINT cNames, CSafeArray* psaTargetDispIds );

protected:
    void* GetInterface(REFIID riid);

public:

	BOOL Initialize( void ) { return TRUE; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiarray.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIARRAY.H

Abstract:

  CWmiArray definition.

  Standard interface for accessing arrays.

History:

  20-Feb-2000	sanjes    Created.

--*/

#ifndef _WMIARRAY_H_
#define _WMIARRAY_H_

#include "hiperflock.h"
#include "corepol.h"
#include <arena.h>

#define	WMIARRAY_UNINITIALIZED	0xFFFFFFFF

#define	WMIARRAY_GROWBY_DEFAULT	0x40

//***************************************************************************
//
//  class CWmiArray
//
//  Implementation of _IWmiArray Interface
//
//***************************************************************************

class COREPROX_POLARITY CWmiArray : public _IWmiArray
{
protected:
	CIMTYPE			m_ct;
	CWbemObject*	m_pObj;
	long			m_lHandle;
	long			m_lRefCount;
	WString			m_wsPrimaryName;
	WString			m_wsQualifierName;
	BOOL			m_fIsQualifier;
	BOOL			m_fHasPrimaryName;
	BOOL			m_fIsMethodQualifier;

	BOOL IsQualifier( void ) { return m_fIsQualifier; }
	BOOL HasPrimaryName( void ) { return m_fHasPrimaryName; }

public:
    CWmiArray();
	virtual ~CWmiArray(); 

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	/* _IWmiArray methods */
    STDMETHOD(Initialize)( long lFlags, CIMTYPE	cimtype, ULONG uNumElements );
	//	Initializes the array.  Number of initial elements as well
	//	as the type (determines the size of each element) and dimension
	//	currently only 1 is supported.

    STDMETHOD(GetInfo)( long lFlags, CIMTYPE* pcimtype, ULONG* puNumElements );
	//	Initializes the array.  Number of initial elements as well
	//	as the type (determines the size of each element).

    STDMETHOD(Empty)( long lFlags );
	//	Clears the array as well as internal data.

	STDMETHOD(GetAt)( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
						ULONG* puNumReturned, ULONG* puBuffSizeUsed, LPVOID pDest );
	// Returns the requested elements.  Buffer must be large enough to hold
	// the element.  Embedded objects returned as AddRef'd _IWmiObject pointers.
	// Strings are copied directly into the specified buffer and null-terminatead. UNICODE only.

	STDMETHOD(SetAt)( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize, LPVOID pDest );
	// Sets the specified elements.  Buffer must supply data matching the CIMTYPE
	// of the Array.  Embedded objects set as _IWmiObject pointers.
	// Strings accessed as LPCWSTRs and the 2-byte null is copied.

    STDMETHOD(Append)( long lFlags, ULONG uNumElements, ULONG uBuffSize, LPVOID pDest );
	// Appends the specified elements.  Buffer must supply data matching
	// the CIMTYPE of the Array.  Embedded objects set as _IWmiObject pointers.
	// Strings accessed as LPCWSTRs and the 2-byte null is copied.

    STDMETHOD(RemoveAt)( long lFlags, ULONG uStartIndex, ULONG uNumElements );
	// Removes the specified elements from the array.  Subseqent elements are copied back
	// to the starting point

public:

	// CWmiArray specific methods
	// Sets the object to work with a property array
	HRESULT InitializePropertyArray( _IWmiObject* pObj, LPCWSTR pwszPropertyName );

	// Sets the object to work with a qualifier array (property or object level)
	HRESULT InitializeQualifierArray( _IWmiObject* pObj, LPCWSTR pwszPrimaryName, 
									LPCWSTR pwszQualifierName, CIMTYPE ct, BOOL fIsMethodQual = FALSE );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmierobj.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIEROBJ.H

Abstract:

  CWmiErrorObject Definition.

  Standard definition for _IWmiErrorObject.

History:

  18-Apr-2000	sanjes    Created.

--*/

#ifndef _WMIERROBJ_H_
#define _WMIERROBJ_H_

#include "corepol.h"
#include <arena.h>
#include "wrapobj.h"

//***************************************************************************
//
//  class CWmiErrorObject
//
//  Implementation of _IWmiErrorObject Interface
//
//***************************************************************************

class COREPROX_POLARITY CWmiErrorObject : public CWmiObjectWrapper
{

public:

	GUID	m_Guid;
	DWORD	m_dwHelpContext;
	LPWSTR	m_pwszHelpFile;
	LPWSTR	m_pwszSource;

    CWmiErrorObject(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWmiErrorObject(); 

	// _IWmiErrorObject Methods

    class COREPROX_POLARITY XWmiErrorObject : public CImpl<_IWmiErrorObject, CWmiErrorObject>
    {
    public:
        XWmiErrorObject(CWmiErrorObject* pObject) : 
            CImpl<_IWmiErrorObject, CWmiErrorObject>(pObject)
        {}

		STDMETHOD(SetErrorInfo)( GUID* pGuidSource, DWORD dwHelpContext, LPCWSTR pwszHelpFile, LPCWSTR pwszSource, LPCWSTR pwszDescription,
				LPCWSTR	pwszOperation, LPCWSTR pwszParameterInfo, LPCWSTR pwzProviderName, DWORD dwStatusCode );

    } m_XWmiErrorObject;
    friend XWmiErrorObject;
	
	// Sets the actual error info values for the object.
	virtual HRESULT SetErrorInfo( GUID* pGuidSource, DWORD dwHelpContext, LPCWSTR pwszHelpFile, LPCWSTR pwszSource, LPCWSTR pwszDescription,
				LPCWSTR	pwszOperation, LPCWSTR pwszParameterInfo, LPCWSTR pwzProviderName, DWORD dwStatusCode );

	// IErrorInfo overrides
	virtual HRESULT GetGUID(GUID* pguid);
	virtual HRESULT GetHelpContext(DWORD* pdwHelpContext);
	virtual HRESULT GetHelpFile(BSTR* pstrHelpFile);
	virtual HRESULT GetSource(BSTR* pstrSource);

public:
	
	// Helper function to initialize the wrapper (we need something to wrap).
	HRESULT Init( CWbemObject* pObj );

	// Creates a new wrapper object to wrap any objects we may return
	CWmiObjectWrapper*	CreateNewWrapper( BOOL fClone );

protected:
    void* GetInterface(REFIID riid);

	HRESULT Copy( const CWmiErrorObject& sourceobj );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobtxt.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBTXT.CPP

Abstract:

  CWmiObjectTextSrc implementation.

  Implements the IWbemObjectTextSrc interface.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "wmiobtxt.h"

//***************************************************************************
//
//  CWmiObjectTextSrc::CWmiObjectTextSrc
//
//***************************************************************************
// ok
CWmiObjectTextSrc::CWmiObjectTextSrc( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XObjectTextSrc( this )
{
}
    
//***************************************************************************
//
//  CWmiObjectTextSrc::~CWmiObjectTextSrc
//
//***************************************************************************
// ok
CWmiObjectTextSrc::~CWmiObjectTextSrc()
{
}

// Override that returns us an interface
void* CWmiObjectTextSrc::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectTextSrc)
        return &m_XObjectTextSrc;
    else
        return NULL;
}

// Pass-through helpers
HRESULT CWmiObjectTextSrc::GetText( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat,
									IWbemContext *pCtx, BSTR *strText )
{
	if ( lFlags != NULL )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CWmiTextSource*	pSource = NULL;
	HRESULT	hr = m_TextSourceMgr.Find( uObjTextFormat, &pSource );
	CTemplateReleaseMe<CWmiTextSource>	rm( pSource );

	if ( SUCCEEDED( hr ) )
	{
		hr = pSource->ObjectToText( 0L, pCtx, pObj, strText );
	}
	 
	return hr;
}

HRESULT CWmiObjectTextSrc::CreateFromText( long lFlags, BSTR strText, ULONG uObjTextFormat,
										IWbemContext *pCtx, IWbemClassObject **pNewObj )
{
	if ( lFlags != NULL )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CWmiTextSource*	pSource = NULL;
	HRESULT	hr = m_TextSourceMgr.Find( uObjTextFormat, &pSource );
	CTemplateReleaseMe<CWmiTextSource>	rm( pSource );

	if ( SUCCEEDED( hr ) )
	{
		hr = pSource->TextToObject( 0L, pCtx, strText, pNewObj );
	}
	 
	return hr;
}

// Actual IWbemObjectTextSrc implementation
STDMETHODIMP CWmiObjectTextSrc::XObjectTextSrc::GetText( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat,
														IWbemContext *pCtx, BSTR *strText )
{
	return m_pObject->GetText( lFlags, pObj, uObjTextFormat, pCtx, strText );
}

STDMETHODIMP CWmiObjectTextSrc::XObjectTextSrc::CreateFromText( long lFlags, BSTR strText, ULONG uObjTextFormat,
															   IWbemContext *pCtx, IWbemClassObject **pNewObj )
{
	return m_pObject->CreateFromText( lFlags, strText, uObjTextFormat, pCtx, pNewObj );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmierobj.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FRFOOBJ.CPP

Abstract:

  CWmiErrorObject Definition.

  Standard definition for _IWmiErrorObject.

History:

  18-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmierobj.h"
#include <corex.h>
#include "strutils.h"

//***************************************************************************
//
//  CWmiErrorObject::~CWmiErrorObject
//
//***************************************************************************
// ok
CWmiErrorObject::CWmiErrorObject( CLifeControl* pControl, IUnknown* pOuter )
:	CWmiObjectWrapper( pControl, pOuter ),
	m_XWmiErrorObject( this ),
	m_dwHelpContext( 0 ),
	m_pwszHelpFile( NULL ),
	m_pwszSource( NULL )
{
	ZeroMemory( &m_Guid, sizeof( &m_Guid ) );
	ObjectCreated( OBJECT_TYPE_FREEFORM_OBJ, this );
}
    
//***************************************************************************
//
//  CWmiErrorObject::~CWmiErrorObject
//
//***************************************************************************
// ok
CWmiErrorObject::~CWmiErrorObject()
{
	if ( NULL != m_pwszHelpFile )
	{
		delete [] m_pwszHelpFile;
	}

	if ( NULL != m_pwszSource )
	{
		delete [] m_pwszSource;
	}

	ObjectDestroyed( OBJECT_TYPE_FREEFORM_OBJ, this );
}


// Helper functions
HRESULT CWmiErrorObject::Init( CWbemObject* pObj )
{

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL == pObj )
	{
		// We always start out as a Class
		pObj = new CWbemClass;

		if ( NULL != pObj )
		{
			try
			{
				// This will throw a memory exception if it fails.
				// We ask for the extra size so that we can limit
				// the number of potential reallocations that occur.
				hr = ((CWbemClass*) pObj)->InitEmpty( FREEFORM_OBJ_EXTRAMEM );

				if ( SUCCEEDED( hr ) )
				{
					// Now we'll set the correct properties
					hr = pObj->WriteProp( L"__CLASS", 0L, ( wcslen(L"__ExtendedStatus") + 1 ) * 2, 0, CIM_STRING, L"__ExtendedStatus" );

					if ( SUCCEEDED( hr ) )
					{
						hr = pObj->WriteProp( L"StatusCode", 0L, 0L, 0, CIM_UINT32, NULL );
					}

					if ( SUCCEEDED( hr ) )
					{
						hr = pObj->WriteProp( L"Description", 0L, 0L, 0, CIM_STRING, NULL );
					}

					if ( SUCCEEDED( hr ) )
					{
						hr = pObj->WriteProp( L"Operation", 0L, 0L, 0, CIM_STRING, NULL );
					}

					if ( SUCCEEDED( hr ) )
					{
						hr = pObj->WriteProp( L"ParameterInfo", 0L, 0L, 0, CIM_STRING, NULL );
					}

					if ( SUCCEEDED( hr ) )
					{
						hr = pObj->WriteProp( L"ProviderName", 0L, 0L, 0, CIM_STRING, NULL );
					}

					if ( SUCCEEDED( hr ) )
					{
						CWbemInstance*	pInst = NULL;

						hr = pObj->SpawnInstance( 0L, (IWbemClassObject**) &pInst );

						if ( SUCCEEDED( hr ) )
						{
							pObj->Release();
							pObj = pInst;
						}
					}

				}	// IF InitEmpty

			}
			catch( CX_MemoryException )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			catch(...)
			{
				hr = WBEM_E_FAILED;
			}
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}

	}

	if ( SUCCEEDED( hr ) )
	{
		// Cleanup the old object
		if ( NULL != m_pObj )
		{
			m_pObj->Release();
		}

		// Finally, set the "wrapped" object
		m_pObj = pObj;
		m_pObj->AddRef();
	}

	return hr;
}

CWmiObjectWrapper* CWmiErrorObject::CreateNewWrapper( BOOL fClone )
{
	CWmiErrorObject*	pNewObj = new CWmiErrorObject( m_pControl, m_pOuter );

	if ( NULL != pNewObj )
	{
		if ( !SUCCEEDED( pNewObj->Copy( *this ) ) )
		{
			delete pNewObj;
			pNewObj = NULL;
		}
	}

	return pNewObj;
}

// Copy the property bags
HRESULT CWmiErrorObject::Copy( const CWmiErrorObject& source )
{
	return WBEM_S_NO_ERROR;
}

/*	IUnknown Methods */

void* CWmiErrorObject::GetInterface(REFIID riid)
{
	if ( riid == IID_IUnknown || riid == IID__IWmiErrorObject )
	{
		return &m_XWmiErrorObject;
	}
	else if ( riid == IID__IWmiObject )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID__IWmiObjectAccessEx )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IWbemObjectAccess )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IWbemClassObject )
	{
		return &m_XWMIObject;
	}
	else if ( riid == IID_IMarshal )
	{
		return &m_XObjectMarshal;
	}
//	else if ( riid == IID_IUmiPropList )
//	{
//		return &m_XUmiPropList;
//	}
    return NULL;
}

/*_IWmiErrorObject Pass-thrus */
// Specifies a property origin (in case we have properties originating in classes
// which we know nothing about).
STDMETHODIMP CWmiErrorObject::XWmiErrorObject::SetErrorInfo( GUID* pGuidSource, DWORD dwHelpContext, LPCWSTR pwszHelpFile, LPCWSTR pwszSource,
				LPCWSTR pwszDescription, LPCWSTR pwszOperation, LPCWSTR pwszParameterInfo, LPCWSTR pwszProviderName, DWORD dwStatusCode )
{
	//Pass through to the wrapper
	return m_pObject->SetErrorInfo( pGuidSource, dwHelpContext, pwszHelpFile, pwszSource, pwszDescription, pwszOperation, pwszParameterInfo,
				pwszProviderName, dwStatusCode );
}

// Specifies a method origin (in case we have methods originating in classes
// which we know nothing about).
HRESULT CWmiErrorObject::SetErrorInfo( GUID* pGuidSource, DWORD dwHelpContext, LPCWSTR pwszHelpFile, LPCWSTR pwszSource, LPCWSTR pwszDescription,
				LPCWSTR	pwszOperation, LPCWSTR pwszParameterInfo, LPCWSTR pwszProviderName, DWORD dwStatusCode )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	CLock	lock(this);

	// Setup our member variables
	if ( NULL != pGuidSource )
	{
		m_Guid = *pGuidSource;
	}

	m_dwHelpContext = dwHelpContext;

	// Dump any preallocated memory
	if ( NULL != m_pwszHelpFile )
	{
		delete [] m_pwszHelpFile;
		m_pwszHelpFile = NULL;
	}

	// Dump any preallocated memory
	if ( NULL != m_pwszSource )
	{
		delete [] m_pwszSource;
		m_pwszSource = NULL;
	}

	// Copy this stuff locally
	if ( NULL != pwszHelpFile )
	{
		m_pwszHelpFile = new WCHAR[wcslen( pwszHelpFile ) + 1];

		if ( NULL != m_pwszHelpFile )
		{
			wcscpy( m_pwszHelpFile, pwszHelpFile );
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	if ( SUCCEEDED(hr) && NULL != pwszSource )
	{
		m_pwszSource = new WCHAR[wcslen( pwszSource ) + 1];

		if ( NULL != m_pwszSource )
		{
			wcscpy( m_pwszSource, pwszSource );
		}
		else
		{
			hr = WBEM_S_NO_ERROR;
		}
	}

	// Finally, set the properties
	if ( SUCCEEDED( hr ) )
	{
		LPCWSTR	apStrPropNames[4] = { L"Description", L"Operation", L"ParameterInfo", L"ProviderName" };
		LPCWSTR	apStrPropValues[4] = {  pwszDescription, pwszOperation, pwszParameterInfo, pwszProviderName };

		for ( int x = 0; SUCCEEDED( hr ) && x < 4; x++ )
		{
			hr = WriteProp( apStrPropNames[x],
							0L,
							( NULL == apStrPropValues[x] ? 0L : ( wcslen( apStrPropValues[x] ) + 1 ) * 2 ),
							0L,
							CIM_STRING,
							(void*) apStrPropValues[x] );
		}

		if ( SUCCEEDED( hr ) )
		{
			hr = WriteProp( L"StatusCode",
							0L,
							sizeof(DWORD),
							0L,
							CIM_UINT32,
							&dwStatusCode );
		}

	}

	return hr;
}

HRESULT CWmiErrorObject::GetGUID(GUID* pguid)
{
    try
    {
        *pguid = m_Guid;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}

HRESULT CWmiErrorObject::GetHelpContext(DWORD* pdwHelpContext)
{
    try
    {
        *pdwHelpContext = 0;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}

HRESULT CWmiErrorObject::GetHelpFile(BSTR* pstrHelpFile)
{
    try
    {
		// Allocate a BSTR if someone gave us a HelpFile.
		if ( NULL != m_pwszHelpFile )
		{
			*pstrHelpFile = SysAllocString( m_pwszHelpFile );

			if ( NULL == *pstrHelpFile )
			{
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			*pstrHelpFile = 0;
		}

        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}

HRESULT CWmiErrorObject::GetSource(BSTR* pstrSource)
{
    try
    {
		// Allocate a BSTR if someone gave us a HelpFile.
		if ( NULL != m_pwszSource )
		{
			*pstrSource = SysAllocString( m_pwszSource );

			if ( NULL == *pstrSource )
			{
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			*pstrSource = 0;
		}

        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmicombd.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMICOMBD.CPP

Abstract:

  CWmiComBinding implementation.

  Implements the IWmiComBinding interface.

History:

  24-Apr-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "wmicombd.h"
#include "arrtempl.h"

//***************************************************************************
//
//  CWmiComBinding::CWmiComBinding
//
//***************************************************************************
// ok
CWmiComBinding::CWmiComBinding( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWmiComBinding( this )
{
}
    
//***************************************************************************
//
//  CWmiComBinding::~CWmiComBinding
//
//***************************************************************************
// ok
CWmiComBinding::~CWmiComBinding()
{
}

// Override that returns us an interface
void* CWmiComBinding::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemComBinding )
        return &m_XWmiComBinding;
    else
        return NULL;
}

// Pass thru _IWbemConfigureRefreshingSvc implementation
STDMETHODIMP CWmiComBinding::XWmiComBinding::GetCLSIDArrayForIID( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags,
															IWbemContext* pCtx, SAFEARRAY** pArray )
{
	return m_pObject->GetCLSIDArrayForIID( pSvcEx, pObject, riid, lFlags, pCtx, pArray );
}

STDMETHODIMP CWmiComBinding::XWmiComBinding::BindComObject( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId,
								IWbemContext *pCtx, long lFlags, IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface )
{
	return m_pObject->BindComObject( pSvcEx, pObject, ClsId, pCtx, lFlags, pUnkOuter, dwClsCntxt, riid, pInterface );
}

STDMETHODIMP CWmiComBinding::XWmiComBinding::GetCLSIDArrayForNames( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
																	LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray )
{
	return m_pObject->GetCLSIDArrayForNames( pSvcEx, pObject, rgszNames, cNames, lcid, pCtx, lFlags, pArray );
}

/* IWmiComBinding implemetation */
HRESULT CWmiComBinding::GetCLSIDArrayForIID( IWbemServicesEx* pSvcEx, IWbemClassObject* pObject, REFIID riid, long lFlags,
										IWbemContext* pCtx, SAFEARRAY** pArray )
{
	// Check we've got everything we need, and that the class context is one of the ones we
	// currently support.

	if ( 0L != lFlags || NULL == pSvcEx || NULL == pObject || NULL == pArray )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Create a string representation of the requested riid
		WCHAR*	pwszRIID = NULL;
		hr = StringFromIID( riid, &pwszRIID );
		CMemFreeMe	mfm( pwszRIID );

		if ( FAILED( hr ) )
		{
			return WBEM_E_INVALID_PARAMETER;
		}

		// Holds the class chain
		CSafeArray	sa( VT_BSTR, CSafeArray::auto_delete );
		hr = GetClassChain( pObject, &sa );

		if ( SUCCEEDED( hr ) )
		{
			// The one we'll return to the user
			CSafeArray	saCLSID( VT_BSTR, CSafeArray::auto_delete );

			// Enumerate the elements
			for ( int i = 0; SUCCEEDED( hr ) && i < sa.Size(); i++ )
			{
				BSTR	bstrClass = sa.GetBSTRAt( i );
				CSysFreeMe	sfm( bstrClass );

				if ( NULL != bstrClass )
				{
					hr = ExecuteComBindingQuery( pSvcEx, pCtx, bstrClass, pwszRIID, &saCLSID );
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}	// FOR Enum derivation

			// IF all is kosher, get the array, and set the destructor policy to not delete it
			if ( SUCCEEDED( hr ) )
			{
				*pArray = saCLSID.GetArray();
				saCLSID.SetDestructorPolicy( CSafeArray::no_delete );
			}

		}	// IF Get __DERIVATION

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	
	return hr;
}

HRESULT CWmiComBinding::BindComObject( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, CLSID ClsId, IWbemContext *pCtx,
										long lFlags, IUnknown *pUnkOuter, DWORD dwClsCntxt, REFIID riid, LPVOID *pInterface )
{
	// Check we've got everything we need, and that the class context is one of the ones we
	// currently support.

	if ( 0L != lFlags || NULL == pSvcEx || NULL == pObject || NULL == pInterface )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// We only accespt INPROC at this time
	if ( dwClsCntxt & ~CLSCTX_INPROC_SERVER )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Aggregation requires IID_IUnknown
	if ( NULL != pUnkOuter && riid != IID_IUnknown )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{

		IUnknown* pUnk = NULL;

		// CoCreate their object
		hr = CoCreateInstance( ClsId, pUnkOuter, dwClsCntxt, IID_IUnknown, (void**) &pUnk );
		CReleaseMe	rm( pUnk );

		if ( SUCCEEDED( hr ) )
		{
			IWbemInitComBinding*	pInitBinding = NULL;

			// Cleanup the binding
			hr = pUnk->QueryInterface( IID_IWbemInitComBinding, (void**) &pInitBinding );
			CReleaseMe	rm1( pInitBinding );

			if ( SUCCEEDED( hr ) )
			{
				// Initialize.  If this succeeds, then we'll QI for the requested interface
				hr = pInitBinding->Initialize( 0L, pSvcEx, pCtx, pObject );

				if ( SUCCEEDED( hr ) )
				{
					// Final QI
					hr = pUnk->QueryInterface( riid, pInterface );
				}

			}	// IF QI for InitComBinding

		}	// IF CCI

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	
	return hr;
}

HRESULT CWmiComBinding::GetCLSIDArrayForNames( IWbemServicesEx *pSvcEx, IWbemClassObject* pObject, LPCWSTR * rgszNames, UINT cNames,
												LCID lcid, IWbemContext* pCtx, long lFlags, SAFEARRAY** pArray )
{
	// Check we've got everything we need, and that the class context is one of the ones we
	// currently support.

	if ( 0L != lFlags || NULL == pSvcEx || NULL == pObject || NULL == pArray )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// We only handle the neutral locale for now
	if ( LOCALE_NEUTRAL != lcid )
	{
		return WBEM_E_INVALID_LOCALE;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// First, get the __COMDispatchInfo class object and spawn an instance we can clone into
		// our result set.

		IWbemClassObject*	pDispInfoInst = NULL;
		hr = GetDispInfoInstance( pSvcEx, pCtx, &pDispInfoInst );

		if ( SUCCEEDED( hr ) )
		{
			CReleaseMe	rmDispInfInst( pDispInfoInst );

			// Now get the __Derivation property, so we have a chain of classes to woalk up for
			// our associators queries 
			// Holds the class chain
			CSafeArray	saDerivation( VT_BSTR, CSafeArray::auto_delete );
			hr = GetClassChain( pObject, &saDerivation );

			if ( SUCCEEDED( hr ) )
			{
				// The one we'll return to the user
				// The array we'll return to the user
				CSafeArray	saObjects( VT_UNKNOWN, CSafeArray::auto_delete );

				// Now make sure we have a list of names and classes
				if ( cNames > 0 && saDerivation.Size() > 0 )
				{
					// Enumerate the elements
					for ( int i = 0; SUCCEEDED( hr ) && i < saDerivation.Size(); i++ )
					{
						BSTR	bstrClass = saDerivation.GetBSTRAt( i );
						CSysFreeMe	sfm( bstrClass );

						if ( NULL != bstrClass )
						{
							hr = ExecuteDispatchElementQuery( pSvcEx, pCtx, pDispInfoInst, bstrClass, rgszNames, cNames, &saObjects );
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}

					}	// FOR Enum derivation
				}

				if ( SUCCEEDED( hr ) )
				{
					*pArray = saObjects.GetArray();
					saObjects.SetDestructorPolicy( CSafeArray::no_delete );
				}

			}	// IF Get __DERIVATION

		}	// IF GetDispInfoInstance

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}
	
	return hr;
}

// Check the RIID against the values in the iidarray of the object.  If we get a match, we will add the
// object's class id to the safe array

HRESULT CWmiComBinding::CheckRIID( IWbemClassObject* pObj, LPCWSTR pwszRIID, CSafeArray* psa )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	VARIANT	v;

	// Get the array
	hr = pObj->Get( L"IID", 0L, &v, NULL, NULL );

	if ( SUCCEEDED( hr ) )
	{
		CClearMe	cm( &v );

		// Check that it's an expected type
		if ( V_VT(&v) == ( VT_BSTR | VT_ARRAY ) )
		{
			CSafeArray	sa( V_ARRAY( &v ), VT_BSTR, CSafeArray::bind | CSafeArray::no_delete );

			// Enumerate the elements
			for ( int i = 0; SUCCEEDED( hr ) && i < sa.Size(); i++ )
			{
				BSTR	bstrRIID = sa.GetBSTRAt( i );
				CSysFreeMe	sfm( bstrRIID );

				if ( NULL != bstrRIID )
				{
					// If a match, get the CLSID and add it to the array
					if ( wbem_wcsicmp( bstrRIID, pwszRIID ) == 0 )
					{
						VARIANT	vCLSID;

						hr = pObj->Get( L"CLSID", 0L, &vCLSID, NULL, NULL );
						
						if ( SUCCEEDED( hr ) )
						{
							CClearMe	cm1( &vCLSID );

							// Check that it's a BSTR
							if ( V_VT( &vCLSID ) == VT_BSTR )
							{
								psa->AddBSTR( V_BSTR( &vCLSID ) );
							}
							else
							{
								// ???????
								hr = WBEM_E_FAILED;
							}

						}	// IF Get CLSID

					}	// IF RIID comparison succeeded

				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}	// FOR enum array

		}	// IF it's the expected type
		else if ( V_VT( &v ) != VT_NULL )
		{
			//??????
			hr = WBEM_E_FAILED;
		}

	}	// IF we got the array property

	return hr;
}

// Execute a COM Binding associators of query
HRESULT CWmiComBinding::ExecuteComBindingQuery( IWbemServicesEx* pSvcEx, IWbemContext* pCtx, BSTR bstrClass, LPCWSTR pwszRIID, CSafeArray* psa )
{
	BSTR	bstrQL = SysAllocString( L"WQL");
	CSysFreeMe	sfm( bstrQL );

	BSTR	bstrQuery = GetAssociatorsQuery( bstrClass, L"__COMInterfaceSet");
	CSysFreeMe	sfm1( bstrQuery );

	if ( NULL == bstrQL || NULL == bstrQuery )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	IEnumWbemClassObject*	pEnum = NULL;

	HRESULT hr = pSvcEx->ExecQuery( bstrQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, pCtx, &pEnum );

	if ( SUCCEEDED( hr ) )
	{
		CSafeArray	sa( VT_BSTR, CSafeArray::auto_delete );

		while ( WBEM_S_NO_ERROR == hr )
		{
			DWORD	dwNumReturned = 0;
			IWbemClassObject*	apObj[10];

			hr = pEnum->Next( WBEM_INFINITE, 10, apObj, &dwNumReturned );

			if ( SUCCEEDED( hr ) )
			{
				for ( DWORD	dwCtr = 0; dwCtr < dwNumReturned; dwCtr++ )
				{
					hr = CheckRIID( apObj[dwCtr], pwszRIID, psa );
					apObj[dwCtr]->Release();
				}	// FOR enum objects

			}	// IF Next

		}	// WHILE enuming objects

	}	// IF ExecQuery

	return hr;
}

BSTR CWmiComBinding::GetAssociatorsQuery( BSTR bstrClass, LPCWSTR pwszResultClass )
{
	BSTR	bstrReturn = NULL;

	// Allocate a buffer big enough to hold the query.  Format it, then
	// create a BSTR from it
	ULONG	uLen = wcslen( COMBINDING_ASSOC_QUERY_FORMAT ) + wcslen( bstrClass ) + wcslen( pwszResultClass ) + 1;

	WCHAR*	wszTemp = new WCHAR[uLen];

	if ( NULL != wszTemp )
	{
		CVectorDeleteMe<WCHAR>	vdm( wszTemp );
		swprintf( wszTemp, COMBINDING_ASSOC_QUERY_FORMAT, bstrClass, pwszResultClass );

		bstrReturn = SysAllocString( wszTemp );
	}

	return bstrReturn;
}

HRESULT CWmiComBinding::GetDispInfoInstance( IWbemServicesEx *pSvcEx, IWbemContext* pCtx, IWbemClassObject** ppInst )
{
	// First, get the __COMDispatchInfo class object and spawn an instance we can clone into
	// our result set.

	BSTR	bstrDispInf = SysAllocString( L"__COMDispatchInfo" );
	CSysFreeMe	sfmDispInf( bstrDispInf );

	if ( NULL == bstrDispInf )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	IWbemClassObject*	pCls = NULL;
	HRESULT	hr = pSvcEx->GetObject( bstrDispInf, 0L, pCtx, &pCls, NULL );
	CReleaseMe	rm( pCls );

	if ( SUCCEEDED( hr ) )
	{
		hr = pCls->SpawnInstance( 0L, ppInst );
	}

	return hr;
}

// Execute a Dispatch Element associators of query
HRESULT CWmiComBinding::ExecuteDispatchElementQuery( IWbemServicesEx* pSvcEx, IWbemContext* pCtx, IWbemClassObject* pInst,
													BSTR bstrClass, LPCWSTR * rgszNames, UINT cNames, CSafeArray* psa )
{
	BSTR	bstrQL = SysAllocString( L"WQL");
	CSysFreeMe	sfm( bstrQL );

	BSTR	bstrQuery = GetAssociatorsQuery( bstrClass, L"__COMDispatchElement");
	CSysFreeMe	sfm1( bstrQuery );

	if ( NULL == bstrQL || NULL == bstrQuery )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	IEnumWbemClassObject*	pEnum = NULL;

	HRESULT hr = pSvcEx->ExecQuery( bstrQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, pCtx, &pEnum );

	if ( SUCCEEDED( hr ) )
	{
		CSafeArray	sa( VT_BSTR, CSafeArray::auto_delete );

		while ( WBEM_S_NO_ERROR == hr )
		{
			DWORD	dwNumReturned = 0;
			IWbemClassObject*	apObj[10];

			hr = pEnum->Next( WBEM_INFINITE, 10, apObj, &dwNumReturned );

			if ( SUCCEEDED( hr ) )
			{
				for ( DWORD	dwCtr = 0; dwCtr < dwNumReturned; dwCtr++ )
				{
					hr = ResolveMethod( apObj[dwCtr], rgszNames, cNames, pInst, psa );
					apObj[dwCtr]->Release();
				}	// FOR enum objects

			}	// IF Next

		}	// WHILE enuming objects

	}	// IF ExecQuery

	return hr;
}

HRESULT	CWmiComBinding::ResolveMethod( IWbemClassObject* pResultObj, LPCWSTR* rgszNames, UINT cNames, IWbemClassObject* pInst, CSafeArray* psa )
{
	VARIANT	vMethodName;

	HRESULT	hr = pResultObj->Get( L"Name", 0L, &vMethodName, NULL, NULL );
	// Get the Name, if it matches, then we've got at least one hit

	if ( SUCCEEDED( hr )  )
	{
		CClearMe	cmMethodName( &vMethodName );

		if ( V_VT( &vMethodName ) == VT_BSTR && wbem_wcsicmp( V_BSTR( &vMethodName ), *rgszNames ) == 0 )
		{
			// Method name matched, so clone a new instance and start copying across data
			IWbemClassObject*	pNewInst = NULL;
			hr = pInst->Clone( &pNewInst );

			if ( SUCCEEDED( hr ) )
			{
				CReleaseMe	rmNewInst( pNewInst );

				hr = CopyMethodNameAndDispId( pResultObj, pNewInst );

				if ( SUCCEEDED( hr ) )
				{
					// Resolve argument names if necessary
					if ( cNames > 1 )
					{
						hr = ResolveArgumentNames( pResultObj, rgszNames + 1, cNames - 1, pInst );
					}

					// If we resolved everything, add the new instance to the target safe array
					// If WBEM_S_DIFFERENT, there was a mismatch.  No big deal.
					if ( WBEM_S_NO_ERROR == hr )
					{
						psa->AddUnknown( pNewInst );
					}

				}	// IF Copied Name and DispId

			}	// IF Clone

		}	// IF Matched method name

	}	// IF Get Name

	return hr;
}

HRESULT	CWmiComBinding::CopyMethodNameAndDispId( IWbemClassObject* pResultObj, IWbemClassObject* pInst )
{
	VARIANT	vTemp;

	HRESULT	hr = pResultObj->Get( L"CLSID", 0L, &vTemp, NULL, NULL );

	if ( SUCCEEDED( hr ) )
	{
		// Put the value
		hr = pInst->Put( L"CLSID", 0L, &vTemp, 0L );
		VariantClear( &vTemp );

		if ( SUCCEEDED( hr ) )
		{
			hr = pResultObj->Get( L"DISPID", 0L, &vTemp, NULL, NULL );

			if ( SUCCEEDED( hr ) )
			{
				// Put the value
				hr = pInst->Put( L"DISPID", 0L, &vTemp, 0L );
				VariantClear( &vTemp );
			}

		}	// IF Put

	}	// IF Get

	return hr;
}

HRESULT	CWmiComBinding::ResolveArgumentNames( IWbemClassObject* pResultObj, LPCWSTR* rgszNames, UINT cNames, IWbemClassObject* pInst )
{
	VARIANT	vArgumentNames;

	HRESULT	hr = pResultObj->Get( L"NamedArguments", 0L, &vArgumentNames, NULL, NULL );

	if ( SUCCEEDED( hr ) )
	{
		CClearMe	cmArgNames( &vArgumentNames );

		VARIANT	vArgumentDispIds;
		hr = pResultObj->Get( L"NamedArgumentDISPIDs", 0L, &vArgumentDispIds, NULL, NULL );

		if ( SUCCEEDED( hr ) )
		{
			CClearMe	cmArgDispIds( &vArgumentDispIds );

			if (	V_VT( &vArgumentNames ) == ( VT_BSTR | VT_ARRAY ) &&
					V_VT( &vArgumentDispIds ) == ( VT_I4 | VT_ARRAY ) )
			{
				CSafeArray	saNames( V_ARRAY( &vArgumentNames ), VT_BSTR, CSafeArray::bind | CSafeArray::no_delete );
				CSafeArray	saDispIds( V_ARRAY( &vArgumentDispIds ), VT_I4, CSafeArray::bind | CSafeArray::no_delete );

				// If the sizes don't match, skip this
				if ( saNames.Size() == saDispIds.Size() )
				{
					// Need something to store matches in
					CSafeArray	saTargetDispIds( VT_I4, CSafeArray::auto_delete );

					// Resolve the argument names
					hr = CheckArgumentNames( &saNames, &saDispIds, rgszNames, cNames, &saTargetDispIds );

					// We resolved all the names if WBEM_S_NO_ERROR, WBEM_S_DIFFERENT means a mismatch
					if ( WBEM_S_NO_ERROR == hr )
					{
						VARIANT	vTargetDispIds;

						// We won't clear this, the Safe Array will take care of cleanup
						V_VT( &vTargetDispIds ) = ( VT_I4 | VT_ARRAY );
						V_ARRAY( &vTargetDispIds ) = saTargetDispIds.GetArray();

						hr = pInst->Put( L"NamedArgumentDISPIDs", 0L, &vTargetDispIds, 0L );
					}
				}
				else
				{
					VARIANT	vTemp;

					if ( SUCCEEDED( pResultObj->Get( L"__PATH", 0L, &vTemp, NULL, NULL ) ) )
					{
						CClearMe	cmTemp( &vTemp );

						if ( V_VT( &vTemp ) == VT_BSTR )
						{
							ERRORTRACE((LOG_WBEMCORE, "__COMDispatchElement contains mismatched Names and DispIds: "
											"%S\n", V_BSTR( &vTemp ) ) );
						}

					}

					hr = WBEM_E_INVALID_OBJECT;


				}	// SIZE mismatch

			}	// IF proper types

		}	// IF Got Dispids

	}	// IF Got Names

	return hr;
}

HRESULT	CWmiComBinding::CheckArgumentNames( CSafeArray* psaNames, CSafeArray* psaDispIds, LPCWSTR* rgszNames, UINT cNames, CSafeArray* psaTargetDispIds )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Walk the names array once, since we'll be referring to it a bunch
	CFixedBSTRArray	bstrNamesArray;
	bstrNamesArray.Create( psaNames->Size() );

	for ( int i = 0; SUCCEEDED( hr ) && i < psaNames->Size(); i++ )
	{
		BSTR	bstrName = psaNames->GetBSTRAt( i );

		if ( NULL != bstrName )
		{
			bstrNamesArray[i] = bstrName;
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	
	// Now compare names.  For each one that matches, get the DISPID and stick
	// it in the target array
	for ( UINT uNameCtr = 0; SUCCEEDED( hr ) && uNameCtr < cNames; uNameCtr++ )
	{
		for ( i = 0; SUCCEEDED( hr ) && i < psaNames->Size(); i++ )
		{
			if ( wbem_wcsicmp( rgszNames[uNameCtr], bstrNamesArray.GetAt( i ) ) == 0 )
			{
				DISPID	dispId = psaDispIds->GetLongAt( i );
				psaTargetDispIds->AddLong( dispId );
				// We matched this name
				break;
			}	// IF matched name

		}	// FOR enum argument names

		// If we didn't match a name, we're outa here - the method can't possibly match
		if ( i >= psaNames->Size() )
		{
			hr = WBEM_E_NOT_FOUND;
		}

	}	// FOR enum names

	// Cleanup
	bstrNamesArray.Free();

	return hr;
}

// Build a class chain we can walk in order to do associators queries
HRESULT CWmiComBinding::GetClassChain( IWbemClassObject* pObject, CSafeArray* psa )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Get the derivation chain
		VARIANT	vDerivation;
		hr = pObject->Get( L"__DERIVATION", 0L, &vDerivation, NULL, NULL );

		if ( SUCCEEDED( hr ) )
		{
			CClearMe	cm( &vDerivation );

			// Check that it's an expected type
			if ( V_VT(&vDerivation) == ( VT_BSTR | VT_ARRAY ) )
			{
				// Handles the variant
				CSafeArray	sa( V_ARRAY( &vDerivation ), VT_BSTR, CSafeArray::no_delete | CSafeArray::bind );

				for ( int x = 0; SUCCEEDED( hr ) && x < sa.Size(); x++ )
				{
					BSTR	bstrName = sa.GetBSTRAt( x );

					if ( NULL != bstrName )
					{
						CSysFreeMe	sfm( bstrName );
						psa->AddBSTR( bstrName );
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

				}	// FOR enum derivation

			}	// IF we got an array

			if ( SUCCEEDED( hr ) )
			{
				VARIANT vClassName;
				hr = pObject->Get( L"__CLASS", 0L, &vClassName, NULL, NULL );

				if ( SUCCEEDED( hr ) )
				{
					CClearMe	cm2( &vClassName );

					if ( V_VT(&vClassName) == VT_BSTR )
					{
						psa->AddBSTR( V_BSTR( &vClassName ) );
					}
					
				}	// IF Get Class

			}	// IF We're okay

		}	// IF Get DERIVATION

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_CRITICAL_ERROR;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobftr.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBFTR.H

Abstract:

  CWmiObjectFactory Definition.

  Standard definition for _IWmiObjectFactory.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _WMIOBFTR_H_
#define _WMIOBFTR_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>

//***************************************************************************
//
//  class CWmiObjectFactory
//
//  Implementation of _IWmiObjectFactory Interface
//
//***************************************************************************

class COREPROX_POLARITY CWmiObjectFactory : public CUnk
{

public:
    CWmiObjectFactory(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CWmiObjectFactory(); 

	/* _IWmiObjectFactory methods */
    HRESULT Create( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid, REFIID riid, LPVOID* ppObj );
	// Specifies everything we could possibly want to know about the creation of
	// an object and more.

    class COREPROX_POLARITY XObjectFactory : public CImpl<_IWmiObjectFactory, CWmiObjectFactory>
    {
    public:
        XObjectFactory(CWmiObjectFactory* pObject) : 
            CImpl<_IWmiObjectFactory, CWmiObjectFactory>(pObject)
        {}

		STDMETHOD(Create)( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid, REFIID riid, LPVOID* ppObj );

    } m_XObjectFactory;
    friend XObjectFactory;


protected:
    void* GetInterface(REFIID riid);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobftr.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBFTR.CPP

Abstract:

  CWmiObjectFactory implementation.

  Implements the _IWmiObjectFactory interface.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include "frfoobj.h"
//#include "umiwrap.h"
#include "wmierobj.h"
//#include "umierobj.h"

//***************************************************************************
//
//  CWmiObjectFactory::~CWmiObjectFactory
//
//***************************************************************************
// ok
CWmiObjectFactory::CWmiObjectFactory( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk(pControl, pOuter),
	m_XObjectFactory( this )
{
}
    
//***************************************************************************
//
//  CWmiObjectFactory::~CWmiObjectFactory
//
//***************************************************************************
// ok
CWmiObjectFactory::~CWmiObjectFactory()
{
}

// Override that returns us an interface
void* CWmiObjectFactory::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWmiObjectFactory)
        return &m_XObjectFactory;
    else
        return NULL;
}

/* _IWmiObjectFactory methods */

HRESULT CWmiObjectFactory::XObjectFactory::Create( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid,
										REFIID riid, LPVOID* ppObj )
{
	return m_pObject->Create( pUnkOuter, ulFlags, rclsid, riid, ppObj );
}


// Specifies everything we could possibly want to know about the creation of
// an object and more.
HRESULT CWmiObjectFactory::Create( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid,
									REFIID riid, LPVOID* ppObj )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		if ( CLSID__WmiFreeFormObject == rclsid )
		{
			// Create a new free form object
			CWmiFreeFormObject*	pffObj = new CWmiFreeFormObject( m_pControl, pUnkOuter );

			if ( NULL != pffObj )
			{
				hr = pffObj->Init( NULL );

				if ( SUCCEEDED( hr ) )
				{
					hr = pffObj->QueryInterface( riid, ppObj );
				}

				if ( FAILED(hr) )
				{
					delete pffObj;
				}
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else if ( CLSID__WmiWbemClass == rclsid )
		{
			// Cannot be aggregated
			if ( NULL == pUnkOuter )
			{
				// Create a new class object and
				// initialize it.

				CWbemClass*	pObject = new CWbemClass;
				// Already AddRef'd
				CReleaseMe	rm( (IWbemClassObject*) pObject );

				if ( NULL != pObject )
				{
					hr = pObject->InitEmpty();

					if ( SUCCEEDED( hr ) )
					{
						hr = pObject->QueryInterface( riid, ppObj );
					}

				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}
			else
			{
	            hr = CLASS_E_NOAGGREGATION;
			}

		}
		else if ( CLSID__WbemEmptyClassObject == rclsid )
		{
			// Cannot be aggregated
			if ( NULL == pUnkOuter )
			{
				// Create a new class object and
				// initialize it.

				CWbemClass*	pObject = new CWbemClass;
				// Already AddRef'd
				CReleaseMe	rm( (IWbemClassObject*) pObject );

				if ( NULL != pObject )
				{
					// When we initialize this class object, we don't want base
					// system properties to be created
					hr = pObject->InitEmpty( 0, FALSE );

					if ( SUCCEEDED( hr ) )
					{
						hr = pObject->QueryInterface( riid, ppObj );
					}
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}
			else
			{
	            hr = CLASS_E_NOAGGREGATION;
			}
		}
		else if ( CLSID__WmiWbemInstance == rclsid )
		{
			// Cannot be aggregated
			if ( NULL == pUnkOuter )
			{

				// Create a new instance object, caller won't
				// be able to do much with it other than set object
				// parts

				CWbemInstance*	pObject = new CWbemInstance;
				// Already AddRef'd
				CReleaseMe	rm( (IWbemClassObject*) pObject );

				if ( NULL != pObject )
				{
					hr = pObject->QueryInterface( riid, ppObj );
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}

		}
/*		
		else if ( CLSID__WbemUMIObjectWrapper == rclsid )
		{
			// Give 'em what they want
			CUMIObjectWrapper*	pUmiObjWrapper = new CUMIObjectWrapper( m_pControl, pUnkOuter );

			if ( NULL != pUmiObjWrapper )
			{
				hr = pUmiObjWrapper->QueryInterface( riid, ppObj );
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

		}
*/		
		else if ( CLSID__WmiErrorObject == rclsid )
		{
			// Give 'em what they want
			CWmiErrorObject*	pErrObj = new CWmiErrorObject( m_pControl, pUnkOuter );

			if ( NULL != pErrObj )
			{
				hr = pErrObj->QueryInterface( riid, ppObj );
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

		}
/*		
		else if ( CLSID__UmiErrorObject == rclsid )
		{
			// Give 'em what they want
			CUMIErrorObject*	pErrObj = new CUMIErrorObject( m_pControl, pUnkOuter );

			if ( NULL != pErrObj )
			{
				hr = pErrObj->QueryInterface( riid, ppObj );
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}

		}
*/		

		return hr;

	}
	catch ( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobtxt.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBTXT.H

Abstract:

  CWmiObjectTextSrc Definition.

  Standard definition for IWbemObjectTextSrc.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _WMIOBTXT_H_
#define _WMIOBTXT_H_

#include "corepol.h"
#include "txtscmgr.h"
#include <arena.h>

//***************************************************************************
//
//  class CWmiObjectTextSrc
//
//  Implementation of _IWmiObjectFactory Interface
//
//***************************************************************************

class COREPROX_POLARITY CWmiObjectTextSrc : public CUnk
{
private:
	CTextSourceMgr	m_TextSourceMgr;

public:
    CWmiObjectTextSrc(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWmiObjectTextSrc(); 

protected:

	HRESULT GetText( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat, IWbemContext *pCtx, BSTR *strText );
	HRESULT CreateFromText( long lFlags, BSTR strText, ULONG uObjTextFormat, IWbemContext *pCtx,
								IWbemClassObject **pNewObj );

    class COREPROX_POLARITY XObjectTextSrc : public CImpl<IWbemObjectTextSrc, CWmiObjectTextSrc>
    {
    public:
        XObjectTextSrc(CWmiObjectTextSrc* pObject) : 
            CImpl<IWbemObjectTextSrc, CWmiObjectTextSrc>(pObject)
        {}

		STDMETHOD(GetText)( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat, IWbemContext *pCtx, BSTR *strText );
		STDMETHOD(CreateFromText)( long lFlags, BSTR strText, ULONG uObjTextFormat, IWbemContext *pCtx,
									IWbemClassObject **pNewObj );

    } m_XObjectTextSrc;
    friend XObjectTextSrc;

protected:
    void* GetInterface(REFIID riid);

public:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wrapobj.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WRAPOBJ.CPP

Abstract:

  CWmiObjectWrapper implementation.

  Implements an aggregable wrapper around a CWbemObject.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wrapobj.h"
#include <corex.h>
#include "strutils.h"

//***************************************************************************
//
//  CWmiObjectWrapper::~CWmiObjectWrapper
//
//***************************************************************************
// ok
CWmiObjectWrapper::CWmiObjectWrapper( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XWMIObject( this ),
	m_XObjectMarshal( this ),
//	m_XUmiPropList( this ),
	m_XErrorInfo( this ),
	m_pObj( NULL )
{
    m_Lock.SetData(&m_LockData);
}
    
//***************************************************************************
//
//  CWmiObjectWrapper::~CWmiObjectWrapper
//
//***************************************************************************
// ok
CWmiObjectWrapper::~CWmiObjectWrapper()
{
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
	}
}

// Helper function to wrap returned CWbemObject pointers (i.e. those returned
// from delegated calls to our own CWbemObject pointer
HRESULT CWmiObjectWrapper::WrapReturnedObject( CWbemObject* pObj, BOOL fClone, REFIID riid, LPVOID* pvObj )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Wrap the cloned object with our free form object
	// Anything that returns a new object will get a new
	// wrapper object
	CWmiObjectWrapper*	pWrapperObj = CreateNewWrapper( fClone );

	if ( NULL == pWrapperObj )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	else
	{
		// We're the only ones that know the dirty little
		// CWbemObject* secret
		hr = pWrapperObj->Init( pObj );

		if ( SUCCEEDED( hr ) )
		{
			hr = pWrapperObj->QueryInterface( riid, pvObj );

			if ( SUCCEEDED( hr ) )
			{
				// Release now, since the wrapper will have bumped the refcount
				pObj->Release();
			}
			else
			{
				delete pWrapperObj;
			}
		}
	}

	return hr;
}

/* IWbemClassObject methods */

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetQualifierSet(IWbemQualifierSet** pQualifierSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetQualifierSet( pQualifierSet );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
									long* plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Get( wszName, lFlags, pVal, pctType, plFlavor );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
	// Pass through to the wrapper object
	return m_pObject->Put( wszName, lFlags, pVal, ctType );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::Delete(LPCWSTR wszName)
{
	// Pass through to the wrapper object
	return m_pObject->Delete( wszName );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
											SAFEARRAY** pNames)
{
	// Pass through to the wrapper object
	return m_pObject->GetNames( wszName, lFlags, pVal, pNames );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::BeginEnumeration(long lEnumFlags)
{
	// Pass through to the wrapper object
	return m_pObject->BeginEnumeration( lEnumFlags );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::CIMTYPEToVARTYPE( CIMTYPE ct, VARTYPE* pvt )
{
	// Pass through to the wrapper object
	return m_pObject->CIMTYPEToVARTYPE( ct, pvt );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SpawnKeyedInstance( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst )
{
	// Pass through to the wrapper object
	return m_pObject->SpawnKeyedInstance( lFlags, pwszPath, ppInst );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                long* plFlavor)
{
	// Pass through to the wrapper object
	return m_pObject->Next( lFlags, pName, pVal, pctType, plFlavor );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::EndEnumeration()
{
	// Pass through to the wrapper object
	return m_pObject->EndEnumeration();
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** pQualifierSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyQualifierSet( wszProperty, pQualifierSet );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::Clone(IWbemClassObject** pCopy)
{
	// Pass through to the wrapper object
	return m_pObject->Clone( pCopy );

}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetObjectText(long lFlags, BSTR* pMofSyntax)
{
	// Pass through to the wrapper object
	return m_pObject->GetObjectText( lFlags, pMofSyntax );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
	// Pass through to the wrapper object
	return m_pObject->CompareTo( lFlags, pCompareTo );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyOrigin( wszProperty, pstrClassName );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::InheritsFrom(LPCWSTR wszClassName)
{
	// Pass through to the wrapper object
	return m_pObject->InheritsFrom( wszClassName );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass)
{
	// Pass through to the wrapper object
	return m_pObject->SpawnDerivedClass( lFlags, ppNewClass );

}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance)
{
	// Pass through to the wrapper object
	return m_pObject->SpawnInstance( lFlags, ppNewInstance );

}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                        IWbemClassObject** ppOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethod( wszName, lFlags, ppInSig, ppOutSig );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                        IWbemClassObject* pOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->PutMethod( wszName, lFlags, pInSig, pOutSig );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::DeleteMethod(LPCWSTR wszName)
{
	// Pass through to the wrapper object
	return m_pObject->DeleteMethod( wszName );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::BeginMethodEnumeration(long lFlags)
{
	// Pass through to the wrapper object
	return m_pObject->BeginMethodEnumeration( lFlags );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::NextMethod(long lFlags, BSTR* pstrName, 
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
{
	// Pass through to the wrapper object
	return m_pObject->NextMethod( lFlags, pstrName, ppInSig, ppOutSig );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::EndMethodEnumeration()
{
	// Pass through to the wrapper object
	return m_pObject->EndMethodEnumeration();
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethodQualifierSet( wszName, ppSet );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName)
{
	// Pass through to the wrapper object
	return m_pObject->GetMethodOrigin( wszMethodName, pstrClassName );
}

// IWbemObjectAccess

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetPropertyHandle(LPCWSTR wszPropertyName, CIMTYPE* pct, long *plHandle)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyHandle( wszPropertyName, pct, plHandle );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::WritePropertyValue(long lHandle, long lNumBytes, const byte *pData)
{
	// Pass through to the wrapper object
	return m_pObject->WritePropertyValue( lHandle, lNumBytes, pData );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::ReadPropertyValue(long lHandle, long lBufferSize, long *plNumBytes, byte *pData)
{
	// Pass through to the wrapper object
	return m_pObject->ReadPropertyValue( lHandle, lBufferSize, plNumBytes, pData );
}


STDMETHODIMP CWmiObjectWrapper::XWMIObject::ReadDWORD(long lHandle, DWORD *pdw)
{
	// Pass through to the wrapper object
	return m_pObject->ReadDWORD( lHandle, pdw );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::WriteDWORD(long lHandle, DWORD dw)
{
	// Pass through to the wrapper object
	return m_pObject->WriteDWORD( lHandle, dw );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::ReadQWORD(long lHandle, unsigned __int64 *pqw)
{
	// Pass through to the wrapper object
	return m_pObject->ReadQWORD( lHandle, pqw );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::WriteQWORD(long lHandle, unsigned __int64 qw)
{
	// Pass through to the wrapper object
	return m_pObject->WriteQWORD( lHandle, qw );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetPropertyInfoByHandle(long lHandle, BSTR* pstrName, CIMTYPE* pct)
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyInfoByHandle( lHandle, pstrName, pct );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::Lock(long lFlags)
{
	// Pass through to the wrapper object
	return m_pObject->Lock( lFlags );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::Unlock(long lFlags)
{
	// Pass through to the wrapper object
	return m_pObject->Unlock( lFlags );
}

// _IWmiObject Object Parts methods
// =================================

STDMETHODIMP CWmiObjectWrapper::XWMIObject::QueryPartInfo( DWORD *pdwResult )
{
	// Pass through to the wrapper object
	return m_pObject->QueryPartInfo( pdwResult );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetObjectMemory( LPVOID pMem, DWORD dwMemSize )
{
	// Pass through to the wrapper object
	return m_pObject->SetObjectMemory( pMem, dwMemSize );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetObjectMemory( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
	// Pass through to the wrapper object
	return m_pObject->GetObjectMemory( pDestination, dwDestBufSize, pdwUsed );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetObjectParts( LPVOID pMem, DWORD dwMemSize, DWORD dwParts )
{
	// Pass through to the wrapper object
	return m_pObject->SetObjectParts( pMem, dwMemSize, dwParts );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetObjectParts( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed )
{
	// Pass through to the wrapper object
	return m_pObject->GetObjectParts( pDestination, dwDestBufSize, dwParts, pdwUsed );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::StripClassPart()
{
	// Pass through to the wrapper object
	return m_pObject->StripClassPart();
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::IsObjectInstance()
{
	// Pass through to the wrapper object
	return m_pObject->IsObjectInstance();
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetClassPart( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
	// Pass through to the wrapper object
	return m_pObject->GetClassPart( pDestination, dwDestBufSize, pdwUsed );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetClassPart( LPVOID pClassPart, DWORD dwSize )
{
	// Pass through to the wrapper object
	return m_pObject->SetClassPart( pClassPart, dwSize );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::MergeClassPart( IWbemClassObject *pClassPart )
{
	// Pass through to the wrapper object
	return m_pObject->MergeClassPart( pClassPart );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetDecoration( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace )
{
	// Pass through to the wrapper object
	return m_pObject->SetDecoration( pwcsServer, pwcsNamespace );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::RemoveDecoration( void )
{
	// Pass through to the wrapper object
	return m_pObject->RemoveDecoration();
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::CompareClassParts( IWbemClassObject* pObj, long lFlags )
{
	// Pass through to the wrapper object
	return m_pObject->CompareClassParts( pObj, lFlags );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::ClearWriteOnlyProperties( void )
{
	// Pass through to the wrapper object
	return m_pObject->ClearWriteOnlyProperties();
}

//
//	_IWmiObjectAccessEx functions
STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetPropertyHandleEx( LPCWSTR pszPropName, long lFlags, CIMTYPE* puCimType, long* plHandle )
{
	// Pass through to the wrapper object
	return m_pObject->GetPropertyHandleEx( pszPropName, lFlags, puCimType, plHandle );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetPropByHandle( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData )
{
	// Pass through to the wrapper object
	return m_pObject->SetPropByHandle( lHandle, lFlags, uDataSize, pvData );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetPropAddrByHandle( long lHandle, long lFlags, ULONG* puFlags,
													 LPVOID *pAddress )
{
	// Pass through to the wrapper object
	return m_pObject->GetPropAddrByHandle( lHandle, lFlags, puFlags, pAddress );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetArrayPropInfoByHandle( long lHandle, long lFlags, BSTR* pstrName,
															CIMTYPE* pct, ULONG* puNumElements )
{
	// Pass through to the wrapper object
	return m_pObject->GetArrayPropInfoByHandle( lHandle, lFlags, pstrName, pct, puNumElements );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetArrayPropAddrByHandle( long lHandle, long lFlags, ULONG* puNumElements,
														  LPVOID *pAddress )
{
	// Pass through to the wrapper object
	return m_pObject->GetArrayPropAddrByHandle( lHandle, lFlags, puNumElements, pAddress );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
															 ULONG* puFlags, ULONG* puNumElements,
															 LPVOID *pAddress )
{
	// Pass through to the wrapper object
	return m_pObject->GetArrayPropElementByHandle( lHandle, lFlags, uElement, puFlags, puNumElements, pAddress );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
															 ULONG uBuffSize, LPVOID pData )
{
	// Pass through to the wrapper object
	return m_pObject->SetArrayPropElementByHandle( lHandle, lFlags, uElement, uBuffSize, pData );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::RemoveArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement )
{
	// Pass through to the wrapper object
	return m_pObject->RemoveArrayPropElementByHandle( lHandle, lFlags, uElement );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
															ULONG uNumElements, ULONG uBuffSize,
															ULONG* puNumReturned, ULONG* pulBuffUsed,
															LPVOID pData )
{
	// Pass through to the wrapper object
	return m_pObject->GetArrayPropRangeByHandle( lHandle, lFlags, uStartIndex, uNumElements, uBuffSize,
												puNumReturned, pulBuffUsed, pData );
}


STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
															ULONG uNumElements, ULONG uBuffSize,
															LPVOID pData )
{
	// Pass through to the wrapper object
	return m_pObject->SetArrayPropRangeByHandle( lHandle, lFlags, uStartIndex, uNumElements, uBuffSize, pData );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::RemoveArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
															  ULONG uNumElements )
{
	// Pass through to the wrapper object
	return m_pObject->RemoveArrayPropRangeByHandle( lHandle, lFlags, uStartIndex, uNumElements );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::AppendArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uNumElements,
															ULONG uBuffSize, LPVOID pData )
{
	// Pass through to the wrapper object
	return m_pObject->AppendArrayPropRangeByHandle( lHandle, lFlags, uNumElements, uBuffSize, pData );
}


STDMETHODIMP CWmiObjectWrapper::XWMIObject::ReadProp( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize,
										CIMTYPE *puCimType,	long* plFlavor, BOOL* pfIsNull,
										ULONG* puBuffSizeUsed, LPVOID pUserBuf )
{
	// Pass through to the wrapper object
	return m_pObject->ReadProp( pszPropName, lFlags, uBuffSize, puCimType, plFlavor, pfIsNull,
							puBuffSizeUsed, pUserBuf );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::WriteProp( LPCWSTR pszPropName, long lFlags, ULONG uBufSize,
										   ULONG uNumElements, CIMTYPE uCimType, LPVOID pUserBuf )
{
	// Pass through to the wrapper object
	return m_pObject->WriteProp( pszPropName, lFlags, uBufSize, uNumElements, uCimType, pUserBuf );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
						ULONG *puQualFlavor, ULONG* puBuffSizeUsed,	LPVOID pDestBuf )
{
	// Pass through to the wrapper object
	return m_pObject->GetObjQual( pszQualName, lFlags, uBufSize, puCimType, puQualFlavor, puBuffSizeUsed, pDestBuf );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
						CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
	// Pass through to the wrapper object
	return m_pObject->SetObjQual( pszQualName, lFlags, uBufSize, uNumElements, uCimType, uQualFlavor, 
								pUserBuf );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
						LPVOID pDestBuf )
{
	// Pass through to the wrapper object
	return m_pObject->GetPropQual( pszPropName, pszQualName, lFlags, uBufSize, puCimType, puQualFlavor,
								puBuffSizeUsed, pDestBuf );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
	// Pass through to the wrapper object
	return m_pObject->SetPropQual( pszPropName, pszQualName, lFlags, uBufSize, uNumElements, uCimType, uQualFlavor, 
								pUserBuf );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
						LPVOID pDestBuf )
{
	// Pass through to the wrapper object
	return m_pObject->GetMethodQual( pszMethodName, pszQualName, lFlags, uBufSize, puCimType, puQualFlavor,
								puBuffSizeUsed, pDestBuf );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
	// Pass through to the wrapper object
	return m_pObject->SetMethodQual( pszMethodName, pszQualName, lFlags, uBufSize, uNumElements, uCimType, uQualFlavor, 
								pUserBuf );
}

//
//	_IWmiObject functions
STDMETHODIMP CWmiObjectWrapper::XWMIObject::CopyInstanceData( long lFlags, _IWmiObject* pSourceInstance )
{
	// Pass through to the wrapper object
	return m_pObject->CopyInstanceData( lFlags, pSourceInstance );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::QueryObjectFlags( long lFlags, unsigned __int64 qObjectInfoMask,
			unsigned __int64 *pqObjectInfo )
{
	// Pass through to the wrapper object
	return m_pObject->QueryObjectFlags( lFlags, qObjectInfoMask, pqObjectInfo );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::SetObjectFlags( long lFlags, unsigned __int64 qObjectInfoOnFlags,
							unsigned __int64 qObjectInfoOffFlags )
{
	// Pass through to the wrapper object
	return m_pObject->SetObjectFlags( lFlags, qObjectInfoOnFlags, qObjectInfoOffFlags );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::QueryPropertyFlags( long lFlags, LPCWSTR pszPropertyName,
													unsigned __int64 qPropertyInfoMask,
													unsigned __int64 *pqPropertyInfo )
{
	// Pass through to the wrapper object
	return m_pObject->QueryPropertyFlags( lFlags, pszPropertyName, qPropertyInfoMask, pqPropertyInfo );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::CloneEx( long lFlags, _IWmiObject* pDestObject )
{
	// Pass through to the wrapper object
	return m_pObject->CloneEx( lFlags, pDestObject );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::IsParentClass( long lFlags, _IWmiObject* pClass )
{
	// Pass through to the wrapper object
	return m_pObject->IsParentClass( lFlags, pClass );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::CompareDerivedMostClass( long lFlags, _IWmiObject* pClass )
{
	// Pass through to the wrapper object
	return m_pObject->CompareDerivedMostClass( lFlags, pClass );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::MergeAmended( long lFlags, _IWmiObject* pAmendedClass )
{
	// Pass through to the wrapper object
	return m_pObject->MergeAmended( lFlags, pAmendedClass );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetDerivation( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
										ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer )
{
	// Pass through to the wrapper object
	return m_pObject->GetDerivation( lFlags, uBufferSize, puNumAntecedents, puBuffSizeUsed, pwstrUserBuffer );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::_GetCoreInfo( long lFlags, void** ppvData )
{
	// Pass through to the wrapper object
	return m_pObject->_GetCoreInfo( lFlags, ppvData );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetClassSubset( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass )
{
	// Pass through to the wrapper object
	return m_pObject->GetClassSubset( dwNumNames, pPropNames, pNewClass );
}

STDMETHODIMP CWmiObjectWrapper::XWMIObject::MakeSubsetInst( _IWmiObject *pInstance, _IWmiObject** pNewInstance )
{
	// Pass through to the wrapper object
	return m_pObject->MakeSubsetInst( pInstance, pNewInstance );
}

// Returns a BLOB of memory containing minimal data (local)
STDMETHODIMP CWmiObjectWrapper::XWMIObject::Unmerge( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID ppObj )
{
	// Pass through to the wrapper object
	return m_pObject->Unmerge( lFlags, uBuffSize, puBuffSizeUsed, ppObj );
}

// Returns a BLOB of memory containing minimal data (local)
STDMETHODIMP CWmiObjectWrapper::XWMIObject::Merge( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj )
{
	// Pass through to the wrapper object
	return m_pObject->Merge( lFlags, uBuffSize, pbData, ppNewObj );
}

// Returns a BLOB of memory containing minimal data (local)
STDMETHODIMP CWmiObjectWrapper::XWMIObject::ReconcileWith( long lFlags, _IWmiObject* pNewObj )
{
	// Pass through to the wrapper object
	return m_pObject->ReconcileWith( lFlags, pNewObj );
}

// Returns the name of the class where the keys were defined
STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetKeyOrigin( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwzClassName )
{
	// Pass through to the wrapper object
	return m_pObject->GetKeyOrigin( lFlags, dwNumChars, pdwNumUsed, pwzClassName );
}

// Returns the name of the class where the keys were defined
STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetKeyString( long lFlags, BSTR* ppwszKeyString )
{
	// Pass through to the wrapper object
	return m_pObject->GetKeyString( lFlags, ppwszKeyString );
}

// Returns the name of the class where the keys were defined
HRESULT CWmiObjectWrapper::XWMIObject::GetNormalizedPath( long lFlags, BSTR* ppstrPath )
{
	// Pass through to the wrapper object
	return m_pObject->GetNormalizedPath( lFlags, ppstrPath );
}

// Upgrades class and instance objects
STDMETHODIMP CWmiObjectWrapper::XWMIObject::Upgrade( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild )
{
	// Pass through to the wrapper object
	return m_pObject->Upgrade( pNewParentClass, lFlags, ppNewChild );
}

// Updates derived class object using the safe/force mode logic
STDMETHODIMP CWmiObjectWrapper::XWMIObject::Update( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass )
{
	// Pass through to the wrapper object
	return m_pObject->Update( pOldChildClass, lFlags, ppNewChildClass );
}

// Allows special filtering when enumerating properties outside the
// bounds of those allowed via BeginEnumeration().
STDMETHODIMP CWmiObjectWrapper::XWMIObject::BeginEnumerationEx( long lFlags, long lExtFlags )
{
	// Pass through to the wrapper object
	return m_pObject->BeginEnumerationEx( lFlags, lExtFlags );
}

// Validate Object Blob.
STDMETHODIMP CWmiObjectWrapper::XWMIObject::ValidateObject( long lFlags )
{
	// Pass through to the wrapper object
	return m_pObject->ValidateObject( lFlags );
}

// Validate Object Blob.
STDMETHODIMP CWmiObjectWrapper::XWMIObject::GetParentClassFromBlob( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass )
{
	// Pass through to the wrapper object
	return m_pObject->GetParentClassFromBlob( lFlags, uBuffSize, pbData, pbstrParentClass );
}

/* IMarshal Pass-thrus */
STDMETHODIMP CWmiObjectWrapper::XObjectMarshal::GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
	// Pass through to the wrapper object
	return m_pObject->GetUnmarshalClass( riid, pv, dwDestContext, pvReserved, mshlFlags, pClsid );
}

STDMETHODIMP CWmiObjectWrapper::XObjectMarshal::GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
	// Pass through to the wrapper object
	return m_pObject->GetMarshalSizeMax( riid, pv, dwDestContext, pvReserved, mshlFlags, plSize );
}

STDMETHODIMP CWmiObjectWrapper::XObjectMarshal::MarshalInterface(IStream* pStream, REFIID riid, void* pv,
													DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
	// Pass through to the wrapper object
	return m_pObject->MarshalInterface( pStream, riid, pv, dwDestContext, pvReserved, mshlFlags );
}

STDMETHODIMP CWmiObjectWrapper::XObjectMarshal::UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv)
{
	// Pass through to the wrapper object
	return m_pObject->UnmarshalInterface( pStream, riid, ppv );
}

STDMETHODIMP CWmiObjectWrapper::XObjectMarshal::ReleaseMarshalData(IStream* pStream)
{
	// Pass through to the wrapper object
	return m_pObject->ReleaseMarshalData( pStream );
}

STDMETHODIMP CWmiObjectWrapper::XObjectMarshal::DisconnectObject(DWORD dwReserved)
{
	// Pass through to the wrapper object
	return m_pObject->DisconnectObject( dwReserved );
}

/* IErrorInfo Pass-thrus */
STDMETHODIMP CWmiObjectWrapper::XErrorInfo::GetDescription(BSTR* pstrDescription)
{
	// Pass through to the wrapper object
	return m_pObject->GetDescription( pstrDescription );
}

STDMETHODIMP CWmiObjectWrapper::XErrorInfo::GetGUID(GUID* pguid)
{
	// Pass through to the wrapper object
	return m_pObject->GetGUID( pguid );
}

STDMETHODIMP CWmiObjectWrapper::XErrorInfo::GetHelpContext(DWORD* pdwHelpContext)
{
	// Pass through to the wrapper object
	return m_pObject->GetHelpContext( pdwHelpContext );
}

STDMETHODIMP CWmiObjectWrapper::XErrorInfo::GetHelpFile(BSTR* pstrHelpFile)
{
	// Pass through to the wrapper object
	return m_pObject->GetHelpFile( pstrHelpFile );
}

STDMETHODIMP CWmiObjectWrapper::XErrorInfo::GetSource(BSTR* pstrSource)
{
	// Pass through to the wrapper object
	return m_pObject->GetSource( pstrSource );
}


// * IUmiPropList functions */
/*
// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp )
{
	return m_pObject->Put( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp )
{
	return m_pObject->Get( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	return m_pObject->GetAt( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp )
{
	return m_pObject->GetAs( pszName, uFlags, uCoercionType, pProp );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::FreeMemory( ULONG uReserved, LPVOID pMem )
{
	return m_pObject->FreeMemory( uReserved, pMem );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::Delete( LPCWSTR pszName, ULONG uFlags )
{
	return m_pObject->Delete( pszName, uFlags );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps )
{
	return m_pObject->GetProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps )
{
	return m_pObject->PutProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::XUmiPropList::PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	return m_pObject->PutFrom( pszName, uFlags, uBufferLength, pExistingMem );
}
*/

// This is the actual implementation

/* IWbemClassObject methods */

HRESULT CWmiObjectWrapper::GetQualifierSet(IWbemQualifierSet** pQualifierSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetQualifierSet( pQualifierSet );
}

HRESULT CWmiObjectWrapper::Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
									long* plFlavor)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Get( wszName, lFlags, pVal, pctType, plFlavor );
}

HRESULT CWmiObjectWrapper::Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Put( wszName, lFlags, pVal, ctType );
}

HRESULT CWmiObjectWrapper::Delete(LPCWSTR wszName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Delete( wszName );
}

HRESULT CWmiObjectWrapper::GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
											SAFEARRAY** pNames)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetNames( wszName, lFlags, pVal, pNames );
}

HRESULT CWmiObjectWrapper::BeginEnumeration(long lEnumFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->BeginEnumeration( lEnumFlags );
}

HRESULT CWmiObjectWrapper::Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                long* plFlavor)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Next( lFlags, pName, pVal, pctType, plFlavor );
}

HRESULT CWmiObjectWrapper::EndEnumeration()
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->EndEnumeration();
}

HRESULT CWmiObjectWrapper::GetPropertyQualifierSet(LPCWSTR wszProperty,
                                   IWbemQualifierSet** pQualifierSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetPropertyQualifierSet( wszProperty, pQualifierSet );
}

HRESULT CWmiObjectWrapper::Clone(IWbemClassObject** pCopy)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	
	HRESULT hr = m_pObj->Clone( pCopy );

	if ( SUCCEEDED( hr ) )
	{
		// This will wrap the object then return us an IWbemClassObject Interface pointer
		hr = WrapReturnedObject( (CWbemObject*) *pCopy, TRUE, IID_IWbemClassObject, (void**) pCopy );

		// Cleanup the object if we failed
		if ( FAILED( hr ) )
		{
			(*pCopy)->Release();
		}

	}	// IF the clone succeeded

	return hr;
}

HRESULT CWmiObjectWrapper::GetObjectText(long lFlags, BSTR* pMofSyntax)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetObjectText( lFlags, pMofSyntax );
}

HRESULT CWmiObjectWrapper::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->CompareTo( lFlags, pCompareTo );
}

HRESULT CWmiObjectWrapper::GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetPropertyOrigin( wszProperty, pstrClassName );
}

HRESULT CWmiObjectWrapper::InheritsFrom(LPCWSTR wszClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->InheritsFrom( wszClassName );
}

HRESULT CWmiObjectWrapper::SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	HRESULT hr = m_pObj->SpawnDerivedClass( lFlags, ppNewClass );

	if ( SUCCEEDED( hr ) )
	{
		// This will wrap the object then return us an IWbemClassObject Interface pointer
		hr = WrapReturnedObject( (CWbemObject*) *ppNewClass, FALSE, IID_IWbemClassObject, (void**) ppNewClass );

		// Cleanup the object if we failed
		if ( FAILED( hr ) )
		{
			(*ppNewClass)->Release();
		}

	}	// IF the spawn succeeded

	return hr;

}

HRESULT CWmiObjectWrapper::SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	HRESULT hr = m_pObj->SpawnInstance( lFlags, ppNewInstance );

	if ( SUCCEEDED( hr ) )
	{
		// This will wrap the object then return us an IWbemClassObject Interface pointer
		hr = WrapReturnedObject( (CWbemObject*) *ppNewInstance, FALSE, IID_IWbemClassObject, (void**) ppNewInstance );

		// Cleanup the object if we failed
		if ( FAILED( hr ) )
		{
			(*ppNewInstance)->Release();
		}

	}	// IF the spawn succeeded

	return hr;
}

HRESULT CWmiObjectWrapper::GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                        IWbemClassObject** ppOutSig)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetMethod( wszName, lFlags, ppInSig, ppOutSig );
}

HRESULT CWmiObjectWrapper::PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                        IWbemClassObject* pOutSig)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->PutMethod( wszName, lFlags, pInSig, pOutSig );
}

HRESULT CWmiObjectWrapper::DeleteMethod(LPCWSTR wszName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->DeleteMethod( wszName );
}

HRESULT CWmiObjectWrapper::BeginMethodEnumeration(long lFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->BeginMethodEnumeration( lFlags );
}

HRESULT CWmiObjectWrapper::NextMethod(long lFlags, BSTR* pstrName, 
                   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig)
				   {
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->NextMethod( lFlags, pstrName, ppInSig, ppOutSig );
}

HRESULT CWmiObjectWrapper::EndMethodEnumeration()
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->EndMethodEnumeration();
}

HRESULT CWmiObjectWrapper::GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetMethodQualifierSet( wszName, ppSet );
}

HRESULT CWmiObjectWrapper::GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetMethodOrigin( wszMethodName, pstrClassName );
}

// IWbemObjectAccess

HRESULT CWmiObjectWrapper::GetPropertyHandle(LPCWSTR wszPropertyName, CIMTYPE* pct, long *plHandle)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetPropertyHandle( wszPropertyName, pct, plHandle );
}

HRESULT CWmiObjectWrapper::WritePropertyValue(long lHandle, long lNumBytes, const byte *pData)
{
	// These methods are documented not Threadsafe
	return m_pObj->WritePropertyValue( lHandle, lNumBytes, pData );
}

HRESULT CWmiObjectWrapper::ReadPropertyValue(long lHandle, long lBufferSize, long *plNumBytes, byte *pData)
{
	// These methods are documented not Threadsafe
	return m_pObj->ReadPropertyValue( lHandle, lBufferSize, plNumBytes, pData );
}


HRESULT CWmiObjectWrapper::ReadDWORD(long lHandle, DWORD *pdw)
{
	// These methods are documented not Threadsafe
	return m_pObj->ReadDWORD( lHandle, pdw );
}

HRESULT CWmiObjectWrapper::WriteDWORD(long lHandle, DWORD dw)
{
	// These methods are documented not Threadsafe
	return m_pObj->WriteDWORD( lHandle, dw );
}

HRESULT CWmiObjectWrapper::ReadQWORD(long lHandle, unsigned __int64 *pqw)
{
	// These methods are documented not Threadsafe
	return m_pObj->ReadQWORD( lHandle, pqw );
}

HRESULT CWmiObjectWrapper::WriteQWORD(long lHandle, unsigned __int64 qw)
{
	// These methods are documented not Threadsafe
	return m_pObj->WriteQWORD( lHandle, qw );
}

HRESULT CWmiObjectWrapper::GetPropertyInfoByHandle(long lHandle, BSTR* pstrName, CIMTYPE* pct)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetPropertyInfoByHandle( lHandle, pstrName, pct );
}

HRESULT CWmiObjectWrapper::Lock(long lFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us

    // Since the flags really don't do anything, we'll require 0L on this call.
    m_Lock.Lock();
	return m_pObj->Lock( lFlags );
}

HRESULT CWmiObjectWrapper::Unlock(long lFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us

	// Exact reverse order of the above
	HRESULT hr = m_pObj->Unlock( lFlags );
    m_Lock.Unlock();

	return hr;
}

// _IWmiObject object parts methods
// =================================

HRESULT CWmiObjectWrapper::QueryPartInfo( DWORD *pdwResult )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->QueryPartInfo( pdwResult );
}

HRESULT CWmiObjectWrapper::SetObjectMemory( LPVOID pMem, DWORD dwMemSize )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetObjectMemory( pMem, dwMemSize );
}

HRESULT CWmiObjectWrapper::GetObjectMemory( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetObjectMemory( pDestination, dwDestBufSize, pdwUsed );
}

HRESULT CWmiObjectWrapper::SetObjectParts( LPVOID pMem, DWORD dwMemSize, DWORD dwParts )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetObjectParts( pMem, dwMemSize, dwParts );
}

HRESULT CWmiObjectWrapper::GetObjectParts( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetObjectParts( pDestination, dwDestBufSize, dwParts, pdwUsed );
}

HRESULT CWmiObjectWrapper::StripClassPart()
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->StripClassPart();
}

HRESULT CWmiObjectWrapper::IsObjectInstance()
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->IsObjectInstance();
}

HRESULT CWmiObjectWrapper::GetClassPart( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetClassPart( pDestination, dwDestBufSize, pdwUsed );
}

HRESULT CWmiObjectWrapper::SetClassPart( LPVOID pClassPart, DWORD dwSize )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetClassPart( pClassPart, dwSize );
}

HRESULT CWmiObjectWrapper::MergeClassPart( IWbemClassObject *pClassPart )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->MergeClassPart( pClassPart );
}

HRESULT CWmiObjectWrapper::SetDecoration( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetDecoration( pwcsServer, pwcsNamespace );
}

HRESULT CWmiObjectWrapper::RemoveDecoration( void )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->RemoveDecoration();
}

HRESULT CWmiObjectWrapper::CompareClassParts( IWbemClassObject* pObj, long lFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->CompareClassParts( pObj, lFlags );
}

HRESULT CWmiObjectWrapper::ClearWriteOnlyProperties( void )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->ClearWriteOnlyProperties();
}

//
//	_IWmiObjectAccessEx functions
HRESULT CWmiObjectWrapper::GetPropertyHandleEx( LPCWSTR pszPropName, long lFlags, CIMTYPE* puCimType, long* plHandle )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetPropertyHandleEx( pszPropName, lFlags, puCimType, plHandle );
}

HRESULT CWmiObjectWrapper::SetPropByHandle( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData )
{
	// Documented as not thread safe
	return m_pObj->SetPropByHandle( lHandle, lFlags, uDataSize, pvData );
}

HRESULT CWmiObjectWrapper::GetPropAddrByHandle( long lHandle, long lFlags, ULONG* puFlags,
													 LPVOID *pAddress )
{
	// Documented as not thread safe
	return m_pObj->GetPropAddrByHandle( lHandle, lFlags, puFlags, pAddress );
}

HRESULT CWmiObjectWrapper::GetArrayPropInfoByHandle( long lHandle, long lFlags, BSTR* pstrName,
															CIMTYPE* pct, ULONG* puNumElements )
{
	// Documented as not thread safe
	return m_pObj->GetArrayPropInfoByHandle( lHandle, lFlags, pstrName, pct, puNumElements );
}

HRESULT CWmiObjectWrapper::GetArrayPropAddrByHandle( long lHandle, long lFlags, ULONG* puNumElements,
														  LPVOID *pAddress )
{
	// Documented as not thread safe
	return m_pObj->GetArrayPropAddrByHandle( lHandle, lFlags, puNumElements, pAddress );
}

HRESULT CWmiObjectWrapper::GetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
															 ULONG* puFlags, ULONG* puNumElements,
															 LPVOID *pAddress )
{
	// Documented as not thread safe
	return m_pObj->GetArrayPropElementByHandle( lHandle, lFlags, uElement, puFlags, puNumElements, pAddress );
}

HRESULT CWmiObjectWrapper::SetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
															 ULONG uBuffSize, LPVOID pData )
{
	// Documented as not thread safe
	return m_pObj->SetArrayPropElementByHandle( lHandle, lFlags, uElement, uBuffSize, pData );
}

HRESULT CWmiObjectWrapper::RemoveArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement )
{
	// Documented as not thread safe
	return m_pObj->RemoveArrayPropElementByHandle( lHandle, lFlags, uElement );
}

HRESULT CWmiObjectWrapper::GetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
															ULONG uNumElements, ULONG uBuffSize,
															ULONG* puNumReturned, ULONG* pulBuffUsed,
															LPVOID pData )
{
	// Documented as not thread safe
	return m_pObj->GetArrayPropRangeByHandle( lHandle, lFlags, uStartIndex, uNumElements, uBuffSize,
												puNumReturned, pulBuffUsed, pData );
}


HRESULT CWmiObjectWrapper::SetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
															ULONG uNumElements, ULONG uBuffSize,
															LPVOID pData )
{
	// Documented as not thread safe
	return m_pObj->SetArrayPropRangeByHandle( lHandle, lFlags, uStartIndex, uNumElements, uBuffSize, pData );
}

HRESULT CWmiObjectWrapper::RemoveArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
															  ULONG uNumElements )
{
	// Documented as not thread safe
	return m_pObj->RemoveArrayPropRangeByHandle( lHandle, lFlags, uStartIndex, uNumElements );
}

HRESULT CWmiObjectWrapper::AppendArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uNumElements,
															ULONG uBuffSize, LPVOID pData )
{
	// Documented as not thread safe
	return m_pObj->AppendArrayPropRangeByHandle( lHandle, lFlags, uNumElements, uBuffSize, pData );
}


HRESULT CWmiObjectWrapper::ReadProp( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize,
										CIMTYPE *puCimType,	long* plFlavor, BOOL* pfIsNull,
										ULONG* puBuffSizeUsed, LPVOID pUserBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->ReadProp( pszPropName, lFlags, uBuffSize, puCimType, plFlavor, pfIsNull,
							puBuffSizeUsed, pUserBuf );
}

HRESULT CWmiObjectWrapper::WriteProp( LPCWSTR pszPropName, long lFlags, ULONG uBufSize,
										   ULONG uNumElements, CIMTYPE uCimType, LPVOID pUserBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->WriteProp( pszPropName, lFlags, uBufSize, uNumElements, uCimType, pUserBuf );
}

HRESULT CWmiObjectWrapper::GetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
						ULONG *puQualFlavor, ULONG* puBuffSizeUsed,	LPVOID pDestBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetObjQual( pszQualName, lFlags, uBufSize, puCimType, puQualFlavor, puBuffSizeUsed, pDestBuf );
}

HRESULT CWmiObjectWrapper::SetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
						CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetObjQual( pszQualName, lFlags, uBufSize, uNumElements, uCimType, uQualFlavor, 
								pUserBuf );
}

HRESULT CWmiObjectWrapper::GetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
						LPVOID pDestBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetPropQual( pszPropName, pszQualName, lFlags, uBufSize, puCimType, puQualFlavor,
								puBuffSizeUsed, pDestBuf );
}

HRESULT CWmiObjectWrapper::SetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetPropQual( pszPropName, pszQualName, lFlags, uBufSize, uNumElements, uCimType, uQualFlavor, 
								pUserBuf );
}

HRESULT CWmiObjectWrapper::GetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
						LPVOID pDestBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetMethodQual( pszMethodName, pszQualName, lFlags, uBufSize, puCimType, puQualFlavor,
								puBuffSizeUsed, pDestBuf );
}

HRESULT CWmiObjectWrapper::SetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
						ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetMethodQual( pszMethodName, pszQualName, lFlags, uBufSize, uNumElements, uCimType, uQualFlavor, 
								pUserBuf );
}


//
//	_IWmiObject functions
HRESULT CWmiObjectWrapper::CopyInstanceData( long lFlags, _IWmiObject* pSourceInstance )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->CopyInstanceData( lFlags, pSourceInstance );
}

HRESULT CWmiObjectWrapper::QueryObjectFlags( long lFlags, unsigned __int64 qObjectInfoMask,
			unsigned __int64 *pqObjectInfo )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->QueryObjectFlags( lFlags, qObjectInfoMask, pqObjectInfo );
}

HRESULT CWmiObjectWrapper::SetObjectFlags( long lFlags, unsigned __int64 qObjectInfoOnFlags,
							unsigned __int64 qObjectInfoOffFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SetObjectFlags( lFlags, qObjectInfoOnFlags, qObjectInfoOffFlags );
}

HRESULT CWmiObjectWrapper::QueryPropertyFlags( long lFlags, LPCWSTR pszPropertyName,
													unsigned __int64 qPropertyInfoMask,
													unsigned __int64 *pqPropertyInfo )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->QueryPropertyFlags( lFlags, pszPropertyName, qPropertyInfoMask, pqPropertyInfo );
}

HRESULT CWmiObjectWrapper::CloneEx( long lFlags, _IWmiObject* pDestObject )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->CloneEx( lFlags, pDestObject );
}

HRESULT CWmiObjectWrapper::IsParentClass( long lFlags, _IWmiObject* pClass )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->IsParentClass( lFlags, pClass );
}

HRESULT CWmiObjectWrapper::CompareDerivedMostClass( long lFlags, _IWmiObject* pClass )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->CompareDerivedMostClass( lFlags, pClass );
}

HRESULT CWmiObjectWrapper::MergeAmended( long lFlags, _IWmiObject* pAmendedClass )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->MergeAmended( lFlags, pAmendedClass );
}

HRESULT CWmiObjectWrapper::GetDerivation( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
										ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetDerivation( lFlags, uBufferSize, puNumAntecedents, puBuffSizeUsed, pwstrUserBuffer );
}

// Returns CWbemObject - allows for quick discovery of the real CWbemObject
// in case we've been wrapped.
HRESULT CWmiObjectWrapper::_GetCoreInfo( long lFlags, void** ppvData )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);

	// AddRef the object before returning it so we're in line with the rules of COM.
	m_pObj->AddRef();
	*ppvData = (void*) m_pObj;

	return WBEM_S_NO_ERROR;
}

HRESULT CWmiObjectWrapper::GetClassSubset( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetClassSubset( dwNumNames, pPropNames, pNewClass );
}

HRESULT CWmiObjectWrapper::MakeSubsetInst( _IWmiObject *pInstance, _IWmiObject** pNewInstance )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->MakeSubsetInst( pInstance, pNewInstance );
}

// Returns a BLOB of memory containing minimal data (local)
HRESULT CWmiObjectWrapper::Unmerge( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID ppObj )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Unmerge( lFlags, uBuffSize, puBuffSizeUsed, ppObj );
}

// Returns a BLOB of memory containing minimal data (local)
HRESULT CWmiObjectWrapper::Merge( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Merge( lFlags, uBuffSize, pbData, ppNewObj );
}

// Returns a BLOB of memory containing minimal data (local)
HRESULT CWmiObjectWrapper::ReconcileWith( long lFlags, _IWmiObject* pNewObj )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->ReconcileWith( lFlags, pNewObj );
}

// Returns the name of the class where the keys were defined
HRESULT CWmiObjectWrapper::GetKeyOrigin( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwzClassName )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetKeyOrigin( lFlags, dwNumChars, pdwNumUsed, pwzClassName );
}

// Validates underlying object blob
HRESULT CWmiObjectWrapper::ValidateObject( long lFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->ValidateObject( lFlags );
}

// Validate Object Blob.
HRESULT CWmiObjectWrapper::GetParentClassFromBlob( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetParentClassFromBlob( lFlags, uBuffSize, pbData, pbstrParentClass );
}

/* IMarshal Methods */

HRESULT CWmiObjectWrapper::GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetUnmarshalClass( riid, pv, dwDestContext, pvReserved, mshlFlags, pClsid );
}

HRESULT CWmiObjectWrapper::GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
													void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetMarshalSizeMax( riid, pv, dwDestContext, pvReserved, mshlFlags, plSize );
}

HRESULT CWmiObjectWrapper::MarshalInterface(IStream* pStream, REFIID riid, void* pv,
													DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->MarshalInterface( pStream, riid, pv, dwDestContext, pvReserved, mshlFlags );
}

HRESULT CWmiObjectWrapper::UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->UnmarshalInterface( pStream, riid, ppv );
}

HRESULT CWmiObjectWrapper::ReleaseMarshalData(IStream* pStream)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->ReleaseMarshalData( pStream );
}

HRESULT CWmiObjectWrapper::DisconnectObject(DWORD dwReserved)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->DisconnectObject( dwReserved );
}

// * IUmiPropList functions */
/*
// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Put( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Get( pszName, uFlags, pProp );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetAt( pszName, uFlags, uBufferLength, pExistingMem );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetAs( pszName, uFlags, uCoercionType, pProp );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::FreeMemory( ULONG uReserved, LPVOID pMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->FreeMemory( uReserved, pMem );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::Delete( LPCWSTR pszName, ULONG uFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Delete( pszName, uFlags );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->PutProps( pszNames, uNameCount, uFlags, pProps );
}

// See UMI.IDL for Documentation
HRESULT CWmiObjectWrapper::PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->PutFrom( pszName, uFlags, uBufferLength, pExistingMem );
}
*/
// Returns the name of the class where the keys were defined
HRESULT CWmiObjectWrapper::GetKeyString( long lFlags, BSTR* ppwszKeyString )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetKeyString( lFlags, ppwszKeyString );
}

// Returns the name of the class where the keys were defined
HRESULT CWmiObjectWrapper::GetNormalizedPath( long lFlags, BSTR* ppstrPath )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetNormalizedPath( lFlags, ppstrPath );
}

// Upgrades class and instance objects
HRESULT CWmiObjectWrapper::Upgrade( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Upgrade( pNewParentClass, lFlags, ppNewChild );
}

// Updates derived class object using the safe/force mode logic
HRESULT CWmiObjectWrapper::Update( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->Update( pOldChildClass, lFlags, ppNewChildClass );
}

// Allows special filtering when enumerating properties outside the
// bounds of those allowed via BeginEnumeration().
HRESULT CWmiObjectWrapper::BeginEnumerationEx( long lFlags, long lExtFlags )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->BeginEnumerationEx( lFlags, lExtFlags );
}

// Returns a VARTYPE from a CIMTYPE
HRESULT CWmiObjectWrapper::CIMTYPEToVARTYPE( CIMTYPE ct, VARTYPE* pvt )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->CIMTYPEToVARTYPE( ct, pvt );
}

HRESULT CWmiObjectWrapper::SpawnKeyedInstance( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst )
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->SpawnKeyedInstance( lFlags, pwszPath, ppInst );
}

/* IErrorInfo Implementation */
HRESULT CWmiObjectWrapper::GetDescription(BSTR* pstrDescription)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetDescription( pstrDescription );
}

HRESULT CWmiObjectWrapper::GetGUID(GUID* pguid)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetGUID( pguid );
}

HRESULT CWmiObjectWrapper::GetHelpContext(DWORD* pdwHelpContext)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetHelpContext( pdwHelpContext );
}

HRESULT CWmiObjectWrapper::GetHelpFile(BSTR* pstrHelpFile)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetHelpFile( pstrHelpFile );
}

HRESULT CWmiObjectWrapper::GetSource(BSTR* pstrSource)
{
	// Do this so the wrapped object doesn't get ripped out from underneath us
	CLock	lock(this);
	return m_pObj->GetSource( pstrSource );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmitxtsc.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMITXTSC.H

Abstract:

  CWmiTextSource Definition.

  Class to encapsulate Text Source Encoder/Decoder Dlls

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _WMITXTSRC_H_
#define _WMITXTSRC_H_

#include "corepol.h"
#include "arrtempl.h"
#include <arena.h>

// Our very own subkey
#define WBEM_REG_WBEM_TEXTSRC __TEXT("Software\\Microsoft\\WBEM\\TextSource")
#define WBEM_REG_WBEM_TEXTSRCDLL __TEXT("TextSourceDll")

// Header definitions for Open/Close/ObjectToText/TextToObject functions
typedef HRESULT (WMIOBJTEXTSRC_OPEN) ( long, ULONG );
typedef HRESULT (WMIOBJTEXTSRC_CLOSE) ( long, ULONG );
typedef HRESULT (WMIOBJTEXTSRC_OBJECTTOTEXT) ( long, ULONG, void*, void*, BSTR* );
typedef HRESULT (WMIOBJTEXTSRC_TEXTTOOBJECT) ( long, ULONG, void*, BSTR, void** );

typedef WMIOBJTEXTSRC_OPEN*			PWMIOBJTEXTSRC_OPEN;
typedef WMIOBJTEXTSRC_CLOSE*		PWMIOBJTEXTSRC_CLOSE;
typedef WMIOBJTEXTSRC_OBJECTTOTEXT*	PWMIOBJTEXTSRC_OBJECTTOTEXT;
typedef WMIOBJTEXTSRC_TEXTTOOBJECT*	PWMIOBJTEXTSRC_TEXTTOOBJECT;

// A conveniently invalid value
#define WMITEXTSC_INVALIDID			0xFFFFFFFF

//***************************************************************************
//
//  class CWmiTextSource
//
//	Maintains information regarding the text source DLLs we will be
//	loading and unloading.	
//
//***************************************************************************
class CWmiTextSource
{
protected:
	// We want this to be refcounted
	long							m_lRefCount;
	
	// Our id and other state variables
	ULONG							m_ulId;
	bool							m_fOpened;

	// The DLL handle
	HINSTANCE						m_hDll;

	// These are the function definitions
	PWMIOBJTEXTSRC_OPEN				m_pOpenTextSrc;
	PWMIOBJTEXTSRC_CLOSE			m_pCloseTextSrc;
	PWMIOBJTEXTSRC_OBJECTTOTEXT		m_pObjectToText;
	PWMIOBJTEXTSRC_TEXTTOOBJECT		m_pTextToObject;

public:

	// Constructor/Destructor
	CWmiTextSource();
	~CWmiTextSource();

	//AddRef/Release
	ULONG	AddRef( void );
	ULONG	Release( void );

	// Initialization helper
	HRESULT	Init( ULONG lId );

	// Pass through to the actual dll
	HRESULT OpenTextSource( long lFlags );
	HRESULT CloseTextSource( long lFlags );
	HRESULT ObjectToText( long lFlags, IWbemContext* pCtx, IWbemClassObject* pObj, BSTR* pbText );
	HRESULT TextToObject( long lFlags, IWbemContext* pCtx, BSTR pText, IWbemClassObject** ppObj );

	ULONG GetId( void )	{ return m_ulId; }
};


// Workaround for import/export issues
class COREPROX_POLARITY CWmiTextSourceArray : public CRefedPointerArray<CWmiTextSource>
{
public:
	CWmiTextSourceArray() {};
	~CWmiTextSourceArray() {};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wrapobj.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WRAPOBJ.H

Abstract:

  CWmiFreeForObject Definition.

  Standard definition for _IWmiFreeFormObject.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _WRAPOBJ_H_
#define _WRAPOBJ_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>

#define FREEFORM_OBJ_EXTRAMEM	4096

//***************************************************************************
//
//  class CWmiObjectWrapper
//
//  Implementation of _IWmiFreeFormObject Interface
//
//***************************************************************************

class COREPROX_POLARITY CWmiObjectWrapper : public CUnk
{
protected:
	CWbemObject*		m_pObj;
    SHARED_LOCK_DATA	m_LockData;
    CSharedLock			m_Lock;

public:

    CWmiObjectWrapper(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CWmiObjectWrapper(); 

    class COREPROX_POLARITY XWMIObject : public CImpl<_IWmiObject, CWmiObjectWrapper>
    {
    public:
        XWMIObject(CWmiObjectWrapper* pObject) : 
            CImpl<_IWmiObject, CWmiObjectWrapper>(pObject)
        {}

		/* IWbemClassObject methods */
		STDMETHOD(GetQualifierSet)(IWbemQualifierSet** pQualifierSet);
		STDMETHOD(Get)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
			long* plFlavor);

		STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
		STDMETHOD(Delete)(LPCWSTR wszName);
		STDMETHOD(GetNames)(LPCWSTR wszName, long lFlags, VARIANT* pVal,
							SAFEARRAY** pNames);
		STDMETHOD(BeginEnumeration)(long lEnumFlags);

		STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
						long* plFlavor);

		STDMETHOD(EndEnumeration)();

		STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty,
										   IWbemQualifierSet** pQualifierSet);
		STDMETHOD(Clone)(IWbemClassObject** pCopy);
		STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax);

		STDMETHOD(CompareTo)(long lFlags, IWbemClassObject* pCompareTo);
		STDMETHOD(GetPropertyOrigin)(LPCWSTR wszProperty, BSTR* pstrClassName);
		STDMETHOD(InheritsFrom)(LPCWSTR wszClassName);

		STDMETHOD(SpawnDerivedClass)(long lFlags, IWbemClassObject** ppNewClass);
		STDMETHOD(SpawnInstance)(long lFlags, IWbemClassObject** ppNewInstance);
		STDMETHOD(GetMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
								IWbemClassObject** ppOutSig);
		STDMETHOD(PutMethod)(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
								IWbemClassObject* pOutSig);
		STDMETHOD(DeleteMethod)(LPCWSTR wszName);
		STDMETHOD(BeginMethodEnumeration)(long lFlags);
		STDMETHOD(NextMethod)(long lFlags, BSTR* pstrName, 
						   IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
		STDMETHOD(EndMethodEnumeration)();
		STDMETHOD(GetMethodQualifierSet)(LPCWSTR wszName, IWbemQualifierSet** ppSet);
		STDMETHOD(GetMethodOrigin)(LPCWSTR wszMethodName, BSTR* pstrClassName);

		// IWbemObjectAccess

		STDMETHOD(GetPropertyHandle)(LPCWSTR wszPropertyName, CIMTYPE* pct,
			long *plHandle);

		STDMETHOD(WritePropertyValue)(long lHandle, long lNumBytes,
					const byte *pData);
		STDMETHOD(ReadPropertyValue)(long lHandle, long lBufferSize,
			long *plNumBytes, byte *pData);

		STDMETHOD(ReadDWORD)(long lHandle, DWORD *pdw);
		STDMETHOD(WriteDWORD)(long lHandle, DWORD dw);
		STDMETHOD(ReadQWORD)(long lHandle, unsigned __int64 *pqw);
		STDMETHOD(WriteQWORD)(long lHandle, unsigned __int64 qw);

		STDMETHOD(GetPropertyInfoByHandle)(long lHandle, BSTR* pstrName,
				 CIMTYPE* pct);

		STDMETHOD(Lock)(long lFlags);
		STDMETHOD(Unlock)(long lFlags);

		// _IWmiObject object parts methods
		// =================================

		STDMETHOD(QueryPartInfo)( DWORD *pdwResult );

		STDMETHOD(SetObjectMemory)( LPVOID pMem, DWORD dwMemSize );
		STDMETHOD(GetObjectMemory)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
		STDMETHOD(SetObjectParts)( LPVOID pMem, DWORD dwMemSize, DWORD dwParts );
		STDMETHOD(GetObjectParts)( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed );

		STDMETHOD(StripClassPart)();
		STDMETHOD(IsObjectInstance)();

		STDMETHOD(GetClassPart)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
		STDMETHOD(SetClassPart)( LPVOID pClassPart, DWORD dwSize );
		STDMETHOD(MergeClassPart)( IWbemClassObject *pClassPart );

		STDMETHOD(SetDecoration)( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace );
		STDMETHOD(RemoveDecoration)( void );

		STDMETHOD(CompareClassParts)( IWbemClassObject* pObj, long lFlags );

		STDMETHOD(ClearWriteOnlyProperties)( void );

		// _IWmiObjectAccessEx methods
		// =================================
		STDMETHOD(GetPropertyHandleEx)( LPCWSTR pszPropName, long lFlags, CIMTYPE* puCimType, long* plHandle );
		// Returns property handle for ALL types

		STDMETHOD(SetPropByHandle)( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData );
		// Sets properties using a handle.  If pvData is NULL, it NULLs the property.
		// Can set an array to NULL.  To set actual data use the corresponding array
		// function.  Objects must be pointers to _IWmiObject pointers.

		STDMETHOD(GetPropAddrByHandle)( long lHandle, long lFlags, ULONG* puFlags, LPVOID *pAddress );
		// Returns a pointer to a memory address containing the requested data
		// Caller should not write into the memory address.  The memory address is
		// not guaranteed to be valid if the object is modified.
		// For String properties, puFlags will contain info on the string
		// For object properties, LPVOID will get back an _IWmiObject pointer
		// that must be released by the caller.  Does not return arrays.

		STDMETHOD(GetArrayPropInfoByHandle)( long lHandle, long lFlags, BSTR* pstrName,
											CIMTYPE* pct, ULONG* puNumElements );
		// Returns a pointer directly to a memory address containing contiguous
		// elements.  Limited to non-string/obj types

		STDMETHOD(GetArrayPropAddrByHandle)( long lHandle, long lFlags, ULONG* puNumElements, LPVOID *pAddress );
		// Returns a pointer directly to a memory address containing contiguous
		// elements.  Limited to non-string/obj types

		STDMETHOD(GetArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement, ULONG* puFlags,
					ULONG* puNumElements, LPVOID *pAddress );
		// Returns a pointer to a memory address containing the requested data
		// Caller should not write into the memory address.  The memory address is
		// not guaranteed to be valid if the object is modified.
		// For String properties, puFlags will contain info on the string
		// For object properties, LPVOID will get back an _IWmiObject pointer
		// that must be released by the caller.

		STDMETHOD(SetArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement, ULONG uBuffSize,
					LPVOID pData );
		// Sets the data at the specified array element.  BuffSize must be appropriate based on the
		// actual element being set.  Object properties require an _IWmiObject pointer.  Strings must
		// be WCHAR null-terminated

		STDMETHOD(RemoveArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement );
		// Removes the data at the specified array element.

		STDMETHOD(GetArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex,
					ULONG uNumElements, ULONG uBuffSize, ULONG* puNumReturned, ULONG* pulBuffUsed,
					LPVOID pData );
		// Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
		// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
		// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
		// of the current array.

		STDMETHOD(SetArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex,
					ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
		// Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
		// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
		// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
		// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
		// array

		STDMETHOD(RemoveArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex, ULONG uNumElements );
		// Removes a range of elements from an array.  The range MUST fit within the bounds
		// of the current array

		STDMETHOD(AppendArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uNumElements,
					ULONG uBuffSize, LPVOID pData );
		// Appends elements to the end of an array.  BuffSize must reflect uNumElements of the size of
		// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
		// must consist of an array of _IWmiObject pointers.


		STDMETHOD(ReadProp)( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize, CIMTYPE *puCimType,
								long* plFlavor, BOOL* pfIsNull, ULONG* puBuffSizeUsed, LPVOID pUserBuf );
		// Assumes caller knows prop type; Objects returned as _IWmiObject pointers.  Strings
		// returned as WCHAR Null terminated strings, copied in place.  Arrays returned as _IWmiArray
		// pointer.  Array pointer used to access actual array values.

		STDMETHOD(WriteProp)( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
								CIMTYPE uCimType, LPVOID pUserBuf );
		// Assumes caller knows prop type; Supports all CIMTYPES.
		// Strings MUST be null-terminated wchar_t arrays.
		// Objects are passed in as pointers to _IWmiObject pointers
		// Using a NULL buffer will set the property to NULL
		// Array properties must conform to array guidelines.  Will
		// completely blow away an old array.

		STDMETHOD(GetObjQual)( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
								ULONG *puQualFlavor, ULONG* puBuffSizeUsed,	LPVOID pDestBuf );
		// Limited to numeric, simple null terminated string types and simple arrays
		// Strings are copied in-place and null-terminated.
		// Arrays come out as a pointer to IWmiArray

		STDMETHOD(SetObjQual)( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
								CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
		// Limited to numeric, simple null terminated string types and simple arrays
		// Strings MUST be WCHAR
		// Arrays are set using _IWmiArray interface from Get

		STDMETHOD(GetPropQual)( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
								CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
								LPVOID pDestBuf );
		// Limited to numeric, simple null terminated string types and simple arrays
		// Strings are copied in-place and null-terminated.
		// Arrays come out as a pointer to IWmiArray

		STDMETHOD(SetPropQual)( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
								ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
		// Limited to numeric, simple null terminated string types and simple arrays
		// Strings MUST be WCHAR
		// Arrays are set using _IWmiArray interface from Get

		STDMETHOD(GetMethodQual)( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
								CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
								LPVOID pDestBuf );
		// Limited to numeric, simple null terminated string types and simple arrays
		// Strings are copied in-place and null-terminated.
		// Arrays come out as a pointer to IWmiArray

		STDMETHOD(SetMethodQual)( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
								ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
		// Limited to numeric, simple null terminated string types and simple arrays
		// Strings MUST be WCHAR
		// Arrays are set using _IWmiArray interface from Get

		//
		//	_IWmiObject functions
		STDMETHOD(CopyInstanceData)( long lFlags, _IWmiObject* pSourceInstance );
		// Copies instance data from source instance into current instance
		// Class Data must be exactly the same

		STDMETHOD(QueryObjectFlags)( long lFlags, unsigned __int64 qObjectInfoMask,
					unsigned __int64 *pqObjectInfo );
		// Returns flags indicating singleton, dynamic, association, etc.

		STDMETHOD(SetObjectFlags)( long lFlags, unsigned __int64 qObjectInfoOnFlags,
									unsigned __int64 qObjectInfoOffFlags );
		// Sets flags, including internal ones normally inaccessible.

		STDMETHOD(QueryPropertyFlags)( long lFlags, LPCWSTR pszPropertyName, unsigned __int64 qPropertyInfoMask,
					unsigned __int64 *pqPropertyInfo );
		// Returns flags indicating key, index, etc.

		STDMETHOD(CloneEx)( long lFlags, _IWmiObject* pDestObject );
		// Clones the current object into the supplied one.  Reuses memory as
		// needed

		STDMETHOD(IsParentClass)( long lFlags, _IWmiObject* pClass );
		// Checks if the current object is a child of the specified class (i.e. is Instance of,
		// or is Child of )

		STDMETHOD(CompareDerivedMostClass)( long lFlags, _IWmiObject* pClass );
		// Compares the derived most class information of two class objects.

		STDMETHOD(MergeAmended)( long lFlags, _IWmiObject* pAmendedClass );
		// Merges in amended qualifiers from the amended class object into the
		// current object.  If lFlags is WMIOBJECT_MERGEAMENDED_FLAG_PAENTLOCALIZED,
		// this means that the parent object was localized, but not the current,
		// so we need to prevent certain qualifiers from "moving over."

		STDMETHOD(GetDerivation)( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
								ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer );
		// Retrieves the derivation of an object as an array of LPCWSTR's, each one
		// terminated by a NULL.  Leftmost class is at the top of the chain

		STDMETHOD(_GetCoreInfo)( long lFlags, void** ppvData );
		//Returns CWbemObject

		STDMETHOD(GetClassSubset)( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass );
		// Creates a limited representation class for projection queries

	    STDMETHOD(MakeSubsetInst)( _IWmiObject *pInstance, _IWmiObject** pNewInstance );
		// Creates a limited representation instance for projection queries
		// "this" _IWmiObject must be a limited class

		STDMETHOD(Unmerge)( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID ppObj );
		// Returns a BLOB of memory containing minimal data (local)

		STDMETHOD(Merge)( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj );
		// Merges a blob with the current object memory and creates a new object

		STDMETHOD(ReconcileWith)( long lFlags, _IWmiObject* pNewObj );
		// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
		// is specified this will only perform a test

		STDMETHOD(GetKeyOrigin)( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwzClassName );
		// Returns the name of the class where the keys were defined

		STDMETHOD(GetKeyString)( long lFlags, BSTR* pwzKeyString );
		// Returns the key string that defines the instance

		STDMETHOD(GetNormalizedPath)( long lFlags, BSTR* ppstrPath );
		// Returns the normalized path of an instance

		STDMETHOD(Upgrade)( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild );
		// Upgrades class and instance objects

		STDMETHOD(Update)( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass );
		// Updates derived class object using the safe/force mode logic

		STDMETHOD(BeginEnumerationEx)( long lFlags, long lExtFlags );
		// Allows special filtering when enumerating properties outside the
		// bounds of those allowed via BeginEnumeration().

		STDMETHOD(CIMTYPEToVARTYPE)( CIMTYPE ct, VARTYPE* pvt );
		// Returns a VARTYPE from a CIMTYPE

		STDMETHOD(SpawnKeyedInstance)( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst );
		// Spawns an instance of a class and fills out the key properties using the supplied
		// path.

		STDMETHOD(ValidateObject)( long lFlags );
		// Validates an object blob

		STDMETHOD(GetParentClassFromBlob)( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass );
		// Returns the parent class name from a BLOB

    } m_XWMIObject;
    friend XWMIObject;

    // IMarshal methods
    class COREPROX_POLARITY XObjectMarshal : public CImpl<IMarshal, CWmiObjectWrapper>
    {
    public:
        XObjectMarshal(CWmiObjectWrapper* pObject) : 
            CImpl<IMarshal, CWmiObjectWrapper>(pObject)
        {}
		STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
			void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
		STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
			void* pvReserved, DWORD mshlFlags, ULONG* plSize);
		STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv,
			DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
		STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
		STDMETHOD(ReleaseMarshalData)(IStream* pStream);
		STDMETHOD(DisconnectObject)(DWORD dwReserved);
	}	m_XObjectMarshal;
	friend XWMIObject;

/*
	// IUmiPropList Methods
    class COREPROX_POLARITY XUmiPropList : public CImpl<IUmiPropList, CWmiObjectWrapper>
    {
    public:
        XUmiPropList(CWmiObjectWrapper* pObject) : 
            CImpl<IUmiPropList, CWmiObjectWrapper>(pObject)
        {}
		STDMETHOD(Put)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp );
		STDMETHOD(Get)( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp );
		STDMETHOD(GetAt)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
		STDMETHOD(GetAs)( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp );
		STDMETHOD(FreeMemory)( ULONG uReserved, LPVOID pMem );
		STDMETHOD(Delete)( LPCWSTR pszName, ULONG uFlags );
		STDMETHOD(GetProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps );
		STDMETHOD(PutProps)( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps );
		STDMETHOD(PutFrom)( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
	}	m_XUmiPropList;
	friend XUmiPropList;
*/	

    // IErrorInfo methods
    class COREPROX_POLARITY XErrorInfo : public CImpl<IErrorInfo, CWmiObjectWrapper>
    {
    public:
        XErrorInfo(CWmiObjectWrapper* pObject) : 
            CImpl<IErrorInfo, CWmiObjectWrapper>(pObject)
        {}
		STDMETHOD(GetDescription)(BSTR* pstrDescription);
		STDMETHOD(GetGUID)(GUID* pguid);
		STDMETHOD(GetHelpContext)(DWORD* pdwHelpContext);
		STDMETHOD(GetHelpFile)(BSTR* pstrHelpFile);
		STDMETHOD(GetSource)(BSTR* pstrSource);
	}	m_XErrorInfo;
	friend XWMIObject;

    /* IWbemClassObject methods */
    virtual HRESULT GetQualifierSet(IWbemQualifierSet** pQualifierSet);
    virtual HRESULT Get(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
        long* plFlavor);

    virtual HRESULT Put(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType);
    virtual HRESULT Delete(LPCWSTR wszName);
    virtual HRESULT GetNames(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                        SAFEARRAY** pNames);
    virtual HRESULT BeginEnumeration(long lEnumFlags);

    virtual HRESULT Next(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                    long* plFlavor);

    virtual HRESULT EndEnumeration();

    virtual HRESULT GetPropertyQualifierSet(LPCWSTR wszProperty,
                                       IWbemQualifierSet** pQualifierSet);
    virtual HRESULT Clone(IWbemClassObject** pCopy);
    virtual HRESULT GetObjectText(long lFlags, BSTR* pMofSyntax);

    virtual HRESULT CompareTo(long lFlags, IWbemClassObject* pCompareTo);
    virtual HRESULT GetPropertyOrigin(LPCWSTR wszProperty, BSTR* pstrClassName);
    virtual HRESULT InheritsFrom(LPCWSTR wszClassName);

    virtual HRESULT SpawnDerivedClass(long lFlags, IWbemClassObject** ppNewClass);
    virtual HRESULT SpawnInstance(long lFlags, IWbemClassObject** ppNewInstance);
    virtual HRESULT GetMethod(LPCWSTR wszName, long lFlags, IWbemClassObject** ppInSig,
                            IWbemClassObject** ppOutSig);
    virtual HRESULT PutMethod(LPCWSTR wszName, long lFlags, IWbemClassObject* pInSig,
                            IWbemClassObject* pOutSig);
    virtual HRESULT DeleteMethod(LPCWSTR wszName);
    virtual HRESULT BeginMethodEnumeration(long lFlags);
    virtual HRESULT NextMethod(long lFlags, BSTR* pstrName, 
                       IWbemClassObject** ppInSig, IWbemClassObject** ppOutSig);
    virtual HRESULT EndMethodEnumeration();
    virtual HRESULT GetMethodQualifierSet(LPCWSTR wszName, IWbemQualifierSet** ppSet);
    virtual HRESULT GetMethodOrigin(LPCWSTR wszMethodName, BSTR* pstrClassName);

    // IWbemObjectAccess

    virtual HRESULT GetPropertyHandle(LPCWSTR wszPropertyName, CIMTYPE* pct,
        long *plHandle);

    virtual HRESULT WritePropertyValue(long lHandle, long lNumBytes,
                const byte *pData);
    virtual HRESULT ReadPropertyValue(long lHandle, long lBufferSize,
        long *plNumBytes, byte *pData);

    virtual HRESULT ReadDWORD(long lHandle, DWORD *pdw);
    virtual HRESULT WriteDWORD(long lHandle, DWORD dw);
    virtual HRESULT ReadQWORD(long lHandle, unsigned __int64 *pqw);
    virtual HRESULT WriteQWORD(long lHandle, unsigned __int64 qw);

    virtual HRESULT GetPropertyInfoByHandle(long lHandle, BSTR* pstrName,
             CIMTYPE* pct);

    virtual HRESULT Lock(long lFlags);
    virtual HRESULT Unlock(long lFlags);

    // _IWmiObject object parts methods
    // =================================

    virtual HRESULT QueryPartInfo( DWORD *pdwResult );

    virtual HRESULT SetObjectMemory( LPVOID pMem, DWORD dwMemSize );
    virtual HRESULT GetObjectMemory( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
    virtual HRESULT SetObjectParts( LPVOID pMem, DWORD dwMemSize, DWORD dwParts );
    virtual HRESULT GetObjectParts( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed );

    virtual HRESULT StripClassPart();
    virtual HRESULT IsObjectInstance();

    virtual HRESULT GetClassPart( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
    virtual HRESULT SetClassPart( LPVOID pClassPart, DWORD dwSize );
    virtual HRESULT MergeClassPart( IWbemClassObject *pClassPart );

    virtual HRESULT SetDecoration( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace );
    virtual HRESULT RemoveDecoration( void );

    virtual HRESULT CompareClassParts( IWbemClassObject* pObj, long lFlags );

    virtual HRESULT ClearWriteOnlyProperties( void );

	//
	//	_IWmiObjectAccessEx functions
    virtual HRESULT GetPropertyHandleEx( LPCWSTR pszPropName, long lFlags, CIMTYPE* puCimType, long* plHandle );
	// Returns property handle for ALL types

    virtual HRESULT SetPropByHandle( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData );
	// Sets properties using a handle.  If pvData is NULL, it NULLs the property.
	// Can set an array to NULL.  To set actual data use the corresponding array
	// function

    virtual HRESULT GetPropAddrByHandle( long lHandle, long lFlags, ULONG* puFlags, LPVOID *pAddress );
    // Returns a pointer to a memory address containing the requested data
	// Caller should not write into the memory address.  The memory address is
	// not guaranteed to be valid if the object is modified.
	// For String properties, puFlags will contain info on the string
	// For object properties, LPVOID will get back an _IWmiObject pointer
	// that must be released by the caller.  Does not return arrays.

    virtual HRESULT GetArrayPropInfoByHandle( long lHandle, long lFlags, BSTR* pstrName,
										CIMTYPE* pct, ULONG* puNumElements );
    // Returns a pointer directly to a memory address containing contiguous
	// elements.  Limited to non-string/obj types

    virtual HRESULT GetArrayPropAddrByHandle( long lHandle, long lFlags, ULONG* puNumElements, LPVOID *pAddress );
    // Returns a pointer directly to a memory address containing contiguous
	// elements.  Limited to non-string/obj types

    virtual HRESULT GetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement, ULONG* puFlags,
				ULONG* puNumElements, LPVOID *pAddress );
    // Returns a pointer to a memory address containing the requested data
	// Caller should not write into the memory address.  The memory address is
	// not guaranteed to be valid if the object is modified.
	// For String properties, puFlags will contain info on the string
	// For object properties, LPVOID will get back an _IWmiObject pointer
	// that must be released by the caller.

    virtual HRESULT SetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement, ULONG uBuffSize,
				LPVOID pData );
    // Sets the data at the specified array element.  BuffSize must be appropriate based on the
	// actual element being set.  Object properties require an _IWmiObject pointer.  Strings must
	// be WCHAR null-terminated

    virtual HRESULT RemoveArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement );
    // Removes the data at the specified array element.

    virtual HRESULT GetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
				ULONG uNumElements, ULONG uBuffSize, ULONG* puNumReturned, ULONG* pulBuffUsed,
				LPVOID pData );
    // Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
	// of the current array.

    virtual HRESULT SetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
				ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

    virtual HRESULT RemoveArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex, ULONG uNumElements );
    // Removes a range of elements from an array.  The range MUST fit within the bounds
	// of the current array

    virtual HRESULT AppendArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uNumElements,
				ULONG uBuffSize, LPVOID pData );
    // Appends elements to the end of an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.


    virtual HRESULT ReadProp( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize, CIMTYPE *puCimType,
							long* plFlavor, BOOL* pfIsNull, ULONG* puBuffSizeUsed, LPVOID pUserBuf );
    // Assumes caller knows prop type; Objects returned as _IWmiObject pointers.  Strings
	// returned as WCHAR Null terminated strings, copied in place.  Arrays returned as _IWmiArray
	// pointer.  Array pointer used to access actual array values.

    virtual HRESULT WriteProp( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
							CIMTYPE uCimType, LPVOID pUserBuf );
    // Assumes caller knows prop type; Supports all CIMTYPES.
	// Strings MUST be null-terminated wchar_t arrays.
	// Objects are passed in as _IWmiObject pointers
	// Using a NULL buffer will set the property to NULL
	// Array properties must conform to array guidelines.  Will
	// completely blow away an old array.

    virtual HRESULT GetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
							ULONG *puQualFlavor, ULONG* puBuffSizeUsed,	LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    virtual HRESULT SetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
							CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

    virtual HRESULT GetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
							LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    virtual HRESULT SetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

	virtual HRESULT GetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
							LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    virtual HRESULT SetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

	//
	//	_IWmiObject functions
	virtual HRESULT CopyInstanceData( long lFlags, _IWmiObject* pSourceInstance );
	// Copies instance data from source instance into current instance
	// Class Data must be exactly the same

    virtual HRESULT QueryObjectFlags( long lFlags, unsigned __int64 qObjectInfoMask,
				unsigned __int64 *pqObjectInfo );
	// Returns flags indicating singleton, dynamic, association, etc.

    virtual HRESULT SetObjectFlags( long lFlags, unsigned __int64 qObjectInfoOnFlags,
								unsigned __int64 qObjectInfoOffFlags );
	// Sets flags, including internal ones normally inaccessible.

    virtual HRESULT QueryPropertyFlags( long lFlags, LPCWSTR pszPropertyName, unsigned __int64 qPropertyInfoMask,
				unsigned __int64 *pqPropertyInfo );
	// Returns flags indicating key, index, etc.

	virtual HRESULT CloneEx( long lFlags, _IWmiObject* pDestObject );
    // Clones the current object into the supplied one.  Reuses memory as
	// needed

    virtual HRESULT IsParentClass( long lFlags, _IWmiObject* pClass );
	// Checks if the current object is a child of the specified class (i.e. is Instance of,
	// or is Child of )

    virtual HRESULT CompareDerivedMostClass( long lFlags, _IWmiObject* pClass );
	// Compares the derived most class information of two class objects.

    virtual HRESULT MergeAmended( long lFlags, _IWmiObject* pAmendedClass );
	// Merges in amended qualifiers from the amended class object into the
	// current object.  If lFlags is WMIOBJECT_MERGEAMENDED_FLAG_PAENTLOCALIZED,
	// this means that the parent object was localized, but not the current,
	// so we need to prevent certain qualifiers from "moving over."

	virtual HRESULT GetDerivation( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
							ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer );
	// Retrieves the derivation of an object as an array of LPCWSTR's, each one
	// terminated by a NULL.  Leftmost class is at the top of the chain

	virtual HRESULT _GetCoreInfo( long lFlags, void** ppvData );
	//Returns CWbemObject

	virtual HRESULT Unmerge( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID ppObj );
	// Returns a BLOB of memory containing minimal data (local)

	virtual HRESULT Merge( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj );
	// Merges a blob with the current object memory and creates a new object

	virtual HRESULT ReconcileWith( long lFlags, _IWmiObject* pNewObj );
	// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
	// is specified this will only perform a test

	virtual HRESULT GetKeyOrigin( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwzClassName );
	// Returns the name of the class where the keys were defined

	virtual HRESULT GetKeyString( long lFlags, BSTR* ppwzClassName );
	// Returns the key sring that defines the instance

	virtual HRESULT GetNormalizedPath( long lFlags, BSTR* ppstrPath );
	// Returns the normalized path of an instance

	virtual HRESULT Upgrade( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild );
	// Upgrades class and instance objects

    virtual HRESULT GetClassSubset( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass );
	// Creates a limited representation class for projection queries

    virtual HRESULT MakeSubsetInst( _IWmiObject *pInstance, _IWmiObject** pNewInstance );
	// Creates a limited representation instance for projection queries
	// "this" _IWmiObject must be a limited class

	virtual HRESULT Update( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass );
	// Updates derived class object using the safe/force mode logic

	virtual HRESULT BeginEnumerationEx( long lFlags, long lExtFlags );
	// Allows special filtering when enumerating properties outside the
	// bounds of those allowed via BeginEnumeration().

	virtual HRESULT CIMTYPEToVARTYPE( CIMTYPE ct, VARTYPE* pvt );
	// Returns a VARTYPE from a CIMTYPE

	virtual HRESULT SpawnKeyedInstance( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst );
	// Spawns an instance of a class and fills out the key properties using the supplied
	// path.

	virtual HRESULT ValidateObject( long lFlags );
	// Validates an object blob

	virtual HRESULT GetParentClassFromBlob( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass );
	// Returns the parent class name from a BLOB

	/* IMarshal methods */
	virtual HRESULT GetUnmarshalClass(REFIID riid, void* pv, DWORD dwDestContext,
		void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
	virtual HRESULT GetMarshalSizeMax(REFIID riid, void* pv, DWORD dwDestContext,
		void* pvReserved, DWORD mshlFlags, ULONG* plSize);
	virtual HRESULT MarshalInterface(IStream* pStream, REFIID riid, void* pv,
		DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
	virtual HRESULT UnmarshalInterface(IStream* pStream, REFIID riid, void** ppv);
	virtual HRESULT ReleaseMarshalData(IStream* pStream);
	virtual HRESULT DisconnectObject(DWORD dwReserved);


	/* IUmiPropList Methods */
/*	
	virtual HRESULT Put( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES *pProp );
	virtual HRESULT Get( LPCWSTR pszName, ULONG uFlags, UMI_PROPERTY_VALUES **pProp );
	virtual HRESULT GetAt( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
	virtual HRESULT GetAs( LPCWSTR pszName, ULONG uFlags, ULONG uCoercionType, UMI_PROPERTY_VALUES **pProp );
	virtual HRESULT FreeMemory( ULONG uReserved, LPVOID pMem );
	virtual HRESULT Delete( LPCWSTR pszName, ULONG uFlags );
	virtual HRESULT GetProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES **pProps );
	virtual HRESULT PutProps( LPCWSTR *pszNames, ULONG uNameCount, ULONG uFlags, UMI_PROPERTY_VALUES *pProps );
	virtual HRESULT PutFrom( LPCWSTR pszName, ULONG uFlags, ULONG uBufferLength, LPVOID pExistingMem );
*/
	/* IErrorInfo Methods */
	virtual HRESULT GetDescription(BSTR* pstrDescription);
	virtual HRESULT GetGUID(GUID* pguid);
	virtual HRESULT GetHelpContext(DWORD* pdwHelpContext);
	virtual HRESULT GetHelpFile(BSTR* pstrHelpFile);
	virtual HRESULT GetSource(BSTR* pstrSource);

public:
	
	// Dummy function called by template code
	void InitEmpty() {};

	// Helper function to initialize the wrapper (we need something to wrap).
	virtual HRESULT Init( CWbemObject* pObj ) = 0;

protected:

	// Helper function that locks/unlocks the object using scoping
    class CLock
    {
    protected:
        CWmiObjectWrapper* m_p;
    public:
        CLock(CWmiObjectWrapper* p, long lFlags = 0) : m_p(p) { if ( NULL != p ) p->Lock(lFlags);}
        ~CLock() { if ( NULL != m_p ) m_p->Unlock(0);}
    };

	virtual CWmiObjectWrapper*	CreateNewWrapper( BOOL fClone = FALSE ) = 0;

	HRESULT	WrapReturnedObject( CWbemObject* pObj, BOOL fClone, REFIID ridd, LPVOID* pvObj );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wrapsink.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WRAPSINK.H

Abstract:

    Sink Wrapper Implementations

History:

--*/

#ifndef __WRAPSINK_H__
#define __WRAPSINK_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>

//***************************************************************************
//
//  class CWrappedSinkExBase
//
//  DESCRIPTION:
//
//  This class wraps an IWbemServicesEx interface and can be used
//	to act as a delegator on method calls.
//
//***************************************************************************

class COREPROX_POLARITY CWrappedSinkExBase : public IWbemObjectSinkEx
{
protected:
	IWbemObjectSinkEx*	m_pTargetSinkEx;
	long				m_lRefCount;
	CCritSec			m_cs;

public:
    CWrappedSinkExBase( IWbemObjectSinkEx* pTargetSinkEx );
	virtual ~CWrappedSinkExBase();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjPAram);

    STDMETHOD(Set)( long lFlags, REFIID riid, void *pComObject );

};

//***************************************************************************
//
//  class CRefreshObjectSink
//
//  DESCRIPTION:
//
//  This class wraps an IWbemServicesEx interface and can be used
//	to act as a delegator on method calls.
//
//***************************************************************************

class COREPROX_POLARITY CRefreshObjectSink : public CWrappedSinkExBase
{
protected:
	BOOL				m_fRefreshed;
	IWbemClassObject*	m_pTargetObj;

public:
    CRefreshObjectSink( IWbemClassObject* pTargetObj, IWbemObjectSinkEx* pTargetSinkEx );
	virtual ~CRefreshObjectSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmitxtsc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMITXTSC.CPP

Abstract:

  CWmiTextSource implementation.

  Helper class for maintaining text source objects.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <tchar.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include "reg.h"
#include "wmitxtsc.h"

//***************************************************************************
//
//  CWmiTextSource::~CWmiTextSource
//
//***************************************************************************
// ok
CWmiTextSource::CWmiTextSource()
:	m_lRefCount( 1 ),	// Always have to be released
	m_ulId( WMITEXTSC_INVALIDID ),
	m_hDll( NULL ),
	m_pOpenTextSrc( NULL ),
	m_pCloseTextSrc( NULL ),
	m_pObjectToText( NULL ),
	m_pTextToObject( NULL ),
	m_fOpened( FALSE )
{
}
    
//***************************************************************************
//
//  CWmiTextSource::~CWmiTextSource
//
//***************************************************************************
// ok
CWmiTextSource::~CWmiTextSource()
{
	if ( m_fOpened )
	{
		CloseTextSource( 0L );
	}

	if ( NULL != m_hDll )
	{
		FreeLibrary( m_hDll );
	}
}

// AddRef/Release
ULONG CWmiTextSource::AddRef( void )
{
	return InterlockedIncrement( &m_lRefCount );
}

ULONG CWmiTextSource::Release( void )
{
	long lReturn = InterlockedDecrement( &m_lRefCount );

	if ( 0L == lReturn )
	{
		delete this;
	}

	return lReturn;
}

// Initialization helper
HRESULT	CWmiTextSource::Init( ULONG lId )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	TCHAR	szSubKey[64];
	_ultot( lId, szSubKey, 10 );

	TCHAR	szRegKey[256];
	
	lstrcpy( szRegKey, WBEM_REG_WBEM_TEXTSRC );
	lstrcat( szRegKey, __TEXT("\\") );
	lstrcat( szRegKey, szSubKey );

	// We only need read privileges
	Registry	reg( HKEY_LOCAL_MACHINE, KEY_READ, szRegKey );

	if (reg.GetLastError() == ERROR_SUCCESS )
	{
		TCHAR*	pszDllPath = NULL;

		// Now query the dllname
		if ( reg.GetStr( WBEM_REG_WBEM_TEXTSRCDLL, &pszDllPath ) == Registry::no_error )
		{
			HINSTANCE	hInst = LoadLibraryEx( pszDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );

			if ( NULL != hInst )
			{
				// Now load our proc addresses
				m_pOpenTextSrc = (PWMIOBJTEXTSRC_OPEN) GetProcAddress( hInst, "OpenWbemTextSource" );
				m_pCloseTextSrc = (PWMIOBJTEXTSRC_CLOSE) GetProcAddress( hInst, "CloseWbemTextSource" );
				m_pObjectToText = (PWMIOBJTEXTSRC_OBJECTTOTEXT) GetProcAddress( hInst, "WbemObjectToText" );
				m_pTextToObject = (PWMIOBJTEXTSRC_TEXTTOOBJECT) GetProcAddress( hInst, "TextToWbemObject" );

				if (	NULL != m_pOpenTextSrc		&&
						NULL != m_pCloseTextSrc		&&
						NULL != m_pObjectToText		&&
						NULL !=	m_pTextToObject	)
				{
					// Set the Id
					m_ulId = lId;

					// Finally, call the open function
					hr = OpenTextSource( 0L );

					if ( SUCCEEDED( hr ) )
					{
						m_hDll = hInst;
						m_fOpened = true;
					}
					else
					{
						FreeLibrary( hInst );
					}
				}
				else
				{

					hr = WBEM_E_FAILED;

				}	// Failed to get a proc address

			}
			else
			{

				hr = WBEM_E_FAILED;

			}	// Failed to load the library

			// Cleanup
			delete [] pszDllPath;
		}
		else
		{

			hr = WBEM_E_NOT_FOUND;

		}	// Failed to get the dll path
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;

}

// Pass-through functions
HRESULT CWmiTextSource::OpenTextSource( long lFlags )
{
	return m_pOpenTextSrc( lFlags, m_ulId );
}

HRESULT CWmiTextSource::CloseTextSource( long lFlags )
{
	return m_pCloseTextSrc( lFlags, m_ulId );
}

HRESULT CWmiTextSource::ObjectToText( long lFlags, IWbemContext* pCtx, IWbemClassObject* pObj, BSTR* pbText )
{
	return m_pObjectToText( lFlags, m_ulId, (void*) pCtx, (void*) pObj, pbText );
}

HRESULT CWmiTextSource::TextToObject( long lFlags, IWbemContext* pCtx, BSTR pText, IWbemClassObject** ppObj )
{
	return m_pTextToObject( lFlags, m_ulId, (void*) pCtx, pText, (void**) ppObj );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\dcomsec\iac.cpp ===
/*++

IAccessControl Sample
Copyright (c) 1996-2001 Microsoft Corporation. All rights reserved.

Module Name:

    iac.cpp

Abstract:

    Demonstration of IAccessControl

Environment:

    Windows 95/Windows NT

--*/

#include <windows.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>
#include <malloc.h>

#include <ole2.h>
#include <objerror.h>
#include <accctrl.h>
#include <winnt.h>      // Security definitions
#include <cguid.h>

#include <iaccess.h>     // IAccessControl
#include "iac.h"

STDAPI DllRegisterServer()
{
    HRESULT                     hResult;
    IStream                     *stream;
    SPermissionHeader           header;
    ACTRL_ACCESSW               access;
    ACTRL_PROPERTY_ENTRYW       propEntry;
    ACTRL_ACCESS_ENTRY_LISTW    entryList;
    ACTRL_ACCESS_ENTRYW         entry;
    HKEY                        key = 0;
    IAccessControl              *accctrl = NULL;
    IPersistStream              *persist = NULL;
    DWORD                       ignore;
    HGLOBAL                     memory;
    ULARGE_INTEGER              size;

#ifdef _DEBUG
    FILE* pfDebugLog;

    pfDebugLog = fopen("c:\\dcomsec.log", "w");

#endif

    //
    // Initialize COM
    //
    hResult = CoInitialize (NULL);

    //
    // Create an DCOM access control object and get its IAccessControl
    // interface.

    hResult = CoCreateInstance (CLSID_DCOMAccessControl,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IAccessControl,
                                (void **) &accctrl);

    if(hResult != S_OK) {
#ifdef _DEBUG
#pragma message("Building for debug")
        fprintf(pfDebugLog, "CoCreateInstance of IID_IAccessControl failed with code 0x%08X\n", hResult);
#endif
        return S_OK;
    }
    //
    // Setup the property list. We use the NULL property because we are
    // trying to adjust the security of the object itself.
    //

    access.cEntries = 1;
    access.pPropertyAccessList = &propEntry;

    propEntry.lpProperty = NULL;
    propEntry.pAccessEntryList = &entryList;
    propEntry.fListFlags = 0;

    //
    // Setup the access control list for the default property
    //

    entryList.cEntries = 1;
    entryList.pAccessList = &entry;

    //
    // Setup the access control entry
    //

    entry.fAccessFlags = ACTRL_ACCESS_ALLOWED;
    entry.Access = COM_RIGHTS_EXECUTE;
    entry.ProvSpecificAccess = 0;
    entry.Inheritance = NO_INHERITANCE;
    entry.lpInheritProperty = NULL;

    //
    // NT requires the system account to have access (for launching)
    //

    entry.Trustee.pMultipleTrustee = NULL;
    entry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    entry.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    entry.Trustee.TrusteeType = TRUSTEE_IS_USER;
    entry.Trustee.ptstrName = L"NT Authority\\System";

    hResult = accctrl->SetAccessRights (&access);

    if(hResult != S_OK) {
        if(hResult == E_NOTIMPL) {
            MessageBox(NULL, "There is a known issue where this setup can not setup DCOM security attributes "
                             "under Windows NT 4.0 128-bit. Please see the release notes on using DCOMCNFG", "ATTENTION", MB_OK);
        }
#ifdef _DEBUG
        fprintf(pfDebugLog, "IAccessControl::SetAccessRights failed with code 0x%08X\n", hResult);
#endif
        return S_OK;;
    }

    // Grant access to everyone
    //

    entry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
    entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
    entry.Trustee.ptstrName                = L"*";

    hResult = accctrl->GrantAccessRights (&access);

    if(hResult != S_OK) {
#ifdef _DEBUG
        fprintf(pfDebugLog, "IAccessControl::GrantAccessRights failed with code 0x%08X\n", hResult);
#endif
        return S_OK;;
    }
    //
    // Get IPersistStream interface from the DCOM access control object
    //

    hResult = accctrl->QueryInterface (IID_IPersistStream, (void **) &persist);

    if(hResult != S_OK) {
#ifdef _DEBUG
        fprintf(pfDebugLog, "IAccessControl::QueryInterface for IID_IPersistStream failed with code 0x%08X\n", hResult);
#endif
        return S_OK;;
    }
    //
    // Find out how large the access control security buffer is
    //

    hResult = persist->GetSizeMax (&size);
    size.QuadPart += sizeof (SPermissionHeader);

    //
    // Create a stream where we can place the access control's
    // security buffer
    //

    memory = GlobalAlloc (GMEM_FIXED, size.LowPart);
    if (memory == 0)
    {
#ifdef _DEBUG
    fprintf(pfDebugLog, "Out of memory allocating buffer for security buffer\n");
#endif
        return E_OUTOFMEMORY;
    }

    hResult = CreateStreamOnHGlobal (memory, TRUE, &stream);

    if(hResult != S_OK) {
#ifdef _DEBUG
    fprintf(pfDebugLog, "CreateStreamOnHGlobal failed with code 0x%08X\n", hResult);
#endif
        return S_OK;
    }
    //
    // Write the header to the stream
    //

    header.version = 2;
    header.classid = CLSID_DCOMAccessControl;
    hResult = stream->Write (&header, sizeof(header), NULL);

    //
    // Write the access control security buffer to the stream
    //

    hResult = persist->Save (stream, TRUE );

    if(hResult != S_OK) {
#ifdef _DEBUG
    fprintf(pfDebugLog, "IPersistStream::Save failed with code 0x%08X\n", hResult);
#endif
        return S_OK;
    }
    //
    // Open the AppID key
    //

    hResult = RegCreateKeyExA (HKEY_CLASSES_ROOT,
                               "AppID\\{74864DA1-0630-11d0-A5B6-00AA00680C3F}",
                               NULL,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &key,
                               &ignore);

    //
    // Throw everything into the registry
    //

    hResult = RegSetValueExA (key,
                              "AccessPermission",
                              NULL,
                              REG_BINARY,
                              (UCHAR *) memory,
                              size.LowPart);

    hResult = RegSetValueExA (key,
                              "LaunchPermission",
                              NULL,
                              REG_BINARY,
                              (UCHAR *) memory,
                              size.LowPart);
    //
    // Release everything and bail out
    //

    RegCloseKey (key);
    persist->Release();
    stream->Release();
    accctrl->Release();
    CoUninitialize();

#ifdef _DEBUG
    fprintf(pfDebugLog, "DCOMSEC.DLL exiting normally\n", hResult);
    fclose(pfDebugLog);
#endif


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wrapsink.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WRAPSINK.CPP

Abstract:

    Sink wrapper implementations

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <fastall.h>
#include "wrapsink.h"


CWrappedSinkExBase::CWrappedSinkExBase( IWbemObjectSinkEx* pTargetSinkEx )
:	m_pTargetSinkEx( pTargetSinkEx ), m_lRefCount( 1 ), m_cs()
{
	if ( NULL != m_pTargetSinkEx )
	{
		m_pTargetSinkEx->AddRef();
	}
}

CWrappedSinkExBase::~CWrappedSinkExBase()
{
	if ( NULL != m_pTargetSinkEx )
	{
		m_pTargetSinkEx->Release();
	}
}


SCODE CWrappedSinkExBase::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IWbemObjectSink)
        *ppvObj = this;
    else if (riid == IID_IWbemObjectSinkEx)
        *ppvObj = this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


ULONG CWrappedSinkExBase::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
    return (ULONG) m_lRefCount;
}

ULONG CWrappedSinkExBase::Release()
{
    InterlockedDecrement(&m_lRefCount);

    if (0 != m_lRefCount)
    {
        return 1;
    }

    delete this;
    return 0;
}


STDMETHODIMP CWrappedSinkExBase::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
	return m_pTargetSinkEx->Indicate( lObjectCount, pObjArray );
}

STDMETHODIMP CWrappedSinkExBase::SetStatus(long lFlags, long lParam, BSTR strParam, 
                         IWbemClassObject* pObjParam)
{ 
	return m_pTargetSinkEx->SetStatus( lFlags, lParam, strParam, pObjParam );
}

STDMETHODIMP CWrappedSinkExBase::Set( long lFlags, REFIID riid, void *pComObject )
{ 
	return m_pTargetSinkEx->Set( lFlags, riid, pComObject );
}

CRefreshObjectSink::CRefreshObjectSink( IWbemClassObject* pTargetObj, IWbemObjectSinkEx* pTargetSinkEx )
:	CWrappedSinkExBase( pTargetSinkEx ), m_pTargetObj( pTargetObj ), m_fRefreshed( FALSE )
{
	if ( NULL != m_pTargetObj )
	{
		m_pTargetObj->AddRef();
	}
}

CRefreshObjectSink::~CRefreshObjectSink()
{
	if ( NULL != m_pTargetObj )
	{
		m_pTargetObj->Release();
	}
}

// When we get our first object, this function will replace the guts of a caller specified target object and
// then indicate the target object into the caller's target sink.

STDMETHODIMP CRefreshObjectSink::Indicate(
    long lObjectCount,
    IWbemClassObject ** pObjArray
    )
{
	HRESULT	hr = WBEM_S_NO_ERROR;
	IWbemClassObject*	pOriginalObj = NULL;

	CCheckedInCritSec	ics( &m_cs );

	// IF we have at least one object and we've never been refreshed, we need to replace the guts of the
	// target object, then place it in the array that is indicated to the target sink.  Before we return,
	// we should replace the original source object in the array.

	if ( lObjectCount > 0 )
	{
		if ( !m_fRefreshed )
		{
			// Get Source and Target Wmi Object Pointers
			_IWmiObject*	pSourceWmiObj = NULL;
			hr = pObjArray[0]->QueryInterface( IID__IWmiObject, (void**) &pSourceWmiObj );
			CReleaseMe	rmSource( pSourceWmiObj );

			if ( SUCCEEDED( hr ) )
			{
				// Get Source and Target Wmi Object Pointers
				_IWmiObject*	pTargetWmiObj = NULL;
				hr = m_pTargetObj->QueryInterface( IID__IWmiObject, (void**) &pTargetWmiObj );
				CReleaseMe	rmTarget( pTargetWmiObj );

				if ( SUCCEEDED( hr ) )
				{

					// Target and source MUST be the same types
					if ( pSourceWmiObj->IsObjectInstance() == pTargetWmiObj->IsObjectInstance() )
					{
						LPVOID	pvData = NULL;
						DWORD	dwMemSize = 0;

						// If this is an instance, use GetObjectParts() in case the class data was stripped
						// We need to find out how big of a memory buffer to allocate
						if ( pSourceWmiObj->IsObjectInstance() == WBEM_S_NO_ERROR )
						{
							hr = pSourceWmiObj->GetObjectParts( NULL, 0,
												WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | WBEM_OBJ_CLASS_PART,
												&dwMemSize );
						}
						else
						{
							hr = pSourceWmiObj->GetObjectMemory( NULL, 0, &dwMemSize );
						}

						pvData = CoTaskMemAlloc( dwMemSize );

						if ( NULL != pvData )
						{
							DWORD	dwTemp = 0;

							// Now fill out the buffer.
							if ( pSourceWmiObj->IsObjectInstance() == WBEM_S_NO_ERROR )
							{
								hr = pSourceWmiObj->GetObjectParts( pvData, dwMemSize,
													WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | WBEM_OBJ_CLASS_PART,
													&dwTemp );
							}
							else
							{
								hr = pSourceWmiObj->GetObjectMemory( pvData, dwMemSize, &dwTemp );
							}
						
							if ( SUCCEEDED( hr ) )
							{
								// Now replace the guts of the object
								hr = pTargetWmiObj->SetObjectMemory( pvData, dwMemSize );
							}

							if ( FAILED( hr ) )
							{
								CoTaskMemFree( pvData );
							}
						}
						else
						{
							hr = WBEM_E_OUT_OF_MEMORY;
						}

					}	// If types match

				}	// IF QI

			}	// IF QI
			
			if ( SUCCEEDED( hr ) )
			{
				// Hold onto this as we swap out the object
				pOriginalObj = pObjArray[0];
				pObjArray[0] = m_pTargetObj;
				m_fRefreshed = TRUE;
			}

		}	// IF we've never refreshed

	}	// If we got at least 1 object back

	// Don't need to be in a critical section any more
	ics.Leave();

	// Now call the real function
	if ( SUCCEEDED( hr ) )
	{
		hr = CWrappedSinkExBase::Indicate( lObjectCount, pObjArray );

		// Replace pObjArray[0] if appropriate
		if ( NULL != pOriginalObj )
		{
			pObjArray[0] = pOriginalObj;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\fastprox.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROX.CPP

Abstract:

    Object Marshaling

History:

--*/

#include "precomp.h"
#include "fastprox.h"

ULONG CFastProxy::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRef);
}

ULONG CFastProxy::Release()
{
    long lNewRef = InterlockedDecrement(&m_lRef);
    if(lNewRef == 0)
    {
        delete this;
    }
    return lNewRef;
}

STDMETHODIMP CFastProxy::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
    {
        AddRef();
        *ppv = (void*)(IUnknown*)(IMarshal*)this;
        return S_OK;
    }
    if(riid == IID_IMarshal)
    {
        AddRef();
        *ppv = (void*)(IMarshal*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CFastProxy::GetUnmarshalClass(REFIID riid, void* pv, 
          DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::GetMarshalSizeMax(REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::MarshalInterface(IStream* pStream, REFIID riid, 
    void* pv, DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::UnmarshalInterface(IStream* pStream, REFIID riid, 
                                            void** ppv)
{
    CWbemObject* pObj = CWbemObject::CreateFromStream(pStream);
    if(pObj == NULL)
        return E_FAIL;

    HRESULT hres = pObj->QueryInterface(riid, ppv);
    pObj->Release();
    return hres;
}

STDMETHODIMP CFastProxy::ReleaseMarshalData(IStream* pStream)
{
    return S_OK;
}

STDMETHODIMP CFastProxy::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\cloadhpenum.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLOADHPENUM.H

Abstract:

    Client Loadable Hi-Perf Enumerator

History:

--*/

#ifndef __CLIENTLOADABLEHPENUM__H_
#define __CLIENTLOADABLEHPENUM__H_

#include <unk.h>
#include <wbemcomn.h>

// All we need to do is implement and do some tweaking to GarbageCollect and implement
// ClearElements (we garbage collect from the rear)
class CHPRemoteObjectArray : public CGarbageCollectArray
{
public:
    CHPRemoteObjectArray() :
        CGarbageCollectArray( FALSE )
    {};
    ~CHPRemoteObjectArray()
    {};

    void ClearElements( int nNumToClear );

};

class CClientLoadableHiPerfEnum : public CHiPerfEnum
{
public:

    CClientLoadableHiPerfEnum( CLifeControl* pLifeControl );
    ~CClientLoadableHiPerfEnum();

    // Our own function for copying objects into an allocated array
    HRESULT Copy( CClientLoadableHiPerfEnum* pEnumToCopy );
    HRESULT Copy( long lBlobType, long lBlobLen, BYTE* pBlob );

protected:

    // Ensure that we have enough objects and object data pointers to handle
    // the specified number of objects
    HRESULT EnsureObjectData( DWORD dwNumRequestedObjects, BOOL fClone = TRUE );

    CLifeControl*               m_pLifeControl;
    CHPRemoteObjectArray        m_apRemoteObj;
};

class CReadOnlyHiPerfEnum : public CClientLoadableHiPerfEnum
{
public:

    CReadOnlyHiPerfEnum( CLifeControl* pLifeControl );
    ~CReadOnlyHiPerfEnum();

    STDMETHOD(AddObjects)( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj );
    STDMETHOD(RemoveObjects)( long lFlags, ULONG uNumObjects, long* apIds );
    STDMETHOD(RemoveAll)( long lFlags );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\dcomsec\iac.h ===
/*++

IAccessControl Sample
Copyright (c) 1996-2001 Microsoft Corporation. All rights reserved.

Module Name:

    iac.h

Abstract:

    Header for IAccessControl sample
    
Environment:

    Windows 95/Windows NT

--*/

//
// We use this macro if we get a failed HRESULT from a particular
// operation. It spits out a human-readable version of the error.
// Then (ungracefully) exits.
//


#define ASSERT_HRESULT(hresult, operation) \
    if (FAILED (hresult)) \
    { \
        SystemMessage (operation, hresult); \
        exit (0); \
    }

const IID IID_IAccessControl =
{0xEEDD23E0,0x8410,0x11CE,{0xA1,0xC3,0x08,0x00,0x2B,0x2B,0x8D,0x8F}};

typedef struct
{
    WORD version;
    WORD pad;
    GUID classid;
} SPermissionHeader;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\context.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CONTEXT.H

Abstract:

    CWbemContext Implementation

History:

--*/

#ifndef __WBEM_CONTEXT__H_
#define __WBEM_CONTEXT__H_

#include <arrtempl.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <unk.h>
#include <sync.h>

class CWbemContext : public IWbemContext, public IMarshal, 
                    public IWbemCausalityAccess
{
protected:
    long m_lRef;
    DWORD m_dwCurrentIndex;
	CLifeControl*	m_pControl;

    struct CContextObj
    {
        BSTR m_strName;
        long m_lFlags;
        VARIANT m_vValue;
    public:
        CContextObj();
        CContextObj(LPCWSTR wszName, long lFlags, VARIANT* pvValue);
        CContextObj(const CContextObj& Obj);
        ~CContextObj();

        DWORD GetMarshalSizeMax();
        HRESULT Marshal(IStream* pStream);
        HRESULT Unmarshal(IStream* pStream);
    };

    CUniquePointerArray<CContextObj> m_aObjects;
    DWORD m_dwNumRequests;
    GUID *m_aRequests;

    long m_lNumParents;
    long m_lNumSiblings;
    long m_lNumChildren;
    CCritSec m_cs;

protected:
    DWORD FindValue(LPCWSTR wszIndex);
    void AssignId();

public:
    CWbemContext(CLifeControl* pControl = NULL);
    CWbemContext(const CWbemContext& Other, DWORD dwExtraSpace = 0);
    ~CWbemContext();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)() 
    {
        return InterlockedIncrement(&m_lRef);
    }
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0) delete this;
        return lRef;
    }

    // IWbemContext methods

    STDMETHOD(Clone)(IWbemContext** ppCopy);
    STDMETHOD(GetNames)(long lFlags, SAFEARRAY** pNames);
    STDMETHOD(BeginEnumeration)(long lFlags);
    STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal);
    STDMETHOD(EndEnumeration)();
    STDMETHOD(SetValue)(LPCWSTR NameIndex, long lFlags, VARIANT* pValue);
    STDMETHOD(GetValue)(LPCWSTR NameIndex, long lFlags, VARIANT* pValue);
    STDMETHOD(DeleteValue)(LPCWSTR NameIndex, long lFlags);
    STDMETHOD(DeleteAll)();

    // IWbemCausalityAccess methods

    STDMETHOD(GetRequestId)(GUID* pId);
    STDMETHOD(IsChildOf)(GUID Id);
    STDMETHOD(CreateChild)(IWbemCausalityAccess** ppChild);
    STDMETHOD(GetParentId)(GUID* pId);
    STDMETHOD(GetHistoryInfo)(long* plNumParents, long* plNumSiblings);
    STDMETHOD(MakeSpecial)();
    STDMETHOD(IsSpecial)();

    // IMarshal methods

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\mrshbase.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MRSHBASE.H

Abstract:

    Marshaling base classes.

History:

--*/

#ifndef __MRSHBASE_H__
#define __MRSHBASE_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <objindpacket.h>

//***************************************************************************
//
//  class CBaseProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides a base class implementation for an IRpcProxyBuffer.  As
//	the code necessary for performing this operation isn't necessarily so
//	obvious, but we use it in several places, this encapsulation is intended
//	to try and keep all of this maintainable.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CBaseProxyBuffer : public IRpcProxyBuffer
{
protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
	IRpcProxyBuffer*	m_pOldProxy;
    long m_lRef;
	REFIID m_riid;
	bool		m_fRemote;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

	virtual void*	GetInterface( REFIID riid ) = 0;
	virtual void**	GetOldProxyInterfacePtr( void ) = 0;
	virtual void	ReleaseOldProxyInterface( void ) = 0;

public:
    CBaseProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter, REFIID riid);
    virtual ~CBaseProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CBaseStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

// Forward the definition
class CBaseStublet;

class CBaseStubBuffer : public CUnk
{
    friend CBaseStublet;

protected:

	IRpcStubBuffer*	m_pOldStub;

protected:

public:
    CBaseStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_pOldStub( NULL )
    {}

};

class CBaseStublet : public CImpl<IRpcStubBuffer, CBaseStubBuffer>
{
protected:
	REFIID	m_riid;
	long	m_lConnections;

protected:

	virtual IUnknown*	GetServerInterface( void ) = 0;
	virtual void**	GetServerPtr( void ) = 0;
	virtual void	ReleaseServerPointer( void ) = 0;

	IRpcStubBuffer*	GetOldStub( void )
	{	return m_pObject->m_pOldStub; }

public:
    CBaseStublet(CBaseStubBuffer* pObj, REFIID riid);
    ~CBaseStublet();

    STDMETHOD(Connect)(IUnknown* pUnkServer);
    STDMETHOD_(void, Disconnect)();
    STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
    STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
    STDMETHOD_(ULONG, CountRefs)();
    STDMETHOD(DebugServerQueryInterface)(void** ppv);
    STDMETHOD_(void, DebugServerRelease)(void* pv);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\cloadhpenum.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLOADHPENUM.CPP

Abstract:

    Client Loadable Hi-Perf Enumerator

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <hiperfenum.h>
#include "cloadhpenum.h"

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::CClientLoadableHiPerfEnum
//
//  Purpose:
//      Constructor.
//
//  Inputs:
//      CLifeControl*   pLifeControl - Controls the DLL lifetime.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CClientLoadableHiPerfEnum::CClientLoadableHiPerfEnum( CLifeControl* pLifeControl )
:   CHiPerfEnum(),
    m_pLifeControl( pLifeControl ),
    m_apRemoteObj()
{
    if ( NULL != m_pLifeControl )
    {
        m_pLifeControl->ObjectCreated( this );
    }
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::~CClientLoadableHiPerfEnum
//
//  Purpose:
//      Destructor.
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CClientLoadableHiPerfEnum::~CClientLoadableHiPerfEnum()
{
    if ( NULL != m_pLifeControl )
    {
        m_pLifeControl->ObjectDestroyed( this );
    }

    // Release all the pointers in this array
    IWbemClassObject*   pObj = NULL;
    for( DWORD dwCtr = 0; dwCtr < m_apRemoteObj.Size(); dwCtr++ )
    {
        pObj = (IWbemClassObject*) m_apRemoteObj[dwCtr];
        if ( NULL != pObj )
        {
            pObj->Release();
        }
    }

}


/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Copy
//
//  Purpose:
//      Copies objects from one enumerator into this one.
//
//  Inputs:
//      CClientLoadableHiPerfEnum*  pEnumToCopy - Enumerator to copy.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      New Objects are cloned from a template.
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Copy( CClientLoadableHiPerfEnum* pEnumToCopy )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );
    CHiPerfLockAccess   lockSrc( &pEnumToCopy->m_Lock );

    // Get through both locks first
    if ( lock.IsLocked() && lockSrc.IsLocked() )
    {
        // Make sure we have enough object data and BLOBs to handle data copying
        hr = EnsureObjectData( pEnumToCopy->m_aIdToObject.Size() );

        // Now copy out the BLOBs
        if ( SUCCEEDED( hr ) )
        {

            DWORD   dwCtr = 0;

            // Write the objects and ids out to the array
            for ( dwCtr = 0; SUCCEEDED( hr ) && dwCtr < pEnumToCopy->m_aIdToObject.Size(); dwCtr++ )
            {
                // Make sure the object is not-NULL, otherwise we need to clone the supplied
                // object.  It may be NULL because someone used the standard Remove methods
                // on the HiPerf Enumerator

                if ( ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj != NULL )
                {
                    hr = ((CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj)->CopyBlobOf(
                            (CWbemObject*) ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_pObj );
                }
                else
                {
                    // Clone the object
                    IWbemClassObject*   pObj = NULL;
                    IWbemObjectAccess*  pAccess = NULL;
                    hr = ((CWbemObject*)
                            ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_pObj)->Clone( &pObj );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );

                        // Clean up the objects
                        pObj->Release();

                        if ( SUCCEEDED( hr ) )
                        {
                            // It's sleazy, but quicker than a QI
                            ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->SetObject( pAccess );

                            // Data object should have the AddRef() here.
                            pAccess->Release();
                        }
                    }
                }

                ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_lId = 
                    ((CHiPerfEnumData*) pEnumToCopy->m_aIdToObject[dwCtr])->m_lId;
            }

            // if everything is okay, go ahead and do any necessary garbage collection on
            // our arrays.

            if ( SUCCEEDED( hr ) )
            {
                m_aReusable.GarbageCollect();
                pEnumToCopy->m_aReusable.GarbageCollect();

                // We don't use remote objects here, so don't worry about garbage
                // collecting that array here.


            }

        }   // IF EnsureObjectData

    }
    else
    {
        // If we can't get access to the enumerator to figure out the objects
        // we need to add to enumeration, something is pretty badly wrong.

        hr = WBEM_E_REFRESHER_BUSY;
    }


    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::Copy
//
//  Purpose:
//      Resets this enumerator using a transfer BLOB and other
//      data.  This is so we can support remote refreshable
//      enumerations.
//
//  Inputs:
//      long                lBlobType - Blob Type
//      long                lBlobLen - Blob Length
//      BYTE*               pBlob - Raw Data to initialize from
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      Internal function
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::Copy( long lBlobType, long lBlobLen, BYTE* pBlob )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CHiPerfLockAccess   lock( &m_Lock );

    if ( lock.IsLocked() )
    {

        long    lNumObjects = 0;

        hr = CWbemInstance::CopyTransferArrayBlob( m_pInstTemplate, lBlobType, lBlobLen, pBlob, m_apRemoteObj, &lNumObjects );

        if ( SUCCEEDED( hr ) )
        {
            // The objects cloned above will do quite nicely
            hr = EnsureObjectData( lNumObjects, FALSE );

            if ( SUCCEEDED( hr ) )
            {
                // Now walk the array of remote objects and the Object-To-ID Array, and reset objects
                // and ids

                IWbemObjectAccess*  pAccess = NULL;

                for ( long  lCtr = 0; lCtr < lNumObjects; lCtr++ )
                {
                    // It's sleazy, but quicker than a QI
                    ((CHiPerfEnumData*) m_aIdToObject[lCtr])->SetObject(
                                        (IWbemObjectAccess*) m_apRemoteObj[lCtr] );
                    ((CHiPerfEnumData*) m_aIdToObject[lCtr])->SetId( lCtr );
                }

                // if everything is okay, go ahead and do any necessary garbage collection on
                // our arrays.

                m_aReusable.GarbageCollect();

                // On this one, since the remote object array should contain the same
                // number of objects as what is in the main array the number of objects
                // to garbage collect is the difference between the two.
                m_apRemoteObj.GarbageCollect(
                    m_apRemoteObj.Size() - m_aIdToObject.Size() );


            }   // IF EnsureObjectData

        }   // IF CopyTransferArray Blob

    }
    else
    {
        hr = WBEM_S_TIMEDOUT;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CClientLoadableHiPerfEnum::EnsureObjectData
//
//  Purpose:
//      Ensures that we have enough objects and object data
//      pointers to handle the requested number of objects.
//
//  Inputs:
//      DWORD   dwNumRequestedObjects - Number of requested objects.
//      BOOL    fClone -    Indicates whether we should clone objects
//                          when we allocate object data pointers.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      New Objects are cloned from a template if necessary.
//      
/////////////////////////////////////////////////////////////////

HRESULT CClientLoadableHiPerfEnum::EnsureObjectData( DWORD dwNumRequestedObjects, BOOL fClone /*=TRUE*/ )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwNumObjects = m_aIdToObject.Size() + m_aReusable.Size();

    // See if we will have enough hiperfenum data pointers to handle the objects
    if ( dwNumRequestedObjects > dwNumObjects )
    {
        DWORD               dwNumNewObjects = dwNumRequestedObjects - dwNumObjects;
        CHiPerfEnumData*    pData = NULL;
        IWbemClassObject*   pObj = NULL;
        IWbemObjectAccess*  pAccess = NULL;

        // Clone new instance objects and stick them in the id to object array
        for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumNewObjects; dwCtr++ )
        {
            if ( fClone )
            {
                hr = m_pInstTemplate->Clone( &pObj );

                if ( SUCCEEDED( hr ) )
                {
                    hr = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );

                    // Release the object
                    pObj->Release();
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                pData = new CHiPerfEnumData( 0, pAccess );

                // Should be AddRefd by data objects
                if ( NULL != pAccess )
                {
                    pAccess->Release();
                }

                if ( NULL != pData )
                {
                    if ( m_aIdToObject.Add( (void*) pData ) != CFlexArray::no_error )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // IF Clone

        }   // FOR allocate new objects

    }   // IF we need new objects

    if ( SUCCEEDED( hr ) )
    {
        // Move objects from the reusable array if we don't have enough
        // or move them into the reusable array if we have to many

        if ( dwNumRequestedObjects > m_aIdToObject.Size() )
        {
            DWORD   dwNumObjectsNeeded = dwNumRequestedObjects - m_aIdToObject.Size();

/*
            // Copy from the end, so we just need to zero out and set size
            DWORD   dwReusableIndex = m_aReusable.Size() - dwNumObjectsNeeded;

            // This means we can pull the pointers en masse from m_aReusable
            void**  pReusable = m_aReusable.GetArrayPtr();
            void**  pIdToObject = m_aIdToObject.GetArrayPtr();

            // A Quick append, then zero out the memory and set the size
            // accounting for the pointers we just "stole".
            CopyMemory( &pIdToObject[m_aIdToObject.Size()],
                    &pReusable[dwReusableIndex],
                    dwNumObjectsNeeded * sizeof(void*) );

            ZeroMemory( &pReusable[dwReusableIndex], dwNumObjectsNeeded * sizeof(void*) );
            m_aReusable.SetSize( m_aReusable.Size() - dwNumObjectsNeeded );
            m_aIdToObject.SetSize( m_aIdToObject.Size() + dwNumObjectsNeeded );
*/
            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumObjectsNeeded; dwCtr++ )
            {
                if ( m_aIdToObject.Add( m_aReusable[m_aReusable.Size() - 1] ) != CFlexArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    m_aReusable.RemoveAt( m_aReusable.Size() - 1 );
                }
            }

        }
        else if ( dwNumRequestedObjects < m_aIdToObject.Size() )
        {
            DWORD   dwNumExtraObjects = m_aIdToObject.Size() - dwNumRequestedObjects;

/*
            // Copy from the end, so we just need to zero out and set size
            DWORD   dwExtraIndex = m_aIdToObject.Size() - dwNumExtraObjects;

            // This means we can pull the pointers en masse from m_aReusable
            void**  pReusable = m_aReusable.GetArrayPtr();
            void**  pIdToObject = m_aIdToObject.GetArrayPtr();

            // A Quick append, then zero out the memory and set the size
            // accounting for the pointers we just "stole".
            CopyMemory( &pReusable[m_aReusable.Size()],
                    &pIdToObject[dwExtraIndex],
                    dwNumExtraObjects * sizeof(void*) );

            ZeroMemory( &pIdToObject[dwExtraIndex], dwNumExtraObjects * sizeof(void*) );
            m_aIdToObject.SetSize( m_aIdToObject.Size() - dwNumExtraObjects );
            m_aReusable.SetSize( m_aReusable.Size() + dwNumExtraObjects );
*/
            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumExtraObjects; dwCtr++ )
            {
                if ( m_aReusable.Add( m_aIdToObject[m_aIdToObject.Size() - 1] ) != CFlexArray::no_error )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    m_aIdToObject.RemoveAt( m_aIdToObject.Size() - 1 );
                }
            }

        }

    }   // IF we ensured enough Object Data Pointers

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::CReadOnlyHiPerfEnum
//
//  Purpose:
//      Constructor.
//
//  Inputs:
//      CLifeControl*   pLifeControl - Controls the DLL lifetime.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CReadOnlyHiPerfEnum::CReadOnlyHiPerfEnum( CLifeControl* pLifeControl )
:   CClientLoadableHiPerfEnum( pLifeControl )
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::~CReadOnlyHiPerfEnum
//
//  Purpose:
//      Destructor.
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CReadOnlyHiPerfEnum::~CReadOnlyHiPerfEnum()
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::AddObjects
//
//  Purpose:
//      Adds new objects to the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//      IWbemObjectAccess** apObj   -   Array of object pointers
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::AddObjects( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj )
{
    return WBEM_E_ACCESS_DENIED;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CReadOnlyHiPerfEnum::Remove
//
//  Purpose:
//      Removes specified objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::RemoveObjects( long lFlags, ULONG uNumObjects, long* apIds )
{
    return WBEM_E_ACCESS_DENIED;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::RemoveAll
//
//  Purpose:
//      Removes all objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_E_ACCESS_DENIED
//
//  Comments:
//      We are read-only
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CReadOnlyHiPerfEnum::RemoveAll( long lFlags )
{
    return WBEM_E_ACCESS_DENIED;
}

// Walks the array and cleans up the specified number of elements
void CHPRemoteObjectArray::ClearElements( int nNumToClear )
{

    // We need to clear from the end
    for ( int nCtr = ( m_nSize - nNumToClear ); nCtr < m_nSize; nCtr++ )
    {
        IWbemObjectAccess* pAcc = (IWbemObjectAccess*) GetAt(nCtr);

        _ASSERT( NULL != pAcc, "Tried to clear a NULL Element!" );
        if ( NULL != pAcc )
        {
            pAcc->Release();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\fastprox.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROX.H

Abstract:

    Object Marshaling

History:

--*/

#ifndef __FAST_WRAPPER__H_
#define __FAST_WRAPPER__H_
#pragma warning (disable : 4786)

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include <commain.h>
#include <wbemutil.h>
#include <fastall.h>

class CFastProxy : public IMarshal
{
protected:
    long m_lRef;

public:

    CFastProxy(CLifeControl* pControl) : m_lRef(0){}

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);
};

class CClassObjectFactory : public IClassFactory
{
protected:
    long m_lRef;
    CLifeControl* m_pControl;

public:
    CClassObjectFactory(CLifeControl* pControl = NULL) : 
        m_pControl(pControl), m_lRef(0){}

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        if(riid == IID_IUnknown || riid == IID_IClassFactory)
        {
            AddRef();
            *ppv = (IClassFactory*)this;
            return S_OK;
        }
        else return E_NOINTERFACE;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement(&m_lRef);
    }

    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
        {
            delete this;
        }
        return lRef;
    }
    STDMETHOD(CreateInstance)(IUnknown* pOuter, REFIID riid, void** ppv)
    {
        if(pOuter)
            return CLASS_E_NOAGGREGATION;
    
        CWbemClass* pNewObj = new CWbemClass;
        pNewObj->InitEmpty(0);

        return pNewObj->QueryInterface(riid, ppv);
    }
    STDMETHOD(LockServer)(BOOL fLock)
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\enummrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    ENUMMRSH.H

Abstract:

    Object Enumerator Marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include "wbemclasscache.h"
#include "wbemclasstoidmap.h"
#include "smartnextpacket.h"
#include "mrshbase.h"

//***************************************************************************
//
//  class CEnumFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CEnumFactoryBuffer : public CUnk
{

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XEnumFactory : public CImpl<IPSFactoryBuffer, CEnumFactoryBuffer>
    {
    public:
        XEnumFactory(CEnumFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CEnumFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XEnumFactory;
public:
    CEnumFactoryBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(NULL, pUnkOuter), m_XEnumFactory(this), m_pLifeControl( pControl )
    {}

    void* GetInterface(REFIID riid);

	friend XEnumFactory;

};


//***************************************************************************
//
//  class CEnumProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CEnumProxyBuffer : public CBaseProxyBuffer
{
private:
	IEnumWbemClassObject*	m_pOldProxyEnum;
    CWbemClassToIdMap		m_ClassToIdMap;
    BOOL					m_fTriedSmartEnum;
    BOOL					m_fUseSmartEnum;
	HANDLE					m_hSmartNextMutex;
	GUID					m_guidSmartEnum;
	IWbemWCOSmartEnum*		m_pSmartEnum;
	CRITICAL_SECTION		m_cs;

protected:
    class XEnumFacelet : public IEnumWbemClassObject, IClientSecurity
    {
    protected:
        CEnumProxyBuffer*	m_pObject;
        CWbemClassCache		m_ClassCache;

    public:
        XEnumFacelet(CEnumProxyBuffer* pObject) : m_pObject(pObject){};
        ~XEnumFacelet(){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

		// IEnumWbemClassObject Methods

		STDMETHOD(Reset)();
		STDMETHOD(Next)(long lTimeout, ULONG uCount,  
			IWbemClassObject** apObj, ULONG FAR* puReturned);
		STDMETHOD(NextAsync)(ULONG uCount, IWbemObjectSink* pSink);
		STDMETHOD(Clone)(IEnumWbemClassObject** pEnum);
		STDMETHOD(Skip)(long lTimeout, ULONG nNum);

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XEnumFacelet;
    friend XEnumFacelet;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

	// Initialize the smart enumerator
	HRESULT InitSmartEnum( BOOL fSetBlanket = FALSE, DWORD AuthnSvc = RPC_C_AUTHN_WINNT,
			DWORD AuthzSvc = RPC_C_AUTHZ_NONE, OLECHAR* pServerPrincName = NULL,
			DWORD AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT, DWORD ImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE,
			void* pAuthInfo = NULL, DWORD Capabilities = EOAC_NONE );

public:
    CEnumProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CEnumProxyBuffer();
};

//***************************************************************************
//
//  class CEnumStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CEnumStubBuffer : public CBaseStubBuffer
{
protected:
    class XEnumStublet : public CBaseStublet
    {
        IWbemObjectSink* m_pServer;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XEnumStublet(CEnumStubBuffer* pObj);
        ~XEnumStublet();

        friend CEnumStubBuffer;
    } m_XEnumStublet;
    friend XEnumStublet;

public:
    CEnumStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer(pControl, pUnkOuter), m_XEnumStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\context.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CONTEXT.CPP

Abstract:

    CWbemContext Implementation

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "context.h"

#define MAX_VARIANT_SIZE 8

DWORD GetBSTRMarshalSize(BSTR str)
{
    return wcslen(str)*2 + sizeof(long);
}

HRESULT MarshalBSTR(IStream* pStream, BSTR str)
{
    HRESULT hres;
    long lLen = wcslen(str);
    hres = pStream->Write((void*)&lLen, sizeof(lLen), NULL);
    if(FAILED(hres)) return hres;
    return pStream->Write((void*)str, lLen*2, NULL);
}

HRESULT UnmarshalBSTR(IStream* pStream, BSTR& str)
{
    long lLen;
    HRESULT hres;
    hres = pStream->Read((void*)&lLen, sizeof(lLen), NULL);
    if(FAILED(hres)) return hres;
    str = SysAllocStringLen(NULL, lLen);
    hres = pStream->Read((void*)str, lLen*2, NULL);
    if(FAILED(hres)) 
    {
        SysFreeString(str);
        return hres;
    }

    str[lLen] = 0;
    return S_OK;
}

DWORD GetSafeArrayMarshalSize(VARTYPE vt, SAFEARRAY* psa)
{
    HRESULT hres;

    DWORD dwLen = sizeof(long)*2; // num elements and size of element

    // Compute vital statistics
    // ========================

    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lNumElements = lUBound - lLBound + 1;
    DWORD dwElemSize = SafeArrayGetElemsize(psa);

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    CUnaccessMe um(psa);

    if(vt == VT_BSTR)
    {
        // Add all BSTR sizes
        // ==================

        BSTR* pstrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            dwLen += GetBSTRMarshalSize(pstrData[i]);
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            DWORD dwThis = 0;
            hres = CoGetMarshalSizeMax(&dwThis, IID_IWbemClassObject, 
                                apObjects[i], 
                                MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            if(FAILED(hres)) return hres;
            dwLen += dwThis;
        }
    }
    else
    {
        dwLen += lNumElements*dwElemSize;
    }

    return dwLen;
}
    

HRESULT MarshalSafeArray(IStream* pStream, VARTYPE vt, SAFEARRAY* psa)
{
    HRESULT hres;

    // First, write the number of elements
    // ===================================

    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lNumElements = lUBound - lLBound + 1;

    hres = pStream->Write((void*)&lNumElements, sizeof(lNumElements), NULL);
    if(FAILED(hres)) return hres;

    // Second, write element size
    // ==========================

    DWORD dwElemSize = SafeArrayGetElemsize(psa);
    hres = pStream->Write((void*)&dwElemSize, sizeof(dwElemSize), NULL);
    if(FAILED(hres)) return hres;

    // Now, write all the elements out
    // ===============================

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    CUnaccessMe um(psa);

    if(vt == VT_BSTR)
    {
        BSTR* astrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            MarshalBSTR(pStream, astrData[i]);
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = CoMarshalInterface(pStream, IID_IWbemClassObject, 
                           apObjects[i], MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            if(FAILED(hres)) return hres;
        }
    }
    else
    {
        // Just dump the data
        // ==================

        hres = pStream->Write((void*)pData, dwElemSize*lNumElements, NULL);
        if(FAILED(hres)) return hres;
    }

    return S_OK;
}

HRESULT UnmarshalSafeArray(IStream* pStream, VARTYPE vt, SAFEARRAY*& psa)
{
    HRESULT hres;

    // Read the number of elements
    // ===========================

    long lNumElements;
    hres = pStream->Read((void*)&lNumElements, sizeof(lNumElements), NULL);
    if(FAILED(hres)) return hres;
    
    // Read the size of an element
    // ===========================

    DWORD dwElemSize;
    hres = pStream->Read((void*)&dwElemSize, sizeof(dwElemSize), NULL);
    if(FAILED(hres)) return hres;
    
    // Create the appropriate SafeArray
    // ================================

    SAFEARRAYBOUND sab;
    sab.lLbound = 0;
    sab.cElements = lNumElements;

    psa = SafeArrayCreate(vt, 1, &sab);
    if(psa == NULL)
        return E_FAIL;

    BYTE* pData;
    SafeArrayAccessData(psa, (void**)&pData);    
    CUnaccessMe um(psa);
    
    if(vt == VT_BSTR)
    {
        // Read all the BSTRs
        // ==================

        BSTR* astrData = (BSTR*)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            UnmarshalBSTR(pStream, astrData[i]);
        }
    }
    else if(vt == VT_EMBEDDED_OBJECT)
    {
        // Read all the objects
        // ====================

        I_EMBEDDED_OBJECT** apObjects = (I_EMBEDDED_OBJECT**)pData;
        for(int i = 0; i < lNumElements; i++)
        {
            hres = CoUnmarshalInterface(pStream, IID_IWbemClassObject, 
                           (void**)(apObjects + i));
            if(FAILED(hres)) return hres;
        }
    }
    else
    {
        // Read the block
        // ==============

        hres = pStream->Read((void*)pData, dwElemSize*lNumElements, NULL);
        if(FAILED(hres)) return hres;
    }
    
    return S_OK;
}
        
        
        
    
    
CWbemContext::CContextObj::CContextObj() : m_strName(NULL), m_lFlags(0)
{
    VariantInit(&m_vValue);
}

CWbemContext::CContextObj::CContextObj(LPCWSTR wszName, long lFlags, 
                                        VARIANT* pvValue)
    : m_lFlags(lFlags), m_strName(SysAllocString(wszName))
{
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, pvValue);
}

CWbemContext::CContextObj::CContextObj(const CContextObj& Obj)
    : m_lFlags(Obj.m_lFlags), m_strName(SysAllocString(Obj.m_strName))
{
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, (VARIANT*)&Obj.m_vValue);
}
    

CWbemContext::CContextObj::~CContextObj()
{
    VariantClear(&m_vValue);
    SysFreeString(m_strName);
}
    


DWORD CWbemContext::CContextObj::GetMarshalSizeMax()
{
    // First, the name
    // ===============

    DWORD dwLength = GetBSTRMarshalSize(m_strName);

    // Then the flags
    // ==============

    dwLength += sizeof(m_lFlags);

    // Then the VARTYPE
    // ================

    dwLength += sizeof(VARTYPE);

    // Then the actual data
    // ====================

    switch(V_VT(&m_vValue))
    {
    case VT_NULL:
        break;
    case VT_BSTR:
        dwLength += GetBSTRMarshalSize(V_BSTR(&m_vValue));
        break;
    case VT_EMBEDDED_OBJECT:
        {
            DWORD dwThis = 0;
            CoGetMarshalSizeMax(&dwThis, IID_IWbemClassObject, 
                                V_EMBEDDED_OBJECT(&m_vValue), 
                                MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
            dwLength += dwThis;
        }
        break;
    default:
        if(V_VT(&m_vValue) & VT_ARRAY)
        {
            dwLength += GetSafeArrayMarshalSize(V_VT(&m_vValue) & ~VT_ARRAY,
                                                V_ARRAY(&m_vValue));
        }
        else
        {
            dwLength += MAX_VARIANT_SIZE;
        }
    }

    return dwLength;
}
            
HRESULT CWbemContext::CContextObj::Marshal(IStream* pStream)
{
    // Write the name
    // ==============

    MarshalBSTR(pStream, m_strName);

    // Write the flags
    // ===============

    pStream->Write((void*)&m_lFlags, sizeof(m_lFlags), NULL);

    // Write the VARTYPE
    // =================

    pStream->Write((void*)&V_VT(&m_vValue), sizeof(VARTYPE), NULL);

    // Write the data
    // ==============

    switch(V_VT(&m_vValue))
    {
    case VT_NULL:
        break;
    case VT_BSTR:
        MarshalBSTR(pStream, V_BSTR(&m_vValue));
        break;
    case VT_EMBEDDED_OBJECT:
        CoMarshalInterface(pStream, IID_IWbemClassObject, 
                           V_EMBEDDED_OBJECT(&m_vValue), 
                           MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
        break;
    default:
        if(V_VT(&m_vValue) & VT_ARRAY)
        {
            MarshalSafeArray(pStream, V_VT(&m_vValue) & ~VT_ARRAY,
                                V_ARRAY(&m_vValue));
        }
        else
        {
            pStream->Write(&V_UI1(&m_vValue), MAX_VARIANT_SIZE, NULL);
        }
        break;
    }

    return S_OK;
}

HRESULT CWbemContext::CContextObj::Unmarshal(IStream* pStream)
{
    // Read the name
    // =============

    UnmarshalBSTR(pStream, m_strName);
    
    // Read the flags
    // ==============

    pStream->Read((void*)&m_lFlags, sizeof(m_lFlags), NULL);

    // Read the VARTYPE
    // ================

    pStream->Read((void*)&V_VT(&m_vValue), sizeof(VARTYPE), NULL);

    // Read the data
    // =============

    switch(V_VT(&m_vValue))
    {
    case VT_NULL:
        break;
    case VT_BSTR:
        UnmarshalBSTR(pStream, V_BSTR(&m_vValue));
        break;
    case VT_EMBEDDED_OBJECT:
        CoUnmarshalInterface(pStream, IID_IWbemClassObject, 
                           (void**)&V_EMBEDDED_OBJECT(&m_vValue));
        break;
    default:
        if(V_VT(&m_vValue) & VT_ARRAY)
        {
            UnmarshalSafeArray(pStream, V_VT(&m_vValue) & ~VT_ARRAY,
                                V_ARRAY(&m_vValue));
        }
        else
        {
            pStream->Read(&V_UI1(&m_vValue), MAX_VARIANT_SIZE, NULL);
        }
        break;
    }

    return S_OK;
}
    


CWbemContext::CWbemContext(CLifeControl* pControl) 
    : m_lRef(0), m_dwCurrentIndex(0xFFFFFFFF), m_lNumChildren(0),
        m_lNumParents(0), m_lNumSiblings(0), m_pControl( pControl )
{
    if ( NULL != m_pControl )
    {
        m_pControl->ObjectCreated((IWbemContext*)this);
    }

    m_dwNumRequests = 1;
    m_aRequests = new GUID;
    AssignId();
}

CWbemContext::CWbemContext(const CWbemContext& Other, DWORD dwExtraSpace) 
    : m_lRef(0), m_dwCurrentIndex(0xFFFFFFFF), m_lNumChildren(0),
        m_lNumParents(0), m_lNumSiblings(0), m_pControl( NULL )
{
    // Copy the life control
    m_pControl = Other.m_pControl;

    if ( NULL != m_pControl )
    {
        m_pControl->ObjectCreated((IWbemContext*)this);
    }

    // Copy data
    // =========

    for(int i = 0; i < Other.m_aObjects.GetSize(); i++)
    {
        m_aObjects.Add(new CContextObj(*Other.m_aObjects[i]));
    }

    // Allocate causality string
    // =========================

    m_dwNumRequests = Other.m_dwNumRequests + dwExtraSpace;
    m_aRequests = new GUID[m_dwNumRequests];

    // Copy the current string, leaving space
    // ======================================

    if(Other.m_dwNumRequests > 0)
    {
        memcpy(m_aRequests + dwExtraSpace, Other.m_aRequests, 
            Other.m_dwNumRequests * sizeof(GUID));
    }
}

CWbemContext::~CWbemContext()
{
    delete [] m_aRequests;
    if ( NULL != m_pControl )
    {
        m_pControl->ObjectDestroyed((IWbemContext*)this);
    }
}

STDMETHODIMP CWbemContext::CreateChild(IWbemCausalityAccess** ppChild)
{
    CInCritSec ics(&m_cs);

    CWbemContext* pNewCtx = new CWbemContext(*this, 1);
    pNewCtx->AssignId();
    pNewCtx->m_lNumSiblings = m_lNumSiblings + m_lNumChildren;
    pNewCtx->m_lNumParents = m_lNumParents + 1;

    m_lNumChildren++;
    return pNewCtx->QueryInterface(IID_IWbemCausalityAccess, (void**)ppChild);
}

STDMETHODIMP CWbemContext::GetRequestId(GUID* pId)
{
    CInCritSec ics(&m_cs);

    if(m_dwNumRequests == 0)
    {
        *pId = GUID_NULL;
        return S_FALSE;
    }
    else
    {
        *pId = m_aRequests[0];
        return S_OK;
    }
}

STDMETHODIMP CWbemContext::GetParentId(GUID* pId)
{
    CInCritSec ics(&m_cs);

    if(m_dwNumRequests < 2)
    {
        *pId = GUID_NULL;
        return S_FALSE;
    }
    else
    {
        *pId = m_aRequests[1];
        return S_OK;
    }
}

STDMETHODIMP CWbemContext::IsChildOf(GUID Id)
{
    CInCritSec ics(&m_cs);

    for(DWORD dw = 0; dw < m_dwNumRequests; dw++)
    {
        if(m_aRequests[dw] == Id)
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CWbemContext::GetHistoryInfo(long* plNumParents, 
                                            long* plNumSiblings)
{
    CInCritSec ics(&m_cs);

    *plNumParents = m_lNumParents;
    *plNumSiblings = m_lNumSiblings;
    return S_OK;
}

void CWbemContext::AssignId()
{
    CInCritSec ics(&m_cs);

    CoCreateGuid(m_aRequests);
}

DWORD CWbemContext::FindValue(LPCWSTR wszIndex)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        if(!wbem_wcsicmp(wszIndex, m_aObjects[i]->m_strName))
        {
            return i;
        }
    }
    return 0xFFFFFFFF;
}

STDMETHODIMP CWbemContext::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemContext)
    {
        *ppv = (void*)(IWbemContext*)this;
        AddRef();
        return S_OK;
    }

    if(riid == IID_IMarshal)
    {
        *ppv = (void*)(IMarshal*)this;
        AddRef();
        return S_OK;
    }

    if(riid == IID_IWbemCausalityAccess)
    {
        *ppv = (void*)(IWbemCausalityAccess*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}
    


STDMETHODIMP CWbemContext::Clone(IWbemContext** ppCopy)
{
    if ( NULL == ppCopy )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CInCritSec ics(&m_cs);

    *ppCopy = new CWbemContext(*this);
    (*ppCopy)->AddRef();
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::GetNames(long lFlags, SAFEARRAY** pNames)
{
    CInCritSec ics(&m_cs);

    SAFEARRAYBOUND sab;
    if(lFlags != 0 || !pNames)
        return WBEM_E_INVALID_PARAMETER;
    sab.cElements = m_aObjects.GetSize();
    sab.lLbound = 0;
    *pNames = SafeArrayCreate(VT_BSTR, 1, &sab);
    for(long i = 0; i < m_aObjects.GetSize(); i++)
    {
        SafeArrayPutElement(*pNames, &i, m_aObjects[i]->m_strName);
    }
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::BeginEnumeration(long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;
    if(m_dwCurrentIndex != 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;
    m_dwCurrentIndex = 0;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::Next(long lFlags, BSTR* pName, VARIANT* pVal)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;
    if(m_dwCurrentIndex == 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;

    if(m_dwCurrentIndex >= m_aObjects.GetSize())
        return WBEM_S_NO_MORE_DATA;
    if(pName)
    {
        *pName = SysAllocString(m_aObjects[m_dwCurrentIndex]->m_strName);
    }

    if(pVal)
    {
        VariantInit(pVal);
        VariantCopy(pVal, &m_aObjects[m_dwCurrentIndex]->m_vValue);
    }
    m_dwCurrentIndex++;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::EndEnumeration()
{
    CInCritSec ics(&m_cs);

    if(m_dwCurrentIndex == 0xFFFFFFFF)
        return WBEM_E_UNEXPECTED;
    m_dwCurrentIndex = 0xFFFFFFFF;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::SetValue(LPCWSTR NameIndex, long lFlags, 
                                    VARIANT* pValue)
{
    CInCritSec ics(&m_cs);

    // These are all invalid parameters
    if( lFlags != 0 || NULL == NameIndex || NULL == pValue )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    DWORD dwIndex = FindValue(NameIndex);
    
    if(dwIndex == 0xFFFFFFFF)
    {
        m_aObjects.Add(new CContextObj(NameIndex, lFlags, pValue));
    }
    else
    {
        CContextObj* pObj = m_aObjects[dwIndex];
        VariantCopy(&pObj->m_vValue, pValue);
        pObj->m_lFlags = lFlags;
    }

    return WBEM_S_NO_ERROR;
}
        
STDMETHODIMP CWbemContext::GetValue(LPCWSTR NameIndex, long lFlags, 
                                    VARIANT* pValue)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0 || NameIndex == NULL || pValue == NULL)
        return WBEM_E_INVALID_PARAMETER;
    DWORD dwIndex = FindValue(NameIndex);
    if(dwIndex == 0xFFFFFFFF)
        return WBEM_E_NOT_FOUND;

    VariantInit(pValue);
    VariantCopy(pValue, &m_aObjects[dwIndex]->m_vValue);

    return WBEM_S_NO_ERROR;
}
    
STDMETHODIMP CWbemContext::DeleteValue(LPCWSTR NameIndex, long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0 || NameIndex == NULL)
        return WBEM_E_INVALID_PARAMETER;
    DWORD dwIndex = FindValue(NameIndex);
    if(dwIndex == 0xFFFFFFFF)
    {
        return WBEM_S_FALSE;
    }

    m_aObjects.RemoveAt(dwIndex);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::DeleteAll()
{
    CInCritSec ics(&m_cs);

    m_aObjects.RemoveAll();
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemContext::MakeSpecial()
{
    CInCritSec ics(&m_cs);

    // Make the ID of this context NULL
    // ================================

    m_aRequests[0] = CLSID_NULL;
    return S_OK;
}

STDMETHODIMP CWbemContext::IsSpecial()
{
    CInCritSec ics(&m_cs);

    // Check if the first GUID is NULL
    // ===============================

    if(m_aRequests[m_dwNumRequests-1] == CLSID_NULL)
        return S_OK;
    else
        return S_FALSE;
}

// IMarshal methods

STDMETHODIMP CWbemContext::GetUnmarshalClass(REFIID riid, void* pv, 
                             DWORD dwDestContext, void* pvReserved, 
                             DWORD mshlFlags, CLSID* pClsid)
{
    CInCritSec ics(&m_cs);

    *pClsid = CLSID_WbemContext;
    return S_OK;
}

STDMETHODIMP CWbemContext::GetMarshalSizeMax(REFIID riid, void* pv, 
                             DWORD dwDestContext, void* pvReserved, 
                             DWORD mshlFlags, ULONG* plSize)
{
    CInCritSec ics(&m_cs);

    DWORD dwLength = sizeof(DWORD); // length of causality string
    dwLength += m_dwNumRequests * sizeof(GUID); // causality string

    dwLength += sizeof(DWORD); // number of objects
    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        dwLength += m_aObjects[i]->GetMarshalSizeMax();
    }

    *plSize = dwLength;
    return S_OK;
}

STDMETHODIMP CWbemContext::MarshalInterface(IStream* pStream, REFIID riid, 
                            void* pv, DWORD dwDestContext, void* pvReserved, 
                            DWORD mshlFlags)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;
    hres = pStream->Write((void*)&m_dwNumRequests, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;
    hres = pStream->Write((void*)m_aRequests, sizeof(GUID) * m_dwNumRequests, 
                            NULL);
    if(FAILED(hres)) return hres;
    
    DWORD dwNum = m_aObjects.GetSize();
    hres = pStream->Write((void*)&dwNum, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        hres = m_aObjects[i]->Marshal(pStream);
        if(FAILED(hres)) return hres;
    }
    return S_OK;
}
    
STDMETHODIMP CWbemContext::UnmarshalInterface(IStream* pStream, REFIID riid, 
                            void** ppv)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;
    DWORD i;
    hres = pStream->Read((void*)&m_dwNumRequests, sizeof(DWORD), NULL);
    if(m_dwNumRequests > 0)
    {
        delete [] m_aRequests;
        m_aRequests = new GUID[m_dwNumRequests];
        hres = pStream->Read((void*)m_aRequests, sizeof(GUID) * m_dwNumRequests,
                                NULL);
        if(FAILED(hres)) return hres;
    }

    DWORD dwNum;
    hres = pStream->Read((void*)&dwNum, sizeof(DWORD), NULL);
    if(FAILED(hres)) return hres;

    for(i = 0; i < dwNum; i++)
    {
        m_aObjects.Add(new CContextObj);
        hres = m_aObjects[i]->Unmarshal(pStream);
        if(FAILED(hres)) return hres;
    }
    return QueryInterface(riid, ppv);
}
    
STDMETHODIMP CWbemContext::ReleaseMarshalData(IStream* pStream)
{
    CInCritSec ics(&m_cs);

    return S_OK;
}

STDMETHODIMP CWbemContext::DisconnectObject(DWORD dwReserved)
{
    CInCritSec ics(&m_cs);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\enummrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    ENUMMRSH.CPP

Abstract:

    Object Enumerator Marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "enummrsh.h"
#include <fastall.h>
#include <cominit.h>

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CEnumFactoryBuffer::XEnumFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CEnumFactoryBuffer::XEnumFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IEnumWbemClassObject)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CEnumProxyBuffer* pProxy = new CEnumProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CEnumFactoryBuffer::XEnumFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IEnumWbemClassObject 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CEnumFactoryBuffer::XEnumFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IEnumWbemClassObject)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CEnumStubBuffer* pStub = new CEnumStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {

        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CEnumFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CEnumFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CEnumFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XEnumFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CEnumProxyBuffer::CEnumProxyBuffer
//  ~CEnumProxyBuffer::CEnumProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CEnumProxyBuffer::CEnumProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IEnumWbemClassObject ),
        m_XEnumFacelet(this), m_pOldProxyEnum( NULL ), m_fTriedSmartEnum( FALSE ),
        m_fUseSmartEnum( FALSE ), m_hSmartNextMutex( INVALID_HANDLE_VALUE ),
        m_pSmartEnum( NULL )
{
    InitializeCriticalSection( &m_cs );
}

CEnumProxyBuffer::~CEnumProxyBuffer()
{
    if ( NULL != m_pSmartEnum )
    {
        m_pSmartEnum->Release();
    }

    // This MUST be released before releasing
    // the Proxy pointer
    if ( NULL != m_pOldProxyEnum )
    {
        m_pOldProxyEnum->Release();
    }

    // Cleanup the mutex
    if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
    {
        CloseHandle( m_hSmartNextMutex );
    }

    DeleteCriticalSection( &m_cs );

}

void* CEnumProxyBuffer::GetInterface( REFIID riid )
{
    if(riid == IID_IEnumWbemClassObject)
        return &m_XEnumFacelet;
    else return NULL;
}

void** CEnumProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxyEnum;
}

void CEnumProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxyEnum )
    {
        m_pOldProxyEnum->Release();
        m_pOldProxyEnum = NULL;
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return our security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

        // Make sure we have a smart enumerator and that we are going to
        // be using it.  If so, make sure the values applied to us are also
        // applied to it's proxy

        if ( SUCCEEDED( m_pObject->InitSmartEnum( TRUE, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities ) ) && m_pObject->m_fUseSmartEnum )
        {
            // Now repeat the above operation for the smart enumerator
            // Set the proxy blanket, ignore IUnknown if we are not going remote
            hr = WbemSetProxyBlanket( m_pObject->m_pSmartEnum, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_pObject->m_fRemote );

        }   // If initialized smart enumerator

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CEnumProxyBuffer::XEnumFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//////////////////////////////////////////////
//////////////////////////////////////////////

//  IEnumWbemClassObject Methods -- Pass Thrus for now

//////////////////////////////////////////////
//////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Reset()
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Reset();

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Next(long lTimeout, ULONG uCount, IWbemClassObject** apObj, ULONG FAR* puReturned)
{

    // At this point we will Query for the new, improved IEnumWCOSmartNext interface.
    // If we get it, we will maintain a pointer to that interface and
    // pass through to that interface.  We will also call CoCreateGuid() so
    // we get a unique identifier on the other end for sending wbem objects
    // back and forth cleanly.

    // The interface will have a single method IEnumWCOSmartNext::Next
    // This will take a GUID identifying this proxy, lTimeout, uCount,
    // puReturned, then dwBuffSize and BYTE**.

    // The other end will allocate memory via CoTaskMemAlloc and this side will
    // Free it via CoTaskMemFree.

    // The other side will Marshal returned objects into the memory block.
    // This side will Unmarshal it (and then free the block).

    //
    //  SAMPLE IDL:
    //  IEnumWCOSmartNext::Next(    [in] GUID proxyGUID,
    //                              [in] LONG lTimeout,
    //                              [in] unsigned long uCount,
    //                              [in, out] DWORD* puReturned,
    //                              [in, out] DWORD* pdwBuffSize,
    //                              [in, out, size_is[,*pdwBuffSize] BYTE** pBuffer
    //

    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure the timeout value makes sense and that puReturned and apObj are non-NULL
    if ( ( lTimeout < 0 && lTimeout != WBEM_INFINITE )  ||
        ( NULL == puReturned ) ||
        ( NULL == apObj ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Check that puReturned and apObj are non-NULL

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartEnum();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartEnum && NULL != m_pObject->m_pSmartEnum )
    {
        DWORD   dwOldTick = GetTickCount();
        DWORD   dwReturn = WaitForSingleObject( m_pObject->m_hSmartNextMutex, lTimeout );

        if (  WAIT_OBJECT_0 == dwReturn )
        {
            BYTE*   pBuffer = NULL;
            ULONG   uSizeOfBuffer = 0;

            // Adjust timeout (if it was > 0) for any milliseconds we may
            // have just been waiting.

            if ( lTimeout > 0 )
            {
                // Get the current tick count.  Be aware that a tick count will
                // rollover every 30 some odd days, so trap for this case by
                // checking that the new tick count >= the old one
                
                DWORD   dwCurrTick = GetTickCount();
                dwCurrTick = ( dwCurrTick >= dwOldTick ? dwCurrTick : dwOldTick );

                // Adjust the timeout, but don't let it fall below 0
                lTimeout -= ( dwCurrTick - dwOldTick );
                lTimeout = ( lTimeout < 0 ? 0 : lTimeout );
            }

            // Ask the server for objects
            hr = m_pObject->m_pSmartEnum->Next( m_pObject->m_guidSmartEnum, lTimeout, uCount, puReturned, &uSizeOfBuffer, &pBuffer );

            // Only need to unmarshal if objects are in the buffer
            if ( SUCCEEDED( hr ) && *puReturned > 0 )
            {

                CWbemSmartEnumNextPacket packet( (LPBYTE) pBuffer, uSizeOfBuffer );
                long lObjectCount; 
                IWbemClassObject ** pObjArray;

                // hr will contain the call's proper return code.  Make sure we don't override it unless
                // the unmarshaling fails.
                HRESULT hrUnmarshal = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

                if ( SUCCEEDED( hrUnmarshal ) )
                {
                    // Copy *puReturned pointers from the allocated pObjArray into apObj.
                    CopyMemory( apObj, pObjArray, ( *puReturned * sizeof(IWbemClassObject*) ) );

                    // Clean up pObjArray  It is the caller's responsibility to free
                    // the IWbemClassObject* pointers.
                    delete [] pObjArray;

                }   // IF UnmarshalPacket
                else
                {
                    hr = hrUnmarshal;
                }

                // Free the memory buffer (allocated by WinMgmt via CoTaskMemAlloc)
                CoTaskMemFree( pBuffer );

            }   // IF Next

            ReleaseMutex( m_pObject->m_hSmartNextMutex );

        }   // IF WAIT_OBJECT_0
        else if ( WAIT_TIMEOUT == dwReturn )
        {
            // Timed out on the mutex
            hr = WBEM_S_TIMEDOUT;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyEnum->Next( lTimeout, uCount, apObj, puReturned );
    }

    return hr;

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      NextAsync(ULONG uCount, IWbemObjectSink* pSink)
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->NextAsync( uCount, pSink );

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Clone(IEnumWbemClassObject** pEnum)
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Clone( pEnum );

}

HRESULT STDMETHODCALLTYPE CEnumProxyBuffer::XEnumFacelet::
      Skip(long lTimeout, ULONG nNum)
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyEnum->Skip( lTimeout, nNum );

}

//***************************************************************************
//
//  HRESULT CEnumProxyBuffer::InitSmartEnum(void)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  This function sets up
//  the smart enumerator pointer so we can perform intelligent marshaling.
//  This cannot be called during a Connect operation.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CEnumProxyBuffer::InitSmartEnum( BOOL fSetBlanket, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Function MUST be thread safe
    CInCritSec ics(&m_cs);

    // If we haven't tried to estalish smart enumeration, do so now

    // If we haven't tried to get a smart enumerator, try to get one.  If
    // we are able to get one, initialize member data we will use in all
    // operations from this proxy.

    if ( NULL == m_pSmartEnum )
    {

        // We'll only get this interface pointer if the server is a new
        // version that understands this interface.  If it does, the pointer
        // will be marshaled through for us.  To get to this pointer,
        // we go directly through our punkOuter.  From the "fetcher" interface
        // we will then get the actual smart enumerator.  We can then free up
        // the fetcher and release it's lock on the proxy manager.  The
        // smart enumerator will be handled on its own.

        IWbemFetchSmartEnum*    pFetchSmartEnum;

        hr = m_pUnkOuter->QueryInterface( IID_IWbemFetchSmartEnum, (void**) &pFetchSmartEnum );

        // Generate a GUID to identify us when we call the smart enumerator
        if ( SUCCEEDED( hr ) )
        {

            // If we need to, set the blanket on the proxy, otherwise, the call to GetSmartEnum
            // may fail.
            if ( fSetBlanket )
            {
                // Ignore the IUnknown if we are not remoting
                hr = WbemSetProxyBlanket( pFetchSmartEnum, AuthnSvc, AuthzSvc, pServerPrincName,
                            AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_fRemote );
            }

            if ( SUCCEEDED( hr ) )
            {

                hr = pFetchSmartEnum->GetSmartEnum( &m_pSmartEnum );

                if ( SUCCEEDED( hr ) )
                {
                    // We need a GUID
                    hr = CoCreateGuid( &m_guidSmartEnum );

                    if ( SUCCEEDED( hr ) )
                    {
                        // We'll also need a Mutex (so we can timeout) here

                        m_hSmartNextMutex = CreateMutex( NULL, FALSE, NULL );

                        if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
                        {
                            // We have everything we need to do things smartly
                            m_fUseSmartEnum = TRUE;
                        }
                    }   // IF CoCreateGuid

                }   // IF got Smart Enumerator

            }   // IF security OK
            
            // Done with the fetcher interface
            pFetchSmartEnum->Release();

        }   // IF QueryInterface
        else
        {
            hr = WBEM_S_NO_ERROR;
        }

    }   // IF NULL == m_pSmartEnum

    return hr;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CEnumFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CEnumFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CEnumStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XEnumStublet;
    else
        return NULL;
}

CEnumStubBuffer::XEnumStublet::XEnumStublet(CEnumStubBuffer* pObj) 
    : CBaseStublet( pObj, IID_IEnumWbemClassObject ), m_pServer(NULL)
{
}

CEnumStubBuffer::XEnumStublet::~XEnumStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CEnumStubBuffer::XEnumStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CEnumStubBuffer::XEnumStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CEnumStubBuffer::XEnumStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\mtgtmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    MTGTMRSH.CPP

Abstract:

    Multi Target Marshaling.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "mtgtmrsh.h"
#include <fastall.h>
#include <cominit.h>

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CMultiTargetFactoryBuffer::XEnumFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetFactoryBuffer::XEnumFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemMultiTarget)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CMultiTargetProxyBuffer* pProxy = new CMultiTargetProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CMultiTargetFactoryBuffer::XEnumFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemMultiTarget 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CMultiTargetFactoryBuffer::XEnumFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemMultiTarget)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CMultiTargetStubBuffer* pStub = new CMultiTargetStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CMultiTargetFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XEnumFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CMultiTargetProxyBuffer::CMultiTargetProxyBuffer
//  ~CMultiTargetProxyBuffer::CMultiTargetProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CMultiTargetProxyBuffer::CMultiTargetProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
        m_XMultiTargetFacelet(this), m_pChannel(NULL), m_pOldProxy( NULL ), m_pOldProxyMultiTarget( NULL ),
        m_fTriedSmartEnum( FALSE ), m_fUseSmartMultiTarget( FALSE ), m_hSmartNextMutex( INVALID_HANDLE_VALUE ),
        m_pSmartMultiTarget( NULL ), m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
    InitializeCriticalSection( &m_cs );
//    m_StubType = UNKNOWN;

}

CMultiTargetProxyBuffer::~CMultiTargetProxyBuffer()
{
    if ( NULL != m_pSmartMultiTarget )
    {
        m_pSmartMultiTarget->Release();
    }

    // This MUST be released before releasing
    // the Proxy pointer
    if ( NULL != m_pOldProxyMultiTarget )
    {
        m_pOldProxyMultiTarget->Release();
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();

    // Cleanup the mutex
    if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
    {
        CloseHandle( m_hSmartNextMutex );
    }

    m_pControl->ObjectDestroyed(this);

    DeleteCriticalSection( &m_cs );

}

ULONG STDMETHODCALLTYPE CMultiTargetProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CMultiTargetProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemMultiTarget)
    {
        *ppv = (IWbemMultiTarget*)&m_XMultiTargetFacelet;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return our security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
    // may have to go remote

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );

    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

        // Make sure we have a smart enumerator and that we are going to
        // be using it.  If so, make sure the values applied to us are also
        // applied to it's proxy

        if ( SUCCEEDED( m_pObject->InitSmartMultiTarget( TRUE, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities ) ) && m_pObject->m_fUseSmartMultiTarget )
        {
            // Now repeat the above operation for the smart enumerator
            // Ignore the IUnknown if we are not remoting
            hr = WbemSetProxyBlanket(  m_pObject->m_pSmartMultiTarget, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_pObject->m_fRemote );

        }   // If initialized smart enumerator

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//////////////////////////////////////////////
//////////////////////////////////////////////

//  IWbemMultiTarget Methods -- Pass Thrus for now

//////////////////////////////////////////////
//////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
DeliverEvent(DWORD dwNumEvents, IWbemClassObject** apEvents, WBEM_REM_TARGETS* aTargets,
           long lSDLength, BYTE* pSD)
{
    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartMultiTarget();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartMultiTarget && NULL != m_pObject->m_pSmartMultiTarget )
    {

        // Function MUST be thread safe
        CInCritSec ics(&m_pObject->m_cs);

        // Calculate data length first 
        DWORD dwLength;

        GUID*   pGUIDs = NULL;
        BOOL*   pfSendFullObject = NULL;

        try
        {
            // Allocate arrays for the guid and the flags
            pGUIDs = new GUID[dwNumEvents];
            pfSendFullObject = new BOOL[dwNumEvents];

            CWbemMtgtDeliverEventPacket packet;
            hr = packet.CalculateLength(dwNumEvents, apEvents, &dwLength, 
                    m_ClassToIdMap, pGUIDs, pfSendFullObject );

            if ( SUCCEEDED( hr ) )
            {

                // As we could be going cross process/machine, use the
                // COM memory allocator
                LPBYTE pbData = (LPBYTE) CoTaskMemAlloc( dwLength );

                if ( NULL != pbData )
                {

                    // Write the objects out to the buffer
                    hr = packet.MarshalPacket( pbData, dwLength, dwNumEvents, 
                                                apEvents, pGUIDs, pfSendFullObject);

                    // Copy the values, we're golden.
                    if ( SUCCEEDED( hr ) )
                    {
                        // Now we can send the data to the stub
                        hr = m_pObject->m_pSmartMultiTarget->DeliverEvent( dwNumEvents, dwLength, pbData, aTargets, lSDLength, pSD );
                    }

                    // Because the buffer is an [in] parameter, it lies on our heads
                    // to free it up.
                    CoTaskMemFree( pbData );
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }   // IF CalculateLength()
        }
        catch (CX_MemoryException)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        catch(...)
        {
            hr = WBEM_E_FAILED;
        }

        // Cleanup the arrays
        if ( NULL != pGUIDs )
        {
            delete [] pGUIDs;
        }

        if ( NULL != pfSendFullObject )
        {
            delete pfSendFullObject;
        }

    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyMultiTarget->DeliverEvent(dwNumEvents, apEvents, aTargets, lSDLength, pSD );
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
DeliverStatus( long lFlags, HRESULT hresStatus, LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
            WBEM_REM_TARGETS* pTargets, long lSDLength, BYTE* pSD)
{
    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyMultiTarget->DeliverStatus( lFlags, hresStatus, wszStatus, pErrorObj, pTargets, lSDLength, pSD );
}

/*
HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
      Next(long lTimeout, ULONG uCount, IWbemClassObject** apObj, ULONG FAR* puReturned)
{

    // At this point we will Query for the new, improved IEnumWCOSmartNext interface.
    // If we get it, we will maintain a pointer to that interface and
    // pass through to that interface.  We will also call CoCreateGuid() so
    // we get a unique identifier on the other end for sending wbem objects
    // back and forth cleanly.

    // The interface will have a single method IEnumWCOSmartNext::Next
    // This will take a GUID identifying this proxy, lTimeout, uCount,
    // puReturned, then dwBuffSize and BYTE**.

    // The other end will allocate memory via CoTaskMemAlloc and this side will
    // Free it via CoTaskMemFree.

    // The other side will Marshal returned objects into the memory block.
    // This side will Unmarshal it (and then free the block).

    //
    //  SAMPLE IDL:
    //  IEnumWCOSmartNext::Next(    [in] GUID proxyGUID,
    //                              [in] LONG lTimeout,
    //                              [in] unsigned long uCount,
    //                              [in, out] DWORD* puReturned,
    //                              [in, out] DWORD* pdwBuffSize,
    //                              [in, out, size_is[,*pdwBuffSize] BYTE** pBuffer
    //

    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure the timeout value makes sense
    if ( lTimeout < 0 && lTimeout != WBEM_INFINITE )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartMultiTarget();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartMultiTarget && NULL != m_pObject->m_pSmartMultiTarget )
    {
        DWORD   dwOldTick = GetTickCount();
        DWORD   dwReturn = WaitForSingleObject( m_pObject->m_hSmartNextMutex, lTimeout );

        if (  WAIT_OBJECT_0 == dwReturn )
        {
            BYTE*   pBuffer = NULL;
            ULONG   uSizeOfBuffer = 0;

            // Adjust timeout (if it was > 0) for any milliseconds we may
            // have just been waiting.

            if ( lTimeout > 0 )
            {
                // Get the current tick count.  Be aware that a tick count will
                // rollover every 30 some odd days, so trap for this case by
                // checking that the new tick count >= the old one
                
                DWORD   dwCurrTick = GetTickCount();
                dwCurrTick = ( dwCurrTick >= dwOldTick ? dwCurrTick : dwOldTick );

                // Adjust the timeout, but don't let it fall below 0
                lTimeout -= ( dwCurrTick - dwOldTick );
                lTimeout = ( lTimeout < 0 ? 0 : lTimeout );
            }

            // Ask the server for objects
            hr = m_pObject->m_pSmartMultiTarget->Next( m_pObject->m_guidSmartEnum, lTimeout, uCount, puReturned, &uSizeOfBuffer, &pBuffer );

            // Only need to unmarshal if objects are in the buffer
            if ( SUCCEEDED( hr ) && *puReturned > 0 )
            {

                CWbemSmartEnumNextPacket packet( (LPBYTE) pBuffer, uSizeOfBuffer );
                long lObjectCount; 
                IWbemClassObject ** pObjArray;
                hr = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

                if ( SUCCEEDED( hr ) )
                {
                    // Copy *puReturned pointers from the allocated pObjArray into apObj.
                    CopyMemory( apObj, pObjArray, ( *puReturned * sizeof(IWbemClassObject*) ) );

                    // Clean up pObjArray  It is the caller's responsibility to free
                    // the IWbemClassObject* pointers.
                    delete [] pObjArray;

                }   // IF UnmarshalPacket

                // Free the memory buffer (allocated by WinMgmt via CoTaskMemAlloc)
                CoTaskMemFree( pBuffer );

            }   // IF Next

            ReleaseMutex( m_pObject->m_hSmartNextMutex );

        }   // IF WAIT_OBJECT_0
        else if ( WAIT_TIMEOUT == dwReturn )
        {
            // Timed out on the mutex
            hr = WBEM_S_TIMEDOUT;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyMultiTarget->Next( lTimeout, uCount, apObj, puReturned );
    }

    return hr;

}
*/

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    // get a pointer to the old sink which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // Establish the marshaling context
    DWORD   dwCtxt = 0;
    pChannel->GetDestCtx( &dwCtxt, NULL );

    m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

    // We aggregated it --- WE OWN IT!
    
    hr = pIPS->CreateProxy( this, IID_IWbemMultiTarget, &m_pOldProxy, (void**) &m_pOldProxyMultiTarget );
    pIPS->Release();

    // Connect the old proxy to the channel
    hr = m_pOldProxy->Connect( pChannel );

    // Save an internal reference to the channel
    if(m_pChannel)
        return E_UNEXPECTED;
    
    m_pChannel = pChannel;
    if(m_pChannel)
        m_pChannel->AddRef();

    return hr;
}

//***************************************************************************
//
//  HRESULT CMultiTargetProxyBuffer::InitSmartMultiTarget(void)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  This function sets up
//  the smart enumerator pointer so we can perform intelligent marshaling.
//  This cannot be called during a Connect operation.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CMultiTargetProxyBuffer::InitSmartMultiTarget( BOOL fSetBlanket, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Function MUST be thread safe
    CInCritSec ics(&m_cs);

    // If we haven't tried to estalish smart enumeration, do so now

    // If we haven't tried to get a smart enumerator, try to get one.  If
    // we are able to get one, initialize member data we will use in all
    // operations from this proxy.

    if ( NULL == m_pSmartMultiTarget )
    {

        // We'll only get this interface pointer if the server is a new
        // version that understands this interface.  If it does, the pointer
        // will be marshaled through for us.  To get to this pointer,
        // we go directly through our punkOuter.  From the "fetcher" interface
        // we will then get the actual smart enumerator.  We can then free up
        // the fetcher and release it's lock on the proxy manager.  The
        // smart enumerator will be handled on its own.

        IWbemFetchSmartMultiTarget* pFetchSmartMultiTarget;

        hr = m_pUnkOuter->QueryInterface( IID_IWbemFetchSmartMultiTarget, (void**) &pFetchSmartMultiTarget );

        // Generate a GUID to identify us when we call the smart enumerator
        if ( SUCCEEDED( hr ) )
        {

            // If we need to, set the blanket on the proxy, otherwise, the call to GetSmartEnum
            // may fail.
            if ( fSetBlanket )
            {
                // Ignore the IUnknown if we are not remoting
                hr = WbemSetProxyBlanket( pFetchSmartMultiTarget, AuthnSvc, AuthzSvc, pServerPrincName,
                            AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_fRemote );
            }

            if ( SUCCEEDED( hr ) )
            {

                hr = pFetchSmartMultiTarget->GetSmartMultiTarget( &m_pSmartMultiTarget );

                if ( SUCCEEDED( hr ) )
                {
                    // We need a GUID
                    hr = CoCreateGuid( &m_guidSmartEnum );

                    if ( SUCCEEDED( hr ) )
                    {
                        // We'll also need a Mutex (so we can timeout) here

                        m_hSmartNextMutex = CreateMutex( NULL, FALSE, NULL );

                        if ( INVALID_HANDLE_VALUE != m_hSmartNextMutex )
                        {
                            // We have everything we need to do things smartly
                            m_fUseSmartMultiTarget = TRUE;
                        }
                    }   // IF CoCreateGuid

                }   // IF got Smart MultiTarget

            }   // IF security OK
            
            // Done with the fetcher interface
            pFetchSmartMultiTarget->Release();

        }   // IF QueryInterface
        else
        {
            hr = WBEM_S_NO_ERROR;
        }

    }   // IF NULL == m_pSmartMultiTarget

    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CMultiTargetProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old Proxy Enum MUST be released first.

    if ( NULL != m_pOldProxyMultiTarget )
    {
        m_pOldProxyMultiTarget->Release();
        m_pOldProxyMultiTarget = NULL;
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CMultiTargetFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CMultiTargetStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XMultiTargetStublet;
    else
        return NULL;
}

CMultiTargetStubBuffer::XMultiTargetStublet::XMultiTargetStublet(CMultiTargetStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CMultiTargetStubBuffer>(pObj), m_pServer(NULL), m_lConnections( 0 )
{
}

CMultiTargetStubBuffer::XMultiTargetStublet::~XMultiTargetStublet() 
{
    if(m_pServer)
        m_pServer->Release();

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject sink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemMultiTarget, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // get a pointer to the old stub which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

    hr = pIPS->CreateStub( IID_IWbemMultiTarget, m_pServer, &m_pObject->m_pOldStub );

    pIPS->Release();

    // Successful connection

    m_lConnections++;
    return S_OK;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemMultiTarget
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    if(m_pServer)
    {
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Successful disconnect
    m_lConnections--;

}


//***************************************************************************
//
//  STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer
    return m_pObject->m_pOldStub->Invoke( pMessage, pChannel );
}

IRpcStubBuffer* STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemMultiTarget)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\mtgtmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    MTGTMRSH.H

Abstract:

    Multi Target Marshaling.

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include "wbemclasscache.h"
#include "wbemclasstoidmap.h"
#include "mtgtpckt.h"

//***************************************************************************
//
//  class CMultiTargetFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CMultiTargetFactoryBuffer : public CUnk
{

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XEnumFactory : public CImpl<IPSFactoryBuffer, CMultiTargetFactoryBuffer>
    {
    public:
        XEnumFactory(CMultiTargetFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CMultiTargetFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XEnumFactory;
public:
    CMultiTargetFactoryBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(NULL, pUnkOuter), m_XEnumFactory(this), m_pLifeControl( pControl )
    {}

    void* GetInterface(REFIID riid);

	friend XEnumFactory;
};

//***************************************************************************
//
//  class CMultiTargetProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CMultiTargetProxyBuffer : public IRpcProxyBuffer
{
private:
	IRpcProxyBuffer*		m_pOldProxy;
	IWbemMultiTarget*		m_pOldProxyMultiTarget;
    BOOL					m_fTriedSmartEnum;
    BOOL					m_fUseSmartMultiTarget;
	HANDLE					m_hSmartNextMutex;
	GUID					m_guidSmartEnum;
	IWbemSmartMultiTarget*	m_pSmartMultiTarget;
	CRITICAL_SECTION		m_cs;
	bool				m_fRemote;

protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XMultiTargetFacelet : public IWbemMultiTarget, IClientSecurity
    {
    protected:
        CMultiTargetProxyBuffer*	m_pObject;
	    CWbemClassToIdMap			m_ClassToIdMap;

    public:
        XMultiTargetFacelet(CMultiTargetProxyBuffer* pObject) : m_pObject(pObject){};
        ~XMultiTargetFacelet(){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

		// IWbemMultiTarget Methods
		STDMETHOD(DeliverEvent)(
            /*[in]*/ DWORD dwNumEvents,
			/*[in]*/ IWbemClassObject** apEvents,
			/*[in]*/ WBEM_REM_TARGETS* aTargets,
            /*[in]*/ long lSDLength,
            /*[in, size_is(lSDLength)]*/ BYTE* pSD);

		STDMETHOD(DeliverStatus)(
			/*[in]*/ long lFlags,
			/*[in]*/ HRESULT hresStatus,
			/*[in, string]*/ LPCWSTR wszStatus,
			/*[in]*/ IWbemClassObject* pErrorObj,
			/*[in]*/ WBEM_REM_TARGETS* pTargets,
            /*[in]*/ long lSDLength,
            /*[in, size_is(lSDLength)]*/ BYTE* pSD);

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XMultiTargetFacelet;
    friend XMultiTargetFacelet;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

	// Initialize the smart enumerator
	HRESULT InitSmartMultiTarget( BOOL fSetBlanket = FALSE, DWORD AuthnSvc = RPC_C_AUTHN_WINNT,
			DWORD AuthzSvc = RPC_C_AUTHZ_NONE, OLECHAR* pServerPrincName = NULL,
			DWORD AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT, DWORD ImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE,
			void* pAuthInfo = NULL, DWORD Capabilities = EOAC_NONE );

public:
    CMultiTargetProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CMultiTargetProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CMultiTargetStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CMultiTargetStubBuffer : public CUnk
{
private:

	IRpcStubBuffer*	m_pOldStub;

protected:
    class XMultiTargetStublet : public CImpl<IRpcStubBuffer, CMultiTargetStubBuffer>
    {
        IWbemObjectSink* m_pServer;
		LONG			m_lConnections;

    public:
        XMultiTargetStublet(CMultiTargetStubBuffer* pObj);
        ~XMultiTargetStublet();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
	private:

        friend CMultiTargetStubBuffer;
    } m_XMultiTargetStublet;
    friend XMultiTargetStublet;

public:
    CMultiTargetStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XMultiTargetStublet(this), m_pOldStub( NULL )
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\mrshbase.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MRSHBASE.CPP

Abstract:

    Marshaling base classes.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "mrshbase.h"
#include <fastall.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CBaseProxyBuffer::CBaseProxyBuffer
//  ~CBaseProxyBuffer::CBaseProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CBaseProxyBuffer::CBaseProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter, REFIID riid)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
       m_pChannel(NULL), m_pOldProxy( NULL ), m_riid( riid ), m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
}

CBaseProxyBuffer::~CBaseProxyBuffer()
{
    // Derived class will destruct first, so it should have cleaned up the
    // old interface pointer by now.

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pControl->ObjectDestroyed(this);

}

ULONG STDMETHODCALLTYPE CBaseProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CBaseProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CBaseProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == m_riid)
    {
        *ppv = GetInterface( riid );
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  STDMETHODIMP CBaseProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CBaseProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    IPSFactoryBuffer*   pIPS;
    HRESULT             hr = S_OK;

    if( NULL == m_pChannel )
    {

        // Establish the marshaling context
        DWORD   dwCtxt = 0;
        pChannel->GetDestCtx( &dwCtxt, NULL );

        m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

        // This is tricky -- All WBEM Interface Proxy/Stubs are still available
        // in WBEMSVC.DLL, but the CLSID for the PSFactory is the same as
        // IID_IWbemObjectSink.

        // get a pointer to the old interface which is in WBEMSVC.DLL  this allows
        // for backward compatibility

        hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                        NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

        // We aggregated it --- WE OWN IT!
        
        if ( SUCCEEDED( hr ) )
        {
            hr = pIPS->CreateProxy( this, m_riid, &m_pOldProxy, GetOldProxyInterfacePtr() );

            if ( SUCCEEDED( hr ) )
            {
                // Save a reference to the channel

                hr = m_pOldProxy->Connect( pChannel );

                m_pChannel = pChannel;
                if(m_pChannel)
                    m_pChannel->AddRef();
            }

            pIPS->Release();
        }

    }
    else
    {
        hr = E_UNEXPECTED;
    }


    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CBaseProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CBaseProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old interfaces MUST be released first.

    ReleaseOldProxyInterface();

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

/*
**  Stub Buffer Code
*/

CBaseStublet::CBaseStublet(CBaseStubBuffer* pObj, REFIID riid) 
    : CImpl<IRpcStubBuffer, CBaseStubBuffer>(pObj), m_lConnections( 0 ), m_riid( riid )
{
}

CBaseStublet::~CBaseStublet() 
{
    // The server pointer will have been cleaned up by the derived class

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CBaseStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject sink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CBaseStublet::Connect(IUnknown* pUnkServer)
{
    // Something is wrong
    if( GetServerInterface() )
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface( m_riid, GetServerPtr() );
    if(FAILED(hres))
        return E_NOINTERFACE;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    IPSFactoryBuffer*   pIPS;

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

    if ( SUCCEEDED( hr ) )
    {
        hr = pIPS->CreateStub( m_riid, GetServerInterface(), &m_pObject->m_pOldStub );

        if ( SUCCEEDED( hr ) )
        {
            // Successful connection
            m_lConnections++;
        }

        pIPS->Release();

    }

    return hr;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CBaseStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemObjectSink
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CBaseStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    ReleaseServerPointer();

    // Successful disconnect
    m_lConnections--;

}

STDMETHODIMP CBaseStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( NULL != m_pObject->m_pOldStub )
    {
        return m_pObject->m_pOldStub->Invoke( pMessage, pChannel );
    }
    else
    {
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;
    }
}

IRpcStubBuffer* STDMETHODCALLTYPE CBaseStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == m_riid)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CBaseStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CBaseStublet::DebugServerQueryInterface(void** ppv)
{
    *ppv = GetServerInterface();

    if ( NULL == *ppv )
    {
        return E_UNEXPECTED;
    }

    return S_OK;
}

void STDMETHODCALLTYPE CBaseStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADDRESLV.H

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <localloc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\refrmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRMRSH.H

Abstract:

    Refresher marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemcomn.h>
#include <sync.h>

class CEventPair
{
protected:
    HANDLE m_hGoEvent;
    HANDLE m_hDoneEvent;
public:
    CEventPair() : m_hGoEvent(NULL), m_hDoneEvent(NULL){}
    ~CEventPair();

    HANDLE GetGoEvent() {return m_hGoEvent;}
    HANDLE GetDoneEvent() {return m_hDoneEvent;}

    void Create();
    DWORD GetDataLength();
    void WriteData(DWORD dwClientPID, void* pvBuffer);
    void ReadData(void* pvBuffer);
    HRESULT SetAndWait();
};

class CRefreshDispatcher
{
protected:
    CCritSec m_cs;

    CFlexArray m_aGoEvents;
    struct CRecord
    {
        IWbemRefresher* m_pRefresher;
        HANDLE m_hDoneEvent;

        CRecord(IWbemRefresher* pRefresher, HANDLE hDoneEvent)
            : m_pRefresher(pRefresher), m_hDoneEvent(hDoneEvent)
        {
            m_pRefresher->AddRef();
        }
        ~CRecord()
        {
            m_pRefresher->Release();
        }
    };

    CUniquePointerArray<CRecord> m_apRecords;
    HANDLE m_hAttentionEvent;
    HANDLE m_hAcceptanceEvent;

    HANDLE m_hNewGoEvent;
    HANDLE m_hNewDoneEvent;
    IWbemRefresher* m_pNewRefresher;

    HANDLE m_hThread;

protected:
    DWORD Worker();
    static DWORD staticWorker(void*);
    BOOL ProcessAttentionRequest();

public:
    CRefreshDispatcher();
    ~CRefreshDispatcher();

    BOOL Add(HANDLE hGoEvent, HANDLE hDoneEvent, 
                            IWbemRefresher* pRefresher);
    BOOL Remove(IWbemRefresher* pRefresher);
    BOOL Stop();
};

class CFactoryBuffer : public CUnk
{
protected:
    class XFactory : public CImpl<IPSFactoryBuffer, CFactoryBuffer>
    {
    public:
        XFactory(CFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XFactory;
public:
    CFactoryBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XFactory(this)
    {}
    void* GetInterface(REFIID riid);
};

/*
    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
    is its "internal" interface --- the interface that does not delegate to the
    aggregator. (Unlike in normal objects, where that interface is IUnknown)
*/
class CProxyBuffer : public IRpcProxyBuffer
{
protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XRefresher : public IWbemRefresher
    {
    protected:
        CProxyBuffer* m_pObject;
    public:
        XRefresher(CProxyBuffer* pObject) : m_pObject(pObject){}

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE Refresh(long lFlags);
    } m_XRefresher;
    friend XRefresher;

protected:
    IRpcChannelBuffer* m_pChannel;
    CEventPair m_EventPair;

public:
    CProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
        : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
            m_XRefresher(this), m_pChannel(NULL)
    {
        m_pControl->ObjectCreated(this);
    }
    ~CProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

class CStubBuffer : public CUnk
{
protected:
    class XStub : public CImpl<IRpcStubBuffer, CStubBuffer>
    {
        static CRefreshDispatcher mstatic_Dispatcher;

        CEventPair m_EventPair;
        IWbemRefresher* m_pServer;
    public:
        XStub(CStubBuffer* pObj);
        ~XStub();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
        friend CStubBuffer;
    } m_XStub;
    friend XStub;

public:
    CStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XStub(this)
    {}
    void* GetInterface(REFIID riid);
    static void Clear() {XStub::mstatic_Dispatcher.Stop();}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\proxmain.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PROXMAIN.CPP

Abstract:

    Main DLL entry points

History:

--*/

#include "precomp.h"
#include "fastprox.h"
#include <context.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <hiperfenum.h>
#include <refrenum.h>
#include <refrcli.h>
#include "sinkmrsh.h"
#include "enummrsh.h"
#include "ubskmrsh.h"
#include "mtgtmrsh.h"
#include <filtprox.h>

// {71285C44-1DC0-11d2-B5FB-00104B703EFD}
const CLSID CLSID_IWbemObjectSinkProxyStub = { 0x71285c44, 0x1dc0, 0x11d2, { 0xb5, 0xfb, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0xfd } };

// {1B1CAD8C-2DAB-11d2-B604-00104B703EFD}
const CLSID CLSID_IEnumWbemClassObjectProxyStub = { 0x1b1cad8c, 0x2dab, 0x11d2, { 0xb6, 0x4, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0xfd } };

// {29B5828C-CAB9-11d2-B35C-00105A1F8177}
const CLSID CLSID_IWbemUnboundObjectSinkProxyStub = { 0x29b5828c, 0xcab9, 0x11d2, { 0xb3, 0x5c, 0x0, 0x10, 0x5a, 0x1f, 0x81, 0x77 } };

// {7016F8FA-CCDA-11d2-B35C-00105A1F8177}
static const CLSID CLSID_IWbemMultiTargetProxyStub = { 0x7016f8fa, 0xccda, 0x11d2, { 0xb3, 0x5c, 0x0, 0x10, 0x5a, 0x1f, 0x81, 0x77 } };

class CMyServer : public CComServer
{
public:
    void Initialize()
    {
        AddClassInfo(CLSID_WbemClassObjectProxy, 
            new CSimpleClassFactory<CFastProxy>(GetLifeControl()),
            __TEXT("WbemClassObject Marshalling proxy"), TRUE);
        
        AddClassInfo(CLSID_WbemContext,
            new CSimpleClassFactory<CWbemContext>(GetLifeControl()),
            __TEXT("Call Context"), TRUE);

        AddClassInfo(CLSID_WbemRefresher,
            new CClassFactory<CUniversalRefresher>(GetLifeControl()),
            __TEXT("Universal Refresher"), TRUE);

        AddClassInfo(CLSID_IWbemObjectSinkProxyStub,
            new CSinkFactoryBuffer(GetLifeControl()), 
            __TEXT("(non)Standard Marshaling for IWbemObjectSink"), TRUE);

        AddClassInfo(CLSID_IEnumWbemClassObjectProxyStub,
            new CEnumFactoryBuffer(GetLifeControl()), 
            __TEXT("(non)Standard Marshaling for IEnumWbemClassObject"), TRUE);

        AddClassInfo(CLSID_WbemUninitializedClassObject,
            new CClassObjectFactory(GetLifeControl()), 
            __TEXT("Uninitialized WbemClassObject for transports"), TRUE);

        AddClassInfo(CLSID_WbemFilterProxy,
            new CSimpleClassFactory<CFilterProxy>(GetLifeControl()), 
            __TEXT("Event filter marshaling proxy"), TRUE);

        AddClassInfo(CLSID_IWbemUnboundObjectSinkProxyStub,
            new CUnboundSinkFactoryBuffer(GetLifeControl()), 
            __TEXT("(non)Standard Marshaling for IWbemUnboundObjectSink"), TRUE);

        AddClassInfo(CLSID_IWbemMultiTargetProxyStub,
            new CMultiTargetFactoryBuffer(GetLifeControl()), 
            __TEXT("(non)Standard Marshaling for IWbemMultiTarget"), TRUE);

    }
    void Uninitialize()
    {
        CUniversalRefresher::Flush();
    }
    void Register()
    {
        RegisterInterfaceMarshaler(IID_IWbemObjectSink, CLSID_IWbemObjectSinkProxyStub,
                __TEXT("IWbemObjectSink"), 5, IID_IUnknown);
        RegisterInterfaceMarshaler(IID_IEnumWbemClassObject, CLSID_IEnumWbemClassObjectProxyStub,
                __TEXT("IEnumWbemClassObject"), 5, IID_IUnknown);
        // This guy only has 4 methods
        RegisterInterfaceMarshaler(IID_IWbemUnboundObjectSink, CLSID_IWbemUnboundObjectSinkProxyStub,
                __TEXT("IWbemUnboundObjectSink"), 4, IID_IUnknown);
        // This guy only has 4 methods
        RegisterInterfaceMarshaler(IID_IWbemMultiTarget, CLSID_IWbemMultiTargetProxyStub,
                __TEXT("IWbemMultiTarget"), 5, IID_IUnknown);
    }
    void Unregister()
    {
        UnregisterInterfaceMarshaler(IID_IWbemObjectSink);
        UnregisterInterfaceMarshaler(IID_IEnumWbemClassObject);
        UnregisterInterfaceMarshaler(IID_IWbemUnboundObjectSink);
        UnregisterInterfaceMarshaler(IID_IWbemMultiTarget);
    }
    void PostUninitialize();

} Server;
            
void CMyServer::PostUninitialize()
{
    // This is called during DLL shutdown. Normally, we wouldn't want to do 
    // anything here, but Windows 95 has an unfortunate bug in that in its
    // CoUninitize it first unloads all COM server DLLs that it has and *then*
    // attempts to release any error object that may be outstanding at that
    // time. This, obviously, causes a crash, since Release code is no longer
    // there. Hence, during our dll unload (DllCanUnloadNow is not called on
    // shutdown), we check if an error object of ours is outstanding and clear
    // it if so.

    IErrorInfo* pInfo = NULL;
    if(SUCCEEDED(GetErrorInfo(0, &pInfo)) && pInfo != NULL)
    {
        IWbemClassObject* pObj;
        if(SUCCEEDED(pInfo->QueryInterface(IID_IWbemClassObject, 
                                            (void**)&pObj)))
        {
            // Our error object is outstanding at the DLL shutdown time.
            // Release it
            // =========================================================

            pObj->Release();
            pInfo->Release();
        }
        else
        {
            // It's not ours
            // =============

            SetErrorInfo(0, pInfo);
            pInfo->Release();
        }
    }
}


void ObjectCreated(DWORD dwType)
{
    Server.GetLifeControl()->ObjectCreated(NULL);
}

void ObjectDestroyed(DWORD dwType)
{
    Server.GetLifeControl()->ObjectDestroyed(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\refrcli.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCLI.CPP

Abstract:

    Refresher Client Side Code.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <process.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <hiperfenum.h>
#include <refrenum.h>
#include <refrcli.h>
#include <sync.h>
#include <provinit.h>
#include <cominit.h>

//*****************************************************************************
//*****************************************************************************
//                              XCREATE
//*****************************************************************************
//*****************************************************************************

STDMETHODIMP CUniversalRefresher::XCreate::AddObjectByPath(
    IWbemServices* pNamespace, LPCWSTR wszPath,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == wszPath || NULL == ppRefreshable || NULL == *wszPath )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Validate flags
    if ( ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        // Acquire internal connection to WINMGMT
        // ====================================

        IWbemRefreshingServices* pRefServ = NULL;

        // Storage for security settings we will need in order to propagate
        // down to our internal interfaces.

        COAUTHINFO  CoAuthInfo;

        // Make sure this is totally empty
        ZeroMemory( &CoAuthInfo, sizeof(CoAuthInfo) );

        hres = m_pObject->GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );

        if ( FAILED( hres ) )
        {
            return hres;
        }
        
        // This guarantees this will be freed when we drop out of scope.  If we store
        // it we will need to allocate an internal copy.

        CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

        // Forward this request
        // ====================

        CRefreshInfo Info;
        DWORD       dwRemoteRefrVersion = 0;

        hres = pRefServ->AddObjectToRefresher(&m_pObject->m_Id, wszPath, lFlags,
                    pContext, WBEM_REFRESHER_VERSION, &Info, &dwRemoteRefrVersion);
        if(FAILED(hres)) 
        {
            pRefServ->Release();
            return hres;
        }

        // Act on the information
        // ======================

        switch(Info.m_lType)
        {
            case WBEM_REFRESH_TYPE_CLIENT_LOADABLE:
                hres = m_pObject->AddClientLoadable(Info.m_Info.m_ClientLoadable, 
                            pNamespace, ppRefreshable, plId);
                break;

            case WBEM_REFRESH_TYPE_DIRECT:
                hres = m_pObject->AddDirect(Info.m_Info.m_Direct, 
                            pNamespace, ppRefreshable, plId);
                break;

            case WBEM_REFRESH_TYPE_REMOTE:

                if ( SUCCEEDED( hres ) )
                {
                    hres = m_pObject->AddRemote( pRefServ, Info.m_Info.m_Remote, wszPath,
                            Info.m_lCancelId, ppRefreshable, plId, &CoAuthInfo);
                }

                break;

            default:
                hres = WBEM_E_INVALID_OPERATION;
        }

        pRefServ->Release();
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}

STDMETHODIMP CUniversalRefresher::XCreate::AddObjectByTemplate(
    IWbemServices* pNamespace, 
    IWbemClassObject* pTemplate,
    long lFlags, IWbemContext* pContext, 
    IWbemClassObject** ppRefreshable, long* plId)
{

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == pTemplate || NULL == ppRefreshable || 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Check that this is an instance object
    if ( ! ((CWbemObject*)pTemplate)->IsInstance() )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CVar vPath;
    ((CWbemObject*)pTemplate)->GetRelPath(&vPath);
    return AddObjectByPath(pNamespace, vPath.GetLPWSTR(), lFlags, pContext,
                            ppRefreshable, plId);
}

STDMETHODIMP CUniversalRefresher::XCreate::AddRefresher(
                    IWbemRefresher* pRefresher, long lFlags, long* plId)
{

    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pRefresher || 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        hres = m_pObject->AddRefresher( pRefresher, lFlags, plId );
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;

}

STDMETHODIMP CUniversalRefresher::XCreate::Remove(long lId, long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid flag values
    if ( ( lFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        hres = m_pObject->Remove(lId, lFlags);
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}

HRESULT CUniversalRefresher::XCreate::AddEnum( IWbemServices* pNamespace, LPCWSTR wszClassName,
                                long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
                                long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == wszClassName || NULL == ppEnum || NULL == *wszClassName )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Validate flags
    if ( ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {

        // Acquire internal connection to WINMGMT
        // ====================================

        IWbemRefreshingServices* pRefServ = NULL;

        // Storage for security settings we will need in order to propagate
        // down to our internal interfaces.

        COAUTHINFO  CoAuthInfo;

        // Make sure this is totally empty
        ZeroMemory( &CoAuthInfo, sizeof(CoAuthInfo) );

        hres = m_pObject->GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );

        if ( FAILED( hres ) )
        {
            return hres;
        }
        
        // This guarantees this will be freed when we drop out of scope
        CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

        // Forward this request
        // ====================

        CRefreshInfo Info;
        DWORD       dwRemoteRefrVersion = 0;

        hres = pRefServ->AddEnumToRefresher(&m_pObject->m_Id, wszClassName, lFlags,
                    pContext, WBEM_REFRESHER_VERSION, &Info, &dwRemoteRefrVersion);
        if(FAILED(hres)) 
        {
            pRefServ->Release();
            return hres;
        }

        // Act on the information
        // ======================

        switch(Info.m_lType)
        {
            case WBEM_REFRESH_TYPE_CLIENT_LOADABLE:
                hres = m_pObject->AddClientLoadableEnum(Info.m_Info.m_ClientLoadable, 
                            pNamespace, wszClassName, ppEnum, plId);
                break;

            case WBEM_REFRESH_TYPE_DIRECT:
                hres = m_pObject->AddDirectEnum(Info.m_Info.m_Direct, 
                            pNamespace, wszClassName, ppEnum, plId);
                break;

            case WBEM_REFRESH_TYPE_REMOTE:

                if ( SUCCEEDED( hres ) )
                {
                    hres = m_pObject->AddRemoteEnum( pRefServ, Info.m_Info.m_Remote, wszClassName,
                                Info.m_lCancelId, ppEnum, plId, &CoAuthInfo );
                }

                break;
        }

        pRefServ->Release();
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}

//*****************************************************************************
//*****************************************************************************
//                              XREFRESHER
//*****************************************************************************
//*****************************************************************************
STDMETHODIMP CUniversalRefresher::XRefresher::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid flag values
    if ( ( lFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( &m_pObject->m_Lock );

    if ( lock.IsLocked() )
    {
        hres = m_pObject->Refresh(lFlags);
    }
    else
    {
        hres = WBEM_E_REFRESHER_BUSY;
    }

    return hres;
}


//*****************************************************************************
//*****************************************************************************
//                          UNIVERSAL REFRESHER
//*****************************************************************************
//*****************************************************************************

CUniversalRefresher::~CUniversalRefresher()
{
    // When we are destructed, we need to make sure that any remote refreshers
    // that may still be trying to reconnect on separate threads are silenced

    for ( long lCtr = 0; lCtr < m_apRemote.GetSize(); lCtr++ )
    {
        CRemote* pRemote = m_apRemote.GetAt( lCtr );

        if ( NULL != pRemote )
        {
            pRemote->Quit();
        }
    }   // FOR enum refreshers
}

CClientLoadableProviderCache CUniversalRefresher::mstatic_Cache;
long CUniversalRefresher::mstatic_lLastId = 0;
long CUniversalRefresher::GetNewId()
{
    return InterlockedIncrement(&mstatic_lLastId);
}

void* CUniversalRefresher::GetInterface(REFIID riid)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRefresher)
        return &m_XRefresher;
    else if(riid == IID_IWbemConfigureRefresher)
        return &m_XCreate;
    else
        return NULL;
}

HRESULT CUniversalRefresher::GetRefreshingServices( IWbemServices* pNamespace,
                IWbemRefreshingServices** ppRefSvc,
                COAUTHINFO* pCoAuthInfo )
{
    // Acquire internal connection to WINMGMT
    // ====================================

    HRESULT hres = pNamespace->QueryInterface(IID_IWbemRefreshingServices, 
                                    (void**) ppRefSvc);

    if ( SUCCEEDED( hres ) )
    {
        // We will query the namespace for its security settings so we can propagate
        // those settings onto our own internal interfaces.

        hres = CoQueryProxyBlanket( pNamespace, &pCoAuthInfo->dwAuthnSvc, &pCoAuthInfo->dwAuthzSvc,
                &pCoAuthInfo->pwszServerPrincName, &pCoAuthInfo->dwAuthnLevel,
                &pCoAuthInfo->dwImpersonationLevel, (RPC_AUTH_IDENTITY_HANDLE*) &pCoAuthInfo->pAuthIdentityData,
                &pCoAuthInfo->dwCapabilities );

        if ( SUCCEEDED( hres ) )
        {
            hres = WbemSetProxyBlanket( *ppRefSvc, pCoAuthInfo->dwAuthnSvc, pCoAuthInfo->dwAuthzSvc,
                pCoAuthInfo->pwszServerPrincName, pCoAuthInfo->dwAuthnLevel,
                pCoAuthInfo->dwImpersonationLevel, pCoAuthInfo->pAuthIdentityData,
                pCoAuthInfo->dwCapabilities );
        }
        else if ( E_NOINTERFACE == hres )
        {
            // If we are in-proc to WMI, then CoQueryProxyBlanket can fail, but this
            // is not really an error, per se, so we will fake it.
            hres = WBEM_S_NO_ERROR;
        }

        if ( FAILED( hres ) )
        {
            (*ppRefSvc)->Release();
            *ppRefSvc = NULL;
        }

    }   // IF QI

    return hres;
}

HRESULT CUniversalRefresher::AddInProcObject(
                                CHiPerfProviderRecord* pProvider,
                                IWbemObjectAccess* pTemplate,
                                IWbemServices* pNamespace,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a provider record with this provider pointer
    // =====================================================

    CDirect* pFoundRec = NULL;
    for(int i = 0; i < m_apDirect.GetSize(); i++)
    {
        CDirect* pDirectRec = m_apDirect[i];
        if(pDirectRec->GetProvider() == pProvider)
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        IWbemRefresher* pRefresher;

        try
        {
            hres = pProvider->m_pProvider->CreateRefresher(pNamespace, 0, &pRefresher);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres))
        {
            return hres;
        }
    
        pFoundRec = _new CDirect(pProvider, pRefresher);
        m_apDirect.Add(pFoundRec);
        pRefresher->Release();
    }

    // Add request in provider
    // =======================

    IWbemObjectAccess* pProviderObject;
    long lProviderId;

    // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
    // IWbemRefreshingServices::AddObjectToRefresher will return a localized
    // instance definition.  Since localized stuff should all be in the class
    // definition, the provider doesn't really "need" toknow  that we're sneaking
    // this in.  To protect our object, we'll clone it BEFORE we pass it to
    // the provider.  The instance that is returned by the provider BETTER be of
    // the same class type we are, however.

    CWbemInstance*  pClientInstance = NULL;

    hres = pTemplate->Clone( (IWbemClassObject**) &pClientInstance );

    if ( FAILED( hres ) )
    {
        return hres;
    }

    try
    {
        hres = pProvider->m_pProvider->CreateRefreshableObject(pNamespace, pTemplate, 
                pFoundRec->GetRefresher(), 0, NULL, &pProviderObject, 
                &lProviderId);
    }
    catch(...)
    {
        // Provider threw an exception, so get out of here ASAP
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(FAILED(hres))
    {
        pClientInstance->Release();
        return hres;
    }

    // Now copy the provider returned instance data.
    hres = pClientInstance->CopyBlobOf( (CWbemInstance*) pProviderObject );

    if ( SUCCEEDED( hres ) )
    {
        hres = pFoundRec->AddRequest((CWbemObject*)pProviderObject, pClientInstance, lProviderId,
                            ppRefreshable, plId);
    }

    pProviderObject->Release();
    pClientInstance->Release();

    return hres;
}

HRESULT CUniversalRefresher::AddInProcEnum(
                                CHiPerfProviderRecord* pProvider,
                                IWbemObjectAccess* pTemplate,
                                IWbemServices* pNamespace, LPCWSTR wszClassName,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a provider record with this provider pointer
    // =====================================================

    CDirect* pFoundRec = NULL;
    for(int i = 0; i < m_apDirect.GetSize(); i++)
    {
        CDirect* pDirectRec = m_apDirect[i];
        if(pDirectRec->GetProvider() == pProvider)
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        IWbemRefresher* pRefresher;

        try
        {
            hres = pProvider->m_pProvider->CreateRefresher(pNamespace, 0, &pRefresher);
        }
        catch(...)
        {
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres))
        {
            return hres;
        }
    
        pFoundRec = _new CDirect(pProvider, pRefresher);
        m_apDirect.Add(pFoundRec);
        pRefresher->Release();
    }

    // Add request in provider
    // =======================

    CClientLoadableHiPerfEnum*  pHPEnum = new CClientLoadableHiPerfEnum( m_pControl );

    if ( NULL != pHPEnum )
    {
        pHPEnum->AddRef();

        // Auto-release this guy when we're done
        CReleaseMe  rmEnum( pHPEnum );

        long lProviderId;

        // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
        // IWbemRefreshingServices::AddEnumToRefresher will return a localized
        // instance definition.  Since localized stuff should all be in the class
        // definition, the provider doesn't really "need" toknow  that we're sneaking
        // this in.


        hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) pTemplate );

        if ( FAILED( hres ) )
        {
            return hres;
        }

        try
        {
            hres = pProvider->m_pProvider->CreateRefreshableEnum(pNamespace, (LPWSTR) wszClassName, 
                    pFoundRec->GetRefresher(), 0, NULL, (IWbemHiPerfEnum*) pHPEnum, 
                    &lProviderId );
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres))
        {
            return hres;
        }
    

        hres = pFoundRec->AddEnumRequest( pHPEnum, lProviderId,
                                ppEnum, plId, m_pControl );
    }

    return hres;
}

HRESULT CUniversalRefresher::AddClientLoadable(
                                const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_wszNamespace, pNamespace, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcObject( pProvider, Info.m_pTemplate, pNamespace, ppRefreshable, plId );

    pProvider->Release();
    return hres;

}
    
HRESULT CUniversalRefresher::AddClientLoadableEnum(
                                const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace, LPCWSTR wszClassName,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_wszNamespace, pNamespace, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcEnum( pProvider, Info.m_pTemplate, pNamespace, wszClassName, ppEnum, plId );

    pProvider->Release();
    return hres;

}

HRESULT CUniversalRefresher::AddDirect(
                                const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_pProvider, Info.m_wszNamespace, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcObject( pProvider, Info.m_pTemplate, pNamespace, ppRefreshable, plId );

    pProvider->Release();
    return hres;
}
    
HRESULT CUniversalRefresher::AddDirectEnum(
                                const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace, LPCWSTR wszClassName,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_pProvider, Info.m_wszNamespace, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcEnum( pProvider, Info.m_pTemplate, pNamespace, wszClassName, ppEnum, plId );

    pProvider->Release();
    return hres;
}

HRESULT CUniversalRefresher::FindRemoteEntry(   const WBEM_REFRESH_INFO_REMOTE& Info,
                                                COAUTHINFO* pAuthInfo,
                                                CRemote** ppRemoteRecord )
{

    // We will identify remote enumerations by server and namespace
    CVar    varNameSpace;

    HRESULT hr = ((CWbemObject*) Info.m_pTemplate)->GetServerAndNamespace( &varNameSpace );

    if ( FAILED( hr ) )
    {
        return hr;
    }
    else if ( NULL == varNameSpace.GetLPWSTR() )
    {
        // This shouldn't happen, but protect against it
        return WBEM_E_FAILED;
    }

    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;
    for(int i = 0; i < m_apRemote.GetSize(); i++)
    {
        CRemote* pRec = m_apRemote[i];

        // Original code:
        //         if(pRec->GetRemoteRefresher() == Info.m_pRefresher)
        if ( wbem_wcsicmp( varNameSpace.GetLPWSTR(), pRec->GetNamespace() ) == 0 )
        {
            pFoundRec = pRec;
            if ( NULL != pFoundRec )
            {
                pFoundRec->AddRef();
            }

            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        // Watch for errors, and do appropriate cleanup
        try
        {
            // Get the server info from the object.  If this returns a NULL, it just
            // means that we will be unable to reconnect

            CVar    varServer;

            hr = ((CWbemObject*) Info.m_pTemplate)->GetServer( &varServer );

            if ( SUCCEEDED( hr ) )
            {
                pFoundRec = _new CRemote(Info.m_pRefresher, pAuthInfo, &Info.m_guid,
                                        varNameSpace.GetLPWSTR(), varServer.GetLPWSTR(), this );

                // Set the scurity appropriately
                hr = pFoundRec->ApplySecurity();

                if ( SUCCEEDED( hr ) )
                {
                    m_apRemote.Add(pFoundRec);
                }
            }

        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        if ( FAILED( hr ) )
        {
            // Release the pointer as we no longer need it
            if ( NULL != pFoundRec )
            {
                pFoundRec->Release();
                pFoundRec = NULL;
            }
        }

    }   // IF NULL == pFoundRec

    *ppRemoteRecord = pFoundRec;

    return hr;
}
        
HRESULT CUniversalRefresher::AddRemote( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
                                LPCWSTR pwcsRequestName, long lCancelId, IWbemClassObject** ppRefreshable,
                                long* plId, COAUTHINFO* pAuthInfo )
{
    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;

    HRESULT hr = FindRemoteEntry( Info, pAuthInfo, &pFoundRec );

    if ( SUCCEEDED( hr ) )
    {

        if ( !pFoundRec->IsConnected() )
        {
            hr = pFoundRec->Rebuild( pRefServ, Info.m_pRefresher, &Info.m_guid );
        }

        if ( SUCCEEDED( hr ) )
        {
            // Add a request to it
            // ===================

            IWbemObjectAccess* pAccess = Info.m_pTemplate;
            CWbemObject* pObj = (CWbemObject*)pAccess;

            hr =  pFoundRec->AddRequest(pObj, pwcsRequestName, lCancelId, ppRefreshable, plId);

        }

        // Release the record
        pFoundRec->Release();
    }

    return hr;
}

HRESULT CUniversalRefresher::AddRemoteEnum( IWbemRefreshingServices* pRefServ,
                                        const WBEM_REFRESH_INFO_REMOTE& Info, LPCWSTR pwcsRequestName,
                                        long lCancelId, IWbemHiPerfEnum** ppEnum, long* plId, COAUTHINFO* pAuthInfo )

{
    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;

    HRESULT hr = FindRemoteEntry( Info, pAuthInfo, &pFoundRec );

    if ( SUCCEEDED( hr ) )
    {
        if ( !pFoundRec->IsConnected() )
        {
            hr = pFoundRec->Rebuild( pRefServ, Info.m_pRefresher, &Info.m_guid );
        }

        if ( SUCCEEDED( hr ) )
        {
            // Add a request to it
            // ===================

            IWbemObjectAccess* pAccess = Info.m_pTemplate;
            CWbemObject* pObj = (CWbemObject*)pAccess;

            hr =  pFoundRec->AddEnumRequest(pObj, pwcsRequestName, lCancelId, ppEnum, plId, m_pControl );

        }

        // Release the record
        pFoundRec->Release();
    }

    return hr;
}

HRESULT CUniversalRefresher::AddRefresher( IWbemRefresher* pRefresher, long lFlags, long* plId )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pRefresher && 0L == lFlags )
    {
        CNestedRefresher*   pNested = new CNestedRefresher( pRefresher );

        if ( NULL != pNested )
        {
            if ( NULL != plId )
            {
                *plId = pNested->GetId();
            }
            m_apNestedRefreshers.Add( pNested );
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

HRESULT CUniversalRefresher::Remove(long lId, long lFlags)
{
    HRESULT hres;

    // Search through them all
    // =======================

    int i;
    for(i = 0; i < m_apRemote.GetSize(); i++)
    {
        hres = m_apRemote[i]->Remove(lId, lFlags, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }

    for(i = 0; i < m_apDirect.GetSize(); i++)
    {
        hres = m_apDirect[i]->Remove(lId, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }

    // Check for a nested refresher
    for ( i = 0; i < m_apNestedRefreshers.GetSize(); i++ )
    {
        if ( m_apNestedRefreshers[i]->GetId() == lId )
        {
            CNestedRefresher*   pNested = m_apNestedRefreshers[i];
            // This will delete the pointer
            m_apNestedRefreshers.RemoveAt( i );
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CUniversalRefresher::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    BOOL    fPartialSuccess = FALSE;

    // Search through them all
    // =======================

    // Keep track of how many different refresh calls we actually make.
    int i;
    HRESULT hrFirstRefresh = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRefresh = FALSE;

    for(i = 0; i < m_apRemote.GetSize(); i++)
    {
        hres = m_apRemote[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }

    for(i = 0; i < m_apDirect.GetSize(); i++)
    {
        hres = m_apDirect[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }
    }

    // Refresh nested refreshers too
    for ( i = 0; i < m_apNestedRefreshers.GetSize(); i++ )
    {
        hres = m_apNestedRefreshers[i]->Refresh( lFlags );

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }
    }

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hres = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hres = hrFirstRefresh;
    }

    return hres;
}

void CUniversalRefresher::Flush()
{
    GetProviderCache()->Flush();
}



//*****************************************************************************
//*****************************************************************************
//                            CLIENT REQUEST
//*****************************************************************************
//*****************************************************************************


CUniversalRefresher::CClientRequest::CClientRequest(CWbemObject* pTemplate)
    : m_pClientObject(NULL), m_lClientId(0)
{
    if(pTemplate)
    {
        pTemplate->AddRef();
        m_pClientObject = (CWbemObject*)pTemplate;
    }

    m_lClientId = CUniversalRefresher::GetNewId();
}

CUniversalRefresher::CClientRequest::~CClientRequest()
{
    if(m_pClientObject)
        m_pClientObject->Release();
}

void CUniversalRefresher::CClientRequest::SetClientObject(
                                            CWbemObject* pClientObject)
{
    if(m_pClientObject)
        m_pClientObject->Release();
    m_pClientObject = pClientObject;
    if(m_pClientObject)
        m_pClientObject->AddRef();
}
void CUniversalRefresher::CClientRequest::GetClientInfo(
                       RELEASE_ME IWbemClassObject** ppRefreshable, long* plId)
{
    *ppRefreshable = m_pClientObject;
    if(m_pClientObject)
        m_pClientObject->AddRef();

    if ( NULL != plId )
    {
        *plId = m_lClientId;
    }
}

//*****************************************************************************
//*****************************************************************************
//                            DIRECT PROVIDER
//*****************************************************************************
//*****************************************************************************


CUniversalRefresher::CDirect::CDirect(CHiPerfProviderRecord* pProvider,
                                        IWbemRefresher* pRefresher)
    : m_pRefresher(pRefresher), m_pProvider(pProvider)
{
    if(m_pRefresher)
        m_pRefresher->AddRef();
    if(m_pProvider)
        m_pProvider->AddRef();
}

CUniversalRefresher::CDirect::~CDirect()
{
    if(m_pRefresher)
        m_pRefresher->Release();
    if(m_pProvider)
        m_pProvider->Release();
}

HRESULT CUniversalRefresher::CDirect::AddRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientInstance,
                         long lCancelId, IWbemClassObject** ppRefreshable, long* plId)
{
    CRequest* pRequest = NULL;

    try
    {
        pRequest = _new CRequest(pRefreshedObject, pClientInstance, lCancelId);
        m_apRequests.Add(pRequest);
        pRequest->GetClientInfo(ppRefreshable, plId);
    }
    catch(...)
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CDirect::AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum,
                        long lCancelId, IWbemHiPerfEnum** ppEnum, long* plId, CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CEnumRequest* pEnumRequest = NULL;

    try
    {
        // We get away with this through inheritance and polymorphism
        pEnumRequest = _new CEnumRequest(pHPEnum, lCancelId, pLifeControl);
        m_apRequests.Add((CRequest*) pEnumRequest);
        hr = pEnumRequest->GetClientInfo(ppEnum, plId);
    }
    catch(...)
    {
        if ( NULL != pEnumRequest )
        {
            delete pEnumRequest;
        }

        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
    
HRESULT CUniversalRefresher::CDirect::Refresh(long lFlags)
{
    HRESULT hres;
    if(m_pRefresher)
    {
        try
        {
            hres = m_pRefresher->Refresh(0L);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres)) return hres;
    }

    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        m_apRequests[i]->Copy();
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CDirect::Remove(long lId, 
                            CUniversalRefresher* pContainer)
{
    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        CRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}
    

CUniversalRefresher::CDirect::CRequest::CRequest( CWbemObject* pProviderObject,
                                                CWbemObject* pClientInstance,
                                                long lProviderId )
    : CClientRequest(pClientInstance), m_pProviderObject(pProviderObject),
        m_lProviderId(lProviderId)
{
    if(m_pProviderObject)
        m_pProviderObject->AddRef();
}

HRESULT CUniversalRefresher::CDirect::CRequest::Cancel(
        CUniversalRefresher::CDirect* pDirect)
{
    if(pDirect->GetProvider())
    {
        try
        {
            return pDirect->GetProvider()->m_pProvider->StopRefreshing(pDirect->GetRefresher(),
                m_lProviderId, 0);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            return WBEM_E_PROVIDER_FAILURE;
        }

    }
    else return WBEM_S_NO_ERROR;
}
    
CUniversalRefresher::CDirect::CRequest::~CRequest()
{
    if(m_pProviderObject)
        m_pProviderObject->Release();
}
    

void CUniversalRefresher::CDirect::CRequest::Copy()
{
    m_pClientObject->CopyBlobOf(m_pProviderObject);
}
    

CUniversalRefresher::CDirect::CEnumRequest::CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, 
                                                long lProviderId, CLifeControl* pLifeControl )
    : CRequest( NULL, NULL, lProviderId ), m_pHPEnum(pHPEnum)
{
    if( m_pHPEnum )
        m_pHPEnum->AddRef();

    // We'll need an enumerator for the client to retrieve objects
    m_pClientEnum = new CReadOnlyHiPerfEnum( pLifeControl );

    if ( NULL != m_pClientEnum )
    {
        // Set the instance template.  Without this, there is no point
        CWbemInstance* pInst = pHPEnum->GetInstanceTemplate();

        if ( NULL != pInst )
        {
            // Don't hold onto the enumerator unless the template is
            // properly set.

            if ( SUCCEEDED(m_pClientEnum->SetInstanceTemplate( pInst ) ) )
            {
                m_pClientEnum->AddRef();
            }
            else
            {
                // Cleanup
                delete m_pClientEnum;
                m_pClientEnum = NULL;
            }

            // GetInstanceTemplate AddRefs
            pInst->Release();

        }
        else
        {
            delete m_pClientEnum;
            m_pClientEnum = NULL;
        }

    }
}

CUniversalRefresher::CDirect::CEnumRequest::~CEnumRequest()
{
    if(m_pHPEnum)
        m_pHPEnum->Release();

    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Release();
    }
}
    

void CUniversalRefresher::CDirect::CEnumRequest::Copy()
{
    // Tell the refresher enumerator to copy its objects from
    // the HiPerf Enumerator
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Copy( m_pHPEnum );
    }

}
    
HRESULT CUniversalRefresher::CDirect::CEnumRequest::GetClientInfo(  RELEASE_ME IWbemHiPerfEnum** ppEnum, 
                                                                long* plId)
{
    // We best have enumerators to hook up here
    if ( NULL != m_pClientEnum )
    {
        // Store the client id, then do a QI

        if ( NULL != plId )
        {
            *plId = m_lClientId;
        }

        return m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum );
    }
    else
    {
        return WBEM_E_FAILED;
    }
}

    
//*****************************************************************************
//*****************************************************************************
//                          REMOTE PROVIDER
//*****************************************************************************
//*****************************************************************************

                    

CUniversalRefresher::CRemote::CRemote(IWbemRemoteRefresher* pRemRefresher, COAUTHINFO* pCoAuthInfo, const GUID* pGuid,
                                      LPCWSTR pwszNamespace, LPCWSTR pwszServer, CUniversalRefresher* pObject )
: m_pRemRefresher(pRemRefresher), m_bstrNamespace( NULL ), m_fConnected( TRUE ), m_pObject( pObject ),
m_bstrServer( NULL ), m_lRefCount( 1 ), m_pReconnectedRemote( NULL ), m_pReconnectSrv( NULL ), m_fQuit( FALSE )
{
    // Initialize the GUID data members
    ZeroMemory( &m_ReconnectGuid, sizeof(GUID));
    m_RemoteGuid = *pGuid;

    if(m_pRemRefresher)
        m_pRemRefresher->AddRef();

    m_CoAuthInfo = *pCoAuthInfo;

    if ( NULL != pCoAuthInfo->pwszServerPrincName )
    {
        // This will throw an exception if it fails
        m_CoAuthInfo.pwszServerPrincName = new WCHAR[wcslen(pCoAuthInfo->pwszServerPrincName)+1];
        wcscpy( m_CoAuthInfo.pwszServerPrincName, pCoAuthInfo->pwszServerPrincName );
    }

    // Store reconnection data
    if ( NULL != pwszNamespace )
    {
        m_bstrNamespace = SysAllocString( pwszNamespace );
    }

    if ( NULL != pwszServer )
    {
        m_bstrServer = SysAllocString( pwszServer );
    }

}
    
CUniversalRefresher::CRemote::~CRemote()
{
    ClearRemoteConnections();

    if ( NULL != m_CoAuthInfo.pwszServerPrincName )
    {
        delete [] m_CoAuthInfo.pwszServerPrincName;
    }

    if ( NULL != m_bstrNamespace )
    {
        SysFreeString( m_bstrNamespace );
    }

    if ( NULL != m_bstrServer )
    {
        SysFreeString( m_bstrServer );
    }

}

ULONG STDMETHODCALLTYPE CUniversalRefresher::CRemote::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CUniversalRefresher::CRemote::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
        delete this;
    return lRef;
}

// Applies appropriate security settings to the proxy
HRESULT CUniversalRefresher::CRemote::ApplySecurity( void )
{
    return WbemSetProxyBlanket( m_pRemRefresher, m_CoAuthInfo.dwAuthnSvc, m_CoAuthInfo.dwAuthzSvc,
                m_CoAuthInfo.pwszServerPrincName, m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData, m_CoAuthInfo.dwCapabilities );
}

void CUniversalRefresher::CRemote::CheckConnectionError( HRESULT hr, BOOL fStartReconnect )
{
    if ( IsConnectionError( hr ) && fStartReconnect )
    {
        // Release and NULL out the remote refresher pointer.  The Remote GUID member
        // will tell us if a reconnect got us back to the same stub on the server

        // DEVNOTE:TODO - Looks like COM has a problem with these, so let the release happen
        // when we try to Rebuild the connection.
//      m_pRemRefresher->Release();
//      m_pRemRefresher = NULL;

        // We should change the m_fConnected data member to indicate that we are no
        // longer connected, and we need to spin off a thread to try and put us back
        // together again.  To keep things running smoothly, we should AddRef() ourselves
        // so the thread will release us when it is done.

        m_fConnected = FALSE;

        // AddRefs us so we can be passed off to the thread
        AddRef();

        DWORD   dwThreadId = NULL;
        HANDLE  hThread = (HANDLE) _beginthreadex( NULL, 0, CRemote::ThreadProc, (void*) this,
                                0, (unsigned int *) &dwThreadId );

        // If no thread was spawned, then there is no need for us to maintain the AddRef() from
        // above.

        if ( NULL != hThread )
        {
            CloseHandle( hThread );
        }
        else
        {
            Release();
        }

    }   // If connection error and start reconnect thread

}

HRESULT CUniversalRefresher::CRemote::AddRequest(
                    CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId, 
                    IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CRequest* pRequest = NULL;

    try
    {
        pRequest = _new CRequest(pTemplate, lCancelId, pwcsRequestName);
        m_apRequests.Add(pRequest);
        pRequest->GetClientInfo(ppRefreshable, plId);
    }
    catch( ... )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }

        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CUniversalRefresher::CRemote::AddEnumRequest(
                    CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId, 
                    IWbemHiPerfEnum** ppEnum, long* plId, CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CEnumRequest* pRequest = NULL;

    try
    {
        // Make sure the request allocates an enumerator internally

        pRequest = _new CEnumRequest( pTemplate, lCancelId, pwcsRequestName, pLifeControl );

        if ( pRequest->IsOk() )
        {
            //  All we need for the client is the id, so
            //  dummy up a holder for the refreshable object
            //  ( which is really the template for the objects
            //  we will be returning from the enumerator.

            IWbemClassObject*   pObjTemp = NULL;

            m_apRequests.Add((CRequest*) pRequest);
            pRequest->GetClientInfo( &pObjTemp, plId );

            if ( NULL != pObjTemp )
            {
                pObjTemp->Release();
            }

            // Get the enumerator
            hr = pRequest->GetEnum( ppEnum );

        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    catch( ... )
    {
        if ( NULL != pRequest )
        {
            delete pRequest;
        }

        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;

}

// Rebuilds a remote refresher
HRESULT CUniversalRefresher::CRemote::Rebuild( IWbemServices* pNamespace )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Storage for security settings we will need in order to propagate
    // down to our internal interfaces.

    COAUTHINFO                  CoAuthInfo;

    // Acquire internal connection to WINMGMT
    // ====================================

    IWbemRefreshingServices* pRefServ = NULL;

    hr = m_pObject->GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );
    CReleaseMe  rmrs(pRefServ);

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    // This guarantees this will be freed when we drop out of scope.  If we store
    // it we will need to allocate an internal copy.

    CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

    IWbemRemoteRefresher*   pRemRefresher = NULL;

    // Make sure a remote refresher exists for "this" refresher
    GUID    remoteGuid;
    DWORD   dwRemoteRefrVersion = 0;

    hr = pRefServ->GetRemoteRefresher( m_pObject->GetId(), 0L, WBEM_REFRESHER_VERSION, 
                        &pRemRefresher, &remoteGuid, &dwRemoteRefrVersion );
    CReleaseMe  rm(pRemRefresher);

    if ( FAILED( hr ) )
    {
        return hr;
    }
    else
    {
        // Will enter and exit the critical section with scoping
        CInCritSec  ics( &m_cs );

        // Check that we're still not connected
        if ( !m_fConnected )
        {
            // Because the original object mayhave been instantiated in an STA, we will let the Refresh
            // call do the dirty work of actually hooking up this bad boy.  In order for this
            // to work, however, 
            hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemRemoteRefresher, pRemRefresher, &m_pReconnectedRemote );

            if ( SUCCEEDED( hr ) )
            {
                hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemRefreshingServices, pRefServ, &m_pReconnectSrv );

                if ( SUCCEEDED( hr ) )
                {
                    // Store the GUID so the refresh will be able to determine the identity
                    // of the remote refresher.

                    m_ReconnectGuid = remoteGuid;
                }
                else
                {
                    IWbemRemoteRefresher*   pTemp = NULL;

                    // Cleanup the data here
                    CoGetInterfaceAndReleaseStream( m_pReconnectedRemote, IID_IWbemRemoteRefresher,
                                            (void**) &pTemp );
                    CReleaseMe  rmTemp( pTemp );

                    // NULL out the old pointer
                    m_pReconnectedRemote = NULL;
                }
            }

        }   // IF !m_fConnected

    }

    return hr;

}

HRESULT CUniversalRefresher::CRemote::Rebuild( IWbemRefreshingServices* pRefServ,
                                                IWbemRemoteRefresher* pRemRefresher,
                                                const GUID* pReconnectGuid )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Will enter and exit the critical section with scoping
    CInCritSec  ics( &m_cs );

    // Right off, check if we ARE connected, in which case we can assume we had
    // a race condition on this function, and the winner got us all hooked back
    // up again.

    if ( m_fConnected )
    {
        return hr;
    }

    // If these two are equal, we can assume that we reconnected without losing our previous connection.
    // If they are not equal, we will then need to rebuild the remote refresher, however, by calling
    // GetRemoteRefresher() successfully we will have effectively ensured that a remote refresher exists
    // for us up on the server.

    if ( *pReconnectGuid != m_RemoteGuid )
    {

        // We will need these memory buffers to hold individual request data
        WBEM_RECONNECT_INFO*    apReconnectInfo = NULL;
        WBEM_RECONNECT_RESULTS* apReconnectResults = NULL;

        // Only alloc and fill out arrays if we have requests
        if ( m_apRequests.GetSize() > 0 )
        {
            try
            {
                apReconnectInfo = new WBEM_RECONNECT_INFO[m_apRequests.GetSize()];
                apReconnectResults = new WBEM_RECONNECT_RESULTS[m_apRequests.GetSize()];
            }
            catch( ... )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            // Don't need to reset anything if nothing to reset

            if ( m_apRequests.GetSize() > 0 )
            {

                // Enumerate the requests and fill out the arrays
                for ( int i = 0; i < m_apRequests.GetSize(); i++ )
                {
                    CRequest*   pRequest = m_apRequests.GetAt( i );

                    // Setup each info structure
                    apReconnectInfo[i].m_lType = ( pRequest->IsEnum() ? WBEM_RECONNECT_TYPE_ENUM :
                                                    WBEM_RECONNECT_TYPE_OBJECT );
                    apReconnectInfo[i].m_pwcsPath = pRequest->GetName();

                    apReconnectResults[i].m_lId = pRequest->GetRemoteId();
                    apReconnectResults[i].m_hr = 0;

                }   // FOR enum requests

                DWORD   dwRemoteRefrVersion = 0;
                hr = pRefServ->ReconnectRemoteRefresher( m_pObject->GetId(), 0L, m_apRequests.GetSize(),
                                                        WBEM_REFRESHER_VERSION, apReconnectInfo,
                                                        apReconnectResults, &dwRemoteRefrVersion );
            }

            // Rehook up the object and enumids
            if ( WBEM_S_NO_ERROR == hr )
            {

                // Cleanup the old pointer
                if ( NULL != m_pRemRefresher )
                {
                    m_pRemRefresher->Release();
                    m_pRemRefresher = NULL;
                }

                // Store the new one and setup the security
                m_pRemRefresher = pRemRefresher;
                hr = ApplySecurity();

                if ( SUCCEEDED( hr ) )
                {
                    m_pRemRefresher->AddRef();

                    // Redo the ones that succeeded.  Clear the rest
                    for( int i = 0; i < m_apRequests.GetSize(); i++ )
                    {
                        CRequest*   pRequest = m_apRequests.GetAt( i );

                        if ( SUCCEEDED( apReconnectResults[i].m_hr ) )
                        {
                            pRequest->SetRemoteId( apReconnectResults[i].m_lId );
                        }
                        else
                        {
                            // This means it didn't get hooked up again.  So if the
                            // user tries to remove him, we will just ignore this
                            // id.
                            pRequest->SetRemoteId( INVALID_REMOTE_REFRESHER_ID );
                        }
                    }
                }
                else
                {
                    // Setting security failed, so just set the pointer to NULL (we haven't
                    // AddRef'd it ).
                    m_pRemRefresher = NULL;
                }

            }   // IF WBEM_S_NO_ERROR == hr

        }   // IF SUCCEEDED(hr)

        // Check that we're good to go
        if ( SUCCEEDED( hr ) )
        {
            // Clear the removed ids array since a new connection was established, hence the
            // old ids are a moot point.
            m_alRemovedIds.Empty();
            m_fConnected = TRUE;
        }


        // Cleanup the memory buffers
        if ( NULL != apReconnectInfo )
        {
            delete [] apReconnectInfo;
        }

        if ( NULL != apReconnectResults )
        {
            delete [] apReconnectResults;
        }


    }   // IF remote refreshers not the same
    else
    {
        // The remote refresher pointers match, so assume that all our old ids are still
        // valid.

        // The refresher we were handed will be automatically released.

        m_fConnected = TRUE;

        // Cleanup the old pointer
        if ( NULL != m_pRemRefresher )
        {
            m_pRemRefresher->Release();
            m_pRemRefresher = NULL;
        }

        // Store the new one and setup the security
        m_pRemRefresher = pRemRefresher;
        hr = ApplySecurity();

        if ( SUCCEEDED( hr ) )
        {
            m_pRemRefresher->AddRef();
        }
        else
        {
            // Setting security failed, so just set the pointer to NULL (we haven't
            // AddRef'd it ).
            m_pRemRefresher = NULL;
        }

        // Delete cached ids if we have any.
        if ( ( SUCCEEDED ( hr ) ) && m_alRemovedIds.Size() > 0 )
        {
            // We will need these memory buffers to hold individual request data
            long*       aplIds = NULL;

            try
            {
                aplIds = new long[m_alRemovedIds.Size()];
            }
            catch( ... )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            if ( SUCCEEDED( hr ) )
            {
                // Enumerate the requests and fill out the arrays
                for ( int i = 0; i < m_alRemovedIds.Size(); i++ )
                {
                    // DEVNOTE:WIN64:SANJ - The id's are 32-bit, but on 64-bit platforms,
                    // the flex array will contain 64-bit values, so use PtrToLong
                    // to get a warning free conversion.  On 32-bit platforms,
                    // PtrToLong will do nothing.

                    aplIds[i] = PtrToLong(m_alRemovedIds.GetAt( i ));

                }   // FOR enum requests

                // DEVNOTE:TODO:SANJ - Do we care about this return code?
                hr = m_pRemRefresher->StopRefreshing( i-1, aplIds, 0 );

                // Clear the array
                m_alRemovedIds.Empty();
            }

            if ( NULL != aplIds )
            {
                delete [] aplIds;
            }

        }   // If RemoveId list is not empty

    }   // We got the remote refresher

    return hr;

}

// This is a temporary helper function which helps us determine if a remote machine
// is actually alive, since COM/RPC seem to have problems with hanging if I constantly
// hammer at CoCreateInstanceEx() when the remote machine is down
HRESULT CUniversalRefresher::CRemote::IsAlive( void )
{
    HRESULT hr = RPC_E_DISCONNECTED;

    HKEY    hRemoteKey = NULL;
    long    lError = RegConnectRegistryW( m_bstrServer, HKEY_LOCAL_MACHINE, &hRemoteKey );

    // If we get a success or an access denied, then we will go ahead
    // and assume that the machine is up.
    if ( ERROR_SUCCESS == lError || ERROR_ACCESS_DENIED == lError )
    {
        hr = WBEM_S_NO_ERROR;
    }

    if ( NULL != hRemoteKey )
    {
        RegCloseKey( hRemoteKey );
    }

    return hr;

}

unsigned CUniversalRefresher::CRemote::ReconnectEntry( void ) 
{
    HRESULT hr = RPC_E_DISCONNECTED;

    // This guy ALWAYS runs in the MTA
    InitializeCom();

    // Basically as long as we can't connect, somebody else doesn't connect us, or we are told
    // to quit, we will run this thread.

    while ( FAILED(hr) && !m_fConnected && !m_fQuit )
    {
        IWbemLocator*   pWbemLocator = NULL;

        // Because COM and RPC seem to have this problem with actually being able to themselves
        // reconnect, we're performing our own low level "ping" of the remote machine, using RegConnectRegistry
        // to verify if the machine is indeed alive.  If it is, then and only then will be deign to use
        // DCOM to follow through the operation.

        hr = IsAlive();

        if ( SUCCEEDED( hr ) )
        {
            // Make sure we have a namespace to connect to
            if ( NULL != m_bstrNamespace )
            {

                hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator, (void**) &pWbemLocator );

                if ( SUCCEEDED( hr ) )
                {

                    IWbemServices*  pNamespace = NULL;

                    // We're gonna default to the system
                    hr = pWbemLocator->ConnectServer(   m_bstrNamespace,    // NameSpace Name
                                                        NULL,           // UserName
                                                        NULL,           // Password
                                                        NULL,           // Locale
                                                        0L,             // Security Flags
                                                        NULL,           // Authority
                                                        NULL,           // Wbem Context
                                                        &pNamespace     // Namespace
                                                        );

                    if ( SUCCEEDED( hr ) )
                    {

                        // Apply security settings to the namespace
                        hr = WbemSetProxyBlanket( pNamespace, m_CoAuthInfo.dwAuthnSvc,
                                    m_CoAuthInfo.dwAuthzSvc, m_CoAuthInfo.pwszServerPrincName,
                                    m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                                    (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                                    m_CoAuthInfo.dwCapabilities );

                        if ( SUCCEEDED( hr ) )
                        {

                            hr = Rebuild( pNamespace );
                        }

                        pNamespace->Release();

                    }   // IF ConnectServer
            
                    pWbemLocator->Release();

                }   // IF Created Locator

            }   // IF NULL != m_bstrNamespace

        }   // IF IsAlive()

        // Sleep for a second and retry
        Sleep( 1000 );
    }

    // Release the AddRef() on the object from when the thread was created
    Release();

    CoUninitialize();

    return 0;
}

void CUniversalRefresher::CRemote::ClearRemoteConnections( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemRemoteRefresher*       pRemRefresher = NULL;
    IWbemRefreshingServices*    pRefServ = NULL;

    // Cleanup the IWbemRefreshingServices stream pointer
    if ( NULL != m_pReconnectSrv )
    {
        hr = CoGetInterfaceAndReleaseStream( m_pReconnectSrv, IID_IWbemRefreshingServices, (void**) &pRefServ );
        // This will autorelease
        CReleaseMe  rmrs( pRefServ );

        if ( SUCCEEDED( hr ) )
        {
            // We need to reset security on the Refreshing services proxy.

            hr = WbemSetProxyBlanket( pRefServ, m_CoAuthInfo.dwAuthnSvc,
                        m_CoAuthInfo.dwAuthzSvc, m_CoAuthInfo.pwszServerPrincName,
                        m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                        m_CoAuthInfo.dwCapabilities );
        }

        m_pReconnectSrv = NULL;
    }

    // Cleanup the IWbemRemoteRefresher stream pointer
    if ( NULL != m_pReconnectedRemote )
    {
        hr = CoGetInterfaceAndReleaseStream( m_pReconnectedRemote, IID_IWbemRemoteRefresher,
                (void**) &pRemRefresher );
        CReleaseMe  rmrr( pRemRefresher );

        if ( SUCCEEDED( hr ) )
        {
            // We need to reset security on the proxy.

            hr = WbemSetProxyBlanket( pRemRefresher, m_CoAuthInfo.dwAuthnSvc,
                        m_CoAuthInfo.dwAuthzSvc, m_CoAuthInfo.pwszServerPrincName,
                        m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                        m_CoAuthInfo.dwCapabilities );
        }

        // Make sure we release the stream
        m_pReconnectedRemote = NULL;
    }

    // Cleanup the IWbemRemoteRefresher pointer
    if ( NULL != m_pRemRefresher )
    {
        m_pRemRefresher->Release();
        m_pRemRefresher = NULL;
    }
}

HRESULT CUniversalRefresher::CRemote::Reconnect( void )
{
    HRESULT hr = RPC_E_DISCONNECTED;

    IWbemRemoteRefresher*       pRemRefresher = NULL;
    IWbemRefreshingServices*    pRefServ = NULL;

    CInCritSec  ics( &m_cs );

    // We will need to unmarshale both the RefreshingServices and the RemoteRefresher pointers,
    // so make sure that the streams we will need to unmarshal these from already exist.

    if ( NULL != m_pReconnectSrv && NULL != m_pReconnectedRemote )
    {
        hr = CoGetInterfaceAndReleaseStream( m_pReconnectSrv, IID_IWbemRefreshingServices, (void**) &pRefServ );
        CReleaseMe  rmrs( pRefServ );

        if ( SUCCEEDED( hr ) )
        {
            // We need to reset security on the Refreshing services proxy.

            hr = WbemSetProxyBlanket( pRefServ, m_CoAuthInfo.dwAuthnSvc,
                        m_CoAuthInfo.dwAuthzSvc, m_CoAuthInfo.pwszServerPrincName,
                        m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                        m_CoAuthInfo.dwCapabilities );

            if ( SUCCEEDED( hr ) )
            {
                hr = CoGetInterfaceAndReleaseStream( m_pReconnectedRemote, IID_IWbemRemoteRefresher,
                        (void**) &pRemRefresher );
                CReleaseMe  rmrr( pRemRefresher );

                if ( SUCCEEDED( hr ) )
                {
                    // Remote refresher and refreshing services
                    hr = Rebuild( pRefServ, pRemRefresher, &m_ReconnectGuid );
                }
                else
                {
                    // Make sure we release the stream
                    m_pReconnectedRemote->Release();
                }
            }
            else
            {
                // Make sure we release the stream
                m_pReconnectedRemote->Release();
            }

        }   // IF unmarshaled refreshing services pointer
        else
        {
            m_pReconnectSrv->Release();
            m_pReconnectedRemote->Release();
        }

        // NULL out both stream pointers
        m_pReconnectSrv = NULL;
        m_pReconnectedRemote = NULL;

    }

    return hr;
}

HRESULT CUniversalRefresher::CRemote::Refresh(long lFlags)
{
    if(m_pRemRefresher == NULL  && IsConnected())
        return WBEM_E_CRITICAL_ERROR;

    WBEM_REFRESHED_OBJECT* aRefreshed = NULL;
    long lNumObjects = 0;

    HRESULT hresRefresh = WBEM_S_NO_ERROR;

    // Make sure we're connected.  If not, and we haven't been told not to, try to reconnect
    if ( !IsConnected() )
    {
        if ( ! (lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
        {
            hresRefresh = Reconnect();
            if ( FAILED( hresRefresh ) )
            {
                return hresRefresh;
            }
        }
        else
        {
            return RPC_E_DISCONNECTED;
        }
    }

    hresRefresh = m_pRemRefresher->RemoteRefresh(0, &lNumObjects, &aRefreshed);

    // If RemoteRefresh returns a connection type error, Set oiur state to "NOT" connected
    if(FAILED(hresRefresh))
    {
        // This will kick off a thread to reconnect if the error return was
        // a connection error, and the appropriate "Don't do this" flag is not set
        CheckConnectionError( hresRefresh, !(lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) );
        return hresRefresh;
    }

    int nSize = m_apRequests.GetSize();
    HRESULT hresFinal = WBEM_S_NO_ERROR;

    //  DEVNOTE:TODO:SANJ - We could make this much faster if we did some sorting on the
    //  server end

    for(int i = 0; i < lNumObjects; i++)
    {

        long lObjectId = aRefreshed[i].m_lRequestId;
        for(int j = 0; j < nSize; j++)
        {
            CRequest* pRequest = m_apRequests[j];
            if(pRequest->GetRemoteId() == lObjectId)
            {
                // The request will refresh itself
                HRESULT hres = pRequest->Refresh( &aRefreshed[i] );

                // Only copy this value if the refresh failed and we haven't already
                // gotten the value
                if(FAILED(hres) && SUCCEEDED(hresFinal))
                {
                    hresFinal = hres;
                }
                break;
            }
        }

        CoTaskMemFree(aRefreshed[i].m_pbBlob);
    }

    // Free the wrapping BLOB
    CoTaskMemFree( aRefreshed );

    // The final return code should give precedence to the actual remote refresh call if it
    // doesn't contain a NO_ERROR, and hresFinal is NOT an error

    if ( SUCCEEDED( hresFinal ) )
    {
        if ( WBEM_S_NO_ERROR != hresRefresh )
        {
            hresFinal = hresRefresh;
        }
    }

    return hresFinal;
}

HRESULT CUniversalRefresher::CRemote::Remove(long lId,
                            long lFlags,
                            CUniversalRefresher* pContainer)
{
    HRESULT hr = WBEM_S_FALSE;

    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        CRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            if ( IsConnected() )
            {
                // Check that the remote id doesn't indicate an item that
                // failed to be reconstructed.

                if ( pRequest->GetRemoteId() == INVALID_REMOTE_REFRESHER_ID )
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = pRequest->Cancel(this);
                }

                if ( FAILED(hr) && IsConnectionError(hr) )
                {
                    // This will kick off a reconnect thread unless we were told not to
                    CheckConnectionError( hr, !(lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) );

                    // We will remove the request from here, but
                    // queue up the id for later deletion
                    hr = WBEM_S_NO_ERROR;
                }
            }

            // DEVNOTE:TODO:SANJ - What about other errors?  For now, we'll lose the local
            // connection.

            if ( SUCCEEDED( hr ) )
            {
                // Retrieves the remote id from the request
                long    lRemoteId = pRequest->GetRemoteId();

                m_apRequests.RemoveAt(i);

                // If we couldn't remove the id remotely, just queue it up in the
                // removed id array so we can clean it up properly if we get
                // reconnected. We will, of course, not need to do anything if the
                // remote id indicates a failed readd during reconnection 

                if ( lRemoteId != INVALID_REMOTE_REFRESHER_ID && !IsConnected() )
                {
                    CInCritSec  ics(&m_cs);

                    // Note that we may have gotten connected on the critical section and
                    // if that is the case, for now, we'll have one extra resource on the
                    // server, but the likelihood of running into contention problems here
                    // is too high.  Plus, if it reconnected via a new remote refresher, if
                    // we retry a remove here, we could remove the "wrong" id.  To protect
                    // against this, we will check that we are still not connected and if
                    // that is not the case, we will just "forget" about the object id.

                    if (!IsConnected())
                    {
                        try
                        {
                            // BUBBUG:WIN64:SANJ - By casting to __int64 and back to void*, in 32-bit,
                            // this truncates the __int64, and in 64-bit, keeps away warningss.
                            m_alRemovedIds.Add( (void*) (__int64) lRemoteId );
                        }
                        catch(...)
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }   // IF Still not connected

                }   // IF Not connected

            }   // IF remote remove ok

            break;

        }   // IF found matching client id

    }   // FOR enum requests

    return hr;
}
            
CUniversalRefresher::CRemote::CRequest::CRequest(CWbemObject* pTemplate, 
                                                 long lRequestId,
                                                 LPCWSTR pwcsRequestName )
    : CClientRequest(pTemplate), m_lRemoteId(lRequestId), m_wstrRequestName( pwcsRequestName )
{
}

HRESULT CUniversalRefresher::CRemote::CRequest::Refresh( WBEM_REFRESHED_OBJECT* pRefrObj )
{
    CWbemInstance* pInst = (CWbemInstance*) GetClientObject();
    return pInst->CopyTransferBlob(
                pRefrObj->m_lBlobType, 
                pRefrObj->m_lBlobLength,
                pRefrObj->m_pbBlob);
                
}

HRESULT CUniversalRefresher::CRemote::CRequest::Cancel(
            CUniversalRefresher::CRemote* pRemote)
{
    if(pRemote->GetRemoteRefresher())
        return pRemote->GetRemoteRefresher()->StopRefreshing( 1, &m_lRemoteId, 0 );
    else
        return WBEM_S_NO_ERROR;
}

CUniversalRefresher::CRemote::CEnumRequest::CEnumRequest(CWbemObject* pTemplate, 
                                                         long lRequestId,
                                                         LPCWSTR pwcsRequestName, 
                                                         CLifeControl* pLifeControl )
    : CRequest(pTemplate, lRequestId, pwcsRequestName), m_pClientEnum(NULL)
{
    m_pClientEnum = new CReadOnlyHiPerfEnum( pLifeControl );

    // AddRef the new enumerator
    if ( NULL != m_pClientEnum )
    {
        // Don't hold onto this guy if we can't set the template
        if ( SUCCEEDED( m_pClientEnum->SetInstanceTemplate( (CWbemInstance*) pTemplate ) ) )
        {
            m_pClientEnum->AddRef();
        }
        else
        {
            // Cleanup
            delete m_pClientEnum;
            m_pClientEnum = NULL;
        }
    }
}

CUniversalRefresher::CRemote::CEnumRequest::~CEnumRequest( void )
{
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Release();
    }
}

HRESULT CUniversalRefresher::CRemote::CEnumRequest::Refresh( WBEM_REFRESHED_OBJECT* pRefrObj )
{
    return m_pClientEnum->Copy( pRefrObj->m_lBlobType,
                                pRefrObj->m_lBlobLength,
                                pRefrObj->m_pbBlob );
}

HRESULT CUniversalRefresher::CRemote::CEnumRequest::GetEnum( IWbemHiPerfEnum** ppEnum )
{
    return ( NULL != m_pClientEnum ?
                m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum ) :
                WBEM_E_FAILED );
}


//*****************************************************************************
//*****************************************************************************
//                          NESTED REFRESHERS
//*****************************************************************************
//*****************************************************************************

                    

CUniversalRefresher::CNestedRefresher::CNestedRefresher( IWbemRefresher* pRefresher )
    : m_pRefresher(pRefresher)
{
    if ( m_pRefresher )
        m_pRefresher->AddRef();

    // Assign a unique id
    m_lClientId = CUniversalRefresher::GetNewId();
}
    
CUniversalRefresher::CNestedRefresher::~CNestedRefresher()
{
    if ( m_pRefresher )
        m_pRefresher->Release();
}

HRESULT CUniversalRefresher::CNestedRefresher::Refresh( long lFlags )
{
    // Make sure we have an internal refresher pointer
    return ( NULL != m_pRefresher ? m_pRefresher->Refresh( lFlags ) : WBEM_E_FAILED );
}

//*****************************************************************************
//*****************************************************************************
//                          PROVIDER CACHE
//*****************************************************************************
//*****************************************************************************

CHiPerfProviderRecord::CHiPerfProviderRecord(REFCLSID rclsid, 
            LPCWSTR wszNamespace, IWbemHiPerfProvider* pProvider)
    : m_clsid(rclsid), m_wsNamespace(wszNamespace), m_pProvider(pProvider),
    m_lRef( 0 )
{
    if(m_pProvider)
        m_pProvider->AddRef();
}

CHiPerfProviderRecord::~CHiPerfProviderRecord()
{
    if(m_pProvider)
        m_pProvider->Release();
}

long CHiPerfProviderRecord::Release()
{
    long lRef = InterlockedDecrement( &m_lRef );

    // Removing us from the cache will delete us
    if ( 0 == lRef )
    {
        CUniversalRefresher::GetProviderCache()->RemoveRecord( this );
    }

    return lRef;
}

HRESULT CClientLoadableProviderCache::FindProvider(REFCLSID rclsid, 
                LPCWSTR wszNamespace, IUnknown* pNamespace,
                CHiPerfProviderRecord** ppProvider)
{
    CLock   lock( &m_Lock );

    // Check that we've got something to look into
    if ( NULL == m_papRecords )
    {
        return WBEM_E_FAILED;
    }

    *ppProvider = NULL;
    HRESULT hres;

    for(int i = 0; i < m_papRecords->GetSize(); i++)
    {
        CHiPerfProviderRecord* pRecord = m_papRecords->GetAt( i );
        if(pRecord->m_clsid == rclsid && 
            pRecord->m_wsNamespace.EqualNoCase(wszNamespace))
        {
            *ppProvider = pRecord;
            (*ppProvider)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // Prepare an namespace pointer
    // ============================

    IWbemServices* pServices = NULL;
    hres = pNamespace->QueryInterface(IID_IWbemServices, (void**)&pServices);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pServices);

    // Create 
    // ======

    IUnknown* pUnk = NULL;
    hres = CoCreateInstance(rclsid, NULL, CLSCTX_INPROC_SERVER,
                        IID_IUnknown, (void**)&pUnk);
    CReleaseMe rm2(pUnk);
    if(FAILED(hres))
        return hres;

    // Initialize
    // ==========

    IWbemProviderInit* pInit = NULL;
    hres = pUnk->QueryInterface(IID_IWbemProviderInit, (void**)&pInit);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm3(pInit);

    CProviderInitSink* pSink = new CProviderInitSink;
    pSink->AddRef();
    CReleaseMe rm4(pSink);

    try
    {
        hres = pInit->Initialize(NULL, 0, (LPWSTR)wszNamespace, NULL, pServices, 
                                    NULL, pSink);
    }
    catch(...)
    {
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(FAILED(hres))
        return hres;

    hres = pSink->WaitForCompletion();
    if(FAILED(hres))
        return hres;

    // Ask for the right interface
    // ===========================

    IWbemHiPerfProvider*    pProvider = NULL;

    hres = pUnk->QueryInterface(IID_IWbemHiPerfProvider, (void**)&pProvider);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm5(pProvider);

    // Create a record
    // ===============

    CHiPerfProviderRecord* pRecord = _new CHiPerfProviderRecord(rclsid, wszNamespace, pProvider);
    m_papRecords->Add(pRecord);

    // AddRef the record
    pRecord->AddRef();
    *ppProvider = pRecord;

    return WBEM_S_NO_ERROR;
}

HRESULT CClientLoadableProviderCache::FindProvider(REFCLSID rclsid,
                IWbemHiPerfProvider* pProvider, LPCWSTR wszNamespace,
                CHiPerfProviderRecord** ppProvider)
{
    CLock   lock( &m_Lock );

    // Check that we've got something to look into
    if ( NULL == m_papRecords )
    {
        return WBEM_E_FAILED;
    }

    *ppProvider = NULL;

    for(int i = 0; i < m_papRecords->GetSize(); i++)
    {
        CHiPerfProviderRecord* pRecord = m_papRecords->GetAt( i );
        if(pRecord->m_clsid == rclsid && 
            pRecord->m_wsNamespace.EqualNoCase(wszNamespace))
        {
            *ppProvider = pRecord;
            (*ppProvider)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // We already have provider pointer so we can just create a record
    // ===============

    CHiPerfProviderRecord* pRecord = _new CHiPerfProviderRecord(rclsid, wszNamespace, pProvider);
    m_papRecords->Add(pRecord);

    // AddRef the record
    pRecord->AddRef();
    *ppProvider = pRecord;

    return WBEM_S_NO_ERROR;
}

void CClientLoadableProviderCache::RemoveRecord( CHiPerfProviderRecord* pRecord )
{
    CLock   lock( &m_Lock );

    // Make sure the record didn't get accessed on another thread.
    // If not, go ahead and look for our record, and remove it
    // from the array.  When we remove it, the record will be
    // deleted.

    if ( pRecord->IsReleased() )
    {

        for(int i = 0; i < m_papRecords->GetSize(); i++)
        {
            if ( pRecord == m_papRecords->GetAt( i ) )
            {
                // This will delete the record
                m_papRecords->RemoveAt( i );
                break;
            }
        }   // FOR search records

    }   // IF record is released

}

void CClientLoadableProviderCache::Flush()
{
    CLock   lock( &m_Lock );
    if ( NULL != m_papRecords )
    {
        m_papRecords->RemoveAll();
    }
}

CClientLoadableProviderCache::~CClientLoadableProviderCache( void )
{
    // This is a static list, so if we're going away and something
    // fails here because people didn't release pointers properly,
    // chances are something will fail, so since we're being dropped
    // from memory, if the provider list is not empty, don't clean
    // it up.  This is really a bad client-created leak anyways.

    if ( NULL != m_papRecords )
    {
        if ( m_papRecords->GetSize() == 0 )
        {
            delete m_papRecords;
        }
    }

}

CClientLoadableProviderCache::CClientLoadableProviderCache( void )
:   m_papRecords( NULL )
{
    m_Lock.SetData( &m_LockData );

    // We need one of these
    m_papRecords = new CUniquePointerArray<CHiPerfProviderRecord>;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\refrcli.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCLI.H

Abstract:

	Refresher Client Side Code.

History:

--*/

#ifndef __UNIVERSAL_REFRESHER__H_
#define __UNIVERSAL_REFRESHER__H_

#include <unk.h>
#include <wbemcomn.h>

// Update this for client side refresher code.  Make sure to update server
// version in refrcache.h as well.
#define WBEM_REFRESHER_VERSION 1

class CHiPerfProviderRecord
{
public:
    long m_lRef;

    CLSID m_clsid;
    WString m_wsNamespace;
    IWbemHiPerfProvider* m_pProvider;
public:
    CHiPerfProviderRecord(REFCLSID rclsid, LPCWSTR wszNamespace, 
                        IWbemHiPerfProvider* pProvider);
    ~CHiPerfProviderRecord();
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release();

	BOOL IsReleased( void ) { return 0 == m_lRef; }

};

class CClientLoadableProviderCache
{
protected:
    CUniquePointerArray<CHiPerfProviderRecord>*	m_papRecords;
	SHARED_LOCK_DATA							m_LockData;
	CSharedLock									m_Lock;

public:
    CClientLoadableProviderCache();
	~CClientLoadableProviderCache();

    HRESULT FindProvider(REFCLSID rclsid, LPCWSTR wszNamespace, 
                IUnknown* pNamespace, CHiPerfProviderRecord** ppProvider);
    HRESULT FindProvider(REFCLSID rclsid, IWbemHiPerfProvider* pProvider,
				LPCWSTR wszNamespace, CHiPerfProviderRecord** ppProvider);
    void Flush();

	void RemoveRecord( CHiPerfProviderRecord* pRecord );

	class CLock
	{
	public:

		CLock( CSharedLock* pLock ) : m_pLock( pLock ) { if ( NULL != m_pLock ) m_pLock->Lock(); }
		~CLock() { if ( NULL != m_pLock ) m_pLock->Unlock(); }

		CSharedLock*	m_pLock;
	};
};



class CUniversalRefresher : public CUnk
{
protected:
    static CClientLoadableProviderCache mstatic_Cache;

public:
    static CClientLoadableProviderCache* GetProviderCache() 
        {return &mstatic_Cache;}

    class CClientRequest
    {
    protected:
        CWbemObject* m_pClientObject;
        long m_lClientId;
    public:
        CClientRequest(CWbemObject* pTemplate = NULL);
        virtual ~CClientRequest();

        void SetClientObject(CWbemObject* pClientObject);
        void GetClientInfo(RELEASE_ME IWbemClassObject** ppRefresher, 
                            long* plId);

        long GetClientId() {return m_lClientId;}
        INTERNAL CWbemObject* GetClientObject() {return m_pClientObject;}
    };
    
    class CDirect
    {
    public:
        class CRequest : public CClientRequest
        {
        protected:
            long m_lProviderId;
            CWbemObject* m_pProviderObject;
        public:
            CRequest(CWbemObject* pProviderObject, CWbemObject* pClientObject, long lProviderId);
            ~CRequest();
            virtual void Copy();
            HRESULT Cancel(CDirect* pDirect);
        };

		class CEnumRequest : public CRequest
		{
			protected:
				CClientLoadableHiPerfEnum*	m_pHPEnum;
				CReadOnlyHiPerfEnum*		m_pClientEnum;

			public:
				CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, long lProviderId, CLifeControl* pLifeControl);
				~CEnumRequest();

				HRESULT GetClientInfo(RELEASE_ME IWbemHiPerfEnum** ppEnum, 
									long* plId);
				void Copy();
		};

    protected:
        CHiPerfProviderRecord* m_pProvider;
        IWbemRefresher* m_pRefresher;

        CUniquePointerArray<CRequest> m_apRequests;
    public:
        INTERNAL CHiPerfProviderRecord* GetProvider() {return m_pProvider;}
        INTERNAL IWbemRefresher* GetRefresher() {return m_pRefresher;}
    public:
        CDirect(CHiPerfProviderRecord* pProvider, IWbemRefresher* pRefresher);
        ~CDirect();
        HRESULT AddRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientObject,
					long lCancelId, IWbemClassObject** ppRefresher, long* plId);

        HRESULT AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, long lCancelId,
					IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        HRESULT Remove(long lId, CUniversalRefresher* pContainer);
    };
        
    class CRemote
    {
    public:
        class CRequest : public CClientRequest
        {
        protected:
            long		m_lRemoteId;
			WString		m_wstrRequestName;

        public:
            CRequest(CWbemObject* pTemplate, long lRemoteId, LPCWSTR pwcsRequestName);
            ~CRequest(){}

            HRESULT Cancel(CRemote* pDirect);
            long GetRemoteId() {return m_lRemoteId;}
			void SetRemoteId( long lId ) { m_lRemoteId = lId; }
			LPCWSTR GetName( void ) { return m_wstrRequestName; }

			virtual BOOL IsEnum( void ) { return FALSE; }
			virtual HRESULT Refresh( WBEM_REFRESHED_OBJECT* pRefrObj );

        };

		class CEnumRequest : public CRequest
		{
        protected:
            long						m_lRemoteId;
			CReadOnlyHiPerfEnum*		m_pClientEnum;
        public:
            CEnumRequest( CWbemObject* pTemplate, long lRemoteId, LPCWSTR pwcsRequestName,
						CLifeControl* pLifeControl );
            ~CEnumRequest();

			BOOL	IsOk( void ) { return ( NULL != m_pClientEnum ); }
			HRESULT GetEnum( IWbemHiPerfEnum** ppEnum );

			virtual BOOL IsEnum( void ) { return TRUE; }
			// Override for enumerators
			HRESULT Refresh( WBEM_REFRESHED_OBJECT* pRefrObj );

		};
        
    protected:
		// The actual remote refresher
        IWbemRemoteRefresher*	m_pRemRefresher;
		// Remote Refresher GUID
		GUID					m_RemoteGuid;
		// Security Info
		COAUTHINFO				m_CoAuthInfo;
		// Namespace and server for reconnect
		BSTR					m_bstrNamespace;
		// Server for Reconnect workaround
		BSTR					m_bstrServer;
		// Are we connected
		BOOL					m_fConnected;
		// Flag tells us to quit if reconnecting
		BOOL					m_fQuit;
		// Requests
        CUniquePointerArray<CRequest>	m_apRequests;
		// Cache of ids we removed.
		CFlexArray						m_alRemovedIds;
		// Our wrapper object
		CUniversalRefresher*	m_pObject;
		// Internal Critical Section
		CCritSec				m_cs;
		// For marshaling/unmarshaling across apartment-models
		// during the reconnect phase
		IStream*				m_pReconnectedRemote;
		IStream*				m_pReconnectSrv;
		GUID					m_ReconnectGuid;

		long					m_lRefCount;

	protected:

		// Helper workaround for COM/RPC inadequacies.
		HRESULT IsAlive( void );

		static unsigned __stdcall ThreadProc( void * pThis )
		{
			return ((CRemote*) pThis)->ReconnectEntry();
		}

		unsigned ReconnectEntry( void );

		// Cleans up all the remote connections we may be holding onto
		void ClearRemoteConnections( void );

    public:
        CRemote( IWbemRemoteRefresher* pRemRefresher, COAUTHINFO* pACoAuthInfo, const GUID* pGuid,
					LPCWSTR pwszNamespace, LPCWSTR pwszServer, CUniversalRefresher* pObject );
        ~CRemote();

		ULONG STDMETHODCALLTYPE AddRef();
		ULONG STDMETHODCALLTYPE Release(); 

        HRESULT AddRequest(CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId,
                    IWbemClassObject** ppRefresher, long* plId );
        HRESULT AddEnumRequest(CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId,
					IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        HRESULT Remove(long lId, long lFlags, CUniversalRefresher* pContainer);
		HRESULT ApplySecurity( void );

		HRESULT Rebuild( IWbemServices* pNamespace );
		HRESULT Rebuild( IWbemRefreshingServices* pRefServ, IWbemRemoteRefresher* pRemRefresher,
							const GUID* pReconnectGuid );

		HRESULT Reconnect( void );
		BOOL IsConnectionError( HRESULT hr )
		{
			return ( RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr) || RPC_E_DISCONNECTED == hr ||
						RPC_S_CALL_FAILED == HRESULT_CODE(hr) );
		}
		void CheckConnectionError( HRESULT, BOOL fStartReconnect = FALSE );
		BOOL IsConnected( void )
		{
			return m_fConnected;
		}

		LPCWSTR GetNamespace( void )
		{
			return m_bstrNamespace;
		}

		void Quit( void )
		{
			m_fQuit = TRUE;
		}

    public:
        INTERNAL IWbemRemoteRefresher* GetRemoteRefresher() 
            {return m_pRemRefresher;}
    };

	class CNestedRefresher
	{
	public:
		CNestedRefresher( IWbemRefresher* pRefresher );
		~CNestedRefresher();

		HRESULT Refresh( long lFlags );
		long GetId( void )
		{ return m_lClientId; }

	private:

		IWbemRefresher*	m_pRefresher;
		long			m_lClientId;
	};

protected:
    CUniquePointerArray<CDirect> m_apDirect;
    CRefedPointerArray<CRemote> m_apRemote;
    CUniquePointerArray<CNestedRefresher> m_apNestedRefreshers;
    
    CRefresherId	m_Id;
	CHiPerfLock		m_Lock;

    static long mstatic_lLastId;
protected:
    class XRefresher : public CImpl<IWbemRefresher, CUniversalRefresher>
    {
    public:
        XRefresher(CUniversalRefresher* pObject) : 
            CImpl<IWbemRefresher, CUniversalRefresher>(pObject)
        {}

        STDMETHOD(Refresh)(long lFlags);
    } m_XRefresher;
    friend XRefresher;

    class XCreate : public CImpl<IWbemConfigureRefresher, CUniversalRefresher>
    {
    public:
        XCreate(CUniversalRefresher* pObject) : 
            CImpl<IWbemConfigureRefresher, CUniversalRefresher>(pObject)
        {}

        STDMETHOD(AddObjectByPath)(IWbemServices* pNamespace, LPCWSTR wszPath,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddObjectByTemplate)(IWbemServices* pNamespace, 
            IWbemClassObject* pTemplate,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddRefresher)(IWbemRefresher* pRefresher, long lFlags,
            long* plId);

        STDMETHOD(Remove)(long lId, long lFlags);

		STDMETHOD(AddEnum)(	IWbemServices*	pNamespace, LPCWSTR wscClassName,
			long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
			long* plId );
							
    } m_XCreate;
    friend XCreate;

protected:
    void* GetInterface(REFIID riid);

	HRESULT AddInProcObject(	CHiPerfProviderRecord* pProvider,
								IWbemObjectAccess* pTemplate,
								IWbemServices* pNamespace,
								IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddInProcEnum(		CHiPerfProviderRecord* pProvider,
								IWbemObjectAccess* pTemplate,
								IWbemServices* pNamespace, LPCWSTR wszClassName,
								IWbemHiPerfEnum** ppEnum, long* plId);


    HRESULT AddClientLoadable(const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace,
                                IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddClientLoadableEnum(	const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
									IWbemServices* pNamespace, LPCWSTR wszClassName,
									IWbemHiPerfEnum** ppEnum, long* plId);

    HRESULT AddDirect(const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace,
                                IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddDirectEnum(	const WBEM_REFRESH_INFO_DIRECT& Info,
									IWbemServices* pNamespace, LPCWSTR wszClassName,
									IWbemHiPerfEnum** ppEnum, long* plId);

	HRESULT FindRemoteEntry(	const WBEM_REFRESH_INFO_REMOTE& Info,
								COAUTHINFO* pAuthInfo,
								CRemote** ppRemoteRecord );

    HRESULT AddRemote( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
						LPCWSTR pwcsRequestName, long lCancelId, IWbemClassObject** ppRefreshable, long* plId,
						COAUTHINFO* pCoAuthInfo );
    HRESULT AddRemoteEnum ( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
								LPCWSTR pwcsRequestName, long lCancelId, IWbemHiPerfEnum** ppEnum,
								long* plId, COAUTHINFO* pCoAuthInfo );

    HRESULT AddRefresher( IWbemRefresher* pRefresher, long lFlags, long* plId );

    HRESULT Remove(long lId, long lFlags);
    HRESULT Refresh(long lFlags);

public:
    CUniversalRefresher(CLifeControl* pControl, IUnknown* pOuter = NULL) 
        : CUnk(pControl, pOuter), m_XRefresher(this), m_XCreate(this)
    {}
	~CUniversalRefresher();

	HRESULT	GetRefreshingServices( IWbemServices* pNamespace,
				IWbemRefreshingServices** ppRefSvc,
				COAUTHINFO* pCoAuthInfo );

    HRESULT FindProvider(REFCLSID rclsid, LPCWSTR wszNamespace, 
                IWbemHiPerfProvider** ppProvider);

    INTERNAL CRefresherId* GetId() {return &m_Id;}
    static long GetNewId();
    static void Flush();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\refrmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRMRSH.CPP

Abstract:

    Refresher marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include "refrmrsh.h"

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

STDMETHODIMP CFactoryBuffer::XFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemRefresher)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CProxyBuffer* pProxy = new CProxyBuffer(m_pObject->m_pControl, pUnkOuter);
    pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
    pProxy->QueryInterface(riid, (void**)ppv);
    return S_OK;
}
    
STDMETHODIMP CFactoryBuffer::XFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemRefresher)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CStubBuffer* pStub = new CStubBuffer(m_pObject->m_pControl, NULL);
    pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);
    if(pUnkServer)
    {
        HRESULT hres = (*ppStub)->Connect(pUnkServer);
        if(FAILED(hres))
        {
            delete pStub;
            *ppStub = NULL;
        }
        return hres;
    }
    else
    {
        return S_OK;
    }
}

void* CFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

ULONG STDMETHODCALLTYPE CProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemRefresher)
    {
        *ppv = (IWbemRefresher*)&m_XRefresher;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CProxyBuffer::XRefresher::
QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        // Trick #2: both are internal interfaces and should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


STDMETHODIMP CProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{
    if(m_pChannel)
        return E_UNEXPECTED;

    // Verify that the channel is local
    // ================================

    DWORD dwContext;
    if(FAILED(pChannel->GetDestCtx(&dwContext, NULL)) ||
        (dwContext != MSHCTX_INPROC && dwContext != MSHCTX_LOCAL))
    {
        return E_UNEXPECTED;
    }
    
    m_pChannel = pChannel;
    if(m_pChannel)
        m_pChannel->AddRef();

    // Receive information from the stub
    // =================================

    // Get a buffer from the channel
    // =============================

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = sizeof(DWORD);
    msg.iMethod = 3;

    HRESULT hres = pChannel->GetBuffer(&msg, IID_IWbemRefresher);
    if(FAILED(hres)) return hres;

    *(DWORD*)msg.Buffer = GetCurrentProcessId();

    // Invoke the method
    // =================

    ULONG dwRes;
    hres = pChannel->SendReceive(&msg, &dwRes);
    if(FAILED(hres))
    {
        if(msg.Buffer)
            pChannel->FreeBuffer(&msg);
        return dwRes;
    }

    // We are fine --- read the event data
    // ===================================

    m_EventPair.ReadData(msg.Buffer);
    pChannel->FreeBuffer(&msg);
    return S_OK;
}

void STDMETHODCALLTYPE CProxyBuffer::Disconnect()
{
    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

STDMETHODIMP CProxyBuffer::XRefresher::Refresh(long lFlags)
{
    return m_pObject->m_EventPair.SetAndWait();
}

CProxyBuffer::~CProxyBuffer()
{
    if(m_pChannel)
        m_pChannel->Release();
    m_pControl->ObjectDestroyed(this);
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************

void* CStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XStub;
    else
        return NULL;
}

CRefreshDispatcher CStubBuffer::XStub::mstatic_Dispatcher;

CStubBuffer::XStub::XStub(CStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CStubBuffer>(pObj), m_pServer(NULL)
{
    m_EventPair.Create();
}

CStubBuffer::XStub::~XStub() 
{
    if(m_pServer)
        m_pServer->Release();
}

STDMETHODIMP CStubBuffer::XStub::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemRefresher, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // Inform the listener of this connection
    // ======================================

    hres = mstatic_Dispatcher.Add(m_EventPair.GetGoEvent(), 
                        m_EventPair.GetDoneEvent(), m_pServer);
    if(FAILED(hres))
        return E_UNEXPECTED;

    return S_OK;
}

void STDMETHODCALLTYPE CStubBuffer::XStub::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = mstatic_Dispatcher.Remove(m_pServer);

    if(m_pServer)
        m_pServer->Release();
}

STDMETHODIMP CStubBuffer::XStub::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // Must be the proxy asking us for the data
    // ========================================

    if(pMessage->cbBuffer != sizeof(DWORD) || pMessage->iMethod != 3)
    {
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;
    }

    // Read the process id
    // ===================

    DWORD dwClientPID = *(DWORD*)pMessage->Buffer;
    
    // Allocate a new buffer
    // =====================

    pMessage->cbBuffer = m_EventPair.GetDataLength();
    HRESULT hres = pChannel->GetBuffer(pMessage, IID_IWbemRefresher);
    if(FAILED(hres)) return hres;

    // Put the info in there
    // =====================

    m_EventPair.WriteData(dwClientPID, pMessage->Buffer);
    return S_OK;
}

IRpcStubBuffer* STDMETHODCALLTYPE CStubBuffer::XStub::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemRefresher)
    {
        AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CStubBuffer::XStub::CountRefs()
{
    return 1; // ?? not sure
}

STDMETHODIMP CStubBuffer::XStub::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CStubBuffer::XStub::DebugServerRelease(void* pv)
{
}

//****************************************************************************
//****************************************************************************
//                          EVENT PAIR
//****************************************************************************
//****************************************************************************


CEventPair::~CEventPair()
{
    CloseHandle(m_hGoEvent);
    CloseHandle(m_hDoneEvent);
}

void CEventPair::Create()
{
    SECURITY_DESCRIPTOR sd;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
    
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = &sd;

    m_hGoEvent = CreateEvent(&sa, FALSE, FALSE, NULL);
    m_hDoneEvent = CreateEvent(&sa, FALSE, FALSE, NULL);
}

DWORD CEventPair::GetDataLength()
{
    return 
        sizeof(DWORD) + // m_hGoEvent
        sizeof(DWORD);  // m_hDoneEvent
}

void CEventPair::WriteData(DWORD dwClientPID, void* pvBuffer)
{
    DWORD* pdwBuffer = (DWORD*)pvBuffer;

    // Open client process
    // ===================

    HANDLE m_hClient = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwClientPID);
    if(m_hClient == NULL)
    {
        long lRes = GetLastError();
        return;
    }

    // Duplicate handles
    // =================

    if(!DuplicateHandle(GetCurrentProcess(), m_hGoEvent, m_hClient, 
        (HANDLE*)pdwBuffer, EVENT_MODIFY_STATE, FALSE, 0))
    {
        long lRes = GetLastError();
        return;
    }

    if(!DuplicateHandle(GetCurrentProcess(), m_hDoneEvent, m_hClient,
        (HANDLE*)(pdwBuffer + 1), SYNCHRONIZE, FALSE, 0))
    {
        long lRes = GetLastError();
        return;
    }
}

void CEventPair::ReadData(void* pvBuffer)
{
    DWORD* pdwBuffer = (DWORD*)pvBuffer;

    m_hGoEvent = (HANDLE)pdwBuffer[0];
    m_hDoneEvent = (HANDLE)pdwBuffer[1];
}

HRESULT CEventPair::SetAndWait()
{
    SetEvent(m_hGoEvent);
    DWORD dwRes = WaitForSingleObject(m_hDoneEvent, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return WBEM_E_CRITICAL_ERROR;

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//****************************************************************************
//                          DISPATCHER
//****************************************************************************
//****************************************************************************

CRefreshDispatcher::CRefreshDispatcher() : m_hThread(NULL)
{
    m_hAttentionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_hAcceptanceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CRefreshDispatcher::~CRefreshDispatcher()
{
    CloseHandle(m_hAttentionEvent);
    CloseHandle(m_hAcceptanceEvent);
}

BOOL CRefreshDispatcher::Add(HANDLE hGoEvent, HANDLE hDoneEvent, 
                                IWbemRefresher* pRefresher)
{
    CInCritSec ics(&m_cs); // all work in critical section

    // Store the data for the thread
    // =============================

    m_hNewGoEvent = hGoEvent;
    m_hNewDoneEvent = hDoneEvent;
    m_pNewRefresher = pRefresher;

    // Set attention event
    // ===================

    SetEvent(m_hAttentionEvent);

    // Make sure the thread is running
    // ===============================

    if(m_hThread == NULL)
    {
        DWORD dw;
        m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&staticWorker,
                        (void*)this, 0, &dw);
        if(m_hThread == NULL)
            return FALSE;
    }

    // Wait for the thread to accept
    // =============================

    DWORD dwRes = WaitForSingleObject(m_hAcceptanceEvent, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return FALSE;

    return TRUE;
}

BOOL CRefreshDispatcher::Remove(IWbemRefresher* pRefresher)
{
    CInCritSec ics(&m_cs); // all work in critical section

    // Store the data for the thread
    // =============================

    m_hNewGoEvent = NULL;
    m_hNewDoneEvent = NULL;
    m_pNewRefresher = pRefresher;

    // Set attention event
    // ===================

    SetEvent(m_hAttentionEvent);

    // Check if the thread is running
    // ==============================

    if(m_hThread == NULL)
    {
        return FALSE;
    }

    // Wait for the thread to accept
    // =============================

    DWORD dwRes = WaitForSingleObject(m_hAcceptanceEvent, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return FALSE;

    return TRUE;
}

BOOL CRefreshDispatcher::Stop()
{
    CInCritSec ics(&m_cs); // all work in critical section

    // Check if the thread is running
    // ==============================

    if(m_hThread == NULL)
    {
        return TRUE;
    }

    // Store the data for the thread
    // =============================

    m_hNewGoEvent = NULL;
    m_hNewDoneEvent = NULL;
    m_pNewRefresher = NULL;

    // Set attention event
    // ===================

    SetEvent(m_hAttentionEvent);

    // Wait for the thread to accept
    // =============================

    DWORD dwRes = WaitForSingleObject(m_hThread, INFINITE);
    if(dwRes != WAIT_OBJECT_0)
        return FALSE;

    CloseHandle(m_hThread);
    m_hThread = NULL;
    return TRUE;
}
    

DWORD CRefreshDispatcher::staticWorker(void* pv)
{
    return ((CRefreshDispatcher*)pv)->Worker();
}

DWORD CRefreshDispatcher::Worker()
{
    // Add the attention event to our array
    // ====================================

    m_aGoEvents.Add((void*)m_hAttentionEvent);
    m_apRecords.Add(NULL);

    while(1)
    {
        // Wait for any go event to be signaled
        // ====================================

        DWORD dwRes = WaitForMultipleObjects(m_aGoEvents.Size(), 
                        (HANDLE*)m_aGoEvents.GetArrayPtr(), FALSE, INFINITE);
        if(dwRes == WAIT_FAILED || dwRes == WAIT_TIMEOUT)
        {
            // TBD: log
            Sleep(1000);
            continue;
        }

        int nIndex = dwRes - WAIT_OBJECT_0;
        if(nIndex == 0)
        {
            // Attention event is signaled --- someone wants something from us
            // ===============================================================

            if(!ProcessAttentionRequest())
            {
                m_aGoEvents.Empty();
                m_apRecords.RemoveAll();
                m_hThread = NULL;
                return 0;
            }
        }
        else
        {
            // Normal event --- refresh something
            // ==================================

            HRESULT hres = m_apRecords[nIndex]->m_pRefresher->Refresh(0);
            // TBD: do something about failures

            SetEvent(m_apRecords[nIndex]->m_hDoneEvent);
        }
    }
}

BOOL CRefreshDispatcher::ProcessAttentionRequest()
{
    BOOL bRes;
    if(m_pNewRefresher == NULL)
    {
        // Time to quit!
        // =============

        bRes = FALSE;
    }
    else if(m_hNewGoEvent == NULL)
    {
        // Remove refresher
        // ================

        for(int i = 1; i < m_apRecords.GetSize(); i++)
        {
            CRecord* pRecord= m_apRecords[i];
            if(pRecord->m_pRefresher == m_pNewRefresher)
            {
                m_apRecords.RemoveAt(i);
                m_aGoEvents.RemoveAt(i);
                i--;
            }
        }
        bRes = (m_apRecords.GetSize() > 1);
    }
    else    
    {
        // Add refresher
        // =============

        CRecord* pRecord = new CRecord(m_pNewRefresher, m_hNewDoneEvent);
        m_apRecords.Add(pRecord);
        m_aGoEvents.Add((void*)m_hNewGoEvent);
        bRes = TRUE;
    }

    SetEvent(m_hAcceptanceEvent);
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\ubskmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKMRSH.CPP

Abstract:

    Unbound Sink Marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "ubskmrsh.h"
#include <fastall.h>
#include <cominit.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemUnboundObjectSink)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CUnboundSinkProxyBuffer* pProxy = new CUnboundSinkProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemUnboundObjectSink 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemUnboundObjectSink)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CUnboundSinkStubBuffer* pStub = new CUnboundSinkStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }

    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CUnboundSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XUnboundSinkFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer
//  ~CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
        m_XUnboundSinkFacelet(this), m_pChannel(NULL), m_pOldProxy( NULL ), m_pOldProxyUnboundSink( NULL ),
        m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
    m_StubType = UNKNOWN;

}

CUnboundSinkProxyBuffer::~CUnboundSinkProxyBuffer()
{
    // This MUST be released first

    if ( NULL != m_pOldProxyUnboundSink )
    {
        m_pOldProxyUnboundSink->Release();
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pControl->ObjectDestroyed(this);

}

ULONG STDMETHODCALLTYPE CUnboundSinkProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CUnboundSinkProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemUnboundObjectSink)
    {
        *ppv = (IWbemUnboundObjectSink*)&m_XUnboundSinkFacelet;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}

//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return the security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // First set the security explicitly on our IUnknown, then we will Set the blanket
    // on ourselves using the punkOuter (It's tricky but it works...uh...we think).
    
    // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
    // may have to go remote

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );

    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
//                      Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemUnboundObjectSink::Indicate calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
IndicateToConsumer( IWbemClassObject* pLogicalConsumer, LONG lObjectCount, IWbemClassObject** ppObjArray )
{
    HRESULT hr = S_OK;

    // Make sure the lObjectCount parameter and the array pointer make sense

    if ( lObjectCount < 0 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount == 0 && NULL != ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount > 0 && NULL == ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }


    CInCritSec ics(&m_cs);

    // If the stublet is an old style, just let the old proxy handle it

    if(m_pObject->m_StubType == OLD) 
        return m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, lObjectCount, ppObjArray );

    // If the stublet is unknown, send just the first object and check the return
    // code to determine what is on the other side. 

    if(m_pObject->m_StubType == UNKNOWN) 
    {
        hr = m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, 1, ppObjArray );

        // bump up pointer to the next object so that it isnt sent more than once
    
        lObjectCount--;
        ppObjArray++;

        if(hr == WBEM_S_NEW_STYLE)
        {
            m_pObject->m_StubType = NEW;
        }
        else
        {
            // We have an old client, set the stub type and send any remaining objects

            m_pObject->m_StubType = OLD;
            if(lObjectCount > 0)
                hr = m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, lObjectCount, ppObjArray );
            return hr;
        }
    }


    if(lObjectCount < 1)
        return S_OK;            // if all done, then just return.

    // Create a packet and some data for it to use.  Then calculate 
    // the length of the packet

    DWORD dwLength;
    GUID* pguidClassIds = new GUID[lObjectCount];
    BOOL* pfSendFullObject = new BOOL[lObjectCount];

    // arrays will be deleted when we drop out of scope.
    CVectorDeleteMe<GUID>   delpguidClassIds( pguidClassIds );
    CVectorDeleteMe<BOOL>   delpfSendFullObject( pfSendFullObject );

    CWbemUnboundSinkIndicatePacket packet;
    hr = packet.CalculateLength( pLogicalConsumer, lObjectCount, ppObjArray, &dwLength, 
            m_pObject->m_ClassToIdMap, pguidClassIds, pfSendFullObject );

    // Declare the message structure

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = dwLength;

    // This is the id of the Invoke function.  This MUST be set before calling GetBuffer, or 
    // it will fail.

    msg.iMethod = 3;

    // allocate the channel buffer and marshal the data into it

    HRESULT hres = m_pObject->GetChannel()->GetBuffer(&msg, IID_IWbemUnboundObjectSink);
    if(FAILED(hres)) return hres;

    // Setup the packet for marshaling
    hr = packet.MarshalPacket(  (LPBYTE)msg.Buffer, dwLength, pLogicalConsumer, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);

    // Send the data to the stub only if the marshaling was successful

    if ( SUCCEEDED( hr ) )
    {

        DWORD dwRes;
        hr = m_pObject->GetChannel()->SendReceive(&msg, &dwRes);
        if(FAILED(hr))
        {
            if(msg.Buffer)
                m_pObject->GetChannel()->FreeBuffer(&msg);
            return dwRes;
        }

        // We appear to be ok, so get HRESULT

        LPBYTE pbData = (LPBYTE) msg.Buffer;
        hr = *((HRESULT*) pbData);
        m_pObject->GetChannel()->FreeBuffer(&msg);

    }
    else
    {
        // Clean up the buffer -- Marshaling the packet failed
        if(msg.Buffer)
            m_pObject->GetChannel()->FreeBuffer(&msg);
    }

    return hr;

}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    // get a pointer to the old UnboundSink which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // Establish the marshaling context
    DWORD   dwCtxt = 0;
    pChannel->GetDestCtx( &dwCtxt, NULL );

    m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.


    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

    // We aggregated it --- WE OWN IT!
    
    hr = pIPS->CreateProxy( this, IID_IWbemUnboundObjectSink, &m_pOldProxy, (void**) &m_pOldProxyUnboundSink );
    pIPS->Release();

    // Save a reference to the channel

    hr = m_pOldProxy->Connect( pChannel );

    if(m_pChannel)
        return E_UNEXPECTED;
    
    m_pChannel = pChannel;
    if(m_pChannel)
        m_pChannel->AddRef();

    return S_OK;
}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CUnboundSinkProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old Proxy UnboundSink MUST be released first.

    if ( NULL != m_pOldProxyUnboundSink )
    {
        m_pOldProxyUnboundSink->Release();
        m_pOldProxyUnboundSink = NULL;
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CUnboundSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CUnboundSinkStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XUnboundSinkStublet;
    else
        return NULL;
}

CUnboundSinkStubBuffer::XUnboundSinkStublet::XUnboundSinkStublet(CUnboundSinkStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CUnboundSinkStubBuffer>(pObj), m_pServer(NULL), m_lConnections( 0 )
{
    m_bFirstIndicate = true;
}

CUnboundSinkStubBuffer::XUnboundSinkStublet::~XUnboundSinkStublet() 
{
    if(m_pServer)
        m_pServer->Release();

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject UnboundSink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemUnboundObjectSink, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // get a pointer to the old stub which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.


    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

    hr = pIPS->CreateStub( IID_IWbemUnboundObjectSink, m_pServer, &m_pObject->m_pOldStub );

    pIPS->Release();

    // Successful connection

    m_lConnections++;
    return S_OK;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemUnboundObjectSink
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    if(m_pServer)
    {
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Successful disconnect
    m_lConnections--;

}


//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( pMessage->iMethod == 3 )
        return IndicateToConsumer_Stub( pMessage, pChannel );
    else
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;

}

//***************************************************************************
//
//  HRESULT CUnboundSinkStubBuffer::XUnboundSinkStublet::IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, 
//                                                        IRpcChannelBuffer* pBuffer )
//
//  DESCRIPTION:
//
//  Handles the Indicate function in the stublet.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CUnboundSinkStubBuffer::XUnboundSinkStublet::IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer )
{
    HRESULT             hr = RPC_E_SERVER_CANTUNMARSHAL_DATA;
    SCODE sc;

    // Determine if an old style, or new style packet has arrived

    CWbemUnboundSinkIndicatePacket packet( (LPBYTE) pMessage->Buffer, pMessage->cbBuffer);
    sc = packet.IsValid();
    bool bOldStyle = (S_OK != packet.IsValid());

    if(bOldStyle)
    {
        // Pass the call in using the old style stub

        hr = m_pObject->m_pOldStub->Invoke( pMessage, pBuffer );
        if(hr == S_OK && m_bFirstIndicate)
        {
            // Let proxy know that we can handle the new style by returning a special return code.
        
            *(( HRESULT __RPC_FAR * )pMessage->Buffer) = WBEM_S_NEW_STYLE;
            m_bFirstIndicate = false;
            return hr;
        }
        return hr;
    }

    m_bFirstIndicate = false;

    // Got some new style data.  Unmarshall it.

    long lObjectCount = 0; 
    IWbemClassObject*   pLogicalConsumer = NULL;
    IWbemClassObject ** pObjArray = NULL;
    sc = packet.UnmarshalPacket( pLogicalConsumer, lObjectCount, pObjArray, m_ClassCache );

    // Only continue if the Unmarshaling succeeded.  If it failed, we still want
    // the sc to go back to the other side

    if ( SUCCEEDED( sc ) )
    {

        // Call the acual UnboundSink
        sc = m_pServer->IndicateToConsumer( pLogicalConsumer, lObjectCount, pObjArray );

        for ( int nCtr = 0; nCtr < lObjectCount; nCtr++ )
        {
            pObjArray[nCtr]->Release();
        }
    
        delete [] pObjArray;

        // Done with the logical consumer
        if ( NULL != pLogicalConsumer )
        {
            pLogicalConsumer->Release();
        }

    }

    // Send the results back

    pMessage->cbBuffer = sizeof(HRESULT);

    hr = pBuffer->GetBuffer( pMessage, IID_IWbemUnboundObjectSink );

    if ( SUCCEEDED( hr ) )
    {
        ((HRESULT*)pMessage->Buffer)[0] = sc;
    }
    else
    {
        hr = sc;
    }
    return hr;

}

IRpcStubBuffer* STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\ubskmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKMRSH.H

Abstract:

    Unbound Sink Marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include "ubskpckt.h"

//***************************************************************************
//
//  class CUnboundSinkFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemUnboundObjectSink interface.
//
//***************************************************************************

class CUnboundSinkFactoryBuffer : public CUnk
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XUnboundSinkFactory : public CImpl<IPSFactoryBuffer, CUnboundSinkFactoryBuffer>
    {
    public:
        XUnboundSinkFactory(CUnboundSinkFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CUnboundSinkFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XUnboundSinkFactory;
public:
    CUnboundSinkFactoryBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(NULL, pUnkOuter), m_XUnboundSinkFactory(this), m_pLifeControl( pControl )
    {}

    void* GetInterface(REFIID riid);

	friend XUnboundSinkFactory;
};

//***************************************************************************
//
//  class CUnboundSinkProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemUnboundObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CUnboundSinkProxyBuffer : public IRpcProxyBuffer
{
private:
	IRpcProxyBuffer*	m_pOldProxy;
	IWbemUnboundObjectSink*	m_pOldProxyUnboundSink;
    enum {OLD, NEW, UNKNOWN} m_StubType;
    CWbemClassToIdMap m_ClassToIdMap;
	bool		m_fRemote;

protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XUnboundSinkFacelet : public IWbemUnboundObjectSink, IClientSecurity
    {
    protected:
        CUnboundSinkProxyBuffer* m_pObject;
        CRITICAL_SECTION m_cs;        

    public:
        XUnboundSinkFacelet(CUnboundSinkProxyBuffer* pObject) : m_pObject(pObject){InitializeCriticalSection(&m_cs);};
        ~XUnboundSinkFacelet(){DeleteCriticalSection(&m_cs);};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE IndicateToConsumer( IWbemClassObject* pLogicalConsumer, LONG lObjectCount, IWbemClassObject** ppObjArray );

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XUnboundSinkFacelet;
    friend XUnboundSinkFacelet;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

public:
    CUnboundSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CUnboundSinkProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CUnboundSinkStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemUnboundObjectSink interface.
//
//***************************************************************************

class CUnboundSinkStubBuffer : public CUnk
{
private:

	IRpcStubBuffer*	m_pOldStub;

protected:
    class XUnboundSinkStublet : public CImpl<IRpcStubBuffer, CUnboundSinkStubBuffer>
    {
        IWbemUnboundObjectSink* m_pServer;
		LONG			m_lConnections;
        CWbemClassCache m_ClassCache;
        bool m_bFirstIndicate;
    public:
        XUnboundSinkStublet(CUnboundSinkStubBuffer* pObj);
        ~XUnboundSinkStublet();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
	private:

		HRESULT IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer );
        friend CUnboundSinkStubBuffer;
    } m_XUnboundSinkStublet;
    friend XUnboundSinkStublet;

public:
    CUnboundSinkStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XUnboundSinkStublet(this), m_pOldStub( NULL )
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\sinkmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SINKMRSH.H

Abstract:

    IWbemObjectSink marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <objindpacket.h>
#include "mrshbase.h"

//***************************************************************************
//
//  class CSinkFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CSinkFactoryBuffer : public CUnk
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XSinkFactory : public CImpl<IPSFactoryBuffer, CSinkFactoryBuffer>
    {
    public:
        XSinkFactory(CSinkFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CSinkFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XSinkFactory;
public:
    CSinkFactoryBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(NULL, pUnkOuter), m_pLifeControl( pControl ), m_XSinkFactory(this)
    {}

    void* GetInterface(REFIID riid);

	friend XSinkFactory;
};

//***************************************************************************
//
//  class CSinkProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CSinkProxyBuffer : public CBaseProxyBuffer
{
private:
    enum {OLD, NEW, UNKNOWN} m_StubType;
    CWbemClassToIdMap m_ClassToIdMap;

protected:
	IWbemObjectSink*	m_pOldProxySink;

protected:
    class XSinkFacelet : public IWbemObjectSink
    {
    protected:
        CSinkProxyBuffer* m_pObject;
        CRITICAL_SECTION m_cs;        

    public:
        XSinkFacelet(CSinkProxyBuffer* pObject) : m_pObject(pObject){InitializeCriticalSection(&m_cs);};
        ~XSinkFacelet(){DeleteCriticalSection(&m_cs);};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray );
		HRESULT STDMETHODCALLTYPE SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam );
    } m_XSinkFacelet;
    friend XSinkFacelet;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

public:
    CSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CSinkProxyBuffer();
};

//***************************************************************************
//
//  class CSinkStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CSinkStubBuffer : public CBaseStubBuffer
{

protected:
    class XSinkStublet : public CBaseStublet
    {
        IWbemObjectSink* m_pServer;
        CWbemClassCache m_ClassCache;
        bool m_bFirstIndicate;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XSinkStublet(CSinkStubBuffer* pObj);
        ~XSinkStublet();

        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        
	private:
		HRESULT Indicate_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer );
        friend CSinkStubBuffer;
    } m_XSinkStublet;
    friend XSinkStublet;

public:
    CSinkStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer( pControl, pUnkOuter ), m_XSinkStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\ubskpckt.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKPCKT.H

Abstract:

    Unbound Sink Packet

History:

--*/

#ifndef __UBSINKPACKET_H__
#define __UBSINKPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_UNBOUNDSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwLogicalConsumerSize;	// Size of Logical Consumer Object
} WBEM_DATAPACKET_UNBOUNDSINK_INDICATE;

typedef WBEM_DATAPACKET_UNBOUNDSINK_INDICATE* PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemUnboundSinkIndicatePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemUnbopundObjectSink::IndicateToConsumer() operation.  The data
//	structure of this packet is described above.  It makes use of
//	CWbemObjectPacket, CWbemInstancePacket, CWbemClassPacket and
//	CWbemClasslessInstancePacket to walk and analyze data for each of
//	the IWbemClassObjects that are indicated into the Sink.
//

class CWbemUnboundSinkIndicatePacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE	m_pUnboundSinkIndicate;

public:

	CWbemUnboundSinkIndicatePacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemUnboundSinkIndicatePacket();

	HRESULT CalculateLength( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
				IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
				IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( IWbemClassObject*& pLogicalConsumer, LONG& lObjectCount,
							IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, IWbemClassObject* pLogicalConsumer, 
				LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds,
				BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemUnboundSinkIndicatePacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength,
															 IWbemClassObject* pLogicalConsumer,
															 LONG lObjectCount,
															 IWbemClassObject** apClassObjects,
															 GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( pLogicalConsumer, lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\ubskpckt.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKPCKT.CPP

Abstract:

    Unbound Sink Packet

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "ubskpckt.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::CWbemUnboundSinkIndicatePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemUnboundSinkIndicatePacket::CWbemUnboundSinkIndicatePacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pUnboundSinkIndicate( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pUnboundSinkIndicate = (PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::~CWbemUnboundSinkIndicatePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemUnboundSinkIndicatePacket::~CWbemUnboundSinkIndicatePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              IWbemClassObject*   pLogicalConsumer - Consumer Object
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::CalculateLength( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
                                                        IWbemClassObject** apClassObjects, DWORD* pdwLength,
                                                        CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds,
                                                        BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwObjectLength = 0;

    // Get the size of the logical consumer object.  If it doesn't exist, obviously
    // its size is 0

    if ( NULL != pLogicalConsumer )
    {
        IWbemObjectInternals* pObjInternals = NULL;

        hr = pLogicalConsumer->QueryInterface( IID_IWbemObjectInternals, (void**) &pObjInternals );

        if ( SUCCEEDED( hr ) )
        {

            // We need enough room to store the logical consumer object
            hr = pObjInternals->GetObjectMemory( NULL, 0, &dwObjectLength );

            // This is not an error
            if ( WBEM_E_BUFFER_TOO_SMALL == hr )
            {
                hr = WBEM_S_NO_ERROR;
            }

            // Cleanup the AddRef
            pObjInternals->Release();

        }   // IF QI

    }   // IF pLogicalConsumer

    // Now factor in the actual array
    if ( SUCCEEDED( hr ) )
    {
        DWORD   dwArrayLength = 0;

        // Now get the size of the objects as described by the object array
        CWbemObjectArrayPacket  arrayPacket;

        hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwArrayLength, classtoidmap, pguidClassIds, pfSendFullObject );

        // Store the length if we're okey-dokey
        if ( SUCCEEDED( hr ) )
        {
            // Account for the header sizes
            *pdwLength = ( dwArrayLength + dwObjectLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_UNBOUNDSINK_INDICATE ) );
        }

    }   // IF Got Object Length

    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              IWbemClassObject*   pLogicalConsumer - Consumer Object
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::MarshalPacket( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
                                                      IWbemClassObject** apClassObjects, GUID* paguidClassIds,
                                                      BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE, 0 );

    if ( SUCCEEDED( hr ) )
    {
        DWORD   dwUnboundObjectLength = 0;

        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pUnboundSinkIndicate;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the Indicate Header
        m_pUnboundSinkIndicate->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        m_pUnboundSinkIndicate->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        if ( NULL != pLogicalConsumer )
        {

            // Now we will get the object memory and copy it into the buffer,
            // remembering that we will be filling the LogicalConsumerLength in
            // the header with the proper object buffer size.

            IWbemObjectInternals*   pObjInternals = NULL;

            hr = pLogicalConsumer->QueryInterface( IID_IWbemObjectInternals, (void**) &pObjInternals );

            if ( SUCCEEDED( hr ) )
            {

                // We need enough room to store the logical consumer object
                hr = pObjInternals->GetObjectMemory( pbData, dwLength, &m_pUnboundSinkIndicate->dwLogicalConsumerSize );

                // Cleanup QI AddRef
                pObjInternals->Release();
                
            }   // IF QI

        }   // IF NULL != pLogicalConsumer
        else
        {
            // No consumer, so the length must be 0
            m_pUnboundSinkIndicate->dwLogicalConsumerSize = 0;
        }

        // Now marshal the array packet
        if ( SUCCEEDED( hr ) )
        {
            // Adjust for the logical consumer object then package up the rest of the array
            pbData += m_pUnboundSinkIndicate->dwLogicalConsumerSize;
            dwLength -= m_pUnboundSinkIndicate->dwLogicalConsumerSize;

            // Now use the array packet class to marshal the objects into the buffer
            CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
            hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

        }   // IF GetObjectMemory



    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              IWbemClassObject*&  pLogicalConsumer - Consumer Object
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::UnmarshalPacket( IWbemClassObject*& pLogicalConsumer, LONG& lObjectCount,
                                                        IWbemClassObject**& apClassObjects,
                                                        CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pUnboundSinkIndicate;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and try to construct the logical consumer from memory.

        // Points us at the logical consumer object
        pbData += sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        // Only need to handle the logical consumer if there was one.  If there wasn't then
        // the size will be 0.

        if ( m_pUnboundSinkIndicate->dwLogicalConsumerSize > 0 )
        {
            // Allocate a buffer big enough to hold the memory blob, copy out the data and then
            // create us an object from the memory

            LPBYTE  pbObjData = new BYTE[m_pUnboundSinkIndicate->dwLogicalConsumerSize];

            if ( NULL != pbObjData )
            {
                // Copy the bytes (this is VERY IMPORTANT)
                memcpy( pbObjData, pbData, m_pUnboundSinkIndicate->dwLogicalConsumerSize );

                pLogicalConsumer = CWbemObject::CreateFromMemory( pbObjData, m_pUnboundSinkIndicate->dwLogicalConsumerSize, TRUE );

                if ( NULL == pLogicalConsumer )
                {
                    // Cleanup the byte array
                    delete [] pbObjData;
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF logical cosumer size is > 0
        else
        {
            // No consumer to worry ourselves over
            pLogicalConsumer = NULL;
        }

        // Unmarshal the object array
        if ( SUCCEEDED( hr ) )
        {
            // Now skip over the object and try to unwind the object array
            pbData += m_pUnboundSinkIndicate->dwLogicalConsumerSize;
            dwLength -= m_pUnboundSinkIndicate->dwLogicalConsumerSize;

            // Unwind the array
            CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
            hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );
        }

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemUnboundSinkIndicatePacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pUnboundSinkIndicate = (PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pUnboundSinkIndicate = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\kerbtest\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WBEM kerberos provider sample code
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "kerbtest.h"

//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;
    return;
}

CProvFactory::~CProvFactory(void)
{
    return;
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
{
    IWbemProviderInit *   pInit;
    HRESULT hr;

    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the Initialize object.
    
    pInit=new CKerbTestPro();

    if (NULL==pInit)
        return E_OUTOFMEMORY;

    hr=pInit->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pInit;
    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\fastprox\sinkmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SINKMRSH.CPP

Abstract:

    IWbemObjectSink marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "sinkmrsh.h"
#include <fastall.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSinkFactoryBuffer::XSinkFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSinkFactoryBuffer::XSinkFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemObjectSink)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CSinkProxyBuffer* pProxy = new CSinkProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CSinkFactoryBuffer::XSinkFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemObjectSink 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CSinkFactoryBuffer::XSinkFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemObjectSink)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CSinkStubBuffer* pStub = new CSinkStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CSinkFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XSinkFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSinkProxyBuffer::CSinkProxyBuffer
//  ~CSinkProxyBuffer::CSinkProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CSinkProxyBuffer::CSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IWbemObjectSink ), 
        m_XSinkFacelet(this), m_pOldProxySink( NULL )
{
    m_StubType = UNKNOWN;
}

CSinkProxyBuffer::~CSinkProxyBuffer()
{
    // This should be cleaned up here

    if ( NULL != m_pOldProxySink )
    {
        m_pOldProxySink->Release();
    }

}

void* CSinkProxyBuffer::GetInterface( REFIID riid )
{
    if(riid == IID_IWbemObjectSink)
        return &m_XSinkFacelet;
    else return NULL;
}

void** CSinkProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxySink;
}

void CSinkProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxySink )
    {
        m_pOldProxySink->Release();
        m_pOldProxySink = NULL;
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//                      Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemObjectSink::Indicate calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )
{
    HRESULT hr = S_OK;

    // Make sure the lObjectCount parameter and the array pointer make sense

    if ( lObjectCount < 0 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount == 0 && NULL != ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount > 0 && NULL == ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }


    CInCritSec ics(&m_cs);

    // If the stublet is an old style, just let the old proxy handle it

    if(m_pObject->m_StubType == OLD) 
        return m_pObject->m_pOldProxySink->Indicate( lObjectCount, ppObjArray );

    // If the stublet is unknown, send just the first object and check the return
    // code to determine what is on the other side. 

    if(m_pObject->m_StubType == UNKNOWN) 
    {
        hr = m_pObject->m_pOldProxySink->Indicate( 1, ppObjArray );

        // bump up pointer to the next object so that it isnt sent more than once
    
        lObjectCount--;
        ppObjArray++;

        if(FAILED(hr))
            return hr;
        if(hr == WBEM_S_NEW_STYLE)
        {
            m_pObject->m_StubType = NEW;
        }
        else
        {
            // We have an old client, set the stub type and send any remaining objects

            m_pObject->m_StubType = OLD;
            if(lObjectCount > 0)
                hr = m_pObject->m_pOldProxySink->Indicate( lObjectCount, ppObjArray );
            return hr;
        }
    }

    if(lObjectCount < 1)
        return S_OK;            // if all done, then just return.

    // Create a packet and some data for it to use.  Then calculate 
    // the length of the packet

    DWORD dwLength;
    GUID* pguidClassIds = new GUID[lObjectCount];
    BOOL* pfSendFullObject = new BOOL[lObjectCount];

    // arrays will be deleted when we drop out of scope.
    CVectorDeleteMe<GUID>   delpguidClassIds( pguidClassIds );
    CVectorDeleteMe<BOOL>   delpfSendFullObject( pfSendFullObject );

    if ( NULL == pguidClassIds || NULL == pfSendFullObject )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemObjSinkIndicatePacket packet;
    hr = packet.CalculateLength(lObjectCount, ppObjArray, &dwLength, 
            m_pObject->m_ClassToIdMap, pguidClassIds, pfSendFullObject );

    // Declare the message structure

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = dwLength;

    // This is the id of the Invoke function.  This MUST be set before calling GetBuffer, or 
    // it will fail.

    msg.iMethod = 3;

    // allocate the channel buffer and marshal the data into it

    HRESULT hres = m_pObject->GetChannel()->GetBuffer(&msg, IID_IWbemObjectSink);
    if(FAILED(hres)) return hres;

    // Setup the packet for marshaling
    hr = packet.MarshalPacket(  (LPBYTE)msg.Buffer, dwLength, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);

    // Send the data to the stub only if the marshaling was successful

    if ( SUCCEEDED( hr ) )
    {

        DWORD dwRes;
        hr = m_pObject->GetChannel()->SendReceive(&msg, &dwRes);
        if(FAILED(hr))
        {
            if(msg.Buffer)
                m_pObject->GetChannel()->FreeBuffer(&msg);
            return dwRes;
        }

        // We appear to be ok, so get HRESULT

        LPBYTE pbData = (LPBYTE) msg.Buffer;
        hr = *((HRESULT*) pbData);
        m_pObject->GetChannel()->FreeBuffer(&msg);

    }
    else
    {
        // Clean up the buffer -- Marshaling the packet failed
        if(msg.Buffer)
            m_pObject->GetChannel()->FreeBuffer(&msg);
    }

    return hr;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//     SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemObjectSink::SetStatus calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
      SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam )
{

    // Just pass through to the old sink.
    return m_pObject->m_pOldProxySink->SetStatus( lFlags, hResult, strParam, pObjParam );

}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CSinkStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XSinkStublet;
    else
        return NULL;
}

CSinkStubBuffer::XSinkStublet::XSinkStublet(CSinkStubBuffer* pObj) 
    : CBaseStublet(pObj, IID_IWbemObjectSink), m_pServer(NULL)
{
    m_bFirstIndicate = true;
}

CSinkStubBuffer::XSinkStublet::~XSinkStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CSinkStubBuffer::XSinkStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CSinkStubBuffer::XSinkStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CSinkStubBuffer::XSinkStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CSinkStubBuffer::XSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSinkStubBuffer::XSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( pMessage->iMethod == 3 )
        return Indicate_Stub( pMessage, pChannel );
    else if ( pMessage->iMethod == 4 )
        return GetOldStub()->Invoke( pMessage, pChannel );
    else
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;

}

//***************************************************************************
//
//  HRESULT CSinkStubBuffer::XSinkStublet::Indicate_Stub( RPCOLEMESSAGE* pMessage, 
//                                                        IRpcChannelBuffer* pBuffer )
//
//  DESCRIPTION:
//
//  Handles the Indicate function in the stublet.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CSinkStubBuffer::XSinkStublet::Indicate_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer )
{
    HRESULT             hr = RPC_E_SERVER_CANTUNMARSHAL_DATA;
    SCODE sc;

    // Determine if an old style, or new style packet has arrived

    CWbemObjSinkIndicatePacket packet( (LPBYTE) pMessage->Buffer, pMessage->cbBuffer);
    sc = packet.IsValid();
    bool bOldStyle = (S_OK != packet.IsValid());

    if(bOldStyle)
    {
        // Pass the call in using the old style stub

        hr = GetOldStub()->Invoke( pMessage, pBuffer );
        if(hr == S_OK && m_bFirstIndicate)
        {
            // Let proxy know that we can handle the new style by returning a special return code.
        
            *(( HRESULT __RPC_FAR * )pMessage->Buffer) = WBEM_S_NEW_STYLE;
            m_bFirstIndicate = false;
            return hr;
        }
        return hr;
    }
    m_bFirstIndicate = false;

    // Got some new style data.  Unmarshall it.

    long lObjectCount; 
    IWbemClassObject ** pObjArray;
    sc = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

    // Only continue if the Unmarshaling succeeded.  If it failed, we still want
    // the sc to go back to the other side

    if ( SUCCEEDED( sc ) )
    {

        // Call the acual sink

        sc = m_pServer->Indicate( lObjectCount, pObjArray );


        for ( int nCtr = 0; nCtr < lObjectCount; nCtr++ )
        {
            pObjArray[nCtr]->Release();
        }
    
        delete [] pObjArray;

    }

    // Send the results back

    pMessage->cbBuffer = sizeof(HRESULT);

    hr = pBuffer->GetBuffer( pMessage, IID_IWbemObjectSink );

    if ( SUCCEEDED( hr ) )
    {
        ((HRESULT*)pMessage->Buffer)[0] = sc;
    }
    else
    {
        hr = sc;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\kerbtest\kerbtest.cpp ===
//***************************************************************************
//
//  KERBTEST.CPP
//
//  Module: WBEM kerberos provider sample code
//
//  Purpose: Defines the CKerbTestPro class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#define _WIN32_WINNT    0x0400

#include <objbase.h>
#include "kerbtest.h"
#include <process.h>
#include <wbemidl.h>
#include <stdio.h>
#include <objbase.h>



//***************************************************************************
//
// CKerbTestPro::CKerbTestPro
// CKerbTestPro::~CKerbTestPro
//
//***************************************************************************

CKerbTestPro::CKerbTestPro()
{
    InterlockedIncrement(&g_cObj);
    return;
   
}

CKerbTestPro::~CKerbTestPro(void)
{
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CKerbTestPro::QueryInterface
// CKerbTestPro::AddRef
// CKerbTestPro::Release
//
// Purpose: IUnknown members for CKerbTestPro object.
//***************************************************************************


STDMETHODIMP CKerbTestPro::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IWbemServices == riid || IID_IWbemProviderInit==riid)
       if(riid== IID_IWbemServices){
          *ppv=(IWbemServices*)this;
       }

       if(IID_IUnknown==riid || riid== IID_IWbemProviderInit){
          *ppv=(IWbemProviderInit*)this;
       }
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CKerbTestPro::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CKerbTestPro::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*CKerbTestPro::Initialize                                                *
*                                                                      *
*Purpose: This is the implementation of IWbemProviderInit. The method  *
* is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/
STDMETHODIMP CKerbTestPro::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{

   
   m_pWbemSvcs=pNamespace;
   m_pWbemSvcs->AddRef();
   
    //Let CIMOM know your initialized
    //===============================
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}



/************************************************************************
*                                                                       *      
*CKerbTestPro::ExecMethodAsync                                          *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*         The only method supported in this sample is named .  It       * 
*         takes an input string, copies it to the output and returns the* 
*         length.  The mof definition is                                *
*                                                                       *
*  [dynamic: ToInstance, provider("KerbTest")]class KerbTest            *
*  {                                                                    * 
*     [implemented, static]                                             *
*        uint32 RemoteGetObject([IN]string sObjPath= "__win32provider" ,*
*					[IN]string sNamespace= "\\\\a-khint3\\root" ,       *
*				    [IN]string sPrincipal="a-davjdom\\a-khint3",        *
*   [out] object OutArg); };                                            *
*                                                                       *
************************************************************************/

STDMETHODIMP CKerbTestPro::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;


    // Do some minimal error checking.  This code only support the
    // method "RemoteGetObject".

    if(_wcsicmp(MethodName, L"RemoteGetObject") || pInParams == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// Get the class object and spawn an instance of the return parameters

    BSTR ClassName = SysAllocString(L"KerbTest");    
	hr = m_pWbemSvcs->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	SysFreeString(ClassName);
	if(hr != S_OK)
	{
		pResultSink->SetStatus(0,hr, NULL, NULL);
		 return WBEM_S_NO_ERROR;
	}

	hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
	pClass->Release();
	pOutClass->SpawnInstance(0, &pOutParams);
	pOutClass->Release();


    // Copy the input arguments into variants    
	// The first argument is the object path and should be an instance or class
	// The second is the remote namespace.  It should be "\\machine\root" etc,
	// The last is the pricipal.  For Kerberos, it should be a combination of
	// the domain and machine name.  Ex;   "a-davjdom\machine"

    VARIANT varObjPath;
    VariantInit(&varObjPath);    // Get the input argument
    pInParams->Get(L"sObjPath", 0, &varObjPath, NULL, NULL);   
	
    VARIANT varNamespace;
    VariantInit(&varNamespace);    // Get the input argument
    pInParams->Get(L"sNamespace", 0, &varNamespace, NULL, NULL);   

    VARIANT varPrincipal;
    VariantInit(&varPrincipal);    // Get the input argument
    pInParams->Get(L"sPrincipal", 0, &varPrincipal, NULL, NULL);   

	// Get the remote machine name.  Extract it from the namespace name.  Note that
	// production code would do a few checks here!

	WCHAR wMachineName[30];
	WCHAR * pTo = wMachineName;
	WCHAR * pFrom = varNamespace.bstrVal + 2;	// The 2 is for skipping around the leading slashes
	for(; *pFrom != L'\\' ; pTo++, pFrom++)
		*pTo = *pFrom;
	*pTo = 0;

	// Impersonate

	hr = CoImpersonateClient();


	// The following code replaces a ConnectServer call!!!
	// Start of by getting the Login object on the remote machine.

	COSERVERINFO csi, *pcsi=NULL;
	MULTI_QI    mq;
	COAUTHINFO AuthInfo;

	IWbemServices *pNamespace = 0;

	memset(&csi, 0, sizeof(COSERVERINFO));
    csi.pwszName = wMachineName;
    pcsi = &csi;

	AuthInfo.dwAuthnSvc = 16;
	AuthInfo.dwAuthzSvc = RPC_C_AUTHZ_NONE;
	AuthInfo.pwszServerPrincName = varPrincipal.bstrVal;
	AuthInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
	AuthInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE;
	AuthInfo.pAuthIdentityData = NULL;
	AuthInfo.dwCapabilities = 0X20; 
	pcsi->pAuthInfo = &AuthInfo;

	// create a remote instance of the Login object on the remote machine
	mq.pIID = &IID_IWbemLevel1Login;
    	mq.pItf = NULL;
    	mq.hr = S_OK;
	hr = CoCreateInstanceEx(CLSID_WbemLevel1Login, NULL, CLSCTX_REMOTE_SERVER, pcsi, 1, &mq);
	IWbemLevel1Login * m_pLevel1 = (IWbemLevel1Login*)mq.pItf;

	if ((hr == S_OK))
	{
		hr = CoSetProxyBlanket(
							m_pLevel1, 
							16, 
							RPC_C_AUTHZ_NONE, 
							varPrincipal.bstrVal,
							RPC_C_AUTHN_LEVEL_CONNECT, 
							RPC_C_IMP_LEVEL_IMPERSONATE, 
							NULL,
							0x20);

		// Use the remote login object to create a services pointer

        hr = m_pLevel1->NTLMLogin(varNamespace.bstrVal, NULL, 0, NULL, &pNamespace); 
		if(hr == S_OK)
			hr = CoSetProxyBlanket(
							pNamespace, 
							16, 
							RPC_C_AUTHZ_NONE, 
							varPrincipal.bstrVal,
							RPC_C_AUTHN_LEVEL_CONNECT, 
							RPC_C_IMP_LEVEL_IMPERSONATE, 
							NULL,
							0x20);
		hr = m_pLevel1->Release();
	}

    if(hr == S_OK)
	{

		// At this point we have a services interface to a remote machine
		// Call get object and revert to self.

		IWbemClassObject * pObj = NULL;
		hr = pNamespace->GetObject(varObjPath.bstrVal, 0, NULL, &pObj, NULL);
		CoRevertToSelf();
		
		if(hr == S_OK)
		{
			// This code is mainly for demo purposes.  This embeds the returned object
			// in the return object of the method and has nothing to do with Kerberos!

			VARIANT var;
			VariantInit(&var);    // Get the input argument
			var.punkVal = (IUnknown *)pObj;
			var.vt = VT_UNKNOWN;
			pOutParams->Put(L"OutArg" , 0, &var, 0);      
			long lLen = wcslen(var.bstrVal);        
			var.vt = VT_I4;
			var.lVal = 0; 
			pOutParams->Put(L"ReturnValue" , 0, &var, 0); 

			// Send the output object back to the client via the sink. Then 
			// release the pointers and free the strings.

			hr = pResultSink->Indicate(1, &pOutParams);    
			pObj->Release();
		}
		pNamespace->Release();
	}

	// Free up stuff

    VariantClear(&varObjPath);
    VariantClear(&varNamespace); 
    VariantClear(&varPrincipal);
	pOutParams->Release();
    
    // all done now, set the status

	pResultSink->SetStatus(0,hr, NULL, NULL);
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\kerbtest\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WBEM Kerberos provider sample code
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include "kerbtest.h"

HMODULE ghModule = NULL;

// TODO, GuidGen should be used to generate a unique number for any 
// providers that are going to be used for anything more extensive 
// than just testing.
                                 
DEFINE_GUID(CLSID_kerberosTest,0xe30ec666, 0x23cf, 0x11d1, 0x8f, 0xde, 0x0, 0x0, 0xf8, 0x4, 0xaa, 0x5c);
//{E30EC6A0-23CF-11d1-8FDE-0000F804AA5C}

//Count number of objects and number of locks.

long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
	if(ghModule == NULL)
		ghModule = hInstance;
    if (DLL_PROCESS_DETACH==ulReason)
    {
        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH!=ulReason)
            return TRUE;
    }

    ghModule = hInstance;
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_kerberosTest!=rclsid)
        return E_FAIL;

    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwMajorVersion >= 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    char       szModule[MAX_PATH];
    char * pName = "WBEM Kerberos Provider Test";
    char * pModel;
    HKEY hKey1, hKey2;

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = "Both";
    else
        pModel = "Apartment";

    // Create the path.

    StringFromGUID2(CLSID_kerberosTest, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, lstrlen(pName)+1);
    RegCreateKey(hKey1,"InprocServer32",&hKey2);

    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        lstrlen(szModule)+1);
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                        (BYTE *)pModel, lstrlen(pModel)+1);
    CloseHandle(hKey1);
    CloseHandle(hKey2);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    char       szID[128];
    WCHAR      wcID[128];
    char  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(CLSID_kerberosTest, wcID, 128);
    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, "InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\enumprxp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    ENUMPRXP.CPP

Abstract:

  CEnumProxy_LPipe Object.

History:

  a-davj  15-Dec-97   Created.

--*/


#include "precomp.h"

CEnumProxy* CEnumProxy_LPipe::GetEnumProxy (IStubAddress& dwAddr)
{
	return new CEnumProxy_LPipe (m_pComLink, dwAddr, GetServiceStubAddr ());
}

void CEnumProxy_LPipe::ReleaseProxy ()
{
	if (NULL == m_pComLink)
		return;

	CProxyOperation_LPipe_Release opn ((CStubAddress_WinMgmt &) GetStubAdd (), 
						ENUMERATOR);
    CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CEnumProxy_LPipe::Reset
//
//  DESCRIPTION:
//
//  Sets pointer back to first element.
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR:       if no error, 
//  else some transport or provider failure.
//
//***************************************************************************

SCODE CEnumProxy_LPipe::Reset()
{
	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Reset opn ((CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CEnumProxy_LPipe::Next
//
//  DESCRIPTION:
//
//  Returns one or more instances.
//
//  PARAMETERS:
//
//  uCount      Number of instances to return.
//  pProp       Pointer to array of objects.
//  puReturned  Pointer to number of objects successfully returned.
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  Note that WBEM_E_FAILED
//  is returned even if there are some instances returned so long as the 
//  number is less than uCount.
//
//***************************************************************************

SCODE CEnumProxy_LPipe::Next(
					    IN long lTimeout, 
                        IN ULONG uCount,
                        OUT IWbemClassObject FAR* FAR* pProp,
                        OUT ULONG FAR* puReturned)
{
    if((NULL == pProp) || (NULL == puReturned))
        return WBEM_E_INVALID_PARAMETER;
    *puReturned = 0;        // to be set later.

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Next opn (lTimeout, uCount, pProp, puReturned,
							(CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}


//***************************************************************************
//
//  SCODE CEnumProxy_LPipe::Clone
//
//  DESCRIPTION:
//
//  Create a duplicate of the enumerator
//
//  PARAMETERS:
//
//  pEnum               where to put the clone.
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        if ok,
//  WBEM_E_INVALID_PARAMETER  if null argument,
//  or various transport, provider, or allocation failures.
//
//***************************************************************************

SCODE CEnumProxy_LPipe::Clone(
                        OUT IEnumWbemClassObject FAR* FAR* ppEnum)
{
    if (NULL == ppEnum)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Clone opn ((CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (ENUMERATOR, (PPVOID)ppEnum, opn);
}

//***************************************************************************
//
//  SCODE CEnumProxy_LPipe::NextAsync
//
//  DESCRIPTION:
//
//  Get elements from the enumerator sent to a sink
//
//  PARAMETERS:
//
//  uCount				how many objects to get
//	pSink               where to send them to
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        if ok,
//  WBEM_E_INVALID_PARAMETER  if null argument,
//  or various transport, provider, or allocation failures.
//
//***************************************************************************
    
SCODE CEnumProxy_LPipe::NextAsync(unsigned long uCount, IWbemObjectSink __RPC_FAR *pSink)
{
	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_NextAsync opn (uCount, pSink, 
		(CStubAddress_WinMgmt &) GetStubAdd (), GetServiceStubAddr ());
	return CallAndCleanupAsync (opn, pSink);
}

//***************************************************************************
//
//  SCODE CEnumProxy_LPipe::Skip
//
//  DESCRIPTION:
//
//  Skips entries when enumerating
//
//  PARAMETERS:
//
//  nNum                number to skip.
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR:       if no error, 
//  else some transport or provider failure.
//
//***************************************************************************

SCODE CEnumProxy_LPipe::Skip(
					    IN long lTimeout, 
						ULONG nNum)
{
	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Skip opn (lTimeout, nNum, (CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\hmmpprox.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    HMMPPROX.CPP

Abstract:

  Declares the CProxy subclasses for HMMP

History:

  alanbos  06-Jan-97   Created.

--*/

#ifndef _HMMPPROX_H_
#define _HMMPPROX_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CResProxy_Hmmp
//
//  DESCRIPTION:
//
//  HMMP Proxy for the IWbemCallResult interface.
//
//***************************************************************************

class CResProxy_HMMP : public CResProxy
{
protected:
	
public:
	CResProxy_Hmmp (CComLink * pComLink) :
		CResProxy (pComLink, 0) {}

	/* IWbemCallResult methods */

    HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppStatusObject);
        
    HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString);
        
    HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus);
        
    HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumProxy_Hmmp
//
//  DESCRIPTION:
//
//  HMMP Proxy for the IEnumWbemClassObject interface.  
//
//***************************************************************************

class CEnumProxy_Hmmp : public CEnumProxy
{
protected:

public:
    CEnumProxy_Hmmp (CComLink * pComLink):
		  CEnumProxy (pComLink, 0) {}
       
    // IEnumWbemClassObject
	STDMETHODIMP Reset();
    STDMETHODIMP Next(long lTimeout, ULONG uCount, IWbemClassObject FAR* FAR* pProp, 
		   ULONG FAR* turned);
	STDMETHODIMP NextAsync(unsigned long uCount, IWbemObjectSink __RPC_FAR *pSink);
    STDMETHODIMP Clone(IEnumWbemClassObject FAR* FAR* pEnum);
    STDMETHODIMP Skip(long lTimeout, ULONG nNum);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CProvProxy_Hmmp
//
//  DESCRIPTION:
//
//  HMMP Proxy for the IWbemServices interface.
//
//***************************************************************************

class CProvProxy_Hmmp : public CProvProxy
{
protected:
	BSTR	namespaceRef;

public:
	CProvProxy_Hmmp (CComLink *pComLink) :
	  CProvProxy (pComLink, 0) {}

	// Proxy Factory Methods
	CProvProxy*				GetProvProxy (DWORD dwAddr);
	CEnumProxy*				GetEnumProxy (DWORD dwAddr);
	CResProxy*				GetResProxy (DWORD dwAddr);
	CObjectSinkProxy*		GetSinkProxy (DWORD dwAddr);
	
    /* IWbemServices methods */
    /* [id] */ HRESULT STDMETHODCALLTYPE OpenNamespace( 
    /* [in] */ const BSTR Namespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    /* [id] */ HRESULT STDMETHODCALLTYPE QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE GetObject( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClass( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnum( 
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstance( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecQuery( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethod( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ const BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ const BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CLoginProxy_Hmmp
//
//  DESCRIPTION:
//
//  HMMP Proxy for the IWbemLevel1Login interface.  Always overridden.
//
//***************************************************************************

class CLoginProxy_Hmmp : public CLoginProxy
{
protected:

public:
	CLoginProxy_Hmmp (CComLink * pComLink) :
		CLoginProxy (pComLink, 0) {}

	// Proxy factory methods
	CProvProxy*				GetProvProxy (DWORD dwAddr);
	
	// IWbemLevel1Login

    STDMETHODIMP RequestChallenge(
		LPWSTR pNetworkResource,
        LPWSTR pUser,
        WBEM_128BITS Nonce,
		DWORD dwProcessID, 
		DWORD * pAuthEventHandle);

    STDMETHODIMP SspiPreLogin( 
        LPWSTR pNetworkResource,
        LPSTR pszSSPIPkg,
        long lFlags,
        long lBufSize,
        byte __RPC_FAR *pInToken,
        long lOutBufSize,
        long __RPC_FAR *plOutBufBytes,
        byte __RPC_FAR *pOutToken,
        DWORD dwProcessId,
        DWORD __RPC_FAR *pAuthEventHandle);  
                    
    STDMETHODIMP Login( 
		LPWSTR pNetworkResource,
        LPWSTR TokenType,
		LPWSTR pPreferredLocale,
        WBEM_128BITS AccessToken,
        IN LONG lFlags,
        IWbemContext  *pCtx,
        IN OUT IWbemServices  **ppNamespace);

    STDMETHODIMP InvalidateAccessToken( 
        /* [unique][in] */ WBEM_128BITS AccessToken,
        /* [in] */ long lFlags);
};


#endif // !_HMMPPROX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\clogin.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CLOGIN.CPP

Abstract:

  CLogin Object.

History:

  a-davj  29-May-97   Created.

--*/


#include "precomp.h"

//***************************************************************************
//
//  CLogin::CLogin
//
//  DESCRIPTION:
//
//  Constructor
//
//  PARAMETERS:
//
//  pComLink            Comlink used to set calls to stub
//
//***************************************************************************

CLogin::CLogin ( 

	TransportType a_TransportType ,
	IN DWORD dwBinaryAddressLength,
	IN BYTE __RPC_FAR *pbBinaryAddress
)
{
    m_cRef = 0;
	m_pLogin = NULL;
	m_TransportType = a_TransportType ;
	m_AddressLength = dwBinaryAddressLength ;

	if ( m_AddressLength ) 
	{
		m_Address = new BYTE [ m_AddressLength ] ;
		memcpy ( m_Address , pbBinaryAddress , m_AddressLength ) ;
	}
	else
	{
		m_Address = NULL ;
	}

	m_dwType = 0;		// assume nothing

    ObjectCreated(OBJECT_TYPE_LOGIN);
    return;
}

//***************************************************************************
//
//  CLogin::~CLogin
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CLogin::~CLogin(void)
{
	if ( m_Address ) 
		delete [] m_Address ;

	if(m_pLogin)
		m_pLogin->Release();

    ObjectDestroyed(OBJECT_TYPE_LOGIN);
    return;
}

//***************************************************************************
// HRESULT CLogin::QueryInterface
// long CLogin::AddRef
// long CLogin::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CLogin::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;
    if (IID_IUnknown==riid)
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CLogin::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CLogin::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

//***************************************************************************
//
//  HRESULT CLogin::RequestChallenge
//
//  DESCRIPTION:
//
//  Asks for a challenge so that a login can be done
//
//  PARAMETERS:
//
//  pNonce              Set to 16 byte value.  Must be freed via CoTaskMemFree()
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLogin::RequestChallenge(
			LPWSTR pNetworkResource,
            LPWSTR pUser,
            WBEM_128BITS Nonce)
{
	HRESULT hRes = MakeSureWeHaveAPointer();
	if(hRes == WBEM_NO_ERROR)
		hRes = m_pLogin->RequestChallenge(pNetworkResource, pUser, Nonce);
	return hRes;
}

//***************************************************************************
//
//  HRESULT CLogin::EstablishPosition
//
//  DESCRIPTION:
//
//  Establish a position
//
//  PARAMETERS:
//
//  
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLogin::EstablishPosition(
			LPWSTR wszClientMachineName,
			DWORD dwProcessId,
			DWORD* phAuthEventHandle
		)
{
	HRESULT hRes = MakeSureWeHaveAPointer();
	if(hRes == WBEM_NO_ERROR)
		hRes = m_pLogin->EstablishPosition(wszClientMachineName, dwProcessId, 
								phAuthEventHandle);
	return hRes;
}

//***************************************************************************
//
//  HRESULT CLogin::WBEMLogin
//
//  DESCRIPTION:
//
//  Perform a WBEM-authenticated login
//
//  PARAMETERS:
//
//  pNonce              Set to 16 byte value.  Must be freed via CoTaskMemFree()
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLogin::WBEMLogin(
			LPWSTR pPreferredLocale,
			WBEM_128BITS AccessToken,
			long lFlags,                                  // WBEM_LOGIN_TYPE
			IWbemContext *pCtx,              
			IWbemServices **ppNamespace
        )
{
	SCODE sc = MakeSureWeHaveAPointer();
	if(sc == WBEM_NO_ERROR)
		sc = m_pLogin->WBEMLogin(pPreferredLocale, AccessToken, lFlags, pCtx,
									ppNamespace);
	return sc;
}

//***************************************************************************
//
//  SCODE CLogin::SspiPreLogin
//
//  DESCRIPTION:
//
//  negotiates the sspi login
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLogin::SspiPreLogin( 
            LPSTR pszSSPIPkg,
            long lFlags,
            long lBufSize,
            byte __RPC_FAR *pInToken,
            long lOutBufSize,
            long __RPC_FAR *plOutBufBytes,
            byte __RPC_FAR *pOutToken,
			LPWSTR wszClientMachineName,
            DWORD dwProcessId,
            DWORD __RPC_FAR *pAuthEventHandle)

{

	HRESULT hRes = MakeSureWeHaveAPointer();
	if(hRes == WBEM_NO_ERROR)
		hRes = m_pLogin->SspiPreLogin(
                pszSSPIPkg,
                lFlags,
                lBufSize,
                pInToken,
                lOutBufSize,
                plOutBufBytes,
                pOutToken,
				wszClientMachineName,
                dwProcessId,
                pAuthEventHandle);
	return hRes;
}
        
//***************************************************************************
//
//  HRESULT CLogin::Login
//
//  DESCRIPTION:
//
//  Connects up to a server.
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLogin::Login( 
			LPWSTR pNetworkResource,
			LPWSTR pPreferredLocale,
            WBEM_128BITS AccessToken,
            IN LONG lFlags,
            IWbemContext  *pCtx,
            IN OUT IWbemServices  **ppNamespace)
{
	HRESULT hRes = MakeSureWeHaveAPointer();
	if(hRes == WBEM_NO_ERROR)
	{
		hRes = m_pLogin->Login(pNetworkResource, pPreferredLocale,
            AccessToken,m_dwType | lFlags, pCtx, ppNamespace);
	}

	return hRes;
}

//***************************************************************************
//
//  HRESULT CLogin::MakeSureWeHaveAPointer
//
//  DESCRIPTION:
//
//  Makes sure there is a pointer to the IWbemLevelLogin1 object.
//
//  PARAMETERS:
//
//  pNetworkResource    The WinMgmt path, ex \\a-davj3\root\default
//  User				User name
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLogin::MakeSureWeHaveAPointer()
{

	// If we already have a pointer to the same resource, return OK.
	if(m_pLogin)
		return WBEM_NO_ERROR;
	
	// Get a new pointer.  Note that it might be a DCOM pointer or a custom proxy

	SCODE sc = RequestLogin(&m_pLogin, m_dwType, m_TransportType , m_AddressLength , m_Address );
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\classfac.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CLASSFAC.CPP

Abstract:

  Contains the class factory.  This creates objects when
  connections are requested.

History:

  a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
// CLocatorFactory::CLocatorFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CLocatorFactory::CLocatorFactory(int iType)
{
    m_cRef=0L;
    m_iType = iType;
    ObjectCreated(OBJECT_TYPE_FACTORY);
    return;
}

//***************************************************************************
//
// CLocatorFactory::~CLocatorFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CLocatorFactory::~CLocatorFactory(void)
{
    ObjectDestroyed(OBJECT_TYPE_FACTORY);
    return;
}

//***************************************************************************
//
// CLocatorFactory::QueryInterface
// CLocatorFactory::AddRef
// CLocatorFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CLocatorFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CLocatorFactory::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CLocatorFactory::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CLocatorFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Provider object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CLocatorFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
    
    if(m_iType == PIPELOCATOR)
	{
        pObj=new CPipeLocator;
	}
#ifdef TCPIP_MARSHALER
	else if(m_iType == TCPIPLOCATOR)
	{
        pObj=new CTcpipLocator;
	}
	else if(m_iType == TCPIPADDRESSRESOLVER)
	{
        pObj=new CTcpipAddress;
	}
#endif
    if (NULL==pObj)
        return hr;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CLocatorFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CLocatorFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\kerbtest\kerbtest.h ===
//***************************************************************************
//
//  kerbtest.h
//
//  Module: WBEM Method Test Provider code
//
//  Purpose: Method kerberos Test Header File.
//
//  Copyright (c)1998-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _kerbtest_H_
#define _kerbtest_H_

#include "wbemidl.h"

typedef LPVOID * PPVOID;

// Provider interfaces are provided by objects of this class
 
class CKerbTestPro : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pWbemSvcs;
        IWbemClassObject* m_pOutClass;
     public:
        CKerbTestPro();
        ~CKerbTestPro(void);

        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};

        //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

        //IWbemServices  

		HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;}
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        // Supported !!!!

        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**){return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*);

       
};

typedef CKerbTestPro *PCKerbTestPro;

// This class is the class factory for CKerbTestPro objects.

class CProvFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CProvFactory(void);
        ~CProvFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CProvFactory *PCProvFactory;



// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern long       g_cLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\enumprox.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    ENUMPROX.CPP

Abstract:

  CEnumProxy Object.

History:

  a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
//  CEnumProxy::CEnumProxy
//
//  DESCRIPTION:
//
//  Constructor
//
//  PARAMETERS:
//
//  pComLink            Comlink used to set calls to stub
//  stubAddr          remote stub
//
//***************************************************************************

CEnumProxy::CEnumProxy(
                        IN CComLink * pComLink,
                        IN IStubAddress& stubAddr) 
                        : CProxy(pComLink, stubAddr)
{
    m_cRef = 0;

	/*
	 * Aggregate the free-threaded marshaler for cheap in-proc
	 * threading as we are thread-safe.  
	 */
	HRESULT hRes = CoCreateFreeThreadedMarshaler ((IUnknown *) this, &m_pUnkInner);

    ObjectCreated(OBJECT_TYPE_ENUMPROXY);
    return;
}

//***************************************************************************
//
//  CEnumProxy::~CEnumProxy
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CEnumProxy::~CEnumProxy(void)
{
    ObjectDestroyed(OBJECT_TYPE_ENUMPROXY);
    return;
}

//***************************************************************************
// HRESULT CEnumProxy::QueryInterface
// long CEnumProxy::AddRef
// long CEnumProxy::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumProxy::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;

	// Delegate queries for IMarshal to the aggregated
	// free-threaded marshaler
	if (IID_IMarshal==riid && m_pUnkInner)
		return m_pUnkInner->QueryInterface (riid, ppv);

    if ((IID_IUnknown==riid || IID_IEnumWbemClassObject == riid) &&
            m_pComLink != NULL && GetStubAdd ().IsValid () && ppv)
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CEnumProxy::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CEnumProxy::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    // refernce count is zero, delete this object and the remote object
	ReleaseProxy ();
    
	m_cRef++;	// Artificial reference count to prevent re-entrancy
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\locator.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOCATOR.CPP

Abstract:

  Defines the CLocator class.

History:

  a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include <lmcons.h>
#include "anonpipe.h"
#ifdef TCPIP_MARSHALER
#include "tcpip.h"
#endif
#include <csspi.h>
#include <servutil.h>
DEFINE_GUID(UUID_LocalAddrType, 
0xa1044803, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

// {8F174CA0-952A-11d1-9367-00AA00A4086C}
DEFINE_GUID(UUID_IWbemAddressResolver_Tcpip, 
0x8f174ca0, 0x952a, 0x11d1, 0x93, 0x67, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

static wchar_t *s_localaddressType = L"{A1044803-8F7E-11D1-9E7C-00C04FC324A8}"; // Local
static wchar_t *s_tcpipaddressType = L"{8F174CA0-952A-11d1-9367-00AA00A4086C}"; // Local

BOOL g_InitialisationComplete = FALSE ;
BOOL g_PipeInitialisationComplete = FALSE ;
BOOL g_TcpipInitialisationComplete = FALSE ;

DWORD LOG = 3;

struct PipeSharedMemoryMessage
{
    DWORD m_Size ;
    CHAR m_Buffer [ 256 ] ;
} ;

CRITICAL_SECTION g_GlobalCriticalSection ;

HANDLE g_Mutex = NULL ;
HANDLE g_StartedEvent ;
HANDLE g_ReplyEvent = NULL ;
HANDLE g_RequestEvent = NULL ;
HANDLE g_SharedMemory = NULL ;
PipeSharedMemoryMessage *g_SharedMemoryBuffer = NULL ;

HRESULT CreateSharedMemory ()
{
    g_StartedEvent = CreateEvent ( NULL , TRUE , FALSE , __TEXT("WBEM_PIPEMARSHALER_STARTED") ) ;
    if ( ! g_StartedEvent ) 
    {
        return WBEM_E_FAILED ;
    }

    if ( GetLastError () != ERROR_ALREADY_EXISTS ) 
    {
        SetObjectAccess ( g_StartedEvent ) ;
    }

    DWORD t_Timeout = GetTimeout () ;
    DWORD t_Status = WbemWaitForSingleObject ( g_StartedEvent , t_Timeout ) ;
    if ( t_Status != WAIT_OBJECT_0 )
    {
        CloseHandle ( g_StartedEvent ) ; 

        g_StartedEvent = NULL ;

        return WBEM_E_FAILED ;
    }

    g_RequestEvent = OpenEvent ( EVENT_ALL_ACCESS, FALSE , __TEXT("WBEM_PIPEMARSHALER_EEQUESTISREADY") ) ;
    if ( ! g_RequestEvent ) 
    {
        CloseHandle ( g_StartedEvent ) ;

        g_StartedEvent = NULL ;

        return WBEM_E_FAILED ;
    }

    g_ReplyEvent = OpenEvent ( EVENT_ALL_ACCESS, FALSE , __TEXT("WBEM_PIPEMARSHALER_REPLYISREADY") ) ;
    if ( ! g_ReplyEvent ) 
    {
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_RequestEvent ) ;

        g_StartedEvent = NULL ;
        g_RequestEvent = NULL ;

        return WBEM_E_FAILED ;
    }

    g_Mutex = OpenMutex ( MUTEX_ALL_ACCESS , FALSE , __TEXT("WBEM_PIPEMARSHALER_MUTUALEXCLUSION") ) ;
    if ( ! g_Mutex ) 
    {
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_RequestEvent ) ;
        CloseHandle ( g_ReplyEvent ) ;

        g_StartedEvent = NULL ;
        g_ReplyEvent = NULL ;
        g_RequestEvent = NULL ;

        return WBEM_E_FAILED ;
    }

    g_SharedMemory = OpenFileMapping (

        FILE_MAP_WRITE ,  
        FALSE ,
        __TEXT("WBEM_PIPEMARSHALER_SHAREDMEMORY")
    );

    if ( ! g_SharedMemory ) 
    {
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_RequestEvent ) ;
        CloseHandle ( g_ReplyEvent ) ;
        CloseHandle ( g_Mutex ) ;

        g_StartedEvent = NULL ;
        g_ReplyEvent = NULL ;
        g_RequestEvent = NULL ;
        g_Mutex = NULL ;

        return WBEM_E_FAILED ;
    }

    g_SharedMemoryBuffer = ( PipeSharedMemoryMessage * ) MapViewOfFile ( 

        g_SharedMemory , 
        FILE_MAP_WRITE , 
        0 , 
        0 , 
        0 
    ) ;

    if ( ! g_SharedMemoryBuffer )
    {
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_RequestEvent ) ;
        CloseHandle ( g_ReplyEvent ) ;
        CloseHandle ( g_Mutex ) ;
        CloseHandle ( g_SharedMemory ) ;

        g_StartedEvent = NULL ;
        g_ReplyEvent = NULL ;
        g_RequestEvent = NULL ;
        g_Mutex = NULL ;
        g_SharedMemory = NULL ;

        return WBEM_E_FAILED ;

    }

    return S_OK ;
}

void DestroySharedMemory ()
{
    CloseHandle ( g_Mutex ) ;
    CloseHandle ( g_StartedEvent ) ;
    CloseHandle ( g_ReplyEvent ) ;
    CloseHandle ( g_RequestEvent ) ;
    CloseHandle ( g_SharedMemory ) ;

    UnmapViewOfFile ( g_SharedMemoryBuffer ) ;

    g_StartedEvent = NULL ;
    g_ReplyEvent = NULL ;
    g_RequestEvent = NULL ;
    g_Mutex = NULL ;
    g_SharedMemory = NULL ;
}

//***************************************************************************
//
//  BOOL  StartLocalServer
//
//  DESCRIPTION:
//
//  Makes sure that WinMgmt is running.  This will start WinMgmt if it isnt running.
//
//  RETURN VALUE:
//
//  TRUE if WinMgmt was already running or was successfully started.
//
//***************************************************************************

BOOL StartLocalServer ()
{
    // temp code, for the local case, check to see if the server is already loaded via
    // the mutex check.  If it isnt, the load it up.

    HANDLE t_RegisteredEvent = OpenEvent ( 

            MUTEX_ALL_ACCESS, 
            FALSE,
            TEXT("WINMGMT_LOADED")
    );

    if ( ! t_RegisteredEvent )
    {
        TCHAR *t_WorkingDirectory ;
        TCHAR t_Executable [256];
        Registry t_RegistryValue (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, WBEM_REG_WBEM) ;

        if ( t_RegistryValue.GetStr (__TEXT("Installation Directory"),&t_WorkingDirectory ) )
        {
            TRACE((LOG,"\ncould not read the registry value for the installation"
                        " directory"));

            return FALSE ;
        }

        wsprintf ( t_Executable ,__TEXT("%s\\WinMgmt.EXE"),t_WorkingDirectory ) ;
        delete [] t_WorkingDirectory ;

        if ( IsNT () )
        {
            if ( ! StartService ( TEXT("WinMgmt") , 5 ) )
            {
                TRACE((LOG,"\ncould not start service"));
                return FALSE;
            }
        }
        else
        {
            char c_Executable[MAX_PATH+1];
#ifdef UNICODE
            wcstombs(c_Executable, t_Executable, (MAX_PATH+1) * sizeof(char));
#else
            lstrcpy(c_Executable, t_Executable);
#endif
            LONG t_Result = WinExec ( c_Executable , SW_NORMAL ) ;
            if ( t_Result <= 31 )
            {
                TRACE((LOG,"\ncould not execute WinMgmt.EXE"));
                return FALSE ;
            }
        }

        ULONG t_Timeout ;
 
        if ( t_RegistryValue.GetDWORD (__TEXT("Startup Timeout"),&t_Timeout ) )
        {
            t_Timeout = 20 ;
        }

        for ( int t_Ticks = 0 ; t_Ticks < t_Timeout; t_Ticks ++ )
        {
            t_RegisteredEvent = OpenEvent (

                MUTEX_ALL_ACCESS, 
                FALSE,
                TEXT("WINMGMT_LOADED")
            );

            if ( t_RegisteredEvent )
                break;

            Sleep ( 1000 ) ;
        }
    }
    else
    {
        DEBUGTRACE((LOG,"\nWinMgmt.EXE is already running."));
    }

    if ( t_RegisteredEvent )
    {
        CloseHandle ( t_RegisteredEvent ) ;
    }
    else
    {
        TRACE((LOG,"\nWinMgmt.EXE was NOT STARTED!!!"));
        return FALSE ;
    }

    if ( ! g_InitialisationComplete ) 
    {
        g_Terminate = CreateEvent(NULL,TRUE,FALSE,NULL);
        if ( ! g_Terminate )
        {
            return FALSE ;
        }

        if ( FAILED ( gMaintObj.StartClientThreadIfNeeded () ) )
        {
            CloseHandle ( g_Terminate ) ;

            return FALSE ;
        }

        g_InitialisationComplete = TRUE ;
    }

    if ( ! g_PipeInitialisationComplete ) 
    {
        if ( FAILED ( CreateSharedMemory () ) )
        {
            return FALSE ; 
        }

        g_PipeInitialisationComplete = TRUE ;
    }

    return TRUE;
}

//***************************************************************************
//
//  SCODE WBEMLogin
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespze path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE WBEMLogin (

    IN TransportType a_TransportType ,
    IN DWORD dwBinaryAddressLength,
    IN BYTE __RPC_FAR *pbBinaryAddress,
    IN BSTR NetworkResource,
    IN BSTR User,
    IN BSTR Password,
    IN BSTR LocaleId,
    IN long lFlags,
    IN BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    OUT IWbemServices FAR* FAR* ppProv
)
{
    CLogin login ( a_TransportType , dwBinaryAddressLength, pbBinaryAddress ) ;

    HANDLE t_ServerAuthenticationEvent = NULL ;

    TCHAR cMyName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    if(!GetComputerName(cMyName,&dwSize))
        return WBEM_E_FAILED;

    WCHAR wszClientMachineName[MAX_PATH];
#ifdef UNICODE
    lstrcpy(wszClientMachineName, cMyName);
#else
    mbstowcs(wszClientMachineName, cMyName, MAX_PATH);
#endif

    TCHAR t_AsciiImpersonatedUser [ UNLEN + 1 ] ;
    ULONG t_UserLength = UNLEN + 1  ;
    if ( ! GetUserName ( t_AsciiImpersonatedUser , & t_UserLength) ) 
    {
        ERRORTRACE((LOG_WBEMPROX, "\nGetUserName failed, using unknown"));
        lstrcpy(t_AsciiImpersonatedUser, __TEXT("<unknown>"));
    }

    WCHAR t_ImpersonatedUser [ UNLEN + 1 ] ;
#ifdef UNICODE
    lstrcpy(t_ImpersonatedUser, t_AsciiImpersonatedUser);
#else
    mbstowcs(t_ImpersonatedUser, t_AsciiImpersonatedUser, UNLEN + 1 );
#endif

    // Establish a position 
    SCODE sc = login.EstablishPosition (
        
        wszClientMachineName,
        GetCurrentProcessId (),
        (DWORD *) & t_ServerAuthenticationEvent

    );

    if ( SUCCEEDED ( sc ) )
    {
        BYTE Nonce [ DIGEST_SIZE ] ;
        WBEM_128BITS pAccessToken = NULL ;
        
        // Get a nonse

        sc = login.RequestChallenge (

            NetworkResource , 
            t_ImpersonatedUser , 
            Nonce 
        );

        if ( SUCCEEDED ( S_OK ) )
        {
            // For the local case, prove to the server that we are really on the same machine

            if (t_ServerAuthenticationEvent)
            {
                int iRet = SetEvent ( t_ServerAuthenticationEvent ) ;
                DWORD dw = GetLastError () ;
            }
    
            BYTE t_AccessToken [ DIGEST_SIZE ] ;
            sc = login.WBEMLogin (

                LocaleId , 
                t_AccessToken , 
                lFlags , 
                pCtx , 
                ppProv
            ) ; 
        }

        if ( t_ServerAuthenticationEvent )
            CloseHandle ( t_ServerAuthenticationEvent ) ;

        if ( pAccessToken )
            CoTaskMemFree ( pAccessToken ) ;
    }

    return sc;
}

char *WideToNarrow (WCHAR * pWide)
{
    if(pWide == NULL)
    {
        return NULL;
    }

    int iLen = wcstombs ( NULL , pWide , wcslen ( pWide ) + 1 ) + 1 ;
    char *pRet = new char [ iLen ] ;
    wcstombs ( pRet , pWide , wcslen ( pWide ) + 1 ) ;

    return pRet ;
}

//***************************************************************************
//
//  SCODE NTLMLogin
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespze path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE NTLMLogin (

    IN TransportType a_TransportType ,
    IN DWORD dwBinaryAddressLength,
    IN BYTE __RPC_FAR *pbBinaryAddress,
    IN BSTR a_NetworkResource,
    IN BSTR a_User,
    IN BSTR a_Password,
    IN BSTR a_LocaleId,
    IN long a_lFlags,
    IN BSTR a_Authority,
    IWbemContext __RPC_FAR *a_Ctx,
    OUT IWbemServices FAR* FAR* a_Prov
)
{
    static BOOL s_InitializeTried = FALSE ;
    static BOOL s_Initialized = FALSE ;

    TCHAR cMyName[MAX_PATH];
    WCHAR wszClientMachineName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    if(!GetComputerName(cMyName,&dwSize))
        return WBEM_E_FAILED;
#ifdef UNICODE
    lstrcpy(wszClientMachineName, cMyName);
#else
    mbstowcs(wszClientMachineName, cMyName, MAX_PATH);
#endif

    // Do a one time initialization.

    if ( ! s_InitializeTried )
    {
        BOOL t_Status = CSSPI::Initialize () ;
        if ( ! t_Status )
        {
            DEBUGTRACE((LOG,"\nCSSPI::Initialize FAILED"));
        }
        else
        {
            s_Initialized = TRUE ;
        }
    }

    s_InitializeTried = TRUE ;
    if ( ! s_Initialized )
    {
        return WBEM_E_FAILED ;
    }

    // Initialize the "Client" object

    CSSPIClient Client("NTLM");

    if ( Client.GetStatus() != CSSPIClient::Waiting )
    {
        DEBUGTRACE((LOG,"\nCSSPIClient.GetStatus didnt return waiting"));

        return WBEM_E_FAILED ;
    }

    HRESULT t_Result = S_OK ;

    if ( a_lFlags == WBEM_FLAG_REMOTE_LOGIN )
    {
        char *t_User = WideToNarrow ( a_User ) ;
        char *t_Password = WideToNarrow ( a_Password ) ;
        char *t_Authority = WideToNarrow ( a_Authority ) ;

        t_Result = Client.SetLoginInfo ( t_User , t_Authority , t_Password ) ;

        if ( t_User )
            delete [] t_User ;

        if ( t_Password )
            delete [] t_Password ;

        if ( t_Authority )
            delete [] t_Authority ;

    }
    else
    {
        t_Result = Client.SetDefaultLogin () ;
    }

    if ( t_Result != 0 )
    {
        DEBUGTRACE((LOG,"*********Unable to set login info.  Error = %s\n",
            CSSPI::TranslateError(t_Result)));

        t_Result = WBEM_E_FAILED ;
    }
    else
    { 
        // Call the SSPIPreLogin the first time with an empty input buffer.

        DWORD dwInSize, dwOutSize ;
        BYTE  Out[1024], *pIn = NULL ;

        t_Result = Client.ContinueLogin ( 

            0 , 
            0 , 
            &pIn , 
            &dwInSize 
        ) ;

        HANDLE t_ServerAuthenticationEvent = NULL ;

        CLogin login ( a_TransportType , dwBinaryAddressLength, pbBinaryAddress ) ;

        t_Result = login.SspiPreLogin ( 

            "NTLM", 
            a_lFlags, 
            dwInSize, 
            pIn, 
            1024, 
            (long *)&dwOutSize, 
            Out, 
            wszClientMachineName,
            GetCurrentProcessId(), 
            (DWORD *)&t_ServerAuthenticationEvent
        );

        if ( pIn )
        {
            delete pIn ;
        }
 
        while ( t_Result == WBEM_S_PRELOGIN )
        {
            t_Result = Client.ContinueLogin (

                Out, 
                dwOutSize, 
                &pIn, 
                &dwInSize
            ) ;

            if ( SUCCEEDED  ( t_Result ) )
            {
                t_Result = login.SspiPreLogin (

                    "NTLM", 
                    a_lFlags, 
                    dwInSize, 
                    pIn, 
                    1024, 
                    (long *)&dwOutSize, 
                    Out, 
                    wszClientMachineName,
                    0, 
                    NULL
                );
            }

            if ( pIn )
            {
                delete pIn ;
                pIn = NULL ;
            }
        }

        if ( ! FAILED ( t_Result ) )
        {
        // For the local case, prove to the server that we are really on the same machine

            int iRet = SetEvent ( t_ServerAuthenticationEvent ) ;
            DWORD dw = GetLastError ();

            t_Result = login.Login (

                a_NetworkResource,
                a_LocaleId, 
                Out, 
                a_lFlags, 
                a_Ctx, 
                a_Prov
            ) ; 
        }

        if ( t_ServerAuthenticationEvent )
            CloseHandle ( t_ServerAuthenticationEvent ) ;
    }

    return t_Result ;
}

//***************************************************************************
//
//  CPipeLocator::CPipeLocator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CPipeLocator::CPipeLocator()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    ObjectCreated(OBJECT_TYPE_LOCATOR);
}

//***************************************************************************
//
//  CPipeLocator::~CPipeLocator
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CPipeLocator::~CPipeLocator(void)
{
    InterlockedDecrement(&g_cObj);
    ObjectDestroyed(OBJECT_TYPE_LOCATOR);
}

//***************************************************************************
// HRESULT CPipeLocator::QueryInterface
// long CPipeLocator::AddRef
// long CPipeLocator::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CPipeLocator::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemClientTransport)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CPipeLocator::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CPipeLocator::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CPipeLocator::ConnectServer
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespace path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CPipeLocator::ConnectServer (

    BSTR AddressType,
    DWORD dwBinaryAddressLength,
    BYTE __RPC_FAR *pbBinaryAddress,
    BSTR NetworkResource,
    BSTR User,
    BSTR Password,
    BSTR LocaleId,
    long lFlags,
    BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    IWbemServices __RPC_FAR *__RPC_FAR *ppProv
)
{
    SCODE sc;

    long t_lFlags = WBEM_FLAG_LOCAL_LOGIN ;;

    if ( IsWin95 () )
    {
        sc = WBEMLogin (

            PipeTransport,
            0 ,
            NULL,
            NetworkResource,
            User,
            Password,
            LocaleId,
            lFlags | t_lFlags ,
            Authority,
            pCtx,
            ppProv
        );
    }
    else
    {
        sc = NTLMLogin (

            PipeTransport,
            0 ,
            NULL,
            NetworkResource,
            User,
            Password,
            LocaleId,
            lFlags | t_lFlags ,
            Authority,
            pCtx,
            ppProv
        ) ;
    }

    return sc;
}

//***************************************************************************
//
//  WCHAR *ExtractMachineName2
//
//  DESCRIPTION:
//
//  Takes a path of form "\\machine\xyz... and returns the
//  "machine" portion in a newly allocated WCHAR.  The return value should
//  be freed via delete. NULL is returned if there is an error.
//
//
//  PARAMETERS:
//
//  pPath               Path to be parsed.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

WCHAR * ExtractMachineName2 ( IN BSTR a_Path )
{
    WCHAR *t_MachineName = NULL;

    //todo, according to the help file, the path can be null which is
    // default to current machine, however Ray's mail indicated that may
    // not be so.

    if ( a_Path == NULL )
    {
        t_MachineName = new WCHAR [ 2 ] ;
        if ( t_MachineName )
        {
           wcscpy ( t_MachineName , L"." ) ;
        }

        return t_MachineName ;
    }

    // First make sure there is a path and determine how long it is.

    if ( ! IsSlash ( a_Path [ 0 ] ) || ! IsSlash ( a_Path [ 1 ] ) || wcslen ( a_Path ) < 3 )
    {
        t_MachineName = new WCHAR [ 2 ] ;
        if ( t_MachineName )
        {
             wcscpy ( t_MachineName , L"." ) ;
        }

        return t_MachineName ;
    }

    WCHAR *t_ThirdSlash ;

    for ( t_ThirdSlash = a_Path + 2 ; *t_ThirdSlash ; t_ThirdSlash ++ )
    {
        if ( IsSlash ( *t_ThirdSlash ) )
            break ;
    }

    if ( t_ThirdSlash == &a_Path [2] )
    {
        return NULL;
    }

    // allocate some memory

    t_MachineName = new WCHAR [ t_ThirdSlash - a_Path - 1 ] ;
    if ( t_MachineName == NULL )
    {
        return t_MachineName ;
    }

    // temporarily replace the third slash with a null and then copy

    WCHAR t_SlashCharacter = *t_ThirdSlash ;
    *t_ThirdSlash = NULL;

    wcscpy ( t_MachineName , a_Path + 2 ) ;

    *t_ThirdSlash  = t_SlashCharacter ;        // restore it.

    return t_MachineName ;
}

#ifdef TCPIP_MARSHALER
//***************************************************************************
//
//  CTcpipLocator::CTcpipLocator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CTcpipLocator::CTcpipLocator()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    ObjectCreated(OBJECT_TYPE_LOCATOR);
}

//***************************************************************************
//
//  CTcpipLocator::~CTcpipLocator
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CTcpipLocator::~CTcpipLocator(void)
{
    InterlockedDecrement(&g_cObj);
    ObjectDestroyed(OBJECT_TYPE_LOCATOR);
}

//***************************************************************************
// HRESULT CTcpipLocator::QueryInterface
// long CTcpipLocator::AddRef
// long CTcpipLocator::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CTcpipLocator::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemClientTransport)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CTcpipLocator::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CTcpipLocator::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  SCODE CTcpipLocator::ConnectServer
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespace path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CTcpipLocator::ConnectServer (

    BSTR AddressType,
    DWORD dwBinaryAddressLength,
    BYTE __RPC_FAR *pbBinaryAddress,
    BSTR NetworkResource,
    BSTR User,
    BSTR Password,
    BSTR LocaleId,
    long lFlags,
    BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    IWbemServices __RPC_FAR *__RPC_FAR *ppProv
)
{
    SCODE sc;

    long t_lFlags = WBEM_FLAG_LOCAL_LOGIN ;
    DWORD t_BinaryAddressLength = 0 ;
    BYTE __RPC_FAR *t_BinaryAddress = NULL ;

    if ( wcscmp ( AddressType , s_tcpipaddressType ) == 0 )
    {
        t_lFlags = WBEM_FLAG_REMOTE_LOGIN ;
        t_BinaryAddressLength = dwBinaryAddressLength ;
        t_BinaryAddress = pbBinaryAddress ;
    }

    if ( IsWin95 () )
    {
        switch ( t_lFlags )
        {
            case WBEM_FLAG_REMOTE_LOGIN:
            {
                sc = NTLMLogin (

                    TcpipTransport,
                    t_BinaryAddressLength,
                    t_BinaryAddress,
                    NetworkResource,
                    User,
                    Password,
                    LocaleId,
                    lFlags | t_lFlags,
                    Authority,
                    pCtx,
                    ppProv
                ) ;

            }
            break ;

            default:
            {
                sc = WBEMLogin (

                    TcpipTransport,
                    t_BinaryAddressLength,
                    t_BinaryAddress,
                    NetworkResource,
                    User,
                    Password,
                    LocaleId,
                    lFlags | t_lFlags ,
                    Authority,
                    pCtx,
                    ppProv 
                );
            }
            break ;
        }
    }
    else
    {
        sc = NTLMLogin (

            TcpipTransport,
            t_BinaryAddressLength,
            t_BinaryAddress,
            NetworkResource,
            User,
            Password,
            LocaleId,
            lFlags | t_lFlags,
            Authority,
            pCtx,
            ppProv
        ) ;
    }


    return sc;
}

//***************************************************************************
//
//  CTcpipAddress::CTcpipAddress
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CTcpipAddress::CTcpipAddress()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    ObjectCreated(TCPIPADDR);
}

//***************************************************************************
//
//  CTcpipAddress::~CTcpipAddress
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CTcpipAddress::~CTcpipAddress(void)
{
    InterlockedDecrement(&g_cObj);
    ObjectDestroyed(TCPIPADDR);
}

//***************************************************************************
// HRESULT CTcpipAddress::QueryInterface
// long CTcpipAddress::AddRef
// long CTcpipAddress::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CTcpipAddress::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    
    if (IID_IUnknown==riid || riid == IID_IWbemAddressResolution)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CTcpipAddress::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CTcpipAddress::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

SCODE CTcpipAddress::Resolve (
 
    LPWSTR pszNamespacePath,
    LPWSTR pszAddressType,
    DWORD __RPC_FAR *pdwAddressLength,
    BYTE __RPC_FAR **pbBinaryAddress
)
{
    HRESULT t_Result = S_OK ;

    GUID gAddr;
    CLSIDFromString(pszAddressType, &gAddr);

    BOOL t_Status = pszNamespacePath == NULL || 
                    pdwAddressLength== NULL || 
                    pbBinaryAddress == NULL || 
                    gAddr != UUID_LocalAddrType || 
                    gAddr != UUID_IWbemAddressResolver_Tcpip ;

    if ( ! t_Status )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    WCHAR *t_ServerMachine = ExtractMachineName2 (pszNamespacePath) ;
    if ( t_ServerMachine == NULL )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }

    if ( wcscmp ( t_ServerMachine , L"." ) == 0 )
    {
        if ( gAddr == UUID_LocalAddrType )
        {
            *pbBinaryAddress = (BYTE *)CoTaskMemAlloc(8);
            if(*pbBinaryAddress == NULL)
            {
                delete [] t_ServerMachine ;
                return WBEM_E_FAILED;
            }

            wcscpy((LPWSTR)*pbBinaryAddress, L"\\\\.");
            *pdwAddressLength = 8;

            return t_Result ;
        }
        else
        {
            delete [] t_ServerMachine ;
            return WBEM_E_FAILED ;
        }
    }

    char *t_AsciiServer = new char [ wcslen ( t_ServerMachine ) * 2 + 1 ] ;
    sprintf ( t_AsciiServer , "%S" , t_ServerMachine ) ;

    delete [] t_ServerMachine;

    BOOL status = FALSE ;
    WORD wVersionRequested;  
    WSADATA wsaData; 

    wVersionRequested = MAKEWORD(1, 1); 
    status = ( WSAStartup ( wVersionRequested , &wsaData ) == 0 ) ;
    if ( status ) 
    {
        ULONG t_Address = inet_addr ( t_AsciiServer ) ;
        if ( t_Address != INADDR_NONE ) 
        {
            char t_LocalMachine [MAX_PATH];
            DWORD t_LocalMachineSize = MAX_PATH;
            if ( GetComputerName ( t_LocalMachine , & t_LocalMachineSize ) )
            {
                hostent *t_HostEntry = gethostbyname ( t_LocalMachine );    
                if ( t_HostEntry )
                {
                    int t_Length = strlen ( t_HostEntry->h_name ) ;
                    char *t_LocalName = new char [ strlen ( t_HostEntry->h_name ) + 1 ] ;
                    strcpy ( t_LocalName , t_HostEntry->h_name ) ;

                    t_HostEntry = gethostbyaddr ( ( char * ) & t_Address , sizeof ( ULONG ) , AF_INET ) ;
                    if ( t_HostEntry ) 
                    {
                        if ( stricmp ( t_LocalName , t_HostEntry->h_name ) == 0 )
                        {
                            if ( gAddr == UUID_LocalAddrType )
                            {
                                *pbBinaryAddress = (BYTE *)CoTaskMemAlloc(8);
                                if(*pbBinaryAddress == NULL)
                                {
                                    delete [] t_ServerMachine ;
                                    return WBEM_E_FAILED;
                                }

                                wcscpy((LPWSTR)*pbBinaryAddress, L"\\\\.");
                                *pdwAddressLength = 8;
                            }
                            else
                            {
                                t_Result = WBEM_E_FAILED ;
                            }
                        }
                        else
                        {
                            if ( gAddr == UUID_IWbemAddressResolver_Tcpip )
                            {
                                *pdwAddressLength = sizeof ( ULONG ) ;
                                *pbBinaryAddress = (BYTE *)CoTaskMemAlloc ( sizeof ( ULONG ) )  ;
                                if(*pbBinaryAddress != NULL)
                                {
                                    ULONG *t_Pointer = ( ULONG * ) *pbBinaryAddress ;
                                    *t_Pointer = ntohl ( t_Address ) ;
                                }
                            }
                            else
                            {
                                t_Result = WBEM_E_FAILED ;
                            }
                        }
                    }
                    else
                    {
                        t_Result = WBEM_E_FAILED ;
                    }

                    delete [] t_LocalName ;
                }
                else
                {
                    t_Result = WBEM_E_FAILED ;
                }
            }
            else
            {
                t_Result = WBEM_E_FAILED ;
            }
        }
        else
        {
            char t_LocalMachine [MAX_PATH];
            DWORD t_LocalMachineSize = MAX_PATH;
            if ( GetComputerName ( t_LocalMachine , & t_LocalMachineSize ) )
            {
                hostent *t_HostEntry = gethostbyname ( t_LocalMachine );    
                if ( t_HostEntry )
                {
                    int t_Length = strlen ( t_HostEntry->h_name ) ;
                    char *t_LocalName = new char [ strlen ( t_HostEntry->h_name ) + 1 ] ;
                    strcpy ( t_LocalName , t_HostEntry->h_name ) ;
                    
                    hostent *t_HostEntry = gethostbyname ( t_AsciiServer ); 
                    if ( t_HostEntry )
                    {
                        if ( strcmp ( t_HostEntry->h_name  , t_LocalName ) == 0 ) 
                        {
                            // Local

                            if ( gAddr == UUID_LocalAddrType )
                            {
                                *pbBinaryAddress = (BYTE *)CoTaskMemAlloc(8);
                                if(*pbBinaryAddress == NULL)
                                {
                                    delete [] t_ServerMachine ;
                                    return WBEM_E_FAILED;
                                }

                                wcscpy((LPWSTR)*pbBinaryAddress, L"\\\\.");
                                *pdwAddressLength = 8;
                            }
                            else
                            {
                                t_Result = WBEM_E_FAILED ;
                            }
                        }
                        else
                        {
                            if ( gAddr == UUID_IWbemAddressResolver_Tcpip )
                            {
                                int t_Index = 0 ;
                                while ( t_HostEntry->h_addr_list[t_Index] )
                                {
                                    t_Index ++ ;
                                }

                                *pdwAddressLength = t_Index * sizeof ( ULONG ) ;
                                *pbBinaryAddress = (BYTE *)CoTaskMemAlloc ( t_Index * sizeof ( ULONG ) )  ;
                                if(*pbBinaryAddress != NULL)
                                {
                                    ULONG *t_Pointer = ( ULONG * ) *pbBinaryAddress ;
                                    t_Index = 0 ;
                                    while ( t_HostEntry->h_addr_list[t_Index] )
                                    {
                                        ULONG t_Address = *((unsigned long *) t_HostEntry->h_addr_list[t_Index]) ;
                                        *t_Pointer = ntohl ( t_Address ) ;
                                        t_Pointer ++ ;
                                        t_Index ++ ;
                                    }
                                }
                                else
                                {
                                    t_Result = WBEM_E_FAILED ;              
                                }
                            }
                            else
                            {
                                t_Result = WBEM_E_FAILED ;
                            }
                        }
                    }
                    else
                    {
                        t_Result = WBEM_E_FAILED ;
                    }

                    delete [] t_LocalName ;
                }
                else
                {
                    t_Result = WBEM_E_FAILED ;
                }
            }
            else
            {
                t_Result = WBEM_E_FAILED ;
            }
        }

        WSACleanup () ;
    }

    delete [] t_AsciiServer ;

    return t_Result ;
}

#endif

//***************************************************************************
//
//  CComLink * CreateAnonPipeConn
//
//  DESCRIPTION:
//
//  Creates a AnonPipe connection.
//  and protocol list.
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  NULL if OK.  pdwRet is also set if an error.
//
//***************************************************************************

CComLink *CreateAnonPipeConn (

    IN CTransportStream &read, 
    IN DWORD *pdwRet
)
{
    HANDLE t_Read, t_Write, t_Term ;

    read.ReadDWORD ( (DWORD *) &t_Read ) ;
    read.ReadDWORD ( (DWORD *) &t_Write ) ;
    read.ReadDWORD ( (DWORD *) &t_Term ) ;

    if ( read.Status () != CTransportStream::no_error )
    {
        *pdwRet = WBEM_E_INVALID_STREAM ;
        return NULL ;
    }

    CComLink *pRet = new CComLink_LPipe ( NORMALCLIENT , t_Read , t_Write , t_Term ) ;
    if ( pRet == NULL )
    {
        *pdwRet = WBEM_E_OUT_OF_MEMORY ;
    }

    return pRet;
}

//***************************************************************************
//
//  STDAPI ClientSendAndGet
//
//  DESCRIPTION:
//
//  Used by clients to send a message to the server.
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI ClientSendAndGet ( 

    CTransportStream *a_Write ,
    CTransportStream *a_Read
)
{
    HRESULT t_Result =  WBEM_E_TRANSPORT_FAILURE;

    BYTE *t_Buffer = NULL ;
    DWORD t_Size = 0 ;

    if ( a_Write->CMemStream :: Serialize ( &t_Buffer , &t_Size ) == CMemStream :: no_error )  
    {
        // Get the mutex and events.  These are created by WINMGMT

        DWORD t_Timeout = GetTimeout () ;
        DWORD t_Status = WbemWaitForSingleObject ( g_Mutex , t_Timeout ) ;
        if ( t_Status == WAIT_OBJECT_0 )
        {
            ResetEvent ( g_ReplyEvent ) ;
    
            g_SharedMemoryBuffer->m_Size = t_Size ;
            memcpy ( g_SharedMemoryBuffer->m_Buffer , t_Buffer , t_Size ) ;

            SetEvent ( g_RequestEvent ) ;

            // Wait for the server to be done, copy the data back

            t_Status = WbemWaitForSingleObject ( g_ReplyEvent , t_Timeout ) ;
            if ( t_Status == WAIT_OBJECT_0 )
            {
                a_Read->CMemStream :: Deserialize ( ( BYTE * ) g_SharedMemoryBuffer->m_Buffer, g_SharedMemoryBuffer->m_Size ) ; 
                a_Read->ReadDWORD ( ( DWORD * ) & t_Result );
            }
            else
            {
            }
        }
        else
        {
        }

        delete t_Buffer;
    }

    ReleaseMutex ( g_Mutex ) ;

    return S_OK;
}

//***************************************************************************
//
//  CComLink * CreatePipeConnection
//
//  DESCRIPTION:
//
//  Establishes a connection.
//
//  PARAMETERS:
//
//  a_StubAddress        set to server stub setup to handle this
//  a_Result             set to error code, 0 if ok
//
//  RETURN VALUE:
//
//  Pointer to a CComLink object if all is well, NULL if error.
//  note that if failure, pdwRet is set to an error code
//
//***************************************************************************

CComLink *CreatePipeConnection (

    OUT DWORD *a_StubAddress ,
    OUT DWORD *a_Result 
)
{
    CComLink *t_ComLink = NULL ;

    DEBUGTRACE((LOG,"\nCreateConnect is starting"));

    // make the call.

    CTransportStream t_WriteStream ( CTransportStream:: auto_delete , NULL , 256 , 256 ) ;
    CTransportStream t_ReadStream ( CTransportStream::auto_delete , NULL , 256 , 256 ) ; 

    t_WriteStream.WriteDWORD  ( (DWORD) GetCurrentProcessId () ) ;

    *a_Result = ClientSendAndGet ( & t_WriteStream , & t_ReadStream ) ;

    DEBUGTRACE((LOG,"\nCreateConnection, after call, dwRet = %x", *a_Result )) ;

    if ( *a_Result == WBEM_NO_ERROR )
    {
        t_ReadStream.ReadDWORD ( a_StubAddress ) ;

        t_ComLink = CreateAnonPipeConn ( t_ReadStream , a_Result ) ;
    }

    return t_ComLink ;
}           

#ifdef TCPIP_MARSHALER

CComLink *CreateTcpipConnection (

    OUT DWORD *a_StubAddress ,
    OUT DWORD *a_Result ,
    IN DWORD a_AddressLength,
    IN BYTE *a_Address
)
{
    if ( ! g_InitialisationComplete ) 
    {
        g_InitialisationComplete = TRUE ;
        g_Terminate = CreateEvent(NULL,TRUE,FALSE,NULL);
        gMaintObj.StartClientThreadIfNeeded () ;
    }

    if ( ! g_TcpipInitialisationComplete ) 
    {
        BOOL status = FALSE ;
        WORD wVersionRequested;  
        WSADATA wsaData; 

        wVersionRequested = MAKEWORD(1, 1); 
        status = ( WSAStartup ( wVersionRequested , &wsaData ) == 0 ) ;
        if ( status ) 
        {
            g_TcpipInitialisationComplete = TRUE ;
        }
        else
        {
            *a_Result = WBEM_E_TRANSPORT_FAILURE ;
            return NULL ;
        }
    }

    CComLink *t_ComLink = NULL ;

    SOCKET t_Socket = socket (AF_INET, SOCK_STREAM, 0);
    if ( t_Socket != SOCKET_ERROR ) 
    {
        struct sockaddr_in t_RemoteAddress ;
        t_RemoteAddress .sin_family = AF_INET;
        t_RemoteAddress.sin_port = htons (4000);

        if ( a_AddressLength ) 
        {
            t_RemoteAddress.sin_addr.s_addr = htonl ( * ( ULONG * ) a_Address );
        }
        else
        {
            t_RemoteAddress.sin_addr.s_addr = htonl ( INADDR_LOOPBACK );
        }

        int t_Status = connect ( t_Socket , ( sockaddr * ) & t_RemoteAddress, sizeof ( t_RemoteAddress ) ) ;
        if ( t_Status != SOCKET_ERROR ) 
        {
            DWORD t_ReadStreamStatus = CTransportStream::no_error;
            CTransportStream t_ReadStream ;

            switch ( t_ReadStream.Deserialize ( t_Socket , INFINITE ) )
            {
                case CTransportStream :: no_error:
                {
                    t_ReadStreamStatus |= t_ReadStream.ReadDWORD ( a_Result ) ;
                    t_ReadStreamStatus |= t_ReadStream.ReadDWORD ( a_StubAddress ) ;

                    t_ComLink = new CComLink_Tcpip ( NORMALSERVER , t_Socket ); 
                    if ( t_ComLink == NULL )
                    {
                    }
                }
                break ;

                default:
                {
                    *a_Result = WBEM_E_TRANSPORT_FAILURE ;
                    closesocket ( t_Socket ) ;
                }
                break ;
            }
        }
        else
        {
            closesocket ( t_Socket ) ;
            *a_Result = WBEM_E_TRANSPORT_FAILURE ;
        }
    }
    else
    {
        *a_Result = WBEM_E_TRANSPORT_FAILURE ;
    }

    return t_ComLink ;
}           

#endif

//***************************************************************************
//
//  SCODE RequestLogin
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server for a login interface.
//  returns a standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  ppLogin             set to login proxy
//  dwType              set to the connection type, Inproc, local or remote
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE RequestLogin (

    OUT IServerLogin FAR* FAR* a_Login ,
    DWORD &a_LocalRemoteFlag ,
    TransportType a_TransportType ,
    IN DWORD a_AddressLength,
    IN BYTE *a_Address
)
{
    EnterCriticalSection ( & g_GlobalCriticalSection ) ;

    DWORD t_Return = WBEM_E_INVALID_PARAMETER;

    USES_CONVERSION;

    // Verify arguments

    DEBUGTRACE((LOG,"\nRequestLogin called"));

    if ( a_Login == NULL )
    {
        DEBUGTRACE((LOG,"\nRequestLogin got passed a NULL ppLogin"));
    }
    else
    {
        *a_Login = NULL;

        // Extract the server name and determine if the connection is to
        // be local.
        DWORD t_StubAddress ;
        CComLink *t_ComLink = NULL ;

        switch ( a_TransportType ) 
        {
            case PipeTransport:
            {
                if ( ! StartLocalServer () )
                {
                    t_Return = WBEM_E_TRANSPORT_FAILURE ;
                    TRACE((LOG,"\nRequestLogin failed bStartLocalServer"));
                }
                else
                {
                    t_ComLink = CreatePipeConnection (

                        &t_StubAddress ,
                        &t_Return
                    );
                }
            }
            break ;

#ifdef TCPIP_MARSHALER
            default:
            {
                a_LocalRemoteFlag = WBEM_FLAG_REMOTE_LOGIN ;

                t_ComLink = CreateTcpipConnection (

                    &t_StubAddress ,
                    &t_Return ,
                    a_AddressLength ,
                    a_Address
                );
            }
            break ;
#else

            default:
            {
            }
            break ;
#endif

        }

        DEBUGTRACE((LOG,"\nRequestLogin did connect, pCom=%x",t_ComLink));

        if ( t_ComLink == NULL )
        {
        }
        else
        {
// Set the notification stub and do a ping to make sure the connection is ok.
// ==============================================================================

            t_Return = t_ComLink->ProbeConnection () ;
            if ( FAILED ( t_Return ) & ( t_ComLink->GetStatus () != CComLink::no_error ) )
            {
                TRACE((LOG,"\nRequestLogin failed pinging"));
            }
            else
            {
            // Create the new prox object, note that the CProvProxy constructor
            // does an "AddRef" on the pCom object and so a Release2 can now be
            // done to counteract the CComLink constructor which sets the ref count
            // to 1.

                CStubAddress_WinMgmt t_WinMgmtStubAddress (t_StubAddress);

                *a_Login = new CLoginProxy_LPipe ( t_ComLink , t_WinMgmtStubAddress ) ;
                if ( ! bVerifyPointer ( *a_Login ) )
                {
                    *a_Login = NULL ;
                    t_Return = WBEM_E_OUT_OF_MEMORY ;
                }
                else
                {
                    t_ComLink->Release2 ( NULL , NONE ) ;

                    DEBUGTRACE((LOG,"\nsuccessfully started connection")) ;

                    t_Return = WBEM_NO_ERROR ;
                }
            }
        }

        if ( t_ComLink && t_Return != WBEM_NO_ERROR )
        {
            gMaintObj.ShutDownComlink ( t_ComLink ) ;
        }
    }

    if ( t_Return )
    {
        DEBUGTRACE((LOG,"\nfailed trying to connect,  error code of %x", t_Return));
    }
    else
    {
        DEBUGTRACE((LOG,"\nConnect succeeded"));
    }

    LeaveCriticalSection ( & g_GlobalCriticalSection ) ;

    return t_Return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\logprxp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOGPRXP.CPP

Abstract:

  Defines the CLoginProxy_LPipe object

History:

  alanbos  15-Dec-97   Created.

--*/

#include "precomp.h"

CProvProxy* CLoginProxy_LPipe::GetProvProxy (IStubAddress& dwAddr)
{
	return new CProvProxy_LPipe (m_pComLink, dwAddr);
}

void CLoginProxy_LPipe::ReleaseProxy ()
{
	if (NULL == m_pComLink)
		return;

	CProxyOperation_LPipe_Release opn ((CStubAddress_WinMgmt &) GetStubAdd (), LOGIN);
    CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  HRESULT CLoginProxy_LPipe::RequestChallenge
//
//  DESCRIPTION:
//
//  Asks for a challenge so that a login can be done
//
//  PARAMETERS:
//
//  pNonce              Set to 16 byte value.  Must be freed via CoTaskMemFree()
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLoginProxy_LPipe::RequestChallenge(
			LPWSTR pNetworkResource,
            LPWSTR pUser,
            WBEM_128BITS Nonce)
{
    if(NULL == Nonce)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_RequestChallenge opn (pNetworkResource, 
						pUser, Nonce, (CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  HRESULT CLoginProxy_LPipe::EstablishPosition
//
//  DESCRIPTION:
//
//  Establishes a position
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLoginProxy_LPipe::EstablishPosition(
			LPWSTR wszClientMachineName,
			DWORD dwProcessId,
			DWORD* phAuthEventHandle
		)
{
	if((NULL == wszClientMachineName) || (NULL == phAuthEventHandle))
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_EstablishPosition opn (wszClientMachineName, 
						dwProcessId, phAuthEventHandle, 
						(CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CLoginProxy_LPipe::WBEMLogin
//
//  DESCRIPTION:
//
//  Login in the user using WBEM authentication
//
//  PARAMETERS:
//
//  pNonce              Set to 16 byte value.  Must be freed via CoTaskMemFree()
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CLoginProxy_LPipe::WBEMLogin(
			LPWSTR pPreferredLocale,
			WBEM_128BITS AccessToken,
			long lFlags,               
			IWbemContext *pCtx,              
			IWbemServices **ppNamespace)
{
    if ((NULL == ppNamespace) || (NULL == AccessToken))
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;


	CProxyOperation_LPipe_WBEMLogin opn (pPreferredLocale, AccessToken, 
						lFlags, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
	return CallAndCleanup (PROVIDER, (PPVOID)ppNamespace, opn);
}

//***************************************************************************
//
//  SCODE CLoginProxy_LPipe::SspiPreLogin
//
//  DESCRIPTION:
//
//  Used for SSPI negotiations.
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

SCODE CLoginProxy_LPipe::SspiPreLogin( 
            LPSTR pszSSPIPkg,
            long lFlags,
            long lBufSize,
            byte __RPC_FAR *pInToken,
            long lOutBufSize,
            long __RPC_FAR *plOutBufBytes,
            byte __RPC_FAR *pOutToken,
			LPWSTR wszClientMachineName,
            DWORD dwProcessId,
            DWORD __RPC_FAR *pAuthEventHandle)
 
{
    if((NULL == pszSSPIPkg) || (0 == lBufSize) || (NULL == pInToken) 
				|| (0 == lOutBufSize) || (NULL == pOutToken) || 
				(NULL == plOutBufBytes)  || (NULL == wszClientMachineName))
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_SspiPreLogin opn (pszSSPIPkg,
			lFlags, lBufSize, pInToken, lOutBufSize, plOutBufBytes,
			pOutToken, wszClientMachineName, dwProcessId, pAuthEventHandle, 
			(CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CLoginProxy_LPipe::Login
//
//  DESCRIPTION:
//
//  Connects up to a server.
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

SCODE CLoginProxy_LPipe::Login( 
			LPWSTR pNetworkResource,
			LPWSTR pPreferredLocale,
            WBEM_128BITS AccessToken,
            IN LONG lFlags,
            IWbemContext  *pCtx,
            IN OUT IWbemServices  **ppNamespace)
{

    if((NULL == ppNamespace) || (NULL == AccessToken))
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Login opn (pNetworkResource, pPreferredLocale,
				AccessToken, lFlags, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
	return CallAndCleanup(PROVIDER, (PPVOID)ppNamespace, opn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

  Contains DLL entry points.  Also has code that controls
  when the DLL can be unloaded by tracking the number of
  objects and locks.

History:

  a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"

#include <initguid.h>
bool bServer = false;

// {C9B930CF-92D6-11d1-8AE6-00600806D9B6} CLSID for the pipes client marshaler
DEFINE_GUID(CLSID_IWbemLocator_Pipes, 
0xc9b930cf, 0x92d6, 0x11d1, 0x8a, 0xe6, 0x0, 0x60, 0x8, 0x6, 0xd9, 0xb6);

// {15AB0B00-9529-11d1-9367-00AA00A4086C}
DEFINE_GUID(CLSID_IWbemLocator_Tcpip, 
0x15ab0b00, 0x9529, 0x11d1, 0x93, 0x67, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {5C20EE1C-95EC-11d1-978E-0000F81E849C}
DEFINE_GUID(CLSID_IWbemAddressResolver_Tcpip, 
0x5c20ee1c, 0x95ec, 0x11d1, 0x97, 0x8e, 0x0, 0x0, 0xf8, 0x1e, 0x84, 0x9c);

// {4FE4452B-92D8-11d1-8AE6-00600806D9B6} Display name for pipes client marshaler
DEFINE_GUID(UUID_PipesName, 
0x4fe4452b, 0x92d8, 0x11d1, 0x8a, 0xe6, 0x0, 0x60, 0x8, 0x6, 0xd9, 0xb6);

// {15AB0B01-9529-11d1-9367-00AA00A4086C}
DEFINE_GUID(UUID_TcpipName, 
0x15ab0b01, 0x9529, 0x11d1, 0x93, 0x67, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

#ifdef TCPIP_MARSHALER
// {8F174CA0-952A-11d1-9367-00AA00A4086C}
DEFINE_GUID(UUID_IWbemAddressResolver_Tcpip, 
0x8f174ca0, 0x952a, 0x11d1, 0x93, 0x67, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {A15E76E0-95EF-11d1-978E-0000F81E849C}
DEFINE_GUID(UUID_IWbemAddressResolver_TcpipName, 
0xa15e76e0, 0x95ef, 0x11d1, 0x97, 0x8e, 0x0, 0x0, 0xf8, 0x1e, 0x84, 0x9c);

// {4BB2D69A-95F0-11d1-978E-0000F81E849C}
DEFINE_GUID(UUID_Tcpip, 
0x4bb2d69a, 0x95f0, 0x11d1, 0x97, 0x8e, 0x0, 0x0, 0xf8, 0x1e, 0x84, 0x9c);

DEFINE_GUID(UUID_LocalAddrType, 
0xa1044803, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

#endif

// Length of a {...} string representation of a GUID
#define GUID_SIZE 39

// Registry key names and values
static TCHAR *s_modTranPath = WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\Network Transport Modules");
static TCHAR *s_AddResPath = WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\Address Resolution Modules");
static TCHAR *s_localizations = WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\Localizations\\409");
static TCHAR *s_pipesName = __TEXT("WBEM Anonymous Pipes Client Marshaler V1");
static TCHAR *s_localaddressType = __TEXT("{A1044803-8F7E-11D1-9E7C-00C04FC324A8}"); // Local

#ifdef TCPIP_MARSHALER
static TCHAR *s_tcpipName = __TEXT("WBEM Tcpip Client Marshaler V1");
static TCHAR *s_tcpipAddressName = __TEXT("WBEM Tcpip Address Resolution Module V1");
static TCHAR *s_tcpipaddressType = __TEXT("{8F174CA0-952A-11d1-9367-00AA00A4086C}"); // Local

#endif

static TCHAR *s_name = __TEXT("Name");
static TCHAR *s_independent = __TEXT("Independent");
static TCHAR *s_supportedAddressTypes = __TEXT("Supported Address Types");
static TCHAR *s_displayName = __TEXT("Display Name");
static TCHAR *s_stackOrder = __TEXT("Stack Order");
    
static LONG ObjectTypeTable[MAX_CLIENT_OBJECT_TYPES] = { 0 };
void ShowObjectCounts ();

// Count number of objects and number of locks.

long g_cObj = 0 ;
ULONG g_cLock = 0 ;

// used to keep track of allocated objects.

MaintObj gMaintObj(TRUE);
CThrdPool gThrdPool;
HMODULE ghModule ;

extern void DestroySharedMemory () ;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
    if ( DLL_PROCESS_DETACH == ulReason )
    {
DEBUGTRACE((LOG,"\nUnloading Pipes Marshaler Proxy"));

		DestroySharedMemory () ;

		DeleteCriticalSection ( & g_GlobalCriticalSection ) ;

        if ( g_Terminate )
        {
			TerminateThread ( gMaintObj.GetThreadHandle () , 0 ) ;

DEBUGTRACE((LOG,"\nShutdown All"));

            gMaintObj.UnLockedShutDownAllComlinks () ;

DEBUGTRACE((LOG,"\nCompleted Shutdown All"));

            gThrdPool.Free () ;
            SetEvent ( g_Terminate ) ;

            int ii;
            for(ii = 0; ii < 50; ii++)
            {
                if(ObjectTypeTable[OBJECT_TYPE_COMLINK] > 0)
                    Sleep(100);
                else
                    break;
            }
        }

DEBUGTRACE((LOG,"\nUnloaded Pipes Marshaler Proxy"));

    	ShowObjectCounts();

        return TRUE;

    }
    else
    {
		if ( DLL_PROCESS_ATTACH == ulReason )
		{
DEBUGTRACE((LOG,"\nLoading Pipes Marshaler Proxy"));

	        ghModule = hInstance;

			InitializeCriticalSection ( & g_GlobalCriticalSection ) ;
		}
        else if ( DLL_PROCESS_ATTACH != ulReason )
        {
            if ( g_Terminate == NULL )
            {
                DEBUGTRACE((LOG,"\ncould not create a terminate event"));
                return FALSE;
            }

            return TRUE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT PPVOID ppv
)
{
DEBUGTRACE((LOG,"\nRequest to get ClassFactory"));

    HRESULT hr;
    CLocatorFactory *pObj = NULL;

    if (CLSID_IWbemLocator_Pipes == rclsid)
	{
        pObj=new CLocatorFactory(CLocatorFactory::PIPELOCATOR);
	}
#ifdef TCPIP_MARSHALER
	else if (CLSID_IWbemLocator_Tcpip == rclsid)
	{
        pObj=new CLocatorFactory(CLocatorFactory::TCPIPLOCATOR);
	}
	else if (CLSID_IWbemAddressResolver_Tcpip == rclsid)
	{
        pObj=new CLocatorFactory(CLocatorFactory::TCPIPADDRESSRESOLVER);
	}
#endif
    else
	{
        return E_FAIL ;
	}

    if (NULL==pObj)
	{
        return ResultFromScode(E_OUTOFMEMORY);
	}

    hr=pObj->QueryInterface(riid, ppv);

    if ( FAILED ( hr ) )
	{
        delete pObj ;
	}

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

extern BOOL g_InitialisationComplete ;
extern BOOL g_PipeInitialisationComplete ;

#ifdef TCPIP_MARSHALER
extern BOOL g_TcpipInitialisationComplete ;
#endif

STDAPI DllCanUnloadNow ()
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
	if ( sc == S_OK )
	{
		gThrdPool.Free () ;

		SetEvent ( g_Terminate ) ;
		CloseHandle ( g_Terminate ) ;

		g_InitialisationComplete = FALSE ;
		g_PipeInitialisationComplete = FALSE ;

#ifdef TCPIP_MARSHALER
		g_TcpipInitialisationComplete = FALSE ;
#endif
	}

    return ResultFromScode(sc);
}

//***************************************************************************
//
//  ObjectCreated
//
//  DESCRIPTION:
//
//  Keeps track of object creation.
//
//  PARAMETERS:
//
//  dwType              type of object created.
//
//***************************************************************************

void ObjectCreated ( DWORD dwType )
{
    if(dwType < MAX_CLIENT_OBJECT_TYPES)
        InterlockedIncrement(&ObjectTypeTable[dwType]);
}

//***************************************************************************
//
//  void ObjectDestroyed
//
//  DESCRIPTION:
//
//  Keeps track of object deletion.
//
//  PARAMETERS:
//
//  dwType              type of object created.
//
//***************************************************************************

void ObjectDestroyed ( DWORD dwType )
{
    if(dwType < MAX_CLIENT_OBJECT_TYPES)
        InterlockedDecrement(&ObjectTypeTable[dwType]);
}

//***************************************************************************
//
//  void ShowObjectCounts
//
//  DESCRIPTION:
//
//  Dumps out the object count.  Used during shutdown to detect leaks.
//
//***************************************************************************

void ShowObjectCounts ()
{
       
    DEBUGTRACE((LOG,"\n---COM Object Ref Count Info for marshalling client---\n"));
    DEBUGTRACE((LOG,"Active Objects = %d\n", g_cObj));
    DEBUGTRACE((LOG,"Server locks   = %d\n", g_cLock));

    DEBUGTRACE((LOG,"Object counts by type:\n"));

    DEBUGTRACE((LOG,"IWbemLocator counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_LOCATOR]));
    DEBUGTRACE((LOG,"IWbemClassObject counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_CLSOBJ]));
    DEBUGTRACE((LOG,"IWbemServices counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_PROVIDER]));
    DEBUGTRACE((LOG,"IWbemQualifierSet counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_QUALIFIER]));
    DEBUGTRACE((LOG,"IEnumMosClassObject counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_OBJENUM]));
    DEBUGTRACE((LOG,"IClassFactory counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_FACTORY]));

    DEBUGTRACE((LOG,"OBJECT_TYPE_ENUMPROXY counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_ENUMPROXY]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_LOGINPROXY counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_LOGINPROXY]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_LOGIN counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_LOGIN]));

    DEBUGTRACE((LOG,"OBJECT_TYPE_OBJSINKPROXY counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_OBJSINKPROXY]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_PROVPROXY counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_PROVPROXY]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_COMLINK counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_COMLINK]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_CSTUB counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_CSTUB]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_RQUEUE counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_RQUEUE]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_PACKET_HEADER counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_PACKET_HEADER]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_SECHELP counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_SECHELP]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_RESPROXY counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_RESPROXY]));


    DEBUGTRACE((LOG,"---End of ref count dump---\n"));
}

//***************************************************************************
//
// AddGUIDToStackOrder
//
// Purpose: Inserts a GUID into the "Stack Order" multistring.
//
//***************************************************************************

void AddGUIDToStackOrder(LPTSTR szGUID, Registry & reg)
{
    long lRes;
    DWORD dwSize;
    TCHAR * pData = NULL;
    pData = reg.GetMultiStr(s_stackOrder, dwSize);

    if(pData)
    {
        // The value already exists.  Allocate enough data to store the data.
    
        TCHAR * pTest;
        for(pTest = pData; *pTest; pTest += lstrlen(pTest) + 1)
            if(!lstrcmpi(pTest, szGUID))
                break;
        if(*pTest == NULL)
        {
            // our isnt in the list, add it to the end; careful with
			// the trailing double NULL.
            DWORD dwDataSize = pTest - pData + 1;
            TCHAR * pNew = new TCHAR[dwDataSize + GUID_SIZE];
			memcpy (pNew, pData, dwDataSize - 1);	// Omit last NULL
            lstrcpy(pNew + dwDataSize - 1, szGUID);
			pNew [dwDataSize + GUID_SIZE - 1] = NULL;		// Double the final NULL
            lRes = reg.SetMultiStr(s_stackOrder, pNew, dwDataSize + GUID_SIZE);
            delete []pNew;
         }

         delete []pData;
    }
    else
    {
        // The value does not exist.  Create it with just our entry in it
        TCHAR * pNew = new TCHAR[GUID_SIZE + 1];
        lstrcpy(pNew, szGUID);
        pNew[GUID_SIZE] = 0;            // put in the double null which is needed for REG_MULTI_SZ
        lRes = reg.SetMultiStr(s_stackOrder, pNew, GUID_SIZE + 1);
        delete []pNew;
    }
}

//***************************************************************************
//
// CreateLPSTRFromGUID
//
// Purpose: Creates narrow string version of a guid
//
//***************************************************************************

void CreateLPSTRFromGUID(IN GUID guid, IN OUT TCHAR * pNarrow, IN DWORD dwSize)
{
    WCHAR      wcID[GUID_SIZE];
    if(0 ==StringFromGUID2(guid, wcID, GUID_SIZE))
		return;
#ifdef UNICODE
	lstrcpy(pNarrow, wcID);
#else
    wcstombs(pNarrow, wcID, dwSize * sizeof(TCHAR));
#endif
}
//***************************************************************************
//
// AddDisplayName
//
// Purpose: Adds a "Display Name" string to the registry which will contain the
// guid of the internationalization string.  It then adds the string to the 
// english part of the internationization table.
//
//***************************************************************************

void AddDisplayName(Registry & reg, GUID guid, LPTSTR pDescription)
{
    TCHAR cGuid[GUID_SIZE];
    CreateLPSTRFromGUID(guid, cGuid, GUID_SIZE);
    reg.SetStr(s_displayName, cGuid);

    Registry reglang(s_localizations);
    reglang.SetStr(cGuid, pDescription);
}

//***************************************************************************
//
// AddSupportedAddressTypes
//
// Purpose: Inserts a GUID into the "Supported Address Types" multistring.
//
//***************************************************************************

void AddSupportedLocalAddressTypes(Registry & reg)
{
    long lRes;
    TCHAR * pNew = new TCHAR[GUID_SIZE + 1];
    lstrcpy(pNew, s_localaddressType);
    pNew[GUID_SIZE] = 0;     // put in the double null which is needed for REG_MULTI_SZ
    lRes = reg.SetMultiStr(s_supportedAddressTypes, pNew, GUID_SIZE + 1);
    delete []pNew;
}

#ifdef TCPIP_MARSHALER
void AddSupportedTcpipAddressTypes(Registry & reg)
{
    long lRes;
    char * pNew = new char[2*GUID_SIZE + 1];
    lstrcpy(pNew, s_localaddressType);
	lstrcpy(pNew+GUID_SIZE, s_tcpipaddressType);
    pNew[2*GUID_SIZE] = 0;     // put in the double null which is needed for REG_MULTI_SZ
    lRes = reg.SetMultiStr(s_supportedAddressTypes, pNew, 2*GUID_SIZE + 1);
    delete []pNew;
}
#endif

#ifdef TCPIP_MARSHALER
//***************************************************************************
//
// CreateAddResModEntries
//
// Purpose: Creates the registry entries for the Address Resolution Modules
//
//***************************************************************************

void CreateAddResModEntries()
{
    // create a narrow string version of the local name resolver CLSID

    TCHAR szLocalAddRes[GUID_SIZE];
    CreateLPSTRFromGUID(CLSID_IWbemAddressResolver_Tcpip, szLocalAddRes, GUID_SIZE);


    // The StackOrder value is a multistring list of the CLSIDs of the network
    // transports.  Create it with a single entry if it doesnt already exist, or
    // just put DCOM at the from of the list if it doesnt exist.

    Registry reg(s_AddResPath);
    AddGUIDToStackOrder(szLocalAddRes, reg);


    // Now add an entry for local address resolution module
    // It will contain
    // "Name"         REG_SZ,     documentary name
    // "Display Name" REG_SZ,     GUID of display name in localization key
    // "Supporte Address Type" REG_MULTI_SZ:  <GUIDs of address types supported>

    reg.MoveToSubkey(szLocalAddRes);
    reg.SetStr("Name", s_tcpipAddressName);
    TCHAR cSupportedTypes[2*GUID_SIZE+1];
    memset(cSupportedTypes, 0, (2*GUID_SIZE+1)*sizeof(TCHAR));
    CreateLPSTRFromGUID(UUID_IWbemAddressResolver_Tcpip, cSupportedTypes, GUID_SIZE);
	CreateLPSTRFromGUID(UUID_LocalAddrType, cSupportedTypes+GUID_SIZE, GUID_SIZE);
    reg.SetMultiStr("Supported Address Types", cSupportedTypes, 2*GUID_SIZE+1);

    AddDisplayName(reg, UUID_IWbemAddressResolver_TcpipName, s_tcpipAddressName);
}

//***************************************************************************
//
// CreateAddrTypesList
//
// Purpose: Creates the address types list
//
//***************************************************************************

void CreateAddrTypesList()
{
    // create a narrow string LocalMachine addr CLSID

    TCHAR szLocalType[GUID_SIZE];
    CreateLPSTRFromGUID(UUID_IWbemAddressResolver_Tcpip, szLocalType, GUID_SIZE);
    Registry reg(WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\AddressTypes\\"));
    reg.MoveToSubkey(szLocalType);

    // Now add an entry for local address type
    // It will contain
    // "Description"         REG_SZ,     documentary name
    // "Display Name" REG_SZ,     GUID of display name in localization key

    reg.SetStr(__TEXT("Description"), __TEXT("TcpIp"));
    AddDisplayName(reg, UUID_Tcpip, __TEXT("TcpIp"));

}
#endif

//***************************************************************************
//
// RegisterClientMarshaler
//
// Purpose: Creates the registry entries for the client marshaler
//
//***************************************************************************

void RegisterClientMarshaler()
{
    // create a narrow string version of the Pipes transport CLSID
	TCHAR szPipesGUID[GUID_SIZE];
    CreateLPSTRFromGUID(CLSID_IWbemLocator_Pipes, szPipesGUID, GUID_SIZE);

	// The StackOrder value is a multistring list of the CLSIDs of the network
    // transports.  Create it with a single entry if it doesnt already exist, or
    // just put PIPES at the end of the list if it doesnt exist.
    Registry pipereg(s_modTranPath);
    AddGUIDToStackOrder(szPipesGUID, pipereg);

    // Now add an entry for pipes.  Identify it as a dependent client marshaler
    pipereg.MoveToSubkey(szPipesGUID);
    pipereg.SetStr(s_name, s_pipesName);
    pipereg.SetDWORD(s_independent, 0);
	AddSupportedLocalAddressTypes (pipereg);
    AddDisplayName(pipereg, UUID_PipesName, s_pipesName);

#ifdef TCPIP_MARSHALER
	TCHAR szTcpipGUID[GUID_SIZE];
    CreateLPSTRFromGUID(CLSID_IWbemLocator_Tcpip, szTcpipGUID, GUID_SIZE);

    Registry tcpipreg(s_modTranPath);
	AddGUIDToStackOrder(szTcpipGUID, tcpipreg);

    // Now add an entry for tcpip.  Identify it as a dependent client marshaler
    tcpipreg.MoveToSubkey(szTcpipGUID);
    tcpipreg.SetStr(s_name, s_tcpipName);
    tcpipreg.SetDWORD(s_independent, 0);
	AddSupportedTcpipAddressTypes (tcpipreg);
    AddDisplayName(tcpipreg, UUID_TcpipName, s_tcpipName);
#endif

}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

#define LocatorPipePROGID __TEXT("WBEMPipesLocator")

#ifdef TCPIP_MARSHALER
#define LocatorTcpipPROGID __TEXT("WBEMTcpipLocator")
#define AddressTcpipPROGID __TEXT("WBEMTcpipAddressResolver")
#endif

STDAPI DllRegisterServer(void)
{ 
    RegisterDLL(ghModule, CLSID_IWbemLocator_Pipes, __TEXT("WBEM Pipes Locator"), __TEXT("Both"), LocatorPipePROGID);
#ifdef TCPIP_MARSHALER
	RegisterDLL(ghModule, CLSID_IWbemLocator_Tcpip, "WBEM Tcpip Locator", "Both", LocatorTcpipPROGID);
	RegisterDLL(ghModule, CLSID_IWbemAddressResolver_Tcpip, __TEXT("WBEM Tcpip Address Resolver"), __TEXT("Both"), AddressTcpipPROGID);


	CreateAddResModEntries () ;

	CreateAddrTypesList () ;

#endif

	// Register the client marshaler
	RegisterClientMarshaler ();
    
	return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	UnRegisterDLL(CLSID_IWbemLocator_Pipes,LocatorPipePROGID);
#ifdef TCPIP_MARSHALER
	UnRegisterDLL(CLSID_IWbemLocator_Tcpip,LocatorTcpipPROGID);
	UnRegisterDLL(CLSID_IWbemAddressResolver_Tcpip,AddressTcpipPROGID);
#endif

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\logprox.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOGPROX.CPP

Abstract:

  Defines the CLoginProxy object

History:

  a-davj  04-May-97   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
//  CLoginProxy::CLoginProxy
//
//  DESCRIPTION:
//
//  Constructor
//
//  PARAMETERS:
//
//  pComLink            Comlink used to set calls to stub
//  stubAddr          remote stub
//
//***************************************************************************

CLoginProxy::CLoginProxy(
                        IN CComLink * pComLink,
                        IN IStubAddress& stubAddr) 
                        : CProxy(pComLink, stubAddr)
{
    m_cRef = 0;

	/*
	 * Aggregate the free-threaded marshaler for cheap in-proc
	 * threading as we are thread-safe.  
	 */
	HRESULT hRes = CoCreateFreeThreadedMarshaler ((IUnknown *) this, &m_pUnkInner);

    ObjectCreated(OBJECT_TYPE_LOGINPROXY);
    return;
}

//***************************************************************************
//
//  CLoginProxy::~CLoginProxy
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CLoginProxy::~CLoginProxy(void)
{
    ObjectDestroyed(OBJECT_TYPE_LOGINPROXY);
    return;
}

//***************************************************************************
// HRESULT CLoginProxy::QueryInterface
// long CLoginProxy::AddRef
// long CLoginProxy::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CLoginProxy::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;

	// Delegate queries for IMarshal to the aggregated
	// free-threaded marshaler
	if (IID_IMarshal==riid && m_pUnkInner)
		return m_pUnkInner->QueryInterface (riid, ppv);

    if ((IID_IUnknown==riid) && m_pComLink != NULL && GetStubAdd ().IsValid ())
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CLoginProxy::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CLoginProxy::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    // refernce count is zero, delete this object and the remote object
	ReleaseProxy ();
    
    m_cRef++;	// Artificial reference count to prevent re-entrancy
	delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\locator.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOCATOR.H

Abstract:

  Declares the CLocator class.

History:

  a-davj  04-May-97   Created.

--*/

#ifndef _locator_H_
#define _locator_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CLocator
//
//  DESCRIPTION:
//
//  Implements the IWbemLocator interface.  This class is what the client gets
//  when it initially hooks up to the Wbemprox.dll.  The ConnectServer function
//  is what get the communication between client and server started.
//
//***************************************************************************

class CPipeLocator : public IWbemClientTransport
{
protected:

	long            m_cRef;         //Object reference count

public:
    
    CPipeLocator();
    ~CPipeLocator(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* iWbemLocator methods */

	HRESULT STDMETHODCALLTYPE ConnectServer( 
    
		BSTR AddressType,
		DWORD dwBinaryAddressLength,
		BYTE __RPC_FAR *pbBinaryAddress,
		BSTR NetworkResource,
		BSTR User,
		BSTR Password,
		BSTR Locale,
		long lSecurityFlags,
		BSTR Authority,
		IWbemContext __RPC_FAR *pCtx,
		IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace
	) ;
};

class CTcpipLocator : public IWbemClientTransport
{
protected:

	long            m_cRef;         //Object reference count

public:
    
    CTcpipLocator();
    ~CTcpipLocator(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* iWbemLocator methods */

	HRESULT STDMETHODCALLTYPE ConnectServer( 
    
		BSTR AddressType,
		DWORD dwBinaryAddressLength,
		BYTE __RPC_FAR *pbBinaryAddress,
		BSTR NetworkResource,
		BSTR User,
		BSTR Password,
		BSTR Locale,
		long lSecurityFlags,
		BSTR Authority,
		IWbemContext __RPC_FAR *pCtx,
		IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace
	) ;

};

class CTcpipAddress : public IWbemAddressResolution
{
protected:

	long            m_cRef;         //Object reference count

public:
    
    CTcpipAddress () ;
    ~CTcpipAddress () ;

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	/* IWbemAddressResolution methods */
 
    HRESULT STDMETHODCALLTYPE Resolve ( 

		LPWSTR pszNamespacePath,
        LPWSTR pszAddressType,
        DWORD __RPC_FAR *pdwAddressLength,
        BYTE __RPC_FAR **pbBinaryAddress
	) ;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\pipeprox.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PIPEPROX.H

Abstract:

  Declares the CProxy subclasses for Anonymous Pipes

History:

  alanbos  12-Dec-97   Created.

--*/

#ifndef _PIPEPROX_H_
#define _PIPEPROX_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CResProxy_LPipe
//
//  DESCRIPTION:
//
//  Anonymous Pipe Proxy for the IWbemCallResult interface.
//
//***************************************************************************

class CResProxy_LPipe : public CResProxy
{
protected:
	void	ReleaseProxy ();

public:
	CResProxy_LPipe (CComLink * pComLink,IStubAddress& stubAddr) :
		CResProxy (pComLink, stubAddr) {}

	// Proxy Factory Methods
	CProvProxy*				GetProvProxy (IStubAddress& dwAddr);
	
	/* IWbemCallResult methods */

    HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppStatusObject);
        
    HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString);
        
    HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus);
        
    HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumProxy_LPipe
//
//  DESCRIPTION:
//
//  Anonymous Pipe Proxy for the IEnumWbemClassObject interface.  
//
//***************************************************************************

class CEnumProxy_LPipe : public CEnumProxy
{
private:
	DWORD	m_dwServiceStubAddr;

protected:
	void	ReleaseProxy ();

public:
    CEnumProxy_LPipe(CComLink * pComLink,IStubAddress& stubAddr, DWORD serviceStubAddr):
			m_dwServiceStubAddr (serviceStubAddr), 
			CEnumProxy (pComLink, stubAddr) {}

	inline DWORD	GetServiceStubAddr () { return m_dwServiceStubAddr; }

	// Proxy Factory Methods
	CEnumProxy*				GetEnumProxy (IStubAddress& dwAddr);

    // IEnumWbemClassObject
	STDMETHODIMP Reset();
    STDMETHODIMP Next(long lTimeout, ULONG uCount, IWbemClassObject FAR* FAR* pProp, 
		   ULONG FAR* turned);
	STDMETHODIMP NextAsync(unsigned long uCount, IWbemObjectSink __RPC_FAR *pSink);
    STDMETHODIMP Clone(IEnumWbemClassObject FAR* FAR* pEnum);
    STDMETHODIMP Skip(long lTimeout, ULONG nNum);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CProvProxy_LPipe
//
//  DESCRIPTION:
//
//  Anonymous Pipe Proxy for the IWbemServices interface.
//
//***************************************************************************

class CProvProxy_LPipe : public CProvProxy
{
protected:
	void	ReleaseProxy ();

public:
	CProvProxy_LPipe (CComLink *pComLink, IStubAddress& stubAddr) :
	  CProvProxy (pComLink, stubAddr) {}

	// Proxy Factory Methods
	CProvProxy*				GetProvProxy (IStubAddress& dwAddr);
	CEnumProxy*				GetEnumProxy (IStubAddress& dwAddr);
	CResProxy*				GetResProxy (IStubAddress& dwAddr);
	CObjectSinkProxy*		GetSinkProxy (IStubAddress& dwAddr);
	
    /* IWbemServices methods */
    /* [id] */ HRESULT STDMETHODCALLTYPE OpenNamespace( 
    /* [in] */ const BSTR Namespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    /* [id] */ HRESULT STDMETHODCALLTYPE QueryObjectSink( 
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE GetObject( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE GetObjectAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutClass( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutClassAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClass( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnum( 
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutInstance( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstance( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecQuery( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethod( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ const BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

    /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ const BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CLoginProxy_LPipe
//
//  DESCRIPTION:
//
//  Proxy for the IWbemLevel1Login interface.  Always overridden.
//
//***************************************************************************

class CLoginProxy_LPipe : public CLoginProxy
{
protected:
	void	ReleaseProxy ();

public:
	CLoginProxy_LPipe (CComLink * pComLink,IStubAddress& stubAddr) :
		CLoginProxy (pComLink, stubAddr) {}

	// Proxy factory methods
	CProvProxy*				GetProvProxy (IStubAddress& dwAddr);
	
	// pseudo-IWbemLevel1Login methods

    STDMETHODIMP RequestChallenge(
		LPWSTR pNetworkResource,
        LPWSTR pUser,
        WBEM_128BITS Nonce);

	STDMETHODIMP EstablishPosition(
			LPWSTR wszClientMachineName,
			DWORD dwProcessId,
			DWORD* phAuthEventHandle
		);

	STDMETHODIMP WBEMLogin(
		LPWSTR pPreferredLocale,
		WBEM_128BITS AccessToken,
		long lFlags,                   // WBEM_LOGIN_TYPE
		IWbemContext *pCtx,              
		IWbemServices **ppNamespace);

	// NTLM authentication methods
    STDMETHODIMP SspiPreLogin( 
        LPSTR pszSSPIPkg,
        long lFlags,
        long lBufSize,
        byte __RPC_FAR *pInToken,
        long lOutBufSize,
        long __RPC_FAR *plOutBufBytes,
        byte __RPC_FAR *pOutToken,
		LPWSTR wszClientMachineName,
        DWORD dwProcessId,
        DWORD __RPC_FAR *pAuthEventHandle);  
                    
    STDMETHODIMP Login( 
		LPWSTR pNetworkResource,
		LPWSTR pPreferredLocale,
        WBEM_128BITS AccessToken,
        IN LONG lFlags,
        IWbemContext  *pCtx,
        IN OUT IWbemServices  **ppNamespace);
};


#endif // !_PIPEPROX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\pipeprxo.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPEPRXO.CPP

Abstract:

  Definees the proxy pipe operation classes

History:

  alanbos  18-Dec-97   Created.

--*/

#include "precomp.h"

// CProxyOperation_LPipe_CreateEnum
void CProxyOperation_LPipe_CreateEnum::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_parent);
    encodeStream.WriteLong(m_flags);
	EncodeContext (encodeStream);

	if (IsAsync ())
		encodeStream.WriteDWORD(m_pHandler);
}


// CProxyOperation_LPipe_Delete
void CProxyOperation_LPipe_Delete::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_path);
	encodeStream.WriteLong(m_flags);
	EncodeContext(encodeStream);

	if (IsAsync ())
		encodeStream.WriteDWORD (m_pHandler);
	else
		encodeStream.WriteLong((long) GetResultObjectPP ());
}


// CProxyOperation_LPipe_ExecQuery
void CProxyOperation_LPipe_ExecQuery::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_queryLanguage);
    encodeStream.WriteBSTR(m_query);
    encodeStream.WriteLong(m_flags);
	EncodeContext(encodeStream);

	if (IsAsync ())
		encodeStream.WriteDWORD(m_pHandler);
}


// CProxyOperation_LPipe_GetObject
void CProxyOperation_LPipe_GetObject::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_path);
    encodeStream.WriteLong(m_flags);
	EncodeContext(encodeStream);

	if (IsAsync ())
		encodeStream.WriteDWORD((DWORD)m_pHandler);
	else
	{
		encodeStream.WriteLong((long) m_ppObject);
		encodeStream.WriteLong((long) GetResultObjectPP ());
	}
}

void CProxyOperation_LPipe_GetObject::DecodeOp (CTransportStream& decodeStream)
{
	if (!IsAsync () && ( SUCCEEDED (GetStatus ())))
	{
		*m_ppObject = CreateClassObject(&decodeStream);
		SetStatus ((bVerifyPointer(*m_ppObject)) ? WBEM_NO_ERROR : WBEM_E_OUT_OF_MEMORY);
    
		if(WBEM_NO_ERROR == GetStatus ())
		{
			// bVerifyPointer AddRef's if successul
			IUnknown *pIUnknown = (IUnknown *)*m_ppObject;
			pIUnknown->Release();
		}
    }

	// Look for stub address of IWbemCallResult if client requested it
	if (GetResultObjectPP ())
		DecodeStubAddress (CALLRESULT, decodeStream);
}


// CProxyOperation_LPipe_OpenNamespace
void CProxyOperation_LPipe_OpenNamespace::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_path);
    encodeStream.WriteLong(m_flags);
	EncodeContext(encodeStream);
	encodeStream.WriteLong((long) GetResultObjectPP ());
}

void CProxyOperation_LPipe_OpenNamespace::DecodeOp (CTransportStream& decodeStream)
{
	if ( SUCCEEDED (GetStatus ()))
		// It's OK to have an invalid stub address if we're doing semisynchronous
		DecodeStubAddress (PROVIDER, decodeStream, !(GetResultObjectPP ()));
	if (GetResultObjectPP ()) 
		DecodeStubAddress (CALLRESULT, decodeStream);
}


// CProxyOperation_LPipe_Put
void CProxyOperation_LPipe_Put::EncodeOp (CTransportStream& encodeStream)
{
	((CWbemObject *)(m_pObject))->WriteToStream(&encodeStream);
    encodeStream.WriteLong(m_flags);
	EncodeContext(encodeStream);

	if (IsAsync ())
		encodeStream.WriteDWORD (m_pHandler);
	else
		encodeStream.WriteLong((long) GetResultObjectPP ());
}


// CProxyOperation_LPipe_ExecMethod
void CProxyOperation_LPipe_ExecMethod::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_path);
	encodeStream.WriteBSTR(m_method);
    encodeStream.WriteLong(m_flags);
	EncodeContext(encodeStream);

	if (m_pInParams)
	{
		encodeStream.WriteLong (1);
		((CWbemObject *)(m_pInParams))->WriteToStream(&encodeStream);
	}
	else
		encodeStream.WriteLong (0);

	if (IsAsync ())
		encodeStream.WriteDWORD((DWORD)m_pHandler);
	else
	{
		encodeStream.WriteLong((long) m_ppOutParams);
		encodeStream.WriteLong((long) GetResultObjectPP());
	}
}

void CProxyOperation_LPipe_ExecMethod::DecodeOp (CTransportStream& decodeStream)
{
	if (!IsAsync () && ( SUCCEEDED (GetStatus ())))
	{
		*m_ppOutParams = CreateClassObject(&decodeStream);
		SetStatus ((bVerifyPointer(*m_ppOutParams)) ? WBEM_NO_ERROR : WBEM_E_OUT_OF_MEMORY);
    
		if( WBEM_NO_ERROR == GetStatus ())
		{
			// bVerifyPointer AddRef's if successul
			IUnknown *pIUnknown = (IUnknown *)*m_ppOutParams;
			pIUnknown->Release();
		}
	}

	// Look for stub address of IWbemCallResult if client requested it
	if (GetResultObjectPP ()) 
		DecodeStubAddress (CALLRESULT, decodeStream);
}

// CProxyOperation_LPipe_RequestChallenge
void CProxyOperation_LPipe_RequestChallenge::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_pNetworkResource);
    encodeStream.WriteBSTR(m_pUser);
}

void CProxyOperation_LPipe_RequestChallenge::DecodeOp (CTransportStream& decodeStream)
{
	if(SUCCEEDED( GetStatus ()))
	    SetStatus (decodeStream.ReadBytes((void *)m_pNonce, DIGEST_SIZE));
}

// CProxyOperation_LPipe_EstablishPosition
void CProxyOperation_LPipe_EstablishPosition::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_pClientMachineName);
    encodeStream.WriteDWORD(m_processId);
}

void CProxyOperation_LPipe_EstablishPosition::DecodeOp (CTransportStream& decodeStream)
{
	if( SUCCEEDED (GetStatus ()))
	    SetStatus (decodeStream.ReadDWORD(m_pAuthEventHandle));
}

// CProxyOperation_LPipe_WBEMLogin
void CProxyOperation_LPipe_WBEMLogin::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_pPreferredLocale);
    encodeStream.WriteBytes(m_accessToken,DIGEST_SIZE);
    encodeStream.WriteLong(m_flags);
    EncodeContext(encodeStream);
}

// CProxyOperation_LPipe_SspiPreLogin
void CProxyOperation_LPipe_SspiPreLogin::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteLPSTR(m_pszSSPIPkg);
    encodeStream.WriteLong(m_flags);
    encodeStream.WriteLong(m_bufSize);
    encodeStream.WriteBytes(m_pInToken,m_bufSize);
    encodeStream.WriteLong(m_outBufSize);
	encodeStream.WriteBSTR(m_pClientMachineName);
    encodeStream.WriteDWORD(m_dwProcessID);
}

void CProxyOperation_LPipe_SspiPreLogin::DecodeOp (CTransportStream& decodeStream)
{
	if( ! FAILED ( GetStatus () ) )
	{
		decodeStream.ReadLong(m_OutBufBytes);
        if(decodeStream.Status() != CTransportStream::no_error)
			SetStatus (WBEM_E_INVALID_STREAM);
		else
		{
			HRESULT dwRet = decodeStream.ReadBytes(m_pOutToken, *m_OutBufBytes);
			if(m_pAuthEventHandle)
				dwRet |= decodeStream.ReadDWORD(m_pAuthEventHandle);
			if ( FAILED ( dwRet ) )
				SetStatus (dwRet);
		}
	}
}

// CProxyOperation_LPipe_Login
void CProxyOperation_LPipe_Login::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteBSTR(m_pNetworkResource);
	encodeStream.WriteBSTR(m_pPreferredLocale);
    encodeStream.WriteBytes(m_accessToken,DIGEST_SIZE);
    encodeStream.WriteLong(m_flags);
    EncodeContext(encodeStream);
}


// CProxyOperation_LPipe_Next
void CProxyOperation_LPipe_Next::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteLong(m_timeout);
	// TODO - m_count was a LONG - should we really be writing a DWORD??
	encodeStream.WriteDWORD(m_count);
}


void CProxyOperation_LPipe_Next::DecodeOp (CTransportStream& decodeStream)
{
	if( SUCCEEDED ( GetStatus () ) )
	{
		decodeStream.ReadDWORD(m_pReturned);

        for(DWORD dwLoop = 0; dwLoop < *m_pReturned && 
                decodeStream.Status() == CTransportStream::no_error; dwLoop++)
        {

            // For each object, create a proxy and add a pointer to the
            // object into the array.
            // ========================================================

            m_objArray [dwLoop] = CreateClassObject(&decodeStream);
            if(!bVerifyPointer(m_objArray[dwLoop]))
                break;					// also do this in noteclie.cpp
            m_objArray[dwLoop]->Release();   // set ref count to 1
        }

        if(dwLoop < *m_pReturned)
        {
            // got some sort of error, free all the ones that were 
            // allocated, set the error code.
                
            DWORD dwDelTo = dwLoop;
            for(dwLoop = 0; dwLoop < dwDelTo; dwLoop++)
                delete m_objArray[dwLoop];
            SetStatus (WBEM_E_FAILED);
	    }
	}
}

// CProxyOperation_LPipe_GetResultObject
void CProxyOperation_LPipe_GetResultObject::EncodeOp (CTransportStream& encodeStream)
{
	encodeStream.WriteLong (m_timeout);
	
	if (*m_ppStatusObject)
	{
		if (CTransportStream::no_error != 
				((CWbemObject *)*m_ppStatusObject)->WriteToStream (&encodeStream))
			SetStatus (WBEM_E_INVALID_STREAM);
	}
}

void CProxyOperation_LPipe_GetResultObject::DecodeOp (CTransportStream& decodeStream)
{
	if (SUCCEEDED (GetStatus ()))
	{
        *m_ppStatusObject = CreateClassObject(&decodeStream);

        if(!bVerifyPointer(*m_ppStatusObject))
			SetStatus (WBEM_E_FAILED);
		else
			(*m_ppStatusObject)->Release();   // set ref count back to 1
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <localloc.h>
#include "wmishared.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\pipeprxo.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPEPRXO.H

Abstract:

  Declares the proxy pipe operation classes

History:

  alanbos  18-Dec-97   Created.

--*/

#ifndef _PIPEPRXO_H_
#define _PIPEPRXO_H_

// Anonymous Pipe Cancel Async Call Operation
class CProxyOperation_LPipe_CancelAsyncCall : public IProxyOperation_LPipe
{
private:
	DWORD	m_pSink;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		encodeStream.WriteDWORD(m_pSink);
	}

public:
	CProxyOperation_LPipe_CancelAsyncCall (IWbemObjectSink __RPC_FAR* pSink, 
		CStubAddress_WinMgmt& stubAddr) : m_pSink ((DWORD) pSink),
		IProxyOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_CancelAsyncCall) {}
}; 


// Anonymous Pipe Create Class or Instance Enum Operation
class CProxyOperation_LPipe_CreateEnum : public IProxyOperation_LPipe
{
private:
	BSTR	m_parent;
	long	m_flags;
	DWORD	m_pHandler;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream) 
	{
		if (!IsAsync () && (WBEM_NO_ERROR == GetStatus ()))
			DecodeStubAddress (ENUMERATOR, decodeStream);
	}

public:
	CProxyOperation_LPipe_CreateEnum (BSTR Parent, long lFlags, 
		DWORD iFunc, IWbemObjectSink FAR* pHandler, CStubAddress_WinMgmt& stubAddr, IWbemContext* pCtx = NULL, 
		IWbemCallResult** ppResult= NULL, bool isAsync = FALSE) : 
		m_parent (Parent), m_flags (lFlags), m_pHandler ((DWORD) pHandler),
		IProxyOperation_LPipe (stubAddr, PROVIDER, iFunc, pCtx, ppResult, isAsync)
	{}
};


	

// Anonymous Pipe Delete Class or Instance Operation
class CProxyOperation_LPipe_Delete : public IProxyOperation_LPipe
{
private:
	BSTR		m_path;
	long		m_flags;
	DWORD		m_pHandler;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (GetResultObjectPP ()) 
			DecodeStubAddress (CALLRESULT, decodeStream);
	}

public:
	CProxyOperation_LPipe_Delete (BSTR path, long lFlags, DWORD iFunc, 
		IWbemObjectSink FAR* pHandler, CStubAddress_WinMgmt& stubAddr,
		IWbemContext* pCtx = NULL, IWbemCallResult** ppResult= NULL, 
		bool isAsync = FALSE) : m_path (path), m_flags (lFlags), m_pHandler ((DWORD) pHandler),
		IProxyOperation_LPipe (stubAddr, PROVIDER, iFunc, pCtx, ppResult, isAsync)
	{}
};



// Anonymous Pipe Execute (Notification) Query Operation
class CProxyOperation_LPipe_ExecQuery : public IProxyOperation_LPipe
{
private:
	BSTR		m_queryLanguage;
	BSTR		m_query;
	long		m_flags;
	DWORD		m_pHandler;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream) 
	{
		if (!IsAsync () && (WBEM_NO_ERROR == GetStatus ()))
			DecodeStubAddress (ENUMERATOR, decodeStream);
	}

public:
	CProxyOperation_LPipe_ExecQuery (BSTR queryLanguage, 
				BSTR query, long lFlags, IWbemObjectSink FAR* pHandler, DWORD iFunc,
				CStubAddress_WinMgmt& stubAddr, IWbemContext* pCtx = NULL, bool isAsync = FALSE) : 
		m_queryLanguage (queryLanguage), m_query (query), m_flags (lFlags),
		m_pHandler ((DWORD) pHandler),
		IProxyOperation_LPipe (stubAddr, PROVIDER, iFunc, pCtx, NULL, isAsync)
	{}
};


// Anonymous Pipe Get Object Operation
class CProxyOperation_LPipe_GetObject : public IProxyOperation_LPipe
{
private:
	BSTR			m_path;
	long			m_flags;
	DWORD			m_pHandler;
	IWbemClassObject FAR* FAR* m_ppObject;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_GetObject (BSTR path, long lFlags, 
			IWbemClassObject FAR* FAR* ppObject, IWbemObjectSink FAR* pHandler,
			CStubAddress_WinMgmt& stubAddr,	IWbemContext* pCtx = NULL, IWbemCallResult** ppResult= NULL, 
			bool isAsync = FALSE) : m_path (path), m_flags (lFlags), m_ppObject (ppObject),
			m_pHandler ((DWORD) pHandler),
		IProxyOperation_LPipe (stubAddr, PROVIDER, 
				(isAsync) ? WBEM_METHOD_GetObjectAsync : WBEM_METHOD_GetObject, 
				pCtx, ppResult, isAsync)
	{}
};


// Anonymous Pipe Open Namespace Operation
class CProxyOperation_LPipe_OpenNamespace : public IProxyOperation_LPipe
{
private:
	BSTR			m_path;
	long			m_flags;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_OpenNamespace (BSTR path, long lFlags, CStubAddress_WinMgmt& stubAddr,
			IWbemContext* pCtx = NULL, IWbemCallResult** ppResult= NULL) : 
		m_path (path), m_flags (lFlags), 
		IProxyOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_OpenNamespace, 
			pCtx, ppResult) {}
};


// Anonymous Pipe Put Class or Instance Operation
class CProxyOperation_LPipe_Put : public IProxyOperation_LPipe
{
private:
	IWbemClassObject FAR*	m_pObject;
	long					m_flags;
	DWORD					m_pHandler;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (GetResultObjectPP ()) 
			DecodeStubAddress (CALLRESULT, decodeStream);
	}
	
public:
	CProxyOperation_LPipe_Put (IWbemClassObject FAR* pObj, long lFlags, DWORD iFunc, 
		IWbemObjectSink FAR* pHandler, CStubAddress_WinMgmt& stubAddr,
		IWbemContext* pCtx = NULL, IWbemCallResult** ppResult= NULL, 
		bool isAsync = FALSE) : m_pObject (pObj), m_flags (lFlags), m_pHandler ((DWORD) pHandler),
		IProxyOperation_LPipe (stubAddr, PROVIDER, iFunc, pCtx, ppResult, isAsync)
	{}
};


// Anonymous Pipe Query Object Sink Operation
class CProxyOperation_LPipe_QueryObjectSink : public IProxyOperation_LPipe
{
private:
	long			m_flags;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
	    encodeStream.WriteLong(m_flags);
	}
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			DecodeStubAddress (OBJECTSINK, decodeStream);
	}

public:
	CProxyOperation_LPipe_QueryObjectSink (long lFlags, CStubAddress_WinMgmt& stubAddr) : 
		m_flags (lFlags), 
		IProxyOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_QueryObjectSink)
	{}
};


// Anonymous Pipe Execute Method Operation
class CProxyOperation_LPipe_ExecMethod : public IProxyOperation_LPipe
{
private:
	BSTR					m_path;
	BSTR					m_method;
	long					m_flags;
	IWbemClassObject FAR*	m_pInParams;
	DWORD					m_pHandler;
	IWbemClassObject FAR* FAR* m_ppOutParams;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_ExecMethod (BSTR ObjectPath, BSTR MethodName, long lFlags, 
			IWbemClassObject FAR* pInParams, IWbemClassObject FAR* FAR* ppOutParams,
			IWbemObjectSink FAR *pHandler, CStubAddress_WinMgmt& stubAddr,
			IWbemContext* pCtx = NULL, IWbemCallResult** ppResult= NULL, 
			bool isAsync = FALSE) : m_path (ObjectPath), m_method (MethodName),
			m_flags (lFlags), m_pInParams (pInParams), m_ppOutParams (ppOutParams),
			m_pHandler ((DWORD) pHandler),
			IProxyOperation_LPipe (stubAddr, PROVIDER, 
				(isAsync) ? WBEM_METHOD_ExecMethodAsync : WBEM_METHOD_ExecMethod, 
				pCtx, ppResult, isAsync)
	{}
};


// Anonymous Pipe request challenge operation
class CProxyOperation_LPipe_RequestChallenge : public IProxyOperation_LPipe
{
private:
	LPWSTR			m_pNetworkResource;
	LPWSTR			m_pUser;
	WBEM_128BITS	m_pNonce;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_RequestChallenge (LPWSTR pNetworkResource,
            LPWSTR pUser, WBEM_128BITS Nonce, CStubAddress_WinMgmt& stubAddr) :
		m_pNetworkResource (pNetworkResource), m_pUser (pUser), m_pNonce (Nonce),
		IProxyOperation_LPipe (stubAddr, LOGIN, REQUESTCHALLENGE)
	{}
};

// Anonymous Pipe establish position operation
class CProxyOperation_LPipe_EstablishPosition : public IProxyOperation_LPipe
{
private:
	LPWSTR			m_pClientMachineName;
	DWORD			m_processId;
	DWORD			*m_pAuthEventHandle;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_EstablishPosition (LPWSTR wszClientMachineName,
            DWORD dwProcessId, DWORD* phAuthEventHandle, CStubAddress_WinMgmt& stubAddr) :
		m_pClientMachineName (wszClientMachineName), m_processId (dwProcessId), 
		m_pAuthEventHandle (phAuthEventHandle),
		IProxyOperation_LPipe (stubAddr, LOGIN, ESTABLISHPOSITION)
	{}
};

// Anonymous Pipe WBEMLogin operation
class CProxyOperation_LPipe_WBEMLogin : public IProxyOperation_LPipe
{
private:
	LPWSTR			m_pPreferredLocale;
	WBEM_128BITS	m_accessToken;
    long			m_flags;
    
protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			DecodeStubAddress (PROVIDER, decodeStream);
	}
	
public:
	CProxyOperation_LPipe_WBEMLogin (LPWSTR pPreferredLocale, WBEM_128BITS AccessToken,
            long lFlags, CStubAddress_WinMgmt& stubAddr, IWbemContext *pCtx) :
		m_pPreferredLocale (pPreferredLocale), m_accessToken (AccessToken), m_flags (lFlags), 
		IProxyOperation_LPipe (stubAddr, LOGIN, WBEMLOGIN, pCtx)
	{}
};

// Anonymous Pipe SSPI Pre Login operation
class CProxyOperation_LPipe_SspiPreLogin : public IProxyOperation_LPipe
{
private:
    LPSTR			m_pszSSPIPkg;
    long			m_flags;
    long			m_bufSize;
    byte __RPC_FAR*	m_pInToken;
    long			m_outBufSize;
    long __RPC_FAR* m_OutBufBytes;
    byte __RPC_FAR*	m_pOutToken;
	LPWSTR			m_pClientMachineName;
	DWORD			m_dwProcessID; 
	DWORD __RPC_FAR*	m_pAuthEventHandle;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_SspiPreLogin (LPSTR pszSSPIPkg, long lFlags, 
			long lBufSize, byte __RPC_FAR* pInToken, long lOutBufSize, 
			long __RPC_FAR* plOutBufBytes, byte __RPC_FAR* pOutToken,
			LPWSTR pClientMachineName, DWORD dwProcessID, 
			DWORD* pAuthEventHandle, CStubAddress_WinMgmt& stubAddr) :
		m_pszSSPIPkg (pszSSPIPkg), 
		m_flags (lFlags), m_bufSize (lBufSize), m_pInToken (pInToken),
		m_outBufSize (lOutBufSize), m_OutBufBytes (plOutBufBytes),
		m_pOutToken (pOutToken), m_pClientMachineName (pClientMachineName), 
		m_dwProcessID (dwProcessID), 
		m_pAuthEventHandle (pAuthEventHandle),
		IProxyOperation_LPipe (stubAddr, LOGIN, SSPIPRELOGIN)
	{}
};

// Anonymous Pipe Login operation
class CProxyOperation_LPipe_Login : public IProxyOperation_LPipe
{
private:
	LPWSTR			m_pNetworkResource;
	LPWSTR			m_pPreferredLocale;
	WBEM_128BITS	m_accessToken;
    long			m_flags;
    
protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			DecodeStubAddress (PROVIDER, decodeStream);
	}
	
public:
	CProxyOperation_LPipe_Login (LPWSTR pNetworkResource,
			LPWSTR pPreferredLocale, WBEM_128BITS AccessToken,
            long lFlags, CStubAddress_WinMgmt& stubAddr, IWbemContext *pCtx) :
		m_pNetworkResource (pNetworkResource), 
		m_pPreferredLocale (pPreferredLocale), m_accessToken (AccessToken), m_flags (lFlags), 
		IProxyOperation_LPipe (stubAddr, LOGIN, LOGINBYTOKEN, pCtx)
	{}
};

// Anonymous Pipe Reset Operation
class CProxyOperation_LPipe_Reset : public IProxyOperation_LPipe
{
public:
	CProxyOperation_LPipe_Reset (CStubAddress_WinMgmt& stubAddr) :
		IProxyOperation_LPipe (stubAddr, ENUMERATOR, RESET) {}
};


// Anonymous Pipe Next Operation
class CProxyOperation_LPipe_Next : public IProxyOperation_LPipe
{
private:
	long		m_timeout;
	ULONG		m_count;
	IWbemClassObject FAR* FAR*	m_objArray;
	ULONG FAR *					m_pReturned;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_Next (long lTimeout, ULONG uCount,
			IWbemClassObject FAR* FAR* pProp, ULONG FAR* puReturned, 
			CStubAddress_WinMgmt& stubAddr) :
		m_timeout (lTimeout), m_count(uCount), m_objArray (pProp), m_pReturned (puReturned),
		IProxyOperation_LPipe (stubAddr, ENUMERATOR, NEXT) {}
};

// Anonymous Pipe Clone Operation
class CProxyOperation_LPipe_Clone : public IProxyOperation_LPipe
{
protected:
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			DecodeStubAddress (ENUMERATOR, decodeStream);
	}

public:
	CProxyOperation_LPipe_Clone (CStubAddress_WinMgmt& stubAddr) :
		IProxyOperation_LPipe (stubAddr, ENUMERATOR, CLONE) {}
};

// Anonymous Pipe NextAsync Operation
class CProxyOperation_LPipe_NextAsync : public IProxyOperation_LPipe
{
private:
	ULONG		m_count;
	DWORD		m_pSink;
	DWORD		m_pServiceStub;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		encodeStream.WriteLong(m_count);
		encodeStream.WriteDWORD(m_pSink);
		encodeStream.WriteDWORD(m_pServiceStub);
	}

public:
	CProxyOperation_LPipe_NextAsync (ULONG uCount,
			IWbemObjectSink __RPC_FAR* pSink, CStubAddress_WinMgmt& stubAddr,
			DWORD serviceStubAddr) :
		m_count(uCount), m_pSink ((DWORD)pSink), m_pServiceStub (serviceStubAddr),
		IProxyOperation_LPipe (stubAddr, ENUMERATOR, NEXTASYNC, NULL, NULL, TRUE) {}
};

// Anonymous Pipe Skip Operation
class CProxyOperation_LPipe_Skip : public IProxyOperation_LPipe
{
private:
	long		m_timeout;
	ULONG		m_number;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		encodeStream.WriteLong(m_timeout);
		encodeStream.WriteDWORD(m_number);
	}

public:
	CProxyOperation_LPipe_Skip (long lTimeout, ULONG nNum, CStubAddress_WinMgmt& stubAddr) :
		m_timeout (lTimeout), m_number(nNum), 
		IProxyOperation_LPipe (stubAddr, ENUMERATOR, SKIP) {}
    virtual ~CProxyOperation_LPipe_Skip () {}
};

// Anonymous Pipe Get Result Operation
class CProxyOperation_LPipe_GetResultObject : public IProxyOperation_LPipe
{
private:
	long	m_timeout;
	IWbemClassObject __RPC_FAR* __RPC_FAR*	m_ppStatusObject;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);

public:
	CProxyOperation_LPipe_GetResultObject (long lTimeout, 
		IWbemClassObject __RPC_FAR *__RPC_FAR *ppStatusObject, CStubAddress_WinMgmt& stubAddr) :
		m_timeout (lTimeout), m_ppStatusObject (ppStatusObject),
		IProxyOperation_LPipe (stubAddr, CALLRESULT, GETRESULTOBJECT) {}
};


// Anonymous Pipe Get Result String Operation
class CProxyOperation_LPipe_GetResultString : public IProxyOperation_LPipe
{
private:
	long	m_timeout;
	BSTR __RPC_FAR* m_pResultString;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		encodeStream.WriteLong (m_timeout);
	}
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			decodeStream.ReadBSTR(m_pResultString);
	}
	
public:
	CProxyOperation_LPipe_GetResultString (long lTimeout, 
		BSTR __RPC_FAR* pstrResultString, CStubAddress_WinMgmt& stubAddr) :
		m_timeout (lTimeout), m_pResultString (pstrResultString),
		IProxyOperation_LPipe (stubAddr, CALLRESULT, GETRESULTSTRING) {}
	virtual ~CProxyOperation_LPipe_GetResultString () {}
};

// Anonymous Pipe Get Call Status Operation
class CProxyOperation_LPipe_GetCallStatus : public IProxyOperation_LPipe
{
private:
	long			m_timeout;
	long __RPC_FAR*	m_pStatus;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		encodeStream.WriteLong (m_timeout);
	}
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			decodeStream.ReadLong(m_pStatus);
	}

public:
	CProxyOperation_LPipe_GetCallStatus (long lTimeout, 
		long __RPC_FAR *plStatus, CStubAddress_WinMgmt& stubAddr) :
		m_timeout (0), m_pStatus (plStatus),
		IProxyOperation_LPipe (stubAddr, CALLRESULT, GETCALLSTATUS) {}
};

// Anonymous Pipe Get Result Services Operation
class CProxyOperation_LPipe_GetResultServices : public IProxyOperation_LPipe
{
private:
	long	m_timeout;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		encodeStream.WriteLong (m_timeout);
	}
	void	DecodeOp (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			DecodeStubAddress (PROVIDER, decodeStream);
	}

public:
	CProxyOperation_LPipe_GetResultServices (long lTimeout, CStubAddress_WinMgmt& stubAddr) :
		m_timeout (lTimeout),
		IProxyOperation_LPipe (stubAddr, CALLRESULT, GETSERVICES) {}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\provprox.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVPROX.CPP

Abstract:

  Defines the CProvProxy object

History:

  a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
//  CProvProxy::CProvProxy
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pComLink            Comlink object.
//  stubAddr          Stub address in the server
//
//***************************************************************************

CProvProxy::CProvProxy(
                        IN CComLink * pComLink,
                        IN IStubAddress& stubAddr)
                        :  CProxy(pComLink, stubAddr)
{
    m_cRef = 0;

    /*
	 * Aggregate the free-threaded marshaler for cheap in-proc
	 * threading as we are thread-safe.  
	 */
	HRESULT hRes = CoCreateFreeThreadedMarshaler ((IUnknown *) this, &m_pUnkInner);

	ObjectCreated(OBJECT_TYPE_PROVPROXY);
    return;
}

//***************************************************************************
//
//  CProvProxy::~CProvProxy
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CProvProxy::~CProvProxy(void)
{
	ObjectDestroyed(OBJECT_TYPE_PROVPROXY);
    return;
}

//***************************************************************************
// HRESULT CProvProxy::QueryInterface
// long CProvProxy::AddRef
// long CProvProxy::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CProvProxy::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;

    if(ppv == NULL)
        return WBEM_E_INVALID_PARAMETER;

	// Delegate queries for IMarshal to the aggregated
	// free-threaded marshaler
	if (IID_IMarshal==riid && m_pUnkInner)
		return m_pUnkInner->QueryInterface (riid, ppv);

    if (IID_IUnknown==riid || IID_IWbemServices == riid)
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvProxy::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CProvProxy::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    // refernce count is zero, delete this object and its remote counterpart
	// if appropriate
    ReleaseProxy ();

	m_cRef++;	// Artificial reference count to prevent re-entrancy
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\proxy.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROXY.H

Abstract:

  Declares the CProxy subclasses used by only the proxy.

History:

  a-davj  04-Mar-97   Created.

--*/

#ifndef _PROXY_H_
#define _PROXY_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CResProxy
//
//  DESCRIPTION:
//
//  Proxy for the IWbemCallResult interface.  Always overridden.
//
//***************************************************************************

class CResProxy : public IWbemCallResult, public CProxy
{
    protected:
		CResProxy(CComLink * pComLink,IStubAddress& stubAddr);
  
    public:
		~CResProxy ();

       //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumProxy
//
//  DESCRIPTION:
//
//  Proxy for the IEnumWbemClassObject interface.  Always overridden.
//
//***************************************************************************

class CEnumProxy : public IEnumWbemClassObject, public CProxy
{
    protected:
        CEnumProxy(CComLink * pComLink,IStubAddress& stubAddr);

    public:
		~CEnumProxy ();

        //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CProvProxy
//
//  DESCRIPTION:
//
//  Proxy for the IWbemServices interface.  Always overridden
//
//***************************************************************************

class CProvProxy : public IWbemServices, public CProxy
{
	private:
		

	protected:
		CProvProxy(CComLink * pComLink,IStubAddress& stubAddr);
        
	public:
		~CProvProxy ();

       //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CLoginProxy
//
//  DESCRIPTION:
//
//  Proxy for the IWbemLevel1Login interface.  Always overridden.
//
//***************************************************************************

class CLoginProxy : public IServerLogin, public CProxy
{
    protected:
        CLoginProxy(CComLink * pComLink,IStubAddress& stubAddr);

    public:
		~CLoginProxy ();

        //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\provhmmp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVHMMP.CPP

Abstract:

  Defines the CProvProxy_Hmmp object

History:

  alanbos  10-Dec-97   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CancelAsyncCall
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CancelAsyncCall.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//***************************************************************************

SCODE CProvProxy_Hmmp::CancelAsyncCall(
                        IWbemObjectSink __RPC_FAR *pSink)
{
    if (pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;
    
	// TODO - HMMP does not support CancelAsyncCall; all we would do 
	// here is delete the operation supporting this object sink.  TO
	// do this we would need to find the operation (by object sink)
	// in the request queue and remove it.
	
	return WBEM_NO_ERROR;
}

//***************************************************************************
//
//  SCODE CProvProxy::DeleteClass
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteClass.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_Hmmp::DeleteClass(const BSTR Class,
                        long lFlags,
                        IWbemContext *pCtx, IWbemCallResult **ppResult)
{
	if (NULL == Class) 
		return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_Hmmp_DeleteClass opn (Class, lFlags, pCtx, ppResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy::DeleteClassAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteClassAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_Hmmp::DeleteClassAsync(
                        const BSTR Class,
                        long lFlags, IWbemContext *pCtx,  
                        IWbemObjectSink FAR* pResponseHandler)
{
    if (Class == NULL || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

	CProxyOperation_Hmmp_DeleteClass opn (Class, lFlags, m_dwStubAddr, pCtx, ppResult, TRUE);
    return CallAndCleanupAsync(pResponseHandler, opn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\provprxp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVPRXP.CPP

Abstract:

  Defines the CProvProxy_LPipe class

History:

  alanbos  10-Dec-97   Created.

--*/

#include "precomp.h"

CProvProxy* CProvProxy_LPipe::GetProvProxy (IStubAddress& dwAddr)
{
	return new CProvProxy_LPipe (m_pComLink, dwAddr);
}

CEnumProxy* CProvProxy_LPipe::GetEnumProxy (IStubAddress& dwAddr)
{
	return new CEnumProxy_LPipe (m_pComLink, dwAddr, 
		((CStubAddress_WinMgmt &)GetStubAdd ()).GetRawAddress ());
}

CResProxy* CProvProxy_LPipe::GetResProxy (IStubAddress& dwAddr)
{
	return new CResProxy_LPipe (m_pComLink, dwAddr);
}

CObjectSinkProxy* CProvProxy_LPipe::GetSinkProxy (IStubAddress& dwAddr)
{
	return new CObjectSinkProxy_LPipe (m_pComLink, dwAddr);
}

void CProvProxy_LPipe::ReleaseProxy ()
{
	if (NULL == m_pComLink)
		return;

	CProxyOperation_LPipe_Release opn ((CStubAddress_WinMgmt &) GetStubAdd (), PROVIDER);
    CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CancelAsyncCall
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CancelAsyncCall.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//***************************************************************************

SCODE CProvProxy_LPipe::CancelAsyncCall(
                        IWbemObjectSink __RPC_FAR *pSink)
{
    if (NULL == pSink)
		return WBEM_E_INVALID_PARAMETER;
                 
	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_CancelAsyncCall opn (pSink, (CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CreateClassEnum
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateClassEnum.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::CreateClassEnum(
                        BSTR Parent,
                        long lFlags,
                        IWbemContext *pCtx, 
						IEnumWbemClassObject **ppEnum)
{
    if (ppEnum == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_CreateEnum opn (Parent, lFlags, WBEM_METHOD_CreateClassEnum,
							NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
    return CallAndCleanup(ENUMERATOR, (PPVOID)ppEnum, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CreateClassEnumAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateClassEnumAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::CreateClassEnumAsync(
                        BSTR RefClass,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler)
{
    if (NULL == pHandler)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_CreateEnum opn 
							(RefClass, lFlags, WBEM_METHOD_CreateClassEnumAsync,
							 pHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pHandler);
}
                
//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CreateInstanceEnum
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateInstanceEnum.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::CreateInstanceEnum(
                        BSTR Class,
                        long lFlags,
						IWbemContext *pCtx,
                        IEnumWbemClassObject FAR* FAR* ppEnum)
{
    if(NULL == ppEnum || NULL == Class) // a-levn
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_CreateEnum opn (Class, lFlags, WBEM_METHOD_CreateInstanceEnum, 
							NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);

    return CallAndCleanup(ENUMERATOR, (PPVOID)ppEnum, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CreateInstanceEnumAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateInstanceEnumAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::CreateInstanceEnumAsync(
                        BSTR Class,
                        long lFlags, IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler)
{
    if(NULL == pHandler || NULL == Class) // a-levn
        return WBEM_E_INVALID_PARAMETER;

   	CProxyOperation_LPipe_CreateEnum opn 
							(Class, lFlags, WBEM_METHOD_CreateInstanceEnumAsync,
							 pHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pHandler);
}


//***************************************************************************
//
//  SCODE CProvProxy_LPipe::DeleteClass
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteClass.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::DeleteClass(
                        BSTR Class,
                        long lFlags,
                        IWbemContext *pCtx, IWbemCallResult **ppResult)
{
	INIT_RES_OBJ(ppResult);

	if (NULL == Class) 
		return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Delete opn (Class, lFlags, WBEM_METHOD_DeleteClass,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::DeleteClassAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteClassAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::DeleteClassAsync(
                        BSTR Class,
                        long lFlags, IWbemContext *pCtx,  
                        IWbemObjectSink FAR* pResponseHandler)
{
    if (NULL == Class || NULL == pResponseHandler)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Delete opn (Class, lFlags, WBEM_METHOD_DeleteClassAsync, 
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), 
					pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::DeleteInstance
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstance.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::DeleteInstance(
                        BSTR ObjectPath,
                        long lFlags, 
                        IWbemContext *pCtx, IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);

    if (NULL == ObjectPath) // a-levn
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_Delete opn (ObjectPath, lFlags, WBEM_METHOD_DeleteInstance,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::DeleteInstanceAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::DeleteInstanceAsync(
                        BSTR ObjectPath,
                        long lFlags, IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pResponseHandler)
{
    if (ObjectPath == 0 || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Delete opn (ObjectPath, lFlags, WBEM_METHOD_DeleteInstanceAsync, 
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecNotificationQuery
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
    if(ppEnum == NULL || QueryLanguage == NULL || Query == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryLanguage, Query, lFlags, NULL,
						WBEM_METHOD_ExecNotificationQuery, 
						(CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
	return CallAndCleanup (ENUMERATOR, (PPVOID)ppEnum, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecNotificationQueryAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    if(pResponseHandler == 0  || QueryLanguage == NULL || Query == NULL) 
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryLanguage, Query, lFlags, 
						pResponseHandler, WBEM_METHOD_ExecNotificationQueryAsync,
						(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, TRUE);
	
    return CallAndCleanupAsync(opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecQuery
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::ExecQuery.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecQuery(
                        BSTR QueryFormat,
                        BSTR Query,
                        long lFlags,
						IWbemContext *pCtx, 
                        IEnumWbemClassObject FAR* FAR* ppEnum) 
{
    if (NULL == ppEnum)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryFormat, Query, lFlags, NULL,
				WBEM_METHOD_ExecQuery, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
	return CallAndCleanup (ENUMERATOR, (PPVOID)ppEnum, opn);
}


//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecQueryAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::ExecQueryAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecQueryAsync(
                        BSTR QueryFormat,
                        BSTR Query,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler) 
{
    if (pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryFormat, Query, lFlags, 
						pHandler, WBEM_METHOD_ExecQueryAsync,
						(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, TRUE);
	return CallAndCleanupAsync(opn, pHandler);
}


//***************************************************************************
//
//  SCODE CProvProxy_LPipe::GetObject
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::GetObject.  
//  See WBEMSVC.HLP for details
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::GetObject(
                        BSTR ObjectPath,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemClassObject FAR* FAR* ppObj, 
                        IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetObject opn (ObjectPath, lFlags, ppObj, NULL,
				(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::GetObjectAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::GetObjectAsync.  
//  See WBEMSVC.HLP for details
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::GetObjectAsync (
                        BSTR ObjectPath,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler)
{
    if(pHandler == 0) // a-levn
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetObject opn (ObjectPath, lFlags, NULL, 
				pHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::OpenNamespace
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::OpenNamespace.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::OpenNamespace(
                        BSTR ObjectPath,
                        long lFlags,
						IWbemContext *pCtx,
                        IWbemServices FAR* FAR* ppNewContext,
						IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);

	// Exactly one of ppNewContext and ppresult must be non-NULL
    if (((NULL == ppNewContext) && (NULL == ppResult)) ||
		((NULL != ppNewContext) && (NULL != ppResult)))
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_OpenNamespace opn (ObjectPath, lFlags, 
				(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
    return CallAndCleanup(PROVIDER, (PPVOID)ppNewContext, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutClass
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutClass.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutClass(
                        IWbemClassObject FAR* pObj,
                        long lFlags, 
						IWbemContext *pCtx,
						IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);
    if (pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pObj, lFlags, WBEM_METHOD_PutClass,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
    return CallAndCleanup(NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutClassAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutClassAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutClassAsync(
                        IWbemClassObject FAR* pObject,
                        long lFlags, 
 						IWbemContext *pCtx,
						IWbemObjectSink *pResponseHandler)
{
    if (pObject == 0 || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pObject, lFlags, WBEM_METHOD_PutClassAsync,
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
    return CallAndCleanupAsync (opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutInstance
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutInstance.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutInstance(
                        IWbemClassObject FAR* pInst,
                        long lFlags, 
                        IWbemContext *pCtx,
						IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult); 
    if (NULL == pInst)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pInst, lFlags, WBEM_METHOD_PutInstance,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
    return CallAndCleanup(NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutInstanceAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutInstanceAsync(
                        IWbemClassObject FAR* pInst,
                        long lFlags,
                        IWbemContext *pCtx,						
                        IWbemObjectSink FAR* pResponseHandler)
{
    if ((NULL == pInst) || (NULL == pResponseHandler))
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pInst, lFlags, WBEM_METHOD_PutInstanceAsync,
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
    return CallAndCleanupAsync (opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::QueryObjectSink
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::QueryObjectSink.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::QueryObjectSink(
						long lFlags,
                        IWbemObjectSink FAR* FAR* ppHandler)
{
    if (ppHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_QueryObjectSink opn (lFlags, (CStubAddress_WinMgmt &) GetStubAdd ());
    return CallAndCleanup(OBJECTSINK, (PPVOID)ppHandler, opn);
}

//***************************************************************************
//
//  HRESULT CProvProxy_LPipe::ExecMethod
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::QueryObjectSink.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

HRESULT CProvProxy_LPipe::ExecMethod( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
    if (ObjectPath == 0 || MethodName == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_ExecMethod opn (ObjectPath, MethodName, lFlags, pInParams,
				ppOutParams, NULL, (CStubAddress_WinMgmt &) GetStubAdd (), 
				pCtx, ppCallResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  HRESULT CProvProxy_LPipe::ExecMethodAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::QueryObjectSink.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

HRESULT CProvProxy_LPipe::ExecMethodAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    if (ObjectPath == 0 || MethodName == NULL || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_ExecMethod opn (ObjectPath, MethodName, lFlags, pInParams,
			NULL, pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
	
    return CallAndCleanupAsync(opn, pResponseHandler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\provprxh.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVPRXH.CPP

Abstract:

  Defines the CProvProxy_Hmmp class

History:

  alanbos  06-Jan-97   Created.

--*/

#include "precomp.h"

CProvProxy* CProvProxy_Hmmp::GetProvProxy (IStubAddress& dwAddr)
{
	return new CProvProxy_Hmmp (m_pComLink, dwAddr);
}

CEnumProxy* CProvProxy_Hmmp::GetEnumProxy (IStubAddress& dwAddr)
{
	return new CEnumProxy_Hmmp (m_pComLink, dwAddr);
}

CResProxy* CProvProxy_Hmmp::GetResProxy (IStubAddress& dwAddr)
{
	return new CResProxy_Hmmp (m_pComLink, dwAddr);
}

CObjectSinkProxy* CProvProxy_Hmmp::GetSinkProxy (IStubAddress& dwAddr)
{
	return new CObjectSinkProxy_Hmmp (m_pComLink, dwAddr);
}

void CProvProxy_Hmmp::ReleaseProxy ()
{
}

//***************************************************************************
//
//  SCODE CProvProxy_Hmmp::CancelAsyncCall
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CancelAsyncCall.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//***************************************************************************

SCODE CProvProxy_Hmmp::CancelAsyncCall(
                        IWbemObjectSink __RPC_FAR *pSink)
{
    if (NULL == pSink)
		return WBEM_E_INVALID_PARAMETER;
                 
	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;

	// TODO - 
	//	1.	Find original async operation(s) which were passed pSink
	//		and remove them from ComLink response queue.
	//	2.	If ExecNotificationQuery operation to be cancelled, this
	//		must be mapped to a real HMMP operation.

	return WBEM_E_FAILED;
}

//***************************************************************************
//
//  SCODE CProvProxy_Hmmp::CreateClassEnum
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateClassEnum.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_Hmmp::CreateClassEnum(
                        const BSTR Parent,
                        long lFlags,
                        IWbemContext *pCtx, 
						IEnumWbemClassObject **ppEnum)
{
    if (ppEnum == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_Hmmp_CreateEnum opn (Parent, lFlags, WBEM_METHOD_CreateClassEnum,
							NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
    return CallAndCleanup(ENUMERATOR, (PPVOID)ppEnum, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CreateClassEnumAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateClassEnumAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::CreateClassEnumAsync(
                        const BSTR RefClass,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler)
{
    if (NULL == pHandler)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_CreateEnum opn 
							(RefClass, lFlags, WBEM_METHOD_CreateClassEnumAsync,
							 pHandler, (CStubAddress_WinMgmt &) GetStubAdd (), 
							 pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pHandler);
}
                
//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CreateInstanceEnum
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateInstanceEnum.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::CreateInstanceEnum(
                        const BSTR Class,
                        long lFlags,
						IWbemContext *pCtx,
                        IEnumWbemClassObject FAR* FAR* ppEnum)
{
    if(NULL == ppEnum || NULL == Class) // a-levn
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_CreateEnum opn (Class, lFlags, WBEM_METHOD_CreateInstanceEnum, 
							NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);

    return CallAndCleanup(ENUMERATOR, (PPVOID)ppEnum, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::CreateInstanceEnumAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::CreateInstanceEnumAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::CreateInstanceEnumAsync(
                        const BSTR Class,
                        long lFlags, IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler)
{
    if(NULL == pHandler || NULL == Class) // a-levn
        return WBEM_E_INVALID_PARAMETER;

   	CProxyOperation_LPipe_CreateEnum opn 
							(Class, lFlags, WBEM_METHOD_CreateInstanceEnumAsync,
							 pHandler, (CStubAddress_WinMgmt &) GetStubAdd (), 
							 pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pHandler);
}


//***************************************************************************
//
//  SCODE CProvProxy_Hmmp::DeleteClass
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteClass.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_Hmmp::DeleteClass(
                        const BSTR Class,
                        long lFlags,
                        IWbemContext *pCtx, IWbemCallResult **ppResult)
{
	INIT_RES_OBJ(ppResult);

	if (NULL == Class) 
		return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_Hmmp_Delete opn (Class, lFlags, WBEM_METHOD_DeleteClass,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::DeleteClassAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteClassAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::DeleteClassAsync(
                        const BSTR Class,
                        long lFlags, IWbemContext *pCtx,  
                        IWbemObjectSink FAR* pResponseHandler)
{
    if (NULL == Class || NULL == pResponseHandler)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink) 
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Delete opn (Class, lFlags, WBEM_METHOD_DeleteClassAsync, 
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), 
					pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::DeleteInstance
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstance.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::DeleteInstance(
                        const BSTR ObjectPath,
                        long lFlags, 
                        IWbemContext *pCtx, IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);

    if (NULL == ObjectPath) // a-levn
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_Delete opn (ObjectPath, lFlags, WBEM_METHOD_DeleteInstance,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::DeleteInstanceAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::DeleteInstanceAsync(
                        const BSTR ObjectPath,
                        long lFlags, IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pResponseHandler)
{
    if (ObjectPath == 0 || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Delete opn (ObjectPath, lFlags, WBEM_METHOD_DeleteInstanceAsync, 
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), 
					pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecNotificationQuery
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
    if(ppEnum == NULL || QueryLanguage == NULL || Query == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryLanguage, Query, lFlags, NULL,
						WBEM_METHOD_ExecNotificationQuery, 
						(CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
	return CallAndCleanup (ENUMERATOR, (PPVOID)ppEnum, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecNotificationQueryAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::DeleteInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    if(pResponseHandler == 0  || QueryLanguage == NULL || Query == NULL) 
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryLanguage, Query, lFlags, 
						pResponseHandler, WBEM_METHOD_ExecNotificationQueryAsync,
						(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, TRUE);
	
    return CallAndCleanupAsync(opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecQuery
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::ExecQuery.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecQuery(
                        const BSTR QueryFormat,
                        const BSTR Query,
                        long lFlags,
						IWbemContext *pCtx, 
                        IEnumWbemClassObject FAR* FAR* ppEnum) 
{
    if (NULL == ppEnum)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryFormat, Query, lFlags, NULL,
				WBEM_METHOD_ExecQuery, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx);
	return CallAndCleanup (ENUMERATOR, (PPVOID)ppEnum, opn);
}


//***************************************************************************
//
//  SCODE CProvProxy_LPipe::ExecQueryAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::ExecQueryAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::ExecQueryAsync(
                        const BSTR QueryFormat,
                        const BSTR Query,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler) 
{
    if (pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_ExecQuery opn (QueryFormat, Query, lFlags, 
						pHandler, WBEM_METHOD_ExecQueryAsync,
						(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, TRUE);
	return CallAndCleanupAsync(opn, pHandler);
}


//***************************************************************************
//
//  SCODE CProvProxy_LPipe::GetObject
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::GetObject.  
//  See WBEMSVC.HLP for details
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::GetObject(
                        const BSTR ObjectPath,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemClassObject FAR* FAR* ppObj, 
                        IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetObject opn (ObjectPath, lFlags, ppObj, NULL,
				(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::GetObjectAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::GetObjectAsync.  
//  See WBEMSVC.HLP for details
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::GetObjectAsync (
                        const BSTR ObjectPath,
                        long lFlags, 
						IWbemContext *pCtx, 
                        IWbemObjectSink FAR* pHandler)
{
    if(pHandler == 0) // a-levn
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetObject opn (ObjectPath, lFlags, NULL, 
				pHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
    return CallAndCleanupAsync(opn, pHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::OpenNamespace
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::OpenNamespace.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::OpenNamespace(
                        const BSTR ObjectPath,
                        long lFlags,
						IWbemContext *pCtx,
                        IWbemServices FAR* FAR* ppNewContext,
						IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);
    if (ppNewContext == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_OpenNamespace opn (ObjectPath, lFlags, 
		(CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
    return CallAndCleanup(PROVIDER, (PPVOID)ppNewContext, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutClass
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutClass.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutClass(
                        IWbemClassObject FAR* pObj,
                        long lFlags, 
						IWbemContext *pCtx,
						IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult);
    if (pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pObj, lFlags, WBEM_METHOD_PutClass,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
    return CallAndCleanup(NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutClassAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutClassAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutClassAsync(
                        IWbemClassObject FAR* pObject,
                        long lFlags, 
 						IWbemContext *pCtx,
						IWbemObjectSink *pResponseHandler)
{
    if (pObject == 0 || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pObject, lFlags, WBEM_METHOD_PutClassAsync,
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), 
					pCtx, NULL, TRUE);
    return CallAndCleanupAsync (opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutInstance
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutInstance.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutInstance(
                        IWbemClassObject FAR* pInst,
                        long lFlags, 
                        IWbemContext *pCtx,
						IWbemCallResult **ppResult)
{
    INIT_RES_OBJ(ppResult); 
    if (NULL == pInst)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pInst, lFlags, WBEM_METHOD_PutInstance,
						NULL, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, ppResult);
    return CallAndCleanup(NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::PutInstanceAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::PutInstanceAsync.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::PutInstanceAsync(
                        IWbemClassObject FAR* pInst,
                        long lFlags,
                        IWbemContext *pCtx,						
                        IWbemObjectSink FAR* pResponseHandler)
{
    if ((NULL == pInst) || (NULL == pResponseHandler))
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_Put opn (pInst, lFlags, WBEM_METHOD_PutInstanceAsync,
					pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), 
					pCtx, NULL, TRUE);
    return CallAndCleanupAsync (opn, pResponseHandler);
}

//***************************************************************************
//
//  SCODE CProvProxy_LPipe::QueryObjectSink
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::QueryObjectSink.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

SCODE CProvProxy_LPipe::QueryObjectSink(
						long lFlags,
                        IWbemObjectSink FAR* FAR* ppHandler)
{
    if (ppHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_QueryObjectSink opn (lFlags, 
						(CStubAddress_WinMgmt &) GetStubAdd ());
    return CallAndCleanup(OBJECTSINK, (PPVOID)ppHandler, opn);
}

//***************************************************************************
//
//  HRESULT CProvProxy_LPipe::ExecMethod
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::QueryObjectSink.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

HRESULT CProvProxy_LPipe::ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
    if (ObjectPath == 0 || MethodName == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_ExecMethod opn (ObjectPath, MethodName, lFlags, pInParams,
				ppOutParams, NULL, (CStubAddress_WinMgmt &) GetStubAdd (), 
				pCtx, ppCallResult);
	return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  HRESULT CProvProxy_LPipe::ExecMethodAsync
//
//  DESCRIPTION:
//
//  Proxy for IWbemServices::QueryObjectSink.  
//  See WBEMSVC.HLP for details
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  or Set by ProxyCall()
//  
//***************************************************************************

HRESULT CProvProxy_LPipe::ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    if (ObjectPath == 0 || MethodName == NULL || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_ExecMethod opn (ObjectPath, MethodName, lFlags, pInParams,
			NULL, pResponseHandler, (CStubAddress_WinMgmt &) GetStubAdd (), pCtx, NULL, TRUE);
	
    return CallAndCleanupAsync(opn, pResponseHandler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\resprox.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    RESPROX.CPP

Abstract:

  Defines the CResProxy object

History:

  a-davj  27-June-97   Created.

--*/

#include "precomp.h"

CProvProxy* CResProxy_LPipe::GetProvProxy (IStubAddress& dwAddr)
{
	return new CProvProxy_LPipe (m_pComLink, dwAddr);
}

//***************************************************************************
//
//  CResProxy::CResProxy
//
//  DESCRIPTION:
//
//  Constructor
//
//  PARAMETERS:
//
//  pComLink            Comlink used to set calls to stub
//  stubAddr          remote stub
//
//***************************************************************************

CResProxy::CResProxy(
                        IN CComLink * pComLink,
                        IN IStubAddress& stubAddr) 
                        : CProxy(pComLink, stubAddr)
{
    m_cRef = 0;

	/*
	 * Aggregate the free-threaded marshaler for cheap in-proc
	 * threading as we are thread-safe.  
	 */
	HRESULT hRes = CoCreateFreeThreadedMarshaler ((IUnknown *) this, &m_pUnkInner);

    ObjectCreated(OBJECT_TYPE_RESPROXY);
    return;
}

//***************************************************************************
//
//  CResProxy::~CResProxy
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CResProxy::~CResProxy(void)
{
    ObjectDestroyed(OBJECT_TYPE_RESPROXY);
    return;
}

//***************************************************************************
// HRESULT CResProxy::QueryInterface
// long CResProxy::AddRef
// long CResProxy::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CResProxy::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;

	// Delegate queries for IMarshal to the aggregated
	// free-threaded marshaler
	if (IID_IMarshal==riid && m_pUnkInner)
		return m_pUnkInner->QueryInterface (riid, ppv);

    if ((IID_IUnknown==riid || IID_IWbemCallResult == riid) &&
            m_pComLink != NULL && GetStubAdd ().IsValid () && ppv)
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CResProxy::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CResProxy::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    // refernce count is zero, delete this object and the remote object
	ReleaseProxy ();
    
	m_cRef++;	// Artificial reference count to prevent re-entrancy
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\resproxp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    RESPROXP.CPP

Abstract:

  Defines the CResProxy_LPipe object

History:

  a-davj  27-June-97   Created.

--*/

#include "precomp.h"

void CResProxy_LPipe::ReleaseProxy ()
{
	if (NULL == m_pComLink)
		return;

	CProxyOperation_LPipe_Release opn ((CStubAddress_WinMgmt &) GetStubAdd (), CALLRESULT);
    CallAndCleanup (NONE, NULL, opn);
}


SCODE CResProxy_LPipe::GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppStatusObject)
{
    if(NULL == ppStatusObject)
        return WBEM_E_INVALID_PARAMETER;
    *ppStatusObject = 0;        // to be set later.

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetResultObject opn (lTimeout, ppStatusObject, 
					(CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}
        
SCODE CResProxy_LPipe::GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString)
{
    if(NULL == pstrResultString)
        return WBEM_E_INVALID_PARAMETER;

    *pstrResultString = 0;        // to be set later.

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetResultString opn (lTimeout, pstrResultString, 
				(CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}


SCODE CResProxy_LPipe::GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus)
{
    if(NULL == plStatus)
        return WBEM_E_INVALID_PARAMETER;

    *plStatus = 0;        // to be set later.

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetCallStatus opn (lTimeout, plStatus, 
			(CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (NONE, NULL, opn);
}

SCODE CResProxy_LPipe::GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices)
{

    if (NULL == ppServices)
        return WBEM_E_INVALID_PARAMETER;

    *ppServices = 0;        // to be set later.

	if (NULL == m_pComLink)
		return WBEM_E_TRANSPORT_FAILURE;

	CProxyOperation_LPipe_GetResultServices opn (lTimeout, 
			(CStubAddress_WinMgmt &) GetStubAdd ());
	return CallAndCleanup (PROVIDER, (PPVOID)ppServices, opn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\wbemprox.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WBEMPROX.H

Abstract:

	Genral purpose include file.

History:

  a-davj  04-Mar-97   Created.

--*/

#ifndef _WBEMPROX_H_
#define _WBEMPROX_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

extern CRITICAL_SECTION g_GlobalCriticalSection ;


// These define objects in addition to the object types defined in
// WBEM.  The first group, upto but NOT including comlink, are Ole
// objects and the second group has object types that are tracked
// just for keeping track of leaks

enum {  OBJECT_TYPE_COMLINK = MAX_OBJECT_TYPES, OBJECT_TYPE_CSTUB, OBJECT_TYPE_RQUEUE, 
	OBJECT_TYPE_PACKET_HEADER,
	OBJECT_TYPE_LOGINPROXY, OBJECT_TYPE_OBJSINKPROXY,OBJECT_TYPE_PROVPROXY, 
	OBJECT_TYPE_ENUMPROXY, OBJECT_TYPE_LOGIN, OBJECT_TYPE_SECHELP, OBJECT_TYPE_RESPROXY, TCPIPADDR, MAX_CLIENT_OBJECT_TYPES};

enum TransportType 
{
	TcpipTransport ,
	PipeTransport 
} ;

//***************************************************************************
//
//  CLASS NAME:
//
//  CLogin
//
//  DESCRIPTION:
//
//  A wrapper for the IWbemLevel1Login interface.  
//
//***************************************************************************

class CLogin: public IUnknown
{
protected:

		DWORD m_AddressLength ; 
		BYTE *m_Address ;

        long        m_cRef;				// Object reference count
		IServerLogin * m_pLogin;	// The "real" login interface (proxied)
		SCODE MakeSureWeHaveAPointer();
		DWORD m_dwType;
		TransportType m_TransportType ;			

public:

        CLogin ( 

			TransportType a_TransportType = PipeTransport , 
			IN DWORD dwBinaryAddressLength = 0 ,
			IN BYTE __RPC_FAR *pbBinaryAddress = NULL 
		);

        ~CLogin(void);
		DWORD GetType(void){return m_dwType;};

        //Non-delegating object IUnknown
      
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		// Methods of IWbemLevel1Login
		STDMETHODIMP RequestChallenge(
   			LPWSTR pNetworkResource,
			LPWSTR pUser,
			WBEM_128BITS Nonce
        );

		STDMETHODIMP EstablishPosition(
			LPWSTR wszClientMachineName,
			DWORD dwProcessId,
			DWORD* phAuthEventHandle
		);

		STDMETHODIMP WBEMLogin(
			LPWSTR pPreferredLocale,
			WBEM_128BITS AccessToken,
			long lFlags,                                  // WBEM_LOGIN_TYPE
			IWbemContext *pCtx,              
			IWbemServices **ppNamespace
        );

		// Methods for NTLM authentication
        STDMETHODIMP SspiPreLogin(
            LPSTR pszSSPIPkg,
            long lFlags,
            long lBufSize,
            byte __RPC_FAR *pInToken,
            long lOutBufSize,
            long __RPC_FAR *plOutBufBytes,
            byte __RPC_FAR *pOutToken,
			LPWSTR wszClientMachineName,
            DWORD dwProcessId,
            DWORD __RPC_FAR *pAuthEventHandle);  
                        
        STDMETHODIMP Login( 
			LPWSTR pNetworkResource,
			LPWSTR pPreferredLocale,
            WBEM_128BITS AccessToken,
            IN LONG lFlags,
            IWbemContext  *pCtx,
            IN OUT IWbemServices  **ppNamespace);
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CLocatorFactory
//
//  DESCRIPTION:
//
//  Class factory for the CLocator class.
//
//***************************************************************************

class CLocatorFactory : public IClassFactory
{
protected:

	long           m_cRef;
    int            m_iType;

public:

    CLocatorFactory(int iType);
    ~CLocatorFactory(void);
    
    enum { PIPELOCATOR , TCPIPLOCATOR , TCPIPADDRESSRESOLVER , HELP , LOGIN };


        //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
	STDMETHODIMP         LockServer(BOOL);

};

SCODE RequestLogin ( 

	OUT IServerLogin FAR* FAR* ppLogin,
	OUT DWORD & dwType, 
	IN TransportType a_TransportType ,
	IN DWORD dwBinaryAddressLength = 0 ,
	IN BYTE *pbBinaryAddress = NULL 
);
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\backuprestore.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    BackupRestore.H

Abstract:

    Backup Restore Interface.

History:

--*/

class CWbemBackupRestore : IWbemBackupRestore
{
    protected:
		TCHAR *m_pDbDir;
		TCHAR *m_pWorkDir;
        long           m_cRef; 
        HINSTANCE m_hInstance;
    public:
        CWbemBackupRestore(HINSTANCE hInstance);

        ~CWbemBackupRestore(void)
		{
			delete [] m_pDbDir;
			delete [] m_pWorkDir;
		}

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv)
		{
			*ppv=NULL;

			if (IID_IUnknown==riid || IID_IWbemBackupRestore==riid)
				*ppv=this;

			if (NULL!=*ppv)
			{
				AddRef();
				return NOERROR;
			}

			return E_NOINTERFACE;
		};

        STDMETHODIMP_(ULONG) AddRef(void)
		{    
			return ++m_cRef;
		};
        STDMETHODIMP_(ULONG) Release(void)
		{
			long lRef = InterlockedDecrement(&m_cRef);
			if (0L == lRef)
				delete this;
			return lRef;
		};

		HRESULT STDMETHODCALLTYPE Backup(
			LPCWSTR   strBackupToFile,
			long   lFlags);
		
		HRESULT STDMETHODCALLTYPE Restore(
			LPCWSTR   strRestoreFromFile,
			long   lFlags);


        void InitEmpty(){};
		TCHAR *GetDbDir();
		TCHAR *GetFullFilename(const TCHAR *pszFilename);
		TCHAR *GetExePath(const TCHAR *pszFilename);
		HRESULT GetDefaultRepDriverClsId(CLSID &clsid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\cntserv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CNTSERV.H

Abstract:

    A class which allows easy creation of Win32 Services.   This class
    only allows one service per .EXE file.  The process can be run as a
    service or a regular non-service EXE, a runtime option.

    This class is largly based on the SMS CService class which was created by
    a-raymcc.  This differs in that it is simplified in two ways; First, it 
    does not keep track of the worker threads since that is the responsibility
    of the derived code, and second, it doesnt use some SMS specific diagnostics

    NOTE: See the file SERVICE.TXT for details on how to use this class.
    There are a number of issues which cannot be conveyed by simply studying
    the class declaration.

History:

  a-davj      20-June-96  Created.

--*/

#ifndef _CNTSERV_H_
#define _CNTSERV_H_

#define DEFAULT_WAIT_HINT 30000


//******************************************************************************
//
//  See SERVICE.TXT for documentation
//
//******************************************************************************
class CNtService {
public: 

    CNtService();
    ~CNtService();

    // Starts up the service.  This must be called to start the service.
    //==================================================================

    DWORD Run(LPCTSTR pszServiceName, BOOL bRunAsService, BOOL bDieImmediately=FALSE);

    // This MUST be overridden since this is where the actual work is done
    //====================================================================

    virtual DWORD WorkerThread() = 0;

    // This MUST be overridden to signal the worker thread to exit its routine
    //=========================================================================

    virtual void Stop() = 0;

    // If there is some lengthy initialization, it should be done by 
    // overriding this routine.
    //===============================================================

    BOOL Initialize(DWORD dwArgc, LPTSTR *lpszArgv){return TRUE;};

    // These routines are optional and should be overridden if the features
    // are desired.  Note that supporting Pause and Continue also require a
    // call to SetPauseContinue()
    //=====================================================================

    virtual void Pause(){return;};
    virtual void Continue(){return;};
    virtual void UserCode(int nCode){return;};    // 127 .. 255

    // dumps messages to the event log.  Can be overriden if there is 
    // another diagnostic in place.
    //===============================================================

    virtual VOID Log(LPCTSTR lpszMsg);

    // Determines if Pause and Continue codes are accepted. Default is to
    // not accept them.  If they are to be handled, then the Pause and 
    // Continue routines must be overridden.
    //===================================================================

    void SetPauseContinue(BOOL bAccepted);
    BOOL GetPauseContinue(){return m_dwCtrlAccepted;};

    //returns if the current application is running as a service
    static DWORD IsRunningAsService(BOOL &bIsService);


private:
    static CNtService * pThis;
    BOOL m_bStarted;
    BOOL m_bRunAsService;
    BOOL m_bDieImmediately;
    TCHAR * m_pszServiceName;
    DWORD m_dwCtrlAccepted;
    SERVICE_STATUS          ssStatus;       // current status of the service
    SERVICE_STATUS_HANDLE   sshStatusHandle;

    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);
    static void WINAPI _Handler(DWORD dwControlCode);
    void ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);
    void Handler(DWORD dwControlCode);
protected:
    // this might come in handy if the derived class needs to communicate
    // with the SCM.
    //===================================================================

    BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
         DWORD dwWin32ExitCode, DWORD dwCheckPoint, DWORD dwWaitHint);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\backuprestore.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    BackupRestore.CPP

Abstract:

    Backup Restore Interface.

History:

  paulall       08-Feb-99   Implemented the call-outs to do the backup
                            and recovery.  Stole lots of code from the core
                            to get this working!

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemint.h>
#include <cominit.h>
#include <genutils.h>
#include <reposit.h>
#include "wbemcomn.h"
#include "MRCIClass.h"
#include "CoreX.h"
#include "Reg.h"
#include "BackupRestore.h"

BOOL CheckSecurity(LPCTSTR pPriv)
{
    WbemCoImpersonateClient();
    HANDLE hToken;
    BOOL bRet = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
    WbemCoRevertToSelf();
    if(!bRet)
        return FALSE;
    bRet = IsPrivilegePresent(hToken, pPriv);
    CloseHandle(hToken);
    return bRet;
}

CWbemBackupRestore::CWbemBackupRestore(HINSTANCE hInstance) : m_pDbDir(0), 
                                            m_pWorkDir(0), m_hInstance(hInstance)
{
    m_cRef=0L;
};


TCHAR *CWbemBackupRestore::GetDbDir()
{
    if (m_pDbDir == NULL)
    {
        if (m_pWorkDir == NULL)
        {
            Registry r1(WBEM_REG_WBEM);
            if (r1.GetStr(__TEXT("Installation Directory"), &m_pWorkDir))
            {
                ERRORTRACE((LOG_WBEMCORE,"Unable to read 'Installation Directory' from registry\n"));
                return NULL;
            }
        }
        Registry r(WBEM_REG_WINMGMT);
        if (r.GetStr(__TEXT("Repository Directory"), &m_pDbDir))
        {
            m_pDbDir = new TCHAR [lstrlen(m_pWorkDir) + lstrlen(__TEXT("\\Repository")) +1];
            wsprintf(m_pDbDir, __TEXT("%s\\REPOSITORY"), m_pWorkDir); 

            r.SetStr(__TEXT("Repository Directory"), m_pDbDir);
        }        
    }
    return m_pDbDir;
}

TCHAR *CWbemBackupRestore::GetFullFilename(const TCHAR *pszFilename)
{
    const TCHAR *pszDirectory = GetDbDir();
    TCHAR *pszPathFilename = new TCHAR[lstrlen(pszDirectory) + lstrlen(pszFilename) + 2];
    if (pszPathFilename == 0)
        return 0;
    lstrcpy(pszPathFilename, pszDirectory);
    if ((lstrlen(pszPathFilename)) && (pszPathFilename[lstrlen(pszPathFilename)-1] != '\\'))
    {
        lstrcat(pszPathFilename, __TEXT("\\"));
    }
    lstrcat(pszPathFilename, pszFilename);

    return pszPathFilename;
}
TCHAR *CWbemBackupRestore::GetExePath(const TCHAR *pszFilename)
{
    TCHAR *pszPathFilename = new TCHAR[lstrlen(m_pWorkDir) + lstrlen(pszFilename) + 2];
    if (pszPathFilename == 0)
        return 0;
    lstrcpy(pszPathFilename, m_pWorkDir);
    lstrcat(pszPathFilename, __TEXT("\\"));
    lstrcat(pszPathFilename, pszFilename);

    return pszPathFilename;
}

HRESULT CWbemBackupRestore::GetDefaultRepDriverClsId(CLSID &clsid)
{
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pClsIdStr = 0;
    TCHAR *pFSClsId = __TEXT("{7998dc37-d3fe-487c-a60a-7701fcc70cc6}");
    HRESULT hRes;
    wchar_t Buf[128];

    if (r.GetStr(__TEXT("Default Repository Driver"), &pClsIdStr))
    {
        // If here, default to FS for now.
        // =====================================
        r.SetStr(__TEXT("Default Repository Driver"), pFSClsId);
        swprintf(Buf, L"%S", pFSClsId);
        hRes = CLSIDFromString(Buf, &clsid);
        return hRes;
    }

    // If here, we actually retrieved one.
    // ===================================
    swprintf(Buf, L"%S", pClsIdStr);
    hRes = CLSIDFromString(Buf, &clsid);
    delete [] pClsIdStr;
    return hRes;
}


//***************************************************************************
//
//  CWbemBackupRestore::Backup()
//
//  Do the backup.
//
//***************************************************************************
HRESULT CWbemBackupRestore::Backup(LPCWSTR strBackupToFile, long lFlags)
{
    try
    {
		// !!!!! ***** temporarily disabled until SVCHOST changes are checked in ***** !!!!!
		return WBEM_E_NOT_SUPPORTED;



        // Check security
		EnableAllPrivileges(TOKEN_PROCESS);
        if(!CheckSecurity(SE_BACKUP_NAME))
            return WBEM_E_ACCESS_DENIED;

        // Check the params
        if (NULL == strBackupToFile || (lFlags != 0))
            return WBEM_E_INVALID_PARAMETER;

        // Use GetFileAttributes to validate the path.
		DWORD dwAttributes = GetFileAttributesW(strBackupToFile);
        if (dwAttributes == 0xFFFFFFFF)
        {
			// It failed -- check for a no such file error (in which case, we're ok).
            if (ERROR_FILE_NOT_FOUND != GetLastError())
            {
                return WBEM_E_INVALID_PARAMETER;
            }
        }
		else
		{
			// The file already exists -- create mask of the attributes that would make an existing file invalid for use
			DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
							FILE_ATTRIBUTE_DIRECTORY |
							FILE_ATTRIBUTE_OFFLINE |
							FILE_ATTRIBUTE_READONLY |
							FILE_ATTRIBUTE_REPARSE_POINT |
							FILE_ATTRIBUTE_SPARSE_FILE |
							FILE_ATTRIBUTE_SYSTEM |
							FILE_ATTRIBUTE_TEMPORARY;

			if (dwAttributes & dwMask)
				return WBEM_E_INVALID_PARAMETER;
		}

		// Retrieve the CLSID of the default repository driver
		CLSID clsid;
		HRESULT hRes = GetDefaultRepDriverClsId(clsid);
		if (FAILED(hRes))
			return hRes;

		// Call IWmiDbController to do backup
		IWmiDbController* pController = NULL;
        _IWmiCoreServices *pCoreServices = NULL;
		int nRet = WBEM_NO_ERROR;
        IWbemServices *pServices = NULL;

        //Make sure the core is initialized...
        hRes = CoCreateInstance(CLSID_IWmiCoreServices, NULL,
                    CLSCTX_INPROC_SERVER, IID__IWmiCoreServices,
                    (void**)&pCoreServices);
        CReleaseMe rm1(pCoreServices);

        if (SUCCEEDED(hRes))
        {
            hRes = pCoreServices->GetServices(L"root", NULL,NULL,0, IID_IWbemServices, (LPVOID*)&pServices);
        }
        CReleaseMe rm2(pServices);

        if (SUCCEEDED(hRes))
        {
            hRes = CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER, IID_IWmiDbController, (LPVOID *) &pController);
        }
        CReleaseMe rm3(pController);

		if (SUCCEEDED(hRes))
		{
			hRes = pController->Backup(strBackupToFile, lFlags);

			if (FAILED(hRes))
			{
				nRet = WBEM_E_FAILED;
			}
		}
		return nRet;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

//***************************************************************************
//
//  CWbemBackupRestore::Restore()
//
//  Do the restore.
//
//***************************************************************************
HRESULT CWbemBackupRestore::Restore(LPCWSTR strRestoreFromFile, long lFlags)
{
	// !!!!! ***** temporarily disabled until SVCHOST changes are checked in ***** !!!!!
	return WBEM_E_NOT_SUPPORTED;


    // Check security
	EnableAllPrivileges(TOKEN_PROCESS);
	if(!CheckSecurity(SE_RESTORE_NAME))
		return WBEM_E_ACCESS_DENIED;

    if(strRestoreFromFile == NULL || (lFlags & ~WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN))
        return WBEM_E_INVALID_PARAMETER;

	PROCESS_INFORMATION pi;
	STARTUPINFOW si;
	memset(&si, 0, sizeof(si));
	si.cb = sizeof(si);

    wchar_t wcBuff[MAX_PATH+1];
    wsprintfW(wcBuff, L"WinMgmt.exe /restore \"%s\" %d",strRestoreFromFile, lFlags);  
	if (CreateProcessW(NULL, wcBuff, 0, 0, FALSE, CREATE_BREAKAWAY_FROM_JOB|DETACHED_PROCESS|CREATE_NO_WINDOW, 0, 0, &si, &pi) == 0)
	{
		return WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING;						
	}
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\cntserv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CNTSERV.CPP

Abstract:

    A class which allows easy creation of Win32 Services.   This class
    only allows one service per .EXE file.  The process can be run as a
    service or a regular non-service EXE, a runtime option.

    This class is largly based on the SMS CService class which was created by
    a-raymcc.  This differs in that it is simplified in two ways; First, it 
    does not keep track of the worker threads since that is the responsibility
    of the derived code, and second, it doesnt use some SMS specific diagnostics

    NOTE: See the file SERVICE.TXT for details on how to use this class.
    There are a number of issues which cannot be conveyed by simply studying
    the class declaration.

History:

  a-davj      20-June-96  Created.

--*/

#include "precomp.h"
#include <wtypes.h>
#include <stdio.h>
#include "cntserv.h"

//****************************************************************************
//
// This pointer is set to the single CNtService object which is supported.
// This allows the Win32 entry points to immediately enter a member function.
//
//****************************************************************************

CNtService *CNtService::pThis = NULL;

//****************************************************************************
//
//  CNtService::CNtService
//  CNtService::~CNtService
//
//  Constructor and destructor.
//
//****************************************************************************

CNtService::CNtService()
{
    pThis = this;
    m_dwCtrlAccepted = 0;
    m_bStarted = FALSE;
    m_bRunAsService = FALSE;
    m_bDieImmediately = FALSE;
    m_pszServiceName = NULL;
}

CNtService::~CNtService()
{
    if(m_pszServiceName)
        delete m_pszServiceName;
}
//****************************************************************************
//
//  CNtService::Run
//
//  Starts the service as either a service, or as an executable.
//
//  Parameters:
//      LPCTSTR pszServiceName          Name of the service.
//      BOOL bRunAsService              TRUE=run as service, FALSE=console app
//      BOOL bDieImmeiately             TRUE if this service should immediately die
//****************************************************************************

DWORD CNtService::Run(LPCTSTR pszServiceName, BOOL bRunAsService, 
                BOOL bDieImmediately)
{
    m_bDieImmediately = bDieImmediately;
    m_bRunAsService = bRunAsService;
    if(!bRunAsService)
        WorkerThread();
    else
    {

        // Make a copy that is not constant and that can be kept
        // around for diagnostics.
        // =====================================================

        m_pszServiceName = new TCHAR[lstrlen(pszServiceName)+1];
        if(m_pszServiceName == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        lstrcpy(m_pszServiceName,pszServiceName);

        SERVICE_TABLE_ENTRY dispatchTable[] = {
            { m_pszServiceName, 
                (LPSERVICE_MAIN_FUNCTION) CNtService::_ServiceMain },
            { NULL, NULL }
        };

        // The next call start the service and will result in a call back to
        // the _ServiceMain function.
        //===================================================================

        if(!StartServiceCtrlDispatcher(dispatchTable))
        {
            Log(TEXT("StartServiceCtrlDispatcher failed."));
            return GetLastError();
        }
    }         
    return 0l;
}

//****************************************************************************
//
//  CNtService::SetPauseContinue
//
//  Allows or disallows Pause and Continue commands.
//
//  Parameters:
//      BOOL bAccepted                  TRUE = we do handle pause and continue
//****************************************************************************

void CNtService::SetPauseContinue(BOOL bAccepted)
{
    m_dwCtrlAccepted = (bAccepted) ? SERVICE_ACCEPT_PAUSE_CONTINUE : 0;
    if(m_bStarted)
    {
        if(!ReportStatusToSCMgr(
                    ssStatus.dwCurrentState,     // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT))        // wait hint
            Log(TEXT("Got error when trying to inform SCM about change in accept/pause"));
    }
}

//****************************************************************************
//
//  CNtService::Log
//
//  Dumps out an error message.  It is dumped to the event log when
//  running as a service and dumps it to stdio if running as an executable.
//  The result of a GetLastError() call is also output.
//
//  Parameters:
//      LPCTSTR lpszMsg                 Message to be added to log
//****************************************************************************

VOID CNtService::Log(LPCTSTR lpszMsg)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPCTSTR  lpszStrings[2];


    DWORD dwErr = GetLastError();
    wsprintf(szMsg, TEXT("%s error: %d"), m_pszServiceName, dwErr);
    if(m_bRunAsService)
    {
        // Dump the error code and text message out to the event log

        hEventSource = RegisterEventSource(NULL, m_pszServiceName);

        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL) {
            ReportEvent(hEventSource, // handle of event source
                EVENTLOG_ERROR_TYPE,  // event type
                0,                    // event category
                0,                    // event ID
                NULL,                 // current user's SID
                2,                    // strings in lpszStrings
                0,                    // no bytes of raw data
                lpszStrings,          // array of error strings
                NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        printf("\n %s %s",szMsg,lpszMsg);
    }
}

//****************************************************************************
//
//  CNtService::_ServiceMain
//  CNtService::_Handler
//
//  Entry points for calls from the NT service control manager.  These entry
//  points just call the actual functions using the default object.
//
//****************************************************************************

void WINAPI CNtService::_ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    pThis->ServiceMain(dwArgc, lpszArgv);
}

void WINAPI CNtService::_Handler(DWORD dwControlCode)
{
    pThis->Handler(dwControlCode);
}

//****************************************************************************
//
//  CNtService::ServiceMain
//
//  The ServiceMain for the service.  This is where services get started.
//
//  Parameters:
//      DWORD dwArgc                    Count of incoming arguments.
//      LPTSTR *lpszArgv                Array of pointers to args.
//****************************************************************************

void CNtService::ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // Register our service control handler.
    // =====================================

    sshStatusHandle = RegisterServiceCtrlHandler(m_pszServiceName, LPHANDLER_FUNCTION(_Handler));

    if (!sshStatusHandle)
    {
        Log(TEXT("Initial call to RegisterServiceCtrlHandler failed"));
        goto cleanup;
    }

    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;

    // Report the status to the service control manager.
    // =================================================

    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING,                // service state
        NO_ERROR,                             // exit code
        1,                                    // checkpoint
        DEFAULT_WAIT_HINT))                   // wait hint
        goto cleanup;

    if(m_bDieImmediately)
    {

        Log(TEXT("Service is immediatly terminating. Run was called with DieImmediately"));
        ReportStatusToSCMgr(
            SERVICE_STOPPED,                 // service state
            ERROR_GEN_FAILURE,                        // exit code
            0,                               // checkpoint
            0);                              // wait hint
        return;
    }

    if (!Initialize(dwArgc, lpszArgv))
    {
        Log(TEXT("Initialize call failed, bailing out"));
        goto cleanup;
    }


    // Report the status to the service control manager.
    // =================================================

    if (!ReportStatusToSCMgr(
        SERVICE_RUNNING,       // service state
        NO_ERROR,              // exit code
        0,                     // checkpoint
        0))                    // wait hint
            goto cleanup;

    m_bStarted = TRUE;

    // The next routine is always over ridden and is 
    // where the acutal work of the service is done.
    // =============================================

    WorkerThread();     

    // Service is done, send last report to SCM.
    // =========================================

cleanup:
    ReportStatusToSCMgr(
        SERVICE_STOPPED,                 // service state
        NO_ERROR,                        // exit code
        0,                               // checkpoint
        0);                              // wait hint

    return;
}

//****************************************************************************
//
//  CNtService::ReportStatusToSCMgr
//
//  Used by other member functions to report their status to the
//  service control manager.
//
//  Parameters:
//      DWORD dwCurrentState            One of the SERVICE_ codes.
//      DWORD dwWin32ExitCode           A Win32 Error code; usually 0.
//      DWORD dwCheckPoint              Checkpoint value (not used).
//      DWORD dwWaitHint                Milliseconds before Service Control
//                                      Manager gets worried.
//  Returns:
//
//      BOOL fResult                    Whatever code was returned
//                                      by SetServiceStatus().
//
//****************************************************************************

BOOL CNtService::ReportStatusToSCMgr(DWORD dwCurrentState,
    DWORD dwWin32ExitCode, DWORD dwCheckPoint, DWORD dwWaitHint)
{
    BOOL fResult;

    // Disable control requests until the service is started.
    // ======================================================

    if (dwCurrentState == SERVICE_START_PENDING)
        ssStatus.dwControlsAccepted = 0;
    else
        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN |
            m_dwCtrlAccepted;

    // These SERVICE_STATUS members are set from parameters.
    // =====================================================

    ssStatus.dwCurrentState  = dwCurrentState;
    ssStatus.dwWin32ExitCode = dwWin32ExitCode;
    ssStatus.dwCheckPoint    = dwCheckPoint;
    ssStatus.dwWaitHint      = dwWaitHint;

    // Report the status of the service to the service control manager.
    // ================================================================

    if (!(fResult = SetServiceStatus(
        sshStatusHandle,    // service reference handle
        &ssStatus)))
    {

        // If an error occurs, log it.
        // =====================================
        
        Log(TEXT("Could not SetServiceStatus"));

    }

    Sleep(250);     // Give SC Man a chance to read this

    return fResult;
}

//*****************************************************************************
//
//  CNtService::Handler
//
//  This handles incoming messages from the Service Controller.
//
//  Parameters:
//
//      DWORD dwControlCode             One of the SERVICE_CONTROL_
//                                      codes or a user defined code 125..255.
//
//*****************************************************************************

void CNtService::Handler(DWORD dwControlCode)
{
    switch(dwControlCode) {

        // Pause, set initial status, call overriden function and set final status
        //========================================================================

        case SERVICE_CONTROL_PAUSE:

            ReportStatusToSCMgr(
                    SERVICE_PAUSE_PENDING,     // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            Pause();
            ReportStatusToSCMgr(
                    SERVICE_PAUSED,            // current state
                    NO_ERROR,                  // exit code
                    0,                         // checkpoint
                    0);                        // wait hint    
            break;


        // Continue, set initial status, call overriden function and set final status
        //===========================================================================

        case SERVICE_CONTROL_CONTINUE:

            ReportStatusToSCMgr(
                    SERVICE_CONTINUE_PENDING,  // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);      // wait hint

            Continue(); 

            ReportStatusToSCMgr(
                    SERVICE_RUNNING,           // current state
                    NO_ERROR,                  // exit code
                    0,                         // checkpoint
                    0);                        // wait hint

            break;

        // Stop the service.  Note that the Stop function is supposed
        // to signal the worker thread which should return which then
        // causes the StartMain() function to end which sends the
        // final status!  
        //==========================================================

        case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:

            ReportStatusToSCMgr(
                    SERVICE_STOP_PENDING,      // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint

            Stop();
            break;

        // Could get an interrogate at any time, just report the current status.
        //======================================================================

        case SERVICE_CONTROL_INTERROGATE:
            ReportStatusToSCMgr(
                    ssStatus.dwCurrentState,   // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
            break;

        // Some user defined code.  Call the overriden function and report status.
        //========================================================================

        default:
            UserCode(dwControlCode);            // Invoke the user's function.
            ReportStatusToSCMgr(
                    ssStatus.dwCurrentState,   // current state
                    NO_ERROR,                  // exit code
                    1,                         // checkpoint
                    DEFAULT_WAIT_HINT);        // wait hint
    }
}

//*****************************************************************************
//
//  CNtService::IsRunningAsService
//
//  This handles incoming messages from the Service Controller.
//
//  Parameters:
//
//      BOOL &bIsService             Returns if it is a service of not
//
//  Returns:
//      DWORD       0 if successfully determined, Win32 error otherwise
//
//*****************************************************************************
DWORD CNtService::IsRunningAsService(BOOL &bIsService)
{    
    // reset flags
    BOOL isInteractive = FALSE;
    bIsService = FALSE;

    HANDLE hProcessToken = NULL;
    DWORD groupLength = 50;
    PTOKEN_GROUPS groupInfo = NULL;

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID pInteractiveSid = NULL;
    PSID pServiceSid = NULL;

    DWORD dwRet = NO_ERROR;

    DWORD ndx;

    // open the token
    if (!::OpenProcessToken(::GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        dwRet = ::GetLastError();
        goto closedown;
    }

    // allocate a buffer of default size
    groupInfo = (PTOKEN_GROUPS)::LocalAlloc(0, groupLength);
    if (groupInfo == NULL)
    {
        dwRet = ::GetLastError();
        goto closedown;
    }

    // try to get the info
    if (!::GetTokenInformation(hProcessToken, TokenGroups, groupInfo, groupLength, &groupLength))
    {
        // if buffer was too small, allocate to proper size, otherwise error
        if (::GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            dwRet = ::GetLastError();
            goto closedown;
        }

        ::LocalFree(groupInfo);

        groupInfo = (PTOKEN_GROUPS)::LocalAlloc(0, groupLength);
        if (groupInfo == NULL)
        {
            dwRet = ::GetLastError();
            goto closedown;
        }

        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo, groupLength, &groupLength)) 
        {
            dwRet = ::GetLastError();
            goto closedown;
        }
    }

    //
    //    We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //    The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //

    // create comparison sids
    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0, 0, 0, 0, 0, 0, &pInteractiveSid))
    {
        dwRet = ::GetLastError();
        goto closedown;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &pServiceSid))
    {
        dwRet = ::GetLastError();
        goto closedown;
    }

    // try to match sids
    for (ndx = 0; ndx < groupInfo->GroupCount ; ndx += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[ndx];
        PSID pSid = sanda.Sid;

        //
        //    Check to see if the group we're looking at is one of
        //    the two groups we're interested in.
        //

        if (::EqualSid(pSid, pInteractiveSid))
        {
            //
            //    This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  a console process
            //
            isInteractive = TRUE;
            bIsService = FALSE;
            break;
        }
        else if (::EqualSid(pSid, pServiceSid))
        {
            //
            //    This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account ( not local system ).
            //
            isInteractive = FALSE;
            bIsService = TRUE;
            break;
        }
    }

    if ( !(bIsService || isInteractive))
    {
        //
        //  Neither Interactive or Service was present in the current users token,
        //  This implies that the process is running as a service, most likely
        //  running as LocalSystem.
        //
        bIsService = TRUE;
    }


    closedown:
        if ( pServiceSid )
            ::FreeSid( pServiceSid );

        if ( pInteractiveSid )
            ::FreeSid( pInteractiveSid );

        if ( groupInfo )
            ::LocalFree( groupInfo );

        if ( hProcessToken )
            ::CloseHandle( hProcessToken );

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\proxy\wmishared.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVSTUB.H

Abstract:

  Master include file

History:

  a-davj  04-Mar-97   Created.

--*/

extern DWORD LOG;
#define TYPEQUAL L"CIMTYPE"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <time.h>
#include <wbemidl.h>        
#include <wbemcomn.h>
#include <transtrm.h>
#include <cominit.H>
#include <stubaddr.h>
#include <stbaddcm.h>
#include <linklist.h>
#include <winsock.h>
#include <comlink.h>
#include <secfilt.h>
#include <iopn.h>
#include <thrdpool.h>
#include <package.h>
#include <maintobj.h>
#include <utils.h>
#include <pipeopn.h>
#include <pipeprxo.h>
#include <cproxy.h>
#include "wbemprox.h"
#include <proxy.h>
#include "pipeprox.h"
#include "pipesnkp.h"
#include "locator.h"
#include <tranutil.h>
#include <genutils.h>
extern MaintObj gMaintObj;
extern CThrdPool gThrdPool;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\ntreg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    NTREG.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "winperf.h"

#include <stdio.h>
#include <wbemutil.h>
#include "ntreg.h"

CNTRegistry::CNTRegistry() : m_hPrimaryKey(0), 
                             m_hSubkey(0),
                             m_nStatus(0),
                             m_nLastError(no_error)
{
}

CNTRegistry::~CNTRegistry()
{
    if (m_hSubkey)
        RegCloseKey(m_hSubkey);
    if (m_hPrimaryKey != m_hSubkey)
        RegCloseKey(m_hPrimaryKey);
}

int CNTRegistry::Open(HKEY hStart, WCHAR *pszStartKey)
{
    int nStatus = no_error;

    m_nLastError = RegOpenKeyExW(hStart, pszStartKey,
                                    0, KEY_ALL_ACCESS, &m_hPrimaryKey );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    m_hSubkey = m_hPrimaryKey;

    return nStatus;
}

int CNTRegistry::MoveToSubkey(WCHAR *pszNewSubkey)
{
    int nStatus = no_error;

    m_nLastError = RegOpenKeyExW(m_hPrimaryKey, pszNewSubkey, 0, KEY_ALL_ACCESS, &m_hSubkey );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::DeleteValue(WCHAR *pwszValueName)
{
    int nStatus = no_error;

    m_nLastError = RegDeleteValueW(m_hSubkey, pwszValueName);

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue)
{
    int nStatus = no_error;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        {
            if (dwType != REG_DWORD)
                nStatus = failed;
            else
                nStatus = no_error; 
        }break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::GetStr(WCHAR *pwszValueName, WCHAR **pwszValue)
{
    *pwszValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if ( ( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ) )
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed due to an invalid registry data type.\n" ) );
        return failed;
    }

    WCHAR *p = new WCHAR[dwSize];

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
        WCHAR* wszTemp = NULL;

        // Get the initial length

        DWORD nSize = ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, 0 ) + 10;
        wszTemp = new WCHAR[ nSize ];
        ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, nSize - 1 );
        delete [] p;
        *pwszValue = wszTemp;
    }
    else
        *pwszValue = p;

    return no_error;
}

int CNTRegistry::GetBinary(WCHAR *pwszValueName, BYTE **ppBuffer)
{
    int nStatus = no_error;
    
    DWORD dwSize = 0;
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, 0, &dwSize );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    if ( no_error == nStatus )
    {
        if ( dwType != REG_BINARY )
        {
            nStatus = failed;
        }

        if ( no_error == nStatus )
        {
            BYTE* pBuffer = new BYTE[dwSize];

            m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, pBuffer, &dwSize );

            if ( ERROR_SUCCESS != m_nLastError )
            {
                delete [] pBuffer;
                nStatus = failed;
            }
            else
            {
                *ppBuffer = pBuffer;
            }
        }
    }

    return nStatus;
}

int CNTRegistry::Enum( DWORD dwIndex, WCHAR **pwszValue, DWORD& dwSize )
{
    DWORD   dwBuffSize = dwSize;

    m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
                                    NULL, NULL, NULL, NULL );

    while ( m_nLastError == ERROR_MORE_DATA )
    {
        // Grow in 256 byte chunks
        dwBuffSize += 256;

        try
        {
            // Reallocate the buffer and retry
            WCHAR*  p = new WCHAR[dwBuffSize];

            if ( NULL != *pwszValue )
            {
                delete *pwszValue;
            }

            *pwszValue = p;
            dwSize = dwBuffSize;

            m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, *pwszValue, &dwBuffSize,
                                            NULL, NULL, NULL, NULL );

        }
        catch (...)
        {
            ERRORTRACE( ( LOG_WMIADAP, "CNTRegistry::Enum() failed due to out of memory exception.\n" ) );
            return out_of_memory;
        }

    }

    if ( ERROR_SUCCESS != m_nLastError )
    {
        if ( ERROR_NO_MORE_ITEMS == m_nLastError )
        {
            return no_more_items;
        }
        else
        {
            return failed;
        }
    }

    return no_error;
}

int CNTRegistry::GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize)
{
    //Find out the size of the buffer required
    DWORD dwType;
    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, NULL, &dwSize);

    //If the error is an unexpected one bail out
    if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
    {
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if (dwSize == 0)
    {
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed due to null string.\n" ) );
        return failed;
    }

    //allocate the buffer required
    WCHAR *pData = new WCHAR[dwSize];
    
    //get the values
    m_nLastError = RegQueryValueExW(m_hSubkey, 
                                   pwszValueName, 
                                   0, 
                                   &dwType, 
                                   LPBYTE(pData), 
                                   &dwSize);

    //if an error bail out
    if (m_nLastError != 0)
    {
        delete [] pData;
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    *pwszValue = pData;

    return no_error;
}

int CNTRegistry::SetDWORD(WCHAR *pwszValueName, DWORD dwValue)
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, 
                                   pwszValueName,
                                   0,
                                   REG_DWORD,
                                   (BYTE*)&dwValue,
                                   sizeof( dwValue ) );

    if ( m_nLastError != ERROR_SUCCESS )
    {
        nStatus = failed;
    }

    return nStatus;
}

int CNTRegistry::SetStr(WCHAR *pwszValueName, WCHAR *wszValue)
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, 
                                   pwszValueName,
                                   0,
                                   REG_SZ,
                                   (BYTE*)wszValue,
                                   sizeof(WCHAR) * (wcslen(wszValue) + 1) );

    if ( m_nLastError != ERROR_SUCCESS )
    {
        nStatus = failed;
    }

    return nStatus;
}

int CNTRegistry::SetBinary(WCHAR *pwszValueName, BYTE* pBuffer, DWORD dwSize )
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, pwszValueName, 0, REG_BINARY, pBuffer, dwSize );

    if ( ERROR_SUCCESS != m_nLastError )
    {
        nStatus = failed;
    }

    return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\ntreg.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    NTREG.H

Abstract:

History:

--*/

#ifndef _NTREG_H_
#define _NTREG_H_
//#include "corepol.h"

class CNTRegistry
{
    HKEY    m_hPrimaryKey;
    HKEY    m_hSubkey;
    int     m_nStatus;
    LONG    m_nLastError;
   
public:
    enum { no_error, failed, out_of_memory, no_more_items, access_denied, not_found };
    
    CNTRegistry();
   ~CNTRegistry();

    int Open(HKEY hStart, WCHAR *pszStartKey);

    int MoveToSubkey(WCHAR *pszNewSubkey);

    int DeleteValue(WCHAR *pwszValueName);

    int GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue);
    int GetStr(WCHAR *pwszValueName, WCHAR **pwszValue);
    int GetBinary(WCHAR *pwszValueName, BYTE** ppBuffer);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    int GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize);

    // Allows key enumneration
    int Enum( DWORD dwIndex, WCHAR** pwszValue, DWORD& dwSize );

    int SetDWORD(WCHAR *pwszValueName, DWORD dwValue);
    int SetStr(WCHAR *pwszValueName, WCHAR *wszValue);
    int SetBinary(WCHAR *pwszValueName, BYTE* pBuffer, DWORD dwSize );

    LONG GetLastError() { return m_nLastError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\servutil.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.H

Abstract:

	Declares a set of general purpose service utilitils.

History:

  a-davj  04-Mar-97   Created.

--*/

#ifndef _SERVUTIL_H_
#define _SERVUTIL_H_

BOOL StopService(LPCTSTR pServiceName, DWORD dwMaxWait=0);
BOOL StartService(LPCTSTR pServiceName, DWORD dwMaxWait=0);
BOOL InstallService(LPCTSTR pServiceName,LPCTSTR pDisplayName, LPCTSTR pBinary);
BOOL RemoveService(LPCTSTR pServiceName);
BOOL SetDependency(LPCTSTR pServiceName, LPCTSTR pDependency);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\resync.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC.H

Abstract:

	Declares the various resync primitives.

History:

--*/

#ifndef _RESYNC_H_
#define _RESYNC_H_

typedef WINBASEAPI BOOL (WINAPI * PSETWAITABLETIMER)(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );

typedef WINBASEAPI HANDLE (WINAPI * PCREATEWAITABLETIMERW)(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCWSTR lpTimerName
    );

typedef struct 
{
	HANDLE				m_hTerminate;
	HANDLE				m_hWaitableTimer;
	CRITICAL_SECTION*	m_pcs;
	BOOL				m_fFullDredge;
}	RESYNCPERFDATASTRUCT;

void ResyncPerf( HANDLE hTerminate );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\sched.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SCHED.CPP

Abstract:

    Implements the CSched class which is a crude schedualer.

History:

--*/

#include "precomp.h"
#include "wbemidl.h"
#include "wbemint.h"
//#include "corepol.h"
#include "persistcfg.h"
#include "sched.h"

CSched::CSched()
{
    for(DWORD dwCnt = 0; dwCnt < EOL; dwCnt++)
        m_dwDue[dwCnt] = 0xffffffff;
}

void CSched::SetWorkItem(JobType jt, DWORD dwMsFromNow)
{
    m_dwDue[jt] = GetTickCount() + dwMsFromNow;
}

DWORD CSched::GetWaitPeriod()
{
    DWORD dwCurr = GetTickCount();
    DWORD dwRet = INFINITE;
    for(DWORD dwCnt = 0; dwCnt < EOL; dwCnt++)
    {
        if(m_dwDue[dwCnt] == 0xffffffff)
            continue;
        if(m_dwDue[dwCnt] < dwCurr)
            dwRet = 10;
        else
        {
            DWORD dwGap = m_dwDue[dwCnt] - dwCurr;
            if(dwGap < dwRet)
                dwRet = dwGap;
        }
    }
    return dwRet;
}

bool CSched::IsWorkItemDue(JobType jt)
{
    DWORD dwCurr = GetTickCount();
    if(m_dwDue[jt] == 0xffffffff)
        return FALSE;
    return (m_dwDue[jt] <= dwCurr);
}

void CSched::ClearWorkItem(JobType jt)
{
    m_dwDue[jt] = INFINITE;
}

void CSched::StartCoreIfEssNeeded()
{

    DWORD dwEssNeedsLoading = 0;
    DWORD dwBackupNeeded = 0;

    // Get the values from the configuration time

    CPersistentConfig per;
    per.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, dwEssNeedsLoading);
    per.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_NEEDSBACKUPCHECK, dwBackupNeeded);

    if(dwEssNeedsLoading || dwBackupNeeded)
    {
        IWbemLevel1Login * pCore = NULL;
        SCODE sc = CoCreateInstance(CLSID_InProcWbemLevel1Login, NULL, 
            CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IUnknown, 
            (void**)&pCore);
        if(sc == S_OK)
        {
            IWbemServices * pServ = NULL;
            sc = pCore->NTLMLogin(L"Root", NULL, 0, NULL, &pServ);
            if(SUCCEEDED(sc))
                pServ->Release();

            pCore->Release();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\resync.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC.CPP

Abstract:

    Implements the windows application or an NT service which
    loads up the various transport prtocols.

    If started with /exe argument, it will always run as an exe.
    If started with /kill argument, it will stop any running exes or services.
    If started with /? or /help dumps out information.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <tchar.h>

#include <wbemidl.h>
#include <reg.h>
#include <wbemutil.h>
#include <cntserv.h>
#include <cominit.h>
#include <sync.h>
#include "WinMgmt.h"
#include <wbemint.h>
#include <wbemprov.h>
#include <winntsec.h>
#include <winmgmtr.h>
#include <genutils.h>
#include "ntreg.h"
#include "process.h"
#include "resync.h"
#include <malloc.h>

// Timeout is a 64-bit value.  See documentation on SetWaitableTimer
// for why we are setting it this way.
#define             _SECOND     10000000
#define             RESYNC_TIMEOUT_INTERVAL 10 * _SECOND
#define             WMIADAP_DEFAULT_DELAY   10

BOOL                gfResyncInit = FALSE;
HANDLE              ghWaitableTimer = NULL;
BOOL                gfSpawnedResync = FALSE;
DWORD               gdwADAPDelaySec = 0;

HANDLE              ghResyncThreadHandle = NULL;
HANDLE              ghResyncThreadEvent = NULL;
CRITICAL_SECTION*   g_pResyncCs = NULL;
DWORD               gdwResyncThreadId = 0;

// A global handle used to store the last dredger we
// kicked off!
HANDLE              ghChildProcessHandle = NULL;

PCREATEWAITABLETIMERW   gpCreateWaitableTimerW = NULL;
PSETWAITABLETIMER       gpSetWaitableTimerW = NULL;
HINSTANCE               ghKernel32;

class CAutoFreeLib
{
public:
    ~CAutoFreeLib() { if ( NULL != ghKernel32 ) FreeLibrary( ghKernel32); }
};

void ResetResyncTimer( HANDLE hResyncTimer )
{
    DWORD dwErr = 0;
    __int64 qwDueTime  = gdwADAPDelaySec * _SECOND; // RESYNC_TIMEOUT_INTERVAL;

    // Convert it to relative time
    qwDueTime *= -1;

    // Copy the relative time into a LARGE_INTEGER.
    LARGE_INTEGER   li;

    li.LowPart  = (DWORD) ( qwDueTime & 0xFFFFFFFF );
    li.HighPart = (LONG)  ( qwDueTime >> 32 );

    if ( !gpSetWaitableTimerW( hResyncTimer, &li, 0, NULL, NULL, FALSE ) )
    {
        dwErr = GetLastError();
    }

}

// This thread controls the actual shelling of a resync perf operation
unsigned __stdcall ResyncPerfThread( void* pVoid )
{
    RESYNCPERFDATASTRUCT*   pResyncPerfData = (RESYNCPERFDATASTRUCT*) pVoid;

    // We get the two handles, copy them and wait on them
    // The first handle is the terminate event, the second is the
    // timer on which to spin off the resync

    HANDLE  aH